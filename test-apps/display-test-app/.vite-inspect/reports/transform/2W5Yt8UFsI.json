{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/FrameBuffer.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { GL } from \"./GL\";\nimport { RenderBuffer, RenderBufferMultiSample } from \"./RenderBuffer\";\nimport { System } from \"./System\";\nimport { TextureHandle } from \"./Texture\";\n/** @internal */\nexport class FrameBuffer {\n    get isDisposed() { return this._fbo === undefined; }\n    get isBound() { return 1 /* FrameBufferBindState.Bound */ <= this._bindState && 4 /* FrameBufferBindState.BoundWithAttachmentsMultisampled */ >= this._bindState; }\n    get isBoundMultisampled() { return 3 /* FrameBufferBindState.BoundMultisampled */ === this._bindState || 4 /* FrameBufferBindState.BoundWithAttachmentsMultisampled */ === this._bindState; }\n    get isSuspended() { return 5 /* FrameBufferBindState.Suspended */ === this._bindState; }\n    get isMultisampled() { return this._colorMsBuffers.length > 0 || undefined !== this.depthBufferMs; }\n    getColor(ndx) {\n        assert(ndx < this._colorTextures.length);\n        if (ndx < this._colorMsBuffers.length && this._colorMsBuffers[ndx].isDirty) {\n            this.blitMsBuffersToTextures(false, ndx);\n        }\n        return this._colorTextures[ndx];\n    }\n    getColorTargets(useMSBuffers, ndx) {\n        let msBuf;\n        if (useMSBuffers) {\n            assert(ndx < this._colorMsBuffers.length);\n            msBuf = this._colorMsBuffers[ndx];\n        }\n        assert(ndx < this._colorTextures.length);\n        return { tex: this._colorTextures[ndx], msBuf };\n    }\n    constructor(fbo, colorTextures, depthBuffer, colorMsBuffers, msFilters, depthBufferMs) {\n        this._bindState = 0 /* FrameBufferBindState.Unbound */;\n        this._colorTextures = [];\n        this._colorMsBuffers = [];\n        this._colorAttachments = [];\n        this._colorMsFilters = [];\n        this._fbo = fbo;\n        const gl = System.instance.context;\n        this.bind(false);\n        let i = 0;\n        for (const colTex of colorTextures) {\n            const attachmentEnum = gl.COLOR_ATTACHMENT0 + i;\n            this._colorAttachments.push(attachmentEnum);\n            this._colorTextures.push(colTex);\n            const texHandle = colTex.getHandle();\n            if (undefined !== texHandle)\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentEnum, gl.TEXTURE_2D, texHandle, 0);\n            i++;\n        }\n        if (depthBuffer !== undefined) {\n            this.depthBuffer = depthBuffer;\n            const dbHandle = depthBuffer.getHandle();\n            if (undefined !== dbHandle) {\n                if (depthBuffer instanceof RenderBuffer) {\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dbHandle);\n                }\n                else if (depthBuffer instanceof RenderBufferMultiSample) {\n                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, dbHandle);\n                }\n                else {\n                    // Looks like we only get a 24 bit depth buffer anyway, so use a 24-8 with a stencil.\n                    // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);\n                }\n            }\n        }\n        this.unbind();\n        if (undefined !== colorMsBuffers && colorMsBuffers.length === colorTextures.length && undefined !== msFilters && msFilters.length === colorMsBuffers.length) {\n            // Create a matching FBO with multisampling render buffers.\n            const fbo2 = System.instance.context.createFramebuffer();\n            if (null !== fbo2) {\n                this._fboMs = fbo2;\n                this.bind(false, true);\n                i = 0;\n                for (const colMsBuff of colorMsBuffers) {\n                    const attachmentEnum = gl.COLOR_ATTACHMENT0 + i;\n                    this._colorMsBuffers.push(colMsBuff);\n                    this._colorMsFilters.push(msFilters[i]);\n                    const msBuffHandle = colMsBuff.getHandle();\n                    if (undefined !== msBuffHandle)\n                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentEnum, gl.RENDERBUFFER, msBuffHandle);\n                    i++;\n                }\n                if (depthBufferMs !== undefined) {\n                    this.depthBufferMs = depthBufferMs;\n                    const dbHandleMs = depthBufferMs.getHandle();\n                    if (undefined !== dbHandleMs) {\n                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, dbHandleMs);\n                    }\n                }\n                this.unbind();\n            }\n        }\n    }\n    static create(colorTextures, depthBuffer, colorMsBuffers, msFilters, depthBufferMs) {\n        const fbo = System.instance.context.createFramebuffer();\n        if (null === fbo) {\n            return undefined;\n        }\n        return new FrameBuffer(fbo, colorTextures, depthBuffer, colorMsBuffers, msFilters, depthBufferMs);\n    }\n    dispose() {\n        // NB: The FrameBuffer does not *own* the textures and depth buffer.\n        if (!this.isDisposed) {\n            System.instance.context.deleteFramebuffer(this._fbo);\n            this._fbo = undefined;\n            if (undefined !== this._fboMs) {\n                System.instance.context.deleteFramebuffer(this._fboMs);\n                this._fboMs = undefined;\n            }\n        }\n    }\n    bind(bindAttachments = false, bindMS = false) {\n        assert(undefined !== this._fbo);\n        assert(!this.isBound);\n        if (undefined === this._fbo)\n            return false;\n        const gl = System.instance.context;\n        if (bindMS && undefined !== this._fboMs) {\n            gl.bindFramebuffer(GL.FrameBuffer.TARGET, this._fboMs);\n            this._bindState = 3 /* FrameBufferBindState.BoundMultisampled */;\n        }\n        else {\n            gl.bindFramebuffer(GL.FrameBuffer.TARGET, this._fbo);\n            this._bindState = 1 /* FrameBufferBindState.Bound */;\n        }\n        if (bindAttachments) {\n            System.instance.setDrawBuffers(this._colorAttachments);\n            this._bindState++;\n        }\n        return true;\n    }\n    unbind() {\n        assert(this.isBound);\n        System.instance.context.bindFramebuffer(GL.FrameBuffer.TARGET, null);\n        this._bindState = 0 /* FrameBufferBindState.Unbound */;\n    }\n    suspend() {\n        assert(this.isBound);\n        this._bindState = 5 /* FrameBufferBindState.Suspended */;\n    }\n    markTargetsDirty() {\n        for (const msBuff of this._colorMsBuffers) {\n            msBuff.markBufferDirty(true);\n        }\n        if (undefined !== this.depthBufferMs)\n            this.depthBufferMs.markBufferDirty(true);\n    }\n    /** blitDepth is true to blit the depth/stencil buffer. ndx is index of single attachment to blit.\n     * All color attachments are blitted if ndx is undefined, none are blitted if ndx is -1.\n     */\n    blitMsBuffersToTextures(blitDepth, ndx) {\n        if (!this._fboMs)\n            return;\n        System.instance.frameBufferStack.suspend();\n        const gl2 = System.instance.context;\n        const attachments = [];\n        const max = (undefined === ndx ? this._colorMsBuffers.length : ndx + 1);\n        for (let i = 0; i < max; ++i) {\n            if (undefined !== ndx && i < ndx) {\n                attachments.push(gl2.NONE); // skip this one, but first add a NONE for it in the attachment list\n                continue;\n            }\n            if (this._colorMsBuffers[i].isDirty) {\n                gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, this._fboMs);\n                gl2.readBuffer(this._colorAttachments[i]);\n                gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, this._fbo);\n                attachments.push(this._colorAttachments[i]);\n                gl2.drawBuffers(attachments);\n                attachments.pop();\n                attachments.push(gl2.NONE);\n                gl2.blitFramebuffer(0, 0, this._colorTextures[i].width, this._colorTextures[i].height, 0, 0, this._colorTextures[i].width, this._colorTextures[i].height, GL.BufferBit.Color, this._colorMsFilters[i]);\n                this._colorMsBuffers[i].markBufferDirty(false);\n                if (undefined !== ndx && i === ndx)\n                    break;\n            }\n        }\n        if (blitDepth && undefined !== this.depthBuffer && undefined !== this.depthBufferMs && this.depthBufferMs.isDirty) {\n            const mask = GL.BufferBit.Depth; // (this.depthBuffer instanceof RenderBuffer ? GL.BufferBit.Depth : GL.BufferBit.Depth | GL.BufferBit.Stencil);\n            gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, this._fboMs);\n            gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, this._fbo);\n            gl2.blitFramebuffer(0, 0, this.depthBuffer.width, this.depthBuffer.height, 0, 0, this.depthBuffer.width, this.depthBuffer.height, mask, GL.MultiSampling.Filter.Nearest);\n            this.depthBufferMs.markBufferDirty(false);\n        }\n        gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);\n        gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);\n        System.instance.frameBufferStack.resume();\n    }\n    /** invDepth is true to invalidate depth buffer. invStencil is true to invalidate stencil buffer. ndx is index of single color attachment to invalidate.\n     * All color attachments are invalidated if ndx is undefined, none are invalidated if ndx is -1.\n     * Set withMultiSampling to true to invalidate the MS buffers.\n     */\n    invalidate(invDepth, invStencil, withMultiSampling, indices) {\n        const gl = System.instance.context;\n        const attachments = invDepth ? (invStencil ? [gl.DEPTH_STENCIL_ATTACHMENT] : [System.instance.context.DEPTH_ATTACHMENT]) : (invDepth ? [gl.STENCIL_ATTACHMENT] : []);\n        if (undefined !== indices) {\n            if (indices.length > 0) {\n                for (const i of indices)\n                    attachments.push(gl.COLOR_ATTACHMENT0 + i);\n            }\n        }\n        else {\n            attachments.concat(this._colorAttachments);\n        }\n        System.instance.frameBufferStack.execute(this, true, withMultiSampling, () => {\n            System.instance.invalidateFrameBuffer(attachments);\n        });\n    }\n    // Chiefly for debugging currently - assumes RGBA, unsigned byte, want all pixels.\n    get debugPixels() {\n        if (!this.isBound || 0 === this._colorTextures.length || !(this._colorTextures[0] instanceof TextureHandle))\n            return undefined;\n        const tex = this._colorTextures[0];\n        if (GL.Texture.Format.Rgba !== tex.format || GL.Texture.DataType.UnsignedByte !== tex.dataType)\n            return undefined;\n        const buffer = new Uint8Array(tex.width * tex.height * 4);\n        for (let i = 0; i < buffer.length; i += 4) {\n            buffer[i] = 0xba;\n            buffer[i + 1] = 0xad;\n            buffer[i + 2] = 0xf0;\n            buffer[i + 3] = 0x0d;\n        }\n        System.instance.context.readPixels(0, 0, tex.width, tex.height, tex.format, tex.dataType, buffer);\n        return buffer;\n    }\n}\n/** @internal */\nexport class FrameBufferStack {\n    constructor() {\n        // FrameBuffers within this array are not owned, as this is only a storage device holding references\n        this._stack = [];\n    }\n    get _top() { return !this.isEmpty ? this._stack[this._stack.length - 1] : undefined; }\n    push(fbo, withAttachments, withMultSampling) {\n        if (undefined !== this._top) {\n            this._top.fbo.suspend();\n        }\n        assert(!fbo.isBound);\n        fbo.bind(withAttachments, withMultSampling);\n        assert(fbo.isBound);\n        this._stack.push({ fbo, withAttachments, withMultSampling });\n    }\n    pop() {\n        assert(!this.isEmpty);\n        if (undefined === this._top) {\n            return;\n        }\n        const fbo = this._top.fbo;\n        this._stack.pop();\n        assert(fbo.isBound);\n        fbo.unbind();\n        assert(!fbo.isBound);\n        if (this.isEmpty) {\n            System.instance.context.bindFramebuffer(GL.FrameBuffer.TARGET, null);\n        }\n        else {\n            const top = this._top;\n            assert(top.fbo.isSuspended);\n            top.fbo.bind(top.withAttachments, top.withMultSampling);\n            assert(top.fbo.isBound);\n        }\n    }\n    get currentColorBuffer() {\n        assert(!this.isEmpty);\n        return undefined !== this._top ? this._top.fbo.getColor(0) : undefined;\n    }\n    get currentFbMultisampled() {\n        return undefined !== this._top ? this._top.fbo.isBoundMultisampled : false;\n    }\n    get isEmpty() { return 0 === this._stack.length; }\n    execute(fbo, withAttachments, withMultSampling, func) {\n        this.push(fbo, withAttachments, withMultSampling);\n        func();\n        this.pop();\n    }\n    markTargetsDirty() {\n        const top = this._top;\n        if (undefined !== top)\n            top.fbo.markTargetsDirty();\n    }\n    suspend() {\n        if (undefined !== this._top) {\n            this._top.fbo.suspend();\n        }\n    }\n    resume() {\n        if (undefined === this._top) {\n            return;\n        }\n        if (this.isEmpty) {\n            System.instance.context.bindFramebuffer(GL.FrameBuffer.TARGET, null);\n        }\n        else {\n            const top = this._top;\n            top.fbo.bind(top.withAttachments, top.withMultSampling);\n            assert(top.fbo.isBound);\n        }\n    }\n}\n//# sourceMappingURL=FrameBuffer.js.map",
      "start": 1693508122183,
      "end": 1693508122347,
      "sourcemaps": null
    }
  ]
}
