{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/tile/GltfTileIO.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tile\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { TileFormat, TileHeader } from \"./TileIO\";\n/** Known version of the [glTF format](https://www.khronos.org/gltf/).\n * @internal\n */\nexport var GltfVersions;\n(function (GltfVersions) {\n    GltfVersions[GltfVersions[\"Version1\"] = 1] = \"Version1\";\n    GltfVersions[GltfVersions[\"Version2\"] = 2] = \"Version2\";\n    GltfVersions[GltfVersions[\"CurrentVersion\"] = 1] = \"CurrentVersion\";\n    GltfVersions[GltfVersions[\"Gltf1SceneFormat\"] = 0] = \"Gltf1SceneFormat\";\n})(GltfVersions || (GltfVersions = {}));\n/** @internal */\nexport var GltfV2ChunkTypes;\n(function (GltfV2ChunkTypes) {\n    GltfV2ChunkTypes[GltfV2ChunkTypes[\"JSON\"] = 1313821514] = \"JSON\";\n    GltfV2ChunkTypes[GltfV2ChunkTypes[\"Binary\"] = 5130562] = \"Binary\";\n})(GltfV2ChunkTypes || (GltfV2ChunkTypes = {}));\nfunction consumeNextChunk(stream) {\n    if (stream.isAtTheEnd)\n        return undefined;\n    const offset = stream.curPos + 8;\n    const length = stream.readUint32();\n    if (stream.isAtTheEnd)\n        return undefined;\n    const type = stream.readUint32();\n    stream.advance(length);\n    return stream.isPastTheEnd ? false : { offset, length, type };\n}\n/** @internal */\nexport class GlbHeader extends TileHeader {\n    get isValid() {\n        return TileFormat.Gltf === this.format;\n    }\n    constructor(stream) {\n        super(stream);\n        this.gltfLength = 0;\n        this.jsonChunk = { offset: 0, length: 0 };\n        this.additionalChunks = [];\n        this.gltfLength = stream.readUint32();\n        const jsonLength = stream.readUint32();\n        const word5 = stream.readUint32();\n        // Early versions of the reality data tile publisher incorrectly put version 2 into header - handle these old tiles\n        // validating the chunk type.\n        if (this.version === GltfVersions.Version2 && word5 === GltfVersions.Gltf1SceneFormat)\n            this.version = GltfVersions.Version1;\n        this.jsonChunk = { offset: stream.curPos, length: jsonLength };\n        switch (this.version) {\n            case GltfVersions.Version1:\n                if (GltfVersions.Gltf1SceneFormat !== word5) {\n                    this.invalidate();\n                    return;\n                }\n                const binaryOffset = stream.curPos + jsonLength;\n                this.binaryChunk = { offset: binaryOffset, length: this.gltfLength - binaryOffset };\n                break;\n            case GltfVersions.Version2:\n                if (word5 !== GltfV2ChunkTypes.JSON) {\n                    this.invalidate();\n                    return;\n                }\n                stream.advance(jsonLength);\n                if (stream.isPastTheEnd) {\n                    this.invalidate();\n                    return;\n                }\n                let chunk;\n                while (chunk = consumeNextChunk(stream)) {\n                    switch (chunk.type) {\n                        case GltfV2ChunkTypes.JSON:\n                            // Only one JSON chunk permitted and it must be the first.\n                            this.invalidate();\n                            return;\n                        case GltfV2ChunkTypes.Binary:\n                            // At most one binary chunk permitted and it must be the second if present.\n                            if (this.binaryChunk || this.additionalChunks.length) {\n                                this.invalidate();\n                                return;\n                            }\n                            this.binaryChunk = { offset: chunk.offset, length: chunk.length };\n                            break;\n                        default:\n                            // Any other chunk type should be ignored - for use by extensions.\n                            this.additionalChunks.push(chunk);\n                            break;\n                    }\n                }\n                if (false === chunk) {\n                    this.invalidate();\n                    return;\n                }\n                assert(undefined === chunk);\n                assert(stream.isAtTheEnd);\n                break;\n            default:\n                this.invalidate();\n                break;\n        }\n    }\n}\n//# sourceMappingURL=GltfTileIO.js.map",
      "start": 1693508121098,
      "end": 1693508121169,
      "sourcemaps": null
    }
  ]
}
