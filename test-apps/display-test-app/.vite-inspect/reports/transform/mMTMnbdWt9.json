{
  "resolvedId": "D:/hub2023A/itwinjs-core/editor/frontend/lib/esm/SolidPrimitiveTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Editing\n */\nimport { DialogProperty, PropertyDescriptionHelper } from \"@itwin/appui-abstract\";\nimport { BentleyError } from \"@itwin/core-bentley\";\nimport { Code, ColorDef, ElementGeometry, } from \"@itwin/core-common\";\nimport { AccuDrawHintBuilder, AngleDescription, GraphicType, IModelApp, LengthDescription, NotifyMessageDetails, OutputMessagePriority, } from \"@itwin/core-frontend\";\nimport { Angle, Arc3d, AxisOrder, Box, Cone, CurvePrimitive, FrameBuilder, Geometry, LinearSweep, LineSegment3d, LineString3d, Loop, Matrix3d, Path, Ray3d, RotationalSweep, Sphere, TorusPipe, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { editorBuiltInCmdIds } from \"@itwin/editor-common\";\nimport { CreateElementWithDynamicsTool } from \"./CreateElementTool\";\nimport { EditTools } from \"./EditTool\";\nimport { basicManipulationIpc } from \"./EditToolIpc\";\nimport { ModifyCurveTool } from \"./ModifyCurveTools\";\n/** @alpha Base class for creating a capped or uncapped SolidPrimitive. */\nexport class SolidPrimitiveTool extends CreateElementWithDynamicsTool {\n    constructor() {\n        super(...arguments);\n        this.accepted = [];\n    }\n    allowView(vp) { return vp.view.is3d(); }\n    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && this.allowView(vp)); }\n    async startCommand() {\n        if (undefined !== this._startedCmd)\n            return this._startedCmd;\n        return EditTools.startCommand({ commandId: editorBuiltInCmdIds.cmdBasicManipulation, iModelKey: this.iModel.key });\n    }\n    getPlacementProps() {\n        if (undefined === this.current)\n            return undefined;\n        const localToWorld = (\"solid\" === this.current.geometryCategory ? this.current.getConstructiveFrame() : FrameBuilder.createRightHandedFrame(this.baseRotation?.getColumn(2), this.current));\n        if (undefined === localToWorld)\n            return undefined;\n        const origin = localToWorld.getOrigin();\n        const angles = new YawPitchRollAngles();\n        YawPitchRollAngles.createFromMatrix3d(localToWorld.matrix, angles);\n        return { origin, angles };\n    }\n    getGeometryProps(placement) {\n        if (undefined === this.current)\n            return undefined;\n        const builder = new ElementGeometry.Builder();\n        builder.setLocalToWorldFromPlacement(placement);\n        if (!builder.appendGeometryQuery(this.current))\n            return;\n        return { format: \"flatbuffer\", data: builder.entries };\n    }\n    getElementProps(placement) {\n        const model = this.targetModelId;\n        const category = this.targetCategory;\n        return { classFullName: \"Generic:PhysicalObject\", model, category, code: Code.createEmpty(), placement };\n    }\n    async doCreateElement(props, data) {\n        try {\n            this._startedCmd = await this.startCommand();\n            await basicManipulationIpc.insertGeometricElement(props, data);\n            await this.saveChanges();\n        }\n        catch (err) {\n            IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, BentleyError.getErrorMessage(err) || \"An unknown error occurred.\"));\n        }\n    }\n}\n/** @alpha Creates a sphere. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateSphereTool extends SolidPrimitiveTool {\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        mainInstrText = EditTools.translate(0 === this.accepted.length ? \"CreateSphere.Prompts.CenterPoint\" : \"CreateSphere.Prompts.RadiusPoint\");\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModePolar();\n        hints.setOrigin(this.accepted[0]);\n        hints.setOriginFixed = true;\n        hints.sendHints();\n    }\n    get useRadiusProperty() {\n        if (!this._useRadiusProperty)\n            this._useRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useSphereRadius\"), false);\n        return this._useRadiusProperty;\n    }\n    get useRadius() { return this.useRadiusProperty.value; }\n    set useRadius(value) { this.useRadiusProperty.value = value; }\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"sphereRadius\", EditTools.translate(\"CreateSphere.Label.Radius\")), 0.1, undefined, !this.useRadius);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"sphereCapped\", EditTools.translate(\"CreateSphere.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    isComplete(_ev) {\n        return (2 === this.accepted.length);\n    }\n    async updateElementData(ev, isDynamics) {\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        if (0 === this.accepted.length) {\n            if (!isDynamics)\n                this.accepted.push(ev.point.clone());\n            return;\n        }\n        const vector0 = Vector3d.createStartEnd(this.accepted[0], ev.point);\n        const radius = (this.useRadius ? this.radius : vector0.magnitude());\n        if (!this.useRadius) {\n            this.radius = radius;\n            this.syncToolSettingPropertyValue(this.radiusProperty);\n        }\n        if (undefined === vector0.scaleToLength(radius, vector0)) {\n            this.current = undefined;\n            this.clearGraphics();\n            return;\n        }\n        this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n        const normal = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n        const vector90 = normal.crossProduct(vector0);\n        const matrix = Matrix3d.createColumns(vector0, vector90, normal);\n        this.baseRotation = Matrix3d.createRigidFromMatrix3d(matrix);\n        this.current = Sphere.createFromAxesAndScales(this.accepted[0], this.baseRotation, radius, radius, radius, undefined, this.capped);\n        if (isDynamics || undefined === this.current)\n            return;\n        this.accepted.push(ev.point.clone());\n    }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useRadiusProperty ? this.radiusProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.radiusProperty, this.useRadiusProperty, this.cappedProperty]);\n        const toolSettings = new Array();\n        this.radiusProperty.isDisabled = !this.useRadius;\n        const useRadiusLock = this.useRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useRadiusLock));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateSphereTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateSphereTool.toolId = \"CreateSphere\";\nCreateSphereTool.iconSpec = \"icon-circle\"; // TODO: Need better icon...\nexport { CreateSphereTool };\n/** @alpha Values for [[CreateCylinderTool.createPhase]. */\nexport var CreateCylinderPhase;\n(function (CreateCylinderPhase) {\n    /** Current tool phase to define center of base */\n    CreateCylinderPhase[CreateCylinderPhase[\"AcceptBase\"] = 0] = \"AcceptBase\";\n    /** Current tool phase to define radius or base axes */\n    CreateCylinderPhase[CreateCylinderPhase[\"AcceptRadius\"] = 1] = \"AcceptRadius\";\n    /** Current tool phase to define length or axis */\n    CreateCylinderPhase[CreateCylinderPhase[\"AcceptLength\"] = 2] = \"AcceptLength\";\n    /** Current tool phase to accept result */\n    CreateCylinderPhase[CreateCylinderPhase[\"AcceptResult\"] = 3] = \"AcceptResult\";\n})(CreateCylinderPhase || (CreateCylinderPhase = {}));\n/** @alpha Creates a cylinder. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateCylinderTool extends SolidPrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this.createPhase = CreateCylinderPhase.AcceptBase;\n    }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        switch (this.createPhase) {\n            case CreateCylinderPhase.AcceptBase:\n                mainInstrText = EditTools.translate(\"CreateCylinder.Prompts.BasePoint\");\n                break;\n            case CreateCylinderPhase.AcceptRadius:\n                mainInstrText = EditTools.translate(\"CreateCylinder.Prompts.RadiusPoint\");\n                break;\n            default:\n                mainInstrText = EditTools.translate(\"CreateCylinder.Prompts.LengthPoint\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModePolar();\n        hints.setOrigin(this.accepted[0]);\n        hints.setOriginFixed = true;\n        if (CreateCylinderPhase.AcceptLength === this.createPhase && undefined !== this.baseRotation) {\n            hints.setXAxis2(this.baseRotation.getColumn(2));\n            if (this.orthogonal) {\n                hints.setModeRectangular();\n                hints.setLockY = true;\n                hints.setLockZ = true;\n            }\n        }\n        hints.sendHints();\n    }\n    get useRadiusProperty() {\n        if (!this._useRadiusProperty)\n            this._useRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCylinderRadius\"), false);\n        return this._useRadiusProperty;\n    }\n    get useRadius() { return this.useRadiusProperty.value; }\n    set useRadius(value) { this.useRadiusProperty.value = value; }\n    get radiusProperty() {\n        if (!this._radiusProperty)\n            this._radiusProperty = new DialogProperty(new LengthDescription(\"cylinderRadius\", EditTools.translate(\"CreateCylinder.Label.Radius\")), 0.1, undefined, !this.useRadius);\n        return this._radiusProperty;\n    }\n    get radius() { return this.radiusProperty.value; }\n    set radius(value) { this.radiusProperty.value = value; }\n    get useLengthProperty() {\n        if (!this._useLengthProperty)\n            this._useLengthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useCylinderLength\"), false);\n        return this._useLengthProperty;\n    }\n    get useLength() { return this.useLengthProperty.value; }\n    set useLength(value) { this.useLengthProperty.value = value; }\n    get lengthProperty() {\n        if (!this._lengthProperty)\n            this._lengthProperty = new DialogProperty(new LengthDescription(\"cylinderLength\", EditTools.translate(\"CreateCylinder.Label.Length\")), 0.1, undefined, !this.useLength);\n        return this._lengthProperty;\n    }\n    get length() { return this.lengthProperty.value; }\n    set length(value) { this.lengthProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"cylinderCapped\", EditTools.translate(\"CreateCylinder.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    get orthogonalProperty() {\n        if (!this._orthogonalProperty)\n            this._orthogonalProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"cylinderOrthogonal\", EditTools.translate(\"CreateCylinder.Label.Orthogonal\")), true);\n        return this._orthogonalProperty;\n    }\n    get orthogonal() { return this.orthogonalProperty.value; }\n    set orthogonal(value) { this.orthogonalProperty.value = value; }\n    isComplete(_ev) {\n        return (CreateCylinderPhase.AcceptResult === this.createPhase);\n    }\n    async updateElementData(ev, isDynamics) {\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        const pt1 = (0 === this.accepted.length ? ev.point : this.accepted[0]);\n        const pt2 = ev.point;\n        switch (this.createPhase) {\n            case CreateCylinderPhase.AcceptBase: {\n                if (isDynamics)\n                    break;\n                // Allow creating cylinder by 2 points when orthogonal and radius are locked...\n                this.accepted.push(pt2.clone());\n                this.createPhase = (this.orthogonal && this.useRadius ? CreateCylinderPhase.AcceptLength : CreateCylinderPhase.AcceptRadius);\n                break;\n            }\n            case CreateCylinderPhase.AcceptRadius: {\n                this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const normal = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n                const vector0 = Vector3d.createStartEnd(pt1, pt2);\n                const vector90 = normal.crossProduct(vector0);\n                const radius = (this.useRadius ? this.radius : vector0.magnitude());\n                if (!this.useRadius) {\n                    this.radius = radius;\n                    this.syncToolSettingPropertyValue(this.radiusProperty);\n                }\n                if (undefined === vector0.scaleToLength(radius, vector0) || undefined === vector90.scaleToLength(radius, vector90)) {\n                    this.current = undefined;\n                    this.clearGraphics();\n                    return;\n                }\n                const arc = Arc3d.create(pt1, vector0, vector90);\n                this.baseRotation = Matrix3d.createRigidFromMatrix3d(arc.matrixRef); // Update base rotation from result arc...\n                this.current = (this.capped ? Loop.create(arc) : arc);\n                if (isDynamics)\n                    break;\n                this.createPhase = CreateCylinderPhase.AcceptLength;\n                break;\n            }\n            case CreateCylinderPhase.AcceptLength: {\n                const zAxis = Vector3d.createStartEnd(pt1, pt2);\n                const length = (this.useLength ? this.length : zAxis.magnitude());\n                if (!this.useLength) {\n                    this.length = length;\n                    this.syncToolSettingPropertyValue(this.lengthProperty);\n                }\n                // Establish base rotation when creating cylinder by 2 points...\n                if (undefined === this.baseRotation)\n                    this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const xAxis = this.baseRotation ? this.baseRotation.getColumn(0) : Vector3d.unitX();\n                const yAxis = this.baseRotation ? this.baseRotation.getColumn(1) : Vector3d.unitY();\n                if (undefined === zAxis.scaleToLength(length, zAxis)) {\n                    xAxis.scaleToLength(this.radius, xAxis);\n                    yAxis.scaleToLength(this.radius, yAxis);\n                    const baseArc = Arc3d.create(pt1, xAxis, yAxis);\n                    this.current = (this.capped ? Loop.create(baseArc) : baseArc);\n                    return;\n                }\n                if (this.orthogonal)\n                    this.current = Cone.createAxisPoints(pt1, pt1.plus(zAxis), this.radius, this.radius, this.capped);\n                else\n                    this.current = Cone.createBaseAndTarget(pt1, pt1.plus(zAxis), xAxis, yAxis, this.radius, this.radius, this.capped);\n                if (isDynamics || undefined === this.current)\n                    break;\n                this.createPhase = CreateCylinderPhase.AcceptResult;\n                break;\n            }\n        }\n    }\n    getToolSettingPropertyLocked(property) {\n        if (property === this.useRadiusProperty)\n            return this.radiusProperty;\n        else if (property === this.useLengthProperty)\n            return this.lengthProperty;\n        return undefined;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.radiusProperty, this.useRadiusProperty, this.lengthProperty, this.useLengthProperty, this.orthogonalProperty, this.cappedProperty]);\n        const toolSettings = new Array();\n        this.radiusProperty.isDisabled = !this.useRadius;\n        const useRadiusLock = this.useRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.radiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useRadiusLock));\n        this.lengthProperty.isDisabled = !this.useLength;\n        const useLengthLock = this.useLengthProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        toolSettings.push(this.lengthProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useLengthLock));\n        toolSettings.push(this.orthogonalProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateCylinderTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateCylinderTool.toolId = \"CreateCylinder\";\nCreateCylinderTool.iconSpec = \"icon-circle\"; // TODO: Need better icon...\nexport { CreateCylinderTool };\n/** @alpha Values for [[CreateConeTool.createPhase]. */\nexport var CreateConePhase;\n(function (CreateConePhase) {\n    /** Current tool phase to define center of base */\n    CreateConePhase[CreateConePhase[\"AcceptBase\"] = 0] = \"AcceptBase\";\n    /** Current tool phase to define base radius or base axes */\n    CreateConePhase[CreateConePhase[\"AcceptBaseRadius\"] = 1] = \"AcceptBaseRadius\";\n    /** Current tool phase to define length or axis */\n    CreateConePhase[CreateConePhase[\"AcceptLength\"] = 2] = \"AcceptLength\";\n    /** Current tool phase to define top radius */\n    CreateConePhase[CreateConePhase[\"AcceptTopRadius\"] = 3] = \"AcceptTopRadius\";\n    /** Current tool phase to accept result */\n    CreateConePhase[CreateConePhase[\"AcceptResult\"] = 4] = \"AcceptResult\";\n})(CreateConePhase || (CreateConePhase = {}));\n/** @alpha Creates a cone. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateConeTool extends SolidPrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this.createPhase = CreateConePhase.AcceptBase;\n    }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        switch (this.createPhase) {\n            case CreateConePhase.AcceptBase:\n                mainInstrText = EditTools.translate(\"CreateCone.Prompts.BasePoint\");\n                break;\n            case CreateConePhase.AcceptBaseRadius:\n                mainInstrText = EditTools.translate(\"CreateCone.Prompts.BaseRadiusPoint\");\n                break;\n            case CreateConePhase.AcceptTopRadius:\n                mainInstrText = EditTools.translate(\"CreateCone.Prompts.TopRadiusPoint\");\n                break;\n            default:\n                mainInstrText = EditTools.translate(\"CreateCone.Prompts.LengthPoint\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModePolar();\n        hints.setOrigin(this.accepted[0]);\n        hints.setOriginFixed = true;\n        if (CreateConePhase.AcceptTopRadius === this.createPhase && 2 === nPts) {\n            hints.setOrigin(this.accepted[1]);\n            if (undefined !== this.baseRotation)\n                hints.setMatrix(this.baseRotation);\n        }\n        else if (CreateConePhase.AcceptLength === this.createPhase && undefined !== this.baseRotation) {\n            hints.setXAxis2(this.baseRotation.getColumn(2));\n            if (this.orthogonal) {\n                hints.setModeRectangular();\n                hints.setLockY = true;\n                hints.setLockZ = true;\n            }\n        }\n        hints.sendHints();\n    }\n    get useBaseRadiusProperty() {\n        if (!this._useBaseRadiusProperty)\n            this._useBaseRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useConeBaseRadius\"), false);\n        return this._useBaseRadiusProperty;\n    }\n    get useBaseRadius() { return this.useBaseRadiusProperty.value; }\n    set useBaseRadius(value) { this.useBaseRadiusProperty.value = value; }\n    get baseRadiusProperty() {\n        if (!this._baseRadiusProperty)\n            this._baseRadiusProperty = new DialogProperty(new LengthDescription(\"coneBaseRadius\", EditTools.translate(\"CreateCone.Label.BaseRadius\")), 0.1, undefined, !this.useBaseRadius);\n        return this._baseRadiusProperty;\n    }\n    get baseRadius() { return this.baseRadiusProperty.value; }\n    set baseRadius(value) { this.baseRadiusProperty.value = value; }\n    get useTopRadiusProperty() {\n        if (!this._useTopRadiusProperty)\n            this._useTopRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useConeTopRadius\"), false);\n        return this._useTopRadiusProperty;\n    }\n    get useTopRadius() { return this.useTopRadiusProperty.value; }\n    set useTopRadius(value) { this.useTopRadiusProperty.value = value; }\n    get topRadiusProperty() {\n        if (!this._topRadiusProperty)\n            this._topRadiusProperty = new DialogProperty(new LengthDescription(\"coneTopRadius\", EditTools.translate(\"CreateCone.Label.TopRadius\")), 0.1, undefined, !this.useTopRadius);\n        return this._topRadiusProperty;\n    }\n    get topRadius() { return this.topRadiusProperty.value; }\n    set topRadius(value) { this.topRadiusProperty.value = value; }\n    get useLengthProperty() {\n        if (!this._useLengthProperty)\n            this._useLengthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useConeLength\"), false);\n        return this._useLengthProperty;\n    }\n    get useLength() { return this.useLengthProperty.value; }\n    set useLength(value) { this.useLengthProperty.value = value; }\n    get lengthProperty() {\n        if (!this._lengthProperty)\n            this._lengthProperty = new DialogProperty(new LengthDescription(\"coneLength\", EditTools.translate(\"CreateCone.Label.Length\")), 0.1, undefined, !this.useLength);\n        return this._lengthProperty;\n    }\n    get length() { return this.lengthProperty.value; }\n    set length(value) { this.lengthProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"coneCapped\", EditTools.translate(\"CreateCone.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    get orthogonalProperty() {\n        if (!this._orthogonalProperty)\n            this._orthogonalProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"coneOrthogonal\", EditTools.translate(\"CreateCone.Label.Orthogonal\")), true);\n        return this._orthogonalProperty;\n    }\n    get orthogonal() { return this.orthogonalProperty.value; }\n    set orthogonal(value) { this.orthogonalProperty.value = value; }\n    isComplete(_ev) {\n        return (CreateConePhase.AcceptResult === this.createPhase);\n    }\n    async updateElementData(ev, isDynamics) {\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        const pt1 = (0 === this.accepted.length ? ev.point : this.accepted[0]);\n        const pt2 = ev.point;\n        switch (this.createPhase) {\n            case CreateConePhase.AcceptBase: {\n                if (isDynamics)\n                    break;\n                // Allow creating cone by 2 points when orthogonal and base/top radii are locked...\n                this.accepted.push(pt2.clone());\n                this.createPhase = (this.orthogonal && this.useBaseRadius ? CreateConePhase.AcceptLength : CreateConePhase.AcceptBaseRadius);\n                break;\n            }\n            case CreateConePhase.AcceptBaseRadius: {\n                this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const normal = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n                const vector0 = Vector3d.createStartEnd(pt1, pt2);\n                const vector90 = normal.crossProduct(vector0);\n                const radius = (this.useBaseRadius ? this.baseRadius : vector0.magnitude());\n                if (!this.useBaseRadius) {\n                    this.baseRadius = radius;\n                    this.syncToolSettingPropertyValue(this.baseRadiusProperty);\n                }\n                if (undefined === vector0.scaleToLength(radius, vector0) || undefined === vector90.scaleToLength(radius, vector90)) {\n                    this.current = undefined;\n                    this.clearGraphics();\n                    return;\n                }\n                const arc = Arc3d.create(pt1, vector0, vector90);\n                this.baseRotation = Matrix3d.createRigidFromMatrix3d(arc.matrixRef); // Update base rotation from result arc...\n                this.current = (this.capped ? Loop.create(arc) : arc);\n                if (isDynamics)\n                    break;\n                this.createPhase = CreateConePhase.AcceptLength;\n                break;\n            }\n            case CreateConePhase.AcceptLength: {\n                const zAxis = Vector3d.createStartEnd(pt1, pt2);\n                const length = (this.useLength ? this.length : zAxis.magnitude());\n                if (!this.useLength) {\n                    this.length = length;\n                    this.syncToolSettingPropertyValue(this.lengthProperty);\n                }\n                // Establish base rotation when creating cone by 2 points...\n                if (undefined === this.baseRotation)\n                    this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const xAxis = this.baseRotation ? this.baseRotation.getColumn(0) : Vector3d.unitX();\n                const yAxis = this.baseRotation ? this.baseRotation.getColumn(1) : Vector3d.unitY();\n                if (undefined === zAxis.scaleToLength(length, zAxis)) {\n                    xAxis.scaleToLength(this.baseRadius, xAxis);\n                    yAxis.scaleToLength(this.baseRadius, yAxis);\n                    const baseArc = Arc3d.create(pt1, xAxis, yAxis);\n                    this.current = (this.capped ? Loop.create(baseArc) : baseArc);\n                    return;\n                }\n                if (this.orthogonal)\n                    this.current = Cone.createAxisPoints(pt1, pt1.plus(zAxis), this.baseRadius, this.useTopRadius ? this.topRadius : 0.0, this.capped);\n                else\n                    this.current = Cone.createBaseAndTarget(pt1, pt1.plus(zAxis), xAxis, yAxis, this.baseRadius, this.useTopRadius ? this.topRadius : 0.0, this.capped);\n                if (isDynamics || undefined === this.current)\n                    break;\n                const localToWorld = this.current.getConstructiveFrame();\n                if (undefined !== localToWorld)\n                    this.baseRotation = localToWorld.matrix; // Update base rotation from result for AccuDraw hints...\n                this.accepted.push(this.current.getCenterB()); // Add top center to accepted points for AccuDraw hints...\n                this.createPhase = this.useTopRadius ? CreateConePhase.AcceptResult : CreateConePhase.AcceptTopRadius;\n                break;\n            }\n            case CreateConePhase.AcceptTopRadius: {\n                const cone = (\"solid\" === this.current?.geometryCategory ? this.current : undefined);\n                if (undefined === cone)\n                    break;\n                const vector0 = Vector3d.createStartEnd(cone.getCenterB(), pt2);\n                const radius = (this.useTopRadius ? this.topRadius : vector0.magnitude());\n                if (!this.useTopRadius) {\n                    this.topRadius = radius;\n                    this.syncToolSettingPropertyValue(this.topRadiusProperty);\n                }\n                this.current = Cone.createBaseAndTarget(cone.getCenterA(), cone.getCenterB(), cone.getVectorX(), cone.getVectorY(), cone.getRadiusA(), radius, this.capped);\n                if (isDynamics)\n                    break;\n                this.createPhase = CreateConePhase.AcceptResult;\n                break;\n            }\n        }\n    }\n    getToolSettingPropertyLocked(property) {\n        if (property === this.useBaseRadiusProperty)\n            return this.baseRadiusProperty;\n        else if (property === this.useTopRadiusProperty)\n            return this.topRadiusProperty;\n        else if (property === this.useLengthProperty)\n            return this.lengthProperty;\n        return undefined;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.baseRadiusProperty, this.useBaseRadiusProperty, this.topRadiusProperty, this.useTopRadiusProperty, this.lengthProperty, this.useLengthProperty, this.orthogonalProperty, this.cappedProperty]);\n        const toolSettings = new Array();\n        this.baseRadiusProperty.isDisabled = !this.useBaseRadius;\n        const useBaseRadiusLock = this.useBaseRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.baseRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useBaseRadiusLock));\n        this.topRadiusProperty.isDisabled = !this.useTopRadius;\n        const useTopRadiusLock = this.useTopRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        toolSettings.push(this.topRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useTopRadiusLock));\n        this.lengthProperty.isDisabled = !this.useLength;\n        const useLengthLock = this.useLengthProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 });\n        toolSettings.push(this.lengthProperty.toDialogItem({ rowPriority: 3, columnIndex: 1 }, useLengthLock));\n        toolSettings.push(this.orthogonalProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 5, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateConeTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateConeTool.toolId = \"CreateCone\";\nCreateConeTool.iconSpec = \"icon-circle\"; // TODO: Need better icon...\nexport { CreateConeTool };\n/** @alpha Creates a bix. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateBoxTool extends SolidPrimitiveTool {\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        switch (this.accepted.length) {\n            case 0:\n                mainInstrText = EditTools.translate(\"CreateBox.Prompts.BasePoint\");\n                break;\n            case 1:\n                mainInstrText = EditTools.translate(\"CreateBox.Prompts.LengthPoint\");\n                break;\n            case 2:\n                mainInstrText = EditTools.translate(\"CreateBox.Prompts.WidthPoint\");\n                break;\n            default:\n                mainInstrText = EditTools.translate(\"CreateBox.Prompts.HeightPoint\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        hints.setModeRectangular();\n        hints.setOrigin(this.accepted[0]);\n        hints.setOriginFixed = true;\n        if (undefined !== this.baseRotation) {\n            if (2 === nPts) {\n                hints.setMatrix(this.baseRotation);\n                hints.setLockX = true;\n                hints.setLockZ = true;\n            }\n            else if (3 === nPts) {\n                hints.setXAxis2(this.baseRotation.getColumn(2));\n                if (this.orthogonal) {\n                    hints.setLockY = true;\n                    hints.setLockZ = true;\n                }\n            }\n        }\n        hints.sendHints();\n    }\n    get useLengthProperty() {\n        if (!this._useLengthProperty)\n            this._useLengthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useBoxLength\"), false);\n        return this._useLengthProperty;\n    }\n    get useLength() { return this.useLengthProperty.value; }\n    set useLength(value) { this.useLengthProperty.value = value; }\n    get lengthProperty() {\n        if (!this._lengthProperty)\n            this._lengthProperty = new DialogProperty(new LengthDescription(\"boxLength\", EditTools.translate(\"CreateBox.Label.Length\")), 0.1, undefined, !this.useLength);\n        return this._lengthProperty;\n    }\n    get length() { return this.lengthProperty.value; }\n    set length(value) { this.lengthProperty.value = value; }\n    get useWidthProperty() {\n        if (!this._useWidthProperty)\n            this._useWidthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useBoxWidth\"), false);\n        return this._useWidthProperty;\n    }\n    get useWidth() { return this.useWidthProperty.value; }\n    set useWidth(value) { this.useWidthProperty.value = value; }\n    get widthProperty() {\n        if (!this._widthProperty)\n            this._widthProperty = new DialogProperty(new LengthDescription(\"boxWidth\", EditTools.translate(\"CreateBox.Label.Width\")), 0.1, undefined, !this.useWidth);\n        return this._widthProperty;\n    }\n    get width() { return this.widthProperty.value; }\n    set width(value) { this.widthProperty.value = value; }\n    get useHeightProperty() {\n        if (!this._useHeightProperty)\n            this._useHeightProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useBoxHeight\"), false);\n        return this._useHeightProperty;\n    }\n    get useHeight() { return this.useHeightProperty.value; }\n    set useHeight(value) { this.useHeightProperty.value = value; }\n    get heightProperty() {\n        if (!this._heightProperty)\n            this._heightProperty = new DialogProperty(new LengthDescription(\"boxHeight\", EditTools.translate(\"CreateBox.Label.Height\")), 0.1, undefined, !this.useHeight);\n        return this._heightProperty;\n    }\n    get height() { return this.heightProperty.value; }\n    set height(value) { this.heightProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"boxCapped\", EditTools.translate(\"CreateBox.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    get orthogonalProperty() {\n        if (!this._orthogonalProperty)\n            this._orthogonalProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"boxOrthogonal\", EditTools.translate(\"CreateBox.Label.Orthogonal\")), true);\n        return this._orthogonalProperty;\n    }\n    get orthogonal() { return this.orthogonalProperty.value; }\n    set orthogonal(value) { this.orthogonalProperty.value = value; }\n    isComplete(_ev) {\n        return (4 === this.accepted.length);\n    }\n    async updateElementData(ev, isDynamics) {\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        switch (this.accepted.length) {\n            case 0: {\n                if (!isDynamics)\n                    this.accepted.push(ev.point.clone());\n                break;\n            }\n            case 1: {\n                const vector0 = Vector3d.createStartEnd(this.accepted[0], ev.point);\n                const length = (this.useLength ? this.length : vector0.magnitude());\n                if (!this.useLength) {\n                    this.length = length;\n                    this.syncToolSettingPropertyValue(this.lengthProperty);\n                }\n                if (undefined === vector0.scaleToLength(length, vector0)) {\n                    this.current = undefined;\n                    this.clearGraphics();\n                    return;\n                }\n                this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const normal = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n                const vector90 = normal.crossProduct(vector0);\n                const matrix = Matrix3d.createColumns(vector0, vector90, normal);\n                this.baseRotation = Matrix3d.createRigidFromMatrix3d(matrix);\n                this.current = LineSegment3d.create(this.accepted[0], this.accepted[0].plus(vector0));\n                if (isDynamics)\n                    return;\n                this.accepted.push(ev.point.clone());\n                break;\n            }\n            case 2: {\n                const vector90 = Vector3d.createStartEnd(this.accepted[0], ev.point);\n                const width = (this.useWidth ? this.width : vector90.magnitude());\n                if (!this.useWidth) {\n                    this.width = width;\n                    this.syncToolSettingPropertyValue(this.widthProperty);\n                }\n                const vector0 = this.baseRotation ? this.baseRotation.getColumn(0) : Vector3d.unitX();\n                const normal = vector90.crossProduct(vector0);\n                const matrix = Matrix3d.createColumns(vector0, vector90, normal);\n                if (undefined === vector90.scaleToLength(width, vector90) || undefined === Matrix3d.createRigidFromMatrix3d(matrix, undefined, matrix)) {\n                    this.current = LineSegment3d.create(this.accepted[0], this.accepted[0].plusScaled(vector0, this.length));\n                    return;\n                }\n                this.baseRotation = matrix; // Update base rotation from cross product...\n                const shapePts = [];\n                shapePts[0] = this.accepted[0].clone();\n                shapePts[1] = shapePts[0].plusScaled(this.baseRotation.getColumn(0), this.length);\n                shapePts[2] = shapePts[1].plusScaled(this.baseRotation.getColumn(1), width);\n                shapePts[3] = shapePts[0].plusScaled(this.baseRotation.getColumn(1), width);\n                shapePts[4] = shapePts[0].clone();\n                const base = LineString3d.create(shapePts);\n                this.current = (this.capped ? Loop.create(base) : base);\n                if (isDynamics)\n                    return;\n                this.accepted.push(ev.point.clone());\n                break;\n            }\n            default: {\n                if (undefined === this.baseRotation)\n                    return; // Should always have base rotation after width is defined...\n                const zAxis = Vector3d.createStartEnd(this.accepted[0], ev.point);\n                const height = (this.useHeight ? this.height : zAxis.magnitude());\n                if (!this.useHeight) {\n                    this.height = height;\n                    this.syncToolSettingPropertyValue(this.heightProperty);\n                }\n                if (undefined === zAxis.scaleToLength(height, zAxis)) {\n                    const shapePts = [];\n                    shapePts[0] = this.accepted[0].clone();\n                    shapePts[1] = shapePts[0].plusScaled(this.baseRotation.getColumn(0), this.length);\n                    shapePts[2] = shapePts[1].plusScaled(this.baseRotation.getColumn(1), this.width);\n                    shapePts[3] = shapePts[0].plusScaled(this.baseRotation.getColumn(1), this.width);\n                    shapePts[4] = shapePts[0].clone();\n                    const base = LineString3d.create(shapePts);\n                    this.current = (this.capped ? Loop.create(base) : base);\n                    return;\n                }\n                if (this.orthogonal) {\n                    const normal = this.baseRotation.getColumn(2);\n                    normal.scaleToLength(normal.dotProduct(zAxis) >= 0.0 ? height : -height, zAxis);\n                }\n                this.current = Box.createDgnBoxWithAxes(this.accepted[0], this.baseRotation, this.accepted[0].plus(zAxis), this.length, this.width, this.length, this.width, this.capped);\n                if (isDynamics || undefined === this.current)\n                    return;\n                this.accepted.push(ev.point.clone());\n                break;\n            }\n        }\n    }\n    getToolSettingPropertyLocked(property) {\n        if (property === this.useLengthProperty)\n            return this.lengthProperty;\n        else if (property === this.useWidthProperty)\n            return this.widthProperty;\n        else if (property === this.useHeightProperty)\n            return this.heightProperty;\n        return undefined;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.lengthProperty, this.useLengthProperty, this.widthProperty, this.useWidthProperty, this.heightProperty, this.useHeightProperty, this.orthogonalProperty, this.cappedProperty]);\n        const toolSettings = new Array();\n        this.lengthProperty.isDisabled = !this.useLength;\n        const useLengthLock = this.useLengthProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.lengthProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useLengthLock));\n        this.widthProperty.isDisabled = !this.useWidth;\n        const useWidthLock = this.useWidthProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        toolSettings.push(this.widthProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useWidthLock));\n        this.heightProperty.isDisabled = !this.useHeight;\n        const useHeightLock = this.useHeightProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 });\n        toolSettings.push(this.heightProperty.toDialogItem({ rowPriority: 3, columnIndex: 1 }, useHeightLock));\n        toolSettings.push(this.orthogonalProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 5, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateBoxTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateBoxTool.toolId = \"CreateBox\";\nCreateBoxTool.iconSpec = \"icon-circle\"; // TODO: Need better icon...\nexport { CreateBoxTool };\n/** @alpha Values for [[CreateTorusTool.createPhase]. */\nexport var CreateTorusPhase;\n(function (CreateTorusPhase) {\n    /** Current tool phase to define start point */\n    CreateTorusPhase[CreateTorusPhase[\"AcceptStart\"] = 0] = \"AcceptStart\";\n    /** Current tool phase to define center point */\n    CreateTorusPhase[CreateTorusPhase[\"AcceptCenter\"] = 1] = \"AcceptCenter\";\n    /** Current tool phase to define  secondary radius */\n    CreateTorusPhase[CreateTorusPhase[\"AcceptSecondaryRadius\"] = 2] = \"AcceptSecondaryRadius\";\n    /** Current tool phase to define sweep angle */\n    CreateTorusPhase[CreateTorusPhase[\"AcceptAngle\"] = 3] = \"AcceptAngle\";\n    /** Current tool phase to accept result */\n    CreateTorusPhase[CreateTorusPhase[\"AcceptResult\"] = 4] = \"AcceptResult\";\n})(CreateTorusPhase || (CreateTorusPhase = {}));\n/** @alpha Creates a torus pipe. Uses model and category from [[BriefcaseConnection.editorToolSettings]]. */\nclass CreateTorusTool extends SolidPrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this.createPhase = CreateTorusPhase.AcceptStart;\n    }\n    provideToolAssistance(mainInstrText, additionalInstr) {\n        switch (this.createPhase) {\n            case CreateTorusPhase.AcceptStart:\n                mainInstrText = EditTools.translate(\"CreateTorus.Prompts.StartPoint\");\n                break;\n            case CreateTorusPhase.AcceptCenter:\n                mainInstrText = EditTools.translate(\"CreateTorus.Prompts.CenterPoint\");\n                break;\n            case CreateTorusPhase.AcceptSecondaryRadius:\n                mainInstrText = EditTools.translate(\"CreateTorus.Prompts.SecondaryRadiusPoint\");\n                break;\n            default:\n                mainInstrText = EditTools.translate(\"CreateTorus.Prompts.AnglePoint\");\n                break;\n        }\n        super.provideToolAssistance(mainInstrText, additionalInstr);\n    }\n    setupAccuDraw() {\n        const nPts = this.accepted.length;\n        if (0 === nPts)\n            return;\n        const hints = new AccuDrawHintBuilder();\n        if (CreateTorusPhase.AcceptCenter === this.createPhase) {\n            hints.setOrigin(this.accepted[0]);\n        }\n        else if (CreateTorusPhase.AcceptSecondaryRadius === this.createPhase) {\n            hints.setModePolar();\n            hints.setOrigin(this.accepted[0]);\n            hints.setOriginFixed = true;\n            if (undefined !== this.baseRotation)\n                hints.setMatrix(Matrix3d.createColumns(this.baseRotation.getColumn(0), this.baseRotation.getColumn(2), this.baseRotation.getColumn(1)));\n        }\n        else if (CreateTorusPhase.AcceptAngle === this.createPhase && 2 === nPts) {\n            hints.setModePolar();\n            hints.setOrigin(this.accepted[1]);\n            hints.setOriginFixed = true;\n            if (undefined !== this.baseRotation)\n                hints.setMatrix(this.baseRotation);\n        }\n        hints.sendHints();\n    }\n    get usePrimaryRadiusProperty() {\n        if (!this._usePrimaryRadiusProperty)\n            this._usePrimaryRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useTorusPrimaryRadius\"), false);\n        return this._usePrimaryRadiusProperty;\n    }\n    get usePrimaryRadius() { return this.usePrimaryRadiusProperty.value; }\n    set usePrimaryRadius(value) { this.usePrimaryRadiusProperty.value = value; }\n    get primaryRadiusProperty() {\n        if (!this._primaryRadiusProperty)\n            this._primaryRadiusProperty = new DialogProperty(new LengthDescription(\"torusPrimaryRadius\", EditTools.translate(\"CreateTorus.Label.PrimaryRadius\")), 0.1, undefined, !this.usePrimaryRadius);\n        return this._primaryRadiusProperty;\n    }\n    get primaryRadius() { return this.primaryRadiusProperty.value; }\n    set primaryRadius(value) { this.primaryRadiusProperty.value = value; }\n    get useSecondaryRadiusProperty() {\n        if (!this._useSecondaryRadiusProperty)\n            this._useSecondaryRadiusProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useTorusSecondaryRadius\"), false);\n        return this._useSecondaryRadiusProperty;\n    }\n    get useSecondaryRadius() { return this.useSecondaryRadiusProperty.value; }\n    set useSecondaryRadius(value) { this.useSecondaryRadiusProperty.value = value; }\n    get secondaryRadiusProperty() {\n        if (!this._secondaryRadiusProperty)\n            this._secondaryRadiusProperty = new DialogProperty(new LengthDescription(\"torusSecondaryRadius\", EditTools.translate(\"CreateTorus.Label.SecondaryRadius\")), 0.05, undefined, !this.useSecondaryRadius);\n        return this._secondaryRadiusProperty;\n    }\n    get secondaryRadius() { return this.secondaryRadiusProperty.value; }\n    set secondaryRadius(value) { this.secondaryRadiusProperty.value = value; }\n    get useAngleProperty() {\n        if (!this._useAngleProperty)\n            this._useAngleProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useTorusAngle\"), false);\n        return this._useAngleProperty;\n    }\n    get useAngle() { return this.useAngleProperty.value; }\n    set useAngle(value) { this.useAngleProperty.value = value; }\n    get angleProperty() {\n        if (!this._angleProperty)\n            this._angleProperty = new DialogProperty(new AngleDescription(\"torusAngle\", EditTools.translate(\"CreateTorus.Label.Angle\")), Math.PI / 2.0, undefined, !this.useAngle);\n        return this._angleProperty;\n    }\n    get angle() { return this.angleProperty.value; }\n    set angle(value) { this.angleProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"torusCapped\", EditTools.translate(\"CreateTorus.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    isComplete(_ev) {\n        return (CreateTorusPhase.AcceptResult === this.createPhase);\n    }\n    async updateElementData(ev, isDynamics) {\n        const vp = this.targetView;\n        if (undefined === vp)\n            return;\n        switch (this.createPhase) {\n            case CreateTorusPhase.AcceptStart: {\n                if (isDynamics)\n                    break;\n                this.accepted.push(ev.point.clone());\n                this.createPhase = CreateTorusPhase.AcceptCenter;\n                break;\n            }\n            case CreateTorusPhase.AcceptCenter: {\n                this.baseRotation = AccuDrawHintBuilder.getCurrentRotation(vp, true, true);\n                const normal = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n                const vector0 = Vector3d.createStartEnd(ev.point, this.accepted[0]);\n                const vector90 = normal.crossProduct(vector0);\n                const primaryRadius = (this.usePrimaryRadius ? this.primaryRadius : vector0.magnitude());\n                if (!this.usePrimaryRadius) {\n                    this.primaryRadius = primaryRadius;\n                    this.syncToolSettingPropertyValue(this.primaryRadiusProperty);\n                }\n                if (undefined === vector0.scaleToLength(primaryRadius, vector0) || undefined === vector90.scaleToLength(primaryRadius, vector90)) {\n                    this.current = undefined;\n                    this.clearGraphics();\n                    return;\n                }\n                const center = this.accepted[0].plus(vector0.negate());\n                const allowComplete = (this.useSecondaryRadius && this.useAngle && (2 * Math.PI) === this.angle);\n                if (allowComplete) {\n                    vector0.normalizeInPlace();\n                    vector90.normalizeInPlace();\n                    this.current = TorusPipe.createDgnTorusPipe(center, vector0, vector90, primaryRadius, this.secondaryRadius, Angle.createRadians(this.angle), this.capped);\n                    if (undefined === this.current) {\n                        this.clearGraphics();\n                        break;\n                    }\n                    if (!isDynamics)\n                        this.createPhase = CreateTorusPhase.AcceptResult;\n                    break;\n                }\n                const arc = Arc3d.create(center, vector0, vector90);\n                this.baseRotation = Matrix3d.createRigidFromMatrix3d(arc.matrixRef); // Update base rotation from result arc...\n                this.current = arc;\n                if (isDynamics)\n                    break;\n                this.accepted.push(arc.center); // Add center to accepted points for AccuDraw hints...\n                this.createPhase = (this.useSecondaryRadius ? CreateTorusPhase.AcceptAngle : CreateTorusPhase.AcceptSecondaryRadius);\n                break;\n            }\n            case CreateTorusPhase.AcceptSecondaryRadius: {\n                const vector0 = Vector3d.createStartEnd(this.accepted[0], ev.point);\n                const secondaryRadius = (this.useSecondaryRadius ? this.secondaryRadius : Math.min(this.primaryRadius, vector0.magnitude()));\n                if (!this.useSecondaryRadius) {\n                    this.secondaryRadius = secondaryRadius;\n                    this.syncToolSettingPropertyValue(this.secondaryRadiusProperty);\n                }\n                const xAxis = this.baseRotation ? this.baseRotation.getColumn(0) : Vector3d.unitX();\n                const yAxis = this.baseRotation ? this.baseRotation.getColumn(1) : Vector3d.unitY();\n                if (undefined === vector0.scaleToLength(secondaryRadius, vector0)) {\n                    xAxis.scaleToLength(this.primaryRadius, xAxis);\n                    yAxis.scaleToLength(this.primaryRadius, yAxis);\n                    this.current = Arc3d.create(this.accepted[1], xAxis, yAxis);\n                    return;\n                }\n                const sweep = Angle.createRadians(this.useAngle ? this.angle : 2 * Math.PI);\n                this.current = TorusPipe.createDgnTorusPipe(this.accepted[1], xAxis, yAxis, this.primaryRadius, secondaryRadius, sweep, this.capped);\n                if (undefined === this.current) {\n                    this.clearGraphics();\n                    break;\n                }\n                if (!isDynamics)\n                    this.createPhase = ((this.useAngle && (2 * Math.PI) === this.angle) ? CreateTorusPhase.AcceptResult : CreateTorusPhase.AcceptAngle);\n                break;\n            }\n            case CreateTorusPhase.AcceptAngle: {\n                const vector90 = Vector3d.createStartEnd(this.accepted[1], ev.point);\n                const xAxis = this.baseRotation ? this.baseRotation.getColumn(0) : Vector3d.unitX();\n                const yAxis = this.baseRotation ? this.baseRotation.getColumn(1) : Vector3d.unitY();\n                const zAxis = this.baseRotation ? this.baseRotation.getColumn(2) : Vector3d.unitZ();\n                const prevSweep = Angle.createRadians(this.angle);\n                const sweep = xAxis.planarAngleTo(vector90, zAxis);\n                if (Math.abs(sweep.radians) < Angle.createDegrees(30.0).radians && prevSweep.isFullCircle && ((sweep.radians < 0.0 && prevSweep.radians > 0.0) || (sweep.radians > 0.0 && prevSweep.radians < 0.0)))\n                    prevSweep.setRadians(-prevSweep.radians); // Reverse direction...\n                if (sweep.isAlmostZero)\n                    sweep.setDegrees(prevSweep.radians < 0.0 ? -360.0 : 360.0); // Create full sweep...\n                if (this.useAngle) {\n                    if ((sweep.radians < 0.0 && this.angle > 0.0) || (sweep.radians > 0.0 && this.angle < 0.0))\n                        sweep.setRadians(-this.angle);\n                    else\n                        sweep.setRadians(this.angle);\n                }\n                else {\n                    if (sweep.radians < 0.0 && prevSweep.radians > 0.0)\n                        sweep.setRadians(Angle.pi2Radians + sweep.radians);\n                    else if (sweep.radians > 0.0 && prevSweep.radians < 0.0)\n                        sweep.setRadians(-(Angle.pi2Radians - sweep.radians));\n                    this.angle = sweep.radians;\n                    this.syncToolSettingPropertyValue(this.angleProperty);\n                }\n                this.current = TorusPipe.createDgnTorusPipe(this.accepted[1], xAxis, yAxis, this.primaryRadius, this.secondaryRadius, sweep, this.capped);\n                if (undefined === this.current) {\n                    this.clearGraphics();\n                    break;\n                }\n                if (!isDynamics)\n                    this.createPhase = CreateTorusPhase.AcceptResult;\n                break;\n            }\n        }\n    }\n    getToolSettingPropertyLocked(property) {\n        if (property === this.usePrimaryRadiusProperty)\n            return this.primaryRadiusProperty;\n        else if (property === this.useSecondaryRadiusProperty)\n            return this.secondaryRadiusProperty;\n        else if (property === this.useAngleProperty)\n            return this.angleProperty;\n        return undefined;\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.primaryRadiusProperty, this.usePrimaryRadiusProperty, this.secondaryRadiusProperty, this.useSecondaryRadiusProperty, this.angleProperty, this.useAngleProperty, this.cappedProperty]);\n        const toolSettings = new Array();\n        this.primaryRadiusProperty.isDisabled = !this.usePrimaryRadius;\n        const usePrimaryRadiusLock = this.usePrimaryRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.primaryRadiusProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, usePrimaryRadiusLock));\n        this.secondaryRadiusProperty.isDisabled = !this.useSecondaryRadius;\n        const useSecondaryRadiusLock = this.useSecondaryRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 });\n        toolSettings.push(this.secondaryRadiusProperty.toDialogItem({ rowPriority: 2, columnIndex: 1 }, useSecondaryRadiusLock));\n        this.angleProperty.isDisabled = !this.useAngle;\n        const useAngleLock = this.useAngleProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 });\n        toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 3, columnIndex: 1 }, useAngleLock));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        return toolSettings;\n    }\n    async onRestartTool() {\n        const tool = new CreateTorusTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nCreateTorusTool.toolId = \"CreateTorus\";\nCreateTorusTool.iconSpec = \"icon-circle\"; // TODO: Need better icon...\nexport { CreateTorusTool };\n/** @alpha Tool for extruding paths and regions. */\nclass ExtrudeCurveTool extends ModifyCurveTool {\n    allowView(vp) { return vp.view.is3d(); }\n    get useLengthProperty() {\n        if (!this._useLengthProperty)\n            this._useLengthProperty = new DialogProperty(PropertyDescriptionHelper.buildLockPropertyDescription(\"useExtrudeLength\"), false);\n        return this._useLengthProperty;\n    }\n    get useLength() { return this.useLengthProperty.value; }\n    set useLength(value) { this.useLengthProperty.value = value; }\n    get lengthProperty() {\n        if (!this._lengthProperty)\n            this._lengthProperty = new DialogProperty(new LengthDescription(\"extrudeLength\", EditTools.translate(\"ExtrudeCurve.Label.Length\")), 0.1, undefined, !this.useLength);\n        return this._lengthProperty;\n    }\n    get length() { return this.lengthProperty.value; }\n    set length(value) { this.lengthProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"extrudeCapped\", EditTools.translate(\"ExtrudeCurve.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    get orthogonalProperty() {\n        if (!this._orthogonalProperty)\n            this._orthogonalProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"extrudeOrthogonal\", EditTools.translate(\"ExtrudeCurve.Label.Orthogonal\")), true);\n        return this._orthogonalProperty;\n    }\n    get orthogonal() { return this.orthogonalProperty.value; }\n    set orthogonal(value) { this.orthogonalProperty.value = value; }\n    get keepProfileProperty() {\n        if (!this._keepProfileProperty)\n            this._keepProfileProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"extrudeKeepProfile\", EditTools.translate(\"ExtrudeCurve.Label.KeepProfile\")), false);\n        return this._keepProfileProperty;\n    }\n    get keepProfile() { return this.keepProfileProperty.value; }\n    set keepProfile(value) { this.keepProfileProperty.value = value; }\n    getToolSettingPropertyLocked(property) {\n        return (property === this.useLengthProperty ? this.lengthProperty : undefined);\n    }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.keepProfileProperty, this.orthogonalProperty, this.cappedProperty, this.useLengthProperty, this.lengthProperty]);\n        const toolSettings = new Array();\n        // ensure controls are enabled/disabled based on current lock property state\n        this.lengthProperty.isDisabled = !this.useLength;\n        const useLengthLock = this.useLengthProperty.toDialogItem({ rowPriority: 1, columnIndex: 0 });\n        toolSettings.push(this.lengthProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }, useLengthLock));\n        toolSettings.push(this.orthogonalProperty.toDialogItem({ rowPriority: 2, columnIndex: 0 }));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n        toolSettings.push(this.keepProfileProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        return toolSettings;\n    }\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return true;\n        switch (curve.curveCollectionType) {\n            case \"path\":\n            case \"loop\":\n            case \"parityRegion\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    modifyCurve(ev, isAccept) {\n        if (undefined === ev.viewport || undefined === this.anchorPoint)\n            return undefined;\n        const geom = this.curveData?.geom;\n        if (undefined === geom)\n            return undefined;\n        const matrix = AccuDrawHintBuilder.getCurrentRotation(ev.viewport, true, true);\n        const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n        if (undefined === localToWorld)\n            return undefined;\n        const spacePoint = this.orthogonal ? AccuDrawHintBuilder.projectPointToLineInView(ev.point, this.anchorPoint, localToWorld.matrix.getColumn(2), ev.viewport, true) : ev.point;\n        if (undefined === spacePoint)\n            return undefined;\n        const direction = Vector3d.createStartEnd(this.anchorPoint, spacePoint);\n        if (this.useLength && undefined === direction.scaleToLength(this.length, direction))\n            return undefined;\n        if (direction.magnitude() < Geometry.smallMetricDistance)\n            return undefined;\n        if (!this.useLength) {\n            this.length = direction.magnitude();\n            this.syncToolSettingPropertyValue(this.lengthProperty);\n            if (isAccept)\n                this.saveToolSettingPropertyValue(this.lengthProperty, this.lengthProperty.dialogItemValue);\n        }\n        const contour = (geom instanceof CurvePrimitive) ? Path.create(geom) : geom;\n        return LinearSweep.create(contour, direction, this.capped && contour.isAnyRegionType);\n    }\n    get wantModifyOriginal() {\n        return !this.keepProfile;\n    }\n    setupAccuDraw() {\n        const hints = new AccuDrawHintBuilder();\n        if (this.agenda.isEmpty) {\n            hints.enableSmartRotation = true;\n        }\n        else if (undefined !== this.anchorPoint && undefined !== this.targetView) {\n            const geom = this.curveData?.geom;\n            const matrix = AccuDrawHintBuilder.getCurrentRotation(this.targetView, true, true);\n            const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n            hints.setModeRectangular();\n            hints.setOrigin(this.anchorPoint);\n            hints.setOriginFixed = true;\n            if (undefined !== localToWorld) {\n                hints.setXAxis2(localToWorld.matrix.getColumn(2));\n                if (this.orthogonal) {\n                    hints.setLockY = true;\n                    hints.setLockZ = true;\n                }\n            }\n        }\n        hints.sendHints(false);\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (!this.agenda.isEmpty)\n            mainMsg = EditTools.translate(\"ExtrudeCurve.Prompts.DefineLength\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new ExtrudeCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nExtrudeCurveTool.toolId = \"ExtrudeCurve\";\nExtrudeCurveTool.iconSpec = \"icon-scale\"; // Need better icon...\nexport { ExtrudeCurveTool };\n/** @alpha Tool for revolving paths and regions. */\nclass RevolveCurveTool extends ModifyCurveTool {\n    constructor() {\n        super(...arguments);\n        this.points = [];\n    }\n    allowView(vp) { return vp.view.is3d(); }\n    get angleProperty() {\n        if (!this._angleProperty)\n            this._angleProperty = new DialogProperty(new AngleDescription(\"revolveAngle\", EditTools.translate(\"RevolveCurve.Label.Angle\")), Angle.piOver2Radians, undefined, false);\n        return this._angleProperty;\n    }\n    get angle() { return this.angleProperty.value; }\n    set angle(value) { this.angleProperty.value = value; }\n    get cappedProperty() {\n        if (!this._cappedProperty)\n            this._cappedProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"revolveCapped\", EditTools.translate(\"RevolveCurve.Label.Capped\")), true);\n        return this._cappedProperty;\n    }\n    get capped() { return this.cappedProperty.value; }\n    set capped(value) { this.cappedProperty.value = value; }\n    get keepProfileProperty() {\n        if (!this._keepProfileProperty)\n            this._keepProfileProperty = new DialogProperty(PropertyDescriptionHelper.buildToggleDescription(\"revolveKeepProfile\", EditTools.translate(\"RevolveCurve.Label.KeepProfile\")), false);\n        return this._keepProfileProperty;\n    }\n    get keepProfile() { return this.keepProfileProperty.value; }\n    set keepProfile(value) { this.keepProfileProperty.value = value; }\n    async applyToolSettingPropertyChange(updatedValue) {\n        return this.changeToolSettingPropertyValue(updatedValue);\n    }\n    supplyToolSettingsProperties() {\n        this.initializeToolSettingPropertyValues([this.keepProfileProperty, this.cappedProperty, this.angleProperty]);\n        const toolSettings = new Array();\n        toolSettings.push(this.angleProperty.toDialogItem({ rowPriority: 1, columnIndex: 1 }));\n        toolSettings.push(this.cappedProperty.toDialogItem({ rowPriority: 3, columnIndex: 0 }));\n        toolSettings.push(this.keepProfileProperty.toDialogItem({ rowPriority: 4, columnIndex: 0 }));\n        return toolSettings;\n    }\n    acceptCurve(curve) {\n        if (\"curvePrimitive\" === curve.geometryCategory)\n            return true;\n        switch (curve.curveCollectionType) {\n            case \"path\":\n            case \"loop\":\n            case \"parityRegion\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    modifyCurve(ev, isAccept) {\n        if (undefined === ev.viewport || this.points.length < (isAccept ? 2 : 1))\n            return undefined;\n        const geom = this.curveData?.geom;\n        if (undefined === geom)\n            return undefined;\n        const direction = Vector3d.createStartEnd(this.points[0], isAccept ? this.points[1] : ev.point);\n        if (direction.magnitude() < Geometry.smallMetricDistance)\n            return undefined;\n        const axis = Ray3d.create(this.points[0], direction);\n        const angle = Angle.createRadians(this.angle);\n        const contour = (geom instanceof CurvePrimitive) ? Path.create(geom) : geom;\n        const sweep = RotationalSweep.create(contour, axis, angle, this.capped && contour.isAnyRegionType);\n        // Detect a self-intersection...contour should not intersect axis of revolution...\n        const localToWorld = sweep?.getConstructiveFrame();\n        if (undefined === localToWorld)\n            return undefined;\n        const xVec = localToWorld.matrix.columnX(); // NOTE: Not always towards contour...\n        const xAxis = Ray3d.create(localToWorld.getOrigin(), xVec);\n        // Check parameter range of radial axis ray, if low is negative and high is positive reject result...\n        const paramRange = sweep?.getCurves().projectedParameterRange(xAxis);\n        if (undefined === paramRange || (paramRange.low < -Geometry.smallMetricDistanceSquared && paramRange.high > Geometry.smallMetricDistanceSquared))\n            return undefined;\n        return sweep;\n    }\n    onDynamicFrame(ev, context) {\n        if (0 === this.points.length)\n            return;\n        const pts = this.points.slice();\n        pts.push(ev.point.clone());\n        const builder = context.createGraphic({ type: GraphicType.WorldOverlay });\n        builder.setSymbology(context.viewport.getContrastToBackgroundColor(), ColorDef.black, 3);\n        builder.addLineString(pts);\n        context.addGraphic(builder.finish());\n        super.onDynamicFrame(ev, context);\n    }\n    get wantModifyOriginal() {\n        return !this.keepProfile;\n    }\n    get wantAdditionalInput() {\n        return this.points.length < 2;\n    }\n    async gatherInput(ev) {\n        if (undefined !== this.anchorPoint)\n            this.points.push(ev.point.clone());\n        return super.gatherInput(ev);\n    }\n    setupAccuDraw() {\n        const hints = new AccuDrawHintBuilder();\n        if (this.agenda.isEmpty) {\n            hints.enableSmartRotation = true;\n        }\n        else if (0 !== this.points.length) {\n            hints.setOrigin(this.points[0]);\n            hints.setOriginFixed = true;\n            hints.setLockZ = true;\n        }\n        else if (undefined !== this.anchorPoint && undefined !== this.targetView) {\n            const geom = this.curveData?.geom;\n            const closeDetail = (geom instanceof CurvePrimitive) ? geom.closestPoint(this.anchorPoint, false) : geom?.closestPoint(this.anchorPoint);\n            if (undefined === closeDetail?.curve)\n                return;\n            const unitX = closeDetail.curve.fractionToPointAndUnitTangent(closeDetail.fraction).direction;\n            if (undefined === unitX)\n                return;\n            const matrix = AccuDrawHintBuilder.getCurrentRotation(this.targetView, true, true);\n            const localToWorld = FrameBuilder.createRightHandedFrame(matrix?.getColumn(2), geom);\n            if (undefined === localToWorld)\n                return;\n            const unitZ = localToWorld.matrix.getColumn(2);\n            const frame = Matrix3d.createRigidFromColumns(unitX, unitZ, AxisOrder.XZY);\n            if (undefined === frame)\n                return;\n            hints.setModeRectangular();\n            hints.setOrigin(closeDetail.point);\n            hints.setMatrix(frame);\n        }\n        hints.sendHints(false);\n    }\n    provideToolAssistance(_mainInstrText, _additionalInstr) {\n        let mainMsg;\n        if (!this.agenda.isEmpty)\n            mainMsg = EditTools.translate(0 === this.points.length ? \"RevolveCurve.Prompts.AxisPoint\" : \"RevolveCurve.Prompts.AxisDirection\");\n        super.provideToolAssistance(mainMsg);\n    }\n    async onRestartTool() {\n        const tool = new RevolveCurveTool();\n        if (!await tool.run())\n            return this.exitTool();\n    }\n}\nRevolveCurveTool.toolId = \"RevolveCurve\";\nRevolveCurveTool.iconSpec = \"icon-scale\"; // Need better icon...\nexport { RevolveCurveTool };\n//# sourceMappingURL=SolidPrimitiveTools.js.map",
      "start": 1693508122947,
      "end": 1693508123096,
      "sourcemaps": null
    }
  ]
}
