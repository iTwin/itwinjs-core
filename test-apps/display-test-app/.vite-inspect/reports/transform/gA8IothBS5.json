{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Plane3dByOriginAndUnitNormal.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Plane3d } from \"./Plane3d\";\nimport { Matrix3d } from \"./Matrix3d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Transform } from \"./Transform\";\n/**\n * A plane defined by\n * * Any point on the plane.\n * * a unit normal.\n * @public\n */\nexport class Plane3dByOriginAndUnitNormal extends Plane3d {\n    // constructor captures references !!!\n    constructor(origin, normal) {\n        super();\n        this._origin = origin;\n        this._normal = normal;\n    }\n    // This is private because it does not check validity of the unit vector.\n    static _create(x, y, z, u, v, w) {\n        return new Plane3dByOriginAndUnitNormal(Point3d.create(x, y, z), Vector3d.create(u, v, w));\n    }\n    /**\n     * Create a plane parallel to the XY plane\n     * @param origin optional plane origin.  If omitted, the origin is placed at 000\n     */\n    static createXYPlane(origin) {\n        if (origin)\n            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);\n        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);\n    }\n    /**\n     * Create a plane parallel to the YZ plane\n     * @param origin optional plane origin.  If omitted, the origin is placed at 000\n     */\n    static createYZPlane(origin) {\n        if (origin)\n            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);\n        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);\n    }\n    /**\n     * Create a plane parallel to the ZX plane\n     * @param origin optional plane origin.  If omitted, the origin is placed at 000\n     */\n    static createZXPlane(origin) {\n        if (origin)\n            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);\n        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);\n    }\n    /**\n     * Create a new Plane3dByOriginAndUnitNormal with given origin and normal.\n     * * The inputs are NOT captured.\n     * * Returns undefined if `normal.normalize()` returns undefined.\n     */\n    static create(origin, normal, result) {\n        if (result) {\n            if (normal.normalize(result._normal) === undefined)\n                return undefined;\n            origin.clone(result._origin);\n            return result;\n        }\n        const normalized = normal.normalize();\n        if (normalized === undefined)\n            return undefined;\n        return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);\n    }\n    /**\n     * Create a new Plane3dByOriginAndUnitNormal from a variety of plane types.\n     * * The inputs are NOT captured.\n     * * Returns undefined if `source.getUnitNormal()` returns undefined.\n     */\n    static createFrom(source, result) {\n        if (source instanceof Plane3dByOriginAndUnitNormal)\n            return source.clone(result);\n        if (result) {\n            if (source.getUnitNormal(result._normal) === undefined)\n                return undefined;\n            source.getAnyPointOnPlane(result._origin);\n            return result;\n        }\n        const normal = source.getUnitNormal();\n        if (normal === undefined)\n            return undefined;\n        const origin = source.getAnyPointOnPlane();\n        return new Plane3dByOriginAndUnitNormal(origin, normal);\n    }\n    /**\n     * Create a new  Plane3dByOriginAndUnitNormal with direct coordinates of origin and normal.\n     * * Returns undefined if the normal vector is all zeros.\n     * * If unable to normalize return undefined. (And if result is given it is left unchanged)\n     */\n    static createXYZUVW(ax, ay, az, ux, uy, uz, result) {\n        const magU = Geometry.hypotenuseXYZ(ux, uy, uz);\n        if (magU < Geometry.smallMetricDistance)\n            return undefined;\n        if (result) {\n            result._origin.set(ax, ay, az);\n            result._normal.set(ux / magU, uy / magU, uz / magU);\n            return result;\n        }\n        return new Plane3dByOriginAndUnitNormal(Point3d.create(ax, ay, az), Vector3d.create(ux / magU, uy / magU, uz / magU));\n    }\n    /**\n     * Create a new  Plane3dByOriginAndUnitNormal with unit normal (a) in the xy plane (b) perpendicular to the line\n     * defined by xy parts of origin to target.\n     * * origin and normal both have z = 0.\n     * * The inputs are NOT captured.\n     * * Returns undefined if the normal vector is all zeros.\n     */\n    static createOriginAndTargetXY(origin, target, result) {\n        const ux = target.x - origin.x;\n        const uy = target.y - origin.y;\n        return this.createXYZUVW(origin.x, origin.y, 0.0, uy, -ux, 0.0, result);\n    }\n    /**\n     * Create a new  Plane3dByOriginAndUnitNormal with xy origin (at z=0) and normal angle in xy plane.\n     * * Returns undefined if the normal vector is all zeros.\n     */\n    static createXYAngle(x, y, normalAngleFromX, result) {\n        if (result) {\n            result._origin.set(x, y, 0.0);\n            result._normal.set(normalAngleFromX.cos(), normalAngleFromX.sin(), 0.0);\n            return result;\n        }\n        return new Plane3dByOriginAndUnitNormal(Point3d.create(x, y, 0), Vector3d.create(normalAngleFromX.cos(), normalAngleFromX.sin()));\n    }\n    /**\n     * Create a plane defined by two points and an in-plane vector.\n     * @param pointA any point in the plane\n     * @param pointB any other point in the plane\n     * @param vector any vector in the plane but not parallel to the vector from pointA to pointB\n     */\n    static createPointPointVectorInPlane(pointA, pointB, vector) {\n        const cross = vector.crossProductStartEnd(pointA, pointB);\n        if (cross.tryNormalizeInPlace())\n            return new Plane3dByOriginAndUnitNormal(pointA, cross);\n        return undefined;\n    }\n    /**\n     * Create a plane defined by three points.\n     * @param pointA any point in the plane.  This will be the origin.\n     * @param pointB any other point in the plane\n     * @param pointC any third point in the plane but not on the line of pointA and pointB\n     */\n    static createOriginAndTargets(pointA, pointB, pointC) {\n        const cross = pointA.crossProductToPoints(pointB, pointC);\n        if (cross.tryNormalizeInPlace())\n            return new Plane3dByOriginAndUnitNormal(pointA, cross);\n        return undefined;\n    }\n    /**\n     * Create a plane defined by a point and two vectors in the plane\n     * @param pointA any point in the plane\n     * @param vectorB any vector in the plane\n     * @param vectorC any vector in the plane but not parallel to vectorB\n     */\n    static createOriginAndVectors(pointA, vectorB, vectorC) {\n        const cross = vectorB.crossProduct(vectorC);\n        if (cross.tryNormalizeInPlace())\n            return new Plane3dByOriginAndUnitNormal(pointA, cross);\n        return undefined;\n    }\n    /** Test for (toleranced) equality with `other` */\n    isAlmostEqual(other) {\n        return this._origin.isAlmostEqual(other._origin) && this._normal.isAlmostEqual(other._normal);\n    }\n    /** Parse a json fragment `{origin: [x,y,z], normal: [ux,uy,uz]}`  */\n    setFromJSON(json) {\n        if (!json) {\n            this._origin.set(0, 0, 0);\n            this._normal.set(0, 0, 1);\n        }\n        else {\n            this._origin.setFromJSON(json.origin);\n            this._normal.setFromJSON(json.normal);\n        }\n    }\n    /**\n     * Convert to a JSON object.\n     * @return {*} [origin,normal]\n     */\n    toJSON() {\n        return { origin: this._origin.toJSON(), normal: this._normal.toJSON() };\n    }\n    /**\n     * Create a new Plane3dByOriginAndUnitNormal from json fragment.\n     * * See `Plane3dByOriginAndUnitNormal.setFromJSON`\n     */\n    static fromJSON(json) {\n        const result = Plane3dByOriginAndUnitNormal.createXYPlane();\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Return a reference to the origin. */\n    getOriginRef() {\n        return this._origin;\n    }\n    /** Return a reference to the unit normal. */\n    getNormalRef() {\n        return this._normal;\n    }\n    /**\n     * Return coordinate axes (as a transform) with\n     * * origin at plane origin\n     * * z axis in direction of plane normal.\n     * * x,y axes in plane.\n     */\n    getLocalToWorld() {\n        const axes = Matrix3d.createRigidHeadsUp(this._normal, AxisOrder.ZXY);\n        return Transform.createRefs(this._origin.clone(), axes);\n    }\n    /** Return a (singular) transform which projects points to this plane. */\n    getProjectionToPlane() {\n        const axes = Matrix3d.createIdentity();\n        axes.addScaledOuterProductInPlace(this._normal, this._normal, -1.0);\n        axes.markSingular();\n        return Transform.createFixedPointAndMatrix(this._origin, axes);\n    }\n    /** Copy coordinates from the given origin and normal. */\n    set(origin, normal) {\n        this._origin.setFrom(origin);\n        this._normal.setFrom(normal);\n    }\n    /** Return a deep clone (point and normal cloned) */\n    clone(result) {\n        if (result) {\n            result.set(this._origin, this._normal);\n            return result;\n        }\n        return new Plane3dByOriginAndUnitNormal(this._origin.clone(), this._normal.clone());\n    }\n    /** Create a clone and return the transform of the clone. */\n    cloneTransformed(transform, inverse = false) {\n        const result = this.clone();\n        if (inverse) {\n            transform.multiplyInversePoint3d(result._origin, result._origin);\n            if (transform.matrix.multiplyTransposeVector(result._normal, result._normal) !== undefined\n                && result._normal.normalizeInPlace())\n                return result;\n        }\n        else {\n            transform.multiplyPoint3d(result._origin, result._origin);\n            if (transform.matrix.multiplyInverseTranspose(result._normal, result._normal) !== undefined\n                && result._normal.normalizeInPlace())\n                return result;\n        }\n        return undefined;\n    }\n    /** Copy data from the given plane. */\n    setFrom(source) {\n        this.set(source._origin, source._normal);\n    }\n    /** Return the altitude of spacePoint above or below the plane.  (Below is negative) */\n    altitude(spacePoint) {\n        return this._normal.dotProductStartEnd(this._origin, spacePoint);\n    }\n    /** Return the altitude of point (x,y)  given xy parts using only the xy parts of origin and unit normal */\n    altitudeXY(x, y) {\n        return (x - this._origin.x) * this._normal.x + (y - this._origin.y) * this._normal.y;\n    }\n    /** Return the x component of the normal used to evaluate altitude. */\n    normalX() {\n        return this._normal.x;\n    }\n    /** Return the x component of the normal used to evaluate altitude. */\n    normalY() {\n        return this._normal.y;\n    }\n    /** Return the z component of the normal used to evaluate altitude. */\n    normalZ() {\n        return this._normal.z;\n    }\n    /** Return (a clone of) the unit normal. */\n    getUnitNormal(result) {\n        return this._normal.clone(result);\n    }\n    /** Return (a clone of) the origin. */\n    getAnyPointOnPlane(result) {\n        // This function returns the plane origin. In general, a point x is on the plane if and only if (x-o).n = 0.\n        return this._origin.clone(result);\n    }\n    /** Return the signed altitude of weighted spacePoint above or below the plane.  (Below is negative) */\n    weightedAltitude(spacePoint) {\n        return this._normal.dotProductStart3dEnd4d(this._origin, spacePoint);\n    }\n    /** Return any point at specified (signed) altitude. */\n    altitudeToPoint(altitude, result) {\n        return this._origin.plusScaled(this._normal, altitude, result);\n    }\n    /**\n     * Return the dot product of spaceVector with the plane's unit normal. This tells the rate of change of altitude\n     * for a point moving at speed one along the spaceVector.\n     */\n    velocityXYZ(x, y, z) {\n        return this._normal.dotProductXYZ(x, y, z);\n    }\n    /**\n     * Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude\n     * for a point moving at speed one along the spaceVector.\n     */\n    velocity(spaceVector) {\n        return this._normal.dotProduct(spaceVector);\n    }\n    /** Return the altitude of a point given as separate x,y,z components. */\n    altitudeXYZ(x, y, z) {\n        return this._normal.dotProductStartEndXYZ(this._origin, x, y, z);\n    }\n    /** Return the altitude of a point given as separate x,y,z,w components. */\n    altitudeXYZW(x, y, z, w) {\n        return this._normal.dotProductStartEndXYZW(this._origin, x, y, z, w);\n    }\n    /** Return the projection of spacePoint onto the plane. */\n    projectPointToPlane(spacePoint, result) {\n        return spacePoint.plusScaled(this._normal, -this._normal.dotProductStartEnd(this._origin, spacePoint), result);\n    }\n    /**\n     * Returns true if spacePoint is within distance tolerance of the plane.\n     * * This logic is identical to the [[Plane3d]] method but avoids a level of function call.\n     */\n    isPointInPlane(spacePoint, tolerance = Geometry.smallMetricDistance) {\n        const altitude = this._normal.dotProductStartEnd(this._origin, spacePoint);\n        return Math.abs(altitude) <= tolerance;\n    }\n}\n//# sourceMappingURL=Plane3dByOriginAndUnitNormal.js.map",
      "start": 1693508123180,
      "end": 1693508123334,
      "sourcemaps": null
    }
  ]
}
