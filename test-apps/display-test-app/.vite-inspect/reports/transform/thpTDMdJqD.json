{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/ParityRegion.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { CurveCollection } from \"./CurveCollection\";\nimport { Loop } from \"./Loop\";\n/**\n * * A `ParityRegion` is a collection of `Loop` objects.\n * * The loops collectively define a planar region.\n * * A point is \"in\" the composite region if it is \"in\" an odd number of the loops.\n * @see [Curve Collections]($docs/learning/geometry/CurveCollection.md) learning article.\n * @public\n */\nexport class ParityRegion extends CurveCollection {\n    /** Test if `other` is an instance of `ParityRegion` */\n    isSameGeometryClass(other) {\n        return other instanceof ParityRegion;\n    }\n    /** Return the array of loops in this parity region. */\n    get children() {\n        return this._children;\n    }\n    /** Construct parity region with empty loop array */\n    constructor() {\n        super();\n        /** String name for schema properties */\n        this.curveCollectionType = \"parityRegion\";\n        this._children = [];\n    }\n    /** Add loops (recursively) to this region's children */\n    addLoops(data) {\n        if (data === undefined) {\n        }\n        else if (data instanceof Loop)\n            this.children.push(data);\n        else if (Array.isArray(data)) {\n            for (const child of data) {\n                if (child instanceof Loop)\n                    this.children.push(child);\n                else if (Array.isArray(child))\n                    this.addLoops(child);\n            }\n        }\n    }\n    /**\n     * Return a single loop or parity region with given loops.\n     * * The returned structure CAPTURES the loops.\n     * * The loops are NOT reorganized by hole analysis.\n     */\n    static createLoops(data) {\n        if (data instanceof Loop)\n            return data;\n        const result = new ParityRegion();\n        result.addLoops(data);\n        return result;\n    }\n    /** Create a parity region with given loops */\n    static create(...data) {\n        const result = new ParityRegion();\n        for (const child of data) {\n            result.children.push(child);\n        }\n        return result;\n    }\n    /** Return the boundary type (4) of a corresponding  MicroStation CurveVector */\n    dgnBoundaryType() {\n        return 4;\n    }\n    /** Invoke `processor.announceParityRegion(this, indexInParent)` */\n    announceToCurveProcessor(processor, indexInParent = -1) {\n        return processor.announceParityRegion(this, indexInParent);\n    }\n    /** Return a deep copy. */\n    clone() {\n        const clone = new ParityRegion();\n        let child;\n        for (child of this.children) {\n            const childClone = child.clone();\n            if (childClone instanceof Loop)\n                clone.children.push(childClone);\n        }\n        return clone;\n    }\n    /** Stroke these curves into a new ParityRegion. */\n    cloneStroked(options) {\n        const clone = new ParityRegion();\n        let child;\n        for (child of this.children) {\n            const childStrokes = child.cloneStroked(options);\n            if (childStrokes)\n                clone.children.push(childStrokes);\n        }\n        return clone;\n    }\n    /** Create a new empty parity region. */\n    cloneEmptyPeer() {\n        return new ParityRegion();\n    }\n    /**\n     * Add `child` to this parity region.\n     * * Any child type other than `Loop` is ignored.\n     */\n    tryAddChild(child) {\n        if (child && child instanceof Loop) {\n            this._children.push(child);\n            return true;\n        }\n        return false;\n    }\n    /** Get child `i` by index. */\n    getChild(i) {\n        if (i < this._children.length)\n            return this._children[i];\n        return undefined;\n    }\n    /** Second step of double dispatch:  call `handler.handleRegion(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleParityRegion(this);\n    }\n}\n//# sourceMappingURL=ParityRegion.js.map",
      "start": 1693508123667,
      "end": 1693508123806,
      "sourcemaps": null
    }
  ]
}
