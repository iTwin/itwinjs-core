{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/TextEdit.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupTools\n */\nimport { CoreTools, EventHandled, IModelApp, InputSource, ToolAssistance, ToolAssistanceImage, ToolAssistanceInputMethod, } from \"@itwin/core-frontend\";\nimport { G, Text as MarkupText } from \"@svgdotjs/svg.js\";\nimport { MarkupApp } from \"./Markup\";\nimport { MarkupTool } from \"./MarkupTool\";\nimport { RedlineTool } from \"./RedlineTool\";\n// cspell:ignore rbox\n/** Tool to place new text notes on a Markup.\n * @public\n */\nclass PlaceTextTool extends RedlineTool {\n    constructor() {\n        super(...arguments);\n        this._nRequiredPoints = 1;\n        this._minPoints = 0;\n    }\n    async onPostInstall() {\n        this._value = MarkupApp.props.text.startValue; // so applications can put a default string (e.g. user's initials) in the note. Can be empty\n        return super.onPostInstall();\n    }\n    showPrompt() { this.provideToolAssistance(`${MarkupTool.toolKey}Text.Place.Prompts.FirstPoint`, true); }\n    async createMarkup(svg, ev, isDynamics) {\n        if (isDynamics && InputSource.Touch === ev.inputSource)\n            return;\n        const start = MarkupApp.convertVpToVb(ev.viewPoint); // starting point in viewbox coordinates\n        const text = new MarkupText().plain(this._value); // create a plain text element\n        svg.put(text); // add it to the supplied container\n        this.setCurrentTextStyle(text); // apply active text style\n        text.translate(start.x, start.y); // and position it relative to the cursor\n        if (isDynamics) {\n            svg.add(text.getOutline().attr(MarkupApp.props.text.edit.textBox).addClass(MarkupApp.textOutlineClass)); // in dynamics, draw the box around the text\n        }\n        else {\n            await new EditTextTool(text, true).run(); // text is now positioned, open text editor\n        }\n    }\n    async onResetButtonUp(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n}\nPlaceTextTool.toolId = \"Markup.Text.Place\";\nPlaceTextTool.iconSpec = \"icon-text-medium\";\nexport { PlaceTextTool };\n/** Tool for editing text. Started automatically by the place text tool and by clicking on text from the SelectTool\n * @public\n */\nclass EditTextTool extends MarkupTool {\n    constructor(text, _fromPlaceTool = false) {\n        super();\n        this.text = text;\n        this._fromPlaceTool = _fromPlaceTool;\n    }\n    showPrompt() {\n        const mainInstruction = ToolAssistance.createInstruction(this.iconSpec, IModelApp.localization.getLocalizedString(`${MarkupTool.toolKey}Text.Edit.Prompts.FirstPoint`));\n        const mouseInstructions = [];\n        const touchInstructions = [];\n        const acceptMsg = CoreTools.translate(\"ElementSet.Inputs.Accept\");\n        const rejectMsg = CoreTools.translate(\"ElementSet.Inputs.Exit\");\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.OneTouchTap, acceptMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.LeftClick, acceptMsg, false, ToolAssistanceInputMethod.Mouse));\n        touchInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.TwoTouchTap, rejectMsg, false, ToolAssistanceInputMethod.Touch));\n        mouseInstructions.push(ToolAssistance.createInstruction(ToolAssistanceImage.RightClick, rejectMsg, false, ToolAssistanceInputMethod.Mouse));\n        const sections = [];\n        sections.push(ToolAssistance.createSection(mouseInstructions, ToolAssistance.inputsLabel));\n        sections.push(ToolAssistance.createSection(touchInstructions, ToolAssistance.inputsLabel));\n        const instructions = ToolAssistance.createInstructions(mainInstruction, sections);\n        IModelApp.notifications.setToolAssistance(instructions);\n    }\n    /** Open the text editor  */\n    startEditor() {\n        let text = this.text;\n        if (text === undefined)\n            return;\n        if (text instanceof G) {\n            this.boxed = text;\n            text = text.children()[1];\n            if (!(text instanceof MarkupText))\n                return;\n            this.text = text;\n        }\n        const markupDiv = this.markup.markupDiv;\n        const editDiv = this.editDiv = document.createElement(\"div\"); // create a new DIV to hold the text editor\n        const editProps = MarkupApp.props.text.edit;\n        let style = editDiv.style;\n        style.backgroundColor = editProps.background;\n        style.top = style.left = \"0\";\n        style.right = style.bottom = \"100%\";\n        markupDiv.appendChild(editDiv); // add textEditor div to markup div\n        const divRect = markupDiv.getBoundingClientRect();\n        const outline = text.getOutline(); // use the outline rather than the text in case it's blank.\n        text.after(outline); // we have to add it to the DOM or the rbox call doesn't work.\n        const rbox = outline.rbox();\n        const bbox = outline.bbox();\n        outline.remove(); // take it out again.\n        const editor = this.editor = document.createElement(\"textarea\");\n        editDiv.appendChild(editor);\n        editor.className = MarkupApp.textEditorClass;\n        editor.contentEditable = \"true\";\n        editor.spellcheck = true;\n        editor.wrap = \"off\";\n        // so we don't send these events to the ToolAdmin and process them by tools. We want default handling\n        const mouseListener = (ev) => (ev.stopPropagation(), true);\n        editor.onselectstart = editor.oncontextmenu = editor.onmousedown = editor.onmouseup = mouseListener; // enable default handling for these events\n        // Tab, Escape, ctrl-enter, or shift-enter all end the editor\n        editor.onkeydown = async (ev) => {\n            if (ev.key === \"Tab\" || ev.key === \"Escape\" || (ev.key === \"Enter\" && (ev.shiftKey || ev.ctrlKey)))\n                this.exitTool(); // eslint-disable-line @typescript-eslint/no-floating-promises\n            ev.stopPropagation();\n        };\n        const textElStyle = window.getComputedStyle(text.node);\n        style = editor.style;\n        style.pointerEvents = \"auto\";\n        style.position = \"absolute\";\n        style.top = `${(rbox.cy - (bbox.h / 2)) - divRect.top}px`; // put the editor over the middle of the text element\n        style.left = `${(rbox.cx - (bbox.w / 2)) - divRect.left}px`;\n        style.height = editProps.size.height;\n        style.width = editProps.size.width;\n        style.resize = \"both\";\n        style.fontFamily = textElStyle.fontFamily; // set the font family and anchor to the same as the text element\n        style.textAnchor = textElStyle.textAnchor;\n        style.fontSize = editProps.fontSize; // from app.props\n        const parentZ = parseInt(window.getComputedStyle(markupDiv).zIndex || \"0\", 10);\n        style.zIndex = (parentZ + 200).toString();\n        editor.innerHTML = text.getMarkup(); // start with existing text\n        this.editor.focus(); // give the editor focus\n        // if we're started from the place text tool, select the entire current value, otherwise place the cursor at the end.\n        this.editor.setSelectionRange(this._fromPlaceTool ? 0 : editor.value.length, editor.value.length);\n    }\n    /** Called when EditText exits, saves the edited value into the text element */\n    async onCleanup() {\n        if (!this.editDiv)\n            return;\n        const text = this.text;\n        const original = this.boxed ? this.boxed : text;\n        const undo = this.markup.undo;\n        undo.performOperation(this.keyin, () => {\n            const newVal = this.editor.value;\n            if (newVal.trim() === \"\") { // if the result of the editing is blank, just delete the text element\n                if (!this._fromPlaceTool)\n                    undo.onDelete(original);\n                original.remove(); // must do this *after* we call undo.onDelete\n                return;\n            }\n            let newText = text.clone();\n            const fontSize = text.getFontSize();\n            newText.createMarkup(newVal, fontSize);\n            if (this.boxed) {\n                newText = this.createBoxedText(original.parent(), newText);\n                newText.matrix(original.matrix());\n            }\n            original.replace(newText);\n            if (this._fromPlaceTool)\n                undo.onAdded(newText);\n            else\n                undo.onModified(newText, original);\n        });\n        const editSize = MarkupApp.props.text.edit.size;\n        const style = this.editor.style;\n        editSize.height = style.height;\n        editSize.width = style.width;\n        this.editDiv.remove();\n        this.editDiv = undefined;\n        this.editor = undefined;\n    }\n    async onInstall() {\n        if (!await super.onInstall())\n            return false;\n        this.startEditor();\n        return true;\n    }\n    async onResetButtonUp(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n    async onDataButtonUp(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n    async onMouseStartDrag(_ev) {\n        await this.exitTool();\n        return EventHandled.Yes;\n    }\n}\nEditTextTool.toolId = \"Markup.Text.Edit\";\nEditTextTool.iconSpec = \"icon-text-medium\";\nexport { EditTextTool };\n//# sourceMappingURL=TextEdit.js.map",
      "start": 1693508125574,
      "end": 1693508125752,
      "sourcemaps": null
    }
  ]
}
