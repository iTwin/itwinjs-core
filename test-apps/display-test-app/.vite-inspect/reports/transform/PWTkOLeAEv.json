{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/widgets/TileMemoryBreakdown.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Widgets\n */\nimport { IModelApp, RenderMemory } from \"@itwin/core-frontend\";\nimport { createCheckBox } from \"../ui/CheckBox\";\nimport { formatMemory } from \"./MemoryTracker\";\nvar TileMemorySelector;\n(function (TileMemorySelector) {\n    TileMemorySelector[TileMemorySelector[\"Selected\"] = 0] = \"Selected\";\n    TileMemorySelector[TileMemorySelector[\"Ancestors\"] = 1] = \"Ancestors\";\n    TileMemorySelector[TileMemorySelector[\"Descendants\"] = 2] = \"Descendants\";\n    TileMemorySelector[TileMemorySelector[\"Orphaned\"] = 3] = \"Orphaned\";\n    TileMemorySelector[TileMemorySelector[\"Total\"] = 4] = \"Total\";\n    TileMemorySelector[TileMemorySelector[\"Count\"] = 5] = \"Count\";\n})(TileMemorySelector || (TileMemorySelector = {}));\nclass TileMemoryTracer {\n    constructor() {\n        this._stats = new RenderMemory.Statistics();\n        this._processedTiles = new Set();\n        this.counters = [];\n        this.numSelected = 0;\n        for (let i = 0; i < TileMemorySelector.Count; i++)\n            this.counters.push({ numTiles: 0, bytesUsed: 0 });\n    }\n    update() {\n        this.reset();\n        const imodels = new Set();\n        const selectedTiles = new Set();\n        for (const vp of IModelApp.viewManager) {\n            imodels.add(vp.iModel);\n            const tiles = IModelApp.tileAdmin.getTilesForUser(vp)?.selected;\n            if (tiles)\n                for (const tile of tiles)\n                    selectedTiles.add(tile);\n        }\n        for (const selected of selectedTiles)\n            this.add(selected, TileMemorySelector.Selected);\n        for (const selected of selectedTiles) {\n            this.processParent(selected.parent);\n            this.processChildren(selected.children);\n        }\n        for (const imodel of imodels) {\n            imodel.tiles.forEachTreeOwner((owner) => {\n                const tree = owner.tileTree;\n                if (tree)\n                    this.processOrphan(tree.rootTile);\n            });\n        }\n        this.counters[TileMemorySelector.Total].numTiles = this.counters.reduce((accum, counter) => accum + counter.numTiles, 0);\n        this.counters[TileMemorySelector.Total].bytesUsed = this.counters.reduce((accum, counter) => accum + counter.bytesUsed, 0);\n    }\n    reset() {\n        this._processedTiles.clear();\n        this.numSelected = 0;\n        for (const counter of this.counters)\n            counter.numTiles = counter.bytesUsed = 0;\n    }\n    add(tile, selector) {\n        this._processedTiles.add(tile);\n        this._stats.clear();\n        tile.collectStatistics(this._stats, false);\n        const bytesUsed = this._stats.totalBytes;\n        if (bytesUsed > 0) {\n            const counter = this.counters[selector];\n            ++counter.numTiles;\n            counter.bytesUsed += bytesUsed;\n        }\n    }\n    processParent(parent) {\n        if (parent && !this._processedTiles.has(parent)) {\n            this.add(parent, TileMemorySelector.Ancestors);\n            this.processParent(parent.parent);\n        }\n    }\n    processChildren(children) {\n        if (!children)\n            return;\n        for (const child of children) {\n            if (!this._processedTiles.has(child)) {\n                this.add(child, TileMemorySelector.Descendants);\n                this.processChildren(child.children);\n            }\n        }\n    }\n    processOrphan(tile) {\n        if (!this._processedTiles.has(tile))\n            this.add(tile, TileMemorySelector.Orphaned);\n        const children = tile.children;\n        if (children)\n            for (const child of children)\n                this.processOrphan(child);\n    }\n}\nconst statsLabels = [\"Selected\", \"Ancestors\", \"Descendants\", \"Orphaned\", \"Total\"];\nfunction format(count, label, bytesUsed) {\n    return `${count} ${label}: ${formatMemory(bytesUsed)}`;\n}\n/** Breaks down the GPU memory allocated to tiles into categories displayed in two panes.\n * The left-hand pane obtains its information from [TileAdmin]($frontend), displaying the number of selected and unselected tiles that are consuming graphics memory along with the amount of memory consumed.\n * The right-hand pane computes its information from the set of all [TileTree]($frontend)s, broken down into groups:\n * - \"Selected\" - tiles that have been selected for display in at least one viewport.\n * - \"Ancestors\" - tiles not selected for display, but have descendents selected for display.\n * - \"Descendants\" - tiles not selected for display, but have ancestors selected for display.\n * - \"Orphans\" - tiles not selected for display that have no ancestors nor descendants selected for display.\n * - \"Total\" - totals of the above categories.\n *\n * Each row of data shows `(number of tiles) Group Name: amount of memory consumed by group`.\n * The number of tiles in each group includes only those tiles that are consuming a non-zero amount of GPU memory.\n * The widget includes a checkbox to toggle tracking and display of these statistics.\n * @beta\n */\nexport class TileMemoryBreakdown {\n    /** Construct a new breakdown widget as a child of the specified parent element. */\n    constructor(parent) {\n        this._tracer = new TileMemoryTracer();\n        this._statsElements = [];\n        this._totalsElements = [];\n        createCheckBox({\n            parent,\n            name: \"Tile Memory Breakdown\",\n            id: \"tileMemoryBreakdown\",\n            handler: (_cb) => this.toggle(),\n        });\n        parent.appendChild(this._div = document.createElement(\"div\"));\n        this._div.style.display = \"none\";\n        this._div.style.textAlign = \"right\";\n        const table = document.createElement(\"table\");\n        table.style.width = \"100%\";\n        table.setAttribute(\"border\", \"1\");\n        this._div.appendChild(table);\n        const row = document.createElement(\"tr\");\n        const leftCell = document.createElement(\"td\");\n        const rightCell = document.createElement(\"td\");\n        leftCell.style.width = rightCell.style.width = \"50%\";\n        row.appendChild(leftCell);\n        row.appendChild(rightCell);\n        table.appendChild(row);\n        for (let i = 0; i < TileMemorySelector.Count; i++) {\n            const div = document.createElement(\"div\");\n            const elem = document.createElement(\"text\");\n            this._statsElements.push(elem);\n            div.appendChild(elem);\n            rightCell.appendChild(div);\n        }\n        for (let i = 0; i < 3; i++) {\n            const div = document.createElement(\"div\");\n            const elem = document.createElement(\"text\");\n            this._totalsElements.push(elem);\n            div.appendChild(elem);\n            leftCell.appendChild(div);\n        }\n    }\n    dispose() {\n        this.clearInterval();\n    }\n    toggle() {\n        if (undefined !== this._curIntervalId) {\n            this._div.style.display = \"none\";\n            this.clearInterval();\n        }\n        else {\n            this._div.style.display = \"block\";\n            this.update();\n            this._curIntervalId = setInterval(() => this.update(), 500);\n        }\n    }\n    clearInterval() {\n        if (undefined !== this._curIntervalId) {\n            clearInterval(this._curIntervalId);\n            this._curIntervalId = undefined;\n        }\n    }\n    update() {\n        this._tracer.update();\n        for (let i = 0; i < this._statsElements.length; i++) {\n            const counter = this._tracer.counters[i];\n            this._statsElements[i].innerText = format(counter.numTiles, statsLabels[i], counter.bytesUsed);\n        }\n        let numUnselected = 0;\n        let unselectedBytes = 0;\n        for (const unselected of IModelApp.tileAdmin.unselectedLoadedTiles) {\n            ++numUnselected;\n            unselectedBytes += unselected.bytesUsed;\n        }\n        let numSelected = 0;\n        let selectedBytes = 0;\n        for (const selected of IModelApp.tileAdmin.selectedLoadedTiles) {\n            ++numSelected;\n            selectedBytes += selected.bytesUsed;\n        }\n        this._totalsElements[0].innerText = format(numSelected, \"Selected\", selectedBytes);\n        this._totalsElements[1].innerText = format(numUnselected, \"Unselected\", unselectedBytes);\n        this._totalsElements[2].innerText = format(numSelected + numUnselected, \"Total\", IModelApp.tileAdmin.totalTileContentBytes);\n    }\n}\n//# sourceMappingURL=TileMemoryBreakdown.js.map",
      "start": 1693508122846,
      "end": 1693508122920,
      "sourcemaps": null
    }
  ]
}
