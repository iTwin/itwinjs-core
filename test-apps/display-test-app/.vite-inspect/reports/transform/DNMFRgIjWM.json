{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/IntegratedSpiral3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { TransitionSpiral3d } from \"./TransitionSpiral3d\";\nimport { Segment1d } from \"../../geometry3d/Segment1d\";\nimport { AngleSweep } from \"../../geometry3d/AngleSweep\";\nimport { Transform } from \"../../geometry3d/Transform\";\nimport { LineString3d } from \"../LineString3d\";\nimport { NormalizedTransition } from \"./NormalizedTransition\";\nimport { TransitionConditionalProperties } from \"./TransitionConditionalProperties\";\nimport { Quadrature } from \"../../numerics/Quadrature\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Matrix3d } from \"../../geometry3d/Matrix3d\";\nimport { AxisOrder, Geometry } from \"../../Geometry\";\nimport { StrokeOptions } from \"../StrokeOptions\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Plane3dByOriginAndVectors } from \"../../geometry3d/Plane3dByOriginAndVectors\";\n/**\n * An IntegratedSpiral3d is a curve defined by integrating its curvature.\n * * The first integral of curvature (with respect to distance along the curve) is the bearing angle (in radians)\n * * Integrating (cos(theta), sin(theta)) gives displacement from the start point, and thus the actual curve position.\n * * The curvature functions of interest are all symmetric snap functions in the NormalizedTransition class.\n * * `TransitionConditionalProperties` implements the computations of the interrelationship of radii, bearing, and length.\n * @public\n */\nclass IntegratedSpiral3d extends TransitionSpiral3d {\n    /** Return the internal stroked form of the (possibly partial) spiral   */\n    get activeStrokes() { return this._activeStrokes !== undefined ? this._activeStrokes : this._globalStrokes; }\n    /** evaluator for transition */\n    // constructor demands all bearing, radius, and length data -- caller determines usual dependency of \"any 4 determine the 5th\"\n    constructor(spiralType, evaluator, radius01, bearing01, activeFractionInterval, localToWorld, arcLength, properties) {\n        super(spiralType, localToWorld, activeFractionInterval, properties);\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"transitionSpiral\";\n        this._evaluator = evaluator;\n        this.radius01 = radius01;\n        this.bearing01 = bearing01;\n        this._arcLength01 = arcLength;\n        this._globalStrokes = LineString3d.create();\n        // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...\n        this._curvature01 = Segment1d.create(0, 1);\n        this.refreshComputedProperties();\n    }\n    /** use the integrated function to return an angle at fractional position. */\n    globalFractionToBearingRadians(fraction) {\n        const areaFraction = this._evaluator.fractionToArea(fraction);\n        const dx = this._arcLength01;\n        return this.bearing01.startRadians + areaFraction * dx * this._curvature01.signedDelta() + fraction * this._curvature01.x0 * dx;\n    }\n    /** use the integrated function to return an angle at fractional position. */\n    globalFractionToCurvature(fraction) {\n        const f = this._evaluator.fractionToCurvatureFraction(fraction);\n        return this._curvature01.fractionToPoint(f);\n    }\n    /** Return the bearing at given fraction of the active interval .... */\n    fractionToBearingRadians(activeFraction) {\n        const fraction = this.activeFractionInterval.fractionToPoint(activeFraction);\n        return this.bearing01.startRadians + fraction * this._arcLength01 * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));\n    }\n    /** Return the curvature at given fraction of the active interval ...\n     * * The `undefined` result is to match the abstract class -- it cannot actually occur.\n     */\n    fractionToCurvature(activeFraction) {\n        // BUG? active interval\n        return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(activeFraction));\n    }\n    /** Initialize class level work arrays. */\n    static initWorkSpace() {\n        IntegratedSpiral3d._gaussFraction = new Float64Array(5);\n        IntegratedSpiral3d._gaussWeight = new Float64Array(5);\n        IntegratedSpiral3d._gaussMapper = (xA, xB, xMapped, wMapped) => Quadrature.setupGauss5(xA, xB, xMapped, wMapped);\n    }\n    /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.\n     * (recall that theta is a nonlinear function of the fraction.)\n     * * This is a single interval of gaussian integration.\n     * * The fraction is on the full spiral (not in the mapped active interval)\n     * @param xyz advancing integrated point.\n     * @param fractionA fraction at start of interval\n     * @param fractionB fraction at end of interval.\n     * @param unitArcLength length of curve for 0 to 1 fractional\n     */\n    fullSpiralIncrementalIntegral(xyz, fractionA, fractionB, applyMatrix) {\n        const gaussFraction = IntegratedSpiral3d._gaussFraction;\n        const gaussWeight = IntegratedSpiral3d._gaussWeight;\n        const numEval = IntegratedSpiral3d._gaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);\n        const deltaL = this._arcLength01;\n        let w = 0;\n        let dx = 0.0;\n        let dy = 0.0;\n        for (let k = 0; k < numEval; k++) {\n            const radians = this.globalFractionToBearingRadians(gaussFraction[k]);\n            w = gaussWeight[k] * deltaL;\n            dx += w * Math.cos(radians);\n            dy += w * Math.sin(radians);\n        }\n        if (applyMatrix)\n            Matrix3d.xyzPlusMatrixTimesXYZ(xyz, this.localToWorld.matrix, { x: dx, y: dy, z: 0.0 }, xyz);\n        else\n            xyz.addXYZInPlace(dx, dy, 0.0);\n    }\n    /** Recompute strokes */\n    refreshComputedProperties() {\n        this._curvature01 = Segment1d.create(TransitionSpiral3d.radiusToCurvature(this.radius01.x0), TransitionSpiral3d.radiusToCurvature(this.radius01.x1));\n        this._globalStrokes.clear();\n        const currentPoint = Point3d.create();\n        this._globalStrokes.appendStrokePoint(currentPoint);\n        const numInterval = 16;\n        const fractionStep = 1.0 / numInterval;\n        for (let i = 1; i <= numInterval; i++) {\n            const fraction0 = (i - 1) * fractionStep;\n            const fraction1 = i * fractionStep;\n            this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1, false);\n            this._globalStrokes.appendStrokePoint(currentPoint);\n        }\n        this._globalStrokes.tryTransformInPlace(this.localToWorld);\n        if (!this.activeFractionInterval.isExact01) {\n            if (this._activeStrokes === undefined)\n                this._activeStrokes = LineString3d.create();\n            this._activeStrokes.clear();\n            // finer strokes in the active interval ... same fraction step, but mapped\n            // This assumes factionToPoint acts normally within refreshComputedProperties -- that depends on the global strokes we just computed, but not on the active strokes\n            for (let i = 0; i <= numInterval; i++) {\n                const localFraction = i * fractionStep;\n                this._activeStrokes.addPoint(this.fractionToPoint(localFraction));\n            }\n        }\n    }\n    /**\n     * Create a transition spiral with radius and bearing conditions.\n     * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)\n     * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis\n     * @param activeFractionInterval fractional limits of the active portion of the spiral.\n     * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.\n     */\n    static createRadiusRadiusBearingBearing(radius01, bearing01, activeFractionInterval, localToWorld, typeName) {\n        const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);\n        if (typeName === undefined)\n            typeName = \"clothoid\";\n        const evaluator = NormalizedTransition.findEvaluator(typeName);\n        if (!evaluator)\n            return undefined;\n        return new IntegratedSpiral3d(typeName, evaluator, radius01.clone(), bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength, new TransitionConditionalProperties(radius01.x0, radius01.x1, bearing01.startAngle.clone(), bearing01.endAngle.clone(), undefined));\n    }\n    /**\n     * Create a transition spiral.\n     * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.\n     * @param spiralType one of \"clothoid\", \"bloss\", \"biquadratic\", \"cosine\", \"sine\".  If undefined, \"clothoid\" is used.\n     * @param radius0 radius (or 0 for tangent to line) at start\n     * @param radius1 radius (or 0 for tangent to line) at end\n     * @param bearing0 bearing, measured CCW from x axis at start.\n     * @param bearing1 bearing, measured CCW from x axis at end.\n     * @param fractionInterval optional fractional interval for an \"active\" portion of the curve.   if omitted, the full [0,1] is used.\n     * @param localToWorld placement transform\n     */\n    static createFrom4OutOf5(spiralType, radius0, radius1, bearing0, bearing1, arcLength, fractionInterval, localToWorld) {\n        if (spiralType === undefined)\n            spiralType = \"clothoid\";\n        const evaluator = NormalizedTransition.findEvaluator(spiralType);\n        if (!evaluator)\n            return undefined;\n        const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);\n        const data1 = data.clone();\n        if (!data.tryResolveAnySingleUnknown())\n            return undefined;\n        if (fractionInterval === undefined)\n            fractionInterval = Segment1d.create(0, 1);\n        return new IntegratedSpiral3d(spiralType, evaluator, Segment1d.create(data.radius0, data.radius1), AngleSweep.createStartEnd(data.bearing0, data.bearing1), fractionInterval ? fractionInterval.clone() : Segment1d.create(0, 1), localToWorld, data.curveLength, data1);\n    }\n    /** Copy all defining data from another spiral. */\n    setFrom(other) {\n        this.localToWorld.setFrom(other.localToWorld);\n        this.radius01.setFrom(other.radius01);\n        this._curvature01.setFrom(other._curvature01);\n        this.bearing01.setFrom(other.bearing01);\n        this.localToWorld.setFrom(other.localToWorld);\n        this.activeFractionInterval.setFrom(other.activeFractionInterval);\n        this._arcLength01 = other._arcLength01;\n        return this;\n    }\n    /** Deep clone of this spiral */\n    clone() {\n        return new IntegratedSpiral3d(this._spiralType, this._evaluator, this.radius01.clone(), this.bearing01.clone(), this.activeFractionInterval.clone(), this.localToWorld.clone(), this._arcLength01, this._designProperties?.clone());\n    }\n    /** apply `transform` to this spiral's local to world transform. */\n    tryTransformInPlace(transformA) {\n        const rigidData = this.applyRigidPartOfTransform(transformA);\n        if (rigidData !== undefined) {\n            this._curvature01.x0 /= rigidData.scale;\n            this._curvature01.x1 /= rigidData.scale;\n            this.radius01.x0 *= rigidData.scale;\n            this.radius01.x1 *= rigidData.scale;\n            this._arcLength01 *= rigidData.scale;\n        }\n        this.refreshComputedProperties();\n        return true;\n    }\n    /** Return the spiral start point. */\n    startPoint() { return this.activeStrokes.startPoint(); }\n    /** return the spiral end point. */\n    endPoint() { return this.activeStrokes.endPoint(); }\n    /** test if the local to world transform places the spiral xy plane into `plane` */\n    isInPlane(plane) {\n        return plane.isPointInPlane(this.localToWorld.origin)\n            && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))\n            && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));\n    }\n    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\n    quickLength() { return this.curveLength(); }\n    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\n    curveLength() { return this._arcLength01 * (this._activeFractionInterval.absoluteDelta()); }\n    /** Return (unsigned) length of the spiral between fractions.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        return this._arcLength01 * (this._activeFractionInterval.absoluteDelta() * Math.abs(fraction1 - fraction0));\n    }\n    /** Test if `other` is an instance of `TransitionSpiral3d` */\n    isSameGeometryClass(other) { return other instanceof TransitionSpiral3d; }\n    /** Add strokes from this spiral to `dest`.\n     * * Linestrings will usually stroke as just their points.\n     * * If maxEdgeLength is given, this will sub-stroke within the linestring -- not what we want.\n     */\n    emitStrokes(dest, options) { this.activeStrokes.emitStrokes(dest, options); }\n    /** emit stroke fragments to `dest` handler. */\n    emitStrokableParts(dest, options) {\n        const n = this.computeStrokeCountForOptions(options);\n        dest.startParentCurvePrimitive(this);\n        const activeStrokes = this.activeStrokes;\n        const preferPrimary = dest.needPrimaryGeometryForStrokes === undefined ? false : dest.needPrimaryGeometryForStrokes();\n        if (!preferPrimary && n <= activeStrokes.numPoints()) {\n            this.activeStrokes.emitStrokableParts(dest, options);\n        }\n        else {\n            dest.announceIntervalForUniformStepStrokes(this, n, 0.0, 1.0);\n        }\n        dest.endParentCurvePrimitive(this);\n    }\n    /**\n     * return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        let numStroke;\n        if (options) {\n            const rMin = Math.min(Math.abs(this.radius01.x0), Math.abs(this.radius01.x1));\n            numStroke = options.applyTolerancesToArc(rMin, this.bearing01.sweepRadians);\n            numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\n            numStroke = options.applyMinStrokesPerPrimitive(numStroke);\n        }\n        else {\n            numStroke = StrokeOptions.applyAngleTol(undefined, 4, this.bearing01.sweepRadians);\n        }\n        return numStroke;\n    }\n    /** Reverse the active interval and active strokes.\n     * * Primary defining data remains unchanged !!!\n     */\n    reverseInPlace() {\n        this.activeFractionInterval.reverseInPlace();\n        if (this._activeStrokes === undefined)\n            this._activeStrokes = this._globalStrokes.clone();\n        this._activeStrokes.reverseInPlace();\n    }\n    /** Evaluate curve point with respect to fraction. */\n    fractionToPoint(activeFraction, result) {\n        const targetGlobalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\n        const numStrokes = this._globalStrokes.packedPoints.length - 1;\n        if (activeFraction > 1.0) {\n            result = this._globalStrokes.packedPoints.back(result);\n            const integrationStep = 1.0 / numStrokes;\n            let currentGlobalFraction = 1.0;\n            let nextGlobalFraction = currentGlobalFraction + integrationStep;\n            while (nextGlobalFraction < targetGlobalFraction) {\n                this.fullSpiralIncrementalIntegral(result, currentGlobalFraction, nextGlobalFraction, true);\n                currentGlobalFraction = nextGlobalFraction;\n                nextGlobalFraction += integrationStep;\n            }\n            this.fullSpiralIncrementalIntegral(result, currentGlobalFraction, targetGlobalFraction, true);\n        }\n        else if (activeFraction < 0.0) {\n            result = this._globalStrokes.packedPoints.front(result);\n            const integrationStep = 1.0 / numStrokes;\n            let currentGlobalFraction = 0.0;\n            let nextGlobalFraction = currentGlobalFraction - integrationStep;\n            while (nextGlobalFraction > targetGlobalFraction) {\n                this.fullSpiralIncrementalIntegral(result, currentGlobalFraction, nextGlobalFraction, true);\n                currentGlobalFraction = nextGlobalFraction;\n                nextGlobalFraction -= integrationStep;\n            }\n            this.fullSpiralIncrementalIntegral(result, currentGlobalFraction, targetGlobalFraction, true);\n        }\n        else {\n            const clampedGlobalFraction = Geometry.clampToStartEnd(targetGlobalFraction, 0, 1);\n            const index0 = Math.trunc(clampedGlobalFraction * numStrokes); // This indexes the point to the left of the query.\n            const globalFraction0 = index0 / numStrokes;\n            result = this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(index0, result);\n            // GeometryCoreTestIO.consoleLog(\" fractionToPoint \", activeFraction, this.activeFractionInterval, \"( global integration \" + globalFraction0 + \" to \" + globalFraction + \")\", index0);\n            this.fullSpiralIncrementalIntegral(result, globalFraction0, targetGlobalFraction, true);\n        }\n        return result;\n    }\n    /** Evaluate curve point and derivative with respect to fraction. */\n    fractionToPointAndDerivative(activeFraction, result) {\n        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\n        result = result ? result : Ray3d.createZero();\n        this.fractionToPoint(activeFraction, result.origin);\n        const radians = this.globalFractionToBearingRadians(globalFraction);\n        const a = this._arcLength01 * this.activeFractionInterval.signedDelta();\n        this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);\n        return result;\n    }\n    /** Return the frenet frame at fractional position. */\n    fractionToFrenetFrame(activeFraction, result) {\n        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\n        result = result ? result : Transform.createIdentity();\n        result.origin.setFrom(this.fractionToPoint(activeFraction));\n        Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix, AxisOrder.XYZ, result.matrix);\n        const radians = this.globalFractionToBearingRadians(globalFraction);\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        result.matrix.applyGivensColumnOp(0, 1, c, s);\n        return result;\n    }\n    /** Return a plane with\n     *\n     * * origin at fractional position along the curve\n     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\n     * * vectorV is the second derivative, i.e.derivative of vectorU.\n     */\n    fractionToPointAnd2Derivatives(activeFraction, result) {\n        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\n        const origin = this.fractionToPoint(activeFraction);\n        const radians = this.globalFractionToBearingRadians(globalFraction);\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n        const delta = this.activeFractionInterval.signedDelta();\n        const a = delta;\n        const b = a * delta;\n        const vectorX = this.localToWorld.matrix.multiplyXY(a * c, a * s);\n        const vectorY = this.localToWorld.matrix.multiplyXY(-b * s, b * c);\n        vectorY.scaleInPlace(this.globalFractionToCurvature(globalFraction));\n        return Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);\n    }\n    /** Second step of double dispatch:  call `handler.handleTransitionSpiral(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleTransitionSpiral(this);\n    }\n    /** compare various coordinate quantities */\n    isAlmostEqual(other) {\n        if (other instanceof IntegratedSpiral3d) {\n            return this.radius01.isAlmostEqual(other.radius01)\n                && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)\n                && this.localToWorld.isAlmostEqual(other.localToWorld)\n                && Geometry.isSameCoordinate(this._arcLength01, other._arcLength01)\n                && this.activeFractionInterval.isAlmostEqual(other.activeFractionInterval)\n                && this._curvature01.isAlmostEqual(other._curvature01);\n        }\n        return false;\n    }\n}\n/** default spiral type name. (clothoid) */\nIntegratedSpiral3d.defaultSpiralType = \"clothoid\";\nexport { IntegratedSpiral3d };\n// at load time, initialize gauss quadrature workspace\nIntegratedSpiral3d.initWorkSpace();\n//# sourceMappingURL=IntegratedSpiral3d.js.map",
      "start": 1693508123716,
      "end": 1693508123860,
      "sourcemaps": null
    }
  ]
}
