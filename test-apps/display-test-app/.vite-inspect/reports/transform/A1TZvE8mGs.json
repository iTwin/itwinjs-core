{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/IndexedCollectionInterval.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\n/**\n * Object describing a (contiguous) subset of indices to an IndexedXYZCollection\n * @public\n */\nexport class IndexedCollectionInterval {\n    constructor(points, base, limit) {\n        this.points = points;\n        this.begin = base;\n        this.end = limit;\n    }\n    /** Create an interval which matches a complete indexed collection. */\n    static createComplete(points) {\n        return new this(points, 0, points.length);\n    }\n    /** Create an interval which matches a collection from `start <= i < end`. */\n    static createBeginEnd(points, begin, end) {\n        return new this(points, begin, end);\n    }\n    /** Create an interval which matches a collection from `start <= i < end`. */\n    static createBeginLength(points, begin, length) {\n        return new this(points, begin, begin + length);\n    }\n    /** Add one to this.begin.  Return true if the interval is still live. */\n    advanceBegin() {\n        this.begin++;\n        return this.begin < this.end;\n    }\n    /** advance this.end (but do not go beyond this.points.length)   return true if the interval is still live. */\n    advanceEnd() {\n        this.end++;\n        if (this.end > this.points.length)\n            this.end = this.points.length;\n        return this.begin < this.end;\n    }\n    /** Return (if possible) the parent index corresponding to `localIndex` */\n    localIndexToParentIndex(localIndex) {\n        if (localIndex >= 0) {\n            const parentIndex = this.begin + localIndex;\n            if (parentIndex < this.points.length)\n                return parentIndex;\n        }\n        return undefined;\n    }\n    /** Return true if\n     * * the interval is empty (the empty set is a subset of all sets!)\n     * * all indices in its range are valid.\n     */\n    get isValidSubset() {\n        return this.length === 0\n            || (this.localIndexToParentIndex(0) !== undefined\n                && this.localIndexToParentIndex(this.length - 1) !== undefined);\n    }\n    /** restrict this.end to this.points.length */\n    restrictEnd() {\n        if (this.end > this.points.length)\n            this.end = this.points.length;\n    }\n    /** Return true if length is 1 or more */\n    get isNonEmpty() {\n        return this.begin < this.end;\n    }\n    /** Advance this.begin to (other.end-1), i.e. catch the last member of other. */\n    advanceToTail(other) {\n        this.begin = other.end - 1;\n        return this.isNonEmpty;\n    }\n    /** Advance this.begin to (other.begin), i.e. catch the first member of other. */\n    advanceToHead(other) {\n        this.begin = other.begin;\n        return this.isNonEmpty;\n    }\n    /** Set this interval from another, with conditional replacements:\n     * * Always reference the same points as other.\n     * * use optional begin and end arguments if present; if not take begin and and from other.\n     * * cap end at points.length.\n     */\n    setFrom(other, base, limit) {\n        this.points = other.points;\n        this.begin = base === undefined ? other.begin : base;\n        this.end = limit === undefined ? other.end : limit;\n        this.restrictEnd();\n    }\n    /** Return the number of steps possible with current begin and end */\n    get length() {\n        return this.end > this.begin ? this.end - this.begin : 0;\n    }\n    /** Return true if the length is exactly 1 */\n    get isSingleton() {\n        return this.begin + 1 === this.end;\n    }\n}\n/**\n * Reference to an interval of the indices of an IndexedXYZCollection.\n * @public\n */\nexport class IndexedXYZCollectionInterval extends IndexedCollectionInterval {\n}\n//# sourceMappingURL=IndexedCollectionInterval.js.map",
      "start": 1693508123115,
      "end": 1693508123286,
      "sourcemaps": null
    }
  ]
}
