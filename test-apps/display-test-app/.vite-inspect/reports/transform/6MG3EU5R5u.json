{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/GlobeAnimator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { Geometry, SmoothTransformBetweenFrusta } from \"@itwin/core-geometry\";\nimport { Cartographic, Easing, Frustum, GlobeMode, Interpolation, Tweens } from \"@itwin/core-common\";\nimport { areaToEyeHeight, areaToEyeHeightFromGcs, eyeToCartographicOnGlobe, metersToRange, ViewGlobalLocationConstants, } from \"./ViewGlobalLocation\";\n/** Animates the transition of a [[Viewport]] to view a location on the Earth. The animation traces a flight path from the viewport's current [Frustum]($common) to the destination.\n * The duration of the animation varies based on the distance traversed.\n * @see [[Viewport.animateFlyoverToGlobalLocation]].\n * @public\n * @extensions\n */\nexport class GlobeAnimator {\n    _moveFlightToFraction(fraction) {\n        const vp = this._viewport;\n        const view = vp.view;\n        if (!(view.is3d()) || !vp.iModel.isGeoLocated) // This animation only works for 3d views and geolocated models\n            return true;\n        // If we're done, set the final state directly\n        if (fraction >= 1.0) {\n            if (vp.view.is3d()) // Need to reset focus as well -- setupViewFromFustum does not set this and it will remain at flight distance.\n                vp.view.camera.setFocusDistance(this._afterFocusDistance);\n            vp.setupViewFromFrustum(this._afterLanding);\n            vp.synchWithView();\n            return true;\n        }\n        // Possibly smooth the takeoff\n        if (fraction < this._fixTakeoffFraction && this._fixTakeoffInterpolator !== undefined) {\n            this._moveFixToFraction((1.0 / this._fixTakeoffFraction) * fraction, this._fixTakeoffInterpolator);\n            return false;\n        }\n        // Possibly smooth the landing\n        if (fraction >= this._fixLandingFraction && fraction < 1.0) {\n            if (this._fixLandingInterpolator === undefined) {\n                const beforeLanding = vp.getWorldFrustum();\n                this._fixLandingInterpolator = SmoothTransformBetweenFrusta.create(beforeLanding.points, this._afterLanding.points);\n            }\n            this._moveFixToFraction((1.0 / (1.0 - this._fixLandingFraction)) * (fraction - this._fixLandingFraction), this._fixLandingInterpolator);\n            return false;\n        }\n        // Set the camera based on a fraction along the flight arc\n        const height = Interpolation.Bezier([this._startHeight, this._midHeight, this._endHeight], fraction);\n        let targetPoint;\n        if (view.globeMode === GlobeMode.Plane)\n            targetPoint = this._columbusLine[0].interpolate(fraction, this._columbusLine[1]);\n        else\n            targetPoint = this._ellipsoidArc.fractionToPoint(fraction);\n        view.lookAtGlobalLocation(height, ViewGlobalLocationConstants.birdPitchAngleRadians, undefined, targetPoint);\n        vp.setupFromView();\n        return false;\n    }\n    /** Apply a SmoothTransformBetweenFrusta interpolator to the view based on a fraction. */\n    _moveFixToFraction(fract, interpolator) {\n        let done = false;\n        if (fract >= 1.0) {\n            fract = 1.0;\n            done = true;\n        }\n        interpolator.fractionToWorldCorners(Math.max(fract, 0), this._scratchFrustum.points);\n        this._viewport.setupViewFromFrustum(this._scratchFrustum);\n        return done;\n    }\n    /** Create an animator to transition to the specified destination.\n     * @param viewport The viewport to animate.\n     * @param destination The destination to travel to.\n     * @returns An animator, or undefined if the viewport's iModel is not geolocated or its view is not 3d.\n     */\n    static async create(viewport, destination) {\n        const view = viewport.view;\n        if (!(view.is3d()) || !viewport.iModel.isGeoLocated) // This animation only works for 3d views and geolocated models\n            return undefined;\n        const endHeight = destination.area !== undefined ? await areaToEyeHeightFromGcs(view, destination.area, destination.center.height) : ViewGlobalLocationConstants.birdHeightAboveEarthInMeters;\n        const beforeFrustum = viewport.getWorldFrustum();\n        await view.lookAtGlobalLocationFromGcs(endHeight, ViewGlobalLocationConstants.birdPitchAngleRadians, destination);\n        viewport.setupFromView();\n        const afterLanding = viewport.getWorldFrustum();\n        const afterFocus = view.camera.focusDist;\n        viewport.setupViewFromFrustum(beforeFrustum); // revert old frustum\n        return new GlobeAnimator(viewport, destination, afterLanding, afterFocus);\n    }\n    constructor(viewport, destination, afterLanding, afterFocus) {\n        this._flightTweens = new Tweens();\n        this._columbusLine = [];\n        this._flightLength = 0;\n        this._fixLandingFraction = 0.9;\n        this._scratchFrustum = new Frustum();\n        this._viewport = viewport;\n        this._endLocation = destination;\n        this._afterLanding = afterLanding;\n        this._afterFocusDistance = afterFocus;\n        const view = viewport.view;\n        if (!(view.is3d()) || !viewport.iModel.isGeoLocated) // This animation only works for 3d views and geolocated models\n            return;\n        // Calculate start height as the height of the current eye above the earth.\n        // Calculate end height from the destination area (if specified); otherwise, use a constant value.\n        const backgroundMapGeometry = view.displayStyle.getBackgroundMapGeometry();\n        if (undefined === backgroundMapGeometry)\n            return;\n        this._startHeight = eyeToCartographicOnGlobe(this._viewport, true).height;\n        this._endHeight = destination.area !== undefined ? areaToEyeHeight(view, destination.area, destination.center.height) : ViewGlobalLocationConstants.birdHeightAboveEarthInMeters;\n        // Starting cartographic position is the eye projected onto the globe.\n        let startCartographic = eyeToCartographicOnGlobe(viewport);\n        if (startCartographic === undefined) {\n            startCartographic = Cartographic.createZero();\n        }\n        this._startCartographic = startCartographic;\n        let maxFlightDuration;\n        if (view.globeMode === GlobeMode.Plane) {\n            // Calculate a line segment going from the starting cartographic coordinate to the ending cartographic coordinate\n            this._columbusLine.push(view.cartographicToRoot(startCartographic));\n            this._columbusLine.push(view.cartographicToRoot(this._endLocation.center));\n            this._flightLength = this._columbusLine[0].distance(this._columbusLine[1]);\n            // Set a shorter flight duration in Plane mode\n            maxFlightDuration = 7000.0;\n        }\n        else {\n            // Calculate a flight arc from the ellipsoid of the Earth and the starting and ending cartographic coordinates.\n            const earthEllipsoid = backgroundMapGeometry.getEarthEllipsoid();\n            this._ellipsoidArc = earthEllipsoid.radiansPairToGreatArc(this._startCartographic.longitude, this._startCartographic.latitude, this._endLocation.center.longitude, this._endLocation.center.latitude);\n            if (this._ellipsoidArc !== undefined)\n                this._flightLength = this._ellipsoidArc.curveLength();\n            // Set a longer flight duration in 3D mode\n            maxFlightDuration = 13000.0;\n        }\n        if (Geometry.isSmallMetricDistance(this._flightLength))\n            return;\n        // The peak of the flight varies based on total distance to travel. The larger the distance, the higher the peak of the flight will be.\n        this._midHeight = metersToRange(this._flightLength, ViewGlobalLocationConstants.birdHeightAboveEarthInMeters, ViewGlobalLocationConstants.satelliteHeightAboveEarthInMeters * 4, ViewGlobalLocationConstants.largestEarthArc);\n        // We will \"fix\" the initial frustum so it smoothly transitions to some point along the travel arc depending on the starting height.\n        // Alternatively, if the distance to travel is small enough, we will _only_ do a frustum transition to the destination location - ignoring the flight arc.\n        const beforeTakeoff = viewport.getWorldFrustum();\n        if (view.globeMode === GlobeMode.Plane) {\n            /// Do not \"fix\" the take-off for plane mode; SmoothTransformBetweenFrusta can behave wrongly.\n            // However, if within driving distance, still use SmoothTransformBetweenFrusta to navigate there without flight.\n            this._fixTakeoffFraction = this._flightLength <= ViewGlobalLocationConstants.maximumDistanceToDrive ? 1.0 : 0.0;\n        }\n        else {\n            this._fixTakeoffFraction = this._flightLength <= ViewGlobalLocationConstants.maximumDistanceToDrive ? 1.0 : metersToRange(this._startHeight, 0.1, 0.4, ViewGlobalLocationConstants.birdHeightAboveEarthInMeters);\n        }\n        if (this._fixTakeoffFraction > 0.0) {\n            this._moveFlightToFraction(this._fixTakeoffFraction);\n            const afterTakeoff = viewport.getWorldFrustum();\n            this._fixTakeoffInterpolator = SmoothTransformBetweenFrusta.create(beforeTakeoff.points, afterTakeoff.points);\n        }\n        // The duration of the animation will increase the larger the distance to travel.\n        const flightDurationInMilliseconds = metersToRange(this._flightLength, 1000, maxFlightDuration, ViewGlobalLocationConstants.largestEarthArc);\n        // Specify the tweening behavior for this animation.\n        this._flightTweens.create({ fraction: 0.0 }, {\n            to: { fraction: 1.0 },\n            duration: flightDurationInMilliseconds,\n            easing: Easing.Cubic.InOut,\n            start: true,\n            onUpdate: (obj) => this._moveFlightToFraction(obj.fraction),\n        });\n    }\n    /** @internal */\n    animate() {\n        if (this._flightLength <= 0) {\n            this._moveFlightToFraction(1.0); // Skip to final frustum\n            return true;\n        }\n        return !this._flightTweens.update();\n    }\n    /** @internal */\n    interrupt() {\n        this._moveFlightToFraction(1.0); // Skip to final frustum\n    }\n}\n//# sourceMappingURL=GlobeAnimator.js.map",
      "start": 1693508119308,
      "end": 1693508119459,
      "sourcemaps": null
    }
  ]
}
