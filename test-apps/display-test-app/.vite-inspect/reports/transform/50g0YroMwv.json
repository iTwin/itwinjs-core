{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/numerics/BezierPolynomials.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\n// import { Angle, AngleSweep, Geometry } from \"../Geometry\";\nimport { Geometry } from \"../Geometry\";\nimport { PascalCoefficients } from \"./PascalCoefficients\";\nimport { AnalyticRoots, Degree2PowerPolynomial } from \"./Polynomials\";\n/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.\n * * The base class carries a Float64Array with coefficients.\n * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.\n * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.\n * * The general degree Bezier class also uses this as its base class.\n * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.\n * @internal\n */\nexport class BezierCoffs {\n    /**\n     * * If `data` is a number, an array of that size is created with zeros.\n     * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)\n     * * If `data` is a number array, its values are copied.\n     */\n    constructor(data) {\n        if (data instanceof Float64Array) {\n            this.coffs = data.slice();\n        }\n        else if (Array.isArray(data)) {\n            this.coffs = new Float64Array(data.length);\n            let i = 0;\n            for (const a of data)\n                this.coffs[i++] = a;\n        }\n        else {\n            this.coffs = new Float64Array(data);\n        }\n    }\n    /**\n     * * Ensure the coefficient array size matches order.  (Reallocate as needed)\n     * * fill with zeros.\n     * @param order required order\n     */\n    allocateToOrder(order) {\n        if (this.coffs.length !== order) {\n            this.coffs = new Float64Array(order);\n        }\n        else {\n            this.coffs.fill(0);\n        }\n    }\n    /**\n     * create an object of same order with zero coefficients.\n     * The base implementation makes a generic Bezier of the same order.\n     */\n    createPeer() {\n        const peer = new UnivariateBezier(this.order);\n        return peer;\n    }\n    /** The order (number of coefficients) as a readable property  */\n    get order() { return this.coffs.length; }\n    /** Copy coefficients from other Bezier. Note that the coefficient count (order) of \"this\" can change. */\n    copyFrom(other) {\n        if (this.order === other.order)\n            for (let i = 0; i < this.coffs.length; i++) {\n                this.coffs[i] = other.coffs[i];\n            }\n        else\n            this.coffs = other.coffs.slice();\n    }\n    /**\n     * Apply a scale factor to all coefficients.\n     * @param scale scale factor to apply to all coefficients.\n     */\n    scaleInPlace(scale) {\n        for (let i = 0; i < this.coffs.length; i++)\n            this.coffs[i] *= scale;\n    }\n    /** add a constant to each coefficient.\n     * @param a constant to add.\n     */\n    addInPlace(a) {\n        for (let i = 0; i < this.coffs.length; i++)\n            this.coffs[i] += a;\n    }\n    /** Compute parameter values where the bezier value matches _targetValue.\n     * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)\n     * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.\n     */\n    roots(targetValue, _restrictTo01) {\n        const bezier = UnivariateBezier.create(this);\n        bezier.addInPlace(-targetValue);\n        return UnivariateBezier.deflateRoots01(bezier);\n    }\n    /** Given an array of numbers, optionally remove those not in the 0..1 interval.\n     * @param roots candidate values\n     * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.\n     *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.\n     */\n    filter01(roots, restrictTo01 = false) {\n        if (!roots || !restrictTo01)\n            return roots;\n        let anyFound = false;\n        for (const r of roots) {\n            if (Geometry.isIn01(r)) {\n                anyFound = true;\n                break;\n            }\n        }\n        if (anyFound) {\n            const roots01 = [];\n            for (const r of roots) {\n                if (Geometry.isIn01(r))\n                    roots01.push(r);\n            }\n            return roots01;\n        }\n        return undefined;\n    }\n    /** zero out all coefficients. */\n    zero() { this.coffs.fill(0); }\n    /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */\n    subdivide(u, left, right) {\n        const order = this.order;\n        if (left.order !== order || right.order !== order)\n            return false;\n        const v = 1.0 - u;\n        right.copyFrom(this);\n        // each left will be filled in directly, so there is no need to initialize it.\n        let n1 = order - 1; // number of interpolations in inner loop.\n        for (let i0 = 0; i0 < order; i0++) {\n            left.coffs[i0] = right.coffs[0];\n            for (let i = 0; i < n1; i++)\n                right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];\n            n1--;\n        }\n        return true;\n    }\n    /** Return the maximum absolute difference between coefficients of two sets of BezierCoffs */\n    static maxAbsDiff(dataA, dataB) {\n        const order = dataA.order;\n        if (dataB.order !== order)\n            return undefined;\n        let d = 0.0;\n        let d1;\n        for (let i = 0; i < order; i++) {\n            d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);\n            if (d1 > d)\n                d = d1;\n        }\n        return d;\n    }\n}\n/**\n * Static methods to operate on univariate bezier polynomials, with coefficients in simple Float64Array or as components of blocked arrays.\n * @internal\n */\nexport class BezierPolynomialAlgebra {\n    /**\n     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\n     * * Symbolically:   `product(s) += scale * (constA - polynomialA(s)) *polynomialB(s)`\n     * * Where coefficients of polynomialA(s) are in column indexA and coefficients of polynomialB(s) are differences within column indexB.\n     * * Treating data as 2-dimensional array:   `product = sum (iA) sum (iB)    (constA - basisFunction[iA} data[indexA][iA]) * basisFunction[iB] * (dataOrder-1)(data[iB + 1][indexB] - data[iB][indexB])`\n     * * Take no action if product length is other than `dataOrder + dataOrder - 2`\n     */\n    static accumulateScaledShiftedComponentTimesComponentDelta(product, data, dataBlockSize, dataOrder, scale, indexA, constA, indexB) {\n        const orderB = dataOrder - 1; // coefficients of the first difference are implicitly present as differences of adjacent entries.\n        const orderA = dataOrder;\n        const orderC = dataOrder + orderB - 1;\n        if (product.length !== orderC)\n            return;\n        const coffA = PascalCoefficients.getRow(orderA - 1);\n        const coffB = PascalCoefficients.getRow(orderB - 1);\n        const coffC = PascalCoefficients.getRow(orderC - 1);\n        let qA;\n        for (let a = 0; a < orderA; a++) {\n            qA = scale * (constA + data[indexA + a * dataBlockSize]) * coffA[a];\n            for (let b = 0, k = indexB; b < orderB; b++, k += dataBlockSize) {\n                product[a + b] += qA * coffB[b] * (data[k + dataBlockSize] - data[k]) / coffC[a + b];\n            }\n        }\n    }\n    /**\n     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\n     * * Univariate bezierB has its coefficients at offset indexB in each block within the array of blocks.\n     * * return the sum coefficients for `constA * polynomialA + constB * polynomialB`\n     * * Symbolically:   `product(s) = (constA * polynomialA(s) + constB * polynomialB(s)`\n     * * The two polynomials are the same order, so this just direct sum of scaled coefficients.\n     *\n     * * Take no action if product length is other than `dataOrder + dataOrder - 2`\n     */\n    static scaledComponentSum(sum, data, dataBlockSize, dataOrder, indexA, constA, indexB, constB) {\n        const orderA = dataOrder;\n        if (sum.length !== orderA)\n            return;\n        for (let a = 0, rowBase = 0; a < orderA; a++, rowBase += dataBlockSize) {\n            sum[a] = constA * data[rowBase + indexA] + constB * data[rowBase + indexB];\n        }\n    }\n    /**\n     * * Univariate bezier has its coefficients at offset index in each block within the array of blocks.\n     * * return the (dataOrder - 1) differences,\n     *\n     * * Take no action if difference length is other than `dataOrder - 1`\n     */\n    static componentDifference(difference, data, dataBlockSize, dataOrder, index) {\n        const orderA = dataOrder;\n        const orderDiff = orderA - 1;\n        if (difference.length !== orderDiff)\n            return;\n        for (let i = 0, k = index; i < orderDiff; k += dataBlockSize, i++)\n            difference[i] = data[k + dataBlockSize] - data[k];\n    }\n    /**\n     * * Univariate bezierA has its coefficients in dataA[i]\n     * * Univariate bezierB has its coefficients in dataB[i]\n     * * return the product coefficients for polynomialA(s) * polynomialB(s) * scale\n     * * Take no action if product length is other than `orderA + orderB - 1`\n     */\n    static accumulateProduct(product, dataA, dataB, scale = 1.0) {\n        const orderA = dataA.length;\n        const orderB = dataB.length;\n        const orderC = orderA + orderB - 1;\n        if (product.length !== orderC)\n            return;\n        let a;\n        let b;\n        let qA;\n        const coffA = PascalCoefficients.getRow(orderA - 1);\n        const coffB = PascalCoefficients.getRow(orderB - 1);\n        const coffC = PascalCoefficients.getRow(orderC - 1);\n        for (a = 0; a < orderA; a++) {\n            qA = scale * coffA[a] * dataA[a];\n            for (b = 0; b < orderB; b++) {\n                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\n            }\n        }\n    }\n    /**\n     * * Univariate bezierA has its coefficients in dataA[i]\n     * * Univariate bezierB has its coefficients in dataB[i]\n     * * return the product coefficients for polynomialADifferences(s) * polynomialB(s) * scale\n     * * Take no action if product length is other than `orderA + orderB - 2`\n     */\n    static accumulateProductWithDifferences(product, dataA, dataB, scale = 1.0) {\n        const orderA = dataA.length - 1; // We deal with its differences, which are lower order !!!\n        const orderB = dataB.length;\n        const orderC = orderA + orderB - 1;\n        if (product.length !== orderC)\n            return;\n        let a;\n        let b;\n        let qA;\n        const coffA = PascalCoefficients.getRow(orderA - 1);\n        const coffB = PascalCoefficients.getRow(orderB - 1);\n        const coffC = PascalCoefficients.getRow(orderC - 1);\n        for (a = 0; a < orderA; a++) {\n            qA = scale * coffA[a] * (dataA[a + 1] - dataA[a]);\n            for (b = 0; b < orderB; b++) {\n                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\n            }\n        }\n    }\n    /**\n     * * Univariate bezier has its coefficients in data[i]\n     * * return the difference data[i+1]-data[i] in difference.\n     * * Take no action if product length is other than `orderA + orderB - 1`\n     */\n    static univariateDifference(data, difference) {\n        const differenceOrder = difference.length;\n        if (difference.length + 1 !== differenceOrder)\n            for (let i = 0; i < differenceOrder; i++) {\n                difference[i] = data[i + 1] - data[i];\n            }\n    }\n    /**\n     * * Univariate bezierA has its coefficients in dataA[i]\n     * * Univariate bezierB has its coefficients in resultB[i]\n     * * add (with no scaling) bezierA to bezierB\n     * * Take no action if resultB.length is other than dataA.length.\n     */\n    static accumulate(dataA, orderA, resultB) {\n        if (resultB.length !== orderA)\n            return;\n        for (let i = 0; i < orderA; i++) {\n            resultB[i] += dataA[i];\n        }\n    }\n}\n/**\n * * The UnivariateBezier class is a univariate bezier polynomial with no particular order.\n * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- can be used when a fixed order is known and the more specialized implementations are appropriate.\n * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)\n *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the\n *     curve order.   Hence those polynomials commonly reach degree 8 to 12.\n * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.\n * * Some machine-level constraints apply for curves of extremely high order, e.g. 70.   For instance, at that level use of\n *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that\n *     large.\n * @internal\n */\nexport class UnivariateBezier extends BezierCoffs {\n    /** Query the order of this bezier. */\n    get order() { return this._order; }\n    constructor(data) {\n        super(data);\n        this._order = super.order;\n    }\n    /** (Re) initialize with given order (and all coffs zero) */\n    allocateOrder(order) {\n        if (this._order !== order) {\n            super.allocateToOrder(order);\n            this._order = order;\n        }\n        this.coffs.fill(0);\n    }\n    /** Return a copy, optionally with coffs array length reduced to actual order. */\n    clone(compressToMinimalAllocation = false) {\n        if (compressToMinimalAllocation) {\n            const result1 = new UnivariateBezier(this.order);\n            result1.coffs = this.coffs.slice(0, this.order);\n            return result1;\n        }\n        const result = new UnivariateBezier(this.coffs.length);\n        result._order = this._order;\n        result.coffs = this.coffs.slice();\n        return result;\n    }\n    /** Create a new bezier which is a copy of other.\n     * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`\n     * @param other coefficients to copy.\n     */\n    static create(other) {\n        const result = new UnivariateBezier(other.order);\n        result.coffs = other.coffs.slice();\n        return result;\n    }\n    /**\n     * copy coefficients into a new bezier.\n     * @param coffs coefficients for bezier\n     */\n    static createCoffs(data) {\n        return new UnivariateBezier(data);\n    }\n    /**\n     * copy coefficients into a new bezier.\n     * * if result is omitted, a new UnivariateBezier is allocated and returned.\n     * * if result is present but has other order, its coefficients are reallocated\n     * * if result is present and has matching order, the values are replace.\n     * @param coffs coefficients for bezier\n     * @param index0 first index to access\n     * @param order number of coefficients, i.e. order for the result\n     * @param result optional result.\n     *\n     */\n    static createArraySubset(coffs, index0, order, result) {\n        if (!result)\n            result = new UnivariateBezier(order);\n        else if (result.order !== order)\n            result.allocateToOrder(order);\n        for (let i = 0; i < order; i++)\n            result.coffs[i] = coffs[index0 + i];\n        return result;\n    }\n    /**\n     * Create a product of 2 bezier polynomials.\n     * @param bezierA\n     * @param bezierB\n     */\n    static createProduct(bezierA, bezierB) {\n        const result = new UnivariateBezier(bezierA.order + bezierB.order - 1);\n        const pascalA = PascalCoefficients.getRow(bezierA.order - 1);\n        const pascalB = PascalCoefficients.getRow(bezierB.order - 1);\n        const pascalC = PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);\n        for (let iA = 0; iA < bezierA.order; iA++) {\n            const a = bezierA.coffs[iA] * pascalA[iA];\n            for (let iB = 0; iB < bezierB.order; iB++) {\n                const b = bezierB.coffs[iB] * pascalB[iB];\n                const iC = iA + iB;\n                const c = pascalC[iC];\n                result.coffs[iC] += a * b / c;\n            }\n        }\n        return result;\n    }\n    /**\n     * Add a squared bezier polynomial (given as simple coffs)\n     * @param coffA coefficients of bezier to square\n     * @param scale scale factor\n     * @return false if order mismatch -- must have `2 * bezierA.length  === this.order + 1`\n     */\n    addSquaredSquaredBezier(coffA, scale) {\n        const orderA = coffA.length;\n        const orderC = this.order;\n        if (orderA * 2 !== orderC + 1)\n            return false;\n        const pascalA = PascalCoefficients.getRow(orderA - 1);\n        const pascalC = PascalCoefficients.getRow(orderC - 1);\n        const coffC = this.coffs;\n        for (let iA = 0; iA < orderA; iA++) {\n            const a = coffA[iA] * pascalA[iA] * scale;\n            for (let iB = 0; iB < orderA; iB++) {\n                const b = coffA[iB] * pascalA[iB];\n                const iC = iA + iB;\n                const c = pascalC[iC];\n                coffC[iC] += a * b / c;\n            }\n        }\n        return true;\n    }\n    /** Add a constant to each coefficient */\n    addConstant(a) {\n        for (let i = 0; i < this.coffs.length; i++) {\n            this.coffs[i] += a;\n        }\n    }\n    /** evaluate the basis functions at specified u.\n     * @param u bezier parameter for evaluation.\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    basisFunctions(u, result) {\n        this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\n        if (!result || result.length !== this.order)\n            result = new Float64Array(this.order);\n        let i = 0;\n        for (const a of this._basisValues)\n            result[i++] = a;\n        return result;\n    }\n    /**\n     * Sum weights[i] * data[...] in blocks of numPerBlock.\n     * This is for low level use -- counts are not checked.\n     * @param weights\n     * @param data\n     * @param numPerBlock\n     */\n    static sumWeightedBlocks(weights, numWeights, data, numPerBlock, result) {\n        for (let k0 = 0; k0 < numPerBlock; k0++) {\n            result[k0] = 0;\n        }\n        let k = 0;\n        let i;\n        for (let iWeight = 0; iWeight < numWeights; iWeight++) {\n            const w = weights[iWeight];\n            for (i = 0; i < numPerBlock; i++) {\n                result[i] += w * data[k++];\n            }\n        }\n    }\n    /**\n     * Given (multidimensional) control points, sum the control points weighted by the basis function values at parameter u.\n     * @param u bezier parameter\n     * @param polygon Array with coefficients in blocks.\n     * @param blockSize size of blocks\n     * @param result `blockSize` summed values.\n     */\n    sumBasisFunctions(u, polygon, blockSize, result) {\n        const order = this._order;\n        if (!result)\n            result = new Float64Array(order);\n        this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\n        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\n        return result;\n    }\n    /**\n     * Given (multidimensional) control points, sum the control points weighted by the basis function derivative values at parameter u.\n     * @param u bezier parameter\n     * @param polygon Array with coefficients in blocks.\n     * @param blockSize size of blocks\n     * @param result `blockSize` summed values.\n     */\n    sumBasisFunctionDerivatives(u, polygon, blockSize, result) {\n        const order = this._order;\n        if (!result)\n            result = new Float64Array(blockSize);\n        this._basisValues = PascalCoefficients.getBezierBasisDerivatives(this.order, u, this._basisValues);\n        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\n        return result;\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluate(u) {\n        this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\n        let sum = 0;\n        for (let i = 0; i < this.order; i++)\n            sum += this._basisValues[i] * this.coffs[i];\n        return sum;\n    }\n    /**\n     * Apply deflation from the left to a bezier.\n     * * This assumes that the left coefficient is zero.\n     */\n    deflateLeft() {\n        // coefficient 0 is zero (caller promises.)\n        // get bezier coffs for both orders ...\n        const order1 = this.order;\n        const order0 = order1 - 1;\n        const coff0 = PascalCoefficients.getRow(order0 - 1);\n        const coff1 = PascalCoefficients.getRow(order1 - 1);\n        let a;\n        for (let i = 0; i < order0; i++) {\n            a = this.coffs[i + 1];\n            this.coffs[i] = a * coff1[i + 1] / coff0[i];\n        }\n        this._order--;\n    }\n    /**\n     * Apply deflation from the right to a frame.\n     * * This assumes that the right coefficient is zero.\n     * @param frame frame description\n     */\n    deflateRight() {\n        // final coefficient is zero (caller promises.)\n        // get bezier coffs for both orders ...\n        const order1 = this.order;\n        const order0 = order1 - 1;\n        const coff0 = PascalCoefficients.getRow(order0 - 1);\n        const coff1 = PascalCoefficients.getRow(order1 - 1);\n        let a, b;\n        for (let i = 0; i < order0; i++) {\n            a = this.coffs[i];\n            b = a * coff1[i] / coff0[i];\n            this.coffs[i] = b;\n        }\n        this._order--;\n    }\n    /**\n     * * divide the polynomial by `(x-root)`.\n     * * return the remainder\n     * * If `root` truly is a root, the return is zero.\n     * @param root root to remove\n     */\n    deflateRoot(root) {\n        const orderA = this.order;\n        const orderC = orderA - 1; // the order of the deflated bezier.\n        if (orderA === 1) {\n            this._order = 0;\n            return this.coffs[0];\n        }\n        if (orderA < 1) {\n            this._order = 0;\n            return 0.0;\n        }\n        const pascalA = PascalCoefficients.getRow(orderA - 1);\n        const pascalC = PascalCoefficients.getRow(orderC - 1);\n        const b0 = -root;\n        const b1 = 1.0 - root;\n        let remainder = 0;\n        if (root > 0.5) {\n            let c0 = this.coffs[0] / b0;\n            let c1;\n            this.coffs[0] = c0;\n            let a1;\n            for (let i = 1; i < orderC; i++) {\n                a1 = this.coffs[i] * pascalA[i];\n                c1 = (a1 - c0 * b1) / b0;\n                this.coffs[i] = c1 / pascalC[i];\n                c0 = c1;\n            }\n            remainder = this.coffs[orderA - 1] - c0 * b1;\n        }\n        else {\n            // work backwards (to get division by larger of b0, b1)\n            // replace coefficients of a starting with orderA -1 --\n            // at end move them all forward.\n            let c1 = this.coffs[orderA - 1] / b1;\n            let c0;\n            this.coffs[orderA - 1] = c1;\n            let a1;\n            for (let i = orderA - 2; i > 0; i--) {\n                a1 = this.coffs[i] * pascalA[i];\n                c0 = (a1 - c1 * b0) / b1;\n                this.coffs[i] = c0 / pascalC[i - 1]; // pascalC index is from destination, which is not shifted.\n                c1 = c0;\n            }\n            remainder = (this.coffs[0] - c1 * b0);\n            for (let i = 0; i < orderC; i++)\n                this.coffs[i] = this.coffs[i + 1];\n        }\n        this._order = orderC;\n        // This should be zero !!!! (If not, `root` was not really a root!!)\n        return remainder;\n    }\n    /**\n     * Run a Newton iteration from startFraction.\n     * @param startFraction [in] fraction for first iteration\n     * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the\n     * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass\n     * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting\n     * that the final iteration will clean it up to nearly machine precision.\n     * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.\n     */\n    runNewton(startFraction, tolerance = 1.0e-11) {\n        const derivativeFactor = this.order - 1;\n        let numConverged = 0;\n        let u = startFraction;\n        let f, df;\n        const bigStep = 10.0;\n        const order = this.order;\n        const coffs = this.coffs;\n        const orderD = order - 1;\n        for (let iterations = 0; iterations++ < 10;) {\n            UnivariateBezier._basisBuffer = PascalCoefficients.getBezierBasisValues(order, u, UnivariateBezier._basisBuffer);\n            f = 0;\n            for (let i = 0; i < order; i++)\n                f += coffs[i] * UnivariateBezier._basisBuffer[i];\n            UnivariateBezier._basisBuffer1 = PascalCoefficients.getBezierBasisValues(orderD, u, UnivariateBezier._basisBuffer1);\n            df = 0;\n            for (let i = 0; i < orderD; i++)\n                df += (coffs[i + 1] - coffs[i]) * UnivariateBezier._basisBuffer1[i];\n            df *= derivativeFactor;\n            if (Math.abs(f) > bigStep * Math.abs(df))\n                return undefined;\n            const du = f / df;\n            if (Math.abs(du) < tolerance) {\n                numConverged++;\n                if (numConverged >= 2)\n                    return u - du;\n            }\n            else {\n                numConverged = 0;\n            }\n            u -= du;\n        }\n        return undefined;\n    }\n    // Deflation table.  b0, b1 are coefficients of term being divided out\n    // Pascal coffs for b0,b1 are just 1.\n    // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.\n    // each ci is a coefficient of the (unknown) result, with its coefficient blended in.\n    // note b0, b1 are both nonzero, so the divisions are safe.\n    // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]\n    // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]\n    // |    |  b0    | b1      |   equivalence               | solve moving down\n    // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0\n    // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0\n    // | c2 | c2* b0 | c2 * b1\n    // Each internal ci = (ai - c[i-1] * b1) /b0\n    // first c0*b0 = a0\n    // last c[orderC-1]*b1 = a[orderA-1]\n    /** Find roots of a bezier polynomial\n     * * Only look for roots in 0..1\n     * * As roots are found, deflate the polynomial.\n     * * bezier coffs are changed (and order reduced) at each step.\n     */\n    static deflateRoots01(bezier) {\n        const roots = [];\n        const coffs = bezier.coffs;\n        let a0, a1, segmentFraction, globalStartFraction, newtonFraction;\n        while (bezier.order > 1) {\n            const order = bezier.order;\n            // Find any crossing\n            if (coffs[0] === 0.0) {\n                bezier.deflateLeft();\n                roots.push(0.0);\n                continue;\n            }\n            let numCrossing = 0;\n            let numNewtonOK = 0;\n            for (let i = 1; i < order; i++) {\n                a0 = coffs[i - 1];\n                a1 = coffs[i];\n                if (a0 * a1 <= 0.0) {\n                    numCrossing++;\n                    segmentFraction = -a0 / (a1 - a0);\n                    globalStartFraction = (i - 1 + segmentFraction) / (order - 1);\n                    newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);\n                    if (newtonFraction !== undefined) {\n                        roots.push(newtonFraction);\n                        bezier.deflateRoot(newtonFraction);\n                        numNewtonOK++;\n                        break;\n                    }\n                }\n            }\n            if (numNewtonOK)\n                continue;\n            // if any crossing was found and led to a good newton, the \"continue\" jumped past this.\n            // if no crossings found, there are no roots to be had -- accept\n            if (numCrossing === 0)\n                return roots;\n            // reach here if there were crossings but not roots.\n            // is this just a local min?  or maybe a big problem?   Whatever, accept it\n            return roots;\n        }\n        return roots;\n    }\n}\n/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function)\\\n * @internal\n */\nexport class Order2Bezier extends BezierCoffs {\n    constructor(f0 = 0.0, f1 = 0.0) {\n        super(2);\n        this.coffs[0] = f0;\n        this.coffs[1] = f1;\n    }\n    /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */\n    clone() {\n        return new Order2Bezier(this.coffs[0], this.coffs[1]);\n    }\n    /** normally, return fractional coordinate where bezier (a0,a1) has a root.\n     * but if the fraction would exceed Geometry.largeFractionResult, return undefined.\n     */\n    static solveCoffs(a0, a1) {\n        return Geometry.conditionalDivideFraction(-a0, (a1 - a0));\n    }\n    /** evaluate the basis functions at specified u.\n     * @param u bezier parameter for evaluation.\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    basisFunctions(u, result) {\n        if (!result)\n            result = new Float64Array(2);\n        result[0] = 1.0 - u;\n        result[1] = u;\n        return result;\n    }\n    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctions(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1.0 - u;\n        for (let i = 0; i < n; i++) {\n            result[i] = v * polygon[i] + u * polygon[i + n];\n        }\n        return result;\n    }\n    /** evaluate the blocked derivative at u.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctionDerivatives(_u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = polygon[i + n] - polygon[i];\n        }\n        return result;\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluate(u) {\n        return (1.0 - u) * this.coffs[0] + u * this.coffs[1];\n    }\n    /** Same as `roots` method but returns single numeric value instead of array. */\n    solve(rightHandSide) {\n        const df = this.coffs[1] - this.coffs[0];\n        return Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);\n    }\n    /**\n     * Concrete implementation of the abstract roots method\n     * @param targetValue target function value.\n     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\n     * @returns If no roots, return undefined.  If single root, return an array with the root.\n     */\n    roots(targetValue, restrictTo01) {\n        const x = this.solve(targetValue);\n        if (x === undefined)\n            return undefined;\n        if (!restrictTo01 || Geometry.isIn01(x))\n            return [x];\n        return undefined;\n    }\n}\n/** Bezier polynomial specialized to order 3 (3 coefficients, parabola  function)\n * @internal\n */\nexport class Order3Bezier extends BezierCoffs {\n    constructor(f0 = 0, f1 = 0, f2 = 0) {\n        super(3);\n        this.coffs[0] = f0;\n        this.coffs[1] = f1;\n        this.coffs[2] = f2;\n    }\n    /** Return a deep copy. */\n    clone() {\n        return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);\n    }\n    /** evaluate the basis functions at specified u.\n     * @param u bezier parameter for evaluation.\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    basisFunctions(u, result) {\n        if (!result)\n            result = new Float64Array(3);\n        const v = 1.0 - u;\n        result[0] = v * v;\n        result[1] = 2.0 * u * v;\n        result[2] = u * u;\n        return result;\n    }\n    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctions(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1 - u;\n        const b0 = v * v;\n        const b1 = 2 * u * v;\n        const b2 = u * u;\n        for (let i = 0; i < n; i++) {\n            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n];\n        }\n        return result;\n    }\n    /** evaluate the blocked derivative at u.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctionDerivatives(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const f0 = 2 * (1 - u);\n        const f1 = 2 * u;\n        const n2 = 2 * n;\n        for (let i = 0; i < n; i++) {\n            const q = polygon[i + n];\n            result[i] = f0 * (q - polygon[i]) + f1 * (polygon[i + n2] - q);\n        }\n        return result;\n    }\n    /**\n     * Add the square of a linear bezier.\n     * @param f0 linear factor value at u=0.\n     * @param f1 linear factor value at u=1.\n     * @param a  scale factor.\n     */\n    addSquareLinear(f0, f1, a) {\n        this.coffs[0] += a * f0 * f0;\n        this.coffs[1] += a * f0 * f1;\n        this.coffs[2] += a * f1 * f1;\n    }\n    /**\n     * Concrete implementation of the abstract roots method\n     * @param targetValue target function value.\n     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\n     * @returns If no roots, return undefined.  If roots exist, return as numeric array.\n     */\n    roots(targetValue, restrictTo01) {\n        const a0 = this.coffs[0] - targetValue;\n        const a1 = this.coffs[1] - targetValue;\n        const a2 = this.coffs[2] - targetValue;\n        const a01 = a1 - a0;\n        const a12 = a2 - a1;\n        const a012 = a12 - a01;\n        const roots = Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);\n        return super.filter01(roots, restrictTo01);\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluate(u) {\n        const v = 1.0 - u;\n        return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);\n    }\n}\n/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function)\n * @internal\n */\nexport class Order4Bezier extends BezierCoffs {\n    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0) {\n        super(4);\n        this.coffs[0] = f0;\n        this.coffs[1] = f1;\n        this.coffs[2] = f2;\n        this.coffs[3] = f3;\n    }\n    /** return a deep copy */\n    clone() {\n        return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);\n    }\n    /** Create a product of a quadratic and a cubic. */\n    static createProductOrder3Order2(factorA, factorB) {\n        return new Order4Bezier(factorA.coffs[0] * factorB.coffs[0], (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0, (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0, factorA.coffs[2] * factorB.coffs[1]);\n    }\n    /** evaluate the basis functions at specified u.\n     * @param u bezier parameter for evaluation.\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    basisFunctions(u, result) {\n        if (!result)\n            result = new Float64Array(4);\n        const v = 1.0 - u;\n        const uu = u * u;\n        const vv = v * v;\n        result[0] = vv * v;\n        result[1] = 3.0 * vv * u;\n        result[2] = 3.0 * v * uu;\n        result[3] = u * uu;\n        return result;\n    }\n    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctions(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1 - u;\n        const uu = u * u;\n        const vv = v * v;\n        const b0 = v * vv;\n        const b1 = 3 * u * vv;\n        const b2 = 3 * uu * v;\n        const b3 = u * uu;\n        for (let i = 0; i < n; i++) {\n            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n];\n        }\n        return result;\n    }\n    /** evaluate the blocked derivative at u.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctionDerivatives(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1 - u;\n        // QUADRATIC basis functions applied to differences ... (with factor 3 for derivative)\n        const f0 = 3 * (v * v);\n        const f1 = 6 * u * v;\n        const f2 = 3 * u * u;\n        for (let i = 0; i < n; i++) {\n            const q0 = polygon[i];\n            const q1 = polygon[i + n];\n            const q2 = polygon[i + 2 * n];\n            const q3 = polygon[i + 3 * n];\n            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2);\n        }\n        return result;\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluate(u) {\n        const v1 = 1.0 - u;\n        const v2 = v1 * v1;\n        const v3 = v2 * v1;\n        return this.coffs[0] * v3\n            + u * (3.0 * this.coffs[1] * v2\n                + u * (3.0 * this.coffs[2] * v1\n                    + u * this.coffs[3]));\n    }\n    /**\n     * convert a power polynomial to bezier\n     */\n    static createFromDegree3PowerPolynomial(source) {\n        const f0 = source.evaluate(0.0);\n        const d0 = source.evaluateDerivative(0.0);\n        const d1 = source.evaluateDerivative(1.0);\n        const f1 = source.evaluate(1.0);\n        const a = 3.0;\n        return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);\n    }\n    /** Find real roots, return in caller-allocated array. */\n    realRoots(e, restrictTo01, roots) {\n        // Get direct solutions in standard basis\n        roots.clear();\n        const cc = new Float64Array(4);\n        const y0 = this.coffs[0];\n        const y1 = this.coffs[1];\n        const y2 = this.coffs[2];\n        const y3 = this.coffs[3];\n        const yMax = Math.max(y0, y1, y2, y3);\n        const yMin = Math.min(y0, y1, y2, y3);\n        const smallValue = Geometry.smallMetricDistance;\n        if (yMin > smallValue)\n            return undefined;\n        if (yMax < -smallValue)\n            return undefined;\n        if (yMin >= -smallValue && yMax < smallValue) {\n            // all 4 are near zero . ..\n            roots.push(0);\n            roots.push(1.0 / 3.0);\n            roots.push(2.0 / 3.0);\n            roots.push(1.0);\n            return; // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic\n        }\n        cc[0] = (y0 - e);\n        cc[1] = 3.0 * (y1 - y0);\n        cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);\n        cc[3] = -y0 + 3.0 * y1 - 3.0 * y2 + y3;\n        AnalyticRoots.appendCubicRoots(cc, roots); // can't have zero solutions after passing min/max conditions . . .\n        if (restrictTo01)\n            roots.reassign(0, 1);\n        return;\n    }\n}\n/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function)\n * @internal\n */\nexport class Order5Bezier extends BezierCoffs {\n    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0) {\n        super(5);\n        this.coffs[0] = f0;\n        this.coffs[1] = f1;\n        this.coffs[2] = f2;\n        this.coffs[3] = f3;\n        this.coffs[4] = f4;\n    }\n    /** Return a deep copy */\n    clone() {\n        return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);\n    }\n    /**\n     * convert a power polynomial to bezier\n     */\n    static createFromDegree4PowerPolynomial(source) {\n        const f0 = source.evaluate(0.0);\n        const d0 = source.evaluateDerivative(0.0);\n        const d4 = source.evaluateDerivative(1.0);\n        const f4 = source.evaluate(1.0);\n        const a = 0.25;\n        const d0a = a * d0;\n        const fa = f0 + d0a;\n        const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;\n        return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);\n    }\n    /** evaluate the basis functions at specified u.\n     * @param u bezier parameter for evaluation.\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    basisFunctions(u, result) {\n        if (!result)\n            result = new Float64Array(5);\n        const v = 1.0 - u;\n        const uu = u * u;\n        const uuu = uu * u;\n        const vv = v * v;\n        const vvv = vv * v;\n        result[0] = vv * vv;\n        result[1] = 4.0 * vvv * u;\n        result[2] = 6.0 * vv * uu;\n        result[3] = 4.0 * v * uuu;\n        result[4] = uu * uu;\n        return result;\n    }\n    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctions(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1.0 - u;\n        const uu = u * u;\n        const uuu = uu * u;\n        const vv = v * v;\n        const vvv = vv * v;\n        const b0 = vv * vv;\n        const b1 = 4.0 * vvv * u;\n        const b2 = 6.0 * vv * uu;\n        const b3 = 4.0 * v * uuu;\n        const b4 = uu * uu;\n        for (let i = 0; i < n; i++) {\n            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n] + b4 * polygon[i + 4 * n];\n        }\n        return result;\n    }\n    /** evaluate the blocked derivative at u.\n     * @param u bezier parameter for evaluation.\n     * @param n dimension of control points.\n     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\n     * @param result optional destination for values.   ASSUMED size `order`\n     * @returns Return a (newly allocated) array of basis function values.\n     */\n    sumBasisFunctionDerivatives(u, polygon, n, result) {\n        if (!result)\n            result = new Float64Array(n);\n        const v = 1 - u;\n        // CUBIC basis functions applied to differences ...\n        const uu = u * u;\n        const vv = v * v;\n        const f0 = 4 * v * vv;\n        const f1 = 12 * u * vv;\n        const f2 = 12 * uu * v;\n        const f3 = 4 * u * uu;\n        for (let i = 0; i < n; i++) {\n            const q0 = polygon[i];\n            const q1 = polygon[i + n];\n            const q2 = polygon[i + 2 * n];\n            const q3 = polygon[i + 3 * n];\n            const q4 = polygon[i + 4 * n];\n            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2) + f3 * (q4 - q3);\n        }\n        return result;\n    }\n    /**\n     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\n     * @param u parameter for evaluation\n     */\n    evaluate(u) {\n        const v1 = 1.0 - u;\n        const v2 = v1 * v1;\n        const v3 = v2 * v1;\n        const v4 = v2 * v2;\n        return this.coffs[0] * v4\n            + u * (4.0 * this.coffs[1] * v3\n                + u * (6.0 * this.coffs[2] * v2\n                    + u * (4.0 * this.coffs[3] * v1\n                        + u * this.coffs[4])));\n    }\n    /** Add the product of a pair of Order3Bezier to this one. */\n    addProductOrder3BezierOrder3Bezier(f, g, a) {\n        this.coffs[0] += a * f.coffs[0] * g.coffs[0];\n        this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;\n        this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;\n        this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;\n        this.coffs[4] += a * f.coffs[2] * g.coffs[2];\n    }\n    /** Add a constant to all coefficients (thereby adding the constant to the evaluated bezier) */\n    addConstant(a) {\n        for (let i = 0; i < 5; i++)\n            this.coffs[i] += a;\n    }\n    /** Find real roots, return in caller-allocated array. */\n    realRoots(e, restrictTo01, roots) {\n        roots.clear();\n        const y0 = this.coffs[0] - e;\n        const y1 = this.coffs[1] - e;\n        const y2 = this.coffs[2] - e;\n        const y3 = this.coffs[3] - e;\n        const y4 = this.coffs[4] - e;\n        // Get direct solutions in standard basis\n        const yMax = Math.max(y0, y1, y2, y3, y4);\n        const yMin = Math.min(y0, y1, y2, y3, y4);\n        const smallValue = Geometry.smallMetricDistance;\n        if (yMin > smallValue)\n            return undefined;\n        if (yMax < -smallValue)\n            return undefined;\n        if (yMin >= -smallValue && yMax < smallValue) {\n            // all 4 are near zero . ..\n            roots.push(0);\n            roots.push(0.25);\n            roots.push(0.5);\n            roots.push(0.75);\n            roots.push(1.0);\n            return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...\n        }\n        const cc = new Float64Array(5);\n        cc[0] = (y0 - e);\n        cc[1] = 4.0 * (-y0 + y1);\n        cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);\n        cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);\n        cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);\n        AnalyticRoots.appendQuarticRoots(cc, roots);\n        if (restrictTo01)\n            roots.reassign(0, 1);\n        return;\n    }\n}\n//# sourceMappingURL=BezierPolynomials.js.map",
      "start": 1693508123453,
      "end": 1693508123608,
      "sourcemaps": null
    }
  ]
}
