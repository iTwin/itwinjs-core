{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { BagOfCurves, CurveCollection } from \"./CurveCollection\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { MultiChainCollector } from \"./internalContexts/MultiChainCollector\";\nimport { CurveChainWireOffsetContext } from \"./internalContexts/PolygonOffsetContext\";\nimport { Loop } from \"./Loop\";\nimport { Path } from \"./Path\";\n/**\n * Static methods for miscellaneous curve operations.\n * @public\n */\nexport class CurveOps {\n    /** Recursively sum curve lengths, allowing CurvePrimitive, CurveCollection, or array of such at any level. */\n    static sumLengths(curves) {\n        let mySum = 0;\n        if (curves instanceof CurvePrimitive) {\n            mySum += curves.curveLength();\n        }\n        else if (curves instanceof CurveCollection) {\n            mySum += curves.sumLengths();\n        }\n        else if (Array.isArray(curves)) {\n            for (const data1 of curves)\n                mySum += this.sumLengths(data1);\n        }\n        return mySum;\n    }\n    /** Recursively extend the range by each curve's range, allowing CurvePrimitive, CurveCollection, or array of such at any level. */\n    static extendRange(range, curves) {\n        if (Array.isArray(curves)) {\n            for (const data1 of curves)\n                this.extendRange(range, data1);\n        }\n        else {\n            curves.extendRange(range);\n        }\n        return range;\n    }\n    /**\n     * Construct a separate xy-offset for each input curve.\n     * * For best offset results, the inputs should be parallel to the xy-plane.\n     * @param curves input curve(s), z-coordinates ignored. Only [[ChainTypes]] are handled.\n     * @param offset offset distance (positive to left of curve, negative to right)\n     * @param result array to collect offset curves\n     * @returns summed length of offset curves\n     */\n    static appendXYOffsets(curves, offset, result) {\n        let summedLengths = 0;\n        if (curves instanceof CurvePrimitive) {\n            const resultA = CurveChainWireOffsetContext.constructCurveXYOffset(Path.create(curves), offset);\n            if (resultA) {\n                summedLengths += this.sumLengths(resultA);\n                result.push(resultA);\n            }\n        }\n        else if (curves instanceof Loop || curves instanceof Path) {\n            const resultA = CurveChainWireOffsetContext.constructCurveXYOffset(curves, offset);\n            if (resultA) {\n                summedLengths += this.sumLengths(resultA);\n                result.push(resultA);\n            }\n        }\n        else if (curves instanceof BagOfCurves) {\n            for (const q of curves.children)\n                summedLengths += this.appendXYOffsets(q, offset, result);\n        }\n        else if (Array.isArray(curves)) {\n            for (const q of curves)\n                summedLengths += this.appendXYOffsets(q, offset, result);\n        }\n        return summedLengths;\n    }\n    /**\n     * Restructure curve fragments as Paths and Loops, and construct xy-offsets of the chains.\n     * * If the inputs do not form Loop(s), the classification of offsets is suspect.\n     * * For best offset results, the inputs should be parallel to the xy-plane.\n     * * Chain formation is dependent upon input fragment order, as a greedy algorithm is employed.\n     * @param fragments fragments to be chained and offset\n     * @param offsetDistance offset distance, applied to both sides of each fragment to produce inside and outside xy-offset curves.\n     * @param gapTolerance distance to be treated as \"effectively zero\" when joining head-to-tail\n     * @returns object with named chains, insideOffsets, outsideOffsets\n     */\n    static collectInsideAndOutsideXYOffsets(fragments, offsetDistance, gapTolerance) {\n        const collector = new MultiChainCollector(gapTolerance);\n        for (const s of fragments) {\n            collector.captureCurve(s);\n        }\n        const chains = collector.grabResult(true);\n        const myOffsetA = [];\n        const myOffsetB = [];\n        const offsetLengthA = CurveOps.appendXYOffsets(chains, offsetDistance, myOffsetA);\n        const offsetLengthB = CurveOps.appendXYOffsets(chains, -offsetDistance, myOffsetB);\n        if (offsetLengthA > offsetLengthB) {\n            return { outsideOffsets: myOffsetA, insideOffsets: myOffsetB, chains };\n        }\n        else {\n            return { insideOffsets: myOffsetA, outsideOffsets: myOffsetB, chains };\n        }\n    }\n    /**\n     * Construct curves that are offset from a Path or Loop as viewed in xy-plane (ignoring z).\n     * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will not detect self intersection among widely separated edges.\n     * @param curves base curves.\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or options object.\n     */\n    static constructCurveXYOffset(curves, offsetDistanceOrOptions) {\n        return CurveChainWireOffsetContext.constructCurveXYOffset(curves, offsetDistanceOrOptions);\n    }\n    /**\n     * Create the offset of a single curve primitive as viewed in the xy-plane (ignoring z).\n     * @param curve primitive to offset\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or options object\n     */\n    static createSingleOffsetPrimitiveXY(curve, offsetDistanceOrOptions) {\n        return CurveChainWireOffsetContext.createSingleOffsetPrimitiveXY(curve, offsetDistanceOrOptions);\n    }\n    /**\n     * Restructure curve fragments as Paths and Loops.\n     * * Chain formation is dependent upon input fragment order, as a greedy algorithm is employed.\n     * @param fragments fragments to be chained\n     * @param gapTolerance distance to be treated as \"effectively zero\" when assembling fragments head-to-tail\n     * @param planeTolerance tolerance for considering a closed chain to be planar. If undefined, only create Path. If defined, create Loops for closed chains within tolerance of a plane.\n     * @returns chains, possibly wrapped in a [[BagOfCurves]].\n     */\n    static collectChains(fragments, gapTolerance = Geometry.smallMetricDistance, planeTolerance = Geometry.smallMetricDistance) {\n        const collector = new MultiChainCollector(gapTolerance, planeTolerance);\n        for (const s of fragments) {\n            collector.captureCurve(s);\n        }\n        return collector.grabResult(true);\n    }\n    /**\n     * Restructure curve fragments as Paths and Loops, to be stroked and passed into the callback.\n     * * Chain formation is dependent upon input fragment order, as a greedy algorithm is employed.\n     * @param fragments fragments to be chained and stroked\n     * @param announceChain callback to process each stroked Path and Loop\n     * @param strokeOptions options for stroking the chains\n     * @param gapTolerance distance to be treated as \"effectively zero\" when assembling fragments head-to-tail. Also used for removing duplicate points in the stroked chains.\n     * @param planeTolerance tolerance for considering a closed chain to be planar. If undefined, only create Path. If defined, create Loops for closed chains within tolerance of a plane.\n     */\n    static collectChainsAsLineString3d(fragments, announceChain, strokeOptions, gapTolerance = Geometry.smallMetricDistance, planeTolerance = Geometry.smallMetricDistance) {\n        const collector = new MultiChainCollector(gapTolerance, planeTolerance);\n        for (const s of fragments) {\n            collector.captureCurve(s);\n        }\n        collector.announceChainsAsLineString3d(announceChain, strokeOptions);\n    }\n}\n//# sourceMappingURL=CurveOps.js.map",
      "start": 1693508123589,
      "end": 1693508123752,
      "sourcemaps": null
    }
  ]
}
