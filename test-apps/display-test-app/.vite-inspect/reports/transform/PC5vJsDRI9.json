{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/CurveCurveCloseApproachXY.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../../bspline/BSplineCurve\";\nimport { Geometry } from \"../../Geometry\";\nimport { RecurseToCurvesGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { GrowableFloat64Array } from \"../../geometry3d/GrowableFloat64Array\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Range3d } from \"../../geometry3d/Range\";\nimport { AnalyticRoots, SmallSystem } from \"../../numerics/Polynomials\";\nimport { Arc3d } from \"../Arc3d\";\nimport { CurveChain } from \"../CurveCollection\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveLocationDetailPair } from \"../CurveLocationDetail\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\n// cspell:word XYRR\n/**\n * Handler class for XY close approach between _geometryB and another geometry.\n * * Approach means the XY distance (z is ignored) between _geometryB and another geometry.\n * * Closest approach is a measure of the proximity of one curve to another. It's the length of the shortest line\n * segment perpendicular to both curves; if the curves intersect, the closest approach is zero. In the context of\n * this class, z-coordinates are ignored, so the closest approach is as seen in the top view. If you have coplanar\n * input curves and want to find closest approach in their plane, rotate them first into a plane parallel to the\n * xy-plane, then afterward, rotate the results back as required.\n * * Close approach can also be from a curve endpoint perpendicular to another curve or from a curve endpoint to\n * another curve endpoint.\n * * Instances are initialized and called from CurveCurve.\n * * geometryB is saved for later reference.\n * @internal\n */\nclass CurveCurveCloseApproachXY extends RecurseToCurvesGeometryHandler {\n    setGeometryB(geometryB) {\n        this._geometryB = geometryB;\n        this._circularArcB = undefined;\n        this._circularRadiusB = undefined;\n        if (geometryB instanceof Arc3d) {\n            const r = geometryB.circularRadiusXY();\n            if (r !== undefined) {\n                this._circularRadiusB = r;\n                this._circularArcB = geometryB;\n            }\n        }\n    }\n    reinitialize() {\n        this._results = [];\n    }\n    /**\n     * Constructor.\n     * @param geometryB second curve for intersection. Saved for reference by specific handler methods.\n     */\n    constructor(geometryB) {\n        super();\n        this.setGeometryB(geometryB);\n        this._maxDistanceSquared = Geometry.smallMetricDistanceSquared;\n        this.reinitialize();\n    }\n    /** Set the (possibly undefined) max XY distance (z is ignored) to accept. */\n    set maxDistanceToAccept(value) {\n        this._maxDistanceToAccept = value;\n        if (this._maxDistanceToAccept !== undefined && this._maxDistanceToAccept > 0)\n            this._maxDistanceSquared = this._maxDistanceToAccept * this._maxDistanceToAccept;\n    }\n    /** Access the (possibly undefined) max XY distance (z is ignored) to accept. */\n    get maxDistanceToAccept() {\n        return this._maxDistanceToAccept;\n    }\n    /** Ask if the maxDistanceToAccept value is defined and positive */\n    get isMaxDistanceSet() {\n        return this._maxDistanceToAccept !== undefined && this._maxDistanceToAccept > 0;\n    }\n    /** Reset the geometry and flags, leaving all other parts unchanged (and preserving accumulated intersections) */\n    resetGeometry(geometryB) {\n        this.setGeometryB(geometryB);\n    }\n    /** returns true if `fraction` is in [0,1] within tolerance */\n    acceptFraction(fraction, fractionTol = 1.0e-12) {\n        if (fraction < -fractionTol)\n            return false;\n        if (fraction > 1.0 + fractionTol)\n            return false;\n        return true;\n    }\n    /**\n     * Return the results structure for the intersection calculation, structured as an array of CurveLocationDetailPair.\n     * @param reinitialize if true, a new results structure is created for use by later calls.\n     */\n    grabPairedResults(reinitialize = false) {\n        const result = this._results;\n        if (reinitialize)\n            this.reinitialize();\n        return result;\n    }\n    /** Returns `true` if `detail` has same curve and fraction. */\n    sameCurveAndFraction(cp, fraction, detail) {\n        return cp === detail.curve && Geometry.isAlmostEqualNumber(fraction, detail.fraction);\n    }\n    /**\n     * If distance between pointA and pointB is less than maxDistance, record CurveLocationDetailPair which is\n     * the approach from pointA to pointB.\n     */\n    testAndRecordPointPairApproach(cpA, fA, pointA, cpB, fB, pointB, reversed) {\n        const d2 = pointA.distanceSquaredXY(pointB);\n        if (d2 < this._maxDistanceSquared) {\n            const detailA = CurveLocationDetail.createCurveFractionPoint(cpA, fA, pointA);\n            const detailB = CurveLocationDetail.createCurveFractionPoint(cpB, fB, pointB);\n            const pair = CurveLocationDetailPair.createCapture(detailA, detailB);\n            if (reversed)\n                pair.swapDetails();\n            this._results.push(pair);\n        }\n    }\n    /**\n     * Create a close approach pair if XY distance is within maxDistance.\n     * @param localFractionA a fraction on first curve\n     * @param cpA the first curve\n     * @param fractionA0 start of the first curve\n     * @param fractionA1 end of the first curve\n     * @param localFractionB a fraction on second curve\n     * @param cpB the second curve\n     * @param fractionB0 start of the second curve\n     * @param fractionB1 end of the second curve\n     * @param reversed true to have order reversed in final structures\n     * @param intervalDetails optional CurveLocationDetailPair\n     */\n    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, cpB, fractionB0, fractionB1, reversed, intervalDetails) {\n        let globalFractionA, globalFractionB;\n        let globalFractionA1, globalFractionB1;\n        const isInterval = intervalDetails !== undefined &&\n            intervalDetails.detailA.hasFraction1 &&\n            intervalDetails.detailB.hasFraction1;\n        if (isInterval) {\n            globalFractionA = Geometry.interpolate(fractionA0, intervalDetails.detailA.fraction, fractionA1);\n            globalFractionB = Geometry.interpolate(fractionB0, intervalDetails.detailB.fraction, fractionB1);\n            globalFractionA1 = Geometry.interpolate(fractionA0, intervalDetails.detailA.fraction1, fractionA1);\n            globalFractionB1 = Geometry.interpolate(fractionB0, intervalDetails.detailB.fraction1, fractionB1);\n        }\n        else {\n            globalFractionA = globalFractionA1 = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\n            globalFractionB = globalFractionB1 = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\n        }\n        // ignore duplicate of most recent approach\n        const numPrevious = this._results.length;\n        if (numPrevious > 0 && !isInterval) {\n            const oldDetailA = this._results[numPrevious - 1].detailA;\n            const oldDetailB = this._results[numPrevious - 1].detailB;\n            if (reversed) {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailB) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailA))\n                    return;\n            }\n            else {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailA) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailB))\n                    return;\n            }\n        }\n        const detailA = CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, cpA.fractionToPoint(globalFractionA));\n        const detailB = CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, cpB.fractionToPoint(globalFractionB));\n        if (isInterval) {\n            detailA.captureFraction1Point1(globalFractionA1, cpA.fractionToPoint(globalFractionA1));\n            detailB.captureFraction1Point1(globalFractionB1, cpB.fractionToPoint(globalFractionB1));\n        }\n        else {\n            const d2 = detailA.point.distanceSquaredXY(detailB.point);\n            if (d2 > this._maxDistanceSquared)\n                return;\n            detailA.setIntervalRole(CurveIntervalRole.isolated);\n            detailB.setIntervalRole(CurveIntervalRole.isolated);\n        }\n        if (reversed) {\n            this._results.push(new CurveLocationDetailPair(detailB, detailA));\n        }\n        else {\n            this._results.push(new CurveLocationDetailPair(detailA, detailB));\n        }\n    }\n    /**\n     * Capture a close approach pair that has point and local fraction but not curve.\n     * * Record the pair, each detail modified with global fraction and input curve.\n     * * Pair is neither modified nor recorded if it would be a duplicate of the last recorded pair.\n     * @param pair details computed with local fractions\n     * @param cpA curveA\n     * @param fractionA0 global start fraction on curveA\n     * @param fractionA1 global end fraction on curveA\n     * @param cpB curveB\n     * @param fractionB0 global start fraction on curveB\n     * @param fractionB1 global end fraction on curveB\n     * @param reversed whether to reverse the details in the pair\n     */\n    capturePairWithLocalFractions(pair, cpA, fractionA0, fractionA1, cpB, fractionB0, fractionB1, reversed) {\n        const globalFractionA = Geometry.interpolate(fractionA0, pair.detailA.fraction, fractionA1);\n        const globalFractionB = Geometry.interpolate(fractionB0, pair.detailB.fraction, fractionB1);\n        // ignore duplicate of most recent pair\n        const numPrevious = this._results.length;\n        if (numPrevious > 0) {\n            const oldDetailA = this._results[numPrevious - 1].detailA;\n            const oldDetailB = this._results[numPrevious - 1].detailB;\n            if (reversed) {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailB) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailA))\n                    return;\n            }\n            else {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailA) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailB))\n                    return;\n            }\n        }\n        if (reversed)\n            pair.swapDetails();\n        // recompute the points just in case\n        CurveLocationDetail.createCurveEvaluatedFraction(cpA, globalFractionA, pair.detailA);\n        CurveLocationDetail.createCurveEvaluatedFraction(cpB, globalFractionB, pair.detailB);\n        pair.detailA.setIntervalRole(CurveIntervalRole.isolated);\n        pair.detailB.setIntervalRole(CurveIntervalRole.isolated);\n        this._results.push(pair);\n    }\n    /**\n     * Emit recordPoint for multiple pairs (on full curve) if within maxDistance.\n     * @param cpA first curve primitive (possibly different from curve in detailA, but fraction compatible)\n     * @param cpB second curve primitive (possibly different from curve in detailA, but fraction compatible)\n     * @param pairs array of pairs\n     * @param reversed true to have order reversed in final structures.\n     */\n    recordPairs(cpA, cpB, pairs, reversed) {\n        if (pairs !== undefined) {\n            for (const p of pairs) {\n                this.recordPointWithLocalFractions(p.detailA.fraction, cpA, 0, 1, p.detailB.fraction, cpB, 0, 1, reversed, p);\n            }\n        }\n    }\n    /**\n     * Record fully assembled (but possibly reversed) detail pair.\n     * @param detailA first detail\n     * @param detailB second detail\n     * @param reversed true to have order reversed in final structures.\n     */\n    captureDetailPair(detailA, detailB, reversed) {\n        if (detailA && detailB) {\n            if (reversed) {\n                this._results.push(CurveLocationDetailPair.createCapture(detailB, detailA));\n            }\n            else {\n                this._results.push(CurveLocationDetailPair.createCapture(detailA, detailB));\n            }\n        }\n    }\n    static updatePointToSegmentDistance(fractionA, pointA, pointB0, pointB1, fractionB, maxDistanceSquared, closestApproach) {\n        let updated = false;\n        if (fractionB < 0)\n            fractionB = 0;\n        else if (fractionB > 1)\n            fractionB = 1;\n        this._workPointB = pointB0.interpolate(fractionB, pointB1, this._workPointB);\n        const distanceSquared = this._workPointB.distanceSquaredXY(pointA);\n        if (distanceSquared < Math.min(maxDistanceSquared, closestApproach.detailA.a)) {\n            closestApproach.detailA.setFP(fractionA, pointA, undefined, distanceSquared);\n            closestApproach.detailB.setFP(fractionB, this._workPointB, undefined, distanceSquared);\n            updated = true;\n        }\n        return updated;\n    }\n    /**\n     * Return fractions of close approach within maxDistance between two line segments (a0,a1) and (b0,b1).\n     * * Math details can be found at docs/learning/geometry/CurveCurve.md\n     * @param a0 start point of line a\n     * @param a1 end point of line a\n     * @param b0 start point of line b\n     * @param b1 end point of line b\n     * @param maxDistanceSquared maximum distance squared (assumed to be positive)\n     * @returns the fractional (not xy) coordinates in result.x and result.y. result.x is fraction on line a.\n     * result.y is fraction on line b.\n     */\n    static segmentSegmentBoundedApproach(a0, a1, b0, b1, maxDistanceSquared) {\n        const ux = a1.x - a0.x;\n        const uy = a1.y - a0.y;\n        const vx = b1.x - b0.x;\n        const vy = b1.y - b0.y;\n        const e00x = b0.x - a0.x;\n        const e00y = b0.y - a0.y;\n        const e01x = b1.x - a0.x;\n        const e01y = b1.y - a0.y;\n        const e10x = b0.x - a1.x;\n        const e10y = b0.y - a1.y;\n        const hab0 = Geometry.crossProductXYXY(ux, uy, e00x, e00y);\n        const hab1 = Geometry.crossProductXYXY(ux, uy, e01x, e01y);\n        const hba0 = -Geometry.crossProductXYXY(vx, vy, e00x, e00y);\n        const hba1 = -Geometry.crossProductXYXY(vx, vy, e10x, e10y);\n        if (hab0 * hab1 < 0.0 && hba0 * hba1 < 0.0) { // true intersection, strictly within both segments\n            const fractionA = -hba0 / (hba1 - hba0);\n            const fractionB = -hab0 / (hab1 - hab0);\n            return CurveLocationDetailPair.createCapture(CurveLocationDetail.createCurveFractionPoint(undefined, fractionA, a0.interpolate(fractionA, a1)), CurveLocationDetail.createCurveFractionPoint(undefined, fractionB, b0.interpolate(fractionB, b1)));\n        }\n        // there's no intersection, so find the closest approach within maxDistance from an endpoint\n        const closestApproach = new CurveLocationDetailPair();\n        closestApproach.detailA.a = 2 * maxDistanceSquared; // init to an approach that's too far away\n        let reversed = false;\n        const uu = Geometry.hypotenuseSquaredXY(ux, uy);\n        if (hab0 * hab0 < maxDistanceSquared * uu) { // test distance of b0 to u\n            const fractionA = Geometry.dotProductXYXY(ux, uy, e00x, e00y) / uu;\n            if (this.updatePointToSegmentDistance(0, b0, a0, a1, fractionA, maxDistanceSquared, closestApproach))\n                reversed = true;\n        }\n        if (hab1 * hab1 < maxDistanceSquared * uu) { // test distance of b1 to u\n            const fractionA = Geometry.dotProductXYXY(ux, uy, e01x, e01y) / uu;\n            if (this.updatePointToSegmentDistance(1, b1, a0, a1, fractionA, maxDistanceSquared, closestApproach))\n                reversed = true;\n        }\n        const vv = Geometry.hypotenuseSquaredXY(vx, vy);\n        if (hba0 * hba0 < maxDistanceSquared * vv) { // test distance of a0 to v\n            const fractionB = -Geometry.dotProductXYXY(vx, vy, e00x, e00y) / vv;\n            if (this.updatePointToSegmentDistance(0, a0, b0, b1, fractionB, maxDistanceSquared, closestApproach))\n                reversed = false;\n        }\n        if (hba1 * hba1 < maxDistanceSquared * vv) { // test distance of a1 to v\n            const fractionB = -Geometry.dotProductXYXY(vx, vy, e10x, e10y) / vv;\n            if (this.updatePointToSegmentDistance(1, a1, b0, b1, fractionB, maxDistanceSquared, closestApproach))\n                reversed = false;\n        }\n        if (closestApproach.detailA.a > maxDistanceSquared)\n            return undefined;\n        if (reversed)\n            closestApproach.swapDetails();\n        return closestApproach;\n    }\n    /**\n     * Check different combination of fractions on curveA and curveB. If distance between points at 2 fractions\n     * is less than maxDistance, record CurveLocationDetailPair which is the approach between the 2 points.\n     * Optionally, record close approaches of one curve's points if they fall between the other curve's points.\n     * @param cpA curveA\n     * @param fA0 fraction0 on curveA\n     * @param fA1 fraction1 on curveA\n     * @param testProjectionOnA whether to record projections of the given curveB points onto curveA\n     * @param cpB curveB\n     * @param fB0 fraction0 on curveB\n     * @param fB1 fraction0 on curveB\n     * @param testProjectionOnB whether to record projections of the given curveA points onto curveB\n     * @param reversed true to have order reversed in final structures.\n     */\n    testAndRecordFractionalPairApproach(cpA, fA0, fA1, testProjectionOnA, cpB, fB0, fB1, testProjectionOnB, reversed) {\n        const pointA0 = cpA.fractionToPoint(fA0);\n        const pointA1 = cpA.fractionToPoint(fA1);\n        const pointB0 = cpB.fractionToPoint(fB0);\n        const pointB1 = cpB.fractionToPoint(fB1);\n        this.testAndRecordPointPairApproach(cpA, fA0, pointA0, cpB, fB0, pointB0, reversed);\n        this.testAndRecordPointPairApproach(cpA, fA1, pointA1, cpB, fB0, pointB0, reversed);\n        this.testAndRecordPointPairApproach(cpA, fA0, pointA0, cpB, fB1, pointB1, reversed);\n        this.testAndRecordPointPairApproach(cpA, fA1, pointA1, cpB, fB1, pointB1, reversed);\n        if (testProjectionOnB) {\n            this.testAndRecordProjection(cpA, fA0, pointA0, cpB, fB0, fB1, reversed);\n            this.testAndRecordProjection(cpA, fA1, pointA1, cpB, fB0, fB1, reversed);\n        }\n        if (testProjectionOnA) {\n            this.testAndRecordProjection(cpB, fB0, pointB0, cpA, fA0, fA1, !reversed);\n            this.testAndRecordProjection(cpB, fB1, pointB1, cpA, fA0, fA1, !reversed);\n        }\n    }\n    /** Find the closest approach between pointA and cpB. Add the approach if it's within fB0 and fB1. */\n    testAndRecordProjection(cpA, fA, pointA, cpB, fB0, fB1, reversed) {\n        // NO NO NO -- this is 3D closest point --- need 2d !!\n        const detail = cpB.closestPoint(pointA, false);\n        if (detail) {\n            const fB = Geometry.restrictToInterval(detail.fraction, fB0, fB1);\n            if (fB === detail.fraction) { // if fraction is within fB0 and fB1\n                this.testAndRecordPointPairApproach(cpA, fA, pointA, cpB, detail.fraction, detail.point, reversed);\n            }\n        }\n    }\n    /**\n     * Compute intersection of two line segments.\n     * Filter by extension rules.\n     * Record with fraction mapping.\n     * * The fraction mappings allow portions of a linestring to be passed here.\n     */\n    computeSegmentSegment3D(cpA, pointA0, fractionA0, pointA1, fractionA1, cpB, pointB0, fractionB0, pointB1, fractionB1, reversed) {\n        // compute a pair with fractions local to segments\n        const approach = CurveCurveCloseApproachXY.segmentSegmentBoundedApproach(pointA0, pointA1, pointB0, pointB1, this._maxDistanceSquared);\n        // adjust the pair to refer to input curves and global fractions, then record it if new\n        if (approach) {\n            approach.detailA.setCurve(cpA);\n            approach.detailB.setCurve(cpB);\n            this.capturePairWithLocalFractions(approach, cpA, fractionA0, fractionA1, cpB, fractionB0, fractionB1, reversed);\n        }\n    }\n    /** Low level dispatch of segment with segment. */\n    dispatchSegmentSegment(cpA, pointA0, fractionA0, pointA1, fractionA1, cpB, pointB0, fractionB0, pointB1, fractionB1, reversed) {\n        this.computeSegmentSegment3D(cpA, pointA0, fractionA0, pointA1, fractionA1, cpB, pointB0, fractionB0, pointB1, fractionB1, reversed);\n    }\n    /**\n     * Low level dispatch of segment with arc.\n     * Find close approaches within maxDistance between a line segments (pointA0, pointA1) and an arc.\n     * To consider:\n     * 1) arc endpoints to segment endpoints or arc endpoints projection to the segment.\n     * 2) intersection between arc and segment.\n     * 3) line parallel to arc tangent.\n     * @param cpA the segment\n     * @param pointA0 start point of the segment\n     * @param fractionA0 fraction of the start of the segment\n     * @param pointA1 end point of the segment\n     * @param fractionA1 fraction of the end of the segment\n     * @param arc the arc\n     * @param reversed true to have order reversed in final structures\n     */\n    dispatchSegmentArc(cpA, pointA0, fractionA0, pointA1, fractionA1, arc, reversed) {\n        // 1) arc endpoints to segment endpoints or arc endpoints projection to the segment\n        this.testAndRecordFractionalPairApproach(cpA, 0, 1, true, arc, 0, 1, false, reversed);\n        // 2) intersection between arc and segment\n        // Suppose:\n        // Arc: X = C + cU + sV where c = cos(theta) and s = sin(theta)\n        // Line: contains points A0 and A1\n        // The arc intersects the line at point X if det(A0, A1, X) = 0 with homogeneous xyw points and vectors.\n        // With equational X:  det(A0, A1, C) + c*det(A0, A1, U) + s*det(A0, A1, V) = 0.\n        // solve for theta.\n        // evaluate points.\n        // project back to line.\n        const data = arc.toTransformedVectors();\n        const pointA0Local = pointA0;\n        const pointA1Local = pointA1;\n        const alpha = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1); //  det(A0, A1, C)\n        const beta = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0); // det(A0, A1, U)\n        const gamma = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0); // det(A0, A1, V)\n        const cosines = new GrowableFloat64Array(2);\n        const sines = new GrowableFloat64Array(2);\n        const radians = new GrowableFloat64Array(2);\n        const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(// solve the equation\n        alpha, beta, gamma, cosines, sines, radians);\n        for (let i = 0; i < numRoots; i++) {\n            const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\n            const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\n            const lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);\n            // only add if the point is within the start and end fractions of both line segment and arc\n            if (lineFraction !== undefined && this.acceptFraction(lineFraction) && this.acceptFraction(arcFraction)) {\n                this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);\n            }\n        }\n        // 3) line parallel to arc tangent.\n        // If line does not intersect the arc, then the closest (and/or the furthest) point on arc to the line is a\n        // point where the tangent line on arc at that point is parallel to the line.\n        const dotUT = data.vector0.crossProductStartEndXY(pointA0, pointA1);\n        const dotVT = data.vector90.crossProductStartEndXY(pointA0, pointA1);\n        const parallelRadians = Math.atan2(dotVT, dotUT);\n        for (const radians1 of [parallelRadians, parallelRadians + Math.PI]) {\n            const arcPoint = data.center.plus2Scaled(data.vector0, Math.cos(radians1), data.vector90, Math.sin(radians1));\n            const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians1);\n            const lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);\n            // only add if the point is within the start and end fractions of both line segment and arc\n            if (lineFraction !== undefined && this.acceptFraction(lineFraction) && this.acceptFraction(arcFraction)) {\n                this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);\n            }\n        }\n    }\n    // Caller accesses data from two arcs, ensures circular, and orders with radiusA >= radiusB\n    dispatchCircularCircularOrdered(cpA, radiusA, cpB, radiusB, reversed) {\n        const c = cpA.center.distance(cpB.center);\n        const e = this._maxDistanceToAccept !== undefined ? this._maxDistanceToAccept : Geometry.smallMetricDistance;\n        if (c > radiusA + radiusB + e) // widely separated\n            return;\n        // To consider:\n        // 1) endpoint to endpoint or projection\n        // 2) true intersection\n        // 3) line parallel to arc tangent.\n        this.testAndRecordFractionalPairApproach(cpA, 0, 1, false, cpB, 0, 1, false, reversed);\n        if (!Geometry.isSmallMetricDistance(c)) {\n            // ?? endpoint hits are recorded.  Maybe also need overlap?\n            const vectorAB = Vector3d.createStartEnd(cpA.center, cpB.center);\n            vectorAB.scaleInPlace(1.0 / c);\n            if (c - radiusA - radiusB > e) {\n                // no approaches possible\n            }\n            else {\n                for (const rA of [-radiusA, radiusA]) {\n                    for (const rB of [-radiusB, radiusB]) {\n                        const tangentDistance = c - rA + rB;\n                        if (tangentDistance < e) {\n                            const detailA = this.resolveDirectionToArcXYFraction(cpA, vectorAB, rA);\n                            if (detailA) {\n                                const detailB = this.resolveDirectionToArcXYFraction(cpB, vectorAB, rB);\n                                if (detailB) {\n                                    this.captureDetailPair(detailA, detailB, reversed);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Find the fractional point (if any) on an arc, known to be circular and displayed from the center in the\n     * direction of a scaled vector.\n     */\n    resolveDirectionToArcXYFraction(arc, radialVector, scale) {\n        // The scale ultimately only affects the direction --- easiest way to use it is two multiplies\n        const c = scale * arc.matrixRef.columnDotXYZ(0, radialVector.x, radialVector.y, 0);\n        const s = scale * arc.matrixRef.columnDotXYZ(1, radialVector.x, radialVector.y, 0);\n        const radians = Math.atan2(s, c);\n        const fraction = arc.sweep.radiansToPositivePeriodicFraction(radians, 0);\n        if (fraction < 1.0)\n            return CurveLocationDetail.createCurveEvaluatedFraction(arc, fraction);\n        return undefined;\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcArc(cpA, cpB, reversed) {\n        if (this._circularArcB) {\n            const radiusB = this._circularRadiusB;\n            const radiusA = cpA.circularRadiusXY();\n            if (radiusA !== undefined) {\n                if (radiusA >= radiusB)\n                    this.dispatchCircularCircularOrdered(cpA, radiusA, cpB, radiusB, reversed);\n                else\n                    this.dispatchCircularCircularOrdered(cpB, radiusB, cpA, radiusA, !reversed);\n                return;\n            }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcBsplineCurve3d(cpA, cpB, reversed) {\n        const ls = LineString3d.create();\n        cpB.emitStrokes(ls);\n        this.computeArcLineString(cpA, ls, reversed);\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchBSplineCurve3dBSplineCurve3d(bcurveA, bcurveB, reversed) {\n        const lsA = LineString3d.create();\n        bcurveA.emitStrokes(lsA);\n        const lsB = LineString3d.create();\n        bcurveB.emitStrokes(lsB);\n        this.computeLineStringLineString(lsA, lsB, reversed);\n    }\n    /** Low level dispatch of linestring with (beziers of) a bspline curve */\n    dispatchLineStringBSplineCurve(lsA, curveB, reversed) {\n        const lsB = LineString3d.create();\n        curveB.emitStrokes(lsB);\n        this.computeLineStringLineString(lsA, lsB, reversed);\n    }\n    /** Low level dispatch of segment with (beziers of) a bspline curve */\n    dispatchSegmentBsplineCurve(segA, curveB, reversed) {\n        const lsB = LineString3d.create();\n        curveB.emitStrokes(lsB);\n        this.computeSegmentLineString(segA, lsB, reversed);\n    }\n    /** Detail computation for segment approaching linestring. */\n    computeSegmentLineString(segA, lsB, reversed) {\n        const numB = lsB.numPoints();\n        const deltaFracB = Geometry.safeDivideFraction(1, numB - 1, 0);\n        const pointA0 = segA.point0Ref;\n        const pointA1 = segA.point1Ref;\n        const pointB0 = CurveCurveCloseApproachXY._workPointBB0;\n        const pointB1 = CurveCurveCloseApproachXY._workPointBB1;\n        for (let i = 0; i < numB - 1; ++i) {\n            const fB0 = i * deltaFracB; // global linestring fractions\n            const fB1 = (i + 1 === numB - 1) ? 1.0 : (i + 1) * deltaFracB; // make sure we nail the end fraction\n            lsB.packedPoints.getPoint3dAtUncheckedPointIndex(i, pointB0);\n            lsB.packedPoints.getPoint3dAtUncheckedPointIndex(i + 1, pointB1);\n            this.dispatchSegmentSegment(segA, pointA0, 0.0, pointA1, 1.0, lsB, pointB0, fB0, pointB1, fB1, reversed);\n        }\n    }\n    /** Detail computation for arc approaching linestring. */\n    computeArcLineString(arcA, lsB, reversed) {\n        const pointB0 = CurveCurveCloseApproachXY._workPointBB0;\n        const pointB1 = CurveCurveCloseApproachXY._workPointBB1;\n        const numB = lsB.numPoints();\n        if (numB > 1) {\n            const dfB = 1.0 / (numB - 1);\n            let fB0;\n            let fB1;\n            fB0 = 0.0;\n            lsB.pointAt(0, pointB0);\n            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                lsB.pointAt(ib, pointB1);\n                fB1 = ib * dfB;\n                this.dispatchSegmentArc(lsB, pointB0, fB0, pointB1, fB1, arcA, !reversed);\n            }\n        }\n        return undefined;\n    }\n    /** Low level dispatch of curve chain.  */\n    dispatchCurveChain(geomA, geomAHandler) {\n        const geomB = this._geometryB; // save\n        if (!geomB || !(geomB instanceof CurveChain))\n            return;\n        for (const child of geomB.children) {\n            this.resetGeometry(child);\n            geomAHandler(geomA);\n        }\n        this._geometryB = geomB; // restore\n    }\n    /** Double dispatch handler for strongly typed segment. */\n    handleLineSegment3d(segmentA) {\n        if (this._geometryB instanceof LineSegment3d) {\n            const segmentB = this._geometryB;\n            this.dispatchSegmentSegment(segmentA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, segmentB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, false);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeSegmentLineString(segmentA, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchSegmentArc(segmentA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchSegmentBsplineCurve(segmentA, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof CurveChain) {\n            this.dispatchCurveChain(segmentA, this.handleLineSegment3d.bind(this));\n        }\n    }\n    /**\n     * Set bits for comparison to range xy\n     * * bit 0x01 => x smaller than range.low.x\n     * * bit 0x02 => x larger than range.high.x\n     * * bit 0x04 => y smaller than range.low.y\n     * * bit 0x08 => y larger than range.high.y\n     * @param xy point to test\n     * @param range range for comparison\n     */\n    classifyBitsPointRangeXY(x, y, range) {\n        let result = 0;\n        if (x < range.low.x)\n            result = 0x01;\n        else if (x > range.high.x)\n            result = 0x02;\n        if (y < range.low.y)\n            result |= 0x04;\n        else if (y > range.high.y)\n            result |= 0x08;\n        return result;\n    }\n    computeLineStringLineString(lsA, lsB, reversed) {\n        const rangeA = lsA.range();\n        const rangeB = lsB.range();\n        rangeA.expandInPlace(this._maxDistanceToAccept);\n        if (!rangeB.intersectsRangeXY(rangeA))\n            return;\n        let bitB0;\n        let bitB1;\n        const rangeA1 = Range3d.createNull();\n        const pointA0 = CurveCurveCloseApproachXY._workPointAA0;\n        const pointA1 = CurveCurveCloseApproachXY._workPointAA1;\n        const pointB0 = CurveCurveCloseApproachXY._workPointBB0;\n        const pointB1 = CurveCurveCloseApproachXY._workPointBB1;\n        const numA = lsA.numPoints();\n        const numB = lsB.numPoints();\n        if (numA > 1 && numB > 1) {\n            lsA.pointAt(0, pointA0);\n            const dfA = 1.0 / (numA - 1);\n            const dfB = 1.0 / (numB - 1);\n            let fA0 = 0.0;\n            let fA1, fB0, fB1;\n            lsA.pointAt(0, pointA0);\n            for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {\n                fA1 = ia * dfA;\n                fB0 = 0.0;\n                lsA.pointAt(ia, pointA1);\n                rangeA1.setNull();\n                rangeA1.extendPoint(pointA0);\n                rangeA1.extendPoint(pointA1);\n                rangeA1.expandInPlace(this._maxDistanceToAccept);\n                if (rangeA1.intersectsRangeXY(rangeB)) {\n                    lsB.pointAt(0, pointB0);\n                    bitB0 = this.classifyBitsPointRangeXY(pointB0.x, pointB0.y, rangeA1);\n                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1, bitB0 = bitB1) {\n                        lsB.pointAt(ib, pointB1);\n                        bitB1 = this.classifyBitsPointRangeXY(pointB1.x, pointB1.y, rangeA1);\n                        fB1 = ib * dfB;\n                        // Do NOT study the segment in detail if both bitB bits are on for any of the 4 planes . ..\n                        if ((bitB0 & bitB1) === 0) {\n                            this.dispatchSegmentSegment(lsA, pointA0, fA0, pointA1, fA1, lsB, pointB0, fB0, pointB1, fB1, reversed);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /** Double dispatch handler for strongly typed linestring. */\n    handleLineString3d(lsA) {\n        if (this._geometryB instanceof LineString3d) {\n            const lsB = this._geometryB;\n            this.computeLineStringLineString(lsA, lsB, false);\n        }\n        else if (this._geometryB instanceof LineSegment3d) {\n            this.computeSegmentLineString(this._geometryB, lsA, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.computeArcLineString(this._geometryB, lsA, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchLineStringBSplineCurve(lsA, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof CurveChain) {\n            this.dispatchCurveChain(lsA, this.handleLineString3d.bind(this));\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed arc. */\n    handleArc3d(arc0) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentArc(this._geometryB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, arc0, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeArcLineString(arc0, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcArc(arc0, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchArcBsplineCurve3d(arc0, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof CurveChain) {\n            this.dispatchCurveChain(arc0, this.handleArc3d.bind(this));\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed bspline curve. */\n    handleBSplineCurve3d(curve) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentBsplineCurve(this._geometryB, curve, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.dispatchLineStringBSplineCurve(this._geometryB, curve, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcBsplineCurve3d(this._geometryB, curve, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3dBase) {\n            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\n        }\n        else if (this._geometryB instanceof CurveChain) {\n            this.dispatchCurveChain(curve, this.handleBSplineCurve3d.bind(this));\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed homogeneous bspline curve .. */\n    handleBSplineCurve3dH(_curve) {\n        /*\n        //NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH.\n        // \"easy\" if both present BezierCurve3dH span loaders\n        if (this._geometryB instanceof LineSegment3d) {\n          this.dispatchSegmentBsplineCurve(\n            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\n            curve, this._extendA, true);\n        } else if (this._geometryB instanceof LineString3d) {\n          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\n        } else if (this._geometryB instanceof Arc3d) {\n          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        */\n        return undefined;\n    }\n}\nCurveCurveCloseApproachXY._workPointAA0 = Point3d.create();\nCurveCurveCloseApproachXY._workPointAA1 = Point3d.create();\nCurveCurveCloseApproachXY._workPointBB0 = Point3d.create();\nCurveCurveCloseApproachXY._workPointBB1 = Point3d.create();\nCurveCurveCloseApproachXY._workPointB = Point3d.create();\nexport { CurveCurveCloseApproachXY };\n//# sourceMappingURL=CurveCurveCloseApproachXY.js.map",
      "start": 1693508125213,
      "end": 1693508125385,
      "sourcemaps": null
    }
  ]
}
