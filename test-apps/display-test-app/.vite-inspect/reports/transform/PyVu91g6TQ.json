{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/IModelTile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BentleyError, ByteStream } from \"@itwin/core-bentley\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { ColorDef, computeChildTileProps, computeChildTileRanges, computeTileChordTolerance, LinePixels, TileFormat, } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { addRangeGraphic, Tile, TileBoundingBoxes, TileLoadStatus, TileTreeLoadStatus, TileVisibility, } from \"./internal\";\n/** @internal */\nexport function iModelTileParamsFromJSON(props, parent) {\n    const { contentId, maximumSize, isLeaf, sizeMultiplier } = props;\n    const range = Range3d.fromJSON(props.range);\n    let contentRange;\n    if (undefined !== props.contentRange)\n        contentRange = Range3d.fromJSON(props.contentRange);\n    return { contentId, range, maximumSize, isLeaf, parent, contentRange, sizeMultiplier };\n}\n/**\n * Indicates whether a parent tile should be drawn in place of a child tile.\n * @internal\n */\nexport var SelectParent;\n(function (SelectParent) {\n    SelectParent[SelectParent[\"No\"] = 0] = \"No\";\n    SelectParent[SelectParent[\"Yes\"] = 1] = \"Yes\";\n})(SelectParent || (SelectParent = {}));\n/** A tile belonging to an [[IModelTileTree].\n * @internal\n */\nexport class IModelTile extends Tile {\n    constructor(params, tree) {\n        super(params, tree);\n        this._sizeMultiplier = params.sizeMultiplier;\n        if (!this.isLeaf && this.tree.is3d && !this.isReady) { // ###TODO: Want to know specifically if tree is *spatial*.\n            // Do not sub-divide such that chord tolerance would be below specified minimum, if minimum defined.\n            const minTolerance = IModelApp.tileAdmin.minimumSpatialTolerance;\n            if (minTolerance > 0 && computeTileChordTolerance(this, this.tree.is3d, this.iModelTree.tileScreenSize) <= minTolerance)\n                this.setLeaf();\n        }\n    }\n    get iModelTree() { return this.tree; }\n    get iModelChildren() { return this.children; }\n    get emptySubRangeMask() { return this._emptySubRangeMask ?? 0; }\n    get sizeMultiplier() { return this._sizeMultiplier; }\n    get hasSizeMultiplier() { return undefined !== this.sizeMultiplier; }\n    get maximumSize() {\n        return super.maximumSize * (this.sizeMultiplier ?? 1.0);\n    }\n    get channel() {\n        return IModelApp.tileAdmin.channels.getIModelTileChannel(this);\n    }\n    async requestContent() {\n        return IModelApp.tileAdmin.generateTileContent(this);\n    }\n    async readContent(data, system, isCanceled) {\n        if (undefined === isCanceled)\n            isCanceled = () => !this.isLoading;\n        assert(data instanceof Uint8Array);\n        const streamBuffer = ByteStream.fromUint8Array(data);\n        const position = streamBuffer.curPos;\n        const format = streamBuffer.readUint32();\n        streamBuffer.curPos = position;\n        let content = { isLeaf: true };\n        assert(TileFormat.IModel === format);\n        if (format !== TileFormat.IModel)\n            return content;\n        const sizeMultiplier = this.hasSizeMultiplier ? this.sizeMultiplier : undefined;\n        try {\n            content = await this.iModelTree.decoder.decode({\n                stream: streamBuffer,\n                options: { tileId: this.contentId },\n                system,\n                isCanceled,\n                sizeMultiplier,\n            });\n        }\n        catch {\n            //\n        }\n        return content;\n    }\n    setContent(content) {\n        super.setContent(content);\n        this._emptySubRangeMask = content.emptySubRangeMask;\n        // NB: If this tile has no graphics, it may or may not have children - but we don't want to load the children until\n        // this tile is too coarse for view based on its size in pixels.\n        // That is different than an \"undisplayable\" tile (maximumSize=0) whose children should be loaded immediately.\n        if (undefined !== content.graphic && 0 === this.maximumSize)\n            this._maximumSize = this.iModelTree.tileScreenSize;\n        const sizeMult = content.sizeMultiplier;\n        if (undefined !== sizeMult && (undefined === this._sizeMultiplier || sizeMult > this._sizeMultiplier)) {\n            this._sizeMultiplier = sizeMult;\n            this._contentId = this.iModelTree.contentIdProvider.idFromParentAndMultiplier(this.contentId, sizeMult);\n            if (undefined !== this.children && this.children.length > 1)\n                this.disposeChildren();\n        }\n    }\n    _loadChildren(resolve, reject) {\n        try {\n            const tree = this.iModelTree;\n            const kids = computeChildTileProps(this, tree.contentIdProvider, tree);\n            IModelApp.tileAdmin.onTilesElided(kids.numEmpty);\n            const children = [];\n            for (const props of kids.children) {\n                const child = new IModelTile(iModelTileParamsFromJSON(props, this), tree);\n                children.push(child);\n            }\n            resolve(children);\n        }\n        catch (err) {\n            reject(err instanceof Error ? err : new Error(BentleyError.getErrorMessage(err)));\n        }\n    }\n    get rangeGraphicColor() {\n        return this.hasSizeMultiplier ? ColorDef.red : super.rangeGraphicColor;\n    }\n    addRangeGraphic(builder, type) {\n        if (TileBoundingBoxes.ChildVolumes !== type) {\n            super.addRangeGraphic(builder, type);\n            return;\n        }\n        const ranges = computeChildTileRanges(this, this.iModelTree);\n        for (const range of ranges) {\n            const color = range.isEmpty ? ColorDef.blue : ColorDef.green;\n            const pixels = !range.isEmpty ? LinePixels.HiddenLine : LinePixels.Solid;\n            const width = !range.isEmpty ? 2 : 1;\n            builder.setSymbology(color, color, width, pixels);\n            addRangeGraphic(builder, range.range, this.tree.is2d);\n        }\n    }\n    pruneChildren(olderThan) {\n        // A tile's usage marker indicates its the most recent time its *children* were used.\n        if (this.usageMarker.isExpired(olderThan)) {\n            this.disposeChildren();\n            return;\n        }\n        // this node has been used recently. Keep it, but potentially unload its grandchildren.\n        const children = this.iModelChildren;\n        if (undefined !== children)\n            for (const child of children)\n                child.pruneChildren(olderThan);\n    }\n    selectTiles(selected, args, numSkipped) {\n        let vis = this.computeVisibility(args);\n        if (TileVisibility.OutsideFrustum === vis)\n            return SelectParent.No;\n        const maxDepth = this.iModelTree.debugMaxDepth;\n        if (undefined !== maxDepth && this.depth >= maxDepth)\n            vis = TileVisibility.Visible;\n        if (TileVisibility.Visible === vis) {\n            // This tile is of appropriate resolution to draw. If need loading or refinement, enqueue.\n            if (!this.isReady)\n                args.insertMissing(this);\n            if (this.hasGraphics) {\n                // It can be drawn - select it\n                args.markReady(this);\n                selected.push(this);\n            }\n            else if (!this.isReady) {\n                // It can't be drawn. Try to draw children in its place; otherwise draw the parent.\n                // Do not load/request the children for this purpose.\n                const initialSize = selected.length;\n                const kids = this.iModelChildren;\n                if (undefined === kids)\n                    return SelectParent.Yes;\n                // Find any descendant to draw, until we exceed max initial tiles to skip.\n                if (this.depth < this.iModelTree.maxInitialTilesToSkip) {\n                    for (const kid of kids) {\n                        if (SelectParent.Yes === kid.selectTiles(selected, args, numSkipped)) {\n                            selected.length = initialSize;\n                            return SelectParent.Yes;\n                        }\n                        return SelectParent.No;\n                    }\n                }\n                // If all visible direct children can be drawn, draw them.\n                for (const kid of kids) {\n                    if (TileVisibility.OutsideFrustum !== kid.computeVisibility(args)) {\n                        if (!kid.hasGraphics) {\n                            selected.length = initialSize;\n                            return SelectParent.Yes;\n                        }\n                        else {\n                            selected.push(kid);\n                        }\n                    }\n                }\n                args.markUsed(this);\n            }\n            // We're drawing either this tile, or its direct children.\n            return SelectParent.No;\n        }\n        // This tile is too coarse to draw. Try to draw something more appropriate.\n        // If it is not ready to draw, we may want to skip loading in favor of loading its descendants.\n        // If we previously loaded and later unloaded content for this tile to free memory, don't force it to reload its content - proceed to children.\n        let canSkipThisTile = (this._hadGraphics && !this.hasGraphics) || this.depth < this.iModelTree.maxInitialTilesToSkip;\n        if (canSkipThisTile) {\n            numSkipped = 1;\n        }\n        else {\n            canSkipThisTile = this.isReady || this.isParentDisplayable || this.depth < this.iModelTree.maxInitialTilesToSkip;\n            if (canSkipThisTile && this.isDisplayable) { // skipping an undisplayable tile doesn't count toward the maximum\n                // Some tiles do not sub-divide - they only facet the same geometry to a higher resolution. We can skip directly to the correct resolution.\n                const isNotReady = !this.isReady && !this.hasGraphics && !this.hasSizeMultiplier;\n                if (isNotReady) {\n                    if (numSkipped >= this.iModelTree.maxTilesToSkip)\n                        canSkipThisTile = false;\n                    else\n                        numSkipped += 1;\n                }\n            }\n        }\n        const childrenLoadStatus = this.loadChildren(); // NB: asynchronous\n        const children = canSkipThisTile ? this.iModelChildren : undefined;\n        if (canSkipThisTile && TileTreeLoadStatus.Loading === childrenLoadStatus) {\n            args.markChildrenLoading();\n            args.markUsed(this);\n        }\n        if (undefined !== children) {\n            // If we are the root tile and we are not displayable, then we want to draw *any* currently available children in our place, or else we would draw nothing.\n            // Otherwise, if we want to draw children in our place, we should wait for *all* of them to load, or else we would show missing chunks where not-yet-loaded children belong.\n            const isUndisplayableRootTile = this.isUndisplayableRootTile;\n            args.markUsed(this);\n            let drawChildren = true;\n            const initialSize = selected.length;\n            for (const child of children) {\n                // NB: We must continue iterating children so that they can be requested if missing.\n                if (SelectParent.Yes === child.selectTiles(selected, args, numSkipped)) {\n                    if (child.loadStatus === TileLoadStatus.NotFound) {\n                        // At least one child we want to draw failed to load. e.g., we reached max depth of map tile tree. Draw parent instead.\n                        drawChildren = canSkipThisTile = false;\n                    }\n                    else {\n                        // At least one child we want to draw is not yet loaded. Wait for it to load before drawing it and its siblings, unless we have nothing to draw in their place.\n                        drawChildren = isUndisplayableRootTile;\n                    }\n                }\n            }\n            if (drawChildren)\n                return SelectParent.No;\n            // Some types of tiles (like maps) allow the ready children to be drawn on top of the parent while other children are not yet loaded.\n            if (args.parentsAndChildrenExclusive)\n                selected.length = initialSize;\n        }\n        if (this.isReady) {\n            if (this.hasGraphics) {\n                selected.push(this);\n                if (!canSkipThisTile) {\n                    // This tile is too coarse, but we require loading it before we can start loading higher-res children.\n                    args.markReady(this);\n                }\n            }\n            return SelectParent.No;\n        }\n        // This tile is not ready to be drawn. Request it *only* if we cannot skip it.\n        if (!canSkipThisTile)\n            args.insertMissing(this);\n        return this.isParentDisplayable ? SelectParent.Yes : SelectParent.No;\n    }\n}\n//# sourceMappingURL=IModelTile.js.map",
      "start": 1693508122046,
      "end": 1693508122225,
      "sourcemaps": null
    }
  ]
}
