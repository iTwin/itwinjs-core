{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/geometry/AdditionalTransform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Geometry\n */\n// cspell:ignore Helmert\nimport { Geometry } from \"@itwin/core-geometry\";\n/** An affine transformation with an additional Z Offset.\n *  The equations are:\n *  given a = scale * cos(rotation) and b = scale * sin(rotation)\n *  X = a * x - b * y + translationX\n *  Y = b * x + a * y + translationY\n *  Z = z + translationZ\n *\n *  Note that the class only implements the definition and not the operation.\n *  @public\n */\nexport class Helmert2DWithZOffset {\n    constructor(data) {\n        if (data) {\n            this.translationX = data.translationX;\n            this.translationY = data.translationY;\n            this.translationZ = data.translationZ;\n            this.rotDeg = data.rotDeg;\n            this.scale = data.scale;\n        }\n    }\n    /** Creates an Helmert Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new Helmert2DWithZOffset(data);\n    }\n    /** Creates a JSON from the Helmert Transform definition\n     * @public */\n    toJSON() {\n        return { translationX: this.translationX, translationY: this.translationY, translationZ: this.translationZ, rotDeg: this.rotDeg, scale: this.scale };\n    }\n    /** Compares two Helmert2DWithZOffset objects applying a minuscule tolerance.\n     *  @public */\n    equals(other) {\n        return (Math.abs(this.translationX - other.translationX) < Geometry.smallMetricDistance &&\n            Math.abs(this.translationY - other.translationY) < Geometry.smallMetricDistance &&\n            Math.abs(this.translationZ - other.translationZ) < Geometry.smallMetricDistance &&\n            Math.abs(this.rotDeg - other.rotDeg) < Geometry.smallAngleDegrees &&\n            Math.abs(this.scale - other.scale) < Geometry.smallFraction);\n    }\n}\n/** Additional Transform implementation.\n *  An additional transform is a transformation that can apply to either the horizontal or vertical coordinates of a\n *  geographic CRS. The transformation is applied after the latitude/longitude have been projected thus the process\n *  is applied to the result Cartesian coordinates of the projection process.\n *  @public\n*/\nexport class AdditionalTransform {\n    constructor(data) {\n        if (data)\n            this.helmert2DWithZOffset = data.helmert2DWithZOffset ? Helmert2DWithZOffset.fromJSON(data.helmert2DWithZOffset) : undefined;\n    }\n    /** Creates an Additional Transform from JSON representation.\n     * @public */\n    static fromJSON(data) {\n        return new AdditionalTransform(data);\n    }\n    /** Creates a JSON from the Additional Transform definition\n     * @public */\n    toJSON() {\n        return { helmert2DWithZOffset: this.helmert2DWithZOffset };\n    }\n    /** Compares two additional transforms applying a minuscule tolerance to comparing numbers.\n     *  @public */\n    equals(other) {\n        if ((this.helmert2DWithZOffset === undefined) !== (other.helmert2DWithZOffset === undefined))\n            return false;\n        if (this.helmert2DWithZOffset && !this.helmert2DWithZOffset.equals(other.helmert2DWithZOffset))\n            return false;\n        return true;\n    }\n}\n//# sourceMappingURL=AdditionalTransform.js.map",
      "start": 1693508120739,
      "end": 1693508120805,
      "sourcemaps": null
    }
  ]
}
