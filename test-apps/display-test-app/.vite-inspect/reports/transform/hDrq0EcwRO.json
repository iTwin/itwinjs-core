{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/PolishCubicSpiralEvaluator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { SimpleNewton } from \"../../numerics/Newton\";\nimport { CubicEvaluator } from \"./CubicEvaluator\";\n/**\n * Polish Cubic.\n * * Construction takes nominal length and end radius.\n * curve is  is y= m*x^3 with\n * * x any point on the x axis\n * * m is (1/6RL)\n * * Lx = x length is along the axis, determined by inversion of a distance series at nominal length\n * *\n * @param localToWorld\n * @param nominalL1\n * @param nominalR1\n * @param activeInterval\n * @internal\n */\nexport class PolishCubicEvaluator extends CubicEvaluator {\n    /** Constructor is private.  Caller responsible for cubicM validity. */\n    constructor(length1, radius1, axisLength, cubicM) {\n        super(axisLength, cubicM);\n        this.nominalLength1 = length1;\n        this.nominalRadius1 = radius1;\n    }\n    /** Compute the czech cubic constant. */\n    static computeCubicM(length1, radius1) {\n        return 1.0 / (6.0 * length1 * radius1);\n    }\n    static create(length1, radius1) {\n        const m = this.computeCubicM(length1, radius1);\n        if (m === undefined)\n            return undefined;\n        const xMax = PolishCubicEvaluator.approximateDistanceAlongToX(length1, radius1, length1);\n        if (xMax === undefined)\n            return undefined;\n        return new PolishCubicEvaluator(length1, radius1, xMax, m);\n    }\n    scaleInPlace(scaleFactor) {\n        this.nominalLength1 *= scaleFactor;\n        this.nominalRadius1 *= scaleFactor;\n        super.scaleInPlace(scaleFactor);\n    }\n    /** return a deep copy of the evaluator */\n    clone() { return new PolishCubicEvaluator(this.nominalLength1, this.nominalRadius1, super._axisLength, this.cubicM); }\n    /** Member by member matchup ... */\n    isAlmostEqual(other) {\n        if (other instanceof PolishCubicEvaluator) {\n            return Geometry.isSameCoordinate(this.nominalLength1, other.nominalLength1)\n                && Geometry.isSameCoordinate(this.nominalRadius1, other.nominalRadius1);\n        }\n        return false;\n    }\n    /** Compute the coefficient of x^4 in the x-to-distance series expansion */\n    static computeX4SeriesCoefficient(length1, radius1) {\n        return 1.0 / (4.0 * length1 * length1 * radius1 * radius1);\n    }\n    /**\n     * Evaluate a series approximation of distance along the true curve.\n     * @param x distance along x axis\n     * @param radius1 nominal end radius\n     * @param length1 nominal length along curve\n     * @returns\n     */\n    static xToApproximateDistance(x, radius1, length1) {\n        // C31 * ( 1 + 1 / 10 * E31 - 1 / 72 * E31^2 + 1 / 208 * E31^3 - 5 / 2176 * E31^4 )\n        const a4 = this.computeX4SeriesCoefficient(length1, radius1);\n        const ax2 = a4 * x * x;\n        const ax3 = ax2 * x;\n        const ax4 = ax3 * x;\n        const s0 = x * (1.0 + ax4 * (0.1 + ax4 * (-1.0 / 72.0 + ax4 * (1.0 / 208.0 - 5.0 * ax4 / 2176.0))));\n        return s0;\n    }\n    /**\n     * Evaluate the derivative of the x-to-distance series.\n     * @param x distance along x axis\n     * @param radius1 nominal end radius\n     * @param length1 nominal length along curve\n     * @returns\n     */\n    static xToApproximateDistanceDerivative(x, radius1, length1) {\n        // C31 * ( 1 + 1 / 10 * E31 - 1 / 72 * E31^2 + 1 / 208 * E31^3 - 5 / 2176 * E31^4 )\n        const a4 = this.computeX4SeriesCoefficient(length1, radius1);\n        const ax2 = a4 * x * x;\n        const ax3 = ax2 * x;\n        const ax4 = ax3 * x;\n        // derivative notes ..\n        // take away leading x -- this reduces each power by 1\n        // multiply each coefficient by its original power:\n        //  0.1==>0.5\n        // 1/72==> 9/72 = 1/8\n        // 1/208==>13/208=1/16\n        // 1/2176==>17/2176= 1/128\n        const ds = (1.0 + ax4 * (0.5 + ax4 * (-1.0 / 8.0 + ax4 * (1.0 / 16.0 - 5.0 * ax4 / 128.0))));\n        return ds;\n    }\n    /** Invert the xToApproximateDistance function. */\n    static approximateDistanceAlongToX(s, radius1, length1) {\n        const root = SimpleNewton.runNewton1D(s, (x) => (this.xToApproximateDistance(x, radius1, length1) - s), (x) => this.xToApproximateDistanceDerivative(x, radius1, length1));\n        return root;\n    }\n}\n//# sourceMappingURL=PolishCubicSpiralEvaluator.js.map",
      "start": 1693508125398,
      "end": 1693508125541,
      "sourcemaps": null
    }
  ]
}
