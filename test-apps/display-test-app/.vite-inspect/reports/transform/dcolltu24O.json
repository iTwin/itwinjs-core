{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/ECSqlReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module iModels\n */\nimport { Base64EncodedString } from \"./Base64EncodedString\";\nimport { DbQueryError, DbRequestKind, DbResponseStatus, DbValueFormat, QueryBinder, QueryOptionsBuilder, QueryRowFormat, } from \"./ConcurrentQuery\";\n/** @public */\nexport class PropertyMetaDataMap {\n    constructor(properties) {\n        this.properties = properties;\n        this._byPropName = new Map();\n        this._byJsonName = new Map();\n        this._byNoCase = new Map();\n        for (const property of this.properties) {\n            this._byPropName.set(property.name, property.index);\n            this._byJsonName.set(property.jsonName, property.index);\n            this._byNoCase.set(property.name.toLowerCase(), property.index);\n            this._byNoCase.set(property.jsonName.toLowerCase(), property.index);\n        }\n    }\n    get length() {\n        return this.properties.length;\n    }\n    [Symbol.iterator]() {\n        return this.properties[Symbol.iterator]();\n    }\n    findByName(name) {\n        const index = this._byPropName.get(name);\n        if (typeof index === \"number\") {\n            return this.properties[index];\n        }\n        return undefined;\n    }\n    findByJsonName(name) {\n        const index = this._byJsonName.get(name);\n        if (typeof index === \"number\") {\n            return this.properties[index];\n        }\n        return undefined;\n    }\n    findByNoCase(name) {\n        const index = this._byNoCase.get(name.toLowerCase());\n        if (typeof index === \"number\") {\n            return this.properties[index];\n        }\n        return undefined;\n    }\n}\n/**\n * Execute ECSQL statements and read the results.\n *\n * The query results are returned one row at a time. The format of the row is dictated by the\n * [[QueryOptions.rowFormat]] specified in the `options` parameter of the constructed ECSqlReader object. Defaults to\n * [[QueryRowFormat.UseECSqlPropertyIndexes]] when no `rowFormat` is defined.\n *\n * There are three primary ways to interact with and read the results:\n * - Stream them using ECSqlReader as an asynchronous iterator.\n * - Iterator over them manually using [[ECSqlReader.step]].\n * - Capture all of the results at once in an array using [[QueryRowProxy.toArray]].\n *\n * @see\n * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)\n * - [ECSQL Row Formats]($docs/learning/ECSQLRowFormat) for more details on how rows are formatted.\n * - [ECSQL Code Examples]($docs/learning/ECSQLCodeExamples#iterating-over-query-results) for examples of each\n *      of the above ways of interacting with ECSqlReader.\n *\n * @note When iterating over the results, the current row will be a [[QueryRowProxy]] object. To get the row as a basic\n *       JavaScript object, call [[QueryRowProxy.toRow]] on it.\n * @public\n */\nclass ECSqlReader {\n    /**\n     * @internal\n     */\n    constructor(_executor, query, param, options) {\n        this._executor = _executor;\n        this.query = query;\n        this._localRows = [];\n        this._localOffset = 0;\n        this._globalOffset = -1;\n        this._globalCount = -1;\n        this._done = false;\n        this._globalDone = false;\n        this._props = new PropertyMetaDataMap([]);\n        this._param = new QueryBinder().serialize();\n        this._lockArgs = false;\n        this._stats = { backendCpuTime: 0, backendTotalTime: 0, backendMemUsed: 0, backendRowsReturned: 0, totalTime: 0, retryCount: 0 };\n        this._options = new QueryOptionsBuilder().getOptions();\n        this._rowProxy = new Proxy(this, {\n            get: (target, key) => {\n                if (typeof key === \"string\") {\n                    const idx = Number.parseInt(key, 10);\n                    if (!Number.isNaN(idx)) {\n                        return target.getRowInternal()[idx];\n                    }\n                    const prop = target._props.findByNoCase(key);\n                    if (prop) {\n                        return target.getRowInternal()[prop.index];\n                    }\n                    if (key === \"getMetaData\") {\n                        return () => target._props.properties;\n                    }\n                    if (key === \"toRow\") {\n                        return () => target.formatCurrentRow(true);\n                    }\n                    if (key === \"toArray\") {\n                        return () => this.getRowInternal();\n                    }\n                }\n                return undefined;\n            },\n            has: (target, p) => {\n                return !target._props.findByNoCase(p);\n            },\n            ownKeys: (target) => {\n                const keys = [];\n                for (const prop of target._props) {\n                    keys.push(prop.name);\n                }\n                return keys;\n            },\n        });\n        if (query.trim().length === 0) {\n            throw new Error(\"expecting non-empty ecsql statement\");\n        }\n        if (param) {\n            this._param = param.serialize();\n        }\n        this.reset(options);\n    }\n    static replaceBase64WithUint8Array(row) {\n        for (const key of Object.keys(row)) {\n            const val = row[key];\n            if (typeof val === \"string\") {\n                if (Base64EncodedString.hasPrefix(val)) {\n                    row[key] = Base64EncodedString.toUint8Array(val);\n                }\n            }\n            else if (typeof val === \"object\" && val !== null) {\n                this.replaceBase64WithUint8Array(val);\n            }\n        }\n    }\n    setParams(param) {\n        if (this._lockArgs) {\n            throw new Error(\"call resetBindings() before setting or changing parameters\");\n        }\n        this._param = param.serialize();\n    }\n    reset(options) {\n        if (options) {\n            this._options = options;\n        }\n        this._props = new PropertyMetaDataMap([]);\n        this._localRows = [];\n        this._globalDone = false;\n        this._globalOffset = 0;\n        this._globalCount = -1;\n        if (typeof this._options.rowFormat === \"undefined\")\n            this._options.rowFormat = QueryRowFormat.UseECSqlPropertyIndexes;\n        if (this._options.limit) {\n            if (typeof this._options.limit.offset === \"number\" && this._options.limit.offset > 0)\n                this._globalOffset = this._options.limit.offset;\n            if (typeof this._options.limit.count === \"number\" && this._options.limit.count > 0)\n                this._globalCount = this._options.limit.count;\n        }\n        this._done = false;\n    }\n    /**\n     * Get the current row from the query result. The current row is the one most recently stepped-to\n     * (by step() or during iteration).\n     *\n     * Each value from the row can be accessed by index or by name.\n     *\n     * The format of the row is dictated by the [[QueryOptions.rowFormat]] specified in the `options` parameter of the\n     * constructed ECSqlReader object.\n     *\n     * @see\n     * - [[QueryRowFormat]]\n     * - [ECSQL Row Formats]($docs/learning/ECSQLRowFormat)\n     *\n     * @note The current row is be a [[QueryRowProxy]] object. To get the row as a basic JavaScript object, call\n     *       [[QueryRowProxy.toRow]] on it.\n     *\n     * @example\n     * ```ts\n     * const reader = iModel.createQueryReader(\"SELECT ECInstanceId FROM bis.Element\");\n     * while (await reader.step()) {\n     *   // Both lines below print the same value\n     *   console.log(reader.current[0]);\n     *   console.log(reader.current.ecinstanceid);\n     * }\n     * ```\n     *\n     * @return The current row as a [[QueryRowProxy]].\n     */\n    get current() {\n        return this._rowProxy;\n    }\n    /**\n     * Clear all bindings.\n     */\n    resetBindings() {\n        this._param = new QueryBinder().serialize();\n        this._lockArgs = false;\n    }\n    /**\n     * Returns if there are more rows available.\n     *\n     * @returns `true` if all rows have been stepped through already.<br/>\n     *          `false` if there are any yet unaccessed rows.\n     */\n    get done() {\n        return this._done;\n    }\n    /**\n     * @internal\n     */\n    getRowInternal() {\n        if (this._localRows.length <= this._localOffset)\n            throw new Error(\"no current row\");\n        return this._localRows[this._localOffset];\n    }\n    /**\n     * Get performance-related statistics for the current query.\n     */\n    get stats() {\n        return this._stats;\n    }\n    /**\n     *\n     */\n    async readRows() {\n        if (this._globalDone) {\n            return [];\n        }\n        this._lockArgs = true;\n        this._globalOffset += this._localRows.length;\n        this._globalCount -= this._localRows.length;\n        if (this._globalCount === 0) {\n            return [];\n        }\n        const valueFormat = this._options.rowFormat === QueryRowFormat.UseJsPropertyNames ? DbValueFormat.JsNames : DbValueFormat.ECSqlNames;\n        const request = {\n            ...this._options,\n            kind: DbRequestKind.ECSql,\n            valueFormat,\n            query: this.query,\n            args: this._param,\n        };\n        request.includeMetaData = this._props.length > 0 ? false : true;\n        request.limit = { offset: this._globalOffset, count: this._globalCount < 1 ? -1 : this._globalCount };\n        const resp = await this.runWithRetry(request);\n        this._globalDone = resp.status === DbResponseStatus.Done;\n        if (this._props.length === 0 && resp.meta.length > 0) {\n            this._props = new PropertyMetaDataMap(resp.meta);\n        }\n        for (const row of resp.data) {\n            ECSqlReader.replaceBase64WithUint8Array(row);\n        }\n        return resp.data;\n    }\n    /**\n     * @internal\n     */\n    async runWithRetry(request) {\n        const needRetry = (rs) => (rs.status === DbResponseStatus.Partial || rs.status === DbResponseStatus.QueueFull || rs.status === DbResponseStatus.Timeout) && (rs.data === undefined || rs.data.length === 0);\n        const updateStats = (rs) => {\n            this._stats.backendCpuTime += rs.stats.cpuTime;\n            this._stats.backendTotalTime += rs.stats.totalTime;\n            this._stats.backendMemUsed += rs.stats.memUsed;\n            this._stats.backendRowsReturned += (rs.data === undefined) ? 0 : rs.data.length;\n        };\n        const execQuery = async (req) => {\n            const startTime = Date.now();\n            const rs = await this._executor.execute(req);\n            this.stats.totalTime += (Date.now() - startTime);\n            return rs;\n        };\n        let retry = ECSqlReader._maxRetryCount;\n        let resp = await execQuery(request);\n        DbQueryError.throwIfError(resp, request);\n        while (--retry > 0 && needRetry(resp)) {\n            resp = await execQuery(request);\n            this._stats.retryCount += 1;\n            if (needRetry(resp)) {\n                updateStats(resp);\n            }\n        }\n        if (retry === 0 && needRetry(resp)) {\n            throw new Error(\"query too long to execute or server is too busy\");\n        }\n        updateStats(resp);\n        return resp;\n    }\n    /**\n     * @internal\n     */\n    formatCurrentRow(onlyReturnObject = false) {\n        if (!onlyReturnObject && this._options.rowFormat === QueryRowFormat.UseECSqlPropertyIndexes) {\n            return this.getRowInternal();\n        }\n        const formattedRow = {};\n        for (const prop of this._props) {\n            const propName = this._options.rowFormat === QueryRowFormat.UseJsPropertyNames ? prop.jsonName : prop.name;\n            const val = this.getRowInternal()[prop.index];\n            if (typeof val !== \"undefined\" && val !== null) {\n                Object.defineProperty(formattedRow, propName, {\n                    value: val,\n                    enumerable: true,\n                });\n            }\n        }\n        return formattedRow;\n    }\n    /**\n     * Get the metadata for each column in the query result.\n     *\n     * @returns An array of [[QueryPropertyMetaData]].\n     */\n    async getMetaData() {\n        if (this._props.length === 0) {\n            await this.fetchRows();\n        }\n        return this._props.properties;\n    }\n    /**\n     *\n     */\n    async fetchRows() {\n        this._localOffset = -1;\n        this._localRows = await this.readRows();\n        if (this._localRows.length === 0) {\n            this._done = true;\n        }\n    }\n    /**\n     * Step to the next row of the query result.\n     *\n     * @returns `true` if a row can be read from `current`.<br/>\n     *          `false` if there are no more rows; i.e., all rows have been stepped through already.\n     */\n    async step() {\n        if (this._done) {\n            return false;\n        }\n        const cachedRows = this._localRows.length;\n        if (this._localOffset < cachedRows - 1) {\n            ++this._localOffset;\n        }\n        else {\n            await this.fetchRows();\n            this._localOffset = 0;\n            return !this._done;\n        }\n        return true;\n    }\n    /**\n     * Get all remaining rows from the query result.\n     *\n     * @returns An array of all remaining rows from the query result.\n     */\n    async toArray() {\n        const rows = [];\n        while (await this.step()) {\n            rows.push(this.formatCurrentRow());\n        }\n        return rows;\n    }\n    /**\n     * Accessor for using ECSqlReader as an asynchronous iterator.\n     *\n     * @returns An asynchronous iterator over the rows returned by the executed ECSQL query.\n     */\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    /**\n     * Calls step when called as an iterator.\n     *\n     * Returns the row alongside a `done` boolean to indicate if there are any more rows for an iterator to step to.\n     *\n     * @returns An object with the keys: `value` which contains the row and `done` which contains a boolean.\n     */\n    async next() {\n        if (await this.step()) {\n            return {\n                done: false,\n                value: this.current,\n            };\n        }\n        else {\n            return {\n                done: true,\n                value: this.current,\n            };\n        }\n    }\n}\nECSqlReader._maxRetryCount = 10;\nexport { ECSqlReader };\n//# sourceMappingURL=ECSqlReader.js.map",
      "start": 1693508120922,
      "end": 1693508120969,
      "sourcemaps": null
    }
  ]
}
