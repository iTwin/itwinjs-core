{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/PlanarGrid.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Plane3dByOriginAndUnitNormal, Point2d, Transform } from \"@itwin/core-geometry\";\nimport { QPoint2dList, QPoint3dList } from \"@itwin/core-common\";\nimport { GraphicBranch } from \"../GraphicBranch\";\nimport { BufferHandle, BufferParameters, QBufferHandle2d, QBufferHandle3d } from \"./AttributeBuffers\";\nimport { AttributeMap } from \"./AttributeMap\";\nimport { IndexedGeometry, IndexedGeometryParams } from \"./CachedGeometry\";\nimport { GL } from \"./GL\";\nimport { Primitive } from \"./Primitive\";\nclass PlanarGridGeometryParams extends IndexedGeometryParams {\n    constructor(positions, uvParams, indices, numIndices, props) {\n        super(positions, indices, numIndices);\n        this.props = props;\n        const attrParams = AttributeMap.findAttribute(\"a_uvParam\", 8 /* TechniqueId.PlanarGrid */, false);\n        assert(attrParams !== undefined);\n        this.buffers.addBuffer(uvParams, [BufferParameters.create(attrParams.location, 2, GL.DataType.UnsignedShort, false, 0, 0, false)]);\n        this.uvParams = uvParams;\n    }\n}\nexport class PlanarGridGeometry extends IndexedGeometry {\n    get techniqueId() { return 8 /* TechniqueId.PlanarGrid */; }\n    getPass() { return \"translucent\"; }\n    collectStatistics(_stats) { }\n    get renderOrder() { return 3 /* RenderOrder.UnlitSurface */; }\n    get asPlanarGrid() { return this; }\n    constructor(params) {\n        super(params);\n        this.uvParams = params.uvParams;\n        this.props = params.props;\n    }\n    static create(frustum, grid, system) {\n        const plane = Plane3dByOriginAndUnitNormal.create(grid.origin, grid.rMatrix.rowZ());\n        const polygon = frustum.getIntersectionWithPlane(plane);\n        if (!polygon || polygon.length < 3)\n            return undefined;\n        const xVector = grid.rMatrix.rowX();\n        const yVector = grid.rMatrix.rowY();\n        const gridsPerRef = Math.max(1, grid.gridsPerRef);\n        const xOrigin = xVector.dotProduct(grid.origin);\n        const yOrigin = yVector.dotProduct(grid.origin);\n        const params = [];\n        for (const polygonPoint of polygon) {\n            const x = (xVector.dotProduct(polygonPoint) - xOrigin) / grid.spacing.x;\n            const y = (yVector.dotProduct(polygonPoint) - yOrigin) / grid.spacing.y;\n            params.push(Point2d.create(x, y));\n        }\n        const qPoints = QPoint3dList.fromPoints(polygon);\n        const qParams = QPoint2dList.fromPoints(params);\n        qParams.params.origin.x = qParams.params.origin.x % gridsPerRef;\n        qParams.params.origin.y = qParams.params.origin.y % gridsPerRef;\n        let transform;\n        // If the grid is far from the origin, create a branch to avoid large coordinate accuracy issues. (Reality models).\n        if (qPoints.params.origin.magnitude() > 1.0E4) {\n            transform = Transform.createTranslationXYZ(qPoints.params.origin.x, qPoints.params.origin.y, qPoints.params.origin.z);\n            qPoints.params.origin.setZero();\n        }\n        const nTriangles = polygon.length - 2;\n        const indices = new Uint32Array(3 * nTriangles);\n        for (let i = 0, j = 0; i < nTriangles; i++) {\n            indices[j++] = 0;\n            indices[j++] = i + 1;\n            indices[j++] = i + 2;\n        }\n        const pointBuffer = QBufferHandle3d.create(qPoints.params, qPoints.toTypedArray());\n        const paramBuffer = QBufferHandle2d.create(qParams.params, qParams.toTypedArray());\n        const indBuffer = BufferHandle.createBuffer(GL.Buffer.Target.ElementArrayBuffer, indices);\n        if (!pointBuffer || !paramBuffer || !indBuffer)\n            return undefined;\n        const geomParams = new PlanarGridGeometryParams(pointBuffer, paramBuffer, indBuffer, indices.length, grid);\n        if (!geomParams)\n            return undefined;\n        const geom = new PlanarGridGeometry(geomParams);\n        let graphic = Primitive.create(geom);\n        if (transform && graphic) {\n            const branch = new GraphicBranch(true);\n            branch.add(graphic);\n            graphic = system.createBranch(branch, transform);\n        }\n        return graphic;\n    }\n}\n//# sourceMappingURL=PlanarGrid.js.map",
      "start": 1693508124528,
      "end": 1693508124600,
      "sourcemaps": null
    }
  ]
}
