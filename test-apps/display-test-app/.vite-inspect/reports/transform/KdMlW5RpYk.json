{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/multiclip/OffsetMeshContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { SmallSystem } from \"../../numerics/Polynomials\";\nimport { GrowableXYZArray } from \"../../geometry3d/GrowableXYZArray\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { PolygonOps } from \"../../geometry3d/PolygonOps\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { HalfEdge, HalfEdgeMask } from \"../../topology/Graph\";\nimport { HalfEdgeGraphFromIndexedLoopsContext } from \"../../topology/HalfEdgeGraphFromIndexedLoopsContext\";\nimport { Geometry } from \"../../Geometry\";\nimport { PolylineCompressionContext } from \"../../geometry3d/PolylineCompressionByEdgeOffset\";\nimport { Angle } from \"../../geometry3d/Angle\";\nfunction isDefinedAndTrue(value) {\n    if (value === undefined)\n        return false;\n    return value;\n}\nclass AverageNormalData {\n    constructor() {\n        this.numActiveSectors = 0;\n        this.numInactiveSectors = 0; // exterior and sling.\n        this.averageNormal = Vector3d.create();\n        this.radiansSum = 0.0;\n        this.maxDeviationRadiansFromAverage = 0.0;\n    }\n    clear() {\n        this.numActiveSectors = 0;\n        this.numInactiveSectors = 0; // exterior and sling.\n        this.averageNormal.setZero();\n        this.radiansSum = 0.0;\n        this.maxDeviationRadiansFromAverage = 0.0;\n    }\n    /** Add a normal to the evolving sum, scaled by radians in the corner */\n    accumulateNormal(node, normal, inactiveMask) {\n        if (node.isMaskSet(inactiveMask)) {\n            this.numInactiveSectors++;\n        }\n        else {\n            const sectorSweepRadians = HalfEdge.sectorSweepRadiansXYZ(node, normal);\n            this.averageNormal.addScaledInPlace(normal, sectorSweepRadians);\n            this.radiansSum += sectorSweepRadians;\n            this.numActiveSectors++;\n        }\n    }\n    /** normalize the accumulated normals. */\n    finishNormalAveraging() {\n        if (this.numActiveSectors > 0 && this.averageNormal.normalizeInPlace()) {\n            return true;\n        }\n        return false;\n    }\n    /** Compute the deviation from average.   update max deviation member */\n    recordDeviation(normal, isActive) {\n        if (isActive) {\n            const radians = this.averageNormal.radiansTo(normal);\n            this.maxDeviationRadiansFromAverage = Math.max(Math.abs(this.maxDeviationRadiansFromAverage), radians);\n        }\n        else {\n        }\n    }\n    /** Return the max deviation as computed on prior calls to recordDeviation */\n    get maxDeviationRadians() { return this.maxDeviationRadiansFromAverage; }\n}\nfunction emitSector(sector) {\n    if (OffsetMeshContext.stringDebugFunction !== undefined) {\n        OffsetMeshContext.stringDebugFunction(`    Sector xyz    ${sector.xyz.x},${sector.xyz.y},${sector.xyz.z} `);\n        OffsetMeshContext.stringDebugFunction(`           normal ${sector.normal.x},${sector.normal.y},${sector.normal.z} `);\n    }\n}\n// facet properties used during offset.\n//\nexport class FacetOffsetProperties {\n    constructor(facetIndex, normal) {\n        this.facetIndex = facetIndex;\n        this.facetNormal = normal;\n    }\n}\n/**\n * Sector properties during offset.\n * * this.normal may be initially assigned as the facet normal but can mutate by\n *     averaging with neighbors.\n * * this.xyz is initially the base mesh xyz but is expected to move along the normal.\n * * this.count is used locally in computations.\n */\nexport class SectorOffsetProperties {\n    constructor(normal, xyz) {\n        this.xyz = xyz;\n        this.normal = normal;\n        this.count = 0;\n    }\n    /**\n     * Compute the angle between plane normals on opposite sides of the edge.\n     * * parallel normals have zero angle.\n     * * if the edge cuts inward to the volume behind the faces, the angle is negative.\n     * * if the edge is outward (a convex edge) the the volume, the angle is positive.\n     * @param edgeNodeA node on one side of the edge\n     * @param edgeVector pre-allocated vector to receive vector along edge.\n     * @param averageNormal pre-allocated vector to receive the average normal for a chamfer of the offset edge.\n     * @param offsetDistance distance of offset being constructed.  The sign of this resolves angle ambiguity.\n     * @param radiansTolerance tolerance for large angle between normals.\n     * @returns true if this edge has SectorOffsetProperties on both sides and the angle between normals angle exceeds radiansTolerance.\n     */\n    static edgeHasLargeExteriorAngleBetweenNormals(edgeNodeA, edgeVector, averageNormal, offsetDistance, radiansTolerance = Math.PI * 0.5) {\n        const propsA = edgeNodeA.edgeTag;\n        const edgeNodeB = edgeNodeA.edgeMate;\n        const propsB = edgeNodeB.edgeTag;\n        if (propsA !== undefined && propsB !== undefined) {\n            edgeNodeA.vectorToFaceSuccessor(edgeVector);\n            const radians = propsA.normal.signedRadiansTo(propsB.normal, edgeVector);\n            if (Geometry.split3WaySign(offsetDistance, -1, 1, 1) * radians >= radiansTolerance) {\n                Vector3d.createAdd2Scaled(propsA.normal, 1.0, propsB.normal, 1.0, averageNormal);\n                if (averageNormal.normalizeInPlace())\n                    return true;\n            }\n        }\n        return false;\n    }\n    static almostEqualNormals(sectorA, sectorB, radiansTolerance = Geometry.smallAngleRadians) {\n        return sectorA.normal.radiansTo(sectorB.normal) <= radiansTolerance;\n    }\n    static radiansBetweenNormals(sectorA, sectorB) {\n        return sectorA.normal.radiansTo(sectorB.normal);\n    }\n    // Set the offset point this.xyz as sum of the nodeXyz + distance * this.normal\n    setOffsetPointAtDistanceAtHalfEdge(halfEdge, distance) {\n        halfEdge.getPoint3d(this.xyz);\n        this.xyz.addScaledInPlace(this.normal, distance);\n    }\n    // Copy xyz from parameter into (preexisting object) xyz\n    static setXYZAtHalfEdge(halfEdge, xyz) {\n        const props = halfEdge.edgeTag;\n        if (props !== undefined && xyz !== undefined)\n            props.xyz.set(xyz.x, xyz.y, xyz.z);\n    }\n    // Set the offset point this.xyz directly\n    setXYAndZ(xyz) {\n        this.xyz.set(xyz.x, xyz.y, xyz.z);\n    }\n    // Look through the half edge to its properties.  Set the normal there.  Optionally set xyz from node xyz and offset distance\n    static setNormalAtHalfEdge(halfEdge, uvw, distance) {\n        const props = halfEdge.edgeTag;\n        if (props !== undefined) {\n            props.normal.set(uvw.x, uvw.y, uvw.z);\n            if (distance !== undefined)\n                props.setOffsetPointAtDistanceAtHalfEdge(halfEdge, distance);\n        }\n    }\n    // Look through the half edge and its vertex successor to properties.  Get the two normals. Return the angle sweeping from one to the next\n    static sweepRadiansAroundNormal(nodeA, upVector) {\n        const propsA = nodeA.edgeTag;\n        const propsB = nodeA.vertexSuccessor.edgeTag;\n        if (propsA !== undefined && propsB !== undefined) {\n            return propsA.normal.planarRadiansTo(propsB.normal, upVector);\n        }\n        return undefined;\n    }\n    // Look through the half edge to its properties.  return (if possible) the coordinates\n    static getSectorPointAtHalfEdge(halfEdge, xyz, xyzArray) {\n        const props = halfEdge.edgeTag;\n        if (props !== undefined) {\n            if (xyz !== undefined)\n                xyz.setFromPoint3d(props.xyz);\n            if (xyzArray !== undefined)\n                xyzArray.push(props.xyz);\n            return true;\n        }\n        return false;\n    }\n    // access the XYZ and push to the array (which makes copies, not reference)\n    // return pointer to the SectorOffsetProperties\n    static pushXYZ(xyzArray, halfEdge) {\n        const sector = halfEdge.edgeTag;\n        if (sector !== undefined)\n            xyzArray.push(sector.xyz);\n        return sector;\n    }\n    // Dereference to execute:       accumulatingVector += halfEdge.edgeTag.normal * scale\n    static accumulateScaledNormalAtHalfEdge(halfEdge, scale, accumulatingVector) {\n        const sector = halfEdge.edgeTag;\n        if (sector !== undefined)\n            accumulatingVector.addScaledInPlace(sector.normal, scale);\n    }\n}\n/*\nAbout Chamfer Edges ..... as constructed in addChamferTopologyToAllEdges\n\nWhen edge vertex X to vertex Y has a sharp angle between normals, a \"chamfer face\" must be created to \"fatten\" it.\n\nThe original half edges (nodes) for the edge are AX and AY.  These are \"mates\" in the halfEdge mental model. As always,\nAX is (as needed)\n   (i) the preferred half edge for the left side of the edge moving from X to Y. (i.e. above the edge)\n   (ii) a part of the face loop for the face to the left when proceeding CCW around the face to the above the drawn edge\n   (iii) a part of the vertex loop around X\nLikewise, AY is (as needed)\n   (i) the preferred half edge for the left side of the edge moving from Y to X (i.e. below the edge)\n   (ii) a part of the face loop for the face to the left of the edge when proceeding CCW around the face below the edge.\n   (iii) a part of the vertex loop around Y\n\n      AX------>\nX______________________________________________________________________Y\n                                                      <---AY\n\nWhen the chamfer face is created, it needs to have a sliver face \"inside the edge\" -- something in the space here\n\n      AX------>\n  _____________________________________________________________________\n /                                                                     \\\nX                                                                       Y\n \\_____________________________________________________________________/\n                                                      <---AY\n\nThe chamfer face will have a plane normal is the average of the two faces' plane normals.\n\nThe creation sequence for the chamfer face puts a slit \"inside the edge\" as above   HalfEdges AX and AY remain as parts\nof their respective face loops.   In addition, at each end a singleton edge \"sling\" face is inserted at each\nend of the sliver face.\n\nThe sequence is:\n\n  STEP 1: splitEdgeCreateSliver creates the sliver face with 2 half edges DX and DY\n  STEP 2: splitEdge (with undefined as the \"prior\" edge) creates a sling with HalfEdge CX \"inside\" and BX \"outside\".\n             (The sling face is not yet attached to X -- briefly floating in space)\n  STEP 3: pinch of HalfEdges BX and DX inserts the sling face \"inside\" the slit face at the X end.\n\n  Steps 2 and 3 are executed from each end.   Due to the symmetric structure, a 2-pass loop can apply the logic at each end without distinct names in code.\n\n         AX------>\n     _______________________________________________________________\n    /                                              <---DY           \\\n   /                                                                 \\\n  /    BX--->                                                         \\\n / _______________                                    _______________  \\\n| /               \\                                  /     <----CY   \\ |\n|/                 \\                                /                 \\|\nX                   |                              |                   Y\n|\\   CX--->         /                               \\                 /|\n| \\_______________/                                  \\_______________/ |\n \\                                                         <---BY     /\n  \\                                                                   /\n   \\      DX--->                                                     /\n    \\ ______________________________________________________________/\n                                                    <---AY\n\nDuring the construction, the letters ABCD are used as above, but with prefixes emphasizing their role\noutsideAX, outsideAY\nslingB, slingC, sliverD\n\nThe \"inside\" sling faces (CX and CY) each have their own FacetOffsetProperties and SectorOffsetProperties.\nThe sliver face has its own FacetOffsetProperties which are referenced by DX, BY, DY, BX.\nEach of those 4 has its own SectorOffSetProperties.\n\nImportant properties during offset construction:\n1) the original graph always has original topology and coordinates\n2) Each face of the original graph has a FacetOffsetProperties with a representative point and a normal.  These are unchanged during the computation.\n3) Each node has its own SectorOffsetProperties with a coordinate and normal independent of the parent node.\n   3.1 The first offset coordinates in each node are directly offset by face normal.\n   3.2 This creates mismatch across edges and around vertices.\n   3.3 Various sweeps \"around each vertex\" try to do intersections among appropriate offset planes to find\n        common coordinates in place of the initial mismatches.\n4) The independence of all the sectors allows the offset construction to fix things up in any order it chooses.\n5) During the construction, the xyz in SectorOffsetProperties around a single vertex do NOT have to match.\n6) At output time, there are three sweeps:\n   6.1: By face:  Go around the face and output a facet with the coordinates in the various sectors.\n   6.2: By edge: For each edge, if the sector xyz match across both ends output nothing.  If not, output a triangle or quad\n   6.3: By vertex:  At each vertex, if all vertex coordinates match  output nothing.   Otherwise output a facet with all the coordinates.\n*/\nexport class OffsetMeshContext {\n    constructor(basePolyface, baseGraph, options) {\n        this._basePolyface = basePolyface;\n        this._baseGraph = baseGraph;\n        this._breakMaskA = baseGraph.grabMask();\n        this._breakMaskB = baseGraph.grabMask();\n        this._insideOfChamferFace = baseGraph.grabMask();\n        this._outsideOfChamferFace = baseGraph.grabMask();\n        this._insideChamferSling = baseGraph.grabMask();\n        this._outsideEndOfChamferFace = baseGraph.grabMask();\n        this._exteriorMask = HalfEdgeMask.EXTERIOR;\n        this._offsetCoordinatesReassigned = baseGraph.grabMask();\n        this._smoothRadiansBetweenNormals = options.smoothSingleAngleBetweenNormals.radians;\n        this._chamferTurnRadians = options.chamferAngleBetweenNormals.radians;\n        this._smoothAccumulatedRadiansBetweenNormals = options.smoothAccumulatedAngleBetweenNormals.radians;\n    }\n    /** \"Exterior\" side of a bare edge of the mesh */\n    get exteriorMask() { return this._exteriorMask; }\n    /** \"First\" sector of a smooth sequence. */\n    get breakMaskA() { return this._breakMaskA; }\n    /** \"Last\" sector of a smooth sequence. */\n    get breakMaskB() { return this._breakMaskB; }\n    /** This edge is on a chamfered face, and along the original edge */\n    get insideOfChamferFace() { return this._insideOfChamferFace; }\n    /** This is the original edge of a chamfer face */\n    get outsideOfChamferFace() { return this._outsideOfChamferFace; }\n    /** This edge is on a chamfered face, and at the end -- other side may be a sling */\n    get insideChamferSling() { return this._insideChamferSling; }\n    /** This is the outside of the end of a chamfer face -- i.e. the inside of a new face-at-vertex */\n    get outsideEndOfChamferFace() { return this._outsideEndOfChamferFace; }\n    // At each node . .\n    // * Find the sector data\n    // * recompute the sector point using node XYZ and sectorData normal.\n    applyFaceNormalOffsetsToSectorData(distance) {\n        this._baseGraph.announceNodes((_graph, node) => {\n            const sectorData = node.edgeTag;\n            if (sectorData !== undefined) {\n                sectorData.setOffsetPointAtDistanceAtHalfEdge(node, distance);\n            }\n            return true;\n        });\n    }\n    /**\n     * * build a mesh offset by given distance.\n     * * output the mesh to the given builder.\n     * @param basePolyface original mesh\n     * @param builder polyface builder to receive the new mesh.\n     * @param distance signed offset distance.\n     */\n    static buildOffsetMeshWithEdgeChamfers(basePolyface, builder, distance, options) {\n        const baseGraph = this.buildBaseGraph(basePolyface);\n        if (baseGraph !== undefined) {\n            const offsetBuilder = new OffsetMeshContext(basePolyface, baseGraph, options);\n            offsetBuilder.applyFaceNormalOffsetsToSectorData(distance);\n            if (OffsetMeshContext.graphDebugFunction !== undefined)\n                OffsetMeshContext.graphDebugFunction(\"BaseGraph\", baseGraph, offsetBuilder._breakMaskA, offsetBuilder._breakMaskB);\n            const outputSelector = options.outputSelector ? options.outputSelector : {\n                outputOffsetsFromFaces: true,\n                outputOffsetsFromEdges: true,\n                outputOffsetsFromVertices: true,\n            };\n            if (isDefinedAndTrue(outputSelector.outputOffsetsFromFacesBeforeChamfers))\n                offsetBuilder.announceFacetsWithSectorCoordinatesAroundFaces(builder);\n            offsetBuilder.addChamferTopologyToAllEdges(options, distance);\n            offsetBuilder.computeOffsetFacetIntersections(distance);\n            if (OffsetMeshContext.graphDebugFunction !== undefined)\n                OffsetMeshContext.graphDebugFunction(\"after computeEdgeChamfers\", baseGraph, offsetBuilder._breakMaskA, offsetBuilder._breakMaskB);\n            if (isDefinedAndTrue(outputSelector.outputOffsetsFromFaces))\n                offsetBuilder.announceFacetsWithSectorCoordinatesAroundFaces(builder);\n            if (isDefinedAndTrue(outputSelector.outputOffsetsFromEdges))\n                offsetBuilder.announceFacetsWithSectorCoordinatesAroundEdges(builder);\n            if (isDefinedAndTrue(outputSelector.outputOffsetsFromVertices))\n                offsetBuilder.announceFacetsWithSectorCoordinatesAroundVertices(builder);\n        }\n    }\n    /**\n   * For each face of the graph, shift vertices by offsetDistance and emit to the builder as a facet\n   * @param polyfaceBuilder\n   */\n    announceSimpleOffsetFromFaces(polyfaceBuilder, offsetDistance) {\n        const xyzLoop = new GrowableXYZArray();\n        const xyz = Point3d.create(); // reused at each point around each facet.\n        const uvw = Vector3d.create(); // reused once per facet\n        const announceNodeAroundFace = (node) => {\n            node.getPoint3d(xyz);\n            xyz.addInPlace(uvw);\n            xyzLoop.push(xyz);\n            return 0;\n        };\n        this._baseGraph.announceFaceLoops((_graph, seed) => {\n            if (!seed.isMaskSet(HalfEdgeMask.EXTERIOR)) {\n                const facetProperties = seed.faceTag;\n                uvw.setFromVector3d(facetProperties.facetNormal.direction);\n                uvw.scaleInPlace(offsetDistance);\n                xyzLoop.length = 0;\n                seed.sumAroundFace(announceNodeAroundFace);\n                polyfaceBuilder.addPolygonGrowableXYZArray(xyzLoop);\n            }\n            return true;\n        });\n    }\n    /**\n   * For each face of the graph, output the xyz of the sector data\n   * @param polyfaceBuilder\n   */\n    announceFacetsWithSectorCoordinatesAroundFaces(polyfaceBuilder) {\n        const xyzLoop = new GrowableXYZArray();\n        // For face loop visits .. get the point from the sector data.\n        const announceNodeAroundFace = (node) => {\n            const sectorData = node.edgeTag;\n            if (sectorData !== undefined) {\n                xyzLoop.push(sectorData.xyz);\n            }\n            return 0;\n        };\n        this._baseGraph.announceFaceLoops((_graph, seed) => {\n            if (!seed.isMaskSet(HalfEdgeMask.EXTERIOR)) {\n                xyzLoop.length = 0;\n                seed.sumAroundFace(announceNodeAroundFace);\n                if (xyzLoop.length > 2)\n                    polyfaceBuilder.addPolygonGrowableXYZArray(xyzLoop);\n            }\n            return true;\n        });\n    }\n    countBits(mask) {\n        let n = 0;\n        let mask1 = mask;\n        while (mask1 !== 0) {\n            if (mask1 & 0x01)\n                n++;\n            mask1 = mask1 >> 1;\n        }\n        return n;\n    }\n    /**\n   * For each edge of the graph . .\n   * * Collect coordinates in 4 sectors going around the edge\n   * * Compress with tight tolerance so adjacent sectors with clean point match reduce to a single point.\n   * * Emit as a facet.\n   * @param polyfaceBuilder\n   */\n    announceFacetsWithSectorCoordinatesAroundEdges(polyfaceBuilder) {\n        const xyzLoop = new GrowableXYZArray();\n        const primaryCompressionTolerance = Geometry.smallMetricDistance;\n        const allMasksForEdgesToIgnore = this._exteriorMask\n            | this._outsideEndOfChamferFace\n            | this._outsideOfChamferFace\n            | this._insideOfChamferFace\n            | this._insideChamferSling;\n        this._baseGraph.announceEdges((_graph, nodeA) => {\n            // This starts by looking for EXTERIOR on both sides ...\n            if (nodeA.findMaskAroundEdge(this._exteriorMask) !== undefined) {\n                return true;\n            }\n            else if (!nodeA.isMaskSet(allMasksForEdgesToIgnore)) { // By design, we believe that these two test for  allMasksForEdgesToIgnore condition would catch the EXTERIOR case above\n                const nodeB = nodeA.faceSuccessor;\n                const nodeC = nodeA.edgeMate;\n                if (!nodeC.isMaskSet(allMasksForEdgesToIgnore)) {\n                    const nodeD = nodeC.faceSuccessor;\n                    xyzLoop.clear();\n                    SectorOffsetProperties.getSectorPointAtHalfEdge(nodeA, undefined, xyzLoop);\n                    SectorOffsetProperties.getSectorPointAtHalfEdge(nodeB, undefined, xyzLoop);\n                    SectorOffsetProperties.getSectorPointAtHalfEdge(nodeC, undefined, xyzLoop);\n                    SectorOffsetProperties.getSectorPointAtHalfEdge(nodeD, undefined, xyzLoop);\n                    PolylineCompressionContext.compressInPlaceByShortEdgeLength(xyzLoop, primaryCompressionTolerance);\n                    if (xyzLoop.length > 2) {\n                        polyfaceBuilder.addPolygonGrowableXYZArray(xyzLoop);\n                    }\n                }\n            }\n            else {\n                return true;\n            }\n            return true;\n        });\n    }\n    getCoordinateString(node, showXYZ = true, showFaceSuccessorXYZ = false) {\n        if (showXYZ) {\n            if (showFaceSuccessorXYZ) {\n                return `${HalfEdge.nodeToIdXYZString(node)} ==> ${HalfEdge.nodeToIdXYZString(node.faceSuccessor)}`;\n            }\n            else {\n                return `${HalfEdge.nodeToIdXYZString(node)}`;\n            }\n        }\n        else {\n            if (showFaceSuccessorXYZ) {\n                return `==> ${HalfEdge.nodeToIdXYZString(node.faceSuccessor)}`;\n            }\n            else {\n                return \"\";\n            }\n        }\n    }\n    inspectMasks(node, showXYZ = true, showFaceSuccessorXYZ = false) {\n        const s = \"[\";\n        const v = s.concat(node.id.toString(), node.isMaskSet(this._exteriorMask) ? \"X\" : \"\", node.isMaskSet(this.breakMaskA) ? \"A\" : \"\", node.isMaskSet(this.breakMaskB) ? \"B\" : \"\", node.isMaskSet(this.insideChamferSling) ? \"(sling)\" : \"\", node.isMaskSet(this.insideOfChamferFace) ? \"(in chamfer)\" : \"\", node.isMaskSet(this.outsideEndOfChamferFace) ? \"(@sling)\" : \"\", node.isMaskSet(this.outsideOfChamferFace) ? \"(@chamfer)\" : \"\", this.getCoordinateString(node, showXYZ, showFaceSuccessorXYZ), \"]\");\n        return v;\n    }\n    /**\n   * For each face of the graph, output the xyz of the sector data\n   * @param polyfaceBuilder\n   */\n    announceFacetsWithSectorCoordinatesAroundVertices(polyfaceBuilder) {\n        const xyzLoop = new GrowableXYZArray();\n        const primaryCompressionTolerance = Geometry.smallMetricDistance;\n        this._baseGraph.announceVertexLoops((_graph, seed) => {\n            if (!seed.findMaskAroundVertex(this._exteriorMask)) {\n                xyzLoop.length = 0;\n                seed.sumAroundVertex((node) => {\n                    if (!node.isMaskSet(this._insideChamferSling))\n                        SectorOffsetProperties.getSectorPointAtHalfEdge(node, undefined, xyzLoop);\n                    return 0.0;\n                });\n                PolylineCompressionContext.compressInPlaceByShortEdgeLength(xyzLoop, primaryCompressionTolerance);\n                if (xyzLoop.length > 2) {\n                    polyfaceBuilder.addPolygonGrowableXYZArray(xyzLoop);\n                }\n            }\n            return true;\n        });\n    }\n    /**\n       * * Exterior half edges have HalfEdgeMask.EXTERIOR\n       * * All interior half edge around a facet have facetTag pointing to a facetProperties object for that facet.\n       *    * the facetOffsetProperties object has the simple facet normal.\n       * * Each half edge has edgeTag pointing to to a sectorOffsetProperties object\n       *    * the sectorOffsetProperties has a copy of the facet normal.\n       * @param polyface\n       * @returns graph\n       */\n    static buildBaseGraph(polyface) {\n        const graphBuilder = new HalfEdgeGraphFromIndexedLoopsContext();\n        const visitor = polyface.createVisitor();\n        const xyzA = Point3d.create();\n        const xyzB = Point3d.create();\n        for (visitor.reset(); visitor.moveToNextFacet();) {\n            const normal = PolygonOps.centroidAreaNormal(visitor.point);\n            if (normal !== undefined) {\n                const edgeA = graphBuilder.insertLoop(visitor.pointIndex, (insideHalfEdge) => {\n                    const mate = insideHalfEdge.edgeMate;\n                    polyface.data.getPoint(insideHalfEdge.i, xyzA);\n                    insideHalfEdge.setXYZ(xyzA);\n                    polyface.data.getPoint(mate.i, xyzB);\n                    mate.setXYZ(xyzB);\n                });\n                const facetProperties = new FacetOffsetProperties(visitor.currentReadIndex(), normal);\n                if (edgeA !== undefined) {\n                    edgeA.sumAroundFace((edgeB) => {\n                        edgeB.faceTag = facetProperties;\n                        edgeB.edgeTag = new SectorOffsetProperties(normal.direction.clone(), edgeB.getPoint3d());\n                        return 0;\n                    });\n                }\n            }\n        }\n        return graphBuilder.graph;\n    }\n    setOffsetAtDistanceAroundVertex(vertexSeed, distance, ignoreChamfers = false) {\n        vertexSeed.sumAroundVertex((nodeAroundVertex) => {\n            const props = nodeAroundVertex.edgeTag;\n            if (props !== undefined) {\n                if (ignoreChamfers && this.isInsideChamferOrSling(vertexSeed)) {\n                    // SKIP !!\n                }\n                else {\n                    props.setOffsetPointAtDistanceAtHalfEdge(nodeAroundVertex, distance);\n                }\n            }\n            return 0.0;\n        });\n    }\n    setOffsetXYAndZAroundVertex(vertexSeed, xyz) {\n        vertexSeed.sumAroundVertex((nodeAroundVertex) => {\n            const props = nodeAroundVertex.edgeTag;\n            if (props !== undefined) {\n                props.setXYAndZ(xyz);\n                nodeAroundVertex.setMask(this._offsetCoordinatesReassigned);\n            }\n            return 0.0;\n        });\n    }\n    /**\n    *  * start at vertexSeed.\n    *  * set the offset point at up to (and including) one with (a) this._breakMaskB or (b) this._exteriorMask\n    *  *\n    * @param vertexSeed first node to mark.\n    * @param f function to call to announce each node and its sector properties.\n    * @returns number of nodes marked.\n    */\n    announceNodeAndSectorPropertiesInSmoothSector(vertexSeed, f) {\n        let n = 0;\n        for (let currentNode = vertexSeed;; currentNode = currentNode.vertexSuccessor) {\n            const props = currentNode.edgeTag;\n            if (props !== undefined) {\n                f(currentNode, props);\n                n++;\n            }\n            if (currentNode.isMaskSet(this._breakMaskB))\n                return n;\n            // REMARK: these additional exit conditions should not happen if (a) the graph is properly marked and (b) the start node is not exterior.\n            if (currentNode.isMaskSet(this._exteriorMask))\n                return n;\n            if (currentNode === vertexSeed && n === 0)\n                return n;\n        }\n    }\n    computeAverageNormalAndMaxDeviationAroundVertex(vertexSeed, data) {\n        data.clear();\n        const inactiveNodeMask = this._exteriorMask | this._insideChamferSling;\n        vertexSeed.sumAroundVertex((node) => {\n            const sectorData = node.edgeTag;\n            if (sectorData)\n                data.accumulateNormal(node, sectorData.normal, inactiveNodeMask);\n            return 0.0;\n        });\n        if (!data.finishNormalAveraging()) {\n            return undefined;\n        }\n        vertexSeed.sumAroundVertex((node) => {\n            const sectorData = node.edgeTag;\n            if (sectorData)\n                data.recordDeviation(sectorData.normal, !node.isMaskSet(inactiveNodeMask));\n            return 0.0;\n        });\n        return data.maxDeviationRadians;\n    }\n    assignOffsetByAverageNormalAroundVertex(vertexSeed, maxAllowedDeviationRadians, data, distance) {\n        const maxDeviationRadians = this.computeAverageNormalAndMaxDeviationAroundVertex(vertexSeed, data);\n        if (OffsetMeshContext.stringDebugFunction) {\n            OffsetMeshContext.stringDebugFunction(`XYZ ${HalfEdge.nodeToIdXYZString(vertexSeed)} Average Normal ${data.averageNormal.toJSON()}`);\n            OffsetMeshContext.stringDebugFunction(`           angle ratio ${data.radiansSum / (2 * Math.PI)}   maxDeviation ${data.maxDeviationRadiansFromAverage}`);\n        }\n        if (maxDeviationRadians !== undefined && maxDeviationRadians <= maxAllowedDeviationRadians) {\n            vertexSeed.sumAroundVertex((node) => {\n                SectorOffsetProperties.setNormalAtHalfEdge(node, data.averageNormal, distance);\n                return 0;\n            });\n            return true;\n        }\n        return false;\n    }\n    /** Search around a vertex for a sector which has a different normal from its vertexPredecessor.\n     * * The seed will be the first candidate considered\n    */\n    markBreakEdgesAndSaveAverageNormalsAroundVertex(vertexSeed) {\n        vertexSeed.clearMaskAroundVertex(this._breakMaskA);\n        vertexSeed.clearMaskAroundVertex(this._breakMaskB);\n        const smoothSingleSmoothRadiansBetweenNormals = this._smoothRadiansBetweenNormals;\n        const accumulatedRadiansBetweenNormals = this._smoothAccumulatedRadiansBetweenNormals;\n        // Step 1: Examine the edge between nodeA and the sector on its vertex predecessor side.  This (alone) determines single angle breaks.\n        let numBreaks = 0;\n        let nodeP = vertexSeed;\n        let _numSmooth = 0;\n        do {\n            const nodeQ = nodeP.edgeMate;\n            const nodeR = nodeQ.faceSuccessor; // same as nodeA.vertexPredecessor\n            if (nodeP.isMaskSet(this._exteriorMask)) {\n                if (!nodeQ.isMaskSet(this._exteriorMask)) {\n                    nodeR.setMask(this._breakMaskB);\n                    numBreaks++;\n                }\n            }\n            else {\n                if (nodeP.isMaskSet(this._outsideOfChamferFace)) {\n                    nodeP.setMask(this._breakMaskA);\n                }\n                else if (nodeP.isMaskSet(this._outsideEndOfChamferFace)) {\n                    nodeP.setMask(this._breakMaskA);\n                    nodeP.setMask(this._breakMaskB);\n                }\n                else if (nodeP.isMaskSet(this._insideChamferSling)) {\n                    // This is the sling.   It's normal is along edge -- not really a break.\n                }\n                else if (nodeP.isMaskSet(this._insideOfChamferFace)) {\n                    nodeP.setMask(this._breakMaskA);\n                    nodeP.setMask(this._breakMaskB);\n                    nodeR.setMask(this._breakMaskB);\n                }\n                else if (nodeQ.isMaskSet(this._exteriorMask)) {\n                    numBreaks++;\n                    nodeP.setMask(this._breakMaskA);\n                }\n                else if (!SectorOffsetProperties.almostEqualNormals(nodeP.edgeTag, nodeR.edgeTag, smoothSingleSmoothRadiansBetweenNormals)) {\n                    nodeP.setMask(this._breakMaskA);\n                    numBreaks++;\n                    nodeR.setMask(this._breakMaskB);\n                }\n                else {\n                    _numSmooth++;\n                }\n            }\n            nodeP = nodeP.vertexSuccessor;\n        } while (nodeP !== vertexSeed);\n        if (OffsetMeshContext.stringDebugFunction !== undefined)\n            OffsetMeshContext.stringDebugFunction(`   numSkip   ${_numSmooth} `);\n        if (numBreaks === 0) {\n            // make the first vertex a break so subsequent searches have a place to start\n            vertexSeed.setMask(this._breakMaskA);\n            vertexSeed.vertexPredecessor.setMask(this._breakMaskB);\n            numBreaks = 1;\n        }\n        // Step 2: At each single break, sweep forward to its closing breakB.  Insert breaks at accumulated angles.\n        // (minor TODO: for the insertion case, try to split more equally.)\n        const nodeAStart = nodeP.findMaskAroundVertex(this._breakMaskA);\n        if (nodeAStart !== undefined) {\n            nodeP = nodeAStart;\n            do {\n                if (nodeP.isMaskSet(this._breakMaskA) && !nodeP.isMaskSet(this._breakMaskB)) {\n                    let accumulatedRadians = 0.0;\n                    do {\n                        const nodeB = nodeP.vertexSuccessor;\n                        accumulatedRadians += SectorOffsetProperties.radiansBetweenNormals(nodeP.edgeTag, nodeB.edgeTag);\n                        if (accumulatedRadians > accumulatedRadiansBetweenNormals) {\n                            nodeP.setMask(this._breakMaskB);\n                            nodeB.setMask(this._breakMaskA);\n                            numBreaks++;\n                            accumulatedRadians = 0.0;\n                        }\n                        nodeP = nodeB;\n                    } while (!nodeP.isMaskSet(this._breakMaskB));\n                }\n                else {\n                    nodeP = nodeP.vertexSuccessor;\n                }\n            } while (nodeP !== nodeAStart);\n        }\n        if (numBreaks > 0 && nodeAStart !== undefined) {\n            // In each compound sector, accumulate and install average normal.\n            nodeP = nodeAStart;\n            const averageNormal = Vector3d.create();\n            const edgeVectorU = Vector3d.create();\n            const edgeVectorV = Vector3d.create();\n            averageNormal.setZero();\n            do {\n                if (nodeP.isMaskSet(this._breakMaskA) && !nodeP.isMaskSet(this._breakMaskB)) {\n                    let nodeQ = nodeP;\n                    averageNormal.setZero();\n                    for (;;) {\n                        nodeQ.vectorToFaceSuccessor(edgeVectorU);\n                        nodeQ.vectorToFacePredecessor(edgeVectorV);\n                        let singleSectorRadians = edgeVectorU.signedRadiansTo(edgeVectorV, nodeQ.faceTag.facetNormal.direction);\n                        if (singleSectorRadians < 0.0)\n                            singleSectorRadians += Math.PI * 2;\n                        SectorOffsetProperties.accumulateScaledNormalAtHalfEdge(nodeQ, singleSectorRadians, averageNormal);\n                        if (nodeQ.isMaskSet(this._breakMaskB))\n                            break;\n                        nodeQ = nodeQ.vertexSuccessor;\n                    }\n                    if (averageNormal.normalizeInPlace()) {\n                        nodeQ = nodeP;\n                        for (;;) {\n                            SectorOffsetProperties.setNormalAtHalfEdge(nodeQ, averageNormal);\n                            if (nodeQ.isMaskSet(this._breakMaskB))\n                                break;\n                            nodeQ = nodeQ.vertexSuccessor;\n                        }\n                    }\n                }\n                nodeP = nodeP.vertexSuccessor;\n            } while (nodeP !== nodeAStart);\n        }\n    }\n    /** Compute the point of intersection of the planes in the sectors of 3 half edges */\n    compute3SectorIntersection(nodeA, nodeB, nodeC, result) {\n        const sectorA = nodeA.edgeTag;\n        const sectorB = nodeB.edgeTag;\n        const sectorC = nodeC.edgeTag;\n        const vector = SmallSystem.intersect3Planes(sectorA.xyz, sectorA.normal, sectorB.xyz, sectorB.normal, sectorC.xyz, sectorC.normal, result);\n        return vector;\n    }\n    /** Compute the point of intersection of the planes in the sectors of 3 half edges */\n    compute3SectorIntersectionDebug(nodeA, nodeB, nodeC, result) {\n        const sectorA = nodeA.edgeTag;\n        const sectorB = nodeB.edgeTag;\n        const sectorC = nodeC.edgeTag;\n        if (OffsetMeshContext.stringDebugFunction !== undefined) {\n            OffsetMeshContext.stringDebugFunction(`compute3${this.inspectMasks(nodeA)}${this.inspectMasks(nodeB)}${this.inspectMasks(nodeC)} `);\n            for (const sector of [sectorA, sectorB, sectorC])\n                emitSector(sector);\n        }\n        const vector = SmallSystem.intersect3Planes(sectorA.xyz, sectorA.normal, sectorB.xyz, sectorB.normal, sectorC.xyz, sectorC.normal, result);\n        if (OffsetMeshContext.stringDebugFunction !== undefined) {\n            if (vector === undefined)\n                OffsetMeshContext.stringDebugFunction(\" NO INTERSECTION\");\n            else\n                OffsetMeshContext.stringDebugFunction(` ComputedVector ${vector.x},${vector.y},${vector.z} `);\n        }\n        return vector;\n    }\n    /** Compute the point of intersection of the planes in the sectors of 2 half edges, using cross product of their normals to resolve */\n    compute2SectorIntersection(nodeA, nodeB, result) {\n        const sectorA = nodeA.edgeTag;\n        const sectorB = nodeB.edgeTag;\n        const normalC = sectorA.normal.crossProduct(sectorB.normal);\n        return SmallSystem.intersect3Planes(sectorA.xyz, sectorA.normal, sectorB.xyz, sectorB.normal, sectorB.xyz, normalC, result);\n    }\n    /**\n     * * at input, graph has all original faces and edges\n     *   * each sector points to a faceProperties with original facet normal\n     * * at exit:\n     *    * new \"chamfer faces\" are added outside of edges with angle between normal sin excess of options.chamferTurnAngleBetweenNormals\n     *    * the original edge is split along its length to create space\n     *      * one edge \"along\" each direction inside the slit.\n     *      * a sling edge at each end of the slit.\n     *          * outside of the sling is part of the slit face loop.\n     *          * inside is a single-node face\n     *    * thus the slit itself has 4 nodes.\n     *    * the two nodes at each end can thus contain the two distinct points at that end of the chamfer.\n     *    * all 4 nodes of the slit face point to a new FacetOffsetProperties with the average normal.\n     *    * the inside of each sling face has\n     *        * original vertex coordinates in the node\n     *        * face properties with a normal pointing outward from that end of the original edge -- hence define a plane that can clip the chamfer\n     *    * the two points at each end of the chamfer are computed as the intersection of\n     *        * chamfer plane\n     *        * sling plane\n     *        * adjacent plane of the face on the other side of the edge being chamfered.\n     * @param distance distance to offset.  The sign of this is important in the chamfer construction.\n     */\n    addChamferTopologyToAllEdges(options, distance) {\n        const edgesToChamfer = [];\n        const chamferRadians = options.chamferAngleBetweenNormals.radians;\n        const vertexXYZ = Point3d.create(); // reuse\n        const edgeVector = Vector3d.create(); // reuse\n        const outwardEdgeVector = Vector3d.create(); // reuse\n        const averageNormal = Vector3d.create(); // reuse\n        // collect all the edges with sharp turn angle.\n        this._baseGraph.announceEdges((_graph, edgeNode) => {\n            if (SectorOffsetProperties.edgeHasLargeExteriorAngleBetweenNormals(edgeNode, edgeVector, averageNormal, distance, chamferRadians)) {\n                edgesToChamfer.push(edgeNode);\n                return true;\n            }\n            return true;\n        });\n        // Create sliver faces.\n        // Sliver face gets an average normal from its neighbors.\n        //  outsideA is the HalfEdge labeled A in the diagram.\n        // sliverDX and sliverDY are the edges \"inside the sliver\" at the respective X and Y ends.\n        for (const outsideA of edgesToChamfer) {\n            // remark: this recomputes as in collection round.\n            if (SectorOffsetProperties.edgeHasLargeExteriorAngleBetweenNormals(outsideA, edgeVector, averageNormal, chamferRadians)) {\n                // This copies coordinates and vertex id .... sectorOffsetProperties are delayed until late in the 2-pass loop below.\n                // The returned HalfEdge is labeled D in the diagram\n                const sliverDX = this._baseGraph.splitEdgeCreateSliverFace(outsideA);\n                const sliverDY = sliverDX.facePredecessor;\n                const offsetPoint = sliverDX.getPoint3d();\n                offsetPoint.addScaledInPlace(averageNormal, distance);\n                const ray = Ray3d.createCapture(offsetPoint, averageNormal.clone());\n                const facetProperties = new FacetOffsetProperties(-1, ray);\n                // for each side (hence end) of the sliver face, set mask and install a sling loop for the anticipated end of the chamfer face\n                // new node names in the loop omit X or Y suffix because that is implied by which pass is running.\n                let s = -1.0;\n                for (const sliverD of [sliverDX, sliverDY]) {\n                    edgeVector.scale(s, outwardEdgeVector);\n                    sliverD.getPoint3d(vertexXYZ);\n                    sliverD.setMask(this._insideOfChamferFace);\n                    sliverD.edgeMate.setMask(this._outsideOfChamferFace);\n                    // mark and reference the chamfer face.\n                    sliverD.faceTag = facetProperties;\n                    // sling at this end\n                    const slingB = this._baseGraph.splitEdge(undefined, vertexXYZ.x, vertexXYZ.y, vertexXYZ.z, sliverD.i);\n                    const slingC = slingB.edgeMate;\n                    slingB.setMask(this._outsideEndOfChamferFace);\n                    slingB.faceTag = facetProperties;\n                    slingC.setMask(this._insideChamferSling);\n                    HalfEdge.pinch(sliverD, slingB);\n                    const endNormal = Ray3d.create(vertexXYZ, outwardEdgeVector); // clones the inputs\n                    const slingFaceProperties = new FacetOffsetProperties(-1, endNormal);\n                    slingC.faceTag = slingFaceProperties;\n                    // initialize sectors with existing vertex point.\n                    sliverD.edgeTag = new SectorOffsetProperties(averageNormal.clone(), offsetPoint.clone());\n                    slingB.edgeTag = new SectorOffsetProperties(averageNormal.clone(), offsetPoint.clone());\n                    slingC.edgeTag = new SectorOffsetProperties(outwardEdgeVector.clone(), vertexXYZ.clone());\n                    // OffsetMeshContext.stringDebugFunction(\"Chamfer Setup\");\n                    const chamferPointE = this.compute3SectorIntersection(sliverD, sliverD.edgeMate, slingC);\n                    const chamferPointF = this.compute3SectorIntersection(slingB, slingB.vertexSuccessor, slingC);\n                    // sliverD.edgeTag = new SectorOffsetProperties(averageNormal.clone(), vertexXYZ.clone());\n                    SectorOffsetProperties.setXYZAtHalfEdge(sliverD, chamferPointE);\n                    SectorOffsetProperties.setXYZAtHalfEdge(slingB, chamferPointF);\n                    s *= -1.0;\n                }\n            }\n        }\n    }\n    /**\n     * * at input:\n     *   * Each node points to sectorOffsetProperties with previously computed XYZ (presumably mismatched)\n     * * at exit:\n     *    * Each sectorOffsetProperties has an offset point computed with consideration of offset planes in the neighborhood.\n     * @param distance distance to offset.\n     */\n    computeOffsetFacetIntersections(distance) {\n        if (OffsetMeshContext.stringDebugFunction !== undefined)\n            OffsetMeshContext.stringDebugFunction(\"*****                                 recompute intersections\");\n        const breakEdges = [];\n        const vertexXYZ = Point3d.create();\n        const chamferXYZ = Point3d.create();\n        const maxVertexMove = 2.0 * distance;\n        const averageNormalData = new AverageNormalData();\n        const maxAllowedNormalDeviationRadians = Angle.degreesToRadians(25.0);\n        //\n        // FOR EACH VERTEX\n        //\n        this._baseGraph.announceVertexLoops((_graph, vertexSeedA) => {\n            // reposition to an important vertex.\n            // first choice: a chamfer face.\n            let vertexSeed = vertexSeedA.findMaskAroundVertex(this._outsideEndOfChamferFace);\n            if (vertexSeed === undefined)\n                vertexSeed = vertexSeedA.findMaskAroundVertex(this._breakMaskA);\n            if (vertexSeed === undefined)\n                vertexSeed = vertexSeedA;\n            if (OffsetMeshContext.stringDebugFunction !== undefined) {\n                OffsetMeshContext.stringDebugFunction(\"\");\n                OffsetMeshContext.stringDebugFunction(` VERTEX LOOP   ${vertexSeed.getPoint3d().toJSON()} `);\n                vertexSeed.sumAroundVertex((node) => { OffsetMeshContext.stringDebugFunction(this.inspectMasks(node, false, true)); return 0; });\n            }\n            // Take care of the easiest vertices directly . . . note that this returns from the lambda, not computeOffsetFacetIntersections\n            if (this.assignOffsetByAverageNormalAroundVertex(vertexSeed, maxAllowedNormalDeviationRadians, averageNormalData, distance))\n                return true;\n            this.markBreakEdgesAndSaveAverageNormalsAroundVertex(vertexSeed);\n            this.setOffsetAtDistanceAroundVertex(vertexSeed, distance, true);\n            vertexSeed.collectMaskedEdgesAroundVertex(this._breakMaskA, true, breakEdges);\n            if (OffsetMeshContext.stringDebugFunction !== undefined) {\n                OffsetMeshContext.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(vertexSeed, true, false)}`);\n                for (const node of breakEdges) {\n                    OffsetMeshContext.stringDebugFunction(this.inspectMasks(node, false, true));\n                }\n            }\n            if (breakEdges.length <= 1) {\n                // just one smooth sequence.\n                // everything is set already.\n            }\n            else if (breakEdges.length === 2) {\n                // exterior vertex with two incident smooth\n                const vectorFromOrigin = this.compute2SectorIntersection(breakEdges[0], breakEdges[1]);\n                if (vectorFromOrigin !== undefined) {\n                    this.setOffsetXYAndZAroundVertex(vertexSeed, vectorFromOrigin);\n                }\n            }\n            else if (breakEdges.length === 3) {\n                if (OffsetMeshContext.stringDebugFunction !== undefined)\n                    OffsetMeshContext.stringDebugFunction(` Vertex Update just ${breakEdges.length} `);\n                const vectorFromOrigin = this.compute3SectorIntersection(breakEdges[0], breakEdges[1], breakEdges[2]);\n                if (vectorFromOrigin !== undefined) {\n                    this.setOffsetXYAndZAroundVertex(vertexSeed, vectorFromOrigin);\n                }\n                // simple 3-face corner . . .\n            }\n            else {\n                // Lots and Lots of edges\n                // each set of 3 sectors independently generates an offset for its central sector.\n                if (OffsetMeshContext.stringDebugFunction !== undefined)\n                    OffsetMeshContext.stringDebugFunction(` Vertex Update breakEdges ${breakEdges.length} `);\n                vertexSeed.getPoint3d(vertexXYZ);\n                // Pass 1 -- look for intersection among multiple chamfers\n                for (let i = 0; i < breakEdges.length; i++) {\n                    const i0 = i;\n                    const i1 = (i0 + 1) % breakEdges.length;\n                    const i2 = (i1 + 1) % breakEdges.length;\n                    if (breakEdges[i0].isMaskSet(this._outsideEndOfChamferFace)\n                        && breakEdges[i1].isMaskSet(this._outsideOfChamferFace)\n                        && breakEdges[i2].isMaskSet(this._insideOfChamferFace)) {\n                        if (OffsetMeshContext.stringDebugFunction !== undefined)\n                            OffsetMeshContext.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(breakEdges[i0])} ${this.inspectMasks(breakEdges[i1])} ${this.inspectMasks(breakEdges[i2])} `);\n                        const vectorFromOrigin = this.compute3SectorIntersection(breakEdges[i0], breakEdges[i1], breakEdges[i2]);\n                        if (vectorFromOrigin !== undefined) {\n                            // Treat all 3 spots as possibly compound sequences\n                            for (const iOutput of [i0, i1, i2]) {\n                                this.announceNodeAndSectorPropertiesInSmoothSector(breakEdges[iOutput], (node, properties) => {\n                                    properties.setXYAndZ(vectorFromOrigin);\n                                    node.setMask(this._offsetCoordinatesReassigned);\n                                });\n                            }\n                            // Since all three were reset, skip past.  This is done on the acyclic integer that controls the loop.\n                            i += 2;\n                        }\n                    }\n                }\n                // Pass 2 -- look for unassigned nodes just before or after a chamfer.\n                //  The chamfer wins\n                for (let i = 0; i < breakEdges.length; i++) {\n                    const i0 = i;\n                    const i1 = (i0 + 1) % breakEdges.length;\n                    if (this.isInsideSling(breakEdges[i0], breakEdges[i1]))\n                        continue;\n                    if (!this.isOffsetAssigned(breakEdges[i0])\n                        && breakEdges[i1].isMaskSet(this.insideOfChamferFace)) {\n                        this.transferXYZFromNodeToSmoothSector(breakEdges[i1], breakEdges[i0], \"push left from chamfer\", chamferXYZ);\n                    }\n                    else if (!this.isOffsetAssigned(breakEdges[i1])\n                        && breakEdges[i0].isMaskSet(this.outsideEndOfChamferFace)) {\n                        this.transferXYZFromNodeToSmoothSector(breakEdges[i0], breakEdges[i1], \"push right from chamfer\", chamferXYZ);\n                    }\n                }\n                // Pass 3 -- look for unassigned nodes as middle of 3-face intersections\n                for (let i = 0; i < breakEdges.length; i++) {\n                    const i0 = i;\n                    const i1 = (i0 + 1) % breakEdges.length;\n                    const i2 = (i1 + 1) % breakEdges.length;\n                    if (this.isInsideSling(breakEdges[i0], breakEdges[i1], breakEdges[i2]))\n                        continue;\n                    if (this.isOffsetAssigned(breakEdges[i1]))\n                        continue;\n                    if (OffsetMeshContext.stringDebugFunction !== undefined)\n                        OffsetMeshContext.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(breakEdges[i0])} ${this.inspectMasks(breakEdges[i1])} ${this.inspectMasks(breakEdges[i2])} `);\n                    const vectorFromOrigin = this.compute3SectorIntersection(breakEdges[i0], breakEdges[i1], breakEdges[i2]);\n                    if (vectorFromOrigin !== undefined) {\n                        if (vertexXYZ.distance(vectorFromOrigin) < maxVertexMove) {\n                            this.announceNodeAndSectorPropertiesInSmoothSector(breakEdges[i1], (node, properties) => {\n                                properties.setXYAndZ(vectorFromOrigin);\n                                node.setMask(this._offsetCoordinatesReassigned);\n                            });\n                        }\n                    }\n                }\n            }\n            if (OffsetMeshContext.stringDebugFunction !== undefined) {\n                const n0 = vertexSeed.countMaskAroundVertex(this._offsetCoordinatesReassigned, false);\n                const n1 = vertexSeed.countMaskAroundVertex(this._offsetCoordinatesReassigned, true);\n                const message = `   **** Vertex offset mask counts(TRUE ${n1})(FALSE ${n0})`;\n                OffsetMeshContext.stringDebugFunction(message);\n            }\n            return true;\n        });\n    }\n    // return true if any of these nodes is \"inside\" the sling at the end of a chamfer.\n    isInsideSling(node0, node1, node2) {\n        return node0.isMaskSet(this._insideChamferSling)\n            || (node1 !== undefined && node1.isMaskSet(this._insideChamferSling))\n            || (node2 !== undefined && node2.isMaskSet(this._insideChamferSling));\n    }\n    // return true if any of these nodes is \"inside\" the sling at the end of a chamfer.\n    isInsideChamferOrSling(node0) {\n        return node0.isMaskSet(this._insideChamferSling)\n            || node0.isMaskSet(this._insideOfChamferFace)\n            || node0.isMaskSet(this._outsideEndOfChamferFace);\n    }\n    isOffsetAssigned(node0, node1, node2) {\n        return node0.isMaskSet(this._offsetCoordinatesReassigned)\n            || (node1 !== undefined && node1.isMaskSet(this._offsetCoordinatesReassigned))\n            || (node2 !== undefined && node2.isMaskSet(this._offsetCoordinatesReassigned));\n    }\n    /**\n     *\n     * @param sourceNode node with good xyz\n     * @param destinationStartNode first of a sequence of nodes to set (delimited by masks)\n     * @param description string for debug\n     * @param workPoint point to use for coordinate transfer.\n     */\n    transferXYZFromNodeToSmoothSector(sourceNode, destinationStartNode, description, workPoint) {\n        if (OffsetMeshContext.stringDebugFunction !== undefined)\n            OffsetMeshContext.stringDebugFunction(`    ${description} ${this.inspectMasks(sourceNode)} to ${this.inspectMasks(destinationStartNode)}} `);\n        SectorOffsetProperties.getSectorPointAtHalfEdge(sourceNode, workPoint, undefined);\n        this.announceNodeAndSectorPropertiesInSmoothSector(destinationStartNode, (node, properties) => {\n            properties.setXYAndZ(workPoint);\n            node.setMask(this._offsetCoordinatesReassigned);\n        });\n    }\n}\n//# sourceMappingURL=OffsetMeshContext.js.map",
      "start": 1693508125525,
      "end": 1693508125618,
      "sourcemaps": null
    }
  ]
}
