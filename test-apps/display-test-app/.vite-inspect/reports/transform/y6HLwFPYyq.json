{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/spiral/MXCubicAlongArcSpiralEvaluator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../../Geometry\";\nimport { CubicEvaluator } from \"./CubicEvaluator\";\n/**\n * MX Cubic along arc.\n * This is y= m*x^3 with\n * * x any point on the x axis\n * * `fraction` along the spiral goes to `x = fraction * Lx`\n * * m is (1/6RL)\n * * construction length L is nominal along the curve.\n * * x length Lx is along the axis, determined by two terms of the clothoid x series.\n * *\n * @param localToWorld\n * @param nominalL1\n * @param nominalR1\n * @param activeInterval\n * @internal\n */\nexport class MXCubicAlongArcEvaluator extends CubicEvaluator {\n    /** Constructor is private.  Caller responsible for cubicM validity. */\n    constructor(length1, radius1, axisLength, cubicM) {\n        super(axisLength, cubicM);\n        this.nominalLength1 = length1;\n        this.nominalRadius1 = radius1;\n    }\n    /** Compute the cubic constant. */\n    static computeCubicM(length1, radius1) {\n        const axisLength = MXCubicAlongArcEvaluator.approximateDistanceAlongToX(length1, radius1, length1);\n        return 1.0 / (6.0 * radius1 * axisLength);\n    }\n    static create(length1, radius1) {\n        const m = this.computeCubicM(length1, radius1);\n        if (m === undefined)\n            return undefined;\n        const xMax = MXCubicAlongArcEvaluator.approximateDistanceAlongToX(length1, radius1, length1);\n        return new MXCubicAlongArcEvaluator(length1, radius1, xMax, m);\n    }\n    scaleInPlace(scaleFactor) {\n        this.nominalLength1 *= scaleFactor;\n        this.nominalRadius1 *= scaleFactor;\n        super.scaleInPlace(scaleFactor);\n    }\n    /** return a deep copy of the evaluator */\n    clone() { return new MXCubicAlongArcEvaluator(this.nominalLength1, this.nominalRadius1, super._axisLength, this.cubicM); }\n    /** Member by member matchup ... */\n    isAlmostEqual(other) {\n        if (other instanceof MXCubicAlongArcEvaluator) {\n            return Geometry.isSameCoordinate(this.nominalLength1, other.nominalLength1)\n                && Geometry.isSameCoordinate(this.nominalRadius1, other.nominalRadius1);\n        }\n        return false;\n    }\n    /**\n     * Return a (fast but mediocre) approximation of spiral x position as function of approximate distance along the curve.\n     * * This x-to-distance relation is not as precise as the CurvePrimitive method moveSignedDistanceFromFraction.\n     * * It is supported here for users interested in replicating the Czech distance mapping rather than the more accurate CurvePrimitive measurements.\n     * @param x distance along the x axis.\n     */\n    static approximateDistanceAlongToX(nominalLength1, nominalRadius1, nominalDistanceAlong) {\n        const l2 = nominalLength1 * nominalLength1;\n        const r2 = nominalRadius1 * nominalRadius1;\n        const xx = nominalDistanceAlong * nominalDistanceAlong;\n        return nominalDistanceAlong * (1.0 - xx * xx / (40.0 * r2 * l2));\n    }\n}\n//# sourceMappingURL=MXCubicAlongArcSpiralEvaluator.js.map",
      "start": 1693508125386,
      "end": 1693508125539,
      "sourcemaps": null
    }
  ]
}
