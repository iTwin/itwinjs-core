{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/frontend-tiles/lib/esm/FrontendTiles.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Logger } from \"@itwin/core-bentley\";\nimport { IModelApp, SpatialTileTreeReferences } from \"@itwin/core-frontend\";\nimport { loggerCategory } from \"./LoggerCategory\";\nimport { createBatchedSpatialTileTreeReferences } from \"./BatchedSpatialTileTreeRefs\";\nfunction createMeshExportServiceQueryUrl(args) {\n    const prefix = args.urlPrefix ?? \"\";\n    let url = `https://${prefix}api.bentley.com/mesh-export/?iModelId=${args.iModelId}&$orderBy=date:desc`;\n    if (args.changesetId)\n        url = `${url}&changesetId=${args.changesetId}`;\n    return url;\n}\n/** Query the [mesh export service](https://developer.bentley.com/apis/mesh-export/operations/get-exports/) for exports of type \"IMODEL\" matching\n * the specified criteria.\n * The exports are sorted from most-recently- to least-recently-produced.\n * @beta\n */\nexport async function* queryMeshExports(args) {\n    const headers = {\n        /* eslint-disable-next-line @typescript-eslint/naming-convention */\n        Authorization: args.accessToken ?? await IModelApp.getAccessToken(),\n        /* eslint-disable-next-line @typescript-eslint/naming-convention */\n        Accept: \"application/vnd.bentley.itwin-platform.v1+json\",\n        /* eslint-disable-next-line @typescript-eslint/naming-convention */\n        Prefer: \"return=representation\",\n    };\n    let url = createMeshExportServiceQueryUrl(args);\n    while (url) {\n        let result;\n        try {\n            const response = await fetch(url, { headers });\n            result = await response.json();\n        }\n        catch (err) {\n            Logger.logException(loggerCategory, err);\n            Logger.logError(loggerCategory, `Failed loading exports for iModel ${args.iModelId}`);\n            break;\n        }\n        const foundExports = result.exports.filter((x) => x.request.exportType === \"IMODEL\" && (args.includeIncomplete || x.status === \"Complete\"));\n        for (const foundExport of foundExports)\n            yield foundExport;\n        url = result._links.next?.href;\n    }\n}\n/** Obtains a URL pointing to a tileset appropriate for visualizing a specific iModel.\n * [[queryCompletedMeshExports]] is used to obtain a list of available exports. By default, the list is sorted from most to least recently-exported.\n * The first export matching the iModel's changeset is selected; or, if no such export exists, the first export in the list is selected.\n * @returns A URL from which the tileset can be loaded, or `undefined` if no appropriate URL could be obtained.\n * @beta\n */\nexport async function obtainMeshExportTilesetUrl(args) {\n    if (!args.iModel.iModelId) {\n        Logger.logInfo(loggerCategory, \"Cannot obtain exports for an iModel with no iModelId\");\n        return undefined;\n    }\n    const queryArgs = {\n        accessToken: args.accessToken,\n        iModelId: args.iModel.iModelId,\n        changesetId: args.iModel.changeset.id,\n        urlPrefix: args.urlPrefix,\n    };\n    let selectedExport;\n    for await (const exp of queryMeshExports(queryArgs)) {\n        selectedExport = exp;\n        break;\n    }\n    if (!selectedExport && !args.requireExactChangeset) {\n        queryArgs.changesetId = undefined;\n        for await (const exp of queryMeshExports(queryArgs)) {\n            selectedExport = exp;\n            Logger.logInfo(loggerCategory, `No exports for iModel ${args.iModel.iModelId} for changeset ${args.iModel.changeset.id}; falling back to most recent`);\n            break;\n        }\n    }\n    if (!selectedExport) {\n        Logger.logInfo(loggerCategory, `No exports available for iModel ${args.iModel.iModelId}`);\n        return undefined;\n    }\n    const url = new URL(selectedExport._links.mesh.href);\n    url.pathname = `${url.pathname}/tileset.json`;\n    return url;\n}\n/** @internal */\nexport const createFallbackSpatialTileTreeReferences = SpatialTileTreeReferences.create;\nlet maxLevelsToSkip = 4;\n/** @internal */\nexport function getMaxLevelsToSkip() {\n    return maxLevelsToSkip;\n}\n/** Initialize the frontend-tiles package to obtain tiles for spatial views.\n * @beta\n */\nexport function initializeFrontendTiles(options) {\n    if (undefined !== options.maxLevelsToSkip && options.maxLevelsToSkip >= 0)\n        maxLevelsToSkip = options.maxLevelsToSkip;\n    const computeUrl = options.computeSpatialTilesetBaseUrl ?? (async (iModel) => obtainMeshExportTilesetUrl({ iModel, accessToken: await IModelApp.getAccessToken() }));\n    SpatialTileTreeReferences.create = (view) => createBatchedSpatialTileTreeReferences(view, computeUrl);\n}\n//# sourceMappingURL=FrontendTiles.js.map",
      "start": 1693508121122,
      "end": 1693508121192,
      "sourcemaps": null
    }
  ]
}
