{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/OutputShadersTool.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { DebugShaderFile, IModelApp, NotifyMessageDetails, OutputMessagePriority, Tool } from \"@itwin/core-frontend\";\r\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\r\n\r\n// cspell:disable\r\n\r\nconst makeShadeBat = `\r\n\r\n@echo off\r\nrem Compiles *VS.hlsl and *FS.hlsl to .h  Also Outputs _WarningsList.txt, _ErrorFileList.txt, and _StatsList.txt\r\nrem /Zi param is sometimes useful (see fxc /?)\r\nrem asm reference https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm4-asm\r\n\r\necho:List of files with errors:> _ErrorFileList.txt\r\necho:> _WarningsList.txt\r\necho:> _StatsList.txt\r\nset _temps=0\r\nset _instr=0\r\nset _fname=\"\"\r\nset /a \"_totVert=0\"\r\nset /a \"_errVert=0\"\r\nset /a \"_tempsVert=0\"\r\nset /a \"_instrVert=0\"\r\nset /a \"_totFrag=0\"\r\nset /a \"_errFrag=0\"\r\nset /a \"_tempsFrag=0\"\r\nset /a \"_instrFrag=0\"\r\nset /a \"_tempsTot=0\"\r\nset /a \"_instrTot=0\"\r\nset /a \"_errTot=0\"\r\n\r\nrem find path to use for fxc.exe\r\nset fxcPath=\"\"\r\ncall :GetWin10SdkDir\r\nif not exist %fxcPath% (\r\n  echo: Error: fxc.exe not found on this machine, aborting\r\n  echo: Is a Windows 10 SDK installed?\r\n  exit /B 1\r\n)\r\ncall :SetFxcShort %fxcPath%\r\necho:Using fxc.exe found at: %fxcPath%\r\necho:\r\n%fxcshort%  /? | findstr Direct3D\r\necho:\r\n\r\nsetlocal enableDelayedExpansion\r\nrem compile vertex shaders\r\nrem qqq for /F %%G in ('dir *VS.hlsl /ON/B') do call :MakeVS4 %%G %1 %2 %3 %4\r\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\r\necho:Prepping VS compile commands...\r\ncall :BuildVSCmdList\r\nset _totShaders=%_totVert%\r\necho:Starting parallel VS compiles of %_totVert% shaders...\r\ncall :RunCmdsParallel\r\necho:Processing VS results...\r\ncall :CalcStats VS\r\nset _errVert=%_errTot%\r\nset _tempsVert=%_tempsTot%\r\nset _instrVert=%_instrTot%\r\n\r\nrem compile fragment shaders\r\nset /a \"_tempsTot=0\"\r\nset /a \"_instrTot=0\"\r\nset /a \"_errTot=0\"\r\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\r\necho:Prepping FS compile commands...\r\ncall :BuildFSCmdList\r\nset _totShaders=%_totFrag%\r\necho:Starting parallel FS compiles of %_totFrag% shaders...\r\ncall :RunCmdsParallel\r\necho:Processing FS results...\r\ncall :CalcStats FS\r\nset _errFrag=%_errTot%\r\nset _tempsFrag=%_tempsTot%\r\nset _instrFrag=%_instrTot%\r\n\r\ncall :OutputResults\r\necho:  See _ErrorFileList.txt for details, see _WarningsList.txt for any warnings or errors\r\ncall :OutputResults >> _ErrorFileList.txt\r\necho:  See _WarningsList.txt for any warnings or errors>> _ErrorFileList.txt\r\ncall :OutputResults >> _StatsList.txt\r\necho:  See _WarningsList.txt for any warnings or errors>> _StatsList.txt\r\n\r\nendlocal\r\nrem call :CleanupALL\r\ngoto :EOF\r\n\r\n:CleanupALL\r\nset _totVert=\r\nset _errVert=\r\nset _tempsVert=\r\nset _instrVert=\r\nset _totVert=\r\nset _totFrag=\r\nset _errFrag=\r\nset _tempsFrag=\r\nset _instrFrag=\r\nset _temps=\r\nset _instr=\r\nset _fname=\r\nset _totShaders=\r\nset _tempsTot=\r\ngoto :EOF\r\n\r\n:SetFxcShort\r\nrem - Get short filename version of path\r\nset fxcShort=%~s1\r\ngoto :EOF\r\n\r\n:BuildVSCmdList\r\nfor /F %%G in ('dir *VS.hlsl /ON/B') do (\r\n    set /a \"_totVert=_totVert+1\"\r\n    if exist %%~nG.h del %%~nG.h\r\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T vs_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\r\n)\r\ngoto :EOF\r\n\r\n:BuildFSCmdList\r\nfor /F %%G in ('dir *FS.hlsl /ON/B') do (\r\n    set /a \"_totFrag=_totFrag+1\"\r\n    if exist %%~nG.h del %%~nG.h\r\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T ps_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\r\n)\r\ngoto :EOF\r\nrem to get preprocessor output (mainly indenting, and minus any defines) use something like this separately:\r\nrem %fxcshort% /nologo /E main /P listings\\\\%%~nG.hlsl %%~nG.hlsl\r\n\r\n\r\n:CalcStats\r\ndir *%1.h /ON/B > _TmpBldCmds.txt\r\nfor /F \"tokens=1-5 delims=: \" %%G in ('findstr /F:_TmpBldCmds.txt \"instruction dcl_temps\"') do (\r\n  if \"%%~nG\" NEQ \"!_fname!\" (\r\n    set \"_temps=   \"\r\n    set _instr=\r\n    set _fname=%%~nG\r\n  )\r\n  if \"%%H\" EQU \"dcl_temps\" set _temps=    %%I\r\n  if \"%%K\" EQU \"instruction\" (\r\n    set _instr=    %%J\r\n    set _temps=!_temps:~-3!\r\n    set _instr=!_instr:~-4!\r\n    rem echo:  !_temps! regs  !_instr! instructions  !_fname!\r\n    echo:  !_temps! regs  !_instr! instructions  !_fname!>> _StatsList.txt\r\n    set /a \"_tempsTot=_tempsTot+_temps\"\r\n    set /a \"_instrTot=_instrTot+_instr\"\r\n  )\r\n)\r\ndel _TmpBldCmds.txt\r\nfor /F %%G in ('dir *%1.hlsl /ON/B') do (\r\n  if not exist %%~nG.h (\r\n  set /a \"_errTot=_errTot+1\"\r\n  echo:%%G>>_ErrorFileList.txt\r\n  echo:ERROR compiling %%G, no .h produced\r\n  )\r\n)\r\ngoto :EOF\r\n\r\n:OutputResults\r\necho:\r\necho: --- Compiled %_totVert% vertex shaders with %_errVert% errors  Totals: %_tempsVert% regs  %_instrVert% instructions\r\necho:\r\necho: --- Compiled %_totFrag% fragment shaders with %_errfrag% errors  Totals: %_tempsFrag% regs  %_instrFrag% instructions\r\necho:\r\ngoto :EOF\r\n\r\n:GetWin10SdkDir\r\n  call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE > nul 2>&1\r\n  if errorlevel 1 set fxcPath=\"c:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\bin\\\\x64\\\\fxc.exe\"\r\ngoto :EOF\r\n\r\n:GetWin10SdkDirHelper\r\n    setlocal enableDelayedExpansion\r\n    rem Get Windows 10 SDK installed folder\r\n    for /F \"tokens=1,2*\" %%i in ('reg query \"%1\\\\Microsoft\\\\Microsoft SDKs\\\\Windows\\\\v10.0\" /v \"InstallationFolder\"') DO (\r\n        echo:   i [%%i] j [%%j]\r\n        if \"%%i\"==\"InstallationFolder\" (\r\n            set WindowsSdkDir=%%~k\r\n        )\r\n    )\r\n    rem Due to SDK installer changes beginning 10.0.15063.0 (RS2 SDK), the SDK installed may not have required stuff\r\n    rem Check for the existence of fxc since that is what is needed here\r\n    set __check_file=fxc.exe\r\n    if not \"%WindowsSdkDir%\"==\"\" for /f %%i IN ('dir \"%WindowsSdkDir%bin\\\\\" /b /ad-h /o-n') DO (\r\n      if EXIST \"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\" (\r\n        set result=%%i\r\n        if \"!result:~0,3!\"==\"10.\" (\r\n          endlocal\r\n          set fxcPath=\"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\"\r\n          goto :EOF\r\n        )\r\n      )\r\n    )\r\nexit /B 1\r\ngoto :EOF\r\n\r\n\r\n:RunCmdsParallel\r\n  rem Based on example code by @dbenham at https://stackoverflow.com/questions/672719/parallel-execution-of-shell-processes\r\n  setlocal enableDelayedExpansion\r\n  set \"lockHandle=1\"\r\n\r\n:: Define the maximum number of parallel processes to run.\r\n  set \"maxProc=%NUMBER_OF_PROCESSORS%\"\r\n  rem set /a \"maxProc=maxProc / 2\"\r\n\r\n:: Get a unique base lock name for this particular instantiation.\r\n:: Incorporate a timestamp from WMIC if possible, but don't fail if WMIC not available.\r\n:: Also incorporate a random number.  These are output to the env %temp% folder and removed at the end.\r\n:: Example filenames: lock20200507001149.344000_15305_6, lock20200507001149.344000_15305_6_data\r\n:: Also added lock20200507001149.344000_15305_Err_shaderName for this, for ordering stderr output.\r\n  set \"lock=\"\r\n  for /f \"skip=1 delims=-+ \" %%T in ('2^>nul wmic os get localdatetime') do (\r\n    set \"lock=%%T\"\r\n    goto :RCP_break\r\n  )\r\n  :RCP_break\r\n  set \"lock=%temp%\\\\lock%lock%_%random%_\"\r\n\r\n:: Initialize the counters\r\n  set /a \"startCount=0, endCount=0, cCnt=1\"\r\n\r\n:: Clear any existing end flags\r\n  for /l %%N in (1 1 %maxProc%) do set \"endProc%%N=\"\r\n\r\n:: Launch the commands in a loop\r\n  set launch=1\r\n  for /f \"tokens=1,2* delims=;\" %%A in (_TmpBldCmds.txt) do (\r\n    if !startCount! lss %maxProc% (\r\n      set /a \"startCount+=1, nextProc=startCount\"\r\n    ) else (\r\n      call :RCP_wait\r\n    )\r\n    set cmd!nextProc!=%%B\r\n    rem echo !time! - proc!nextProc!: starting %%B\r\n    2>nul del %lock%!nextProc!_data\r\n\techo %%A>\"%lock%!nextProc!_data\"\r\n    2>nul del %lock%!nextProc!\r\n    2>nul del %lock%Err_%%A\r\n    %= Redirect the lock handle to the lock file. The CMD process will     =%\r\n    %= maintain an exclusive lock on the lock file until the process ends. =%\r\n    start /b \"\" cmd /c %lockHandle%^>\"%lock%!nextProc!\" 2^>\"%lock%Err_%%A\" %%B\r\n  )\r\n  set \"launch=\"\r\n\r\n:RCP_wait\r\n:: Wait for procs to finish in a loop\r\n:: If still launching then return as soon as a proc ends, else wait for all procs to finish\r\n:: redirect stderr to null to suppress any error message if redirection within the loop fails.\r\n  for /l %%N in (1 1 %startCount%) do 2>nul (\r\n    %= Redirect an unused file handle to the lock file. If the process is    =%\r\n    %= still running then redirection will fail and the IF body will not run =%\r\n    if not defined endProc%%N if exist \"%lock%%%N\" 9>>\"%lock%%%N\" (\r\n      %= Made it inside the IF body so the process must have finished =%\r\n      rem echo !time! - proc%%N: finished !cmd%%N!\r\n      rem   these two options are just as fast as without them, but on a different line than the count\r\n      rem   the first is the name of the file, 2nd is the result of the compile (including name)\r\n      rem type \"%lock%%%N_data\"\r\n      rem type \"%lock%%%N\"\r\n      echo:  !cCnt! of %_totShaders%\r\n      set /a \"cCnt+=1\"\r\n      if defined launch (\r\n        set nextProc=%%N\r\n        exit /b\r\n      )\r\n      set /a \"endCount+=1, endProc%%N=1\"\r\n    )\r\n  )\r\n  if %endCount% lss %startCount% (\r\n    1>nul 2>nul ping /n 2 ::1\r\n    goto :RCP_wait\r\n  )\r\n\r\nrem Process stderr outputs\r\ndir %lock%Err_* /ON/B/S > _TmpBldCmds.txt\r\nfor /F \"tokens=*\" %%G in (_TmpBldCmds.txt) do (type \"%%G\" >> _WarningsList.txt)\r\ndel _TmpBldCmds.txt\r\necho:\r\n\r\n2>nul del %lock%*\r\ngoto :EOF\r\n`;\r\n\r\nfunction skipThisShader(entry: DebugShaderFile, usedFlag: string, typeFlag: string, langFlag: string): boolean {\r\n  return (\"n\" === usedFlag && entry.isUsed) || (\"u\" === usedFlag && !entry.isUsed) ||\r\n    (\"f\" === typeFlag && entry.isVS) || (\"v\" === typeFlag && !entry.isVS) ||\r\n    (\"h\" === langFlag && entry.isGL) || (\"g\" === langFlag && !entry.isGL);\r\n}\r\n\r\nasync function outputShaders(dsf: DebugShaderFile[], usedFlag: string, typeFlag: string, langFlag: string, dir: string) {\r\n  // output shader make file\r\n  let fname = `${dir}_makeShade.bat`;\r\n  await DtaRpcInterface.getClient().writeExternalFile(fname, makeShadeBat);\r\n\r\n  // output output list\r\n  fname = `${dir}_OutputList.txt`;\r\n  let src = \"\";\r\n  for (const entry of dsf) {\r\n    if (!skipThisShader(entry, usedFlag, typeFlag, langFlag))\r\n      src = `${src + entry.filename}  isUsed: ${entry.isUsed}\\n`;\r\n  }\r\n  await DtaRpcInterface.getClient().writeExternalFile(fname, src);\r\n\r\n  // output shader files\r\n  for (const entry of dsf) {\r\n    if (skipThisShader(entry, usedFlag, typeFlag, langFlag))\r\n      continue;\r\n\r\n    fname = dir + entry.filename;\r\n    src = (entry.isGL ? \"\" : `// ${entry.filename}  isUsed: ${entry.isUsed}\\n`) + entry.src;\r\n    await DtaRpcInterface.getClient().writeExternalFile(fname, src);\r\n  }\r\n\r\n  IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Shaders output to directory ${dir}`));\r\n}\r\n\r\nexport class OutputShadersTool extends Tool {\r\n  public static override toolId = \"OutputShaders\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 2; }\r\n\r\n  public override async run(compile: boolean, usedFlag: string, typeFlag: string, langFlag: string, outputDir: string): Promise<boolean> {\r\n    if (compile) {\r\n      const compiled = IModelApp.renderSystem.debugControl?.compileAllShaders();\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(compiled ? OutputMessagePriority.Info : OutputMessagePriority.Error, `${compiled ? \"No\" : \"Some\"} compilation errors occurred.`));\r\n    }\r\n    const dsf = IModelApp.renderSystem.debugControl?.debugShaderFiles;\r\n    if (undefined !== dsf && dsf.length > 0)\r\n      await outputShaders(dsf, usedFlag, typeFlag, langFlag, outputDir);\r\n    else\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, \"No shaders (did you define IMJS_DEBUG_SHADERS?)\"));\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    let compile = false;\r\n    let usedFlag;\r\n    let typeFlag;\r\n    let langFlag;\r\n    let outputDir;\r\n\r\n    for (const arg of args) {\r\n      const parts = arg.split(\"=\");\r\n      if (1 === parts.length) {\r\n        const lowerArgs = parts[0].toLowerCase();\r\n        compile = lowerArgs.includes(\"c\");\r\n        usedFlag = lowerArgs.includes(\"u\") ? \"u\" : (lowerArgs.includes(\"n\") ? \"n\" : \"\");\r\n        typeFlag = lowerArgs.includes(\"v\") ? \"v\" : (lowerArgs.includes(\"f\") ? \"f\" : \"\");\r\n        langFlag = lowerArgs.includes(\"g\") ? \"g\" : (lowerArgs.includes(\"h\") ? \"h\" : \"\");\r\n      } else if (2 === parts.length && \"d\" === parts[0].toLowerCase()) {\r\n        outputDir = parts[1];\r\n        if (-1 !== outputDir.indexOf(\"\\\\\") && !outputDir.endsWith(\"\\\\\"))\r\n          outputDir += \"\\\\\";\r\n        else if (-1 !== outputDir.indexOf(\"/\") && !outputDir.endsWith(\"/\"))\r\n          outputDir += \"/\";\r\n      }\r\n    }\r\n\r\n    return this.run(compile, usedFlag ?? \"\", typeFlag ?? \"\", langFlag ?? \"\", outputDir ?? \"d:\\\\temp\\\\shaders\\\\\");\r\n  }\r\n}\r\n",
      "start": 1693508121213,
      "end": 1693508121256,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { IModelApp, NotifyMessageDetails, OutputMessagePriority, Tool } from \"@itwin/core-frontend\";\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\nconst makeShadeBat = `\n\n@echo off\nrem Compiles *VS.hlsl and *FS.hlsl to .h  Also Outputs _WarningsList.txt, _ErrorFileList.txt, and _StatsList.txt\nrem /Zi param is sometimes useful (see fxc /?)\nrem asm reference https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm4-asm\n\necho:List of files with errors:> _ErrorFileList.txt\necho:> _WarningsList.txt\necho:> _StatsList.txt\nset _temps=0\nset _instr=0\nset _fname=\"\"\nset /a \"_totVert=0\"\nset /a \"_errVert=0\"\nset /a \"_tempsVert=0\"\nset /a \"_instrVert=0\"\nset /a \"_totFrag=0\"\nset /a \"_errFrag=0\"\nset /a \"_tempsFrag=0\"\nset /a \"_instrFrag=0\"\nset /a \"_tempsTot=0\"\nset /a \"_instrTot=0\"\nset /a \"_errTot=0\"\n\nrem find path to use for fxc.exe\nset fxcPath=\"\"\ncall :GetWin10SdkDir\nif not exist %fxcPath% (\n  echo: Error: fxc.exe not found on this machine, aborting\n  echo: Is a Windows 10 SDK installed?\n  exit /B 1\n)\ncall :SetFxcShort %fxcPath%\necho:Using fxc.exe found at: %fxcPath%\necho:\n%fxcshort%  /? | findstr Direct3D\necho:\n\nsetlocal enableDelayedExpansion\nrem compile vertex shaders\nrem qqq for /F %%G in ('dir *VS.hlsl /ON/B') do call :MakeVS4 %%G %1 %2 %3 %4\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\necho:Prepping VS compile commands...\ncall :BuildVSCmdList\nset _totShaders=%_totVert%\necho:Starting parallel VS compiles of %_totVert% shaders...\ncall :RunCmdsParallel\necho:Processing VS results...\ncall :CalcStats VS\nset _errVert=%_errTot%\nset _tempsVert=%_tempsTot%\nset _instrVert=%_instrTot%\n\nrem compile fragment shaders\nset /a \"_tempsTot=0\"\nset /a \"_instrTot=0\"\nset /a \"_errTot=0\"\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\necho:Prepping FS compile commands...\ncall :BuildFSCmdList\nset _totShaders=%_totFrag%\necho:Starting parallel FS compiles of %_totFrag% shaders...\ncall :RunCmdsParallel\necho:Processing FS results...\ncall :CalcStats FS\nset _errFrag=%_errTot%\nset _tempsFrag=%_tempsTot%\nset _instrFrag=%_instrTot%\n\ncall :OutputResults\necho:  See _ErrorFileList.txt for details, see _WarningsList.txt for any warnings or errors\ncall :OutputResults >> _ErrorFileList.txt\necho:  See _WarningsList.txt for any warnings or errors>> _ErrorFileList.txt\ncall :OutputResults >> _StatsList.txt\necho:  See _WarningsList.txt for any warnings or errors>> _StatsList.txt\n\nendlocal\nrem call :CleanupALL\ngoto :EOF\n\n:CleanupALL\nset _totVert=\nset _errVert=\nset _tempsVert=\nset _instrVert=\nset _totVert=\nset _totFrag=\nset _errFrag=\nset _tempsFrag=\nset _instrFrag=\nset _temps=\nset _instr=\nset _fname=\nset _totShaders=\nset _tempsTot=\ngoto :EOF\n\n:SetFxcShort\nrem - Get short filename version of path\nset fxcShort=%~s1\ngoto :EOF\n\n:BuildVSCmdList\nfor /F %%G in ('dir *VS.hlsl /ON/B') do (\n    set /a \"_totVert=_totVert+1\"\n    if exist %%~nG.h del %%~nG.h\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T vs_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\n)\ngoto :EOF\n\n:BuildFSCmdList\nfor /F %%G in ('dir *FS.hlsl /ON/B') do (\n    set /a \"_totFrag=_totFrag+1\"\n    if exist %%~nG.h del %%~nG.h\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T ps_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\n)\ngoto :EOF\nrem to get preprocessor output (mainly indenting, and minus any defines) use something like this separately:\nrem %fxcshort% /nologo /E main /P listings\\\\%%~nG.hlsl %%~nG.hlsl\n\n\n:CalcStats\ndir *%1.h /ON/B > _TmpBldCmds.txt\nfor /F \"tokens=1-5 delims=: \" %%G in ('findstr /F:_TmpBldCmds.txt \"instruction dcl_temps\"') do (\n  if \"%%~nG\" NEQ \"!_fname!\" (\n    set \"_temps=   \"\n    set _instr=\n    set _fname=%%~nG\n  )\n  if \"%%H\" EQU \"dcl_temps\" set _temps=    %%I\n  if \"%%K\" EQU \"instruction\" (\n    set _instr=    %%J\n    set _temps=!_temps:~-3!\n    set _instr=!_instr:~-4!\n    rem echo:  !_temps! regs  !_instr! instructions  !_fname!\n    echo:  !_temps! regs  !_instr! instructions  !_fname!>> _StatsList.txt\n    set /a \"_tempsTot=_tempsTot+_temps\"\n    set /a \"_instrTot=_instrTot+_instr\"\n  )\n)\ndel _TmpBldCmds.txt\nfor /F %%G in ('dir *%1.hlsl /ON/B') do (\n  if not exist %%~nG.h (\n  set /a \"_errTot=_errTot+1\"\n  echo:%%G>>_ErrorFileList.txt\n  echo:ERROR compiling %%G, no .h produced\n  )\n)\ngoto :EOF\n\n:OutputResults\necho:\necho: --- Compiled %_totVert% vertex shaders with %_errVert% errors  Totals: %_tempsVert% regs  %_instrVert% instructions\necho:\necho: --- Compiled %_totFrag% fragment shaders with %_errfrag% errors  Totals: %_tempsFrag% regs  %_instrFrag% instructions\necho:\ngoto :EOF\n\n:GetWin10SdkDir\n  call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\n  if errorlevel 1 call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE > nul 2>&1\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE > nul 2>&1\n  if errorlevel 1 set fxcPath=\"c:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\bin\\\\x64\\\\fxc.exe\"\ngoto :EOF\n\n:GetWin10SdkDirHelper\n    setlocal enableDelayedExpansion\n    rem Get Windows 10 SDK installed folder\n    for /F \"tokens=1,2*\" %%i in ('reg query \"%1\\\\Microsoft\\\\Microsoft SDKs\\\\Windows\\\\v10.0\" /v \"InstallationFolder\"') DO (\n        echo:   i [%%i] j [%%j]\n        if \"%%i\"==\"InstallationFolder\" (\n            set WindowsSdkDir=%%~k\n        )\n    )\n    rem Due to SDK installer changes beginning 10.0.15063.0 (RS2 SDK), the SDK installed may not have required stuff\n    rem Check for the existence of fxc since that is what is needed here\n    set __check_file=fxc.exe\n    if not \"%WindowsSdkDir%\"==\"\" for /f %%i IN ('dir \"%WindowsSdkDir%bin\\\\\" /b /ad-h /o-n') DO (\n      if EXIST \"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\" (\n        set result=%%i\n        if \"!result:~0,3!\"==\"10.\" (\n          endlocal\n          set fxcPath=\"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\"\n          goto :EOF\n        )\n      )\n    )\nexit /B 1\ngoto :EOF\n\n\n:RunCmdsParallel\n  rem Based on example code by @dbenham at https://stackoverflow.com/questions/672719/parallel-execution-of-shell-processes\n  setlocal enableDelayedExpansion\n  set \"lockHandle=1\"\n\n:: Define the maximum number of parallel processes to run.\n  set \"maxProc=%NUMBER_OF_PROCESSORS%\"\n  rem set /a \"maxProc=maxProc / 2\"\n\n:: Get a unique base lock name for this particular instantiation.\n:: Incorporate a timestamp from WMIC if possible, but don't fail if WMIC not available.\n:: Also incorporate a random number.  These are output to the env %temp% folder and removed at the end.\n:: Example filenames: lock20200507001149.344000_15305_6, lock20200507001149.344000_15305_6_data\n:: Also added lock20200507001149.344000_15305_Err_shaderName for this, for ordering stderr output.\n  set \"lock=\"\n  for /f \"skip=1 delims=-+ \" %%T in ('2^>nul wmic os get localdatetime') do (\n    set \"lock=%%T\"\n    goto :RCP_break\n  )\n  :RCP_break\n  set \"lock=%temp%\\\\lock%lock%_%random%_\"\n\n:: Initialize the counters\n  set /a \"startCount=0, endCount=0, cCnt=1\"\n\n:: Clear any existing end flags\n  for /l %%N in (1 1 %maxProc%) do set \"endProc%%N=\"\n\n:: Launch the commands in a loop\n  set launch=1\n  for /f \"tokens=1,2* delims=;\" %%A in (_TmpBldCmds.txt) do (\n    if !startCount! lss %maxProc% (\n      set /a \"startCount+=1, nextProc=startCount\"\n    ) else (\n      call :RCP_wait\n    )\n    set cmd!nextProc!=%%B\n    rem echo !time! - proc!nextProc!: starting %%B\n    2>nul del %lock%!nextProc!_data\n\techo %%A>\"%lock%!nextProc!_data\"\n    2>nul del %lock%!nextProc!\n    2>nul del %lock%Err_%%A\n    %= Redirect the lock handle to the lock file. The CMD process will     =%\n    %= maintain an exclusive lock on the lock file until the process ends. =%\n    start /b \"\" cmd /c %lockHandle%^>\"%lock%!nextProc!\" 2^>\"%lock%Err_%%A\" %%B\n  )\n  set \"launch=\"\n\n:RCP_wait\n:: Wait for procs to finish in a loop\n:: If still launching then return as soon as a proc ends, else wait for all procs to finish\n:: redirect stderr to null to suppress any error message if redirection within the loop fails.\n  for /l %%N in (1 1 %startCount%) do 2>nul (\n    %= Redirect an unused file handle to the lock file. If the process is    =%\n    %= still running then redirection will fail and the IF body will not run =%\n    if not defined endProc%%N if exist \"%lock%%%N\" 9>>\"%lock%%%N\" (\n      %= Made it inside the IF body so the process must have finished =%\n      rem echo !time! - proc%%N: finished !cmd%%N!\n      rem   these two options are just as fast as without them, but on a different line than the count\n      rem   the first is the name of the file, 2nd is the result of the compile (including name)\n      rem type \"%lock%%%N_data\"\n      rem type \"%lock%%%N\"\n      echo:  !cCnt! of %_totShaders%\n      set /a \"cCnt+=1\"\n      if defined launch (\n        set nextProc=%%N\n        exit /b\n      )\n      set /a \"endCount+=1, endProc%%N=1\"\n    )\n  )\n  if %endCount% lss %startCount% (\n    1>nul 2>nul ping /n 2 ::1\n    goto :RCP_wait\n  )\n\nrem Process stderr outputs\ndir %lock%Err_* /ON/B/S > _TmpBldCmds.txt\nfor /F \"tokens=*\" %%G in (_TmpBldCmds.txt) do (type \"%%G\" >> _WarningsList.txt)\ndel _TmpBldCmds.txt\necho:\n\n2>nul del %lock%*\ngoto :EOF\n`;\nfunction skipThisShader(entry, usedFlag, typeFlag, langFlag) {\n  return \"n\" === usedFlag && entry.isUsed || \"u\" === usedFlag && !entry.isUsed || \"f\" === typeFlag && entry.isVS || \"v\" === typeFlag && !entry.isVS || \"h\" === langFlag && entry.isGL || \"g\" === langFlag && !entry.isGL;\n}\nasync function outputShaders(dsf, usedFlag, typeFlag, langFlag, dir) {\n  let fname = `${dir}_makeShade.bat`;\n  await DtaRpcInterface.getClient().writeExternalFile(fname, makeShadeBat);\n  fname = `${dir}_OutputList.txt`;\n  let src = \"\";\n  for (const entry of dsf) {\n    if (!skipThisShader(entry, usedFlag, typeFlag, langFlag))\n      src = `${src + entry.filename}  isUsed: ${entry.isUsed}\n`;\n  }\n  await DtaRpcInterface.getClient().writeExternalFile(fname, src);\n  for (const entry of dsf) {\n    if (skipThisShader(entry, usedFlag, typeFlag, langFlag))\n      continue;\n    fname = dir + entry.filename;\n    src = (entry.isGL ? \"\" : `// ${entry.filename}  isUsed: ${entry.isUsed}\n`) + entry.src;\n    await DtaRpcInterface.getClient().writeExternalFile(fname, src);\n  }\n  IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Shaders output to directory ${dir}`));\n}\nexport class OutputShadersTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 2;\n  }\n  async run(compile, usedFlag, typeFlag, langFlag, outputDir) {\n    if (compile) {\n      const compiled = IModelApp.renderSystem.debugControl?.compileAllShaders();\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(compiled ? OutputMessagePriority.Info : OutputMessagePriority.Error, `${compiled ? \"No\" : \"Some\"} compilation errors occurred.`));\n    }\n    const dsf = IModelApp.renderSystem.debugControl?.debugShaderFiles;\n    if (void 0 !== dsf && dsf.length > 0)\n      await outputShaders(dsf, usedFlag, typeFlag, langFlag, outputDir);\n    else\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, \"No shaders (did you define IMJS_DEBUG_SHADERS?)\"));\n    return true;\n  }\n  async parseAndRun(...args) {\n    let compile = false;\n    let usedFlag;\n    let typeFlag;\n    let langFlag;\n    let outputDir;\n    for (const arg of args) {\n      const parts = arg.split(\"=\");\n      if (1 === parts.length) {\n        const lowerArgs = parts[0].toLowerCase();\n        compile = lowerArgs.includes(\"c\");\n        usedFlag = lowerArgs.includes(\"u\") ? \"u\" : lowerArgs.includes(\"n\") ? \"n\" : \"\";\n        typeFlag = lowerArgs.includes(\"v\") ? \"v\" : lowerArgs.includes(\"f\") ? \"f\" : \"\";\n        langFlag = lowerArgs.includes(\"g\") ? \"g\" : lowerArgs.includes(\"h\") ? \"h\" : \"\";\n      } else if (2 === parts.length && \"d\" === parts[0].toLowerCase()) {\n        outputDir = parts[1];\n        if (-1 !== outputDir.indexOf(\"\\\\\") && !outputDir.endsWith(\"\\\\\"))\n          outputDir += \"\\\\\";\n        else if (-1 !== outputDir.indexOf(\"/\") && !outputDir.endsWith(\"/\"))\n          outputDir += \"/\";\n      }\n    }\n    return this.run(compile, usedFlag ?? \"\", typeFlag ?? \"\", langFlag ?? \"\", outputDir ?? \"d:\\\\temp\\\\shaders\\\\\");\n  }\n}\nOutputShadersTool.toolId = \"OutputShaders\";\n",
      "start": 1693508121256,
      "end": 1693508121455,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/OutputShadersTool.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { DebugShaderFile, IModelApp, NotifyMessageDetails, OutputMessagePriority, Tool } from \"@itwin/core-frontend\";\r\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\r\n\r\n// cspell:disable\r\n\r\nconst makeShadeBat = `\r\n\r\n@echo off\r\nrem Compiles *VS.hlsl and *FS.hlsl to .h  Also Outputs _WarningsList.txt, _ErrorFileList.txt, and _StatsList.txt\r\nrem /Zi param is sometimes useful (see fxc /?)\r\nrem asm reference https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm4-asm\r\n\r\necho:List of files with errors:> _ErrorFileList.txt\r\necho:> _WarningsList.txt\r\necho:> _StatsList.txt\r\nset _temps=0\r\nset _instr=0\r\nset _fname=\"\"\r\nset /a \"_totVert=0\"\r\nset /a \"_errVert=0\"\r\nset /a \"_tempsVert=0\"\r\nset /a \"_instrVert=0\"\r\nset /a \"_totFrag=0\"\r\nset /a \"_errFrag=0\"\r\nset /a \"_tempsFrag=0\"\r\nset /a \"_instrFrag=0\"\r\nset /a \"_tempsTot=0\"\r\nset /a \"_instrTot=0\"\r\nset /a \"_errTot=0\"\r\n\r\nrem find path to use for fxc.exe\r\nset fxcPath=\"\"\r\ncall :GetWin10SdkDir\r\nif not exist %fxcPath% (\r\n  echo: Error: fxc.exe not found on this machine, aborting\r\n  echo: Is a Windows 10 SDK installed?\r\n  exit /B 1\r\n)\r\ncall :SetFxcShort %fxcPath%\r\necho:Using fxc.exe found at: %fxcPath%\r\necho:\r\n%fxcshort%  /? | findstr Direct3D\r\necho:\r\n\r\nsetlocal enableDelayedExpansion\r\nrem compile vertex shaders\r\nrem qqq for /F %%G in ('dir *VS.hlsl /ON/B') do call :MakeVS4 %%G %1 %2 %3 %4\r\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\r\necho:Prepping VS compile commands...\r\ncall :BuildVSCmdList\r\nset _totShaders=%_totVert%\r\necho:Starting parallel VS compiles of %_totVert% shaders...\r\ncall :RunCmdsParallel\r\necho:Processing VS results...\r\ncall :CalcStats VS\r\nset _errVert=%_errTot%\r\nset _tempsVert=%_tempsTot%\r\nset _instrVert=%_instrTot%\r\n\r\nrem compile fragment shaders\r\nset /a \"_tempsTot=0\"\r\nset /a \"_instrTot=0\"\r\nset /a \"_errTot=0\"\r\nif exist _TmpBldCmds.txt del _TmpBldCmds.txt\r\necho:Prepping FS compile commands...\r\ncall :BuildFSCmdList\r\nset _totShaders=%_totFrag%\r\necho:Starting parallel FS compiles of %_totFrag% shaders...\r\ncall :RunCmdsParallel\r\necho:Processing FS results...\r\ncall :CalcStats FS\r\nset _errFrag=%_errTot%\r\nset _tempsFrag=%_tempsTot%\r\nset _instrFrag=%_instrTot%\r\n\r\ncall :OutputResults\r\necho:  See _ErrorFileList.txt for details, see _WarningsList.txt for any warnings or errors\r\ncall :OutputResults >> _ErrorFileList.txt\r\necho:  See _WarningsList.txt for any warnings or errors>> _ErrorFileList.txt\r\ncall :OutputResults >> _StatsList.txt\r\necho:  See _WarningsList.txt for any warnings or errors>> _StatsList.txt\r\n\r\nendlocal\r\nrem call :CleanupALL\r\ngoto :EOF\r\n\r\n:CleanupALL\r\nset _totVert=\r\nset _errVert=\r\nset _tempsVert=\r\nset _instrVert=\r\nset _totVert=\r\nset _totFrag=\r\nset _errFrag=\r\nset _tempsFrag=\r\nset _instrFrag=\r\nset _temps=\r\nset _instr=\r\nset _fname=\r\nset _totShaders=\r\nset _tempsTot=\r\ngoto :EOF\r\n\r\n:SetFxcShort\r\nrem - Get short filename version of path\r\nset fxcShort=%~s1\r\ngoto :EOF\r\n\r\n:BuildVSCmdList\r\nfor /F %%G in ('dir *VS.hlsl /ON/B') do (\r\n    set /a \"_totVert=_totVert+1\"\r\n    if exist %%~nG.h del %%~nG.h\r\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T vs_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\r\n)\r\ngoto :EOF\r\n\r\n:BuildFSCmdList\r\nfor /F %%G in ('dir *FS.hlsl /ON/B') do (\r\n    set /a \"_totFrag=_totFrag+1\"\r\n    if exist %%~nG.h del %%~nG.h\r\n    echo %%~nG;%fxcshort% /nologo %1 %2 %3 %4 /T ps_4_0 /E main /Fc %%~nG.h %%~nG.hlsl>> _TmpBldCmds.txt\r\n)\r\ngoto :EOF\r\nrem to get preprocessor output (mainly indenting, and minus any defines) use something like this separately:\r\nrem %fxcshort% /nologo /E main /P listings\\\\%%~nG.hlsl %%~nG.hlsl\r\n\r\n\r\n:CalcStats\r\ndir *%1.h /ON/B > _TmpBldCmds.txt\r\nfor /F \"tokens=1-5 delims=: \" %%G in ('findstr /F:_TmpBldCmds.txt \"instruction dcl_temps\"') do (\r\n  if \"%%~nG\" NEQ \"!_fname!\" (\r\n    set \"_temps=   \"\r\n    set _instr=\r\n    set _fname=%%~nG\r\n  )\r\n  if \"%%H\" EQU \"dcl_temps\" set _temps=    %%I\r\n  if \"%%K\" EQU \"instruction\" (\r\n    set _instr=    %%J\r\n    set _temps=!_temps:~-3!\r\n    set _instr=!_instr:~-4!\r\n    rem echo:  !_temps! regs  !_instr! instructions  !_fname!\r\n    echo:  !_temps! regs  !_instr! instructions  !_fname!>> _StatsList.txt\r\n    set /a \"_tempsTot=_tempsTot+_temps\"\r\n    set /a \"_instrTot=_instrTot+_instr\"\r\n  )\r\n)\r\ndel _TmpBldCmds.txt\r\nfor /F %%G in ('dir *%1.hlsl /ON/B') do (\r\n  if not exist %%~nG.h (\r\n  set /a \"_errTot=_errTot+1\"\r\n  echo:%%G>>_ErrorFileList.txt\r\n  echo:ERROR compiling %%G, no .h produced\r\n  )\r\n)\r\ngoto :EOF\r\n\r\n:OutputResults\r\necho:\r\necho: --- Compiled %_totVert% vertex shaders with %_errVert% errors  Totals: %_tempsVert% regs  %_instrVert% instructions\r\necho:\r\necho: --- Compiled %_totFrag% fragment shaders with %_errfrag% errors  Totals: %_tempsFrag% regs  %_instrFrag% instructions\r\necho:\r\ngoto :EOF\r\n\r\n:GetWin10SdkDir\r\n  call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE\\\\Wow6432Node > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKLM\\\\SOFTWARE > nul 2>&1\r\n  if errorlevel 1 call :GetWin10SdkDirHelper HKCU\\\\SOFTWARE > nul 2>&1\r\n  if errorlevel 1 set fxcPath=\"c:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\bin\\\\x64\\\\fxc.exe\"\r\ngoto :EOF\r\n\r\n:GetWin10SdkDirHelper\r\n    setlocal enableDelayedExpansion\r\n    rem Get Windows 10 SDK installed folder\r\n    for /F \"tokens=1,2*\" %%i in ('reg query \"%1\\\\Microsoft\\\\Microsoft SDKs\\\\Windows\\\\v10.0\" /v \"InstallationFolder\"') DO (\r\n        echo:   i [%%i] j [%%j]\r\n        if \"%%i\"==\"InstallationFolder\" (\r\n            set WindowsSdkDir=%%~k\r\n        )\r\n    )\r\n    rem Due to SDK installer changes beginning 10.0.15063.0 (RS2 SDK), the SDK installed may not have required stuff\r\n    rem Check for the existence of fxc since that is what is needed here\r\n    set __check_file=fxc.exe\r\n    if not \"%WindowsSdkDir%\"==\"\" for /f %%i IN ('dir \"%WindowsSdkDir%bin\\\\\" /b /ad-h /o-n') DO (\r\n      if EXIST \"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\" (\r\n        set result=%%i\r\n        if \"!result:~0,3!\"==\"10.\" (\r\n          endlocal\r\n          set fxcPath=\"%WindowsSdkDir%bin\\\\%%i\\\\x64\\\\%__check_file%\"\r\n          goto :EOF\r\n        )\r\n      )\r\n    )\r\nexit /B 1\r\ngoto :EOF\r\n\r\n\r\n:RunCmdsParallel\r\n  rem Based on example code by @dbenham at https://stackoverflow.com/questions/672719/parallel-execution-of-shell-processes\r\n  setlocal enableDelayedExpansion\r\n  set \"lockHandle=1\"\r\n\r\n:: Define the maximum number of parallel processes to run.\r\n  set \"maxProc=%NUMBER_OF_PROCESSORS%\"\r\n  rem set /a \"maxProc=maxProc / 2\"\r\n\r\n:: Get a unique base lock name for this particular instantiation.\r\n:: Incorporate a timestamp from WMIC if possible, but don't fail if WMIC not available.\r\n:: Also incorporate a random number.  These are output to the env %temp% folder and removed at the end.\r\n:: Example filenames: lock20200507001149.344000_15305_6, lock20200507001149.344000_15305_6_data\r\n:: Also added lock20200507001149.344000_15305_Err_shaderName for this, for ordering stderr output.\r\n  set \"lock=\"\r\n  for /f \"skip=1 delims=-+ \" %%T in ('2^>nul wmic os get localdatetime') do (\r\n    set \"lock=%%T\"\r\n    goto :RCP_break\r\n  )\r\n  :RCP_break\r\n  set \"lock=%temp%\\\\lock%lock%_%random%_\"\r\n\r\n:: Initialize the counters\r\n  set /a \"startCount=0, endCount=0, cCnt=1\"\r\n\r\n:: Clear any existing end flags\r\n  for /l %%N in (1 1 %maxProc%) do set \"endProc%%N=\"\r\n\r\n:: Launch the commands in a loop\r\n  set launch=1\r\n  for /f \"tokens=1,2* delims=;\" %%A in (_TmpBldCmds.txt) do (\r\n    if !startCount! lss %maxProc% (\r\n      set /a \"startCount+=1, nextProc=startCount\"\r\n    ) else (\r\n      call :RCP_wait\r\n    )\r\n    set cmd!nextProc!=%%B\r\n    rem echo !time! - proc!nextProc!: starting %%B\r\n    2>nul del %lock%!nextProc!_data\r\n\techo %%A>\"%lock%!nextProc!_data\"\r\n    2>nul del %lock%!nextProc!\r\n    2>nul del %lock%Err_%%A\r\n    %= Redirect the lock handle to the lock file. The CMD process will     =%\r\n    %= maintain an exclusive lock on the lock file until the process ends. =%\r\n    start /b \"\" cmd /c %lockHandle%^>\"%lock%!nextProc!\" 2^>\"%lock%Err_%%A\" %%B\r\n  )\r\n  set \"launch=\"\r\n\r\n:RCP_wait\r\n:: Wait for procs to finish in a loop\r\n:: If still launching then return as soon as a proc ends, else wait for all procs to finish\r\n:: redirect stderr to null to suppress any error message if redirection within the loop fails.\r\n  for /l %%N in (1 1 %startCount%) do 2>nul (\r\n    %= Redirect an unused file handle to the lock file. If the process is    =%\r\n    %= still running then redirection will fail and the IF body will not run =%\r\n    if not defined endProc%%N if exist \"%lock%%%N\" 9>>\"%lock%%%N\" (\r\n      %= Made it inside the IF body so the process must have finished =%\r\n      rem echo !time! - proc%%N: finished !cmd%%N!\r\n      rem   these two options are just as fast as without them, but on a different line than the count\r\n      rem   the first is the name of the file, 2nd is the result of the compile (including name)\r\n      rem type \"%lock%%%N_data\"\r\n      rem type \"%lock%%%N\"\r\n      echo:  !cCnt! of %_totShaders%\r\n      set /a \"cCnt+=1\"\r\n      if defined launch (\r\n        set nextProc=%%N\r\n        exit /b\r\n      )\r\n      set /a \"endCount+=1, endProc%%N=1\"\r\n    )\r\n  )\r\n  if %endCount% lss %startCount% (\r\n    1>nul 2>nul ping /n 2 ::1\r\n    goto :RCP_wait\r\n  )\r\n\r\nrem Process stderr outputs\r\ndir %lock%Err_* /ON/B/S > _TmpBldCmds.txt\r\nfor /F \"tokens=*\" %%G in (_TmpBldCmds.txt) do (type \"%%G\" >> _WarningsList.txt)\r\ndel _TmpBldCmds.txt\r\necho:\r\n\r\n2>nul del %lock%*\r\ngoto :EOF\r\n`;\r\n\r\nfunction skipThisShader(entry: DebugShaderFile, usedFlag: string, typeFlag: string, langFlag: string): boolean {\r\n  return (\"n\" === usedFlag && entry.isUsed) || (\"u\" === usedFlag && !entry.isUsed) ||\r\n    (\"f\" === typeFlag && entry.isVS) || (\"v\" === typeFlag && !entry.isVS) ||\r\n    (\"h\" === langFlag && entry.isGL) || (\"g\" === langFlag && !entry.isGL);\r\n}\r\n\r\nasync function outputShaders(dsf: DebugShaderFile[], usedFlag: string, typeFlag: string, langFlag: string, dir: string) {\r\n  // output shader make file\r\n  let fname = `${dir}_makeShade.bat`;\r\n  await DtaRpcInterface.getClient().writeExternalFile(fname, makeShadeBat);\r\n\r\n  // output output list\r\n  fname = `${dir}_OutputList.txt`;\r\n  let src = \"\";\r\n  for (const entry of dsf) {\r\n    if (!skipThisShader(entry, usedFlag, typeFlag, langFlag))\r\n      src = `${src + entry.filename}  isUsed: ${entry.isUsed}\\n`;\r\n  }\r\n  await DtaRpcInterface.getClient().writeExternalFile(fname, src);\r\n\r\n  // output shader files\r\n  for (const entry of dsf) {\r\n    if (skipThisShader(entry, usedFlag, typeFlag, langFlag))\r\n      continue;\r\n\r\n    fname = dir + entry.filename;\r\n    src = (entry.isGL ? \"\" : `// ${entry.filename}  isUsed: ${entry.isUsed}\\n`) + entry.src;\r\n    await DtaRpcInterface.getClient().writeExternalFile(fname, src);\r\n  }\r\n\r\n  IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, `Shaders output to directory ${dir}`));\r\n}\r\n\r\nexport class OutputShadersTool extends Tool {\r\n  public static override toolId = \"OutputShaders\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 2; }\r\n\r\n  public override async run(compile: boolean, usedFlag: string, typeFlag: string, langFlag: string, outputDir: string): Promise<boolean> {\r\n    if (compile) {\r\n      const compiled = IModelApp.renderSystem.debugControl?.compileAllShaders();\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(compiled ? OutputMessagePriority.Info : OutputMessagePriority.Error, `${compiled ? \"No\" : \"Some\"} compilation errors occurred.`));\r\n    }\r\n    const dsf = IModelApp.renderSystem.debugControl?.debugShaderFiles;\r\n    if (undefined !== dsf && dsf.length > 0)\r\n      await outputShaders(dsf, usedFlag, typeFlag, langFlag, outputDir);\r\n    else\r\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Info, \"No shaders (did you define IMJS_DEBUG_SHADERS?)\"));\r\n\r\n    return true;\r\n  }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    let compile = false;\r\n    let usedFlag;\r\n    let typeFlag;\r\n    let langFlag;\r\n    let outputDir;\r\n\r\n    for (const arg of args) {\r\n      const parts = arg.split(\"=\");\r\n      if (1 === parts.length) {\r\n        const lowerArgs = parts[0].toLowerCase();\r\n        compile = lowerArgs.includes(\"c\");\r\n        usedFlag = lowerArgs.includes(\"u\") ? \"u\" : (lowerArgs.includes(\"n\") ? \"n\" : \"\");\r\n        typeFlag = lowerArgs.includes(\"v\") ? \"v\" : (lowerArgs.includes(\"f\") ? \"f\" : \"\");\r\n        langFlag = lowerArgs.includes(\"g\") ? \"g\" : (lowerArgs.includes(\"h\") ? \"h\" : \"\");\r\n      } else if (2 === parts.length && \"d\" === parts[0].toLowerCase()) {\r\n        outputDir = parts[1];\r\n        if (-1 !== outputDir.indexOf(\"\\\\\") && !outputDir.endsWith(\"\\\\\"))\r\n          outputDir += \"\\\\\";\r\n        else if (-1 !== outputDir.indexOf(\"/\") && !outputDir.endsWith(\"/\"))\r\n          outputDir += \"/\";\r\n      }\r\n    }\r\n\r\n    return this.run(compile, usedFlag ?? \"\", typeFlag ?? \"\", langFlag ?? \"\", outputDir ?? \"d:\\\\temp\\\\shaders\\\\\");\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
