{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/RealityTile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { dispose } from \"@itwin/core-bentley\";\nimport { ClipMaskXYZRangePlanes, ClipShape, ClipVector, Point3d } from \"@itwin/core-geometry\";\nimport { Frustum } from \"@itwin/core-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicBranch } from \"../render/GraphicBranch\";\nimport { RealityTileRegion, Tile, TileLoadStatus, TileTreeLoadStatus, } from \"./internal\";\nconst scratchLoadedChildren = new Array();\nconst scratchCorners = [Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero()];\nconst additiveRefinementThreshold = 10000; // Additive tiles (Cesium OSM tileset) are subdivided until their range diagonal falls below this threshold to ensure accurate reprojection.\nconst additiveRefinementDepthLimit = 20;\nconst scratchFrustum = new Frustum();\n/** A [[Tile]] within a [[RealityTileTree]], representing part of a reality model (e.g., a point cloud or photogrammetry mesh) or 3d terrain with map imagery.\n * @public\n */\nexport class RealityTile extends Tile {\n    /** @internal */\n    constructor(props, tree) {\n        super(props, tree);\n        this._everDisplayed = false;\n        this.transformToRoot = props.transformToRoot;\n        this.additiveRefinement = props.additiveRefinement ?? this.realityParent?.additiveRefinement;\n        this.noContentButTerminateOnSelection = props.noContentButTerminateOnSelection;\n        this.rangeCorners = props.rangeCorners;\n        this.region = props.region;\n        this._geometricError = props.geometricError;\n        if (undefined === this.transformToRoot)\n            return;\n        // Can transform be non-rigid?? -- if so would have to handle (readonly) radius.\n        this.boundingSphere.transformBy(this.transformToRoot, this.boundingSphere);\n        this.transformToRoot.multiplyRange(this.range, this.range);\n        if (this.rangeCorners)\n            this.transformToRoot.multiplyPoint3dArrayInPlace(this.rangeCorners);\n        if (undefined !== this._contentRange)\n            this.transformToRoot.multiplyRange(this._contentRange, this._contentRange);\n    }\n    /** @internal */\n    setContent(content) {\n        super.setContent(content);\n        this._geometry = content.geometry;\n    }\n    /** @internal */\n    get realityChildren() { return this.children; }\n    /** @internal */\n    get realityParent() { return this.parent; }\n    /** @internal */\n    get realityRoot() { return this.tree; }\n    /** @internal */\n    get graphicType() { return undefined; } // If undefined, use tree type.\n    /** @internal */\n    get maxDepth() { return this.realityRoot.loader.maxDepth; }\n    /** @internal */\n    get isPointCloud() { return this.realityRoot.loader.containsPointClouds; }\n    /** @internal */\n    get isLoaded() { return this.loadStatus === TileLoadStatus.Ready; } // Reality tiles may depend on secondary tiles (maps) so can ge loaded but not ready.\n    /** A representation of the tile's geometry.\n     * This property is only available when using [[TileGeometryCollector]].\n     * @beta\n     */\n    get geometry() { return this._geometry; }\n    /** @internal */\n    get isDisplayable() {\n        if (this.noContentButTerminateOnSelection)\n            return false;\n        else\n            return super.isDisplayable;\n    }\n    /** @internal */\n    markUsed(args) {\n        args.markUsed(this);\n    }\n    /** @internal */\n    markDisplayed() {\n        this._everDisplayed = true;\n    }\n    /** @internal */\n    isOccluded(_viewingSpace) {\n        return false;\n    }\n    /** @internal */\n    get channel() {\n        return this.realityRoot.loader.getRequestChannel(this);\n    }\n    /** @internal */\n    async requestContent(isCanceled) {\n        return this.realityRoot.loader.requestTileContent(this, isCanceled);\n    }\n    /** @internal */\n    useAdditiveRefinementStepchildren() {\n        // Create additive stepchildren only if we are this tile is additive and we are re-projecting and the radius exceeds the additiveRefinementThreshold.\n        // This criteria is currently only met by the Cesium OSM tileset.\n        const rangeDiagonal = this.rangeCorners ? this.rangeCorners[0].distance(this.rangeCorners[3]) : 0;\n        return this.additiveRefinement && this.isDisplayable && rangeDiagonal > additiveRefinementThreshold && this.depth < additiveRefinementDepthLimit && this.realityRoot.doReprojectChildren(this);\n    }\n    /** @internal */\n    _loadChildren(resolve, reject) {\n        this.realityRoot.loader.loadChildren(this).then((children) => {\n            /* If this is a large tile is to be included additively, but we are re-projecting (Cesium OSM) then we must add step-children to display the geometry as an overly large\n               tile cannot be reprojected accurately.  */\n            if (this.useAdditiveRefinementStepchildren())\n                this.loadAdditiveRefinementChildren((stepChildren) => { children = children ? children?.concat(stepChildren) : stepChildren; });\n            if (children)\n                this.realityRoot.reprojectAndResolveChildren(this, children, resolve); /* Potentially reproject and resolve these children */\n        }).catch((err) => {\n            reject(err);\n        });\n    }\n    /** @internal */\n    async readContent(data, system, isCanceled) {\n        return this.realityRoot.loader.loadTileContent(this, data, system, isCanceled);\n    }\n    /** @internal */\n    computeLoadPriority(viewports, users) {\n        return this.realityRoot.loader.computeTilePriority(this, viewports, users);\n    }\n    /** @internal */\n    getContentClip() {\n        return ClipVector.createCapture([ClipShape.createBlock(this.contentRange, ClipMaskXYZRangePlanes.All)]);\n    }\n    /** Allow tile to select additional tiles (Terrain Imagery...)\n     * @internal\n     */\n    selectSecondaryTiles(_args, _context) { }\n    /** An upsampled tile is not loadable - will override to return loadable parent.\n     * @internal\n     */\n    get loadableTile() { return this; }\n    /** @internal */\n    preloadRealityTilesAtDepth(depth, context, args) {\n        if (this.depth === depth) {\n            context.preload(this, args);\n            return;\n        }\n        this.loadChildren();\n        if (undefined !== this.realityChildren) {\n            for (const child of this.realityChildren)\n                child.preloadRealityTilesAtDepth(depth, context, args);\n        }\n    }\n    // Preload tiles that are protected:\n    // * used tiles (where \"used\" may mean: selected/preloaded for display or content requested);\n    // * parents and siblings of other protected tiles.\n    /** @internal */\n    preloadProtectedTiles(args, context) {\n        const children = this.realityChildren;\n        let hasProtectedChildren = false;\n        if (children && !this.additiveRefinement) {\n            for (const child of children) {\n                hasProtectedChildren = child.preloadProtectedTiles(args, context) || hasProtectedChildren;\n            }\n        }\n        if (children && hasProtectedChildren) {\n            for (const child of children) {\n                if (child.isDisplayable && !child.isLoaded)\n                    context.preload(child, args);\n            }\n            return true; // Parents of protected tiles are protected\n        }\n        // Special case of the root tile\n        if (this === this.realityRoot.rootTile) {\n            context.preload(this, args);\n            return true;\n        }\n        return context.selected.find((tile) => tile === this) !== undefined;\n    }\n    /** @internal */\n    addBoundingGraphic(builder, color) {\n        builder.setSymbology(color, color, 3);\n        let corners = this.rangeCorners ? this.rangeCorners : this.range.corners();\n        if (this._reprojectionTransform)\n            corners = this._reprojectionTransform.multiplyPoint3dArray(corners);\n        builder.addRangeBoxFromCorners(corners);\n    }\n    /** @internal */\n    reproject(rootReprojection) {\n        this._reprojectionTransform = rootReprojection;\n        rootReprojection.multiplyRange(this.range, this.range);\n        this.boundingSphere.transformBy(rootReprojection, this.boundingSphere);\n        if (this.contentRange)\n            rootReprojection.multiplyRange(this.contentRange, this.contentRange);\n        if (this.rangeCorners)\n            rootReprojection.multiplyPoint3dArrayInPlace(this.rangeCorners);\n    }\n    /** @internal */\n    allChildrenIncluded(tiles) {\n        if (this.children === undefined || tiles.length !== this.children.length)\n            return false;\n        for (const tile of tiles)\n            if (tile.parent !== this)\n                return false;\n        return true;\n    }\n    /** @internal */\n    getLoadedRealityChildren(args) {\n        if (this._childrenLoadStatus !== TileTreeLoadStatus.Loaded || this.realityChildren === undefined)\n            return false;\n        for (const child of this.realityChildren) {\n            if (child.isReady && child.computeVisibilityFactor(args) > 0) {\n                scratchLoadedChildren.push(child);\n            }\n            else if (!child.getLoadedRealityChildren(args)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    forceSelectRealityTile() { return false; }\n    /** @internal */\n    minimumVisibleFactor() {\n        if (this.additiveRefinement)\n            return 0.25;\n        else\n            return 0;\n    }\n    /** @internal */\n    selectRealityTiles(context, args, traversalDetails) {\n        const visibility = this.computeVisibilityFactor(args);\n        const isNotVisible = visibility < 0;\n        if (isNotVisible)\n            return;\n        // Force loading if loader requires this tile. (cesium terrain visibility).\n        if (this.realityRoot.loader.forceTileLoad(this) && !this.isReady) {\n            context.selectOrQueue(this, args, traversalDetails);\n            return;\n        }\n        // Force to return early without selecting\n        if (visibility >= 1 && this.noContentButTerminateOnSelection)\n            return;\n        const shouldSelectThisTile = visibility >= 1 || this._anyChildNotFound || this.forceSelectRealityTile() || context.selectionCountExceeded;\n        if (shouldSelectThisTile && this.isDisplayable) { // Select this tile\n            // Return early if tile is totally occluded\n            if (this.isOccluded(args.viewingSpace))\n                return;\n            // Attempt to select this tile. If not ready, queue it\n            context.selectOrQueue(this, args, traversalDetails);\n            // This tile is visible but not loaded - Use higher resolution children if present\n            if (!this.isReady)\n                this.selectRealityChildrenAsFallback(context, args, traversalDetails);\n        }\n        else { // Select children instead of this tile\n            // With additive refinement it is necessary to display this tile along with any displayed children\n            if (this.additiveRefinement && this.isDisplayable && !this.useAdditiveRefinementStepchildren())\n                context.selectOrQueue(this, args, traversalDetails);\n            this.selectRealityChildren(context, args, traversalDetails);\n            // Children are not ready: use this tile to avoid leaving a hole\n            traversalDetails.shouldSelectParent = traversalDetails.shouldSelectParent || traversalDetails.queuedChildren.length !== 0;\n            if (traversalDetails.shouldSelectParent) {\n                // If the tile has not yet been displayed in this viewport -- display only if it is visible enough. Avoid overly tiles popping into view unexpectedly (terrain)\n                if (visibility > this.minimumVisibleFactor() || this._everDisplayed) {\n                    context.selectOrQueue(this, args, traversalDetails);\n                }\n            }\n        }\n    }\n    // Attempt to select the children of a tile in case they could be displayed while this tile is loading. This does not take into account visibility.\n    /** @internal */\n    selectRealityChildrenAsFallback(context, args, traversalDetails) {\n        const childrenReady = this.getLoadedRealityChildren(args);\n        if (childrenReady) {\n            context.select(scratchLoadedChildren, args);\n            traversalDetails.shouldSelectParent = false;\n        }\n        scratchLoadedChildren.length = 0;\n    }\n    // Recurse through children to select them normally\n    /** @internal */\n    selectRealityChildren(context, args, traversalDetails) {\n        // Load children if not yet requested\n        const childrenLoadStatus = this.loadChildren(); // NB: asynchronous\n        // Children are not ready yet\n        if (childrenLoadStatus === TileTreeLoadStatus.Loading) {\n            args.markChildrenLoading();\n            traversalDetails.shouldSelectParent = true;\n            return;\n        }\n        if (this.realityChildren !== undefined) {\n            // Attempt to select the children\n            const traversalChildren = this.realityRoot.getTraversalChildren(this.depth);\n            traversalChildren.initialize();\n            for (let i = 0; i < this.children.length; i++)\n                this.realityChildren[i].selectRealityTiles(context, args, traversalChildren.getChildDetail(i));\n            traversalChildren.combine(traversalDetails);\n        }\n    }\n    /** @internal */\n    purgeContents(olderThan, useProtectedTiles) {\n        const tilesToPurge = new Set();\n        // Get the list of tiles to purge\n        if (useProtectedTiles && !this.additiveRefinement)\n            this.getTilesToPurge(olderThan, tilesToPurge);\n        else\n            this.getTilesToPurgeWithoutProtection(olderThan, tilesToPurge);\n        // Discard contents of tiles that have been marked.\n        // Note we do not discard the child Tile objects themselves.\n        for (const tile of tilesToPurge)\n            tile.disposeContents();\n    }\n    // Populate a set with tiles that should be disposed. Prevent some tiles to be disposed to avoid holes when moving.\n    // Return true if the current tile is \"protected\".\n    getTilesToPurge(olderThan, tilesToPurge) {\n        const children = this.realityChildren;\n        // Protected tiles cannot be purged. They are:\n        // * used tiles (where \"used\" may mean: selected/preloaded for display or content requested);\n        // * parents and siblings of other protected tiles.\n        let hasProtectedChildren = false;\n        if (children) {\n            for (const child of children) {\n                hasProtectedChildren = child.getTilesToPurge(olderThan, tilesToPurge) || hasProtectedChildren;\n            }\n            if (hasProtectedChildren) {\n                // Siblings of protected tiles are protected too. We need to remove them from it\n                for (const child of children) {\n                    // Because the current tile can be invisible, relying on its children to display geometry,\n                    // we have to recurse in order to remove the first children that has geometry, otherwise,\n                    // some holes might appear\n                    child.removeFirstDisplayableChildrenFromSet(tilesToPurge);\n                }\n                return true; // Parents of protected tiles are protected\n            }\n        }\n        const isInUse = this.usageMarker.getIsTileInUse();\n        if (!isInUse && this.usageMarker.isTimestampExpired(olderThan)) {\n            tilesToPurge.add(this);\n        }\n        return isInUse;\n    }\n    // Populate a set with tiles that should be disposed. Does not prevent some tiles to be disposed to avoid holes when moving.\n    // This method is simpler and more fitting for devices that has a bigger memory constraint, such as mobiles.\n    // However, it causes the apparition of holes by letting important tiles to be purged.\n    getTilesToPurgeWithoutProtection(olderThan, tilesToPurge) {\n        const children = this.realityChildren;\n        if (children) {\n            for (const child of children) {\n                child.getTilesToPurgeWithoutProtection(olderThan, tilesToPurge);\n            }\n        }\n        if (this.usageMarker.isExpired(olderThan))\n            tilesToPurge.add(this);\n    }\n    removeFirstDisplayableChildrenFromSet(set) {\n        if (set.size === 0)\n            return;\n        if (this.isDisplayable) {\n            set.delete(this);\n            return;\n        }\n        if (this.realityChildren !== undefined) {\n            for (const child of this.realityChildren)\n                child.removeFirstDisplayableChildrenFromSet(set);\n        }\n    }\n    /** @internal */\n    computeVisibilityFactor(args) {\n        if (this.isEmpty)\n            return -1;\n        if (this.rangeCorners)\n            scratchFrustum.setFromCorners(this.rangeCorners);\n        else\n            Frustum.fromRange(this.range, scratchFrustum);\n        if (this.isFrustumCulled(scratchFrustum, args, true, this.boundingSphere))\n            return -1;\n        // some nodes are merely for structure and don't have any geometry\n        if (0 === this.maximumSize)\n            return 0;\n        if (this.isLeaf)\n            return this.hasContentRange && this.isContentCulled(args) ? -1 : 1;\n        if (undefined !== this._geometricError) {\n            const radius = args.getTileRadius(this);\n            const center = args.getTileCenter(this);\n            const pixelSize = args.computePixelSizeInMetersAtClosestPoint(center, radius);\n            const sse = this._geometricError / pixelSize;\n            return args.maximumScreenSpaceError / sse;\n        }\n        return this.maximumSize / args.getPixelSize(this);\n    }\n    /** @internal */\n    get _anyChildNotFound() {\n        if (undefined !== this.children)\n            for (const child of this.children)\n                if (child.isNotFound)\n                    return true;\n        return this._childrenLoadStatus === TileTreeLoadStatus.NotFound;\n    }\n    /** @internal */\n    getSizeProjectionCorners() {\n        if (!this.tree.isContentUnbounded)\n            return undefined; // For a non-global tree use the standard size algorithm.\n        // For global tiles (as in OSM buildings) return the range corners or X-Y corners only if bounded by region- this allows an algorithm that uses the area of the projected corners to attenuate horizon tiles.\n        if (!this.rangeCorners)\n            return this.range.corners(scratchCorners);\n        return this.region ? this.rangeCorners.slice(4) : this.rangeCorners;\n    }\n    /** @internal */\n    get isStepChild() { return false; }\n    /** @internal */\n    loadAdditiveRefinementChildren(resolve) {\n        const region = this.region;\n        const corners = this.rangeCorners;\n        if (!region || !corners)\n            return;\n        const maximumSize = this.maximumSize;\n        const rangeDiagonal = corners[0].distance(corners[3]);\n        const isLeaf = rangeDiagonal < additiveRefinementThreshold || this.depth > additiveRefinementDepthLimit;\n        const stepChildren = new Array();\n        const latitudeDelta = (region.maxLatitude - region.minLatitude) / 2;\n        const longitudeDelta = (region.maxLongitude - region.minLongitude) / 2;\n        const minHeight = region.minHeight;\n        const maxHeight = region.maxHeight;\n        for (let i = 0, minLongitude = region.minLongitude, step = 0; i < 2; i++, minLongitude += longitudeDelta, step++) {\n            for (let j = 0, minLatitude = region.minLatitude; j < 2; j++, minLatitude += latitudeDelta) {\n                const childRegion = new RealityTileRegion({ minLatitude, maxLatitude: minLatitude + latitudeDelta, minLongitude, maxLongitude: minLongitude + longitudeDelta, minHeight, maxHeight });\n                const childRange = childRegion.getRange();\n                const contentId = `${this.contentId}_S${step++}`;\n                const childParams = { rangeCorners: childRange.corners, contentId, range: childRange.range, maximumSize, parent: this, additiveRefinement: false, isLeaf, region: childRegion };\n                stepChildren.push(new AdditiveRefinementStepChild(childParams, this.realityRoot));\n            }\n        }\n        resolve(stepChildren);\n    }\n    /** @internal */\n    produceGraphics() {\n        if (undefined === this._reprojectionTransform)\n            return super.produceGraphics();\n        if (undefined === this._reprojectedGraphic && undefined !== this._graphic) {\n            const branch = new GraphicBranch(false);\n            branch.add(this._graphic);\n            this._reprojectedGraphic = IModelApp.renderSystem.createGraphicBranch(branch, this._reprojectionTransform);\n        }\n        return this._reprojectedGraphic;\n    }\n    /** @internal */\n    get unprojectedGraphic() {\n        return this._graphic;\n    }\n    /** @internal */\n    disposeContents() {\n        super.disposeContents();\n        this._reprojectedGraphic = dispose(this._reprojectedGraphic);\n    }\n    /** @internal */\n    collectTileGeometry(collector) {\n        const status = collector.collectTile(this);\n        switch (status) {\n            case \"reject\":\n                return;\n            case \"continue\":\n                if (!this.isLeaf && !this._anyChildNotFound) {\n                    const childrenLoadStatus = this.loadChildren();\n                    if (TileTreeLoadStatus.Loading === childrenLoadStatus) {\n                        collector.markLoading();\n                    }\n                    else if (undefined !== this.realityChildren && !this._anyChildNotFound) {\n                        for (const child of this.realityChildren)\n                            child.collectTileGeometry(collector);\n                    }\n                    break;\n                } // else fall through to \"accept\"\n            // eslint-disable-next-line no-fallthrough\n            case \"accept\":\n                if (!this.isReady)\n                    collector.addMissingTile(this.loadableTile);\n                else if (this.geometry?.polyfaces)\n                    collector.polyfaces.push(...this.geometry.polyfaces);\n                break;\n        }\n    }\n}\n/** When additive refinement is used (as in the Cesium OSM tileset) it is not possible to accurately reproject very large, low level tiles\n * In this case we create additional \"step\" children (grandchildren etc. ) that will clipped portions display the their ancestor's additive geometry.\n * These step children are subdivided until they are small enough to be accurately reprojected - this is controlled by the additiveRefinementThreshold (currently 2KM).\n * The stepchildren do not contain any tile graphics - they just create a branch with clipping and reprojection to display their additive refinement ancestor graphics.\n */\nclass AdditiveRefinementStepChild extends RealityTile {\n    get isStepChild() { return true; }\n    constructor(props, tree) {\n        super(props, tree);\n        this._loadableTile = this.realityParent;\n        for (; this._loadableTile && this._loadableTile.isStepChild; this._loadableTile = this._loadableTile.realityParent)\n            ;\n    }\n    get loadableTile() {\n        return this._loadableTile;\n    }\n    get isLoading() { return this._loadableTile.isLoading; }\n    get isQueued() { return this._loadableTile.isQueued; }\n    get isNotFound() { return this._loadableTile.isNotFound; }\n    get isReady() { return this._loadableTile.isReady; }\n    get isLoaded() { return this._loadableTile.isLoaded; }\n    get isEmpty() { return false; }\n    produceGraphics() {\n        if (undefined === this._graphic) {\n            const parentGraphics = this._loadableTile.unprojectedGraphic;\n            if (!parentGraphics || !this._reprojectionTransform)\n                return undefined;\n            const branch = new GraphicBranch(false);\n            branch.add(parentGraphics);\n            const renderSystem = IModelApp.renderSystem;\n            const branchOptions = {};\n            if (this.rangeCorners) {\n                const clipPolygon = [this.rangeCorners[0], this.rangeCorners[1], this.rangeCorners[3], this.rangeCorners[2]];\n                branchOptions.clipVolume = renderSystem.createClipVolume(ClipVector.create([ClipShape.createShape(clipPolygon, undefined, undefined, this.tree.iModelTransform)]));\n            }\n            this._graphic = renderSystem.createGraphicBranch(branch, this._reprojectionTransform, branchOptions);\n        }\n        return this._graphic;\n    }\n    markUsed(args) {\n        args.markUsed(this);\n        args.markUsed(this._loadableTile);\n    }\n    _loadChildren(resolve, _reject) {\n        this.loadAdditiveRefinementChildren((stepChildren) => {\n            if (stepChildren)\n                this.realityRoot.reprojectAndResolveChildren(this, stepChildren, resolve);\n        });\n    }\n}\n//# sourceMappingURL=RealityTile.js.map",
      "start": 1693508121434,
      "end": 1693508121701,
      "sourcemaps": null
    }
  ]
}
