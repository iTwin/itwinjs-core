{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/Frustum.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { AxisOrder, ClipPlane, ConvexClipPlaneSet, Geometry, GrowableXYZArray, Map4d, Matrix3d, Point3d, Range3d, Vector3d, } from \"@itwin/core-geometry\";\n/** The 8 corners of the [Normalized Plane Coordinate]($docs/learning/glossary.md#npc) cube.\n * @public\n * @extensions\n */\nexport var Npc;\n(function (Npc) {\n    /** Left bottom rear */\n    Npc[Npc[\"_000\"] = 0] = \"_000\";\n    /** Right bottom rear */\n    Npc[Npc[\"_100\"] = 1] = \"_100\";\n    /** Left top rear */\n    Npc[Npc[\"_010\"] = 2] = \"_010\";\n    /** Right top rear */\n    Npc[Npc[\"_110\"] = 3] = \"_110\";\n    /** Left bottom front */\n    Npc[Npc[\"_001\"] = 4] = \"_001\";\n    /** Right bottom front */\n    Npc[Npc[\"_101\"] = 5] = \"_101\";\n    /** Left top front */\n    Npc[Npc[\"_011\"] = 6] = \"_011\";\n    /** Right top front */\n    Npc[Npc[\"_111\"] = 7] = \"_111\";\n    Npc[Npc[\"LeftBottomRear\"] = 0] = \"LeftBottomRear\";\n    Npc[Npc[\"RightBottomRear\"] = 1] = \"RightBottomRear\";\n    Npc[Npc[\"LeftTopRear\"] = 2] = \"LeftTopRear\";\n    Npc[Npc[\"RightTopRear\"] = 3] = \"RightTopRear\";\n    Npc[Npc[\"LeftBottomFront\"] = 4] = \"LeftBottomFront\";\n    Npc[Npc[\"RightBottomFront\"] = 5] = \"RightBottomFront\";\n    Npc[Npc[\"LeftTopFront\"] = 6] = \"LeftTopFront\";\n    Npc[Npc[\"RightTopFront\"] = 7] = \"RightTopFront\";\n    /** useful for sizing arrays */\n    Npc[Npc[\"CORNER_COUNT\"] = 8] = \"CORNER_COUNT\";\n})(Npc || (Npc = {}));\n/** The 8 corners of an [[Npc]] Frustum.\n * @public\n */\nexport const NpcCorners = [\n    new Point3d(0.0, 0.0, 0.0),\n    new Point3d(1.0, 0.0, 0.0),\n    new Point3d(0.0, 1.0, 0.0),\n    new Point3d(1.0, 1.0, 0.0),\n    new Point3d(0.0, 0.0, 1.0),\n    new Point3d(1.0, 0.0, 1.0),\n    new Point3d(0.0, 1.0, 1.0),\n    new Point3d(1.0, 1.0, 1.0),\n];\nNpcCorners.forEach((corner) => Object.freeze(corner));\nObject.freeze(NpcCorners);\n/** The center point of the [Normalized Plane Coordinate]($docs/learning/glossary.md#npc) cube.\n * @public\n */\nexport const NpcCenter = new Point3d(.5, .5, .5); // eslint-disable-line @typescript-eslint/naming-convention\nObject.freeze(NpcCenter);\n/** The region of physical (3d) space that appears in a view. It forms the field-of-view of a camera.\n * It is stored as 8 points, in [[Npc]] order, that must define a truncated pyramid.\n * @public\n */\nexport class Frustum {\n    /** Constructor for Frustum. Members are initialized to the Npc cube. */\n    constructor() {\n        /** Array of the 8 points of this Frustum. */\n        this.points = [];\n        for (let i = 0; i < 8; ++i)\n            this.points[i] = NpcCorners[i].clone();\n    }\n    /** Initialize this Frustum to the 8 corners of the NPC cube. */\n    initNpc() {\n        for (let i = 0; i < 8; ++i)\n            Point3d.createFrom(NpcCorners[i], this.points[i]);\n        return this;\n    }\n    /** Get a corner Point from this Frustum. */\n    getCorner(i) { return this.points[i]; }\n    /** Get the point at the center of this Frustum (halfway between RightTopFront and LeftBottomRear. */\n    getCenter() {\n        return this.getCorner(Npc.RightTopFront).interpolate(0.5, this.getCorner(Npc.LeftBottomRear));\n    }\n    /** Get the distance between two corners of this Frustum. */\n    distance(corner1, corner2) {\n        return this.getCorner(corner1).distance(this.getCorner(corner2));\n    }\n    /** Get the ratio of the length of the diagonal of the front plane to the diagonal of the back plane. */\n    getFraction() {\n        return Geometry.safeDivideFraction(this.distance(Npc.LeftTopFront, Npc.RightBottomFront), this.distance(Npc.LeftTopRear, Npc.RightBottomRear), 0);\n    }\n    /** Multiply all the points of this Frustum by a Transform, in place. */\n    multiply(trans) {\n        trans.multiplyPoint3dArrayInPlace(this.points);\n    }\n    /** Offset all of the points of this Frustum by a vector. */\n    translate(offset) {\n        for (const pt of this.points)\n            pt.plus(offset, pt);\n    }\n    /** Transform all the points of this Frustum and return the result in another Frustum. */\n    transformBy(trans, result) {\n        result = result ? result : new Frustum();\n        trans.multiplyPoint3dArray(this.points, result.points);\n        return result;\n    }\n    /** Calculate a bounding range from the 8 points in this Frustum. */\n    toRange(range) {\n        return Range3d.createArray(this.points, range);\n    }\n    /** Make a copy of this Frustum.\n     * @param result Optional Frustum for copy. If undefined allocate a new Frustum.\n     */\n    clone(result) {\n        result = result ? result : new Frustum();\n        result.setFrom(this);\n        return result;\n    }\n    /** Set the points of this Frustum to be copies of the points in another Frustum. */\n    setFrom(other) { this.setFromCorners(other.points); }\n    /** Set the points of this frustum from array of corner points in NPC order. */\n    setFromCorners(corners) {\n        for (let i = 0; i < 8; ++i)\n            this.points[i].setFrom(corners[i]);\n    }\n    /** Scale this Frustum, in place, about its center by a scale factor. */\n    scaleAboutCenter(scale) {\n        const orig = this.clone();\n        const f = 0.5 * (1.0 + scale);\n        orig.points[Npc._111].interpolate(f, orig.points[Npc._000], this.points[Npc._000]);\n        orig.points[Npc._011].interpolate(f, orig.points[Npc._100], this.points[Npc._100]);\n        orig.points[Npc._101].interpolate(f, orig.points[Npc._010], this.points[Npc._010]);\n        orig.points[Npc._001].interpolate(f, orig.points[Npc._110], this.points[Npc._110]);\n        orig.points[Npc._110].interpolate(f, orig.points[Npc._001], this.points[Npc._001]);\n        orig.points[Npc._010].interpolate(f, orig.points[Npc._101], this.points[Npc._101]);\n        orig.points[Npc._100].interpolate(f, orig.points[Npc._011], this.points[Npc._011]);\n        orig.points[Npc._000].interpolate(f, orig.points[Npc._111], this.points[Npc._111]);\n    }\n    /** The point at the center of the front face of this frustum */\n    get frontCenter() {\n        return this.getCorner(Npc.LeftBottomFront).interpolate(.5, this.getCorner(Npc.RightTopFront));\n    }\n    /** The point at the center of the rear face of this frustum */\n    get rearCenter() {\n        return this.getCorner(Npc.LeftBottomRear).interpolate(.5, this.getCorner(Npc.RightTopRear));\n    }\n    /** Scale this frustum's XY (viewing) plane about its center */\n    scaleXYAboutCenter(scale) {\n        const frontCenter = this.frontCenter, rearCenter = this.rearCenter;\n        frontCenter.interpolate(scale, this.points[Npc.LeftTopFront], this.points[Npc.LeftTopFront]);\n        frontCenter.interpolate(scale, this.points[Npc.RightTopFront], this.points[Npc.RightTopFront]);\n        frontCenter.interpolate(scale, this.points[Npc.LeftBottomFront], this.points[Npc.LeftBottomFront]);\n        frontCenter.interpolate(scale, this.points[Npc.RightBottomFront], this.points[Npc.RightBottomFront]);\n        rearCenter.interpolate(scale, this.points[Npc.LeftTopRear], this.points[Npc.LeftTopRear]);\n        rearCenter.interpolate(scale, this.points[Npc.RightTopRear], this.points[Npc.RightTopRear]);\n        rearCenter.interpolate(scale, this.points[Npc.LeftBottomRear], this.points[Npc.LeftBottomRear]);\n        rearCenter.interpolate(scale, this.points[Npc.RightBottomRear], this.points[Npc.RightBottomRear]);\n    }\n    /** Create a Map4d that converts world coordinates to/from [[Npc]] coordinates of this Frustum. */\n    toMap4d() {\n        const org = this.getCorner(Npc.LeftBottomRear);\n        const xVec = org.vectorTo(this.getCorner(Npc.RightBottomRear));\n        const yVec = org.vectorTo(this.getCorner(Npc.LeftTopRear));\n        const zVec = org.vectorTo(this.getCorner(Npc.LeftBottomFront));\n        return Map4d.createVectorFrustum(org, xVec, yVec, zVec, this.getFraction());\n    }\n    /** Get the rotation matrix to the frame of this frustum.  This is equivalent to the view rotation matrix. */\n    getRotation(result) {\n        const org = this.getCorner(Npc.LeftBottomRear);\n        const xVec = org.vectorTo(this.getCorner(Npc.RightBottomRear));\n        const yVec = org.vectorTo(this.getCorner(Npc.LeftTopRear));\n        const matrix = Matrix3d.createRigidFromColumns(xVec, yVec, AxisOrder.XYZ, result);\n        if (matrix)\n            matrix.transposeInPlace();\n        return matrix;\n    }\n    /** Get the eye point  - undefined if parallel projection */\n    getEyePoint(result) {\n        const fraction = this.getFraction();\n        if (Math.abs(fraction - 1) < 1E-8)\n            return undefined; // Parallel.\n        const org = this.getCorner(Npc.LeftBottomRear);\n        const zVec = org.vectorTo(this.getCorner(Npc.LeftBottomFront));\n        return org.plusScaled(zVec, 1 / (1 - fraction), result);\n    }\n    /** Invalidate this Frustum by setting all 8 points to zero. */\n    invalidate() {\n        for (let i = 0; i < 8; ++i)\n            this.points[i].set(0, 0, 0);\n    }\n    /** Return true if this Frustum is equal to another Frustum */\n    equals(rhs) {\n        for (let i = 0; i < 8; ++i) {\n            if (!this.points[i].isExactEqual(rhs.points[i]))\n                return false;\n        }\n        return true;\n    }\n    /** Return true if all of the points in this Frustum are *almost* the same as the points in another Frustum.\n     * @see [[equals]], [XYZ.isAlmostEqual]($geometry)\n     */\n    isSame(other) {\n        for (let i = 0; i < 8; ++i) {\n            if (!this.points[i].isAlmostEqual(other.points[i]))\n                return false;\n        }\n        return true;\n    }\n    /** Initialize this Frustum from a Range */\n    initFromRange(range) {\n        const getZ = (arg) => arg.z !== undefined ? arg.z : 0;\n        const pts = this.points;\n        pts[0].x = pts[2].x = pts[4].x = pts[6].x = range.low.x;\n        pts[1].x = pts[3].x = pts[5].x = pts[7].x = range.high.x;\n        pts[0].y = pts[1].y = pts[4].y = pts[5].y = range.low.y;\n        pts[2].y = pts[3].y = pts[6].y = pts[7].y = range.high.y;\n        pts[0].z = pts[1].z = pts[2].z = pts[3].z = getZ(range.low);\n        pts[4].z = pts[5].z = pts[6].z = pts[7].z = getZ(range.high);\n    }\n    /** Create a new Frustum from a Range3d */\n    static fromRange(range, out) {\n        const frustum = undefined !== out ? out : new Frustum();\n        frustum.initFromRange(range);\n        return frustum;\n    }\n    /** Return true if this Frustum has a mirror (is not in the correct order.) */\n    get hasMirror() {\n        const pts = this.points;\n        const u = pts[Npc._000].vectorTo(pts[Npc._001]);\n        const v = pts[Npc._000].vectorTo(pts[Npc._010]);\n        const w = pts[Npc._000].vectorTo(pts[Npc._100]);\n        return (u.tripleProduct(v, w) > 0);\n    }\n    /** Make sure the frustum point order does not include mirroring. If so, reverse the order. */\n    fixPointOrder() {\n        if (!this.hasMirror)\n            return;\n        // frustum has mirroring, reverse points\n        const pts = this.points;\n        for (let i = 0; i < 8; i += 2) {\n            const tmpPoint = pts[i];\n            pts[i] = pts[i + 1];\n            pts[i + 1] = tmpPoint;\n        }\n    }\n    /** Get a convex set of clipping planes bounding the region contained by this Frustum. */\n    getRangePlanes(clipFront, clipBack, expandPlaneDistance) {\n        const convexSet = ConvexClipPlaneSet.createEmpty();\n        const scratchNormal = Vector3d.create();\n        Vector3d.createCrossProductToPoints(this.points[5], this.points[3], this.points[1], scratchNormal);\n        if (scratchNormal.normalizeInPlace())\n            convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[1]) - expandPlaneDistance));\n        Vector3d.createCrossProductToPoints(this.points[2], this.points[4], this.points[0], scratchNormal);\n        if (scratchNormal.normalizeInPlace())\n            convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));\n        Vector3d.createCrossProductToPoints(this.points[3], this.points[6], this.points[2], scratchNormal);\n        if (scratchNormal.normalizeInPlace())\n            convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[2]) - expandPlaneDistance));\n        Vector3d.createCrossProductToPoints(this.points[4], this.points[1], this.points[0], scratchNormal);\n        if (scratchNormal.normalizeInPlace())\n            convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));\n        if (clipBack) {\n            Vector3d.createCrossProductToPoints(this.points[1], this.points[2], this.points[0], scratchNormal);\n            if (scratchNormal.normalizeInPlace())\n                convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[0]) - expandPlaneDistance));\n        }\n        if (clipFront) {\n            Vector3d.createCrossProductToPoints(this.points[6], this.points[5], this.points[4], scratchNormal);\n            if (scratchNormal.normalizeInPlace())\n                convexSet.addPlaneToConvexSet(ClipPlane.createNormalAndDistance(scratchNormal, scratchNormal.dotProduct(this.points[4]) - expandPlaneDistance));\n        }\n        return convexSet;\n    }\n    /** Get a (convex) polygon that represents the intersection of this frustum with a plane, or undefined if no intersection exists */\n    getIntersectionWithPlane(plane) {\n        const clipPlane = ClipPlane.createPlane(plane);\n        const loopPoints = clipPlane.intersectRange(this.toRange(), true);\n        if (undefined === loopPoints)\n            return undefined;\n        const convexSet = this.getRangePlanes(false, false, 0);\n        const workPoints = new GrowableXYZArray();\n        const outPoints = new GrowableXYZArray();\n        convexSet.polygonClip(loopPoints, outPoints, workPoints);\n        return outPoints.length < 4 ? undefined : outPoints.getPoint3dArray();\n    }\n}\n//# sourceMappingURL=Frustum.js.map",
      "start": 1693508120734,
      "end": 1693508120806,
      "sourcemaps": null
    }
  ]
}
