{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/CurveCurveIntersectXY.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../../bspline/BSplineCurve\";\nimport { Geometry } from \"../../Geometry\";\nimport { CoincidentGeometryQuery } from \"../../geometry3d/CoincidentGeometryOps\";\nimport { NullGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { GrowableFloat64Array } from \"../../geometry3d/GrowableFloat64Array\";\nimport { Matrix3d } from \"../../geometry3d/Matrix3d\";\nimport { Vector2d } from \"../../geometry3d/Point2dVector2d\";\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { Point4d } from \"../../geometry4d/Point4d\";\nimport { UnivariateBezier } from \"../../numerics/BezierPolynomials\";\nimport { Newton2dUnboundedWithDerivative, NewtonEvaluatorRRtoRRD } from \"../../numerics/Newton\";\nimport { AnalyticRoots, SmallSystem, TrigPolynomial } from \"../../numerics/Polynomials\";\nimport { Arc3d } from \"../Arc3d\";\nimport { CurveIntervalRole, CurveLocationDetail, CurveLocationDetailPair } from \"../CurveLocationDetail\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\n// cspell:word XYRR\n/**\n * Private class for refining bezier-bezier intersections.\n * * The inputs are assumed pre-transformed so that the target condition is to match x and y coordinates.\n * @internal\n */\nexport class BezierBezierIntersectionXYRRToRRD extends NewtonEvaluatorRRtoRRD {\n    constructor(curveA, curveB) {\n        super();\n        this._curveA = curveA;\n        this._curveB = curveB;\n        this._rayA = Ray3d.createZero();\n        this._rayB = Ray3d.createZero();\n    }\n    evaluate(fractionA, fractionB) {\n        this._curveA.fractionToPointAndDerivative(fractionA, this._rayA);\n        this._curveB.fractionToPointAndDerivative(fractionB, this._rayB);\n        this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x - this._rayA.origin.x, this._rayB.origin.y - this._rayA.origin.y, 0.0, -this._rayA.direction.x, -this._rayA.direction.y, 0.0, this._rayB.direction.x, this._rayB.direction.y, 0.0);\n        return true;\n    }\n}\n/**\n * Handler class for XY intersections between _geometryB and another geometry.\n * * Instances are initialized and called from CurveCurve.\n * * geometryB is saved for later reference.\n * @internal\n */\nclass CurveCurveIntersectXY extends NullGeometryHandler {\n    reinitialize() {\n        this._results = [];\n    }\n    /**\n     * @param worldToLocal optional transform (possibly perspective) to project to xy plane for intersection.\n     * @param extendA flag to enable using extension of the other geometry.\n     * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.\n     * @param extendB flag for extension of geometryB.\n     * @param tolerance optional distance tolerance for coincidence\n     */\n    constructor(worldToLocal, extendA, geometryB, extendB, tolerance = Geometry.smallMetricDistance) {\n        super();\n        this._extendA = extendA;\n        this._geometryB = geometryB;\n        this._extendB = extendB;\n        this._worldToLocalPerspective = undefined;\n        this._worldToLocalAffine = undefined;\n        if (worldToLocal !== undefined && !worldToLocal.isIdentity()) {\n            this._worldToLocalAffine = worldToLocal.asTransform;\n            if (!this._worldToLocalAffine)\n                this._worldToLocalPerspective = worldToLocal.clone();\n        }\n        this._coincidentGeometryContext = CoincidentGeometryQuery.create(tolerance);\n        this.reinitialize();\n    }\n    /** Reset the geometry and flags, leaving all other parts unchanged (and preserving accumulated intersections) */\n    resetGeometry(extendA, geometryB, extendB) {\n        this._extendA = extendA;\n        this._geometryB = geometryB;\n        this._extendB = extendB;\n    }\n    acceptFraction(extend0, fraction, extend1, fractionTol = 1.0e-12) {\n        if (!extend0 && fraction < -fractionTol)\n            return false;\n        if (!extend1 && fraction > 1.0 + fractionTol)\n            return false;\n        return true;\n    }\n    /**\n     * Test the fraction by strict parameter, but allow toleranced distance test at ends.\n     * @param tolerance optional distance tolerance to check proximity to start/end point\n     */\n    acceptFractionOnLine(extend0, fraction, extend1, pointA, pointB, tolerance = Geometry.smallMetricDistance) {\n        if (!extend0 && fraction < 0) {\n            return Geometry.isDistanceWithinTol(fraction * pointA.distanceXY(pointB), tolerance);\n        }\n        else if (!extend1 && fraction > 1.0)\n            return Geometry.isDistanceWithinTol((fraction - 1.0) * pointA.distanceXY(pointB), tolerance);\n        return true;\n    }\n    /**\n     * * Return the results structure for the intersection calculation, structured as an array of CurveLocationDetailPair\n     * @param reinitialize if true, a new results structure is created for use by later calls.\n     */\n    grabPairedResults(reinitialize = false) {\n        const result = this._results;\n        if (reinitialize)\n            this.reinitialize();\n        return result;\n    }\n    sameCurveAndFraction(cp, fraction, detail) {\n        return cp === detail.curve && Geometry.isAlmostEqualNumber(fraction, detail.fraction);\n    }\n    /**\n     * Compute intersection of two line segments.\n     * Filter by extension rules.\n     * Record with fraction mapping.\n     */\n    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, // Computed intersection fraction\n    cpB, fractionB0, fractionB1, reversed, intervalDetails) {\n        let globalFractionA, globalFractionB;\n        let globalFractionA1, globalFractionB1;\n        const isInterval = intervalDetails !== undefined &&\n            intervalDetails.detailA.hasFraction1 &&\n            intervalDetails.detailB.hasFraction1;\n        if (isInterval) {\n            globalFractionA = Geometry.interpolate(fractionA0, intervalDetails.detailA.fraction, fractionA1);\n            globalFractionB = Geometry.interpolate(fractionB0, intervalDetails.detailB.fraction, fractionB1);\n            globalFractionA1 = Geometry.interpolate(fractionA0, intervalDetails.detailA.fraction1, fractionA1);\n            globalFractionB1 = Geometry.interpolate(fractionB0, intervalDetails.detailB.fraction1, fractionB1);\n        }\n        else {\n            globalFractionA = globalFractionA1 = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\n            globalFractionB = globalFractionB1 = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\n        }\n        // ignore duplicate of most recent point .  ..\n        const numPrevious = this._results.length;\n        if (numPrevious > 0 && !isInterval) {\n            const oldDetailA = this._results[numPrevious - 1].detailA;\n            const oldDetailB = this._results[numPrevious - 1].detailB;\n            if (reversed) {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailB) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailA))\n                    return;\n            }\n            else {\n                if (this.sameCurveAndFraction(cpA, globalFractionA, oldDetailA) &&\n                    this.sameCurveAndFraction(cpB, globalFractionB, oldDetailB))\n                    return;\n            }\n        }\n        const detailA = CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, cpA.fractionToPoint(globalFractionA));\n        const detailB = CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, cpB.fractionToPoint(globalFractionB));\n        if (isInterval) {\n            detailA.captureFraction1Point1(globalFractionA1, cpA.fractionToPoint(globalFractionA1));\n            detailB.captureFraction1Point1(globalFractionB1, cpB.fractionToPoint(globalFractionB1));\n        }\n        else {\n            detailA.setIntervalRole(CurveIntervalRole.isolated);\n            detailB.setIntervalRole(CurveIntervalRole.isolated);\n        }\n        if (reversed) {\n            this._results.push(new CurveLocationDetailPair(detailB, detailA));\n        }\n        else {\n            this._results.push(new CurveLocationDetailPair(detailA, detailB));\n        }\n    }\n    /**\n     * Emit recordPoint for multiple pairs (on full curve!)\n     * @param cpA first curve primitive (possibly different from curve in detailA, but fraction compatible)\n     * @param cpB second curve primitive (possibly different from curve in detailA, but fraction compatible)\n     * @param pairs array of pairs\n     * @param reversed true to have order reversed in final structures.\n     */\n    recordPairs(cpA, cpB, pairs, reversed) {\n        if (pairs !== undefined) {\n            for (const p of pairs) {\n                this.recordPointWithLocalFractions(p.detailA.fraction, cpA, 0, 1, p.detailB.fraction, cpB, 0, 1, reversed, p);\n            }\n        }\n    }\n    /**\n     * Compute intersection of two line segments.\n     * Filter by extension rules.\n     * Record with fraction mapping.\n     */\n    computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {\n        const uv = CurveCurveIntersectXY._workVector2dA;\n        // Problem: Normal practice is to do the (quick, simple) transverse intersection first\n        // But the transverse intersector notion of coincidence is based on the determinant ratios, which are hard\n        // to relate to physical tolerance.\n        //  So do the overlap first.  This should do a quick exit in non-coincident case.\n        const overlap = this._coincidentGeometryContext.coincidentSegmentRangeXY(pointA0, pointA1, pointB0, pointB1);\n        if (overlap) {\n            this.recordPointWithLocalFractions(overlap.detailA.fraction, cpA, fractionA0, fractionA1, overlap.detailB.fraction, cpB, fractionB0, fractionB1, reversed, overlap);\n        }\n        else if (SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(pointA0, pointA1, pointB0, pointB1, uv)) {\n            if (this.acceptFractionOnLine(extendA0, uv.x, extendA1, pointA0, pointA1, this._coincidentGeometryContext.tolerance) &&\n                this.acceptFractionOnLine(extendB0, uv.y, extendB1, pointB0, pointB1, this._coincidentGeometryContext.tolerance)) {\n                this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);\n            }\n        }\n    }\n    // intersection of PROJECTED homogeneous segments ...  assumes caller knows the _worldToLocal is present\n    computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {\n        const hA0 = CurveCurveIntersectXY._workPointA0H;\n        const hA1 = CurveCurveIntersectXY._workPointA1H;\n        const hB0 = CurveCurveIntersectXY._workPointB0H;\n        const hB1 = CurveCurveIntersectXY._workPointB1H;\n        this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1, hA0);\n        this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1, hA1);\n        this._worldToLocalPerspective.multiplyPoint3d(pointB0, 1, hB0);\n        this._worldToLocalPerspective.multiplyPoint3d(pointB1, 1, hB1);\n        const fractionAB = SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1);\n        if (fractionAB !== undefined) {\n            const fractionA = fractionAB.x;\n            const fractionB = fractionAB.y;\n            if (this.acceptFraction(extendA0, fractionA, extendA1) && this.acceptFraction(extendB0, fractionB, extendB1)) {\n                // final fraction acceptance uses original world points, with perspective-aware fractions\n                this.recordPointWithLocalFractions(fractionA, cpA, fractionA0, fractionA1, fractionB, cpB, fractionB0, fractionB1, reversed);\n            }\n        }\n    }\n    // Caller accesses data from a line segment and passes to here.\n    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.\n    // The fraction and extend parameters allow all combinations to be passed in)\n    // This method applies transform.\n    dispatchSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {\n        if (this._worldToLocalAffine) {\n            // non-perspective projection\n            CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine, pointA0, pointA1, pointB0, pointB1);\n            this.computeSegmentSegment3D(cpA, extendA0, CurveCurveIntersectXY._workPointA0, fractionA0, CurveCurveIntersectXY._workPointA1, fractionA1, extendA1, cpB, extendB0, CurveCurveIntersectXY._workPointB0, fractionB0, CurveCurveIntersectXY._workPointB1, fractionB1, extendB1, reversed);\n        }\n        else if (this._worldToLocalPerspective) {\n            this.computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);\n        }\n        else {\n            this.computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);\n        }\n    }\n    // Caller accesses data from a linestring or segment and passes it here.\n    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.\n    // The fraction and extend parameters allow all combinations to be passed in)\n    dispatchSegmentArc(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, arc, extendB0, extendB1, reversed) {\n        // Arc: X = C + cU + sV\n        // Line:  contains points A0,A1\n        // Arc point colinear with line if det (A0, A1, X) = 0\n        // with homogeneous xyw points and vectors.\n        // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.\n        // solve for theta.\n        // evaluate points.\n        // project back to line.\n        if (this._worldToLocalPerspective) {\n            const data = arc.toTransformedPoint4d(this._worldToLocalPerspective);\n            const pointA0H = this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1);\n            const pointA1H = this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1);\n            const alpha = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.center);\n            const beta = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector0);\n            const gamma = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector90);\n            const cosines = new GrowableFloat64Array(2);\n            const sines = new GrowableFloat64Array(2);\n            const radians = new GrowableFloat64Array(2);\n            const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\n            for (let i = 0; i < numRoots; i++) {\n                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\n                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\n                const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, arcPoint);\n                if (lineFraction !== undefined &&\n                    this.acceptFraction(extendA0, lineFraction, extendA1) &&\n                    this.acceptFraction(extendB0, arcFraction, extendB1)) {\n                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);\n                }\n            }\n        }\n        else {\n            const data = arc.toTransformedVectors(this._worldToLocalAffine);\n            let pointA0Local = pointA0;\n            let pointA1Local = pointA1;\n            if (this._worldToLocalAffine) {\n                pointA0Local = this._worldToLocalAffine.multiplyPoint3d(pointA0);\n                pointA1Local = this._worldToLocalAffine.multiplyPoint3d(pointA1);\n            }\n            const alpha = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1);\n            const beta = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0);\n            const gamma = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0);\n            const cosines = new GrowableFloat64Array(2);\n            const sines = new GrowableFloat64Array(2);\n            const radians = new GrowableFloat64Array(2);\n            const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\n            const lineFractionTol = 1.0e-10;\n            const arcFractionTol = 1.0e-7;\n            for (let i = 0; i < numRoots; i++) {\n                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\n                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\n                const lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);\n                if (lineFraction !== undefined &&\n                    this.acceptFraction(extendA0, lineFraction, extendA1, lineFractionTol) &&\n                    this.acceptFraction(extendB0, arcFraction, extendB1, arcFractionTol)) {\n                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);\n                }\n            }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // each matrix has [U V C] in (x,y,w) form from projection.\n    // invert the projection matrix matrixA.\n    // apply the inverse to matrixB. Then arc b is an ellipse in the circular space of A\n    dispatchArcArcThisOrder(cpA, matrixA, // homogeneous xyw projection !!!\n    extendA, cpB, matrixB, // homogeneous xyw projection !!!\n    extendB, reversed) {\n        const inverseA = matrixA.inverse();\n        if (inverseA) {\n            const localB = inverseA.multiplyMatrixMatrix(matrixB); // localB->localA transform\n            const ellipseRadians = [];\n            const circleRadians = [];\n            TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(localB.coffs[2], localB.coffs[5], localB.coffs[8], // center xyw\n            localB.coffs[0], localB.coffs[3], localB.coffs[6], // vector0 xyw\n            localB.coffs[1], localB.coffs[4], localB.coffs[7], // vector90 xyw\n            ellipseRadians, circleRadians);\n            for (let i = 0; i < ellipseRadians.length; i++) {\n                const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);\n                const fractionB = cpB.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);\n                // hm .. do we really need to check the fractions?  We know they are internal to the beziers\n                if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\n                    this.recordPointWithLocalFractions(fractionA, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);\n                }\n            }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcArc(cpA, extendA, cpB, extendB, reversed) {\n        // Arc: X = C + cU + sV\n        // Line:  contains points A0,A1\n        // Arc point colinear with line if det (A0, A1, X) = 0\n        // with homogeneous xyw points and vectors.\n        // With equational X:   det (A0, A1, C) + c det (A0, A1, U) + s det (A0, A1, V) = 0.\n        // solve for theta.\n        // evaluate points.\n        // project back to line.\n        let matrixA;\n        let matrixB;\n        if (this._worldToLocalPerspective) {\n            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\n            const dataB = cpB.toTransformedPoint4d(this._worldToLocalPerspective);\n            matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\n            matrixB = Matrix3d.createColumnsXYW(dataB.vector0, dataB.vector0.w, dataB.vector90, dataA.vector90.w, dataB.center, dataB.center.w);\n        }\n        else {\n            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\n            const dataB = cpB.toTransformedVectors(this._worldToLocalAffine);\n            matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\n            matrixB = Matrix3d.createColumnsXYW(dataB.vector0, 0, dataB.vector90, 0, dataB.center, 1);\n        }\n        const conditionA = matrixA.conditionNumber();\n        const conditionB = matrixB.conditionNumber();\n        if (conditionA > conditionB)\n            this.dispatchArcArcThisOrder(cpA, matrixA, extendA, cpB, matrixB, extendB, reversed);\n        else\n            this.dispatchArcArcThisOrder(cpB, matrixB, extendB, cpA, matrixA, extendA, !reversed);\n        // overlap handling .. perspective is not handled . . .\n        if (!this._coincidentGeometryContext) {\n            // do nothing\n        }\n        else if (this._worldToLocalPerspective) {\n            // do nothing\n        }\n        else if (this._worldToLocalAffine) {\n            // do nothing\n        }\n        else {\n            const pairs = this._coincidentGeometryContext.coincidentArcIntersectionXY(cpA, cpB, true);\n            if (pairs !== undefined)\n                this.recordPairs(cpA, cpB, pairs, reversed);\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchArcBsplineCurve3d(cpA, extendA, cpB, extendB, reversed) {\n        // Arc: X = C + cU + sV\n        // implicitize the arc as viewed.  This \"3d\" matrix is homogeneous \"XYW\" not \"xyz\"\n        let matrixA;\n        if (this._worldToLocalPerspective) {\n            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\n            matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\n        }\n        else {\n            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\n            matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\n        }\n        // The worldToLocal has moved the arc vectors into local space.\n        // matrixA captures the xyw parts (ignoring z)\n        // for any point in world space,\n        // THIS CODE ONLY WORKS FOR\n        const matrixAInverse = matrixA.inverse();\n        if (matrixAInverse) {\n            const orderF = cpB.order; // order of the beziers for simple coordinates\n            const orderG = 2 * orderF - 1; // order of the (single) bezier for squared coordinates.\n            const coffF = new Float64Array(orderF);\n            const univariateBezierG = new UnivariateBezier(orderG);\n            const axx = matrixAInverse.at(0, 0);\n            const axy = matrixAInverse.at(0, 1);\n            const axz = 0.0;\n            const axw = matrixAInverse.at(0, 2);\n            const ayx = matrixAInverse.at(1, 0);\n            const ayy = matrixAInverse.at(1, 1);\n            const ayz = 0.0;\n            const ayw = matrixAInverse.at(1, 2);\n            const awx = matrixAInverse.at(2, 0);\n            const awy = matrixAInverse.at(2, 1);\n            const awz = 0.0;\n            const aww = matrixAInverse.at(2, 2);\n            if (matrixAInverse) {\n                let bezier;\n                for (let spanIndex = 0;; spanIndex++) {\n                    bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);\n                    if (!bezier)\n                        break;\n                    if (this._worldToLocalPerspective)\n                        bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\n                    else if (this._worldToLocalAffine)\n                        bezier.tryTransformInPlace(this._worldToLocalAffine);\n                    univariateBezierG.zero();\n                    bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);\n                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\n                    bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);\n                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\n                    bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);\n                    univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);\n                    const roots = univariateBezierG.roots(0.0, true);\n                    if (roots) {\n                        for (const root of roots) {\n                            const fractionB = bezier.fractionToParentFraction(root);\n                            // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\n                            const bcurvePoint4d = bezier.fractionToPoint4d(root);\n                            const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\n                            const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\n                            const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\n                            if (this.acceptFraction(extendA, arcFraction, extendA) &&\n                                this.acceptFraction(extendB, fractionB, extendB)) {\n                                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /** Apply the transformation to bezier curves. optionally construct ranges. */\n    transformBeziers(beziers) {\n        if (this._worldToLocalAffine) {\n            for (const bezier of beziers)\n                bezier.tryTransformInPlace(this._worldToLocalAffine);\n        }\n        else if (this._worldToLocalPerspective) {\n            for (const bezier of beziers)\n                bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\n        }\n    }\n    getRanges(beziers) {\n        const ranges = [];\n        ranges.length = 0;\n        for (const b of beziers) {\n            ranges.push(b.range());\n        }\n        return ranges;\n    }\n    dispatchBezierBezierStrokeFirst(bezierA, bcurveA, strokeCountA, bezierB, bcurveB, _strokeCountB, univariateBezierB, // caller-allocated for univariate coefficients.\n    reversed) {\n        if (!this._xyzwA0)\n            this._xyzwA0 = Point4d.create();\n        if (!this._xyzwA1)\n            this._xyzwA1 = Point4d.create();\n        if (!this._xyzwPlane)\n            this._xyzwPlane = Point4d.create();\n        if (!this._xyzwB)\n            this._xyzwB = Point4d.create();\n        /*\n        const roots = univariateBezierG.roots(0.0, true);\n        if (roots) {\n          for (const root of roots) {\n            const fractionB = bezier.fractionToParentFraction(root);\n            // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\n            const bcurvePoint4d = bezier.fractionToPoint4d(root);\n            const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\n            const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\n            const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\n            if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\n              this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\n                fractionB, cpB, 0, 1, reversed);\n            }\n          }\n        */\n        bezierA.fractionToPoint4d(0.0, this._xyzwA0);\n        let f0 = 0.0;\n        let f1;\n        const intervalTolerance = 1.0e-5;\n        const df = 1.0 / strokeCountA;\n        for (let i = 1; i <= strokeCountA; i++, f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {\n            f1 = i * df;\n            bezierA.fractionToPoint4d(f1, this._xyzwA1);\n            Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);\n            bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);\n            let errors = 0;\n            const roots = univariateBezierB.roots(0.0, true);\n            if (roots)\n                for (const r of roots) {\n                    let bezierBFraction = r;\n                    bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);\n                    const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);\n                    if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {\n                        let bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);\n                        const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);\n                        const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);\n                        newtonSearcher.setUV(bezierAFraction, bezierBFraction);\n                        if (newtonSearcher.runIterations()) {\n                            bezierAFraction = newtonSearcher.getU();\n                            bezierBFraction = newtonSearcher.getV();\n                        }\n                        // We have a near intersection at fractions on the two beziers !!!\n                        // Iterate on the curves for a true intersection ....\n                        // NEEDS WORK -- just accept . . .\n                        const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);\n                        const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);\n                        const xyzA0 = bezierA.fractionToPoint(bezierAFraction);\n                        const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);\n                        const xyzB0 = bezierB.fractionToPoint(bezierBFraction);\n                        const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);\n                        if (!xyzA0.isAlmostEqualXY(xyzA1))\n                            errors++;\n                        if (!xyzB0.isAlmostEqualXY(xyzB1))\n                            errors++;\n                        if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))\n                            errors++;\n                        if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))\n                            errors++;\n                        if (this.acceptFraction(false, bcurveAFraction, false) &&\n                            this.acceptFraction(false, bcurveBFraction, false)) {\n                            this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1, bcurveBFraction, bcurveB, 0, 1, reversed);\n                        }\n                    }\n                }\n        }\n    }\n    // Caller accesses data from two arcs.\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchBSplineCurve3dBSplineCurve3d(bcurveA, bcurveB, _reversed) {\n        const bezierSpanA = bcurveA.collectBezierSpans(true);\n        const bezierSpanB = bcurveB.collectBezierSpans(true);\n        const numA = bezierSpanA.length;\n        const numB = bezierSpanB.length;\n        this.transformBeziers(bezierSpanA);\n        this.transformBeziers(bezierSpanB);\n        const rangeA = this.getRanges(bezierSpanA);\n        const rangeB = this.getRanges(bezierSpanB);\n        const orderA = bcurveA.order;\n        const orderB = bcurveB.order;\n        const univariateCoffsA = new UnivariateBezier(orderA);\n        const univariateCoffsB = new UnivariateBezier(orderB);\n        for (let a = 0; a < numA; a++) {\n            for (let b = 0; b < numB; b++) {\n                if (rangeA[a].intersectsRangeXY(rangeB[b])) {\n                    const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();\n                    const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();\n                    if (strokeCountA < strokeCountB)\n                        this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, _reversed);\n                    else\n                        this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, !_reversed);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the projection transform (if any) to (xyz, w)\n     * @param xyz xyz parts of input point.\n     * @param w weight to use for homogeneous effects\n     */\n    projectPoint(xyz, w = 1.0) {\n        if (this._worldToLocalPerspective)\n            return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);\n        if (this._worldToLocalAffine)\n            return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);\n        return Point4d.createFromPointAndWeight(xyz, w);\n    }\n    mapNPCPlaneToWorld(npcPlane, worldPlane) {\n        // for NPC pointY, Y^ * H = 0 is \"on\" plane H.  (Hat is transpose)\n        // NPC Y is A*X for our transform A and worldPointX.\n        // hence (A X)^ * H = 0\n        // hence X^ * A^ * H = 0\n        // hence K = A^ * H\n        if (this._worldToLocalAffine) {\n            this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);\n        }\n        else if (this._worldToLocalPerspective) {\n            this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);\n        }\n        else {\n            npcPlane.clone(worldPlane);\n        }\n    }\n    // Caller accesses data from segment and bsplineCurve\n    // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\n    // Solves the arc-arc equations\n    dispatchSegmentBsplineCurve(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, bcurve, extendB, reversed) {\n        const pointA0H = this.projectPoint(pointA0);\n        const pointA1H = this.projectPoint(pointA1);\n        const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);\n        this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);\n        // NOW .. we have a plane in world space.  Intersect it with the bspline:\n        const intersections = [];\n        bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);\n        // intersections has WORLD points with bspline fractions.\n        // (the bspline fractions are all good 0..1 fractions within the spline).\n        // accept those that are within the segment range.\n        for (const detail of intersections) {\n            const fractionB = detail.fraction;\n            const curvePoint = detail.point;\n            const curvePointH = this.projectPoint(curvePoint);\n            const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);\n            if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) &&\n                this.acceptFraction(extendB, fractionB, extendB)) {\n                this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, fractionB, bcurve, 0, 1, reversed);\n            }\n        }\n    }\n    /** Low level dispatch of linestring with (beziers of) a bspline curve. */\n    dispatchLineStringBSplineCurve(lsA, extendA, curveB, extendB, reversed) {\n        const numA = lsA.numPoints();\n        if (numA > 1) {\n            const dfA = 1.0 / (numA - 1);\n            let fA0;\n            let fA1;\n            fA0 = 0.0;\n            const pointA0 = CurveCurveIntersectXY._workPointA0;\n            const pointA1 = CurveCurveIntersectXY._workPointA1;\n            lsA.pointAt(0, pointA0);\n            for (let iA = 1; iA < numA; iA++, pointA0.setFrom(pointA1), fA0 = fA1) {\n                lsA.pointAt(iA, pointA1);\n                fA1 = iA * dfA;\n                this.dispatchSegmentBsplineCurve(lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA, curveB, extendB, reversed);\n            }\n        }\n        return undefined;\n    }\n    /** Detail computation for segment intersecting linestring. */\n    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {\n        const pointA0 = lsA.point0Ref;\n        const pointA1 = lsA.point1Ref;\n        const pointB0 = CurveCurveIntersectXY._workPointBB0;\n        const pointB1 = CurveCurveIntersectXY._workPointBB1;\n        const numB = lsB.numPoints();\n        if (numB > 1) {\n            const dfB = 1.0 / (numB - 1);\n            let fB0;\n            let fB1;\n            fB0 = 0.0;\n            lsB.pointAt(0, pointB0);\n            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                lsB.pointAt(ib, pointB1);\n                fB1 = ib * dfB;\n                this.dispatchSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);\n            }\n        }\n        return undefined;\n    }\n    /** Detail computation for arc intersecting linestring. */\n    computeArcLineString(arcA, extendA, lsB, extendB, reversed) {\n        const pointB0 = CurveCurveIntersectXY._workPointBB0;\n        const pointB1 = CurveCurveIntersectXY._workPointBB1;\n        const numB = lsB.numPoints();\n        if (numB > 1) {\n            const dfB = 1.0 / (numB - 1);\n            let fB0;\n            let fB1;\n            fB0 = 0.0;\n            lsB.pointAt(0, pointB0);\n            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                lsB.pointAt(ib, pointB1);\n                fB1 = ib * dfB;\n                this.dispatchSegmentArc(lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, arcA, extendA, extendA, !reversed);\n            }\n        }\n        return undefined;\n    }\n    static setTransformedWorkPoints(transform, pointA0, pointA1, pointB0, pointB1) {\n        transform.multiplyPoint3d(pointA0, this._workPointA0);\n        transform.multiplyPoint3d(pointA1, this._workPointA1);\n        transform.multiplyPoint3d(pointB0, this._workPointB0);\n        transform.multiplyPoint3d(pointB1, this._workPointB1);\n    }\n    /** Double dispatch handler for strongly typed segment. */\n    handleLineSegment3d(segmentA) {\n        if (this._geometryB instanceof LineSegment3d) {\n            const segmentB = this._geometryB;\n            this.dispatchSegmentSegment(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB, false);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchSegmentArc(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchSegmentBsplineCurve(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, false);\n        }\n    }\n    /** Double dispatch handler for strongly typed linestring. */\n    handleLineString3d(lsA) {\n        if (this._geometryB instanceof LineString3d) {\n            const lsB = this._geometryB;\n            const pointA0 = CurveCurveIntersectXY._workPointAA0;\n            const pointA1 = CurveCurveIntersectXY._workPointAA1;\n            const pointB0 = CurveCurveIntersectXY._workPointBB0;\n            const pointB1 = CurveCurveIntersectXY._workPointBB1;\n            const numA = lsA.numPoints();\n            const numB = lsB.numPoints();\n            if (numA > 1 && numB > 1) {\n                lsA.pointAt(0, pointA0);\n                const dfA = 1.0 / (numA - 1);\n                const dfB = 1.0 / (numB - 1);\n                let fA0 = 0.0;\n                let fB0;\n                let fA1;\n                let fB1;\n                const extendA = this._extendA;\n                const extendB = this._extendB;\n                lsA.pointAt(0, pointA0);\n                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {\n                    fA1 = ia * dfA;\n                    fB0 = 0.0;\n                    lsA.pointAt(ia, pointA1);\n                    lsB.pointAt(0, pointB0);\n                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {\n                        lsB.pointAt(ib, pointB1);\n                        fB1 = ib * dfB;\n                        this.dispatchSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);\n                    }\n                }\n            }\n        }\n        else if (this._geometryB instanceof LineSegment3d) {\n            this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed arc. */\n    handleArc3d(arc0) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentArc(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, arc0, this._extendA, this._extendA, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        else if (this._geometryB instanceof BSplineCurve3d) {\n            this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed bspline curve. */\n    handleBSplineCurve3d(curve) {\n        if (this._geometryB instanceof LineSegment3d) {\n            this.dispatchSegmentBsplineCurve(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof LineString3d) {\n            this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof Arc3d) {\n            this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        else if (this._geometryB instanceof BSplineCurve3dBase) {\n            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\n        }\n        return undefined;\n    }\n    /** Double dispatch handler for strongly typed homogeneous bspline curve .. */\n    handleBSplineCurve3dH(_curve) {\n        /*\n        // NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH .\n        // \"easy\" if both present BezierCurve3dH span loaders\n        if (this._geometryB instanceof LineSegment3d) {\n          this.dispatchSegmentBsplineCurve(\n            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\n            curve, this._extendA, true);\n        } else if (this._geometryB instanceof LineString3d) {\n          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\n        } else if (this._geometryB instanceof Arc3d) {\n          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\n        }\n        */\n        return undefined;\n    }\n}\nCurveCurveIntersectXY._workVector2dA = Vector2d.create();\nCurveCurveIntersectXY._workPointA0H = Point4d.create();\nCurveCurveIntersectXY._workPointA1H = Point4d.create();\nCurveCurveIntersectXY._workPointB0H = Point4d.create();\nCurveCurveIntersectXY._workPointB1H = Point4d.create();\nCurveCurveIntersectXY._workPointAA0 = Point3d.create();\nCurveCurveIntersectXY._workPointAA1 = Point3d.create();\nCurveCurveIntersectXY._workPointBB0 = Point3d.create();\nCurveCurveIntersectXY._workPointBB1 = Point3d.create();\nCurveCurveIntersectXY._workPointA0 = Point3d.create();\nCurveCurveIntersectXY._workPointA1 = Point3d.create();\nCurveCurveIntersectXY._workPointB0 = Point3d.create();\nCurveCurveIntersectXY._workPointB1 = Point3d.create();\nexport { CurveCurveIntersectXY };\n//# sourceMappingURL=CurveCurveIntersectXY.js.map",
      "start": 1693508125271,
      "end": 1693508125397,
      "sourcemaps": null
    }
  ]
}
