{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/hypermodeling/lib/esm/SectionMarkerHandler.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module HyperModeling\n */\nimport { IModelApp } from \"@itwin/core-frontend\";\n/** Supplies interactions with [[SectionMarker]]s, including a mini-toolbar displayed when the mouse hovers over a marker and what action occurs when the user clicks a marker.\n * The base implementation supplies the following interactions:\n *  * Click: Toggle display of the section graphics and clip volume; apply the section's spatial view if toggling on.\n *  * Toolbar:\n *    * Apply Section: Applies the section location's spatial view to the viewport and displays the 2d section graphics.\n *    * Open Drawing: Navigates to the section drawing view. By default, this applies the section drawing view to the viewport.\n *    * Open Sheet: Navigates to the [ViewAttachment]($backend) of the section drawing on a [Sheet]($backend). Disabled if no such attachment exists.\n * @see [[HyperModelingConfig]] to override the default handler by supplying a subclass of `SectionMarkerHandler`.\n * @see [[HyperModelingDecorator]] for various methods that might be usefully wired up to marker click or toolbar actions.\n * @public\n */\nexport class SectionMarkerHandler {\n    /** Respond to activation of the specified marker. Return true if the marker should become the active marker - i.e., if the marker was successfully activated.\n     * @see [[SectionMarkerHandler.deactivateMarker]].\n     */\n    async activateMarker(marker, decorator) {\n        return decorator.toggleSection(marker, true);\n    }\n    /** Respond to deactivation of the specified marker. Invoked when the user clicks on the marker while it is the active marker.\n     * This should perform the inverse of [[SectionMarkerHandler.activateMarker]]. The marker becomes inactive as a result.\n     */\n    async deactivateMarker(marker, decorator) {\n        await decorator.toggleSection(marker, false);\n    }\n    /** Return toolbar items for the specified marker. If the array of toolbar items is empty, no toolbar will be displayed.\n     * @see [[executeCommand]] to implement each toolbar command.\n     */\n    getToolbarProps(marker, _decorator) {\n        const localization = IModelApp.localization;\n        return {\n            items: [\n                {\n                    id: \"apply_view\",\n                    itemPriority: 10,\n                    label: localization.getLocalizedString(\"HyperModeling:Message.ApplyView\"),\n                    icon: \"icon-spatial-view-apply\",\n                    execute: () => { },\n                    isDisabled: false,\n                },\n                {\n                    id: \"open_section\",\n                    itemPriority: 20,\n                    label: localization.getLocalizedString(\"HyperModeling:Message.OpenSection\"),\n                    icon: \"icon-plan-drawing\",\n                    execute: () => { },\n                    isDisabled: false,\n                },\n                {\n                    id: \"open_sheet\",\n                    itemPriority: 30,\n                    label: localization.getLocalizedString(\"HyperModeling:Message.OpenSheet\"),\n                    icon: \"icon-plan-floor\",\n                    execute: () => { },\n                    isDisabled: undefined === marker.state.viewAttachment?.viewId,\n                },\n            ],\n        };\n    }\n    /** Execute the command associated with the specified tool bar item.\n     * @see [[getToolbarProps]] to define the set of commands.\n     */\n    async executeCommand(commandId, marker, decorator) {\n        switch (commandId) {\n            case \"apply_view\":\n                await decorator.applySpatialView(marker);\n                break;\n            case \"open_section\":\n                await decorator.openSection(marker);\n                break;\n            case \"open_sheet\":\n                await decorator.openSheet(marker);\n                break;\n        }\n    }\n    /** Customize which markers are visible. [[HyperModelingDecorator]] determines marker visibility as follows:\n     *  - If a marker is currently active (selected), only that marker is visible.\n     *  - Otherwise, the marker is visible if this method returns `true`.\n     * The default implementation of this method determines visibility based on the [[SectionMarkerConfig]] as follows.\n     *  - If the marker is of a type included in the config's `hiddenSectionTypes`, it is invisible.\n     *  - If the marker belongs to a model not currently displayed in the viewport and the config's `ignoreModelSelector` is false, it is invisible.\n     *  - If the marker belongs to a category not currently displayed in the viewport and the config's `ignoreCategorySelector` is false, it is invisible,\n     *  - Otherwise, the marker is visible, unless this method returns `false`.\n     * The default implementation of this method always returns `true`\n     * @param marker The marker whose visibility is to be determined.\n     * @param decorator The hypermodeling decorator to which the marker belongs.\n     * @param config The configuration controlling marker visibility based on [SectionType]($common), [ModelSelectorState]($frontend), and [CategorySelectorState]($frontend).\n     * @returns true if the marker should be displayed; false to make it invisible.\n     * @see [[HyperModelingDecorator.requestSync]] to force the decorator to reevaluate marker visibility when the criterion used by your implementation of this method changes.\n     */\n    isMarkerVisible(marker, decorator, config) {\n        if (undefined !== config.hiddenSectionTypes && config.hiddenSectionTypes.includes(marker.state.sectionType))\n            return false;\n        if (!config.ignoreCategorySelector && !decorator.viewport.view.viewsCategory(marker.state.category))\n            return false;\n        if (!config.ignoreModelSelector && !decorator.viewport.view.viewsModel(marker.state.model))\n            return false;\n        return true;\n    }\n}\n//# sourceMappingURL=SectionMarkerHandler.js.map",
      "start": 1693508122871,
      "end": 1693508122972,
      "sourcemaps": null
    }
  ]
}
