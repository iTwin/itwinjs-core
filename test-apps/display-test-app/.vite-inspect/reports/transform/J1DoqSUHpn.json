{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/topology/HalfEdgePositionDetail.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Topology\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n/**\n * Enumeration of categorization of \"where\" a HalfEdgePositionDetail is sitting in the graph.\n */\nexport var HalfEdgeTopo;\n(function (HalfEdgeTopo) {\n    /** No known position */\n    HalfEdgeTopo[HalfEdgeTopo[\"None\"] = 0] = \"None\";\n    /**  Sitting at a vertex, reached by a ray in this sector */\n    HalfEdgeTopo[HalfEdgeTopo[\"Vertex\"] = 1] = \"Vertex\";\n    /** Sitting on an edge */\n    HalfEdgeTopo[HalfEdgeTopo[\"Edge\"] = 2] = \"Edge\";\n    /** Face point (before hitting barrier edge) */\n    HalfEdgeTopo[HalfEdgeTopo[\"Face\"] = 3] = \"Face\";\n    /** Exterior point (after hitting barrier edge at fraction)\n     * Fraction is 0 if exterior point \"in sweep around exterior corner\"\n    */\n    HalfEdgeTopo[HalfEdgeTopo[\"ExteriorFace\"] = 4] = \"ExteriorFace\";\n})(HalfEdgeTopo || (HalfEdgeTopo = {}));\n/**\n * Description of a generalized position within a graph, categorized as:\n * * \"at a certain node around a vertex\"\n * * \"at a fractional position along an edge\n * * \"within a face\"\n */\nexport class HalfEdgePositionDetail {\n    /** Constructor.\n     * * The point is CAPTURED.  (static `create` methods normally clone their inputs.)\n     */\n    constructor(node, x, y, z, topo, edgeFraction, iTag, dTag, isExteriorTarget) {\n        this._node = node;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this._topo = topo;\n        this._edgeFraction = edgeFraction;\n        this._iTag = iTag;\n        this._dTag = dTag;\n        this._isExteriorTarget = isExteriorTarget;\n    }\n    /** Copy (clones of) all data from other */\n    setFrom(other) {\n        this._node = other._node;\n        this.x = other.x;\n        this.y = other.y;\n        this.z = other.z;\n        this._topo = other._topo;\n        this._edgeFraction = other._edgeFraction;\n        this._iTag = other._iTag;\n        this._dTag = other._dTag;\n    }\n    /** reset to null topo state. */\n    resetAsUnknown() {\n        this._node = undefined;\n        this._topo = HalfEdgeTopo.None;\n    }\n    /**  Create with null data. */\n    static create() {\n        const detail = new HalfEdgePositionDetail(undefined, 0, 0, 0, HalfEdgeTopo.None);\n        return detail;\n    }\n    getITag() { return this._iTag; }\n    setITag(value) { this._iTag = value; }\n    getDTag() { return this._dTag; }\n    setDTag(value) { this._dTag = value; }\n    getTopo() { return this._topo; }\n    /** Create with node, fraction along edge, marked as \"HalfEdgeTopo.Edge\".  Compute interpolated xyz on the edge */\n    static createEdgeAtFraction(node, edgeFraction) {\n        const node1 = node.faceSuccessor;\n        const x = Geometry.interpolate(node.x, edgeFraction, node1.x);\n        const y = Geometry.interpolate(node.y, edgeFraction, node1.y);\n        const z = Geometry.interpolate(node.z, edgeFraction, node1.z);\n        return new HalfEdgePositionDetail(node, x, y, z, HalfEdgeTopo.Edge, edgeFraction);\n    }\n    /** reassign contents so this instance becomes a face hit.\n     * @param node new node value. If missing, current node is left unchanged.\n     * @param xyz new coordinates. if missing, current coordinates are left unchanged.\n     */\n    resetAsFace(node, xyz) {\n        this._topo = HalfEdgeTopo.Face;\n        if (node)\n            this._node = node;\n        if (xyz) {\n            this.x = xyz.x;\n            this.y = xyz.y;\n            this.z = xyz.z;\n        }\n        this._isExteriorTarget = undefined;\n        return this;\n    }\n    /** reassign contents so this instance has dTag but no node or HalfEdgeTopo\n     */\n    resetAsUndefinedWithTag(dTag) {\n        this._topo = HalfEdgeTopo.None;\n        this._dTag = 0;\n        this._iTag = 0;\n        this._dTag = dTag;\n        this._node = undefined;\n        this._isExteriorTarget = undefined;\n        return this;\n    }\n    /** reassign contents so this instance becomes an edge hit\n     * @param node new node value.\n     * @param edgeFraction new edge fraction.   xyz is recomputed from this edge and its face successor.\n     */\n    resetAtEdgeAndFraction(node, edgeFraction) {\n        this._topo = HalfEdgeTopo.Edge;\n        this._node = node;\n        const nodeB = node.faceSuccessor;\n        this._edgeFraction = edgeFraction;\n        this.x = Geometry.interpolate(node.x, edgeFraction, nodeB.x);\n        this.y = Geometry.interpolate(node.y, edgeFraction, nodeB.y);\n        this.z = Geometry.interpolate(node.z, edgeFraction, nodeB.z);\n        this._isExteriorTarget = undefined;\n        return this;\n    }\n    /** Create at a node.\n     * * Take xyz from the node.\n     */\n    static createVertex(node) {\n        return new HalfEdgePositionDetail(node, node.x, node.y, node.z, HalfEdgeTopo.Vertex);\n    }\n    /** Mark as \"HalfEdgeTopo.Vertex\"\n     */\n    resetAsVertex(node) {\n        this._topo = HalfEdgeTopo.Vertex;\n        this._node = node;\n        this._edgeFraction = 0.0;\n        this.setXYZFromNode(node);\n        this._isExteriorTarget = undefined;\n        return this;\n    }\n    /**  Set the flag for an exterior relationship to target. */\n    setIsExteriorTarget(isExterior) {\n        this._isExteriorTarget = isExterior;\n    }\n    /** Copy x,y,z from the node to this instance local values. */\n    setXYZFromNode(node) {\n        this.x = node.x;\n        this.y = node.y;\n        this.z = node.z;\n    }\n    /**\n     * Return the (possibly undefined) edge fraction.\n     */\n    get edgeFraction() {\n        return this._edgeFraction;\n    }\n    /**  property access for the flag for an exterior relationship to target.\n     * * undefined flag is returned as false.\n    */\n    get isExteriorTarget() {\n        return this._isExteriorTarget !== undefined ? this._isExteriorTarget : false;\n    }\n    /** Return true if this detail is marked as being within a face. */\n    get isFace() { return this._topo === HalfEdgeTopo.Face; }\n    /** Return true if this detail is marked as being within an edge. */\n    get isEdge() { return this._topo === HalfEdgeTopo.Edge; }\n    /** Return true if this detail is marked as being at a vertex. */\n    get isVertex() { return this._topo === HalfEdgeTopo.Vertex; }\n    /** Return true if this detail has no vertex, edge, or face qualifier. */\n    get isUnclassified() { return this._topo === HalfEdgeTopo.None; }\n    /** Return the node reference from this detail */\n    get node() { return this._node; }\n    /** Return the (clone of, or optional filled in result) coordinates from this detail. */\n    clonePoint(result) { return Point3d.create(this.x, this.y, this.z, result); }\n    /*\n      // If candidateKey is less than resultKey, replace resultPos and resultKey\n      // by the candidate data.\n      public updateMinimizer(\n        HalfEdgePositionDetail & resultPos, number & resultKey,\n    : HalfEdgePositionDetail & candidatePos, candidateKey: number\n      ): boolean {\n        if (candidateKey < resultKey) {\n          resultKey = candidateKey;\n          resultPos = candidatePos;\n          return true;\n        }\n        return false;\n      }\n    */\n    isAtXY(x, y) {\n        return this._topo !== HalfEdgeTopo.None && Geometry.isSameCoordinate(this.x, x) && Geometry.isSameCoordinate(this.y, y);\n    }\n}\n//# sourceMappingURL=HalfEdgePositionDetail.js.map",
      "start": 1693508126392,
      "end": 1693508126436,
      "sourcemaps": null
    }
  ]
}
