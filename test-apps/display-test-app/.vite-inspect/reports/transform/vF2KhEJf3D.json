{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/GreedyTriangulationBetweenLineStrings.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollectionInterval } from \"../geometry3d/IndexedCollectionInterval\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { TriangleCandidate } from \"./TriangleCandidate\";\n/** @packageDocumentation\n * @module Polyface\n */\n/**\n * * Context for constructing triangulations between linestrings with dis-similar point counts and distribution.\n * @internal\n */\nclass GreedyTriangulationBetweenLineStrings {\n    constructor(turnRadians) {\n        this._turnRadians = turnRadians;\n        this._xyzA = Point3d.create();\n        this._xyzB = Point3d.create();\n        this._forwardA = Vector3d.create();\n        this._forwardB = Vector3d.create();\n        this._vector1 = Vector3d.create();\n        this._crossA = Vector3d.create();\n        this._crossB = Vector3d.create();\n    }\n    isForwardVector(candidate, forward, perp) {\n        if (candidate.dotProduct(forward) <= 0.0)\n            return false;\n        const theta = candidate.angleFromPerpendicular(perp);\n        if (Math.abs(theta.radians) > this._turnRadians)\n            return false;\n        return true;\n    }\n    isPlanarBase(pointsA, baseA, pointsB, baseB, xyzA, crossA, forwardA, xyzB, crossB, forwardB) {\n        if (baseA + 1 < pointsA.length && baseB + 1 < pointsB.length) {\n            pointsA.getPoint3dAtUncheckedPointIndex(baseA, xyzA);\n            pointsB.getPoint3dAtUncheckedPointIndex(baseB, xyzB);\n            pointsA.vectorXYAndZIndex(xyzA, baseA + 1, forwardA);\n            pointsB.vectorXYAndZIndex(xyzB, baseB + 1, forwardB);\n            Vector3d.createStartEnd(xyzA, xyzB, this._vector1);\n            this._vector1.crossProduct(forwardA, crossA);\n            this._vector1.crossProduct(forwardB, crossB);\n            if (!xyzA.isAlmostEqual(xyzB) && crossA.angleTo(crossB).radians < this._turnRadians)\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Starting at start in source, examine points to see how long they are close to being \"in plane\"\n     * * child interval begins at parent.begin\n     * * child interval end initializes at trialEnd and grows.\n     * * child must be predefined by caller\n     * * Return the accepted interval\n     */\n    advanceToPlanarLimit(parent, child, trialEnd, xyzA, perpA, forwardA, perpB, forwardB) {\n        child.setFrom(parent, parent.begin, trialEnd); // initialize as empty interval.\n        while (child.end < parent.end) {\n            child.points.vectorXYAndZIndex(xyzA, child.end, this._vector1);\n            if (!this.isForwardVector(this._vector1, forwardA, perpA))\n                break;\n            if (!this.isForwardVector(this._vector1, forwardB, perpB))\n                break;\n            if (child.end > 0) {\n                child.points.vectorIndexIndex(child.end - 1, child.end, this._vector1);\n                if (!this.isForwardVector(this._vector1, forwardA, perpA))\n                    break;\n            }\n            child.end++;\n        }\n    }\n    /** evaluate aspect ratios to select heuristically best triangles with given index intervals.\n     * (ASSUME NO DUPLICATES, as in caller.)\n     */\n    addGreedy(intervalA, intervalB, handler, addOnly1 = false) {\n        intervalA.restrictEnd();\n        intervalB.restrictEnd();\n        while (intervalA.length > 1 && intervalB.length > 1) {\n            // triangles A1 and B1 are always valid.\n            this._triangleA1 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 1, this._triangleA1);\n            this._triangleA2 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin + 1, intervalA.points, intervalA.begin + 2, intervalB.points, intervalB.begin, 2, this._triangleA2);\n            this._triangleA3 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin + 1, 3, this._triangleA3);\n            this._triangleB1 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, -1, this._triangleB1);\n            this._triangleB2 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 2, intervalB.points, intervalB.begin + 1, intervalA.points, intervalA.begin, -2, this._triangleB2);\n            this._triangleB3 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin + 1, -3, this._triangleB3);\n            // Look at pairs of 2 triangles.\n            // (each pair begins with 1 or -1)\n            // For each pair find the smallest aspect ratio of its two triangles.  (Small is bad)\n            // Choose the pair where that (smaller aspect ratio of two) is largest.\n            // Advance in that direction.\n            this._bestTriangle = TriangleCandidate.copyWithLowerQuality(this._triangleA1, this._triangleB3, this._bestTriangle);\n            this._workTriangle = TriangleCandidate.copyWithLowerQuality(this._triangleB1, this._triangleA3, this._workTriangle);\n            TriangleCandidate.updateIfOtherHasHigherQuality(this._bestTriangle, this._workTriangle);\n            // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleB1, triangleB2));\n            // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleA1, triangleA2));\n            if (this._bestTriangle.id > 0) {\n                intervalA.advanceBegin();\n                handler(this._bestTriangle);\n                if (addOnly1)\n                    return;\n            }\n            else {\n                intervalB.advanceBegin();\n                handler(this._bestTriangle);\n                if (addOnly1)\n                    return;\n            }\n        }\n        // sweep in trailing points from either side.  At least one of intervalA.begin, intervalB.begin is at its limit, so only one of these will execute any bodies.\n        if (intervalA.isSingleton) {\n            while (intervalB.length >= 2) {\n                this._workTriangle = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, 0, this._workTriangle);\n                //  this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.\n                handler(this._workTriangle);\n                intervalB.advanceBegin();\n            }\n        }\n        // sweep in trailing points from either side.  At least one of baseA, baseB is at its limit, so only one of these will execute any bodies.\n        if (intervalB.isSingleton) {\n            while (intervalA.length >= 2) {\n                this._workTriangle = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 0, this._workTriangle);\n                // this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.\n                handler(this._workTriangle);\n                intervalA.advanceBegin();\n            }\n        }\n    }\n    /**\n     * Working from start to finish, emit triangles with heuristic lookahead to get pleasing matching between the linestrings.\n     * @param pointsA\n     * @param pointsB\n     * @param handler\n     */\n    emitTriangles(pointsA, pointsB, handler) {\n        /** Clean up duplicates for the real logic . . . */\n        this.emitTrianglesGo(resolveToNoDuplicates(pointsA), resolveToNoDuplicates(pointsB), handler);\n    }\n    /**\n     * Run triangle logic on inputs with no duplicates.\n     * @param pointsA\n     * @param pointsB\n     * @param handler\n     */\n    emitTrianglesGo(pointsA, pointsB, handler) {\n        const intervalA = IndexedXYZCollectionInterval.createComplete(pointsA);\n        const intervalB = IndexedXYZCollectionInterval.createComplete(pointsB);\n        const childA = IndexedXYZCollectionInterval.createComplete(pointsA);\n        const childB = IndexedXYZCollectionInterval.createComplete(pointsB);\n        while (intervalA.length > 0 && intervalB.length > 0 && (intervalA.length > 1 || intervalB.length > 1)) {\n            // const lA = intervalA.length;\n            // const lB = intervalB.length;\n            if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\n                this.advanceToPlanarLimit(intervalA, childA, intervalA.begin + 1, this._xyzA, this._crossA, this._forwardA, this._crossB, this._forwardB);\n                this.advanceToPlanarLimit(intervalB, childB, intervalB.begin + 1, this._xyzB, this._crossB, this._forwardB, this._crossA, this._forwardA);\n                this.addGreedy(childA, childB, handler);\n                intervalA.advanceToTail(childA);\n                intervalB.advanceToTail(childB);\n            }\n            else if (this.isPlanarBase(pointsA, intervalA.begin + 1, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\n                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\n                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 1);\n                this.addGreedy(childA, childB, handler);\n                intervalA.advanceToTail(childA);\n                intervalB.advanceToTail(childB);\n            }\n            else if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin + 1, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\n                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 1);\n                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\n                this.addGreedy(childA, childB, handler);\n                intervalA.advanceToTail(childA);\n                intervalB.advanceToTail(childB);\n            }\n            else if (intervalA.length > 1 && intervalB.length > 1) {\n                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\n                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\n                this.addGreedy(childA, childB, handler, true);\n                intervalA.advanceToHead(childA);\n                intervalB.advanceToHead(childB);\n            }\n            else if (intervalA.length > 1) {\n                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\n                childB.setFrom(intervalB);\n                this.addGreedy(childA, childB, handler);\n                intervalA.advanceToTail(childA);\n                intervalB.advanceToTail(childB);\n            }\n            else if (intervalB.length > 1) {\n                childA.setFrom(intervalA);\n                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\n                this.addGreedy(childA, childB, handler);\n                intervalA.advanceToTail(childA);\n                intervalB.advanceToTail(childB);\n            }\n            /*      if (intervalA.length >= lA && intervalB.length >= lB) {\n                    // This should not happen == neither one advanced.   Just move ahead in the longer one ..\n                    if (intervalA.length > intervalB.length)\n                      intervalA.advanceBegin();\n                    else intervalB.advanceBegin();\n                  } */\n        }\n        // catch everything else blindly\n        this.addGreedy(intervalA, intervalB, handler);\n    }\n    static createContext(planarTurnAngle = this.defaultNearColinearAngle) {\n        return new GreedyTriangulationBetweenLineStrings(planarTurnAngle.radians);\n    }\n}\n/** Default angle for considering two vectors to be colinear */\nGreedyTriangulationBetweenLineStrings.defaultNearColinearAngle = Angle.createDegrees(15);\nexport { GreedyTriangulationBetweenLineStrings };\n/**\n * * If there are no contiguous duplicated points in `data` return `data` unchanged.\n * * If there are duplicates, compress to a new array.\n * @param data\n * @param tolerance\n */\nfunction resolveToNoDuplicates(data, tolerance = Geometry.smallMetricDistance) {\n    let hasDuplicates = false;\n    const n = data.length;\n    for (let i = 0; i + 1 < n; i++) {\n        if (data.distanceIndexIndex(i, i + 1) <= tolerance) {\n            hasDuplicates = true;\n            break;\n        }\n    }\n    if (!hasDuplicates)\n        return data;\n    const result = new GrowableXYZArray(n);\n    result.pushXYZ(data.getXAtUncheckedPointIndex(0), data.getYAtUncheckedPointIndex(0), data.getZAtUncheckedPointIndex(0));\n    let i0 = 0;\n    for (let i = 1; i < n; i++) {\n        if (data.distanceIndexIndex(i0, i) > tolerance) {\n            result.pushXYZ(data.getXAtUncheckedPointIndex(i), data.getYAtUncheckedPointIndex(i), data.getZAtUncheckedPointIndex(i));\n            i0 = i;\n        }\n    }\n    /** enforce exact closure if original was closed. */\n    if (data.distanceIndexIndex(0, n - 1) <= tolerance) {\n        result.pop();\n        result.pushFromGrowableXYZArray(result, 0);\n    }\n    return result;\n}\n//# sourceMappingURL=GreedyTriangulationBetweenLineStrings.js.map",
      "start": 1693508125463,
      "end": 1693508125561,
      "sourcemaps": null
    }
  ]
}
