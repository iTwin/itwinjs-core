{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/IndexedXYCollection.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\n/**\n * abstract base class for access to XY data with indexed reference.\n * * This allows algorithms to work with Point2d[] or GrowableXY.\n *   * GrowableXYArray implements these for its data.\n *   * Point2dArrayCarrier carries a (reference to) a Point2d[] and implements the methods with calls on that array reference.\n * * In addition to \"point by point\" accessors, other abstract members compute commonly useful vector data \"between points\".\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\n * @public\n */\nexport class IndexedXYCollection {\n    /** access x of indexed point\n     * * Subclasses may wish to override with a more efficient implementation.\n     */\n    getXAtUncheckedPointIndex(pointIndex) {\n        const pt = this.getPoint2dAtCheckedPointIndex(pointIndex, IndexedXYCollection._workPoint);\n        if (undefined === IndexedXYCollection._workPoint)\n            IndexedXYCollection._workPoint = pt; // allocate the cache\n        return pt ? pt.x : 0.0;\n    }\n    /** access y of indexed point\n     * * Subclasses may wish to override with a more efficient implementation.\n     */\n    getYAtUncheckedPointIndex(pointIndex) {\n        const pt = this.getPoint2dAtCheckedPointIndex(pointIndex, IndexedXYCollection._workPoint);\n        if (undefined === IndexedXYCollection._workPoint)\n            IndexedXYCollection._workPoint = pt; // allocate the cache\n        return pt ? pt.y : 0.0;\n    }\n    /** Compute the linear combination s of the indexed p_i and given scales s_i.\n     * @param scales array of scales. For best results, scales should have same length as the instance.\n     * @param result optional pre-allocated object to fill and return\n     * @return s = sum(p_i * s_i), where i ranges from 0 to min(this.length, scales.length).\n     */\n    linearCombination(scales, result) {\n        const n = Math.min(this.length, scales.length);\n        const sum = (result instanceof Vector2d) ? Vector2d.createZero(result) : Point2d.createZero(result);\n        for (let i = 0; i < n; ++i) {\n            sum.x += scales[i] * this.getXAtUncheckedPointIndex(i);\n            sum.y += scales[i] * this.getYAtUncheckedPointIndex(i);\n        }\n        return sum;\n    }\n}\n//# sourceMappingURL=IndexedXYCollection.js.map",
      "start": 1693508123147,
      "end": 1693508123260,
      "sourcemaps": null
    }
  ]
}
