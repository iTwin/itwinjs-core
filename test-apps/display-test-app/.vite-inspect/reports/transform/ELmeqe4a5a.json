{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapLayerImageryProvider.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MapLayers\n */\nimport { assert, BeEvent } from \"@itwin/core-bentley\";\nimport { Base64EncodedString, ImageSource, ImageSourceFormat } from \"@itwin/core-common\";\nimport { Angle } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"../../NotificationManager\";\nimport { GeographicTilingScheme, WebMercatorTilingScheme } from \"../internal\";\n/** @internal */\nconst tileImageSize = 256, untiledImageSize = 256;\nconst earthRadius = 6378137;\nconst doDebugToolTips = false;\n/** The status of the map layer imagery provider that lets you know if authentication is needed to request tiles.\n * @public\n */\nexport var MapLayerImageryProviderStatus;\n(function (MapLayerImageryProviderStatus) {\n    MapLayerImageryProviderStatus[MapLayerImageryProviderStatus[\"Valid\"] = 0] = \"Valid\";\n    MapLayerImageryProviderStatus[MapLayerImageryProviderStatus[\"RequireAuth\"] = 1] = \"RequireAuth\";\n})(MapLayerImageryProviderStatus || (MapLayerImageryProviderStatus = {}));\n/** Abstract class for map layer imagery providers.\n * Map layer imagery providers request and provide tile images and other data. Each map layer from a separate source needs its own imagery provider object.\n * @beta\n */\nexport class MapLayerImageryProvider {\n    /** @internal */\n    get status() { return this._status; }\n    /** @alpha */\n    get supportsMapFeatureInfo() { return false; }\n    resetStatus() { this.setStatus(MapLayerImageryProviderStatus.Valid); }\n    /** @internal */\n    get tileSize() { return this._usesCachedTiles ? tileImageSize : untiledImageSize; }\n    /** @internal */\n    get maximumScreenSize() { return 2 * this.tileSize; }\n    get minimumZoomLevel() { return this.defaultMinimumZoomLevel; }\n    get maximumZoomLevel() { return this.defaultMaximumZoomLevel; }\n    /** @internal */\n    get usesCachedTiles() { return this._usesCachedTiles; }\n    get mutualExclusiveSubLayer() { return false; }\n    /** @internal */\n    get useGeographicTilingScheme() { return false; }\n    /** @internal */\n    get _filterByCartoRange() { return true; }\n    constructor(_settings, _usesCachedTiles) {\n        this._settings = _settings;\n        this._usesCachedTiles = _usesCachedTiles;\n        this._hasSuccessfullyFetchedTile = false;\n        this.onStatusChanged = new BeEvent();\n        /** @internal */\n        this._mercatorTilingScheme = new WebMercatorTilingScheme();\n        /** @internal */\n        this._geographicTilingScheme = new GeographicTilingScheme();\n        /** @internal */\n        this._status = MapLayerImageryProviderStatus.Valid;\n        // Those values are used internally for various computation, this should not get overriden.\n        /** @internal */\n        this.defaultMinimumZoomLevel = 0;\n        /** @internal */\n        this.defaultMaximumZoomLevel = 22;\n        this._mercatorTilingScheme = new WebMercatorTilingScheme();\n        this._geographicTilingScheme = new GeographicTilingScheme(2, 1, true);\n    }\n    /** @internal */\n    async initialize() {\n        this.loadTile(0, 0, this.defaultMaximumZoomLevel).then((tileData) => {\n            if (tileData !== undefined)\n                this._missingTileData = tileData.data;\n        });\n    }\n    get tilingScheme() { return this.useGeographicTilingScheme ? this._geographicTilingScheme : this._mercatorTilingScheme; }\n    /** @internal */\n    addLogoCards(_cards, _viewport) { }\n    /** @internal */\n    get transparentBackgroundString() { return this._settings.transparentBackground ? \"true\" : \"false\"; }\n    /** @internal */\n    async _areChildrenAvailable(_tile) { return true; }\n    /** @internal */\n    getPotentialChildIds(tile) {\n        const childLevel = tile.quadId.level + 1;\n        return tile.quadId.getChildIds(this.tilingScheme.getNumberOfXChildrenAtLevel(childLevel), this.tilingScheme.getNumberOfYChildrenAtLevel(childLevel));\n    }\n    /** @internal */\n    _generateChildIds(tile, resolveChildren) {\n        resolveChildren(this.getPotentialChildIds(tile));\n    }\n    /** @internal */\n    generateChildIds(tile, resolveChildren) {\n        if (tile.depth >= this.maximumZoomLevel || (undefined !== this.cartoRange && this._filterByCartoRange && !this.cartoRange.intersectsRange(tile.rectangle))) {\n            tile.setLeaf();\n            return;\n        }\n        this._generateChildIds(tile, resolveChildren);\n    }\n    /** @internal */\n    async getToolTip(strings, quadId, _carto, tree) {\n        if (doDebugToolTips) {\n            const range = quadId.getLatLongRangeDegrees(tree.tilingScheme);\n            strings.push(`QuadId: ${quadId.debugString}, Lat: ${range.low.x} - ${range.high.x} Long: ${range.low.y} - ${range.high.y}`);\n        }\n    }\n    /** @internal */\n    async getFeatureInfo(featureInfos, _quadId, _carto, _tree, _hit) {\n        // default implementation; simply return an empty feature info\n        featureInfos.push({ layerName: this._settings.name });\n    }\n    /** @internal */\n    async getImageFromTileResponse(tileResponse, zoomLevel) {\n        const arrayBuffer = await tileResponse.arrayBuffer();\n        const byteArray = new Uint8Array(arrayBuffer);\n        if (!byteArray || (byteArray.length === 0))\n            return undefined;\n        if (this.matchesMissingTile(byteArray) && zoomLevel > 8)\n            return undefined;\n        const contentType = tileResponse.headers.get(\"content-type\")?.toLowerCase();\n        let imageFormat;\n        if (contentType) {\n            // Note: 'includes' is used here instead of exact comparison because we encountered\n            // some servers that would give content type such as 'image/png;charset=UTF-8'.\n            if (contentType.includes(\"image/jpeg\"))\n                imageFormat = ImageSourceFormat.Jpeg;\n            else if (contentType.includes(\"image/png\"))\n                imageFormat = ImageSourceFormat.Png;\n        }\n        if (imageFormat !== undefined)\n            return new ImageSource(byteArray, imageFormat);\n        assert(false, \"Invalid tile content type\");\n        return undefined;\n    }\n    /** Change the status of this provider.\n     * Sub-classes should override 'onStatusUpdated' instead of this method.\n     * @internal\n     */\n    setStatus(status) {\n        if (this._status !== status) {\n            this.onStatusUpdated(status);\n            this._status = status;\n            this.onStatusChanged.raiseEvent(this);\n        }\n    }\n    /** Method called whenever the status changes, giving the opportunity to sub-classes to have a custom behavior.\n     *  @internal\n     */\n    onStatusUpdated(_newStatus) { }\n    /** @internal */\n    setRequestAuthorization(headers) {\n        if (this._settings.userName && this._settings.password) {\n            headers.set(\"Authorization\", `Basic ${Base64EncodedString.encode(`${this._settings.userName}:${this._settings.password}`)}`);\n        }\n    }\n    /** @internal */\n    async makeTileRequest(url) {\n        let headers;\n        if (this._settings.userName && this._settings.password) {\n            headers = new Headers();\n            this.setRequestAuthorization(headers);\n        }\n        return fetch(url, { method: \"GET\", headers });\n    }\n    /** Returns a map layer tile at the specified settings. */\n    async loadTile(row, column, zoomLevel) {\n        try {\n            const tileUrl = await this.constructUrl(row, column, zoomLevel);\n            if (tileUrl.length === 0)\n                return undefined;\n            const tileResponse = await this.makeTileRequest(tileUrl);\n            if (!this._hasSuccessfullyFetchedTile) {\n                this._hasSuccessfullyFetchedTile = true;\n            }\n            return await this.getImageFromTileResponse(tileResponse, zoomLevel);\n        }\n        catch (error) {\n            if (error?.status === 401) {\n                this.setStatus(MapLayerImageryProviderStatus.RequireAuth);\n                // Only report error to end-user if we were previously able to fetch tiles\n                // and then encountered an error, otherwise I assume an error was already reported\n                // through the source validation process.\n                if (this._hasSuccessfullyFetchedTile) {\n                    const msg = IModelApp.localization.getLocalizedString(\"iModelJs:MapLayers.Messages.LoadTileTokenError\", { layerName: this._settings.name });\n                    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Warning, msg));\n                }\n            }\n            return undefined;\n        }\n    }\n    /** @internal */\n    async toolTipFromUrl(strings, url) {\n        const headers = new Headers();\n        this.setRequestAuthorization(headers);\n        try {\n            const response = await fetch(url, { method: \"GET\", headers });\n            const text = await response.text();\n            if (undefined !== text) {\n                strings.push(text);\n            }\n        }\n        catch {\n        }\n    }\n    /** @internal */\n    matchesMissingTile(tileData) {\n        if (!this._missingTileData)\n            return false;\n        if (tileData.length !== this._missingTileData.length)\n            return false;\n        for (let i = 0; i < tileData.length; i += 10) {\n            if (this._missingTileData[i] !== tileData[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    // calculates the projected x cartesian coordinate in EPSG:3857from the longitude in EPSG:4326 (WGS84)\n    getEPSG3857X(longitude) {\n        return longitude * 20037508.34 / 180.0;\n    }\n    /** @internal */\n    // calculates the projected y cartesian coordinate in EPSG:3857from the latitude in EPSG:4326 (WGS84)\n    getEPSG3857Y(latitude) {\n        const y = Math.log(Math.tan((90.0 + latitude) * Math.PI / 360.0)) / (Math.PI / 180.0);\n        return y * 20037508.34 / 180.0;\n    }\n    /** @internal */\n    // calculates the longitude in EPSG:4326 (WGS84) from the projected x cartesian coordinate in EPSG:3857\n    getEPSG4326Lon(x3857) {\n        return Angle.radiansToDegrees(x3857 / earthRadius);\n    }\n    /** @internal */\n    // calculates the latitude in EPSG:4326 (WGS84) from the projected y cartesian coordinate in EPSG:3857\n    getEPSG4326Lat(y3857) {\n        const y = 2 * Math.atan(Math.exp(y3857 / earthRadius)) - (Math.PI / 2);\n        return Angle.radiansToDegrees(y);\n    }\n    /** @internal */\n    // Map tile providers like Bing and Mapbox allow the URL to be constructed directory from the zoom level and tile coordinates.\n    // However, WMS-based servers take a bounding box instead. This method can help get that bounding box from a tile.\n    getEPSG4326Extent(row, column, zoomLevel) {\n        // Shift left (this.tileSize << zoomLevel) overflow when using 512 pixels tile at higher resolution,\n        // so use Math.pow instead (I assume the performance lost to be minimal)\n        const mapSize = this.tileSize * Math.pow(2, zoomLevel);\n        const leftGrid = this.tileSize * column;\n        const topGrid = this.tileSize * row;\n        const longitudeLeft = 360 * ((leftGrid / mapSize) - 0.5);\n        const y0 = 0.5 - ((topGrid + this.tileSize) / mapSize);\n        const latitudeBottom = 90.0 - 360.0 * Math.atan(Math.exp(-y0 * 2 * Math.PI)) / Math.PI;\n        const longitudeRight = 360 * (((leftGrid + this.tileSize) / mapSize) - 0.5);\n        const y1 = 0.5 - (topGrid / mapSize);\n        const latitudeTop = 90.0 - 360.0 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;\n        return { longitudeLeft, longitudeRight, latitudeTop, latitudeBottom };\n    }\n    /** @internal */\n    getEPSG3857Extent(row, column, zoomLevel) {\n        const epsg4326Extent = this.getEPSG4326Extent(row, column, zoomLevel);\n        const left = this.getEPSG3857X(epsg4326Extent.longitudeLeft);\n        const right = this.getEPSG3857X(epsg4326Extent.longitudeRight);\n        const bottom = this.getEPSG3857Y(epsg4326Extent.latitudeBottom);\n        const top = this.getEPSG3857Y(epsg4326Extent.latitudeTop);\n        return { left, right, bottom, top };\n    }\n    /** @internal */\n    getEPSG3857ExtentString(row, column, zoomLevel) {\n        const tileExtent = this.getEPSG3857Extent(row, column, zoomLevel);\n        return `${tileExtent.left.toFixed(2)},${tileExtent.bottom.toFixed(2)},${tileExtent.right.toFixed(2)},${tileExtent.top.toFixed(2)}`;\n    }\n    /** @internal */\n    getEPSG4326ExtentString(row, column, zoomLevel, latLongAxisOrdering) {\n        const tileExtent = this.getEPSG4326Extent(row, column, zoomLevel);\n        if (latLongAxisOrdering) {\n            return `${tileExtent.latitudeBottom.toFixed(8)},${tileExtent.longitudeLeft.toFixed(8)},\r\n              ${tileExtent.latitudeTop.toFixed(8)},${tileExtent.longitudeRight.toFixed(8)}`;\n        }\n        else {\n            return `${tileExtent.longitudeLeft.toFixed(8)},${tileExtent.latitudeBottom.toFixed(8)},\r\n              ${tileExtent.longitudeRight.toFixed(8)},${tileExtent.latitudeTop.toFixed(8)}`;\n        }\n    }\n}\n//# sourceMappingURL=MapLayerImageryProvider.js.map",
      "start": 1693508121812,
      "end": 1693508122012,
      "sourcemaps": null
    }
  ]
}
