{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/render/TileLoadSorter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\n/** @internal */\n// NOTE: this class has been translated from Java.\n// Do not modify this file, changes will be overwritten.\nimport { Coordinate } from \"../../spatial/geom/Coordinate\";\nimport { GridIndex } from \"../model/GridIndex\";\n/**\n * Class TileLoadSorter sorts file tiles by their angle with the forward view direction (smaller angles first to load tiles in the view center first).\n *\n * @internal\n */\nclass TileLoadSorter {\n    /** The view projection */\n    /**\n     * Create a new sorter.\n     * @param tileIndex the global tile index.\n     * @param modelTransform the model transformation.\n     * @param projection the view projection.\n     */\n    constructor(tileIndex, viewProjector) {\n        this.viewProjector = viewProjector;\n        // the interface implementation markers:\n        this.isiComparator_TileIndex_Instance = true;\n        this.tileIndex = tileIndex;\n    }\n    /**\n     * Get the position of a tile in the view (camera) space.\n     * @param tile the grid index of the tile.\n     * @param dX the x grid index offset.\n     * @param dY the y grid index offset.\n     * @param dZ the z grid index offset.\n     * @return the position in view space.\n     */\n    getTilePosition(tile, dX, dY, dZ) {\n        /* Get the position of the tile center in the view world space */\n        let tileGrid = this.tileIndex.getLevel(tile.level).getTileGrid();\n        let tileCenter = tileGrid.getCellCenter(new GridIndex(tile.gridIndex.x + dX, tile.gridIndex.y + dY, tile.gridIndex.z + dZ));\n        this.viewProjector.projectToViewForSort(tileCenter);\n        /* Return the position */\n        return tileCenter;\n    }\n    /**\n     * Get the radius of a tile.\n     * @param tile the grid index of the tile.\n     * @param tilePosition the position of the tile in view space.\n     * @return the radius of the tile.\n     */\n    getTileRadius(tile, tilePosition) {\n        /* Get the position of the next tile */\n        let nextTilePosition = this.getTilePosition(tile, 1, 0, 0);\n        /* Get the distance (in view space) */\n        return nextTilePosition.distance3D(tilePosition);\n    }\n    /**\n     * Get the score of a tile.\n     * @param tile the tile index.\n     * @return the score (the lower the better).\n     */\n    getScore(tile) {\n        /* We need a tile index */\n        if (tile == null)\n            return 0.0;\n        /* Get the position of the tile center in the view (camera) space */\n        let tileCenter = this.getTilePosition(tile, 0, 0, 0);\n        if (tileCenter == null)\n            return 0.0;\n        /* Get the angle from the camera boresight (screen center) (the smaller the better) (radians) */\n        let angleFromScreenCenter = Coordinate.getAngleRad(tileCenter, new Coordinate(0.0, 0.0, 1.0) /*forward*/);\n        /* Get the radius of the tile in the view (camera) space */\n        let tileRadius = this.getTileRadius(tile, tileCenter);\n        /* Get the angular extent of the tile (the bigger the better) (radians) */\n        let tileDistance = tileCenter.getLength();\n        let tileExtent = 2.0 * Math.atan2(tileRadius, tileDistance);\n        /* We want tiles with a small screen center angle and with a big screen extent */\n        return (angleFromScreenCenter - tileExtent);\n    }\n    // Comparator interface method\n    compare(tile1, tile2) {\n        /* Load higher level tiles first (added on 21/03/2017 by LER) */\n        let dLevel = (tile1.level - tile2.level);\n        if (dLevel != 0)\n            return (-dLevel);\n        /* Compare the scores inside the level */\n        let d = (this.getScore(tile1) - this.getScore(tile2)); // new scoring method on 02/02/2017 by LER\n        return (d > 0.0) ? 1 : (d < 0.0) ? -1 : 0;\n    }\n}\n/** @ignore */\nTileLoadSorter._CLASSNAME_ = \"orbitgt.pointcloud.render.TileLoadSorter\"; // the full name of the original java class\nexport { TileLoadSorter };\n//# sourceMappingURL=TileLoadSorter.js.map",
      "start": 1693508125996,
      "end": 1693508126116,
      "sourcemaps": null
    }
  ]
}
