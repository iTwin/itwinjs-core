{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/ClipPlane.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Plane3d } from \"../geometry3d/Plane3d\";\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { IndexedXYZCollectionPolygonOps } from \"../geometry3d/PolygonOps\";\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { AnalyticRoots } from \"../numerics/Polynomials\";\nimport { ClipUtilities } from \"./ClipUtils\";\n/**\n * A ClipPlane is a single plane represented as\n * * An inward unit normal (u,v,w)\n * * A signedDistance\n * More details can be found at docs/learning/geometry/Clipping.md\n *\n * Hence\n * * The halfspace function evaluation for \"point\" (x,y,z) is `(x,y,z) DOT (u,v,w) - signedDistance`.\n * * POSITIVE values of the halfspace function are \"inside\".\n * * ZERO value of the halfspace function is \"on\".\n * * NEGATIVE value of the halfspace function is \"outside\".\n * * A representative point on the plane is (signedDistance * u, signedDistance * v, signedDistance * w).\n * * Given a point on the plane and the inward normal of the plane, `signedDistance = point DOT normal`.\n * @public\n */\nclass ClipPlane extends Plane3d {\n    constructor(normal, distance, invisible, interior) {\n        super();\n        this._invisible = invisible;\n        this._interior = interior;\n        this._inwardNormal = normal;\n        this._distanceFromOrigin = distance;\n    }\n    /*\n      private safeSetXYZDistance(nx: number, ny: number, nz: number, d: number) {\n        this._inwardNormal.set(nx, ny, nz);\n        this._distanceFromOrigin = d;\n      }\n    */\n    /**\n     * Return true if all members are almostEqual to corresponding members of other.\n     * @param other clip plane to compare\n     */\n    isAlmostEqual(other) {\n        return Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)\n            && this._inwardNormal.isAlmostEqual(other._inwardNormal)\n            && this._interior === other._interior\n            && this._invisible === other._invisible;\n    }\n    /** Return a cloned plane */\n    clone() {\n        const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\n        return result;\n    }\n    /** Return a cloned plane with coordinate data negated. */\n    cloneNegated() {\n        const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\n        plane.negateInPlace();\n        return plane;\n    }\n    /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */\n    static createPlane(plane, invisible = false, interior = false, result) {\n        const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());\n        if (result) {\n            result._invisible = invisible;\n            result._interior = interior;\n            result._inwardNormal = plane.getNormalRef().clone();\n            result._distanceFromOrigin = distance;\n            return result;\n        }\n        return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);\n    }\n    /**\n     * Create a ClipPlane with direct normal and signedDistance.\n     * * The vector is normalized for storage.\n     */\n    static createNormalAndDistance(normal, distance, invisible = false, interior = false, result) {\n        const normalized = normal.normalize();\n        if (normalized) {\n            if (result) {\n                result._invisible = invisible;\n                result._interior = interior;\n                result._inwardNormal = normalized;\n                result._distanceFromOrigin = distance;\n            }\n            return new ClipPlane(normalized, distance, invisible, interior);\n        }\n        return undefined;\n    }\n    /**\n     * Create a ClipPlane\n     * * \"normal\" is the inward normal of the plane (it is internally normalized).\n     * * \"point\" is any point of the plane.\n     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as\n     * a vector from the origin.)\n     */\n    static createNormalAndPoint(normal, point, invisible = false, interior = false, result) {\n        const normalized = normal.normalize();\n        if (normalized) {\n            const distance = normalized.dotProduct(point);\n            if (result) {\n                result._invisible = invisible;\n                result._interior = interior;\n                result._inwardNormal = normalized;\n                result._distanceFromOrigin = distance;\n            }\n            return new ClipPlane(normalized, distance, invisible, interior);\n        }\n        return undefined;\n    }\n    /**\n     * Create a clip plane\n     * @param origin any point on the plane.\n     * @param vectorA any vector in the plane\n     * @param vectorB any vector in the plane\n     * Returns undefined if the vectors are not independent.\n     * * The stored inward normal is vectorB.crossProduct(vectorA).\n     * * That is, the vectors are considered as a right-handed pair when viewed from the outside.\n     */\n    static createOriginAndVectors(origin, vectorA, vectorB, invisible = false, interior = false, result) {\n        const normalized = vectorB.crossProduct(vectorA);\n        return this.createNormalAndPoint(normalized, origin, invisible, interior, result);\n    }\n    /**\n     * Create a ClipPlane\n     * * \"normal\" (normalX, normalY, normalZ) is the inward normal of the plane.\n     * * \"point\" (originX,originY,originZ) is any point of the plane.\n     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz\n     * as a vector from the origin.)\n     */\n    static createNormalAndPointXYZXYZ(normalX, normalY, normalZ, originX, originY, originZ, invisible = false, interior = false, result) {\n        const q = Geometry.hypotenuseXYZ(normalX, normalY, normalZ);\n        const r = Geometry.conditionalDivideFraction(1, q);\n        if (r !== undefined) {\n            if (result) {\n                result._inwardNormal.set(normalX * r, normalY * r, normalZ * r);\n                result._distanceFromOrigin = result._inwardNormal.dotProductXYZ(originX, originY, originZ);\n                result._invisible = invisible;\n                result._interior = interior;\n                return result;\n            }\n            const normal = Vector3d.create(normalX * r, normalY * r, normalZ * r);\n            return new ClipPlane(normal, normal.dotProductXYZ(originX, originY, originZ), invisible, interior);\n        }\n        return undefined;\n    }\n    /**\n     * Return a json object of the form\n     * `{\"normal\":[u,v,w],\"dist\":signedDistanceValue,\"interior\":true,\"invisible\":true}`\n     */\n    toJSON() {\n        const props = {\n            normal: this.inwardNormalRef.toJSON(),\n            dist: this.distance,\n        };\n        if (this.interior)\n            props.interior = true;\n        if (this.invisible)\n            props.invisible = true;\n        return props;\n    }\n    /** Parse json object to ClipPlane instance */\n    static fromJSON(json, result) {\n        if (json && json.normal && undefined !== json.dist && Number.isFinite(json.dist))\n            return ClipPlane.createNormalAndDistance(Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);\n        return ClipPlane.createNormalAndDistance(Vector3d.unitZ(), 0, false, false, result);\n    }\n    /** Set both the invisible and interior flags. */\n    setFlags(invisible, interior) {\n        this._invisible = invisible;\n        this._interior = interior;\n    }\n    /** Return the stored distanceFromOrigin property. */\n    get distance() {\n        return this._distanceFromOrigin;\n    }\n    /** * Return the stored inward normal property. */\n    get inwardNormalRef() {\n        return this._inwardNormal;\n    }\n    /**  Return the \"interior\" property bit */\n    get interior() {\n        return this._interior;\n    }\n    /**  Return the \"invisible\" property bit. */\n    get invisible() {\n        return this._invisible;\n    }\n    /**\n     * Create a plane defined by two points, an up vector, and a tilt angle relative to the up vector.\n     * @param point0 start point of the edge\n     * @param point1 end point of the edge\n     * @param upVector vector perpendicular to the plane\n     * @param tiltAngle angle to tilt the plane around the edge in the direction of the up vector.\n     * @param result optional preallocated plane\n     */\n    static createEdgeAndUpVector(point0, point1, upVector, tiltAngle, result) {\n        const edgeVector = Vector3d.createFrom(point1.minus(point0));\n        let normal = (upVector.crossProduct(edgeVector)).normalize();\n        if (normal) {\n            if (tiltAngle !== undefined && !tiltAngle.isAlmostZero) {\n                const tiltNormal = Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);\n                if (tiltNormal) {\n                    normal = tiltNormal.clone();\n                }\n            }\n            normal.negate(normal);\n            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\n        }\n        return undefined;\n    }\n    /** Create a plane perpendicular to the edge between the xy parts of point0 and point1. */\n    static createEdgeXY(point0, point1, result) {\n        const normal = Vector3d.create(point0.y - point1.y, point1.x - point0.x);\n        if (normal.normalizeInPlace())\n            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\n        return undefined;\n    }\n    /**\n     * Return the Plane3d form of the plane.\n     * * The plane origin is the point `distance * inwardNormal`\n     * * The plane normal is the inward normal of the ClipPlane.\n     */\n    getPlane3d() {\n        const d = this._distanceFromOrigin;\n        // normal should be normalized, will not return undefined\n        return Plane3dByOriginAndUnitNormal.create(Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal);\n    }\n    /**\n     * Return the Point4d d form of the plane.\n     * * The homogeneous xyz are the inward normal xyz.\n     * * The homogeneous weight is the negated ClipPlane distance.\n     */\n    getPlane4d() {\n        return Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, -this._distanceFromOrigin);\n    }\n    /**\n     * Set the plane from DPoint4d style plane.\n     * * The saved plane has its direction normalized.\n     * * This preserves the plane itself as a zero set but make plane evaluations act as true distances (even if the\n     * plane coefficients are scaled otherwise).\n     * @param plane the DPoint4d style plane.\n     */\n    setPlane4d(plane) {\n        const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);\n        const r = a === 0.0 ? 1.0 : 1.0 / a;\n        this._inwardNormal.x = r * plane.x;\n        this._inwardNormal.y = r * plane.y;\n        this._inwardNormal.z = r * plane.z;\n        this._distanceFromOrigin = -r * plane.w;\n    }\n    /**\n     * Evaluate the altitude in weighted space, i.e. (dot product with inward normal) minus distance, with point.w\n     * scale applied to distance.\n     * @param point space point to test.\n     */\n    weightedAltitude(point) {\n        return point.x * this._inwardNormal.x\n            + point.y * this._inwardNormal.y\n            + point.z * this._inwardNormal.z\n            - point.w * this._distanceFromOrigin;\n    }\n    /**\n     * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance.\n     * @param point space point to test.\n     */\n    altitude(point) {\n        return point.x * this._inwardNormal.x\n            + point.y * this._inwardNormal.y\n            + point.z * this._inwardNormal.z\n            - this._distanceFromOrigin;\n    }\n    /**\n     * Evaluate the distance from the plane to a point in space with point given as x,y,z, i.e. (dot product with\n     * inward normal) minus distance.\n     * @param point space point to test.\n     */\n    altitudeXYZ(x, y, z) {\n        return x * this._inwardNormal.x\n            + y * this._inwardNormal.y\n            + z * this._inwardNormal.z\n            - this._distanceFromOrigin;\n    }\n    /** Return the x component of the normal used to evaluate altitude. */\n    normalX() {\n        return this._inwardNormal.x;\n    }\n    /** Return the x component of the normal used to evaluate altitude. */\n    normalY() {\n        return this._inwardNormal.y;\n    }\n    /** Return the z component of the normal used to evaluate altitude. */\n    normalZ() {\n        return this._inwardNormal.z;\n    }\n    /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin). */\n    velocity(vector) {\n        return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;\n    }\n    /**\n     * Return the dot product of the plane normal with the x,yz, vector components (NOT using the plane's\n     * distanceFromOrigin).\n     */\n    velocityXYZ(x, y, z) {\n        return x * this._inwardNormal.x + y * this._inwardNormal.y + z * this._inwardNormal.z;\n    }\n    /**\n     * Return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT\n     * using the plane's distanceFromOrigin).\n     */\n    dotProductPlaneNormalPoint(point) {\n        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;\n    }\n    /**\n     * Return true if spacePoint is inside or on the plane, with tolerance applied to \"on\".\n     * @param spacePoint point to test.\n     * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\n     */\n    isPointOnOrInside(spacePoint, tolerance = Geometry.smallMetricDistance) {\n        let value = this.altitude(spacePoint);\n        if (tolerance) {\n            value += tolerance;\n        }\n        return value >= 0.0;\n    }\n    /**\n     * Return true if spacePoint is strictly inside the halfspace, with tolerance applied to \"on\".\n     * @param spacePoint point to test.\n     * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\n     */\n    isPointInside(point, tolerance = Geometry.smallMetricDistance) {\n        let value = this.altitude(point);\n        if (tolerance) {\n            value -= tolerance;\n        }\n        return value > 0.0;\n    }\n    /**\n     * Return true if spacePoint is strictly on the plane, within tolerance\n     * @param spacePoint point to test.\n     * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\n     */\n    isPointOn(point, tolerance = Geometry.smallMetricDistance) {\n        return Math.abs(this.altitude(point)) <= tolerance;\n    }\n    /**\n     * Compute intersections of an (UNBOUNDED) arc with the plane.  Append them (as radians) to a growing array.\n     * @param arc arc to test.  The angle limits of the arc are NOT considered.\n     * @param intersectionRadians array to receive results\n     */\n    appendIntersectionRadians(arc, intersectionRadians) {\n        const arcVectors = arc.toVectors();\n        const alpha = this.altitude(arc.center);\n        const beta = this.velocity(arcVectors.vector0);\n        const gamma = this.velocity(arcVectors.vector90);\n        AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);\n    }\n    /**\n     * Announce fractional intervals of arc clip.\n     * * Each call to `announce(fraction0, fraction1, arc)` announces one interval that is inside the clip plane.\n     */\n    announceClippedArcIntervals(arc, announce) {\n        const breaks = ClipPlane._clipArcFractionArray;\n        breaks.clear();\n        this.appendIntersectionRadians(arc, breaks);\n        arc.sweep.radiansArrayToPositivePeriodicFractions(breaks);\n        return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\n    }\n    /**\n     * Compute intersection of (unbounded) segment with the plane.\n     * * If the ends are on the same side of the plane, return undefined.\n     * * If the intersection is an endpoint or interior to the segment return the fraction.\n     * * If both ends are on, return undefined.\n     */\n    getBoundedSegmentSimpleIntersection(pointA, pointB) {\n        const h0 = this.altitude(pointA);\n        const h1 = this.altitude(pointB);\n        if (h0 * h1 > 0.0)\n            return undefined;\n        if (h0 === 0.0 && h1 === 0.0) {\n            return undefined;\n        }\n        return -h0 / (h1 - h0);\n    }\n    /** Apply transform to the origin. Apply inverse transpose of the matrix part to th normal vector. */\n    transformInPlace(transform) {\n        const plane = this.getPlane3d();\n        const matrix = transform.matrix;\n        const newPoint = transform.multiplyPoint3d(plane.getOriginRef());\n        // Normal transforms as the inverse transpose of the matrix part\n        // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)\n        const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());\n        if (!newNormal)\n            return false;\n        plane.set(newPoint, newNormal);\n        const normalized = (plane.getNormalRef()).normalize();\n        if (!normalized)\n            return false;\n        this._inwardNormal = normalized;\n        this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());\n        return true;\n    }\n    /** Set the invisible flag. Interpretation of this is up to the use code algorithms. */\n    setInvisible(invisible) {\n        this._invisible = invisible;\n    }\n    /** Reverse the sign of all coefficients, so outside and inside reverse */\n    negateInPlace() {\n        this._inwardNormal = this._inwardNormal.negate();\n        this._distanceFromOrigin = -this._distanceFromOrigin;\n    }\n    /**\n     * Move the plane INWARD by given distance\n     * @param offset distance of shift inwards\n     */\n    offsetDistance(offset) {\n        this._distanceFromOrigin += offset;\n    }\n    /**\n     * Clip a polygon to the inside or outside of the plane.\n     * * Results with 2 or fewer points are ignored.\n     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\n     * @param xyz input points.\n     * @param work work buffer\n     * @param tolerance tolerance for \"on plane\" decision.\n     */\n    clipConvexPolygonInPlace(xyz, work, inside = true, tolerance = Geometry.smallMetricDistance) {\n        return IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(this, xyz, work, inside, tolerance);\n    }\n    /**\n     * Multiply the ClipPlane's DPoint4d by matrix.\n     * @param matrix matrix to apply.\n     * @param invert if true, use in verse of the matrix.\n     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\n     * @param matrix matrix to apply\n     * @return false if unable to invert\n     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding\n     * effect on the plane is the inverse transpose of matrixA\n     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\n     * * Both params default to true to get the full effect of transforming space.\n     */\n    multiplyPlaneByMatrix4d(matrix, invert = true, transpose = true) {\n        const plane = this.getPlane4d();\n        if (invert) {\n            const inverse = matrix.createInverse();\n            if (inverse)\n                return this.multiplyPlaneByMatrix4d(inverse, false, transpose);\n            return false;\n        }\n        if (transpose)\n            matrix.multiplyTransposePoint4d(plane, plane);\n        else\n            matrix.multiplyPoint4d(plane, plane);\n        this.setPlane4d(plane);\n        return true;\n    }\n    /** Announce the interval (if any) where a line is within the clip plane half space. */\n    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {\n        if (f1 < f0)\n            return false;\n        const h0 = -this.altitude(pointA);\n        const h1 = -this.altitude(pointB);\n        const delta = h1 - h0;\n        const f = Geometry.conditionalDivideFraction(-h0, delta);\n        if (f === undefined) { // The segment is parallel to the plane.\n            if (h0 <= 0.0) {\n                if (announce)\n                    announce(f0, f1);\n                return true;\n            }\n            return false;\n        }\n        if (delta > 0) { // segment aims OUT\n            if (f < f1)\n                f1 = f;\n        }\n        else {\n            // segment aims IN\n            if (f > f0)\n                f0 = f;\n        }\n        if (f1 < f0)\n            return false;\n        if (announce)\n            announce(f0, f1);\n        return true;\n    }\n    /**\n     * Return a coordinate frame with\n     * * origin at closest point to global origin\n     * * z axis points in\n     * * x and y are \"in plane\"\n     */\n    getFrame() {\n        const d = this._distanceFromOrigin;\n        const origin = Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d);\n        const matrix = Matrix3d.createRigidHeadsUp(this._inwardNormal, AxisOrder.ZXY);\n        return Transform.createOriginAndMatrix(origin, matrix);\n    }\n    /**\n     * Return the intersection of the plane with a range cube.\n     * @param range\n     * @param xyzOut intersection polygon.  This is convex.\n     */\n    intersectRange(range, addClosurePoint = false) {\n        if (range.isNull)\n            return undefined;\n        const corners = range.corners();\n        const frameOnPlane = this.getFrame();\n        frameOnPlane.multiplyInversePoint3dArrayInPlace(corners);\n        const localRange = Range3d.createArray(corners);\n        if (localRange.low.z * localRange.high.z > 0.0)\n            return undefined;\n        // oversized polygon on local z= 0\n        const xyzOut = new GrowableXYZArray();\n        xyzOut.pushXYZ(localRange.low.x, localRange.low.y, 0);\n        xyzOut.pushXYZ(localRange.high.x, localRange.low.y, 0);\n        xyzOut.pushXYZ(localRange.high.x, localRange.high.y, 0);\n        xyzOut.pushXYZ(localRange.low.x, localRange.high.y, 0);\n        xyzOut.multiplyTransformInPlace(frameOnPlane);\n        IndexedXYZCollectionPolygonOps.intersectRangeConvexPolygonInPlace(range, xyzOut);\n        if (xyzOut.length === 0)\n            return undefined;\n        if (addClosurePoint)\n            xyzOut.pushWrap(1);\n        return xyzOut;\n    }\n    /**\n     * Implement appendPolygonClip, as defined in interface PolygonClipper.\n     * @param xyz convex polygon. This is not changed.\n     * @param insideFragments Array to receive \"inside\" fragments. Each fragment is a GrowableXYZArray grabbed\n     * from the cache. This is NOT cleared.\n     * @param outsideFragments Array to receive \"outside\" fragments. Each fragment is a GrowableXYZArray grabbed\n     * from the cache. This is NOT cleared.\n     * @param arrayCache cache for reusable GrowableXYZArray.\n     */\n    appendPolygonClip(xyz, insideFragments, outsideFragments, arrayCache) {\n        const perpendicularRange = Range1d.createNull();\n        const newInside = arrayCache.grabFromCache();\n        const newOutside = arrayCache.grabFromCache();\n        IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(this, xyz, newInside, newOutside, perpendicularRange);\n        ClipUtilities.captureOrDrop(newInside, 3, insideFragments, arrayCache);\n        ClipUtilities.captureOrDrop(newOutside, 3, outsideFragments, arrayCache);\n    }\n    /** Project a point in space to the plane. */\n    projectPointToPlane(spacePoint, result) {\n        const d = -this.altitude(spacePoint);\n        return spacePoint.plusXYZ(d * this._inwardNormal.x, d * this._inwardNormal.y, d * this._inwardNormal.z, result);\n    }\n}\nClipPlane._clipArcFractionArray = new GrowableFloat64Array();\nexport { ClipPlane };\n//# sourceMappingURL=ClipPlane.js.map",
      "start": 1693508123334,
      "end": 1693508123491,
      "sourcemaps": null
    }
  ]
}
