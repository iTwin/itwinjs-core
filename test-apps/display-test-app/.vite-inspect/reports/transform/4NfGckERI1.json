{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveExtendMode.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\n/** module Curve */\n/** enumeration of condition for extending a curve beyond start or end point.\n * * Not all CurvePrimitives support these modes.\n * @public\n */\nexport var CurveExtendMode;\n(function (CurveExtendMode) {\n    /** No extension allowed. */\n    CurveExtendMode[CurveExtendMode[\"None\"] = 0] = \"None\";\n    /** Extend along continuation of the end tangent */\n    CurveExtendMode[CurveExtendMode[\"OnTangent\"] = 1] = \"OnTangent\";\n    /** Extend along continuation of the curve. */\n    CurveExtendMode[CurveExtendMode[\"OnCurve\"] = 2] = \"OnCurve\";\n})(CurveExtendMode || (CurveExtendMode = {}));\n/** Logic for deciding how a curve may be extended for closest point or intersection searches.\n * @public\n */\nexport class CurveExtendOptions {\n    /** Given an ExtendParameter, isolate the particular CurveExtendOptions in effect at an end.\n     * * Return undefined if `param === false`\n     * * return the (strongly typed) pointer to the param if it is a single CurveExtendOptions.\n     * * Return dereferenced array entry 0 or 1 if the param is an array of CurveExtendOptions.\n     */\n    static resolveVariantCurveExtendParameterToCurveExtendMode(param, endIndex) {\n        if (param === false)\n            return CurveExtendMode.None;\n        if (param === true)\n            return CurveExtendMode.OnCurve;\n        if (Array.isArray(param))\n            return param[endIndex];\n        return param;\n    }\n    /**\n     *\n     * * if fraction is between 0 and 1 return it unchanged.\n     * * if fraction is less than 0 use the variant param to choose the fraction or 0\n     * * if fraction is greater than 1 use the variant param to choose the fraction or 1\n     *\n     */\n    static correctFraction(extendParam, fraction) {\n        if (fraction < 0) {\n            const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);\n            if (mode === CurveExtendMode.None)\n                fraction = 0.0;\n        }\n        else if (fraction > 1.0) {\n            const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);\n            if (mode === CurveExtendMode.None)\n                fraction = 1.0;\n        }\n        return fraction;\n    }\n    /**\n     * Adjust a radians value to an angle sweep, allowing the extendParam to affect choice among periodic fractions.\n     * * if radians is within the sweep, convert it to a fraction of the sweep.\n     * * if radians is outside, use the extendParam to choose among:\n     *    * fraction below 0\n     *    * fraction above 1\n     */\n    static resolveRadiansToSweepFraction(extendParam, radians, sweep) {\n        let fraction = sweep.radiansToSignedPeriodicFraction(radians);\n        if (!sweep.isRadiansInSweep(radians)) {\n            const fractionPeriod = sweep.fractionPeriod();\n            const mode0 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);\n            const mode1 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);\n            if (mode0 !== CurveExtendMode.None) {\n                if (mode1 !== CurveExtendMode.None) {\n                    // both extensions possible ... let the sweep resolve to the \"closer\" end\n                    fraction = sweep.radiansToSignedPeriodicFraction(radians);\n                }\n                else {\n                    // only extend to negative .....\n                    if (fraction > 1.0)\n                        fraction -= fractionPeriod;\n                }\n            }\n            else if (mode1 !== CurveExtendMode.None) {\n                if (fraction < 0.0)\n                    fraction += fractionPeriod;\n            }\n            else { // both clamped !!!!\n                fraction = Geometry.clamp(fraction, 0, 1);\n            }\n        }\n        return fraction;\n    }\n}\n//# sourceMappingURL=CurveExtendMode.js.map",
      "start": 1693508123555,
      "end": 1693508123714,
      "sourcemaps": null
    }
  ]
}
