{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/Bezier1dNd.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\nimport { KnotVector } from \"./KnotVector\";\n/**\n * Shared implementation details for derived bezier curve classes\n * * BezierCurve3d implements with blockSize 3.\n * * BezierCurve3dH implements with blockSize 4.\n * @public\n */\nexport class Bezier1dNd {\n    // constructor CAPTURES the control points array.\n    constructor(blockSize, polygon) {\n        this._blockSize = blockSize;\n        this._order = Math.floor(polygon.length / blockSize); // This should be an integer!!!\n        this._packedData = polygon;\n        this._basis = new UnivariateBezier(this._order);\n    }\n    /** return a clone of the data array */\n    clonePolygon(result) {\n        const n = this._packedData.length;\n        if (!result || result.length !== n)\n            return this._packedData.slice();\n        /** move data into the supplied result */\n        for (let i = 0; i < n; i++)\n            result[i] = this._packedData[i];\n        return result;\n    }\n    /** Return the bezier order */\n    get order() { return this._order; }\n    /** return the packed data array.  This is a REFERENCE to the array. */\n    get packedData() { return this._packedData; }\n    /** Create a Bezier1dNd, using the structure of `data[0]` to determine the bezier order. */\n    static create(data) {\n        if (data.length < 1)\n            return undefined;\n        if (data[0] instanceof Point3d) {\n            const polygon = new Float64Array(data.length * 3);\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = p.z;\n            }\n            return new Bezier1dNd(3, polygon);\n        }\n        else if (data[0] instanceof Point4d) {\n            const polygon = new Float64Array(data.length * 4);\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = p.z;\n                polygon[i++] = p.w;\n            }\n            return new Bezier1dNd(4, polygon);\n        }\n        else if (data[0] instanceof Point2d) {\n            const polygon = new Float64Array(data.length * 2);\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n            }\n            return new Bezier1dNd(2, polygon);\n        }\n        return undefined;\n    }\n    /** Return the curve value at bezier fraction `s`\n     * @return buffer of length `blockSize`.\n     */\n    evaluate(s, buffer) {\n        return this._basis.sumBasisFunctions(s, this._packedData, this._blockSize, buffer);\n    }\n    /** Return the curve derivative value at bezier fraction `s`\n     * @return buffer of length `blockSize`.\n     */\n    evaluateDerivative(s, buffer) {\n        return this._basis.sumBasisFunctionDerivatives(s, this._packedData, this._blockSize, buffer);\n    }\n    /** get a single point of the polygon as a simple array.  */\n    getPolygonPoint(i, buffer) {\n        if (!buffer)\n            buffer = new Float64Array(this._blockSize);\n        if (i >= 0 && i < this._order) {\n            const k0 = this._blockSize * i;\n            for (let k = 0; k < this._blockSize; k++)\n                buffer[k] = this._packedData[k0 + k];\n            return buffer;\n        }\n        return undefined;\n    }\n    /** set a single point of the polygon as a simple array.  */\n    setPolygonPoint(i, buffer) {\n        if (i >= 0 && i < this._order) {\n            const k0 = this._blockSize * i;\n            for (let k = 0; k < this._blockSize; k++)\n                this._packedData[k0 + k] = buffer[k];\n        }\n    }\n    /** Load order * dimension doubles from data[dimension * spanIndex] as poles\n     * @param data packed source array.  block size in `data` assumed to match dimension for this.\n     * @param spanIndex block index in data.\n     */\n    loadSpanPoles(data, spanIndex) {\n        let k = spanIndex * this._blockSize;\n        for (let i = 0; i < this._packedData.length; i++)\n            this._packedData[i] = data[k++];\n    }\n    /** Load order * (dataDimension + 1)  doubles from data[dataDimension * spanIndex] as poles with weight inserted\n     * @param data packed array of data.\n     * @param dataDimension dimension of data. Must have `dataDimension+1=this.order`\n     * @param spanIndex index of first data block to access.\n     * @param weight weight to append to each block\n     */\n    loadSpanPolesWithWeight(data, dataDimension, spanIndex, weight) {\n        let destIndex = 0;\n        const order = this._order;\n        let dataIndex = spanIndex * dataDimension;\n        for (let i = 0; i < order; i++) {\n            for (let j = 0; j < dataDimension; j++)\n                this._packedData[destIndex++] = data[dataIndex++];\n            this._packedData[destIndex++] = weight;\n        }\n    }\n    /**  return a json array of arrays with each control point as a lower level array of numbers */\n    unpackToJsonArrays() {\n        return Point3dArray.unpackNumbersToNestedArrays(this._packedData, this._blockSize);\n    }\n    /** equality test with usual metric tolerances */\n    isAlmostEqual(other) {\n        if (other instanceof Bezier1dNd) {\n            if (this._blockSize !== other._blockSize)\n                return false;\n            if (this._order !== other._order)\n                return false;\n            if (this._packedData.length !== other._packedData.length)\n                return false;\n            for (let i = 0; i < this._packedData.length; i++) {\n                if (!Geometry.isSameCoordinate(this._packedData[i], other._packedData[i]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /** block-by-block reversal */\n    reverseInPlace() {\n        const m = this._blockSize;\n        const n = this._order;\n        let i, j;\n        let a;\n        for (i = 0, j = (n - 1) * m; i < j; i += m, j -= m) {\n            for (let k = 0; k < m; k++) {\n                a = this._packedData[i + k];\n                this._packedData[i + k] = this._packedData[j + k];\n                this._packedData[j + k] = a;\n            }\n        }\n    }\n    /**\n     * interpolate at `fraction` between poleA and poleB.\n     * * Data is left \"in place\" in poleIndexA\n     * @param poleIndexA first pole index\n     * @param fraction fractional position\n     * @param poleIndexB second pole index\n     */\n    interpolatePoleInPlace(poleIndexA, fraction, poleIndexB) {\n        let i0 = poleIndexA * this._blockSize;\n        let i1 = poleIndexB * this._blockSize;\n        const data = this._packedData;\n        for (let i = 0; i < this._blockSize; i++, i0++, i1++) {\n            data[i0] += fraction * (data[i1] - data[i0]);\n        }\n    }\n    /**\n     * Compute new control points to \"clamp\" bspline unsaturated support to saturated form.\n     * * At input time, the control points are associated with the input knots (unsaturated)\n     * * At output, the control points are modified by repeated knot insertion to be fully clamped.\n     * @param knots knot values for the current (unsaturated) pole set\n     * @param spanIndex index of span whose (unsaturated) poles are in the bezier.\n     */\n    saturateInPlace(knots, spanIndex) {\n        const degree = knots.degree;\n        const kA = spanIndex + degree - 1; // left knot index of the active span\n        const kB = kA + 1;\n        if (spanIndex < 0 || spanIndex >= knots.numSpans)\n            return false;\n        const knotArray = knots.knots;\n        const knotA = knotArray[kA];\n        const knotB = knotArray[kB];\n        this.setInterval(knotA, knotB);\n        if (knotB <= knotA + KnotVector.knotTolerance)\n            return false;\n        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\n            //  left numInsert poles are pulled forward\n            let k0 = kA - numInsert;\n            if (knotArray[k0] < knotA) {\n                let k1 = kB;\n                for (let i = 0; i < numInsert; i++, k0++, k1++) {\n                    const knot0 = knotArray[k0];\n                    const knot1 = knotArray[k1];\n                    const fraction = (knotA - knot0) / (knot1 - knot0);\n                    this.interpolatePoleInPlace(i, fraction, i + 1);\n                }\n            }\n        }\n        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\n            let k2 = kB + numInsert;\n            if (knotArray[k2] > knotB) {\n                for (let i = 0; i < numInsert; i++, k2--) {\n                    const knot2 = knotArray[k2]; // right side of moving window\n                    // left side of window ia always the (previously saturated) knotA\n                    const fraction = (knotB - knot2) / (knotA - knot2);\n                    this.interpolatePoleInPlace(degree - i, fraction, degree - i - 1);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Saturate a univariate bspline coefficient array in place\n     * * On input, the array is the coefficients of one span of a bspline, packed in an array of `(knots.order)` values.\n     * * These are modified in place, and on return are a bezier for the same knot interval.\n     * @param coffs input as bspline coefficients, returned as bezier coefficients\n     * @param knots knot vector\n     * @param spanIndex index of span whose (unsaturated) poles are in the coefficients.\n     */\n    static saturate1dInPlace(coffs, knots, spanIndex) {\n        const degree = knots.degree;\n        const kA = spanIndex + degree - 1; // left knot index of the active span\n        const kB = kA + 1;\n        if (spanIndex < 0 || spanIndex >= knots.numSpans)\n            return false;\n        const knotArray = knots.knots;\n        const knotA = knotArray[kA];\n        const knotB = knotArray[kB];\n        if (knotB <= knotA + KnotVector.knotTolerance)\n            return false;\n        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\n            //  left numInsert poles are pulled forward\n            let k0 = kA - numInsert;\n            if (knotArray[k0] < knotA) {\n                let k1 = kB;\n                for (let i = 0; i < numInsert; i++, k0++, k1++) {\n                    const knot0 = knotArray[k0];\n                    const knot1 = knotArray[k1];\n                    const fraction = (knotA - knot0) / (knot1 - knot0);\n                    coffs[i] = coffs[i] + fraction * (coffs[i + 1] - coffs[i]);\n                }\n            }\n        }\n        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\n            let k2 = kB + numInsert;\n            let k;\n            if (knotArray[k2] > knotB) {\n                for (let i = 0; i < numInsert; i++, k2--) {\n                    const knot2 = knotArray[k2]; // right side of moving window\n                    // left side of window is always the (previously saturated) knotA\n                    const fraction = (knotB - knot2) / (knotA - knot2);\n                    k = degree - i;\n                    coffs[k] += fraction * (coffs[k - 1] - coffs[k]);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Apply deCasteljau interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original\n     * @param fraction \"end\" fraction for split.\n     * @returns false if fraction is 0 or 1 -- no changes applied.\n     */\n    subdivideInPlaceKeepLeft(fraction) {\n        if (Geometry.isAlmostEqualNumber(fraction, 1.0))\n            return true;\n        if (Geometry.isAlmostEqualNumber(fraction, 0.0))\n            return false;\n        const g = 1.0 - fraction; // interpolations will pull towards right indices\n        const order = this.order;\n        for (let level = 1; level < order; level++) {\n            for (let i1 = order - 1; i1 >= level; i1--) {\n                this.interpolatePoleInPlace(i1, g, i1 - 1); // leave updates to right\n            }\n        }\n        return true;\n    }\n    /**\n     * Apply deCasteljau interpolations to isolate a smaller bezier polygon, representing interval fraction..1 of the original\n     * @param fraction \"start\" fraction for split.\n     * @returns false if fraction is 0 or 1 -- no changes applied.\n     */\n    subdivideInPlaceKeepRight(fraction) {\n        if (Geometry.isAlmostEqualNumber(fraction, 0.0))\n            return true;\n        if (Geometry.isAlmostEqualNumber(fraction, 1.0))\n            return false;\n        const order = this.order;\n        for (let level = 1; level < order; level++) {\n            for (let i0 = 0; i0 + level < order; i0++)\n                this.interpolatePoleInPlace(i0, fraction, i0 + 1); // leave updates to left.\n        }\n        return true;\n    }\n    /**\n     * Saturate a univariate bspline coefficient array in place\n     * @param fraction0 fraction for first split.   This is the start of the output polygon\n     * @param fraction1 fraction for second split.   This is the end of the output polygon\n     * @return false if fractions are (almost) identical.\n     */\n    subdivideToIntervalInPlace(fraction0, fraction1) {\n        if (Geometry.isAlmostEqualNumber(fraction0, fraction1))\n            return false;\n        if (fraction1 < fraction0) {\n            this.subdivideToIntervalInPlace(fraction1, fraction0);\n            this.reverseInPlace();\n            return true;\n        }\n        this.subdivideInPlaceKeepLeft(fraction1);\n        this.subdivideInPlaceKeepRight(fraction0 / fraction1);\n        return true;\n    }\n    /** create or update the mapping to parent curve. */\n    setInterval(a, b) {\n        this.interval = Segment1d.create(a, b, this.interval);\n    }\n    /** map a fraction to the parent space. */\n    fractionToParentFraction(fraction) { return this.interval ? this.interval.fractionToPoint(fraction) : fraction; }\n}\n//# sourceMappingURL=Bezier1dNd.js.map",
      "start": 1693508123816,
      "end": 1693508123940,
      "sourcemaps": null
    }
  ]
}
