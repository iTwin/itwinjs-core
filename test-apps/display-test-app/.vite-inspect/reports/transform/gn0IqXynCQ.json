{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry4d/Map4d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Numerics\n */\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { Matrix4d } from \"./Matrix4d\";\n/** Map4 carries two Matrix4d which are inverses of each other.\n * @public\n */\nexport class Map4d {\n    constructor(matrix0, matrix1) {\n        this._matrix0 = matrix0;\n        this._matrix1 = matrix1;\n    }\n    /** Return a reference to (not copy of) the \"forward\" Matrix4d */\n    get transform0() { return this._matrix0; }\n    /** Return a reference to (not copy of) the \"reverse\" Matrix4d */\n    get transform1() { return this._matrix1; }\n    /** Create a Map4d, capturing the references to the two matrices. */\n    static createRefs(matrix0, matrix1) {\n        return new Map4d(matrix0, matrix1);\n    }\n    /** Create an identity map. */\n    static createIdentity() { return new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity()); }\n    /** Create a Map4d with given transform pair.\n     * @returns undefined if the transforms are not inverses of each other.\n     */\n    static createTransform(transform0, transform1) {\n        if (transform1 === undefined) {\n            transform1 = transform0.inverse();\n            if (transform1 === undefined)\n                return undefined;\n        }\n        else {\n            const product = transform0.multiplyTransformTransform(transform1);\n            if (!product.isIdentity)\n                return undefined;\n        }\n        return new Map4d(Matrix4d.createTransform(transform0), Matrix4d.createTransform(transform1));\n    }\n    /**\n     * Create a mapping the scales and translates (no rotation) between boxes.\n     * @param lowA low point of box A\n     * @param highA high point of box A\n     * @param lowB low point of box B\n     * @param highB high point of box B\n     */\n    static createBoxMap(lowA, highA, lowB, highB, result) {\n        const t0 = Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);\n        const t1 = Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);\n        if (t0 && t1) {\n            if (result)\n                return result;\n            return new Map4d(t0, t1);\n        }\n        return undefined;\n    }\n    /** Copy contents from another Map4d */\n    setFrom(other) { this._matrix0.setFrom(other._matrix0), this._matrix1.setFrom(other._matrix1); }\n    /** Return a clone of this Map4d */\n    clone() { return new Map4d(this._matrix0.clone(), this._matrix1.clone()); }\n    /** Reinitialize this Map4d as an identity. */\n    setIdentity() { this._matrix0.setIdentity(); this._matrix1.setIdentity(); }\n    /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\n    setFromJSON(json) {\n        if (json.matrix0 && json.matrix1) {\n            this._matrix0.setFromJSON(json.matrix0);\n            this._matrix1.setFromJSON(json.matrix1);\n        }\n        else\n            this.setIdentity();\n    }\n    /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\n    static fromJSON(json) {\n        const result = new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity());\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Return a json object `{matrix0: value0, matrix1: value1}` */\n    toJSON() { return { matrix0: this._matrix0.toJSON(), matrix1: this._matrix1.toJSON() }; }\n    /** Test if both matrices are almost equal to those */\n    isAlmostEqual(other) {\n        return this._matrix0.isAlmostEqual(other._matrix0) && this._matrix1.isAlmostEqual(other._matrix1);\n    }\n    /** Create a map between a frustum and world coordinates.\n     * @param origin lower left of frustum\n     * @param uVector Vector from lower left rear to lower right rear\n     * @param vVector Vector from lower left rear to upper left rear\n     * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.\n     * @param fraction front size divided by rear size.\n     */\n    static createVectorFrustum(origin, uVector, vVector, wVector, fraction) {\n        fraction = Math.max(fraction, 1.0e-8);\n        const slabToWorld = Transform.createOriginAndMatrix(origin, Matrix3d.createColumns(uVector, vVector, wVector));\n        const worldToSlab = slabToWorld.inverse();\n        if (!worldToSlab)\n            return undefined;\n        const worldToSlabMap = new Map4d(Matrix4d.createTransform(worldToSlab), Matrix4d.createTransform(slabToWorld));\n        const slabToNPCMap = new Map4d(Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));\n        const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);\n        /*\n        let numIdentity = 0;\n        const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);\n        if (productA.isIdentity())\n          numIdentity++;\n        const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);\n        if (productB.isIdentity())\n          numIdentity++;\n        const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);\n        if (product.isIdentity())\n          numIdentity++;\n        if (numIdentity === 3)\n            return result;\n          */\n        return result;\n    }\n    /** multiply this*other. The output matrices are\n     * * output matrix0 = `this.matrix0 * other.matrix0`\n     * * output matrix1 = 'other.matrix1 * this.matrix1`\n     */\n    multiplyMapMap(other) {\n        return new Map4d(this._matrix0.multiplyMatrixMatrix(other._matrix0), other._matrix1.multiplyMatrixMatrix(this._matrix1));\n    }\n    /** Exchange the two matrices of the map. */\n    reverseInPlace() {\n        const temp = this._matrix0;\n        this._matrix0 = this._matrix1;\n        this._matrix1 = temp;\n    }\n    /** return a Map4d whose transform0 is\n     * other.transform0 * this.transform0 * other.transform1\n     */\n    sandwich0This1(other) {\n        return new Map4d(other._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix1)), other._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix1)));\n    }\n    /** return a Map4d whose transform0 is\n     * other.transform1 * this.transform0 * other.transform0\n     */\n    sandwich1This0(other) {\n        return new Map4d(other._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix0)), other._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix0)));\n    }\n} // Map4d\n//# sourceMappingURL=Map4d.js.map",
      "start": 1693508123443,
      "end": 1693508123585,
      "sourcemaps": null
    }
  ]
}
