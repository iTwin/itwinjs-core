{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/FeatureIndex.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { ColorDef } from \"./ColorDef\";\n/** As part of a [[ColorIndex]], describes per-vertex colors for a [MeshArgs]($frontend) or [PolylineArgs]($frontend).\n * The [[colors]] array holds the set of unique colors. The [[indices]] array describes the color of each vertex as an index into [[colors]].\n * @note A `NonUniformColor` table cannot contain a mix of opaque and translucent colors. If any color in [[colors]] has a transparency greater\n * than zero, all of them must have a transparency greater than zero.\n * @public\n */\nexport class NonUniformColor {\n    /** Constructor.\n     * @param colors See [[colors]].\n     * @param indices See [[indices]]\n     * @param hasAlpha `true` if all `colors` have a transparency greater than zero, or `false` if they all have a transparency of zero.\n     */\n    constructor(colors, indices, hasAlpha) {\n        this.colors = new Uint32Array(colors.buffer);\n        this.indices = Uint16Array.from(indices);\n        this.isOpaque = !hasAlpha;\n    }\n}\n/** Describes the color(s) of the vertices of a [MeshArgs]($frontend) or [PolylineArgs]($frontend).\n * This may be a uniform color to be applied to every vertex, or a table specifying individual per-vertex colors.\n * @public\n */\nexport class ColorIndex {\n    /** Whether the color(s) in this index have transparency. */\n    get hasAlpha() { return !this._color.isOpaque; }\n    /** Whether this index specifies a single uniform color for the entire mesh or polyline. */\n    get isUniform() { return this._color instanceof ColorDef; }\n    /** The number of colors in this index. */\n    get numColors() { return this.isUniform ? 1 : this.nonUniform.colors.length; }\n    /** Construct a default index specifying a uniform white color. */\n    constructor() { this._color = ColorDef.white; }\n    /** Reset this index to specify a uniform white color. */\n    reset() { this._color = ColorDef.white; }\n    /** Returns the single color to be applied to all vertices, if [[isUniform]] is `true`; or `undefined` otherwise. */\n    get uniform() {\n        return this.isUniform ? this._color : undefined;\n    }\n    /** Set the specified color to be applied to all vertices. */\n    initUniform(color) {\n        this._color = typeof color === \"number\" ? ColorDef.fromJSON(color) : color;\n    }\n    /** Returns the per-vertex colors, if [[isUniform]] is `false`; or `undefined` otherwise. */\n    get nonUniform() {\n        return !this.isUniform ? this._color : undefined;\n    }\n    /** Set the per-vertex colors.\n     * @param colors See [[NonUniformColor.colors]].\n     * @param indices See [[NonUniformColor.indices]].\n     * @param hasAlpha `true` if all `colors` have a transparency greater than zero, or `false` if they all have a transparency of zero.\n     */\n    initNonUniform(colors, indices, hasAlpha) {\n        this._color = new NonUniformColor(colors, indices, hasAlpha);\n    }\n}\n/** Describes the type of a [[FeatureIndex]].\n * @public\n */\nexport var FeatureIndexType;\n(function (FeatureIndexType) {\n    /** Indicates that the index contains no features. */\n    FeatureIndexType[FeatureIndexType[\"Empty\"] = 0] = \"Empty\";\n    /** Indicates that the index contains exactly one feature. */\n    FeatureIndexType[FeatureIndexType[\"Uniform\"] = 1] = \"Uniform\";\n    /** Indicates that the index contains more than one feature. */\n    FeatureIndexType[FeatureIndexType[\"NonUniform\"] = 2] = \"NonUniform\";\n})(FeatureIndexType || (FeatureIndexType = {}));\n/** Describes the set of [[Feature]]s associated with a [MeshArgs]($frontend) or [PolylineArgs]($frontend).\n * The mesh or polyline may have zero or one features; or, individual vertices may be associated with different features.\n * The features are expressed as unsigned 32-bit integer Ids of [[Feature]]s within a [[FeatureTable]].\n * @public\n */\nexport class FeatureIndex {\n    constructor() {\n        /** Describes the quantity (zero, one, or more than one) of features in this index. */\n        this.type = FeatureIndexType.Empty;\n        /** If [[type]] is [[FeatureIndexType.Uniform]], the Id of the single feature. */\n        this.featureID = 0;\n    }\n    /** True if [[type]] is [[FeatureIndexType.Uniform]]. */\n    get isUniform() { return FeatureIndexType.Uniform === this.type; }\n    /** True if [[type]] is [[FeatureIndexType.Empty]]. */\n    get isEmpty() { return FeatureIndexType.Empty === this.type; }\n    /** Reset to an empty index. */\n    reset() {\n        this.type = FeatureIndexType.Empty;\n        this.featureID = 0;\n        this.featureIDs = undefined;\n    }\n}\n//# sourceMappingURL=FeatureIndex.js.map",
      "start": 1693508120727,
      "end": 1693508120798,
      "sourcemaps": null
    }
  ]
}
