{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcOperation.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { BentleyStatus } from \"@itwin/core-bentley\";\nimport { IModelError } from \"../../IModelError\";\nimport { RpcResponseCacheControl } from \"./RpcConstants\";\nimport { OPERATION, POLICY, RpcRegistry } from \"./RpcRegistry\";\n/* eslint-disable deprecation/deprecation */\n/** The policy for an RPC operation.\n * @internal\n */\nexport class RpcOperationPolicy {\n    constructor() {\n        /** Supplies the IModelRpcProps for an operation request. */\n        this.token = (request) => request.findTokenPropsParameter();\n        /** Supplies the initial retry interval for an operation request. */\n        this.retryInterval = (configuration) => configuration.pendingOperationRetryInterval;\n        /** Called before every operation request on the frontend is sent. */\n        this.requestCallback = (_request) => { };\n        /** Called after every operation request on the frontend is sent. */\n        this.sentCallback = (_request) => { };\n        /**\n         * Determines if caching is permitted for an operation response.\n         * @note Not all RPC protocols support caching.\n         */\n        this.allowResponseCaching = (_request) => RpcResponseCacheControl.None;\n        /** Forces RpcConfiguration.strictMode for this operation. */\n        this.forceStrictMode = false;\n        /** Whether the IModelRpcProps in the operation parameter list is allowed to differ from the token in the request URL. */\n        this.allowTokenMismatch = false;\n        /** Whether to compress the operation response with one of the client's supported encodings. */\n        this.allowResponseCompression = false;\n    }\n}\n/** An RPC operation descriptor.\n * @internal\n */\nclass RpcOperation {\n    /** Looks up an RPC operation by name. */\n    static lookup(target, operationName) {\n        const definition = typeof (target) === \"string\" ? RpcRegistry.instance.lookupInterfaceDefinition(target) : target;\n        const propertyName = RpcOperation.computeOperationName(operationName);\n        const proto = definition.prototype;\n        if (!proto.hasOwnProperty(propertyName))\n            throw new IModelError(BentleyStatus.ERROR, `RPC interface class \"${definition.interfaceName}\" does not does not declare operation \"${operationName}\"`);\n        return proto[propertyName][OPERATION];\n    }\n    /** Iterates the operations of an RPC interface definition. */\n    static forEach(definition, callback) {\n        Object.getOwnPropertyNames(definition.prototype).forEach((operationName) => {\n            if (operationName === \"constructor\" || operationName === \"configurationSupplier\")\n                return;\n            const propertyName = RpcOperation.computeOperationName(operationName);\n            callback(definition.prototype[propertyName][OPERATION]);\n        });\n    }\n    /** The version of this operation. */\n    get interfaceVersion() { return this.interfaceDefinition.interfaceVersion; }\n    /** @internal */\n    constructor(definition, operation, policy) {\n        this.interfaceDefinition = definition;\n        this.operationName = operation;\n        this.policy = policy;\n    }\n    /** @internal */\n    static computeOperationName(identifier) {\n        const c = identifier.indexOf(\":\");\n        if (c === -1)\n            return identifier;\n        return identifier.substring(0, c + 1);\n    }\n}\n/** A fallback token to use for RPC requests that do not semantically depend on an iModel. */\nRpcOperation.fallbackToken = undefined;\nexport { RpcOperation };\n/** @internal */\n(function (RpcOperation) {\n    function obtainInstance(obj) {\n        if (obj instanceof RpcOperationPolicy) {\n            return obj;\n        }\n        else {\n            const instance = new RpcOperationPolicy();\n            Object.assign(instance, obj);\n            return instance;\n        }\n    }\n    /** Decorator for setting the policy for an RPC operation function. */\n    function setPolicy(policy) {\n        return (target, propertyKey, descriptor) => {\n            descriptor.value[OPERATION] = new RpcOperation(target.constructor, propertyKey, obtainInstance(policy));\n        };\n    }\n    RpcOperation.setPolicy = setPolicy;\n    /** Convenience decorator for setting an RPC operation policy that allows response caching. */\n    function allowResponseCaching(control = RpcResponseCacheControl.Immutable) {\n        return (target, propertyKey, descriptor) => {\n            descriptor.value[OPERATION] = new RpcOperation(target.constructor, propertyKey, new class extends RpcOperationPolicy {\n                constructor() {\n                    super(...arguments);\n                    this.allowResponseCaching = () => control;\n                }\n            }());\n        };\n    }\n    RpcOperation.allowResponseCaching = allowResponseCaching;\n    /** Convenience decorator for setting an RPC operation policy that supplies the IModelRpcProps for an operation. */\n    function setRoutingProps(handler) {\n        return (target, propertyKey, descriptor) => {\n            descriptor.value[OPERATION] = new RpcOperation(target.constructor, propertyKey, new class extends RpcOperationPolicy {\n                constructor() {\n                    super(...arguments);\n                    this.token = handler;\n                }\n            }());\n        };\n    }\n    RpcOperation.setRoutingProps = setRoutingProps;\n    /** Decorator for setting the default policy for an RPC interface definition class. */\n    function setDefaultPolicy(policy) {\n        return (definition) => {\n            definition[POLICY] = obtainInstance(policy);\n        };\n    }\n    RpcOperation.setDefaultPolicy = setDefaultPolicy;\n})(RpcOperation || (RpcOperation = {}));\n//# sourceMappingURL=RpcOperation.js.map",
      "start": 1693508121015,
      "end": 1693508121075,
      "sourcemaps": null
    }
  ]
}
