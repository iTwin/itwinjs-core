{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/AttributeBuffers.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n/** Provides convenience methods for creating a BufferHandleLinkage interface. */\nclass BufferHandleLinkage {\n    constructor() { }\n    static create(buffer, params) {\n        return { buffer, params };\n    }\n    static clone(linkage) {\n        const clonedParams = [];\n        for (const param of linkage.params) {\n            clonedParams.push(BufferParameters.clone(param));\n        }\n        return BufferHandleLinkage.create(linkage.buffer, clonedParams);\n    }\n}\n/**\n * Provides convenience methods for creating a BuffersParameter interface.\n * @internal\n */\nexport var BufferParameters;\n(function (BufferParameters) {\n    function create(glAttribLoc, glSize, glType, glNormalized, glStride, glOffset, glInstanced) {\n        return { glAttribLoc, glSize, glType, glNormalized, glStride, glOffset, glInstanced };\n    }\n    BufferParameters.create = create;\n    function clone(params) {\n        return BufferParameters.create(params.glAttribLoc, params.glSize, params.glType, params.glNormalized, params.glStride, params.glOffset, params.glInstanced);\n    }\n    BufferParameters.clone = clone;\n})(BufferParameters || (BufferParameters = {}));\n/**\n * An abstract class which specifies an interface for binding and unbinding vertex buffers and their associated state.\n * @internal\n */\nexport class BuffersContainer {\n    static create() {\n        return new BuffersContainer(System.instance.context);\n    }\n    constructor(context) {\n        this.linkages = [];\n        this._context = context;\n        this._vao = new VAOHandle(this._context);\n    }\n    // NB: BufferHandle objects contained within BufferHandleLinkage entries are disposed where they are created because they could be shared among multiple BuffersContainer objects.\n    dispose() {\n        this._vao.dispose();\n    }\n    get isDisposed() {\n        return this._vao.isDisposed;\n    }\n    addBuffer(buffer, params) {\n        const linkage = BufferHandleLinkage.create(buffer, params);\n        this.linkages.push(linkage);\n        this._bindLinkage(linkage);\n    }\n    appendLinkages(linkages) {\n        for (const linkage of linkages) {\n            this.linkages.push(BufferHandleLinkage.clone(linkage));\n            this._bindLinkage(linkage);\n        }\n    }\n    _bindLinkage(linkage) {\n        this.bind();\n        linkage.buffer.bind();\n        for (const p of linkage.params) {\n            System.instance.context.enableVertexAttribArray(p.glAttribLoc);\n            if (p.glInstanced) {\n                System.instance.vertexAttribDivisor(p.glAttribLoc, 1);\n            }\n            System.instance.context.vertexAttribPointer(p.glAttribLoc, p.glSize, p.glType, p.glNormalized, p.glStride, p.glOffset);\n        }\n        this.unbind();\n    }\n    bind() {\n        this._vao.bind();\n    }\n    unbind() {\n        VAOHandle.unbind(this._context);\n    }\n}\n/** A handle to a WebGLVertexArrayObjectOES.\n * The WebGLVertexArrayObjectOES is allocated by the constructor and should be freed by a call to dispose().\n * @internal\n */\nexport class VAOHandle {\n    /** Allocates the WebGLVertexArrayObjectOES using the supplied context. Free the WebGLVertexArrayObjectOES using dispose() */\n    constructor(context) {\n        this._context = context;\n        const arrayObject = this._context.createVertexArray();\n        // vaoExt.createVertexArrayOES() returns WebGLVertexArrayObjectOES | null...\n        if (null !== arrayObject) {\n            this._arrayObject = arrayObject;\n        }\n        else {\n            this._arrayObject = undefined;\n        }\n        assert(!this.isDisposed);\n    }\n    get isDisposed() { return this._arrayObject === undefined; }\n    /** Frees the WebGL vertex array object */\n    dispose() {\n        if (!this.isDisposed) {\n            this._context.deleteVertexArray(this._arrayObject);\n            this._arrayObject = undefined;\n        }\n    }\n    /** Binds this vertex array object */\n    bind() {\n        if (undefined !== this._arrayObject) {\n            this._context.bindVertexArray(this._arrayObject);\n        }\n    }\n    /** Ensures no vertex array object is bound */\n    static unbind(context) {\n        context.bindVertexArray(null);\n    }\n}\n/**\n * A handle to a WebGLBuffer, such as a vertex or index buffer.\n * The WebGLBuffer is allocated by the constructor and should be freed by a call to dispose().\n * @internal\n */\nexport class BufferHandle {\n    /** Allocates the WebGLBuffer using the supplied context. Free the WebGLBuffer using dispose() */\n    constructor(target) {\n        this._bytesUsed = 0;\n        this._target = target;\n        const glBuffer = System.instance.context.createBuffer();\n        // gl.createBuffer() returns WebGLBuffer | null...\n        if (null !== glBuffer) {\n            this._glBuffer = glBuffer;\n        }\n        else {\n            this._glBuffer = undefined;\n        }\n        assert(!this.isDisposed);\n    }\n    get isDisposed() { return this._glBuffer === undefined; }\n    get bytesUsed() { return this._bytesUsed; }\n    /** Frees the WebGL buffer */\n    dispose() {\n        if (!this.isDisposed) {\n            System.instance.context.deleteBuffer(this._glBuffer);\n            this._glBuffer = undefined;\n            this._bytesUsed = 0;\n        }\n    }\n    /** Binds this buffer to the target specified during construction */\n    bind() {\n        if (undefined !== this._glBuffer) {\n            System.instance.context.bindBuffer(this._target, this._glBuffer);\n        }\n    }\n    /** Sets the specified target to be bound to no buffer */\n    unbind() { System.instance.context.bindBuffer(this._target, null); }\n    /** Binds this buffer to the target specified at construction and sets the buffer's data store. */\n    bindData(data, usage = GL.Buffer.Usage.StaticDraw) {\n        this.bind();\n        System.instance.context.bufferData(this._target, data, usage);\n        this.unbind();\n        this._bytesUsed = data.byteLength;\n    }\n    /** Creates a BufferHandle and binds its data */\n    static createBuffer(target, data, usage = GL.Buffer.Usage.StaticDraw) {\n        const handle = new BufferHandle(target);\n        if (handle.isDisposed) {\n            return undefined;\n        }\n        handle.bindData(data, usage);\n        return handle;\n    }\n    /** Creates a BufferHandle and binds its data */\n    static createArrayBuffer(data, usage = GL.Buffer.Usage.StaticDraw) {\n        return BufferHandle.createBuffer(GL.Buffer.Target.ArrayBuffer, data, usage);\n    }\n    isBound(binding) { return System.instance.context.getParameter(binding) === this._glBuffer; }\n}\nfunction setScale(index, value, array) {\n    array[index] = 0.0 !== value ? 1.0 / value : value;\n}\n/**\n * Converts 2d quantization parameters to a format appropriate for submittal to the GPU.\n * params[0] = origin.x\n * params[1] = origin.y\n * params[2] = scale.x\n * params[3] = scale.y\n * @internal\n */\nexport function qparams2dToArray(params) {\n    const arr = new Float32Array(4);\n    arr[0] = params.origin.x;\n    arr[1] = params.origin.y;\n    setScale(2, params.scale.x, arr);\n    setScale(3, params.scale.y, arr);\n    return arr;\n}\n/** @internal */\nexport function qorigin3dToArray(qorigin) {\n    const origin = new Float32Array(3);\n    origin[0] = qorigin.x;\n    origin[1] = qorigin.y;\n    origin[2] = qorigin.z;\n    return origin;\n}\n/** @internal */\nexport function qscale3dToArray(qscale) {\n    const scale = new Float32Array(3);\n    setScale(0, qscale.x, scale);\n    setScale(1, qscale.y, scale);\n    setScale(2, qscale.z, scale);\n    return scale;\n}\n/** Converts 3d quantization params to a pair of Float32Arrays\n * @internal\n */\nexport function qparams3dToArray(params) {\n    const origin = qorigin3dToArray(params.origin);\n    const scale = qscale3dToArray(params.scale);\n    return { origin, scale };\n}\n/** A handle to a WebGLBuffer intended to hold quantized 2d points\n * @internal\n */\nexport class QBufferHandle2d extends BufferHandle {\n    constructor(qParams) {\n        super(GL.Buffer.Target.ArrayBuffer);\n        this.params = qparams2dToArray(qParams);\n    }\n    static create(qParams, data) {\n        const handle = new QBufferHandle2d(qParams);\n        if (handle.isDisposed) {\n            return undefined;\n        }\n        handle.bindData(data);\n        return handle;\n    }\n}\n/* A handle to a WebGLBuffer intended to hold quantized 3d points\n * @internal\n */\nexport class QBufferHandle3d extends BufferHandle {\n    constructor(qParams) {\n        super(GL.Buffer.Target.ArrayBuffer);\n        this.origin = qorigin3dToArray(qParams.origin);\n        this.scale = qscale3dToArray(qParams.scale);\n    }\n    static create(qParams, data) {\n        const handle = new QBufferHandle3d(qParams);\n        if (handle.isDisposed) {\n            return undefined;\n        }\n        handle.bindData(data);\n        return handle;\n    }\n}\n//# sourceMappingURL=AttributeBuffers.js.map",
      "start": 1693508124708,
      "end": 1693508124768,
      "sourcemaps": null
    }
  ]
}
