{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/IncidentMarkerDemo.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Logger } from \"@itwin/core-bentley\";\r\nimport { AngleSweep, Arc3d, Point2d, Point3d, XAndY, XYAndZ } from \"@itwin/core-geometry\";\r\nimport { AxisAlignedBox3d, ColorByName, ColorDef } from \"@itwin/core-common\";\r\nimport {\r\n  BeButton, BeButtonEvent, Cluster, DecorateContext, GraphicType, imageElementFromUrl, IModelApp, Marker, MarkerImage, MarkerSet, MessageBoxIconType,\r\n  MessageBoxType, Tool,\r\n} from \"@itwin/core-frontend\";\r\n\r\n// cspell:ignore lerp\r\n\r\n/** Example Marker to show an *incident*. Each incident has an *id*, a *severity*, and an *icon*. */\r\nclass IncidentMarker extends Marker {\r\n  private static _size = Point2d.create(30, 30);\r\n  private static _imageSize = Point2d.create(40, 40);\r\n  private static _imageOffset = Point2d.create(0, 30);\r\n  private static _amber = ColorDef.create(ColorByName.amber);\r\n  private static _sweep360 = AngleSweep.create360();\r\n  private _color: ColorDef;\r\n\r\n  /** uncomment the next line to make the icon only show when the cursor is over an incident marker. */\r\n  // public get wantImage() { return this._isHilited; }\r\n\r\n  /** Get a color based on severity by interpolating Green(0) -> Amber(15) -> Red(30)  */\r\n  public static makeColor(severity: number): ColorDef {\r\n    return (severity <= 16 ? ColorDef.green.lerp(this._amber, (severity - 1) / 15.) :\r\n      this._amber.lerp(ColorDef.red, (severity - 16) / 14.));\r\n  }\r\n\r\n  // when someone clicks on our marker, open a message box with the severity of the incident.\r\n  public override onMouseButton(ev: BeButtonEvent): boolean {\r\n    if (ev.button === BeButton.Data && ev.isDown) {\r\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n      IModelApp.notifications.openMessageBox(MessageBoxType.LargeOk, `severity = ${this.severity}`, MessageBoxIconType.Information);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Create a new IncidentMarker */\r\n  constructor(location: XYAndZ, public severity: number, public id: number, icon: HTMLImageElement) {\r\n    super(location, IncidentMarker._size);\r\n    this._color = IncidentMarker.makeColor(severity); // color interpolated from severity\r\n    this.setImage(icon); // save icon\r\n    this.imageOffset = IncidentMarker._imageOffset; // move icon up by 30 pixels so the bottom of the flag is at the incident location in the view.\r\n    this.imageSize = IncidentMarker._imageSize; // 40x40\r\n    this.title = `Severity: ${severity}<br>Id: ${id}`; // tooltip\r\n    this.setScaleFactor({ low: .2, high: 1.4 }); // make size 20% at back of frustum and 140% at front of frustum (if camera is on)\r\n    this.label = id.toString();\r\n  }\r\n\r\n  /**\r\n   * For this demo, add a WorldDecoration that draws a circle with a radius of 200cm centered at the incident location.\r\n   * WorldDecorations are in world coordinates, so the circle will change size as you zoom in/out. Also, they are drawn with the z-buffer enabled, so\r\n   * the circle may be obscured by other geometry in front of in the view. This can help the user understand the point that the marker relates to,\r\n   * but that effect isn't always desireable.\r\n   *\r\n   * World decorations for markers are completely optional. If you don't want anything drawn with WorldDecorations, don't follow this example.\r\n   *\r\n   */\r\n  public override addMarker(context: DecorateContext) {\r\n    super.addMarker(context);\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\r\n    const ellipse = Arc3d.createScaledXYColumns(this.worldLocation, context.viewport.rotation.transpose(), .2, .2, IncidentMarker._sweep360);\r\n    // draw the circle the color of the marker, but with some transparency.\r\n    let color = this._color;\r\n    builder.setSymbology(ColorDef.white, color, 1);\r\n    color = color.withTransparency(200);\r\n    builder.addArc(ellipse, false, false);\r\n    builder.setBlankingFill(color);\r\n    builder.addArc(ellipse, true, true);\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n}\r\n\r\n/** A Marker used to show a cluster of incidents */\r\nclass IncidentClusterMarker extends Marker {\r\n  private _clusterColor: string;\r\n  // public get wantImage() { return this._isHilited; }\r\n\r\n  // draw the cluster as a white circle with an outline color based on what's in the cluster\r\n  public override drawFunc(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = this._clusterColor;\r\n    ctx.fillStyle = \"white\";\r\n    ctx.lineWidth = 5;\r\n    ctx.arc(0, 0, 13, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.stroke();\r\n  }\r\n\r\n  /** Create a new cluster marker with label and color based on the content of the cluster */\r\n  constructor(location: XYAndZ, size: XAndY, cluster: Cluster<IncidentMarker>, image: MarkerImage | Promise<MarkerImage> | undefined) {\r\n    super(location, size);\r\n\r\n    // get the top 10 incidents by severity\r\n    const sorted: IncidentMarker[] = [];\r\n    const maxLen = 10;\r\n    cluster.markers.forEach((marker) => {\r\n      if (maxLen > sorted.length || marker.severity > sorted[sorted.length - 1].severity) {\r\n        const index = sorted.findIndex((val) => val.severity < marker.severity);\r\n        if (index === -1)\r\n          sorted.push(marker);\r\n        else\r\n          sorted.splice(index, 0, marker);\r\n        if (sorted.length > maxLen)\r\n          sorted.length = maxLen;\r\n      }\r\n    });\r\n\r\n    this.imageOffset = new Point3d(0, 28);\r\n    this.imageSize = new Point2d(30, 30);\r\n    this.label = cluster.markers.length.toLocaleString();\r\n    this.labelColor = \"black\";\r\n    this.labelFont = \"bold 14px sans-serif\";\r\n    this.setScaleFactor({ low: .7, high: 1.2 });\r\n\r\n    let title = \"\";\r\n    sorted.forEach((marker) => {\r\n      if (title !== \"\")\r\n        title += \"<br>\";\r\n      title += `Severity: ${marker.severity} Id: ${marker.id}`;\r\n    });\r\n    if (cluster.markers.length > maxLen)\r\n      title += \"<br>...\";\r\n\r\n    const div = document.createElement(\"div\"); // Use HTML as markup isn't supported for string.\r\n    div.innerHTML = title;\r\n    this.title = div;\r\n    this._clusterColor = IncidentMarker.makeColor(sorted[0].severity).toHexString();\r\n    if (image)\r\n      this.setImage(image);\r\n  }\r\n}\r\n\r\n/** A MarkerSet to hold incidents. This class supplies to `getClusterMarker` method to create IncidentClusterMarkers. */\r\nclass IncidentMarkerSet extends MarkerSet<IncidentMarker> {\r\n  protected getClusterMarker(cluster: Cluster<IncidentMarker>): Marker {\r\n    return new IncidentClusterMarker(cluster.getClusterLocation(), cluster.markers[0].size, cluster, IncidentMarkerDemo.decorator!.warningSign);\r\n  }\r\n}\r\n\r\n/** This demo shows how to use MarkerSets to cluster markers that overlap on the screen. It creates a set of 500\r\n * \"incidents\" at random locations within the ProjectExtents. For each incident, it creates an IncidentMarker with an Id and\r\n * with a random value between 1-30 for \"severity\", and one of 5 possible icons.\r\n */\r\nexport class IncidentMarkerDemo {\r\n  private _awaiting = false;\r\n  private _loading?: Promise<any>;\r\n  private _images: Array<HTMLImageElement | undefined> = [];\r\n  public readonly incidents = new IncidentMarkerSet();\r\n  private static _numMarkers = 500;\r\n  public static decorator?: IncidentMarkerDemo; // static variable so we can tell if the demo is active.\r\n\r\n  public get warningSign() { return this._images[0]; }\r\n\r\n  // Load one image, logging if there was an error\r\n  private async loadOne(src: string) {\r\n    try {\r\n      return await imageElementFromUrl(src); // note: \"return await\" is necessary inside try/catch\r\n    } catch (err) {\r\n      const msg = `Could not load image ${src}`;\r\n      Logger.logError(\"IncidentDemo\", msg);\r\n      console.log(msg); // eslint-disable-line no-console\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // load all images. After they're loaded, make the incident markers.\r\n  // If there will be a lot of markers displayed, it's best to draw images without scaling.\r\n  // The Warning_sign.svg used in this example is quite large and is always being scaled down.\r\n  private async loadAll(extents: AxisAlignedBox3d) {\r\n    const loads = [\r\n      this.loadOne(\"Warning_sign.svg\"), // must be first, see \"get warningSign()\" above\r\n      this.loadOne(\"Hazard_biological.svg\"),\r\n      this.loadOne(\"Hazard_electric.svg\"),\r\n      this.loadOne(\"Hazard_flammable.svg\"),\r\n      this.loadOne(\"Hazard_toxic.svg\"),\r\n      this.loadOne(\"Hazard_tripping.svg\"),\r\n    ];\r\n    await (this._loading = Promise.all(loads)); // this is a member so we can tell if we're still loading\r\n    for (const img of loads)\r\n      this._images.push(await img);\r\n\r\n    const len = this._images.length;\r\n    const pos = new Point3d();\r\n    for (let i = 0; i < IncidentMarkerDemo._numMarkers; ++i) {\r\n      pos.x = extents.low.x + (Math.random() * extents.xLength());\r\n      pos.y = extents.low.y + (Math.random() * extents.yLength());\r\n      pos.z = extents.low.z + (Math.random() * extents.zLength());\r\n      const img = this._images[(i % len) + 1];\r\n      if (undefined !== img)\r\n        this.incidents.markers.add(new IncidentMarker(pos, 1 + Math.round(Math.random() * 29), i, img));\r\n    }\r\n    this._loading = undefined;\r\n  }\r\n\r\n  public constructor(extents: AxisAlignedBox3d) {\r\n    this.loadAll(extents); // eslint-disable-line @typescript-eslint/no-floating-promises\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. We add the MarkerSet. */\r\n  public decorate(context: DecorateContext) {\r\n    if (!context.viewport.view.isSpatialView())\r\n      return;\r\n\r\n    if (undefined === this._loading) {\r\n      this.incidents.addDecoration(context);\r\n      return;\r\n    }\r\n\r\n    // if we're still loading, just mark this viewport as needing decorations when all loads are complete\r\n    if (!this._awaiting) {\r\n      this._awaiting = true;\r\n      this._loading.then(() => {\r\n        context.viewport.invalidateCachedDecorations(this);\r\n        this._awaiting = false;\r\n      }).catch(() => undefined);\r\n    }\r\n  }\r\n\r\n  /** start the demo by creating the IncidentMarkerDemo object and adding it as a ViewManager decorator. */\r\n  private static start(extents: AxisAlignedBox3d) {\r\n    IncidentMarkerDemo.decorator = new IncidentMarkerDemo(extents);\r\n    IModelApp.viewManager.addDecorator(IncidentMarkerDemo.decorator);\r\n\r\n    // hook the event for viewport changing and stop the demo. This is called when the view is closed too. */\r\n    IncidentMarkerDemo.decorator.incidents.viewport!.onChangeView.addOnce(() => this.stop());\r\n  }\r\n\r\n  /** stop the demo */\r\n  private static stop() {\r\n    if (IncidentMarkerDemo.decorator)\r\n      IModelApp.viewManager.dropDecorator(IncidentMarkerDemo.decorator);\r\n    IncidentMarkerDemo.decorator = undefined;\r\n  }\r\n\r\n  /** Turn the markers on and off. Each time it runs it creates a new random set of incidents. */\r\n  public static toggle(extents: AxisAlignedBox3d) {\r\n    if (undefined === IncidentMarkerDemo.decorator)\r\n      this.start(extents);\r\n    else\r\n      this.stop();\r\n  }\r\n}\r\n\r\nexport class IncidentMarkerDemoTool extends Tool {\r\n  public static override toolId = \"ToggleIncidentMarkers\";\r\n  public override async run(_args: any[]): Promise<boolean> {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp && vp.view.isSpatialView())\r\n      IncidentMarkerDemo.toggle(vp.view.iModel.projectExtents);\r\n\r\n    return true;\r\n  }\r\n}\r\n",
      "start": 1693508121206,
      "end": 1693508121255,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { Logger } from \"@itwin/core-bentley\";\nimport { AngleSweep, Arc3d, Point2d, Point3d } from \"@itwin/core-geometry\";\nimport { ColorByName, ColorDef } from \"@itwin/core-common\";\nimport {\n  BeButton,\n  GraphicType,\n  imageElementFromUrl,\n  IModelApp,\n  Marker,\n  MarkerSet,\n  MessageBoxIconType,\n  MessageBoxType,\n  Tool\n} from \"@itwin/core-frontend\";\nconst _IncidentMarker = class _IncidentMarker extends Marker {\n  /** Create a new IncidentMarker */\n  constructor(location, severity, id, icon) {\n    super(location, _IncidentMarker._size);\n    this.severity = severity;\n    this.id = id;\n    this._color = _IncidentMarker.makeColor(severity);\n    this.setImage(icon);\n    this.imageOffset = _IncidentMarker._imageOffset;\n    this.imageSize = _IncidentMarker._imageSize;\n    this.title = `Severity: ${severity}<br>Id: ${id}`;\n    this.setScaleFactor({ low: 0.2, high: 1.4 });\n    this.label = id.toString();\n  }\n  /** uncomment the next line to make the icon only show when the cursor is over an incident marker. */\n  // public get wantImage() { return this._isHilited; }\n  /** Get a color based on severity by interpolating Green(0) -> Amber(15) -> Red(30)  */\n  static makeColor(severity) {\n    return severity <= 16 ? ColorDef.green.lerp(this._amber, (severity - 1) / 15) : this._amber.lerp(ColorDef.red, (severity - 16) / 14);\n  }\n  // when someone clicks on our marker, open a message box with the severity of the incident.\n  onMouseButton(ev) {\n    if (ev.button === BeButton.Data && ev.isDown) {\n      IModelApp.notifications.openMessageBox(MessageBoxType.LargeOk, `severity = ${this.severity}`, MessageBoxIconType.Information);\n    }\n    return true;\n  }\n  /**\n   * For this demo, add a WorldDecoration that draws a circle with a radius of 200cm centered at the incident location.\n   * WorldDecorations are in world coordinates, so the circle will change size as you zoom in/out. Also, they are drawn with the z-buffer enabled, so\n   * the circle may be obscured by other geometry in front of in the view. This can help the user understand the point that the marker relates to,\n   * but that effect isn't always desireable.\n   *\n   * World decorations for markers are completely optional. If you don't want anything drawn with WorldDecorations, don't follow this example.\n   *\n   */\n  addMarker(context) {\n    super.addMarker(context);\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n    const ellipse = Arc3d.createScaledXYColumns(this.worldLocation, context.viewport.rotation.transpose(), 0.2, 0.2, _IncidentMarker._sweep360);\n    let color = this._color;\n    builder.setSymbology(ColorDef.white, color, 1);\n    color = color.withTransparency(200);\n    builder.addArc(ellipse, false, false);\n    builder.setBlankingFill(color);\n    builder.addArc(ellipse, true, true);\n    context.addDecorationFromBuilder(builder);\n  }\n};\n_IncidentMarker._size = Point2d.create(30, 30);\n_IncidentMarker._imageSize = Point2d.create(40, 40);\n_IncidentMarker._imageOffset = Point2d.create(0, 30);\n_IncidentMarker._amber = ColorDef.create(ColorByName.amber);\n_IncidentMarker._sweep360 = AngleSweep.create360();\nlet IncidentMarker = _IncidentMarker;\nclass IncidentClusterMarker extends Marker {\n  /** Create a new cluster marker with label and color based on the content of the cluster */\n  constructor(location, size, cluster, image) {\n    super(location, size);\n    const sorted = [];\n    const maxLen = 10;\n    cluster.markers.forEach((marker) => {\n      if (maxLen > sorted.length || marker.severity > sorted[sorted.length - 1].severity) {\n        const index = sorted.findIndex((val) => val.severity < marker.severity);\n        if (index === -1)\n          sorted.push(marker);\n        else\n          sorted.splice(index, 0, marker);\n        if (sorted.length > maxLen)\n          sorted.length = maxLen;\n      }\n    });\n    this.imageOffset = new Point3d(0, 28);\n    this.imageSize = new Point2d(30, 30);\n    this.label = cluster.markers.length.toLocaleString();\n    this.labelColor = \"black\";\n    this.labelFont = \"bold 14px sans-serif\";\n    this.setScaleFactor({ low: 0.7, high: 1.2 });\n    let title = \"\";\n    sorted.forEach((marker) => {\n      if (title !== \"\")\n        title += \"<br>\";\n      title += `Severity: ${marker.severity} Id: ${marker.id}`;\n    });\n    if (cluster.markers.length > maxLen)\n      title += \"<br>...\";\n    const div = document.createElement(\"div\");\n    div.innerHTML = title;\n    this.title = div;\n    this._clusterColor = IncidentMarker.makeColor(sorted[0].severity).toHexString();\n    if (image)\n      this.setImage(image);\n  }\n  // public get wantImage() { return this._isHilited; }\n  // draw the cluster as a white circle with an outline color based on what's in the cluster\n  drawFunc(ctx) {\n    ctx.beginPath();\n    ctx.strokeStyle = this._clusterColor;\n    ctx.fillStyle = \"white\";\n    ctx.lineWidth = 5;\n    ctx.arc(0, 0, 13, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n  }\n}\nclass IncidentMarkerSet extends MarkerSet {\n  getClusterMarker(cluster) {\n    return new IncidentClusterMarker(cluster.getClusterLocation(), cluster.markers[0].size, cluster, IncidentMarkerDemo.decorator.warningSign);\n  }\n}\nconst _IncidentMarkerDemo = class _IncidentMarkerDemo {\n  constructor(extents) {\n    this._awaiting = false;\n    this._images = [];\n    this.incidents = new IncidentMarkerSet();\n    /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\n    this.useCachedDecorations = true;\n    this.loadAll(extents);\n  }\n  // static variable so we can tell if the demo is active.\n  get warningSign() {\n    return this._images[0];\n  }\n  // Load one image, logging if there was an error\n  async loadOne(src) {\n    try {\n      return await imageElementFromUrl(src);\n    } catch (err) {\n      const msg = `Could not load image ${src}`;\n      Logger.logError(\"IncidentDemo\", msg);\n      console.log(msg);\n    }\n    return void 0;\n  }\n  // load all images. After they're loaded, make the incident markers.\n  // If there will be a lot of markers displayed, it's best to draw images without scaling.\n  // The Warning_sign.svg used in this example is quite large and is always being scaled down.\n  async loadAll(extents) {\n    const loads = [\n      this.loadOne(\"Warning_sign.svg\"),\n      // must be first, see \"get warningSign()\" above\n      this.loadOne(\"Hazard_biological.svg\"),\n      this.loadOne(\"Hazard_electric.svg\"),\n      this.loadOne(\"Hazard_flammable.svg\"),\n      this.loadOne(\"Hazard_toxic.svg\"),\n      this.loadOne(\"Hazard_tripping.svg\")\n    ];\n    await (this._loading = Promise.all(loads));\n    for (const img of loads)\n      this._images.push(await img);\n    const len = this._images.length;\n    const pos = new Point3d();\n    for (let i = 0; i < _IncidentMarkerDemo._numMarkers; ++i) {\n      pos.x = extents.low.x + Math.random() * extents.xLength();\n      pos.y = extents.low.y + Math.random() * extents.yLength();\n      pos.z = extents.low.z + Math.random() * extents.zLength();\n      const img = this._images[i % len + 1];\n      if (void 0 !== img)\n        this.incidents.markers.add(new IncidentMarker(pos, 1 + Math.round(Math.random() * 29), i, img));\n    }\n    this._loading = void 0;\n  }\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. We add the MarkerSet. */\n  decorate(context) {\n    if (!context.viewport.view.isSpatialView())\n      return;\n    if (void 0 === this._loading) {\n      this.incidents.addDecoration(context);\n      return;\n    }\n    if (!this._awaiting) {\n      this._awaiting = true;\n      this._loading.then(() => {\n        context.viewport.invalidateCachedDecorations(this);\n        this._awaiting = false;\n      }).catch(() => void 0);\n    }\n  }\n  /** start the demo by creating the IncidentMarkerDemo object and adding it as a ViewManager decorator. */\n  static start(extents) {\n    _IncidentMarkerDemo.decorator = new _IncidentMarkerDemo(extents);\n    IModelApp.viewManager.addDecorator(_IncidentMarkerDemo.decorator);\n    _IncidentMarkerDemo.decorator.incidents.viewport.onChangeView.addOnce(() => this.stop());\n  }\n  /** stop the demo */\n  static stop() {\n    if (_IncidentMarkerDemo.decorator)\n      IModelApp.viewManager.dropDecorator(_IncidentMarkerDemo.decorator);\n    _IncidentMarkerDemo.decorator = void 0;\n  }\n  /** Turn the markers on and off. Each time it runs it creates a new random set of incidents. */\n  static toggle(extents) {\n    if (void 0 === _IncidentMarkerDemo.decorator)\n      this.start(extents);\n    else\n      this.stop();\n  }\n};\n_IncidentMarkerDemo._numMarkers = 500;\nexport let IncidentMarkerDemo = _IncidentMarkerDemo;\nexport class IncidentMarkerDemoTool extends Tool {\n  async run(_args) {\n    const vp = IModelApp.viewManager.selectedView;\n    if (void 0 !== vp && vp.view.isSpatialView())\n      IncidentMarkerDemo.toggle(vp.view.iModel.projectExtents);\n    return true;\n  }\n}\nIncidentMarkerDemoTool.toolId = \"ToggleIncidentMarkers\";\n",
      "start": 1693508121255,
      "end": 1693508121435,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/IncidentMarkerDemo.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Logger } from \"@itwin/core-bentley\";\r\nimport { AngleSweep, Arc3d, Point2d, Point3d, XAndY, XYAndZ } from \"@itwin/core-geometry\";\r\nimport { AxisAlignedBox3d, ColorByName, ColorDef } from \"@itwin/core-common\";\r\nimport {\r\n  BeButton, BeButtonEvent, Cluster, DecorateContext, GraphicType, imageElementFromUrl, IModelApp, Marker, MarkerImage, MarkerSet, MessageBoxIconType,\r\n  MessageBoxType, Tool,\r\n} from \"@itwin/core-frontend\";\r\n\r\n// cspell:ignore lerp\r\n\r\n/** Example Marker to show an *incident*. Each incident has an *id*, a *severity*, and an *icon*. */\r\nclass IncidentMarker extends Marker {\r\n  private static _size = Point2d.create(30, 30);\r\n  private static _imageSize = Point2d.create(40, 40);\r\n  private static _imageOffset = Point2d.create(0, 30);\r\n  private static _amber = ColorDef.create(ColorByName.amber);\r\n  private static _sweep360 = AngleSweep.create360();\r\n  private _color: ColorDef;\r\n\r\n  /** uncomment the next line to make the icon only show when the cursor is over an incident marker. */\r\n  // public get wantImage() { return this._isHilited; }\r\n\r\n  /** Get a color based on severity by interpolating Green(0) -> Amber(15) -> Red(30)  */\r\n  public static makeColor(severity: number): ColorDef {\r\n    return (severity <= 16 ? ColorDef.green.lerp(this._amber, (severity - 1) / 15.) :\r\n      this._amber.lerp(ColorDef.red, (severity - 16) / 14.));\r\n  }\r\n\r\n  // when someone clicks on our marker, open a message box with the severity of the incident.\r\n  public override onMouseButton(ev: BeButtonEvent): boolean {\r\n    if (ev.button === BeButton.Data && ev.isDown) {\r\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n      IModelApp.notifications.openMessageBox(MessageBoxType.LargeOk, `severity = ${this.severity}`, MessageBoxIconType.Information);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Create a new IncidentMarker */\r\n  constructor(location: XYAndZ, public severity: number, public id: number, icon: HTMLImageElement) {\r\n    super(location, IncidentMarker._size);\r\n    this._color = IncidentMarker.makeColor(severity); // color interpolated from severity\r\n    this.setImage(icon); // save icon\r\n    this.imageOffset = IncidentMarker._imageOffset; // move icon up by 30 pixels so the bottom of the flag is at the incident location in the view.\r\n    this.imageSize = IncidentMarker._imageSize; // 40x40\r\n    this.title = `Severity: ${severity}<br>Id: ${id}`; // tooltip\r\n    this.setScaleFactor({ low: .2, high: 1.4 }); // make size 20% at back of frustum and 140% at front of frustum (if camera is on)\r\n    this.label = id.toString();\r\n  }\r\n\r\n  /**\r\n   * For this demo, add a WorldDecoration that draws a circle with a radius of 200cm centered at the incident location.\r\n   * WorldDecorations are in world coordinates, so the circle will change size as you zoom in/out. Also, they are drawn with the z-buffer enabled, so\r\n   * the circle may be obscured by other geometry in front of in the view. This can help the user understand the point that the marker relates to,\r\n   * but that effect isn't always desireable.\r\n   *\r\n   * World decorations for markers are completely optional. If you don't want anything drawn with WorldDecorations, don't follow this example.\r\n   *\r\n   */\r\n  public override addMarker(context: DecorateContext) {\r\n    super.addMarker(context);\r\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\r\n    const ellipse = Arc3d.createScaledXYColumns(this.worldLocation, context.viewport.rotation.transpose(), .2, .2, IncidentMarker._sweep360);\r\n    // draw the circle the color of the marker, but with some transparency.\r\n    let color = this._color;\r\n    builder.setSymbology(ColorDef.white, color, 1);\r\n    color = color.withTransparency(200);\r\n    builder.addArc(ellipse, false, false);\r\n    builder.setBlankingFill(color);\r\n    builder.addArc(ellipse, true, true);\r\n    context.addDecorationFromBuilder(builder);\r\n  }\r\n}\r\n\r\n/** A Marker used to show a cluster of incidents */\r\nclass IncidentClusterMarker extends Marker {\r\n  private _clusterColor: string;\r\n  // public get wantImage() { return this._isHilited; }\r\n\r\n  // draw the cluster as a white circle with an outline color based on what's in the cluster\r\n  public override drawFunc(ctx: CanvasRenderingContext2D) {\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = this._clusterColor;\r\n    ctx.fillStyle = \"white\";\r\n    ctx.lineWidth = 5;\r\n    ctx.arc(0, 0, 13, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    ctx.stroke();\r\n  }\r\n\r\n  /** Create a new cluster marker with label and color based on the content of the cluster */\r\n  constructor(location: XYAndZ, size: XAndY, cluster: Cluster<IncidentMarker>, image: MarkerImage | Promise<MarkerImage> | undefined) {\r\n    super(location, size);\r\n\r\n    // get the top 10 incidents by severity\r\n    const sorted: IncidentMarker[] = [];\r\n    const maxLen = 10;\r\n    cluster.markers.forEach((marker) => {\r\n      if (maxLen > sorted.length || marker.severity > sorted[sorted.length - 1].severity) {\r\n        const index = sorted.findIndex((val) => val.severity < marker.severity);\r\n        if (index === -1)\r\n          sorted.push(marker);\r\n        else\r\n          sorted.splice(index, 0, marker);\r\n        if (sorted.length > maxLen)\r\n          sorted.length = maxLen;\r\n      }\r\n    });\r\n\r\n    this.imageOffset = new Point3d(0, 28);\r\n    this.imageSize = new Point2d(30, 30);\r\n    this.label = cluster.markers.length.toLocaleString();\r\n    this.labelColor = \"black\";\r\n    this.labelFont = \"bold 14px sans-serif\";\r\n    this.setScaleFactor({ low: .7, high: 1.2 });\r\n\r\n    let title = \"\";\r\n    sorted.forEach((marker) => {\r\n      if (title !== \"\")\r\n        title += \"<br>\";\r\n      title += `Severity: ${marker.severity} Id: ${marker.id}`;\r\n    });\r\n    if (cluster.markers.length > maxLen)\r\n      title += \"<br>...\";\r\n\r\n    const div = document.createElement(\"div\"); // Use HTML as markup isn't supported for string.\r\n    div.innerHTML = title;\r\n    this.title = div;\r\n    this._clusterColor = IncidentMarker.makeColor(sorted[0].severity).toHexString();\r\n    if (image)\r\n      this.setImage(image);\r\n  }\r\n}\r\n\r\n/** A MarkerSet to hold incidents. This class supplies to `getClusterMarker` method to create IncidentClusterMarkers. */\r\nclass IncidentMarkerSet extends MarkerSet<IncidentMarker> {\r\n  protected getClusterMarker(cluster: Cluster<IncidentMarker>): Marker {\r\n    return new IncidentClusterMarker(cluster.getClusterLocation(), cluster.markers[0].size, cluster, IncidentMarkerDemo.decorator!.warningSign);\r\n  }\r\n}\r\n\r\n/** This demo shows how to use MarkerSets to cluster markers that overlap on the screen. It creates a set of 500\r\n * \"incidents\" at random locations within the ProjectExtents. For each incident, it creates an IncidentMarker with an Id and\r\n * with a random value between 1-30 for \"severity\", and one of 5 possible icons.\r\n */\r\nexport class IncidentMarkerDemo {\r\n  private _awaiting = false;\r\n  private _loading?: Promise<any>;\r\n  private _images: Array<HTMLImageElement | undefined> = [];\r\n  public readonly incidents = new IncidentMarkerSet();\r\n  private static _numMarkers = 500;\r\n  public static decorator?: IncidentMarkerDemo; // static variable so we can tell if the demo is active.\r\n\r\n  public get warningSign() { return this._images[0]; }\r\n\r\n  // Load one image, logging if there was an error\r\n  private async loadOne(src: string) {\r\n    try {\r\n      return await imageElementFromUrl(src); // note: \"return await\" is necessary inside try/catch\r\n    } catch (err) {\r\n      const msg = `Could not load image ${src}`;\r\n      Logger.logError(\"IncidentDemo\", msg);\r\n      console.log(msg); // eslint-disable-line no-console\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // load all images. After they're loaded, make the incident markers.\r\n  // If there will be a lot of markers displayed, it's best to draw images without scaling.\r\n  // The Warning_sign.svg used in this example is quite large and is always being scaled down.\r\n  private async loadAll(extents: AxisAlignedBox3d) {\r\n    const loads = [\r\n      this.loadOne(\"Warning_sign.svg\"), // must be first, see \"get warningSign()\" above\r\n      this.loadOne(\"Hazard_biological.svg\"),\r\n      this.loadOne(\"Hazard_electric.svg\"),\r\n      this.loadOne(\"Hazard_flammable.svg\"),\r\n      this.loadOne(\"Hazard_toxic.svg\"),\r\n      this.loadOne(\"Hazard_tripping.svg\"),\r\n    ];\r\n    await (this._loading = Promise.all(loads)); // this is a member so we can tell if we're still loading\r\n    for (const img of loads)\r\n      this._images.push(await img);\r\n\r\n    const len = this._images.length;\r\n    const pos = new Point3d();\r\n    for (let i = 0; i < IncidentMarkerDemo._numMarkers; ++i) {\r\n      pos.x = extents.low.x + (Math.random() * extents.xLength());\r\n      pos.y = extents.low.y + (Math.random() * extents.yLength());\r\n      pos.z = extents.low.z + (Math.random() * extents.zLength());\r\n      const img = this._images[(i % len) + 1];\r\n      if (undefined !== img)\r\n        this.incidents.markers.add(new IncidentMarker(pos, 1 + Math.round(Math.random() * 29), i, img));\r\n    }\r\n    this._loading = undefined;\r\n  }\r\n\r\n  public constructor(extents: AxisAlignedBox3d) {\r\n    this.loadAll(extents); // eslint-disable-line @typescript-eslint/no-floating-promises\r\n  }\r\n\r\n  /** This will allow the render system to cache and reuse the decorations created by this decorator's decorate() method. */\r\n  public readonly useCachedDecorations = true;\r\n\r\n  /** We added this class as a ViewManager.decorator below. This method is called to ask for our decorations. We add the MarkerSet. */\r\n  public decorate(context: DecorateContext) {\r\n    if (!context.viewport.view.isSpatialView())\r\n      return;\r\n\r\n    if (undefined === this._loading) {\r\n      this.incidents.addDecoration(context);\r\n      return;\r\n    }\r\n\r\n    // if we're still loading, just mark this viewport as needing decorations when all loads are complete\r\n    if (!this._awaiting) {\r\n      this._awaiting = true;\r\n      this._loading.then(() => {\r\n        context.viewport.invalidateCachedDecorations(this);\r\n        this._awaiting = false;\r\n      }).catch(() => undefined);\r\n    }\r\n  }\r\n\r\n  /** start the demo by creating the IncidentMarkerDemo object and adding it as a ViewManager decorator. */\r\n  private static start(extents: AxisAlignedBox3d) {\r\n    IncidentMarkerDemo.decorator = new IncidentMarkerDemo(extents);\r\n    IModelApp.viewManager.addDecorator(IncidentMarkerDemo.decorator);\r\n\r\n    // hook the event for viewport changing and stop the demo. This is called when the view is closed too. */\r\n    IncidentMarkerDemo.decorator.incidents.viewport!.onChangeView.addOnce(() => this.stop());\r\n  }\r\n\r\n  /** stop the demo */\r\n  private static stop() {\r\n    if (IncidentMarkerDemo.decorator)\r\n      IModelApp.viewManager.dropDecorator(IncidentMarkerDemo.decorator);\r\n    IncidentMarkerDemo.decorator = undefined;\r\n  }\r\n\r\n  /** Turn the markers on and off. Each time it runs it creates a new random set of incidents. */\r\n  public static toggle(extents: AxisAlignedBox3d) {\r\n    if (undefined === IncidentMarkerDemo.decorator)\r\n      this.start(extents);\r\n    else\r\n      this.stop();\r\n  }\r\n}\r\n\r\nexport class IncidentMarkerDemoTool extends Tool {\r\n  public static override toolId = \"ToggleIncidentMarkers\";\r\n  public override async run(_args: any[]): Promise<boolean> {\r\n    const vp = IModelApp.viewManager.selectedView;\r\n    if (undefined !== vp && vp.view.isSpatialView())\r\n      IncidentMarkerDemo.toggle(vp.view.iModel.projectExtents);\r\n\r\n    return true;\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
