{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/PrimaryTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, comparePossiblyUndefined, compareStrings, } from \"@itwin/core-bentley\";\nimport { BatchType, compareIModelTileTreeIds, FeatureAppearanceProvider, iModelTileTreeIdToString, RenderMode, SpatialClassifier, } from \"@itwin/core-common\";\nimport { Range3d, StringifiedClipVector, Transform } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../IModelApp\";\nimport { formatAnimationBranchId } from \"../render/GraphicBranch\";\nimport { AnimationNodeId } from \"../common/render/AnimationNodeId\";\nimport { IModelTileTree, iModelTileTreeParamsFromJSON, MapLayerTileTreeReference, TileGraphicType, TileTreeReference, } from \"./internal\";\nclass PlanProjectionTileTree extends IModelTileTree {\n    constructor(params, treeId, baseElevation) {\n        super(params, treeId);\n        this.baseElevation = baseElevation;\n    }\n}\nclass PrimaryTreeSupplier {\n    constructor() {\n    }\n    compareTileTreeIds(lhs, rhs) {\n        // NB: we don't compare isPlanProjection or is3d - they should always have the same value for a given modelId.\n        return compareStrings(lhs.modelId, rhs.modelId) || compareIModelTileTreeIds(lhs.treeId, rhs.treeId)\n            || comparePossiblyUndefined((x, y) => x.compareTo(y), lhs.timeline, rhs.timeline);\n    }\n    async createTileTree(id, iModel) {\n        const treeId = id.treeId;\n        const idStr = iModelTileTreeIdToString(id.modelId, treeId, IModelApp.tileAdmin);\n        const props = await IModelApp.tileAdmin.requestTileTreeProps(iModel, idStr);\n        // ###TODO remove restriction that animated tile trees can't contained instanced geometry.\n        const isAnimated = undefined !== treeId.animationId || undefined !== id.timeline;\n        const allowInstancing = !isAnimated && !treeId.enforceDisplayPriority && !treeId.sectionCut;\n        const options = {\n            edges: treeId.edges,\n            allowInstancing,\n            is3d: id.is3d,\n            batchType: BatchType.Primary,\n            timeline: id.timeline,\n        };\n        const params = iModelTileTreeParamsFromJSON(props, iModel, id.modelId, options);\n        if (!id.isPlanProjection)\n            return new IModelTileTree(params, id.treeId);\n        let elevation = 0;\n        try {\n            const ranges = await iModel.models.queryExtents(id.modelId);\n            if (1 === ranges.length) {\n                const range = Range3d.fromJSON(ranges[0].extents);\n                const lo = range.low.z;\n                const hi = range.high.z;\n                if (lo <= hi)\n                    elevation = (lo + hi) / 2;\n            }\n        }\n        catch (_err) {\n            //\n        }\n        return new PlanProjectionTileTree(params, id.treeId, elevation);\n    }\n    getOwner(id, iModel) {\n        return iModel.tiles.getTileTreeOwner(id, this);\n    }\n    addModelsAnimatedByScript(modelIds, scriptSourceId, trees) {\n        // Note: This is invoked when an element hosting a schedule script is updated - it doesn't care about frontend schedule scripts.\n        for (const tree of trees)\n            if (scriptSourceId === tree.id.treeId.animationId)\n                modelIds.add(tree.id.modelId);\n    }\n    addSpatialModels(modelIds, trees) {\n        for (const tree of trees)\n            if (tree.id.is3d)\n                modelIds.add(tree.id.modelId);\n    }\n}\nconst primaryTreeSupplier = new PrimaryTreeSupplier();\n/** Find all extant tile trees associated with the specified model Ids and dispose of them.\n * This is used by BriefcaseConnection when a GraphicalEditingScope is exited or after a change to the models' geometry guids\n * is committed, undone, redone, or merged.\n * @internal\n */\nexport function disposeTileTreesForGeometricModels(modelIds, iModel) {\n    const trees = iModel.tiles.getTreeOwnersForSupplier(primaryTreeSupplier);\n    for (const kvp of trees) {\n        const id = kvp.id;\n        assert(undefined !== id.modelId);\n        if (modelIds.has(id.modelId))\n            kvp.owner.dispose();\n    }\n}\nclass PrimaryTreeReference extends TileTreeReference {\n    constructor(view, model, planProjection, transformNodeId, sectionClip) {\n        super();\n        /** Chiefly for debugging - disables iteration of this reference in SpatialModelRefs to e.g. omit the reference from the scene. */\n        this.deactivated = false;\n        this.view = view;\n        this.model = model;\n        this._animationTransformNodeId = transformNodeId;\n        this._sectionClip = sectionClip;\n        this._viewFlagOverrides = { ...model.jsonProperties.viewFlagOverrides };\n        if (sectionClip) {\n            // Clipping will be applied on backend; don't clip out cut geometry.\n            this._viewFlagOverrides.clipVolume = false;\n            this._sectionCutAppearanceProvider = FeatureAppearanceProvider.supplement((app) => {\n                const cutApp = this.view.displayStyle.settings.clipStyle.cutStyle.appearance;\n                return cutApp ? app.extendAppearance(cutApp) : app;\n            });\n        }\n        const scriptInfo = IModelApp.tileAdmin.getScriptInfoForTreeId(model.id, view.displayStyle.scheduleScriptReference); // eslint-disable-line deprecation/deprecation\n        this._id = {\n            modelId: model.id,\n            is3d: model.is3d,\n            treeId: this.createTreeId(view, model.id),\n            isPlanProjection: planProjection,\n            timeline: scriptInfo?.timeline,\n        };\n        this._owner = primaryTreeSupplier.getOwner(this._id, model.iModel);\n    }\n    getAnimationTransformNodeId() {\n        return this._animationTransformNodeId ?? AnimationNodeId.Untransformed;\n    }\n    getViewFlagOverrides(_tree) {\n        return this._viewFlagOverrides;\n    }\n    getAppearanceProvider(_tree) {\n        if (this._sectionCutAppearanceProvider && this.view.displayStyle.settings.clipStyle.cutStyle.appearance)\n            return this._sectionCutAppearanceProvider;\n        return undefined;\n    }\n    getHiddenLineSettings(_tree) {\n        return this._sectionClip ? this.view.displayStyle.settings.clipStyle.cutStyle.hiddenLine : undefined;\n    }\n    get castsShadows() {\n        return true;\n    }\n    get isPlanProjection() {\n        return false;\n    }\n    getClipVolume(_tree) {\n        // ###TODO: reduce frequency with which getModelClip() is called\n        return this.view.is3d() && !this._sectionClip ? this.view.getModelClip(this.model.id) : undefined;\n    }\n    createDrawArgs(context) {\n        const args = super.createDrawArgs(context);\n        if (args)\n            args.intersectionClip = this._sectionClip;\n        return args;\n    }\n    get treeOwner() {\n        const newId = this.createTreeId(this.view, this._id.modelId);\n        const timeline = IModelApp.tileAdmin.getScriptInfoForTreeId(this._id.modelId, this.view.displayStyle.scheduleScriptReference)?.timeline; // eslint-disable-line deprecation/deprecation\n        if (0 !== compareIModelTileTreeIds(newId, this._id.treeId) || timeline !== this._id.timeline) {\n            this._id = {\n                modelId: this._id.modelId,\n                is3d: this._id.is3d,\n                treeId: newId,\n                isPlanProjection: this._id.isPlanProjection,\n                timeline,\n            };\n            this._owner = primaryTreeSupplier.getOwner(this._id, this.model.iModel);\n        }\n        return this._owner;\n    }\n    createTreeId(view, modelId) {\n        if (this._sectionClip) {\n            // We do this each time in case the ClipStyle's overrides are modified.\n            // ###TODO: can we avoid that? Event listeners maybe?\n            this._viewFlagOverrides = {\n                ...this.view.displayStyle.settings.clipStyle.cutStyle.viewflags,\n                // Do not clip out the cut geometry intersecting the clip planes.\n                clipVolume: false,\n                // The cut geometry is planar - it should win a z-fight.\n                // Also we need to preserve this flag if this is a plan projection tile tree reference.\n                forceSurfaceDiscard: true,\n            };\n        }\n        const animationId = IModelApp.tileAdmin.getScriptInfoForTreeId(modelId, view.displayStyle.scheduleScriptReference)?.animationId; // eslint-disable-line deprecation/deprecation\n        const renderMode = this._viewFlagOverrides.renderMode ?? view.viewFlags.renderMode;\n        const visibleEdges = this._viewFlagOverrides.visibleEdges ?? view.viewFlags.visibleEdges;\n        const edgesRequired = visibleEdges || RenderMode.SmoothShade !== renderMode || IModelApp.tileAdmin.alwaysRequestEdges;\n        const edges = edgesRequired ? IModelApp.tileAdmin.edgeOptions : false;\n        const sectionCut = this._sectionClip?.clipString;\n        return { type: BatchType.Primary, edges, animationId, sectionCut };\n    }\n    computeBaseTransform(tree) {\n        return super.computeTransform(tree);\n    }\n    computeTransform(tree) {\n        const baseTf = this.computeBaseTransform(tree);\n        const displayTf = this.view.modelDisplayTransformProvider?.getModelDisplayTransform(this.model.id);\n        return displayTf ? baseTf.multiplyTransformTransform(displayTf, displayTf) : baseTf;\n    }\n}\n/** @internal */\nexport class AnimatedTreeReference extends PrimaryTreeReference {\n    constructor(view, model, transformNodeId) {\n        super(view, model, false, transformNodeId);\n        this._branchId = formatAnimationBranchId(model.id, transformNodeId);\n    }\n    computeBaseTransform(tree) {\n        const tf = super.computeBaseTransform(tree);\n        const style = this.view.displayStyle;\n        const script = style.scheduleScript;\n        if (undefined === script || undefined === this._animationTransformNodeId)\n            return tf;\n        const timePoint = style.settings.timePoint ?? script.duration.low;\n        const animTf = script.getTransform(this._id.modelId, this._animationTransformNodeId, timePoint);\n        if (animTf)\n            animTf.multiplyTransformTransform(tf, tf);\n        return tf;\n    }\n    createDrawArgs(context) {\n        const animBranch = context.viewport.target.animationBranches?.branchStates.get(this._branchId);\n        if (animBranch && animBranch.omit)\n            return undefined;\n        const args = super.createDrawArgs(context);\n        if (args?.tree && undefined !== this._animationTransformNodeId) {\n            assert(args.tree instanceof IModelTileTree);\n            args.boundingRange = args.tree.getTransformNodeRange(this._animationTransformNodeId);\n        }\n        return args;\n    }\n}\nclass PlanProjectionTreeReference extends PrimaryTreeReference {\n    get _view3d() { return this.view; }\n    constructor(view, model, sectionCut) {\n        super(view, model, true, undefined, sectionCut);\n        this._baseTransform = Transform.createIdentity();\n        this._viewFlagOverrides.forceSurfaceDiscard = true;\n    }\n    get castsShadows() {\n        return false;\n    }\n    get isPlanProjection() {\n        return true;\n    }\n    createDrawArgs(context) {\n        const args = super.createDrawArgs(context);\n        if (undefined !== args && this._id.treeId.enforceDisplayPriority) {\n            args.drawGraphics = () => {\n                const graphics = args.produceGraphics();\n                if (undefined !== graphics) {\n                    const settings = this.getSettings();\n                    const asOverlay = undefined !== settings && settings.overlay;\n                    const transparency = settings?.transparency || 0;\n                    let elevation = settings?.elevation;\n                    if (undefined === elevation) {\n                        const tree = this.treeOwner.tileTree;\n                        if (tree) {\n                            assert(tree instanceof PlanProjectionTileTree);\n                            elevation = tree.baseElevation;\n                        }\n                        else {\n                            elevation = 0;\n                        }\n                    }\n                    context.outputGraphic(context.target.renderSystem.createGraphicLayerContainer(graphics, asOverlay, transparency, elevation));\n                }\n            };\n        }\n        return args;\n    }\n    computeBaseTransform(tree) {\n        assert(tree instanceof PlanProjectionTileTree);\n        const transform = tree.iModelTransform.clone(this._baseTransform);\n        const elevation = this.getSettings()?.elevation;\n        if (undefined !== elevation)\n            transform.origin.z = elevation;\n        return transform;\n    }\n    draw(args) {\n        const settings = this.getSettings();\n        if (undefined === settings || settings.enforceDisplayPriority || !settings.overlay)\n            super.draw(args);\n        else\n            args.context.withGraphicType(TileGraphicType.Overlay, () => args.tree.draw(args));\n    }\n    getSettings() {\n        return this._view3d.getDisplayStyle3d().settings.getPlanProjectionSettings(this.model.id);\n    }\n    createTreeId(view, modelId) {\n        const id = super.createTreeId(view, modelId);\n        const settings = this.getSettings();\n        if (undefined !== settings && settings.enforceDisplayPriority)\n            id.enforceDisplayPriority = true;\n        return id;\n    }\n}\nfunction isPlanProjection(view, model) {\n    const model3d = view.is3d() ? model.asGeometricModel3d : undefined;\n    return undefined !== model3d && model3d.isPlanProjection;\n}\nfunction createTreeRef(view, model, sectionCut) {\n    if (false !== IModelApp.renderSystem.options.planProjections && isPlanProjection(view, model))\n        return new PlanProjectionTreeReference(view, model, sectionCut);\n    return new PrimaryTreeReference(view, model, false, undefined, sectionCut);\n}\n/** @internal */\nexport function createPrimaryTileTreeReference(view, model) {\n    return createTreeRef(view, model, undefined);\n}\nclass MaskTreeReference extends TileTreeReference {\n    get castsShadows() { return false; }\n    constructor(view, model) {\n        super();\n        this.model = model;\n        this._id = {\n            modelId: model.id,\n            is3d: model.is3d,\n            treeId: this.createTreeId(),\n            isPlanProjection: isPlanProjection(view, model),\n        };\n        this._owner = primaryTreeSupplier.getOwner(this._id, model.iModel);\n    }\n    get treeOwner() {\n        const newId = this.createTreeId();\n        if (0 !== compareIModelTileTreeIds(newId, this._id.treeId)) {\n            this._id = { modelId: this._id.modelId, is3d: this._id.is3d, treeId: newId, isPlanProjection: false };\n            this._owner = primaryTreeSupplier.getOwner(this._id, this.model.iModel);\n        }\n        return this._owner;\n    }\n    createTreeId() {\n        return { type: BatchType.Primary, edges: false };\n    }\n}\n/** @internal */\nexport function createMaskTreeReference(view, model) {\n    return new MaskTreeReference(view, model);\n}\n/** @internal */\nexport class ModelMapLayerTileTreeReference extends MapLayerTileTreeReference {\n    get isPlanar() { return true; }\n    get activeClassifier() { return this._classifier; }\n    constructor(layerSettings, _classifier, layerIndex, iModel, _source) {\n        super(layerSettings, layerIndex, iModel);\n        this._classifier = _classifier;\n        this._source = _source;\n        this._id = {\n            modelId: _classifier.modelId,\n            is3d: true,\n            treeId: this.createTreeId(),\n            isPlanProjection: false, // isPlanProjection(view, model),\n        };\n        this._owner = primaryTreeSupplier.getOwner(this._id, this.iModel);\n    }\n    createTreeId() {\n        return { type: BatchType.Primary, edges: false };\n    }\n    get treeOwner() {\n        const newId = this.createTreeId();\n        if (0 !== compareIModelTileTreeIds(newId, this._id.treeId)) {\n            this._id = { modelId: this._id.modelId, is3d: this._id.is3d, treeId: newId, isPlanProjection: false };\n            this._owner = primaryTreeSupplier.getOwner(this._id, this.iModel);\n        }\n        return this._owner;\n    }\n    get viewFlags() {\n        return {\n            renderMode: RenderMode.SmoothShade,\n            transparency: true,\n            textures: true,\n            lighting: false,\n            shadows: false,\n            monochrome: false,\n            materials: false,\n            ambientOcclusion: false,\n            visibleEdges: true,\n            hiddenEdges: false,\n            fill: true,\n        };\n    }\n}\n/** @internal */\nexport function createModelMapLayerTileTreeReference(layerSettings, layerIndex, iModel) {\n    const classifier = SpatialClassifier.fromModelMapLayer(layerSettings);\n    return classifier ? new ModelMapLayerTileTreeReference(layerSettings, classifier, layerIndex, iModel) : undefined;\n}\n/** Provides [[TileTreeReference]]s for the loaded models present in a [[SpatialViewState]]'s [[ModelSelectorState]].\n * @internal\n */\nexport var SpatialTileTreeReferences;\n(function (SpatialTileTreeReferences) {\n    /** Create a SpatialTileTreeReferences object reflecting the contents of the specified view. */\n    function create(view) {\n        return new SpatialRefs(view);\n    }\n    SpatialTileTreeReferences.create = create;\n})(SpatialTileTreeReferences || (SpatialTileTreeReferences = {}));\n/** Represents the [[TileTreeReference]]s associated with one model in a [[SpatialTileTreeReferences]]. */\nclass SpatialModelRefs {\n    constructor(model, view) {\n        /** TileTreeReferences representing nodes transformed by the view's schedule script. */\n        this._animatedRefs = [];\n        this._modelRef = model.createTileTreeReference(view);\n        this._isPrimaryRef = this._modelRef instanceof PrimaryTreeReference;\n    }\n    *[Symbol.iterator]() {\n        if (!this._primaryRef || !this._primaryRef.deactivated)\n            yield this._modelRef;\n        for (const animated of this._animatedRefs)\n            if (!animated.deactivated)\n                yield animated;\n        if (this._sectionCutRef && !this._sectionCutRef.deactivated)\n            yield this._sectionCutRef;\n    }\n    updateAnimated(script) {\n        const ref = this._primaryRef;\n        if (!ref)\n            return;\n        this._animatedRefs.length = 0;\n        const nodeIds = script?.script.getTransformBatchIds(ref.model.id);\n        if (nodeIds)\n            for (const nodeId of nodeIds)\n                this._animatedRefs.push(new AnimatedTreeReference(ref.view, ref.model, nodeId));\n    }\n    updateSectionCut(clip) {\n        const ref = this._primaryRef;\n        if (!ref) {\n            assert(undefined === this._sectionCutRef);\n            return;\n        }\n        // If the clip isn't supposed to apply to this model, don't produce cut geometry.\n        const vfJson = clip ? ref.model.jsonProperties.viewFlagOverrides : undefined;\n        const vfOvrs = vfJson ? { ...vfJson } : undefined;\n        if (vfOvrs && !vfOvrs.clipVolume)\n            clip = undefined;\n        this._sectionCutRef = clip ? createTreeRef(ref.view, ref.model, clip) : undefined;\n    }\n    setDeactivated(deactivated, which) {\n        if (typeof which !== \"string\") {\n            for (const index of which)\n                if (this._animatedRefs[index])\n                    this._animatedRefs[index].deactivated = deactivated ?? !this._animatedRefs[index].deactivated;\n            return;\n        }\n        if ((\"all\" === which || \"primary\" === which) && this._primaryRef)\n            this._primaryRef.deactivated = deactivated ?? !this._primaryRef.deactivated;\n        if ((\"all\" === which || \"section\" === which) && this._sectionCutRef)\n            this._sectionCutRef.deactivated = deactivated ?? !this._sectionCutRef.deactivated;\n        if ((\"all\" === which || \"animated\" === which))\n            for (const ref of this._animatedRefs)\n                ref.deactivated = deactivated ?? !ref.deactivated;\n    }\n    get _primaryRef() {\n        if (!this._isPrimaryRef)\n            return undefined;\n        assert(this._modelRef instanceof PrimaryTreeReference);\n        return this._modelRef;\n    }\n}\n/** Provides [[TileTreeReference]]s for the loaded models present in a [[SpatialViewState]]'s [[ModelSelectorState]]. */\nclass SpatialRefs {\n    constructor(view) {\n        this._allLoaded = false;\n        this._refs = new Map();\n        this._swapRefs = new Map();\n        this._view = view;\n        this._scheduleScript = view.displayStyle.scheduleScriptReference; // eslint-disable-line deprecation/deprecation\n        this._sectionCut = this.getSectionCutFromView();\n    }\n    update() {\n        this._allLoaded = false;\n    }\n    attachToViewport() { }\n    detachFromViewport() { }\n    *[Symbol.iterator]() {\n        this.load();\n        for (const modelRef of this._refs.values())\n            for (const ref of modelRef)\n                yield ref;\n    }\n    setDeactivated(modelIds, deactivated, refs) {\n        if (undefined === modelIds) {\n            for (const model of this._refs.values())\n                model.setDeactivated(deactivated, refs);\n            return;\n        }\n        if (typeof modelIds === \"string\")\n            modelIds = [modelIds];\n        for (const modelId of modelIds)\n            this._refs.get(modelId)?.setDeactivated(deactivated, refs);\n    }\n    load() {\n        if (!this._allLoaded) {\n            this._allLoaded = true;\n            this.updateModels();\n        }\n        const curScript = this._view.displayStyle.scheduleScriptReference; // eslint-disable-line deprecation/deprecation\n        const prevScript = this._scheduleScript;\n        if (curScript !== prevScript) {\n            this._scheduleScript = curScript;\n            if (!curScript || !prevScript || !curScript.script.equals(prevScript.script))\n                for (const ref of this._refs.values())\n                    ref.updateAnimated(curScript);\n        }\n        const sectionCut = this.getSectionCutFromView();\n        if (sectionCut?.clipString !== this._sectionCut?.clipString) {\n            this._sectionCut = sectionCut;\n            for (const ref of this._refs.values())\n                ref.updateSectionCut(sectionCut);\n        }\n    }\n    getSectionCutFromView() {\n        const wantCut = this._view.viewFlags.clipVolume && this._view.displayStyle.settings.clipStyle.produceCutGeometry;\n        const clip = wantCut ? this._view.getViewClip() : undefined;\n        return StringifiedClipVector.fromClipVector(clip);\n    }\n    /** Ensure this._refs contains a SpatialModelRefs for all loaded models in the model selector. */\n    updateModels() {\n        const prev = this._refs;\n        const cur = this._swapRefs;\n        this._refs = cur;\n        this._swapRefs = prev;\n        cur.clear();\n        for (const modelId of this._view.modelSelector.models) {\n            let modelRefs = prev.get(modelId);\n            if (!modelRefs) {\n                const model = this._view.iModel.models.getLoaded(modelId)?.asGeometricModel3d;\n                if (model) {\n                    modelRefs = new SpatialModelRefs(model, this._view);\n                    modelRefs.updateAnimated(this._scheduleScript);\n                    modelRefs.updateSectionCut(this._sectionCut);\n                }\n            }\n            if (modelRefs)\n                cur.set(modelId, modelRefs);\n        }\n    }\n}\n//# sourceMappingURL=PrimaryTileTree.js.map",
      "start": 1693508122061,
      "end": 1693508122240,
      "sourcemaps": null
    }
  ]
}
