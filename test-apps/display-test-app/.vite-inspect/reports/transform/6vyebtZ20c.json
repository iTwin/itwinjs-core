{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/PlanarClassification.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Matrix4d } from \"@itwin/core-geometry\";\nimport { SpatialClassifierInsideDisplay } from \"@itwin/core-common\";\nimport { Matrix4 } from \"../Matrix\";\nimport { PlanarClassifierContent } from \"../PlanarClassifier\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { addShaderFlags, addUInt32s } from \"./Common\";\nimport { addClassifierFlash } from \"./FeatureSymbology\";\nimport { addWindowToTexCoords } from \"./Fragment\";\nimport { addInstancedRtcMatrix } from \"./Vertex\";\nexport const volClassOpaqueColor = `\r\nvec4 volClassColor(vec4 baseColor, float depth) {\r\n  if (depth <= TEXTURE(s_pClassSampler, windowCoordsToTexCoords(gl_FragCoord.xy)).r)\r\n    discard;\r\n  return vec4(baseColor.rgb, 1.0);\r\n}\r\n`;\nconst volClassTranslucentColor = `\r\nvec4 volClassColor(vec4 baseColor, float depth) {\r\n  return vec4(baseColor.rgb, depth); // This will never be called, so we use depth here to avoid a compile error\r\n}\r\n`;\nconst applyPlanarClassificationPrelude = `\r\nconst float dimScale = .7;\r\n\r\nvec2 classPos = v_pClassPos.xy / v_pClassPosW;\r\nbool isOutside = classPos.x < 0.0 || classPos.x > 1.0 || classPos.y < 0.0 || classPos.y > 1.0;\r\nif (u_pClassColorParams.x > kClassifierDisplay_Element) { // texture/terrain drape.\r\n  if (u_pClassColorParams.x > kTextureDrape) {\r\n    return volClassColor(baseColor, depth);\r\n  }\r\n  if (isOutside)\r\n    discard;\r\n\r\n  vec3 rgb = TEXTURE(s_pClassSampler, classPos.xy).rgb;\r\n  return vec4(rgb, baseColor.a);\r\n}\r\nfloat imageCount = u_pClassColorParams.z;\r\n// If imageCount is less than zero - the mask sense is inverted - inside rather than outside.  (masks only)\r\nbool doInvert = false;\r\nif (imageCount < 0.0) {\r\n  imageCount = - imageCount;\r\n  doInvert = true;\r\n}\r\n\r\nvec4 colorTexel = vec4(0);\r\nvec4 maskTexel = vec4(0);\r\nbool doMask = imageCount != kTextureContentClassifierOnly;\r\nbool doClassify = imageCount != kTextureContentMaskOnly;\r\n\r\nif (!isOutside) {\r\n  if (imageCount == kTextureContentClassifierOnly) {\r\n    colorTexel = TEXTURE(s_pClassSampler, vec2(classPos.x, classPos.y / imageCount));\r\n  } else if (imageCount == kTextureContentMaskOnly) {\r\n    maskTexel = TEXTURE(s_pClassSampler, vec2(classPos.x, classPos.y));\r\n  } else if (imageCount == kTextureContentClassifierAndMask) {\r\n    colorTexel = TEXTURE(s_pClassSampler, vec2(classPos.x, classPos.y / imageCount));\r\n    maskTexel = TEXTURE(s_pClassSampler, vec2(classPos.x, (2.0 + classPos.y) / imageCount));\r\n  }\r\n  if (colorTexel.b >= 0.5) {\r\n    if (u_shaderFlags[kShaderBit_IgnoreNonLocatable]) {\r\n      discard;\r\n      return vec4(0.0);\r\n    }\r\n    colorTexel.b = (colorTexel.b * 255.0 - 128.0) / 127.0;\r\n  } else {\r\n    colorTexel.b *= 255.0 / 127.0;\r\n  }\r\n}\r\nif (doMask) {\r\n  bool masked = !isOutside && (maskTexel.r + maskTexel.g + maskTexel.b + maskTexel.a) > 0.0;\r\n  if (doInvert)\r\n    masked = !masked;\r\n  if (masked) {\r\n    float   maskTransparency = u_pClassColorParams.w < 0.0 ? (1.0 - maskTexel.a) : u_pClassColorParams.w;\r\n    if (maskTransparency <= 0.0) {\r\n      discard;\r\n      return vec4(0);\r\n      }\r\n\r\n    baseColor.a = baseColor.a * maskTransparency;\r\n   }\r\n\r\n  if (!doClassify)\r\n    return baseColor;\r\n  }\r\n\r\n  bool isClassified = !isOutside && (colorTexel.r + colorTexel.g + colorTexel.b + colorTexel.a > 0.0);\r\n  float param = isClassified ? u_pClassColorParams.x : u_pClassColorParams.y;\r\n  if (kClassifierDisplay_Off == param) {\r\n    discard;\r\n    return vec4(0);\r\n}\r\n`;\n// Currently we discard if classifier is pure black (acts as clipping mask).\n// These could be more efficiently handled with masks.\nconst applyPlanarClassificationColor = applyPlanarClassificationPrelude + // eslint-disable-line prefer-template\n    `\r\n  float colorMix = u_pClassPointCloud ? .65 : .35;\r\n  vec4 classColor;\r\n  if (kClassifierDisplay_On == param)\r\n    classColor = baseColor;\r\n  else if (!isClassified || kClassifierDisplay_Dimmed == param)\r\n    classColor = vec4(baseColor.rgb * dimScale, baseColor.a);\r\n  else if (kClassifierDisplay_Hilite == param)\r\n    classColor = vec4(mix(baseColor.rgb, u_hilite_settings[0], u_hilite_settings[2][0]), baseColor.a);\r\n  else {\r\n    if (colorTexel.b > colorTexel.a) {\r\n      discard;\r\n      return vec4(0.0);\r\n    }\r\n\r\n    // NB: colorTexel contains pre-multiplied alpha. We know it is greater than zero from above.\r\n    float alpha = colorTexel.a * baseColor.a;\r\n    vec3 rgb = colorTexel.rgb / colorTexel.a;\r\n    rgb = mix(baseColor.rgb, rgb, colorMix);\r\n    classColor = vec4(rgb, alpha);\r\n  }\r\n\r\n  if (kClassifierDisplay_Element != param && isClassified) {\r\n    if (colorTexel.r > colorTexel.a && kClassifierDisplay_Hilite != param)\r\n      classColor = vec4(mix(baseColor.rgb, u_hilite_settings[0], u_hilite_settings[2][0]), 1.0);\r\n\r\n    if (colorTexel.g > colorTexel.a)\r\n      classColor = applyClassifierFlash(classColor);\r\n  }\r\n\r\n  return classColor;\r\n`;\nconst applyPlanarClassificationColorForThematic = applyPlanarClassificationPrelude + // eslint-disable-line prefer-template\n    `\r\n  vec4 classColor = baseColor;\r\n\r\n  if (kClassifierDisplay_Element == param) {\r\n    if (colorTexel.b > colorTexel.a) {\r\n      discard;\r\n      return vec4(0.0);\r\n    }\r\n\r\n    // We stashed the element alpha in blue channel. Make sure to handle pre-multiplied alpha.\r\n    baseColor.rgb = baseColor.rgb / baseColor.a;\r\n    classColor = vec4(baseColor.rgb, colorTexel.b);\r\n    classColor.rgb *= classColor.a;\r\n    colorTexel.a = 0.5; // make conditions below potentially pass\r\n  }\r\n\r\n  if (isClassified) {\r\n    if (colorTexel.r > colorTexel.a && kClassifierDisplay_Hilite != param)\r\n      classColor = vec4(mix(baseColor.rgb, u_hilite_settings[0], u_hilite_settings[2][0]), 1.0);\r\n\r\n    if (colorTexel.g > colorTexel.a)\r\n      classColor = applyClassifierFlash(classColor);\r\n  }\r\n\r\n  return classColor;\r\n`;\nconst overrideFeatureId = `\r\n  if (u_pClassColorParams.x > kClassifierDisplay_Element) return currentId;\r\n  vec2 classPos = v_pClassPos / v_pClassPosW;\r\n  vec4 featureTexel = TEXTURE(s_pClassSampler, vec2(classPos.x, (1.0 + classPos.y) /  u_pClassColorParams.z));\r\n  return (featureTexel == vec4(0)) ? currentId : addUInt32s(u_batchBase, featureTexel * 255.0) / 255.0;\r\n  `;\nconst computeClassifiedHiliteColor = `\r\n  vec2 classPos = v_pClassPos / v_pClassPosW;\r\n  return TEXTURE(s_pClassHiliteSampler, classPos);\r\n`;\nconst computeClassifiedSurfaceHiliteColor = `\r\n  if (isSurfaceBitSet(kSurfaceBit_HasTexture) && TEXTURE(s_texture, v_texCoord).a <= 0.15)\r\n    return vec4(0.0);\r\n${computeClassifiedHiliteColor}`;\nconst computeClassifierPos = \"vec4 classProj = u_pClassProj * rawPosition; v_pClassPos = classProj.xy;\";\nconst computeInstancedClassifierPos = \"vec4 classProj = u_pClassProj * g_instancedRtcMatrix * rawPosition; v_pClassPos = classProj.xy;\";\nconst computeClassifierPosW = \"v_pClassPosW = classProj.w;\";\nconst scratchBytes = new Uint8Array(4);\nconst scratchBatchBaseId = new Uint32Array(scratchBytes.buffer);\nconst scratchBatchBaseComponents = [0, 0, 0, 0];\nconst scratchColorParams = new Float32Array(4); // Unclassified scale, classified base scale, classified classifier scale, content/image count...  MaskOnly = 1, ClassifierOnly = 2, ClassifierAndMask = 3\nconst scratchModel = Matrix4d.createIdentity();\nconst scratchModelProjection = Matrix4d.createIdentity();\nconst scratchMatrix = new Matrix4();\nfunction addPlanarClassifierCommon(builder) {\n    const vert = builder.vert;\n    vert.addUniform(\"u_pClassProj\", 7 /* VariableType.Mat4 */, (prog) => {\n        prog.addGraphicUniform(\"u_pClassProj\", (uniform, params) => {\n            const source = params.target.currentPlanarClassifierOrDrape;\n            assert(undefined !== source || undefined !== params.target.activeVolumeClassifierTexture);\n            if (undefined !== params.target.currentPlanarClassifierOrDrape) {\n                source.projectionMatrix.multiplyMatrixMatrix(Matrix4d.createTransform(params.target.currentTransform, scratchModel), scratchModelProjection);\n                scratchMatrix.initFromMatrix4d(scratchModelProjection);\n            }\n            else\n                scratchMatrix.initIdentity(); // needs to be identity for volume classifiers\n            uniform.setMatrix4(scratchMatrix);\n        });\n    });\n    if (vert.usesInstancedGeometry)\n        addInstancedRtcMatrix(vert);\n    builder.addInlineComputedVarying(\"v_pClassPos\", 3 /* VariableType.Vec2 */, vert.usesInstancedGeometry ? computeInstancedClassifierPos : computeClassifierPos);\n    builder.addInlineComputedVarying(\"v_pClassPosW\", 2 /* VariableType.Float */, computeClassifierPosW);\n    addPlanarClassifierConstants(builder.frag);\n}\nfunction addPlanarClassifierConstants(builder) {\n    builder.addDefine(\"kClassifierDisplay_Off\", SpatialClassifierInsideDisplay.Off.toFixed(1));\n    builder.addDefine(\"kClassifierDisplay_On\", SpatialClassifierInsideDisplay.On.toFixed(1));\n    builder.addDefine(\"kClassifierDisplay_Dimmed\", SpatialClassifierInsideDisplay.Dimmed.toFixed(1));\n    builder.addDefine(\"kClassifierDisplay_Hilite\", SpatialClassifierInsideDisplay.Hilite.toFixed(1));\n    builder.addDefine(\"kClassifierDisplay_Element\", SpatialClassifierInsideDisplay.ElementColor.toFixed(1));\n    const td = SpatialClassifierInsideDisplay.ElementColor + 1;\n    builder.addDefine(\"kTextureDrape\", td.toFixed(1));\n    builder.addDefine(\"kTextureContentClassifierOnly\", PlanarClassifierContent.ClassifierOnly.toFixed(1));\n    builder.addDefine(\"kTextureContentMaskOnly\", PlanarClassifierContent.MaskOnly.toFixed(1));\n    builder.addDefine(\"kTextureContentClassifierAndMask\", PlanarClassifierContent.ClassifierAndMask.toFixed(1));\n}\n/** @internal */\nexport function addColorPlanarClassifier(builder, translucent, isThematic) {\n    addPlanarClassifierCommon(builder);\n    const frag = builder.frag;\n    frag.addUniform(\"s_pClassSampler\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_pClassSampler\", (uniform, params) => {\n            const source = params.target.currentPlanarClassifierOrDrape;\n            const volClass = params.target.activeVolumeClassifierTexture;\n            assert(undefined !== source || undefined !== volClass);\n            if (source) {\n                assert(undefined !== source.texture);\n                source.texture.texture.bindSampler(uniform, TextureUnit.PlanarClassification);\n            }\n            else\n                Texture2DHandle.bindSampler(uniform, volClass, TextureUnit.PlanarClassification);\n        });\n    });\n    frag.addUniform(\"u_pClassColorParams\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_pClassColorParams\", (uniform, params) => {\n            const source = params.target.currentPlanarClassifierOrDrape;\n            const volClass = params.target.activeVolumeClassifierTexture;\n            assert(undefined !== source || undefined !== volClass);\n            if (undefined !== source) {\n                source.getParams(scratchColorParams);\n            }\n            else {\n                scratchColorParams[0] = 6.0; // Volume classifier, by element color.\n                scratchColorParams[1] = 0.5; // used for alpha value\n                scratchColorParams[2] = 0.0; // Not used for volume.\n                scratchColorParams[3] = 0.0; // Not used for volume.\n            }\n            uniform.setUniform4fv(scratchColorParams);\n        });\n    });\n    if (isThematic === 0 /* IsThematic.No */) {\n        frag.addUniform(\"u_pClassPointCloud\", 0 /* VariableType.Boolean */, (prog) => {\n            prog.addGraphicUniform(\"u_pClassPointCloud\", (uniform, params) => {\n                const classifier = params.target.currentPlanarClassifier;\n                const isPointCloud = undefined !== classifier && classifier.isClassifyingPointCloud;\n                uniform.setUniform1i(isPointCloud ? 1 : 0);\n            });\n        });\n    }\n    addClassifierFlash(frag);\n    if (translucent)\n        // We will never call the shaders for volume classifiers with translucency,\n        // so use a different version of the function which does not use glFragCoord to reduce the varyings count\n        frag.addFunction(volClassTranslucentColor);\n    else {\n        addWindowToTexCoords(frag);\n        frag.addFunction(volClassOpaqueColor);\n    }\n    addShaderFlags(builder);\n    frag.set(12 /* FragmentShaderComponent.ApplyPlanarClassifier */, (isThematic === 0 /* IsThematic.No */) ? applyPlanarClassificationColor : applyPlanarClassificationColorForThematic);\n}\n/** @internal */\nexport function addFeaturePlanarClassifier(builder) {\n    const frag = builder.frag;\n    frag.addUniform(\"u_batchBase\", 5 /* VariableType.Vec4 */, (prog) => {\n        prog.addGraphicUniform(\"u_batchBase\", (uniform, params) => {\n            const classifier = params.target.currentPlanarClassifier;\n            if (classifier !== undefined) {\n                scratchBatchBaseId[0] = classifier.baseBatchId;\n                scratchBatchBaseComponents[0] = scratchBytes[0];\n                scratchBatchBaseComponents[1] = scratchBytes[1];\n                scratchBatchBaseComponents[2] = scratchBytes[2];\n                scratchBatchBaseComponents[3] = scratchBytes[3];\n            }\n            uniform.setUniform4fv(scratchBatchBaseComponents);\n        });\n    });\n    frag.set(17 /* FragmentShaderComponent.OverrideFeatureId */, overrideFeatureId);\n    frag.addFunction(addUInt32s);\n}\n/** @internal */\nexport function addHilitePlanarClassifier(builder, supportTextures = true) {\n    addPlanarClassifierCommon(builder);\n    const frag = builder.frag;\n    frag.addUniform(\"s_pClassHiliteSampler\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addGraphicUniform(\"s_pClassHiliteSampler\", (uniform, params) => {\n            const classifier = params.target.currentPlanarClassifier;\n            assert(undefined !== classifier && undefined !== classifier.hiliteTexture);\n            classifier.hiliteTexture.texture.bindSampler(uniform, TextureUnit.PlanarClassificationHilite);\n        });\n    });\n    frag.set(1 /* FragmentShaderComponent.ComputeBaseColor */, supportTextures ? computeClassifiedSurfaceHiliteColor : computeClassifiedHiliteColor);\n}\n// NonLocatable flag is put in upper bit of blue component when drawing the classification texture.\nconst encodeNonLocatableWithFeatures = `\r\nvec4 encodeNonLocatable(vec4 clr) {\r\n  float encoded_b = (floor(clr.b * 127.0) + float(extractNthBit(floor(v_feature_emphasis + 0.5), kEmphBit_NonLocatable)) * 128.0) / 255.0;\r\n  return vec4(clr.r, clr.g, encoded_b, clr.a);\r\n}\r\n`;\nconst encodeNonLocatable = `\r\nvec4 encodeNonLocatable(vec4 clr) {\r\n  float encoded_b = floor(clr.b * 127.0) / 255.0;\r\n  return vec4(clr.r, clr.g, encoded_b, clr.a);\r\n}\r\n`;\nconst overrideClassifierColorPrelude = `\r\n  if (0.0 == u_planarClassifierInsideMode)\r\n    return currentColor;\r\n\r\n  if (0.0 == currentColor.a)\r\n    return encodeNonLocatable(vec4(0.0, 0.0, 1.0, 0.5));\r\n`;\nconst overrideClassifierEmphasis = `\r\n  if (kClassifierDisplay_Element != u_planarClassifierInsideMode) {\r\n    float emph = floor(v_feature_emphasis + 0.5);\r\n    if (0.0 != emph)\r\n      return encodeNonLocatable(vec4(extractNthBit(emph, kEmphBit_Hilite), extractNthBit(emph, kEmphBit_Flash), 0.0, 0.5));\r\n  }\r\n`;\nconst overrideClassifierColorPostlude = `\r\n  return encodeNonLocatable(currentColor);\r\n`;\nconst overrideClassifierWithFeatures = overrideClassifierColorPrelude + overrideClassifierEmphasis + overrideClassifierColorPostlude;\nconst overrideClassifierForClip = overrideClassifierColorPrelude + overrideClassifierColorPostlude;\nconst overrideClassifierColorPreludeForThematic = `\r\n  if (0.0 == u_planarClassifierInsideMode)\r\n    return currentColor;\r\n\r\n  if (0.0 == currentColor.a)\r\n    return encodeNonLocatable(vec4(0.0, 0.0, 1.0, 0.5));\r\n\r\n  bool isElem = kClassifierDisplay_Element == u_planarClassifierInsideMode;\r\n`;\nconst overrideClassifierEmphasisForThematic = `\r\n  float emph = floor(v_feature_emphasis + 0.5);\r\n  if (0.0 != emph)\r\n    return encodeNonLocatable(vec4(extractNthBit(emph, kEmphBit_Hilite), extractNthBit(emph, kEmphBit_Flash), isElem ? currentColor.a : 0.0, isElem ? 1.0 : 0.5));\r\n  else if (kClassifierDisplay_Element == u_planarClassifierInsideMode)\r\n    return encodeNonLocatable(vec4(0.0, 0.0, currentColor.a, 1.0));\r\n`;\n// Thematic classifiers use alpha of 1 to blend; we just want thematic colors to largely win out except when selecting and flashing classifiers.\nconst overrideClassifierColorPostludeClipForThematic = `\r\n  return encodeNonLocatable(isElem ? vec4(0.0, 0.0, 1.0, 1.0) : currentColor);\r\n`;\nconst overrideClassifierWithFeaturesForThematic = overrideClassifierColorPreludeForThematic + overrideClassifierEmphasisForThematic + overrideClassifierColorPostlude;\nconst overrideClassifierForClipForThematic = overrideClassifierColorPreludeForThematic + overrideClassifierColorPostludeClipForThematic;\n/** The classified geometry needs some information about the classifier geometry. The classified fragment shader outputs special values that do not represent valid RGB+A combinations when using\n * pre-multiplied alpha. The alpha channel will be 0.5, and the red, green, and/or blue channels will be 1.0:\n * - Red: hilited.\n * - Green: flashed.\n * - Blue: fully-transparent. Indicates clipping mask (discard the classified pixel).\n * @internal\n */\nexport function addOverrideClassifierColor(builder, isThematic) {\n    addPlanarClassifierConstants(builder.frag);\n    builder.frag.addUniform(\"u_planarClassifierInsideMode\", 2 /* VariableType.Float */, (prog) => {\n        prog.addGraphicUniform(\"u_planarClassifierInsideMode\", (uniform, params) => {\n            const classifier = params.target.currentlyDrawingClassifier;\n            const override = undefined !== classifier ? classifier.insideDisplay : 0;\n            uniform.setUniform1f(override);\n        });\n    });\n    const haveOverrides = undefined !== builder.frag.find(\"v_feature_emphasis\");\n    builder.frag.addFunction(haveOverrides ? encodeNonLocatableWithFeatures : encodeNonLocatable);\n    if (isThematic === 0 /* IsThematic.No */)\n        builder.frag.set(19 /* FragmentShaderComponent.OverrideColor */, haveOverrides ? overrideClassifierWithFeatures : overrideClassifierForClip);\n    else\n        builder.frag.set(19 /* FragmentShaderComponent.OverrideColor */, haveOverrides ? overrideClassifierWithFeaturesForThematic : overrideClassifierForClipForThematic);\n}\n//# sourceMappingURL=PlanarClassification.js.map",
      "start": 1693508126518,
      "end": 1693508126591,
      "sourcemaps": null
    }
  ]
}
