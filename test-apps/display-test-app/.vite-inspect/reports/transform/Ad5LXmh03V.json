{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/IndexedEdgeMatcher.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\n/**\n * * For boundary sorting, an edge is a (packed!) Float64Array.\n * * Fixed entry positions are:\n *   * [0] is start vertex index (in CCW order around its facet)\n *   * [1] is end vertex index (in CCW order around its facet)\n *   * [2] is facet index.\n */\nexport class SortableEdge extends Float64Array {\n    /** Return the vertex index that appears first in the order stored.  */\n    get vertexIndexA() { return this[0]; }\n    /** Return the vertex index that appears second in the order stored.  */\n    get vertexIndexB() { return this[1]; }\n    /** Return the facet index.  */\n    get facetIndex() { return this[2]; }\n    /** return true if vertexIndexA is less than vertexIndexB */\n    get isLowHigh() { return this[0] < this[1]; }\n    /** Return the vertex index with lower numeric value */\n    get lowVertexIndex() { return this[0] < this[1] ? this[0] : this[1]; }\n    /** Return the vertex index with higher numeric value */\n    get highVertexIndex() { return this[0] > this[1] ? this[0] : this[1]; }\n    /** Return true if the vertices edgeA and edgeB are the same vertex indices in opposite order */\n    static areDirectedPartners(edgeA, edgeB) { return edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]; }\n    /** Return true if the vertices edgeA and edgeB are the same vertex indices with no consideration of order */\n    static areUndirectedPartners(edgeA, edgeB) {\n        return (edgeA[0] === edgeB[0] && edgeA[1] === edgeB[1]) || ((edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]));\n    }\n    /** Return numeric relationship of edgeA and edgeB:\n     * * 1 if they share start and end in the same order\n     * * -1 if they share start and end in reversed order\n     * * 0 otherwise.\n     */\n    static relativeOrientation(edgeA, edgeB) {\n        if (edgeA[0] === edgeB[0] && edgeA[1] === edgeB[1])\n            return 1;\n        if (edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0])\n            return -1;\n        return 0;\n    }\n    get isNullEdge() { return this[0] === this[1]; }\n    /**\n     * lexical comparison of two edges.\n     * * If the edges have the same vertex pair (in same or opposite order) they will end up adjacent in a sort\n     * * If the edges have 0 or 1 shared vertex indices, the one with lowest low comes first.\n     * @param edgeA first edge\n     * @param edgeB second edge\n     */\n    static lessThan(edgeA, edgeB) {\n        // primary compare is based on indirect indices\n        const lowA = edgeA.lowVertexIndex;\n        const lowB = edgeB.lowVertexIndex;\n        if (lowA < lowB)\n            return -1;\n        if (lowB < lowA)\n            return 1;\n        const highA = edgeA.highVertexIndex;\n        const highB = edgeB.highVertexIndex;\n        if (highA < highB)\n            return -1;\n        if (highB < highA)\n            return 1;\n        // undirected indices match ... use directed vertexIndexA\n        return edgeA.vertexIndexA - edgeB.vertexIndexA;\n    }\n    constructor(vertexA, vertexB, facetIndex) {\n        super(3);\n        this[0] = vertexA;\n        this[1] = vertexB;\n        this[2] = facetIndex;\n    }\n    toJSON() { return [this[0], this[1], this[2]]; }\n    static clusterToJSON(data) {\n        if (data instanceof SortableEdge)\n            return data.toJSON();\n        const result = [];\n        for (const edge of data)\n            result.push(edge.toJSON());\n    }\n    static clusterArrayToJSON(data) {\n        const result = [];\n        for (const cluster of data)\n            result.push(SortableEdge.clusterToJSON(cluster));\n        return result;\n    }\n}\n/**\n * An IndexedEdgeMatcher carries an array (`edges`) of edges start & end indices for sorting and subsequent analyses (such as testing for closed mesh)\n */\nexport class IndexedEdgeMatcher {\n    constructor() {\n        this.edges = [];\n    }\n    /**\n     * push a new edge.\n     * @returns the edge (as emplaced at the back of the sortableEdge array)\n     * @param vertexA start vertex\n     * @param vertexB end vertex\n     * @param facetIndex facet index\n     */\n    addEdge(vertexA, vertexB, facetIndex) {\n        const edge = new SortableEdge(vertexA, vertexB, facetIndex);\n        this.edges.push(edge);\n        return edge;\n    }\n    /**\n     * Push edges all around a facet, returning to vertexArray[0]\n     * @param vertexArray array of vertex indices around facet\n     * @param facetIndex\n     */\n    addPath(vertexArray, facetIndex, closeLoop = true) {\n        if (vertexArray.length === 0)\n            return;\n        const m = vertexArray.length - 1;\n        for (let i = 0; i < m; i++) {\n            this.addEdge(vertexArray[i], vertexArray[i + 1], facetIndex);\n        }\n        if (closeLoop)\n            this.addEdge(vertexArray[m], vertexArray[0], facetIndex);\n    }\n    /** Sort the edge index array. */\n    sort() {\n        this.edges.sort((edgeA, edgeB) => SortableEdge.lessThan(edgeA, edgeB));\n    }\n    /** Create a single or compound SortableEdgeCluster in dest. */\n    collectSortableEdgeCluster(index0, index1, dest) {\n        if (dest !== undefined && index1 > index0) {\n            if (index1 === index0 + 1) {\n                dest.push(this.edges[index0]);\n            }\n            else {\n                const cluster = [];\n                for (let i = index0; i < index1; i++)\n                    cluster.push(this.edges[i]);\n                dest.push(cluster);\n            }\n        }\n    }\n    /**\n     * sort the edges, and look for three categories of paired edges:\n     * * caller must allocate all result arrays of interest.\n     * * Any combination of the result arrays may be `undefined`, indicating that category is to be ignored.\n     * * Any combination of the result arrays may be aliased as the same target, in which case those to categories are merged into the target.\n     * * For instance, to ignore manifold pairs and collect all others (singleton, null, and other) as a single array `allOther`, create `const allOther = []` as an empty array and call\n     * `sortAndCollectClusters (undefined, allOther, allOther, allOther);`\n     * @param manifoldPairs optional array to receive pairs of properly mated SortableEdgePairs, i.e. simple interior edges adjacent to two facets in opposing directions.\n     * @param singletons optional array to receive edges that are simple boundary edges.\n     * @param nullEdges optional array to receive arrays of null edges (same start and end vertex)\n     * @param allOtherClusters optional array to receive arrays in which all the edges are partners in an undirected sense but not a simple directed pair.\n     */\n    sortAndCollectClusters(manifoldPairs, singletons, nullEdges, allOtherClusters) {\n        this.sort();\n        if (manifoldPairs)\n            manifoldPairs.length = 0;\n        if (singletons)\n            singletons.length = 0;\n        if (nullEdges)\n            nullEdges.length = 0;\n        if (allOtherClusters)\n            allOtherClusters.length = 0;\n        const n = this.edges.length;\n        let clusterLength;\n        for (let index0 = 0; index0 < n; index0 += clusterLength) {\n            const baseEdge = this.edges[index0];\n            clusterLength = 1;\n            for (let index1 = index0 + 1; index1 < n && SortableEdge.areUndirectedPartners(baseEdge, this.edges[index1]); index1++) {\n                clusterLength++;\n            }\n            if (this.edges[index0].isNullEdge) {\n                this.collectSortableEdgeCluster(index0, index0 + clusterLength, nullEdges);\n            }\n            else if (clusterLength === 2 && SortableEdge.areDirectedPartners(baseEdge, this.edges[index0 + 1])) {\n                this.collectSortableEdgeCluster(index0, index0 + clusterLength, manifoldPairs);\n            }\n            else if (clusterLength === 1) {\n                this.collectSortableEdgeCluster(index0, index0 + 1, singletons);\n            }\n            else {\n                this.collectSortableEdgeCluster(index0, index0 + clusterLength, allOtherClusters);\n            }\n        }\n    }\n}\n//# sourceMappingURL=IndexedEdgeMatcher.js.map",
      "start": 1693508125471,
      "end": 1693508125557,
      "sourcemaps": null
    }
  ]
}
