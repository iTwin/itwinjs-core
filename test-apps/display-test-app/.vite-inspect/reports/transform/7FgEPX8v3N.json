{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BezierCurve3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\nimport { BezierCurveBase } from \"./BezierCurveBase\";\n// ================================================================================================================\n// ================================================================================================================\n// ================================================================================================================\n// ================================================================================================================\n/** 3d Bezier curve class.\n * * Use BezierCurve3dH if the curve has weights.\n * * The control points (xyz) are managed as the _packedData buffer in the _polygon member of BezierCurveBase.\n * @public\n */\nexport class BezierCurve3d extends BezierCurveBase {\n    /** test if `other` is also a BezierCurve3d. */\n    isSameGeometryClass(other) { return other instanceof BezierCurve3d; }\n    /** apply the transform to the control points. */\n    tryTransformInPlace(transform) {\n        const data = this._workData0;\n        for (let i = 0; i < this._polygon.order; i++) {\n            this._polygon.getPolygonPoint(i, data);\n            transform.multiplyXYZToFloat64Array(data[0], data[1], data[2], data);\n            this._polygon.setPolygonPoint(i, data);\n        }\n        return true;\n    }\n    /** Return a specific pole as a full `[x,y,z] Point3d` */\n    getPolePoint3d(i, result) {\n        const data = this._polygon.getPolygonPoint(i, this._workData0);\n        if (data)\n            return Point3d.create(data[0], data[1], data[2], result);\n        return undefined;\n    }\n    /** Return a specific pole as a full `[w*x,w*y,w*z, w] Point4d` */\n    getPolePoint4d(i, result) {\n        const data = this._polygon.getPolygonPoint(i, this._workData0);\n        if (data)\n            return Point4d.create(data[0], data[1], data[2], 1.0, result);\n        return undefined;\n    }\n    /**\n     * Capture a polygon as the data for a new `BezierCurve3d`\n     * @param polygon complete packed data and order.\n     */\n    constructor(polygon) {\n        super(3, polygon);\n        this._workRay0 = Ray3d.createXAxis();\n        this._workRay1 = Ray3d.createXAxis();\n    }\n    /** Return poles as a linestring */\n    copyPointsAsLineString() {\n        const result = LineString3d.create();\n        for (let i = 0; i < this._polygon.order; i++)\n            result.addPoint(this.getPolePoint3d(i));\n        return result;\n    }\n    /** Create a curve with given points.\n     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\n     * * If input is `Point3d[]`, the points are promoted with w=1`\n     *\n     */\n    static create(data) {\n        if (data.length < 1)\n            return undefined;\n        const polygon = new Float64Array(data.length * 3);\n        if (data[0] instanceof Point3d) {\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = p.z;\n            }\n            return new BezierCurve3d(polygon);\n        }\n        else if (data[0] instanceof Point2d) {\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = 0.0;\n            }\n            return new BezierCurve3d(polygon);\n        }\n        return undefined;\n    }\n    /** create a bezier curve of specified order, filled with zeros */\n    static createOrder(order) {\n        const polygonArray = new Float64Array(order * 3); // This is initialized to zeros!!\n        return new BezierCurve3d(polygonArray);\n    }\n    /** Load order * 3 doubles from data[3 * spanIndex] as poles */\n    loadSpanPoles(data, spanIndex) {\n        this._polygon.loadSpanPoles(data, spanIndex);\n    }\n    /** Clone as a bezier 3d. */\n    clone() {\n        return new BezierCurve3d(this._polygon.clonePolygon());\n    }\n    /** Return a (de-weighted) point on the curve. If de-weight fails, returns 000 */\n    fractionToPoint(fraction, result) {\n        this._polygon.evaluate(fraction, this._workData0);\n        return Point3d.create(this._workData0[0], this._workData0[1], this._workData0[2], result);\n    }\n    /** Return the cartesian point and derivative vector. */\n    fractionToPointAndDerivative(fraction, result) {\n        this._polygon.evaluate(fraction, this._workData0);\n        this._polygon.evaluateDerivative(fraction, this._workData1);\n        return Ray3d.createXYZUVW(this._workData0[0], this._workData0[1], this._workData0[2], this._workData1[0], this._workData1[1], this._workData1[2], result);\n    }\n    /** Construct a plane with\n     * * origin at the fractional position along the arc\n     * * x axis is the first derivative, i.e. tangent along the arc\n     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\n     * If the arc is circular, the second derivative is directly towards the center\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const epsilon = 1.0e-8;\n        const a = 1.0 / (2.0 * epsilon);\n        if (!result)\n            result = Plane3dByOriginAndVectors.createXYPlane();\n        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\n        result.origin.setFrom(ray.origin);\n        result.vectorU.setFrom(ray.direction);\n        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\n        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\n        Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\n        return result;\n    }\n    /** Near-equality test on poles. */\n    isAlmostEqual(other) {\n        if (other instanceof BezierCurve3d) {\n            return this._polygon.isAlmostEqual(other._polygon);\n        }\n        return false;\n    }\n    /** Second step of double dispatch:  call `handler.handleBezierCurve3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBezierCurve3d(this);\n    }\n    /** Extend `rangeToExtend`, using candidate extrema at\n     * * both end points\n     * * any internal extrema in x,y,z\n     */\n    extendRange(rangeToExtend, transform) {\n        const order = this.order;\n        if (!transform) {\n            this.allocateAndZeroBezierWorkData(order - 1, 0, 0);\n            const bezier = this._workBezier;\n            this.getPolePoint3d(0, this._workPoint0);\n            rangeToExtend.extend(this._workPoint0);\n            this.getPolePoint3d(order - 1, this._workPoint0);\n            rangeToExtend.extend(this._workPoint0);\n            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\n                BezierPolynomialAlgebra.componentDifference(bezier.coffs, this._polygon.packedData, 3, order, axisIndex);\n                const roots = bezier.roots(0.0, true);\n                if (roots) {\n                    for (const r of roots) {\n                        this.fractionToPoint(r, this._workPoint0);\n                        rangeToExtend.extend(this._workPoint0);\n                    }\n                }\n            }\n        }\n        else {\n            this.allocateAndZeroBezierWorkData(order - 1, order, 0);\n            const bezier = this._workBezier;\n            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.\n            this.getPolePoint3d(0, this._workPoint0);\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n            this.getPolePoint3d(order - 1, this._workPoint0);\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n            const data = this._polygon.packedData;\n            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\n                // apply one row of the transform to get the transformed coff by itself\n                for (let i = 0, k = 0; i < order; i++, k += 3)\n                    componentCoffs[i] = transform.multiplyComponentXYZ(axisIndex, data[k], data[k + 1], data[k + 2]);\n                BezierPolynomialAlgebra.univariateDifference(componentCoffs, bezier.coffs);\n                const roots = bezier.roots(0.0, true);\n                if (roots && roots.length > 0) {\n                    for (const r of roots) {\n                        this.fractionToPoint(r, this._workPoint0);\n                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=BezierCurve3d.js.map",
      "start": 1693508123821,
      "end": 1693508123961,
      "sourcemaps": null
    }
  ]
}
