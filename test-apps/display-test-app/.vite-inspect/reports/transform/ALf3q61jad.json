{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/render/primitives/DisplayParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, compareBooleans, compareNumbers, comparePossiblyUndefined, compareStringsOrUndefined } from \"@itwin/core-bentley\";\nimport { FillFlags, Gradient, LinePixels, TextureMapping } from \"@itwin/core-common\";\nfunction compareMaterials(lhs, rhs) {\n    return comparePossiblyUndefined((lhMat, rhMat) => lhMat === rhMat ? 0 : compareStringsOrUndefined(lhMat.key, rhMat.key), lhs, rhs);\n}\nfunction compareTextureMappings(_lhs, _rhs) {\n    // ###TODO we don't have a way of ordering the textures from the pattern/normal map(s) - not all textures have keys defined.\n    // For now this will only work if the GraphicBuilder uses a single material for all geometry.\n    // return comparePossiblyUndefined((lhTex: TextureMapping, rhTex: TextureMapping) => lhTex === rhTex ? 0 : compareStringsOrUndefined(lhTex.texture.key, rhTex.texture.key), lhs, rhs);\n    return 0;\n}\n/** This class is used to determine if things can be batched together for display.\n * @internal\n */\nclass DisplayParams {\n    constructor(type, lineColor, fillColor, width = 0, linePixels = LinePixels.Solid, fillFlags = FillFlags.None, material, gradient, ignoreLighting = false, textureMapping) {\n        this.type = DisplayParams.Type.Mesh;\n        this.type = type;\n        this.material = material;\n        this.gradient = gradient;\n        this.lineColor = DisplayParams.adjustTransparency(lineColor);\n        this.fillColor = DisplayParams.adjustTransparency(fillColor);\n        this.width = width;\n        this.linePixels = linePixels;\n        this.fillFlags = fillFlags;\n        this.ignoreLighting = ignoreLighting;\n        this._textureMapping = textureMapping;\n        assert(undefined === material || undefined === textureMapping);\n    }\n    /** Creates a DisplayParams object for a particular type (mesh, linear, text) based on the specified GraphicParams. */\n    static createForType(type, gf, resolveGradient, ignoreLighting = false) {\n        const lineColor = DisplayParams.adjustTransparency(gf.lineColor);\n        switch (type) {\n            case DisplayParams.Type.Mesh: {\n                let gradientMapping;\n                if (undefined !== gf.gradient && undefined !== resolveGradient) {\n                    const gradientTexture = resolveGradient(gf.gradient);\n                    if (undefined !== gradientTexture)\n                        gradientMapping = new TextureMapping(gradientTexture, new TextureMapping.Params());\n                }\n                return new DisplayParams(type, lineColor, DisplayParams.adjustTransparency(gf.fillColor), gf.rasterWidth, gf.linePixels, gf.fillFlags, gf.material, gf.gradient, ignoreLighting, gradientMapping);\n            }\n            case DisplayParams.Type.Linear:\n                return new DisplayParams(type, lineColor, lineColor, gf.rasterWidth, gf.linePixels);\n            default: // DisplayParams.Type.Text\n                return new DisplayParams(type, lineColor, lineColor, 0, LinePixels.Solid, FillFlags.Always, undefined, undefined, true);\n        }\n    }\n    /** Creates a DisplayParams object that describes mesh geometry based on the specified GraphicParams. */\n    static createForMesh(gf, ignoreLighting, resolveGradient) {\n        return DisplayParams.createForType(DisplayParams.Type.Mesh, gf, resolveGradient, ignoreLighting);\n    }\n    /** Creates a DisplayParams object that describes linear geometry based on the specified GraphicParams. */\n    static createForLinear(gf) {\n        return DisplayParams.createForType(DisplayParams.Type.Linear, gf);\n    }\n    /** Creates a DisplayParams object that describes text geometry based on the specified GraphicParams. */\n    static createForText(gf) {\n        return DisplayParams.createForType(DisplayParams.Type.Text, gf);\n    }\n    get regionEdgeType() {\n        if (this.hasBlankingFill)\n            return DisplayParams.RegionEdgeType.None;\n        if (this.gradient !== undefined && undefined !== this.gradient.flags) {\n            // Even if the gradient is not outlined, produce an outline to be displayed as the region's edges when fill ViewFlag is off.\n            const gradFlags = this.gradient.flags;\n            if (0 !== (gradFlags & Gradient.Flags.Outline) || FillFlags.None === (this.fillFlags & FillFlags.Always))\n                return DisplayParams.RegionEdgeType.Outline;\n            return DisplayParams.RegionEdgeType.None;\n        }\n        return (!this.fillColor.equals(this.lineColor)) ? DisplayParams.RegionEdgeType.Outline : DisplayParams.RegionEdgeType.Default;\n    }\n    get wantRegionOutline() {\n        return DisplayParams.RegionEdgeType.Outline === this.regionEdgeType;\n    }\n    get hasBlankingFill() { return FillFlags.Blanking === (this.fillFlags & FillFlags.Blanking); }\n    get hasFillTransparency() { return 255 !== this.fillColor.getAlpha(); }\n    get hasLineTransparency() { return 255 !== this.lineColor.getAlpha(); }\n    get textureMapping() { return undefined !== this.material ? this.material.textureMapping : this._textureMapping; }\n    get isTextured() { return undefined !== this.textureMapping; }\n    /** Determines if the properties of this DisplayParams object are equal to those of another DisplayParams object.  */\n    equals(rhs, purpose = DisplayParams.ComparePurpose.Strict) {\n        if (DisplayParams.ComparePurpose.Merge === purpose)\n            return 0 === this.compareForMerge(rhs);\n        else if (rhs === this)\n            return true;\n        if (this.type !== rhs.type)\n            return false;\n        if (this.ignoreLighting !== rhs.ignoreLighting)\n            return false;\n        if (this.width !== rhs.width)\n            return false;\n        if (this.linePixels !== rhs.linePixels)\n            return false;\n        if (this.fillFlags !== rhs.fillFlags)\n            return false;\n        if (this.wantRegionOutline !== rhs.wantRegionOutline)\n            return false;\n        if (this.material !== rhs.material)\n            return false;\n        if (this.textureMapping !== rhs.textureMapping)\n            return false;\n        if (!this.fillColor.equals(rhs.fillColor))\n            return false;\n        if (!this.lineColor.equals(rhs.lineColor))\n            return false;\n        return true;\n    }\n    compareForMerge(rhs) {\n        if (rhs === this)\n            return 0;\n        let diff = compareNumbers(this.type, rhs.type);\n        if (0 === diff) {\n            diff = compareBooleans(this.ignoreLighting, rhs.ignoreLighting);\n            if (0 === diff) {\n                diff = compareNumbers(this.width, rhs.width);\n                if (0 === diff) {\n                    diff = compareNumbers(this.linePixels, rhs.linePixels);\n                    if (0 === diff) {\n                        diff = compareNumbers(this.fillFlags, rhs.fillFlags);\n                        if (0 === diff) {\n                            diff = compareBooleans(this.wantRegionOutline, rhs.wantRegionOutline);\n                            if (0 === diff) {\n                                diff = compareBooleans(this.hasFillTransparency, rhs.hasFillTransparency);\n                                if (0 === diff) {\n                                    diff = compareBooleans(this.hasLineTransparency, rhs.hasLineTransparency);\n                                    if (0 === diff) {\n                                        diff = compareMaterials(this.material, rhs.material);\n                                        if (0 === diff && undefined === this.material && this.isTextured) {\n                                            diff = compareTextureMappings(this.textureMapping, rhs.textureMapping);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n    /**\n     * Given a ColorDef object, check its transparency and if it falls below the minimum, mark the color as fully opaque.\n     * @return The original reference to the color provided, which has possibly been modified.\n     */\n    static adjustTransparency(color) {\n        return (color.colors.t < DisplayParams.minTransparency) ? color.withTransparency(0) : color;\n    }\n}\nDisplayParams.minTransparency = 15; // Threshold below which we consider a color fully opaque\nexport { DisplayParams };\n/** @internal */\n(function (DisplayParams) {\n    let Type;\n    (function (Type) {\n        Type[Type[\"Mesh\"] = 0] = \"Mesh\";\n        Type[Type[\"Linear\"] = 1] = \"Linear\";\n        Type[Type[\"Text\"] = 2] = \"Text\";\n    })(Type = DisplayParams.Type || (DisplayParams.Type = {}));\n    let RegionEdgeType;\n    (function (RegionEdgeType) {\n        RegionEdgeType[RegionEdgeType[\"None\"] = 0] = \"None\";\n        RegionEdgeType[RegionEdgeType[\"Default\"] = 1] = \"Default\";\n        RegionEdgeType[RegionEdgeType[\"Outline\"] = 2] = \"Outline\";\n    })(RegionEdgeType = DisplayParams.RegionEdgeType || (DisplayParams.RegionEdgeType = {}));\n    let ComparePurpose;\n    (function (ComparePurpose) {\n        ComparePurpose[ComparePurpose[\"Merge\"] = 0] = \"Merge\";\n        ComparePurpose[ComparePurpose[\"Strict\"] = 1] = \"Strict\";\n    })(ComparePurpose = DisplayParams.ComparePurpose || (DisplayParams.ComparePurpose = {}));\n})(DisplayParams || (DisplayParams = {}));\n//# sourceMappingURL=DisplayParams.js.map",
      "start": 1693508118883,
      "end": 1693508119261,
      "sourcemaps": null
    }
  ]
}
