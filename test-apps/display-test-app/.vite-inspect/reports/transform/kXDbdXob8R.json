{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveCurve.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { CurveCollection } from \"./CurveCollection\";\nimport { CurveCurveCloseApproachXY } from \"./internalContexts/CurveCurveCloseApproachXY\";\nimport { CurveCurveIntersectXY } from \"./internalContexts/CurveCurveIntersectXY\";\nimport { CurveCurveIntersectXYZ } from \"./internalContexts/CurveCurveIntersectXYZ\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\n/**\n * `CurveCurve` has static method for various computations that work on a pair of curves or curve collections.\n * @public\n */\nexport class CurveCurve {\n    /**\n     * Return xy intersections of 2 curves.\n     * @param curveA first curve\n     * @param extendA true to allow curveA to extend\n     * @param curveB second curve\n     * @param extendB true to allow curveB to extend\n     * @param tolerance optional distance tolerance for coincidence\n     */\n    static intersectionXYPairs(curveA, extendA, curveB, extendB, tolerance = Geometry.smallMetricDistance) {\n        const handler = new CurveCurveIntersectXY(undefined, extendA, curveB, extendB, tolerance);\n        if (curveB instanceof CurvePrimitive) {\n            curveA.dispatchToGeometryHandler(handler);\n        }\n        else if (curveB instanceof CurveCollection) {\n            const allCurves = curveB.collectCurvePrimitives();\n            for (const child of allCurves) {\n                handler.resetGeometry(false, child, false);\n                curveA.dispatchToGeometryHandler(handler);\n            }\n        }\n        return handler.grabPairedResults();\n    }\n    /**\n     * Return xy intersections of 2 projected curves.\n     * @param curveA first curve\n     * @param extendA true to allow curveA to extend\n     * @param curveB second curve\n     * @param extendB true to allow curveB to extend\n     * @param tolerance optional distance tolerance for coincidence\n     */\n    static intersectionProjectedXYPairs(worldToLocal, curveA, extendA, curveB, extendB, tolerance = Geometry.smallMetricDistance) {\n        const handler = new CurveCurveIntersectXY(worldToLocal, extendA, curveB, extendB, tolerance);\n        curveA.dispatchToGeometryHandler(handler);\n        return handler.grabPairedResults();\n    }\n    /**\n     * Return full 3d xyz intersections of 2 curves.\n     *  * Implemented for combinations of LineSegment3d, LineString3d, Arc3d.\n     *  * Not Implemented for bspline and bezier curves.\n     * @beta\n     * @param curveA first curve\n     * @param extendA true to allow curveA to extend\n     * @param curveB second curve\n     * @param extendB true to allow curveB to extend\n     */\n    static intersectionXYZ(curveA, extendA, curveB, extendB) {\n        const handler = new CurveCurveIntersectXYZ(extendA, curveB, extendB);\n        curveA.dispatchToGeometryHandler(handler);\n        return handler.grabResults();\n    }\n    /**\n     * Return xy intersections of input curves.\n     * @param primitives input curves to intersect\n     * @param tolerance optional distance tolerance for coincidence\n     */\n    static allIntersectionsAmongPrimitivesXY(primitives, tolerance = Geometry.smallMetricDistance) {\n        const handler = new CurveCurveIntersectXY(undefined, false, undefined, false, tolerance);\n        for (let i = 0; i < primitives.length; i++) {\n            const curveA = primitives[i];\n            for (let j = i + 1; j < primitives.length; j++) {\n                handler.resetGeometry(false, primitives[j], false);\n                curveA.dispatchToGeometryHandler(handler);\n            }\n        }\n        return handler.grabPairedResults();\n    }\n    /**\n     * Return at least one XY close approach between 2 curves.\n     * * Close approach xy-distances are measured without regard to z. This is equivalent to their separation distance\n     * as seen in the top view, or as measured between their projections onto the xy-plane.\n     * * If more than one approach is returned, one of them is the closest approach.\n     * @param curveA first curve\n     * @param curveB second curve\n     * @param maxDistance maximum xy-distance to consider between the curves.\n     * Close approaches further than this xy-distance are not returned.\n     */\n    static closeApproachProjectedXYPairs(curveA, curveB, maxDistance) {\n        const handler = new CurveCurveCloseApproachXY(curveB);\n        handler.maxDistanceToAccept = maxDistance;\n        curveA.dispatchToGeometryHandler(handler);\n        return handler.grabPairedResults();\n    }\n    /**\n     * Convenience method that calls [[closeApproachProjectedXYPairs]] with a large `maxDistance`\n     * and returns a detail pair representing the closest xy-approach between the curves.\n     * * There may be many detail pairs that represent \"closest\" xy-approach, including coincident interval pairs,\n     * isolated intersections, or close approaches within tolerance of each other. This method makes no attempt to\n     * distinguish among them, and returns a pair whose `detail.point` values are separated by the smallest xy distance\n     * found among the pairs.\n     * @param curveA first curve\n     * @param curveB second curve\n     * @return detail pair of closest xy-approach, undefined if not found\n     */\n    static closestApproachProjectedXYPair(curveA, curveB) {\n        const range = curveA.range();\n        range.extendRange(curveB.range());\n        const maxDistance = range.low.distanceXY(range.high);\n        const closeApproaches = this.closeApproachProjectedXYPairs(curveA, curveB, maxDistance);\n        if (!closeApproaches.length)\n            return undefined;\n        let iMin = 0;\n        let minDistXY = 2 * maxDistance;\n        for (let i = 0; i < closeApproaches.length; ++i) {\n            const distXY = closeApproaches[i].detailA.point.distanceXY(closeApproaches[i].detailB.point);\n            if (distXY < minDistXY) {\n                iMin = i;\n                minDistXY = distXY;\n            }\n        }\n        return closeApproaches[iMin];\n    }\n}\n//# sourceMappingURL=CurveCurve.js.map",
      "start": 1693508123561,
      "end": 1693508123723,
      "sourcemaps": null
    }
  ]
}
