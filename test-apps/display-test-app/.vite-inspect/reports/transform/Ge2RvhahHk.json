{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/web/WebAppRpcRequest.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nvar _a;\nimport { BentleyStatus } from \"@itwin/core-bentley\";\nimport { IModelError, ServerError, ServerTimeoutError } from \"../../IModelError\";\nimport { RpcContentType, RpcProtocolEvent, WEB_RPC_CONSTANTS } from \"../core/RpcConstants\";\nimport { MarshalingBinaryMarker, RpcSerializedValue } from \"../core/RpcMarshaling\";\nimport { RpcRequest } from \"../core/RpcRequest\";\nimport { RpcMultipartParser } from \"./multipart/RpcMultipartParser\";\nimport { RpcMultipart } from \"./RpcMultipart\";\nimport { WebAppRpcProtocol } from \"./WebAppRpcProtocol\";\n/** A web application RPC request.\n * @internal\n */\nclass WebAppRpcRequest extends RpcRequest {\n    get _headers() { return this._request.headers; }\n    /** Parses a request. */\n    static async parseRequest(protocol, req) {\n        return this.backend.parseRequest(protocol, req);\n    }\n    /** Sends the response for a web request. */\n    static async sendResponse(protocol, request, fulfillment, req, res) {\n        return this.backend.sendResponse(protocol, request, fulfillment, req, res);\n    }\n    /** Determines the most efficient transport type for an RPC value. */\n    static computeTransportType(value, source) {\n        if (source instanceof Uint8Array || (Array.isArray(source) && source[0] instanceof Uint8Array)) {\n            return RpcContentType.Binary;\n        }\n        else if (value.data.length > 0) {\n            return RpcContentType.Multipart;\n        }\n        else if (value.stream) {\n            return RpcContentType.Stream;\n        }\n        else {\n            return RpcContentType.Text;\n        }\n    }\n    /** Constructs a web application request. */\n    constructor(client, operation, parameters) {\n        super(client, operation, parameters);\n        this._loading = false;\n        this._request = {};\n        this._pathSuffix = \"\";\n        /** Convenience access to the protocol of this request. */\n        this.protocol = this.client.configuration.protocol;\n        /** Standardized access to metadata about the request (useful for purposes such as logging). */\n        this.metadata = { status: 0, message: \"\" };\n        this.path = this.protocol.supplyPathForOperation(this.operation, this);\n        this.method = \"head\";\n        this._request.headers = {};\n    }\n    /** Sets request header values. */\n    setHeader(name, value) {\n        this._headers[name] = value;\n    }\n    /** Sends the request. */\n    async send() {\n        this._loading = true;\n        await this.setupTransport();\n        return new Promise(async (resolve, reject) => {\n            try {\n                resolve(await this.performFetch());\n            }\n            catch (reason) {\n                reject(new ServerError(-1, typeof (reason) === \"string\" ? reason : \"Server connection error.\"));\n            }\n        });\n    }\n    computeRetryAfter(attempts) {\n        const retryAfter = this._response && this._response.headers.get(\"Retry-After\");\n        if (retryAfter) {\n            this.resetTransientFaultCount();\n            const r = Number(retryAfter);\n            if (Number.isFinite(r)) {\n                return r * 1000;\n            }\n            const d = Date.parse(retryAfter);\n            if (!Number.isNaN(d)) {\n                return d - Date.now();\n            }\n        }\n        else {\n            this.recordTransientFault();\n        }\n        return super.computeRetryAfter(attempts);\n    }\n    handleUnknownResponse(code) {\n        if (this.protocol.isTimeout(code)) {\n            this.reject(new ServerTimeoutError(\"Request timeout.\"));\n        }\n        else {\n            this.reject(new ServerError(code, \"Unknown server response code.\"));\n        }\n    }\n    async load() {\n        return new Promise(async (resolve, reject) => {\n            try {\n                if (!this._loading)\n                    return;\n                const response = this._response;\n                if (!response) {\n                    reject(new IModelError(BentleyStatus.ERROR, \"Invalid state.\"));\n                    return;\n                }\n                if (this.protocol.protocolVersionHeaderName) {\n                    const version = response.headers.get(this.protocol.protocolVersionHeaderName);\n                    if (version) {\n                        this.responseProtocolVersion = parseInt(version, 10);\n                    }\n                }\n                const contentType = response.headers.get(WEB_RPC_CONSTANTS.CONTENT);\n                const responseType = WebAppRpcProtocol.computeContentType(contentType);\n                if (responseType === RpcContentType.Binary) {\n                    resolve(await this.loadBinary(response));\n                }\n                else if (responseType === RpcContentType.Multipart) {\n                    resolve(await this.loadMultipart(response, contentType));\n                }\n                else {\n                    resolve(await this.loadText(response));\n                }\n                this._loading = false;\n                this.setLastUpdatedTime();\n                this.protocol.events.raiseEvent(RpcProtocolEvent.ResponseLoaded, this);\n            }\n            catch (reason) {\n                if (!this._loading)\n                    return;\n                this._loading = false;\n                reject(new ServerError(this.metadata.status, typeof (reason) === \"string\" ? reason : \"Unknown server response error.\"));\n            }\n        });\n    }\n    /** Override to supply an alternate fetch function. */\n    supplyFetch() {\n        return fetch;\n    }\n    /** Override to supply an alternate Request function. */\n    supplyRequest() {\n        return Request;\n    }\n    async performFetch() {\n        const requestClass = this.supplyRequest();\n        const fetchFunction = this.supplyFetch();\n        const path = new URL(this.path, typeof (location) !== \"undefined\" ? location.origin : undefined);\n        if (this._pathSuffix) {\n            const params = new URLSearchParams();\n            params.set(\"parameters\", this._pathSuffix);\n            path.search = `?${params.toString()}`;\n        }\n        const request = new requestClass(path.toString(), this._request);\n        const response = await fetchFunction(request);\n        this._response = response;\n        this.metadata.status = response.status;\n        return response.status;\n    }\n    async loadText(response) {\n        const value = await response.text();\n        this.metadata.message = value;\n        return RpcSerializedValue.create(value);\n    }\n    async loadBinary(response) {\n        const value = new Uint8Array(await response.arrayBuffer());\n        const objects = JSON.stringify(MarshalingBinaryMarker.createDefault());\n        return RpcSerializedValue.create(objects, [value]);\n    }\n    async loadMultipart(response, contentType) {\n        const data = await response.arrayBuffer();\n        const value = new RpcMultipartParser(contentType, new Uint8Array(data)).parse();\n        return value;\n    }\n    async setupTransport() {\n        const parameters = (await this.protocol.serialize(this)).parameters;\n        const transportType = WebAppRpcRequest.computeTransportType(parameters, this.parameters);\n        if (transportType === RpcContentType.Binary) {\n            this.setupBinaryTransport(parameters);\n        }\n        else if (transportType === RpcContentType.Multipart) {\n            this.setupMultipartTransport(parameters);\n        }\n        else {\n            this.setupTextTransport(parameters);\n        }\n    }\n    setupBinaryTransport(parameters) {\n        this._headers[WEB_RPC_CONSTANTS.CONTENT] = WEB_RPC_CONSTANTS.BINARY;\n        this._request.method = \"post\";\n        this._request.body = parameters.data[0];\n    }\n    setupMultipartTransport(parameters) {\n        // IMPORTANT: do not set a multipart Content-Type header value. The browser does this automatically!\n        delete this._headers[WEB_RPC_CONSTANTS.CONTENT];\n        this._request.method = \"post\";\n        this._request.body = RpcMultipart.createForm(parameters);\n    }\n    setupTextTransport(parameters) {\n        if (this.operation.policy.allowResponseCaching(this)) {\n            const encodedBody = btoa(parameters.objects); // eslint-disable-line deprecation/deprecation\n            if (encodedBody.length <= WebAppRpcRequest.maxUrlComponentSize) {\n                this._request.method = \"get\";\n                this._request.body = undefined;\n                delete this._headers[WEB_RPC_CONSTANTS.CONTENT];\n                this._pathSuffix = encodedBody;\n                return;\n            }\n        }\n        this._pathSuffix = \"\";\n        this._headers[WEB_RPC_CONSTANTS.CONTENT] = WEB_RPC_CONSTANTS.TEXT;\n        this._request.method = \"post\";\n        this._request.body = parameters.objects;\n    }\n}\n_a = WebAppRpcRequest;\n/** The maximum size permitted for an encoded component in a URL.\n * Note that some backends limit the total cumulative request size. Our current node backends accept requests with a max size of 16 kb.\n * In addition to the url size, an authorization header may also add considerably to the request size.\n * @note This is used for features like encoding the payload of a cacheable request in the URL.\n */\nWebAppRpcRequest.maxUrlComponentSize = 1024 * 8;\n/** @internal */\nWebAppRpcRequest.backend = {\n    sendResponse: async (_protocol, _request, _fulfillment, _req, _res) => {\n        throw new IModelError(BentleyStatus.ERROR, \"Not bound.\");\n    },\n    parseRequest: async (_protocol, _req) => {\n        throw new IModelError(BentleyStatus.ERROR, \"Not bound.\");\n    },\n};\nexport { WebAppRpcRequest };\n//# sourceMappingURL=WebAppRpcRequest.js.map",
      "start": 1693508121078,
      "end": 1693508121147,
      "sourcemaps": null
    }
  ]
}
