{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/IpcApp.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module NativeApp\n */\nimport { BackendError, IModelError, IModelStatus, ipcAppChannels, iTwinChannel, } from \"@itwin/core-common\";\nimport { IModelApp } from \"./IModelApp\";\n/**\n * The frontend of apps with a dedicated backend that can use [Ipc]($docs/learning/IpcInterface.md).\n * @public\n */\nclass IpcApp {\n    /** Get the implementation of the [[IpcSocketFrontend]] interface. */\n    static get ipc() { return this._ipc; }\n    /** Determine whether Ipc is available for this frontend. This will only be true if [[startup]] has been called on this class. */\n    static get isValid() { return undefined !== this._ipc; }\n    /**\n     * Establish a message handler function for the supplied channel over Ipc. The handler will be called when messages are sent for\n     * the channel via  [[BackendIpc.send]].\n     * @param channel the name of the channel\n     * @param handler the message handler\n     * @returns A function to remove the handler\n     * @note Ipc is only supported if [[isValid]] is true.\n     */\n    static addListener(channel, handler) {\n        return this.ipc.addListener(iTwinChannel(channel), handler);\n    }\n    /**\n     * Remove a previously registered listener\n     * @param channel The name of the channel for the listener previously registered with [[addListener]]\n     * @param listener The function passed to [[addListener]]\n     */\n    static removeListener(channel, listener) {\n        this.ipc.removeListener(iTwinChannel(channel), listener);\n    }\n    /**\n     * Send a message to the backend via `channel` and expect a result asynchronously. The handler must be established on the backend via [[BackendIpc.handle]]\n     * @param channel The name of the channel for the method.\n     * @see Electron [ipcRenderer.invoke](https://www.electronjs.org/docs/api/ipc-renderer) documentation for details.\n     * Note that this interface may be implemented via Electron for desktop apps, or via\n     * [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) for mobile or web-based\n     * Ipc connections. In either case, the Electron documentation provides the specifications for how it works.\n     * @note `args` are serialized with the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), so only\n     * primitive types and `ArrayBuffers` are allowed.\n     */\n    static async invoke(channel, ...args) {\n        return this.ipc.invoke(iTwinChannel(channel), ...args);\n    }\n    /**\n     * Send a message over the socket.\n     * @param channel The name of the channel for the message.\n     * @param data The optional data of the message.\n     * @note `data` is serialized with the [Structured Clone Algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), so only\n     * primitive types and `ArrayBuffers` are allowed.\n     */\n    static send(channel, ...data) {\n        return this.ipc.send(iTwinChannel(channel), ...data);\n    }\n    /**\n     * Call a method on the backend through an Ipc channel.\n     * @param channelName the channel registered by the backend handler.\n     * @param methodName  the name of a method implemented by the backend handler.\n     * @param args arguments to `methodName`\n     * @return a Promise with the return value from `methodName`\n     * @note If the backend implementation throws an exception, this method will throw a [[BackendError]] exception\n     * with the `errorNumber` and `message` from the backend.\n     * @note Ipc is only supported if [[isValid]] is true.\n     * @internal Use [[makeIpcProxy]] for a type-safe interface.\n     */\n    static async callIpcChannel(channelName, methodName, ...args) {\n        const retVal = (await this.invoke(channelName, methodName, ...args));\n        if (undefined !== retVal.error) {\n            const err = new BackendError(retVal.error.errorNumber, retVal.error.name, retVal.error.message);\n            err.stack = retVal.error.stack;\n            throw err;\n        }\n        return retVal.result;\n    }\n    /** Create a type safe Proxy object to make IPC calls to a registered backend interface.\n     * @param channelName the channel registered by the backend handler.\n     */\n    static makeIpcProxy(channelName) {\n        return new Proxy({}, {\n            get(_target, methodName) {\n                return async (...args) => IpcApp.callIpcChannel(channelName, methodName, ...args);\n            },\n        });\n    }\n    /** Create a type safe Proxy object to call an IPC function on a of registered backend handler that accepts a \"methodName\" argument followed by optional arguments\n     * @param channelName the channel registered by the backend handler.\n     * @param functionName the function to call on the handler.\n     * @internal\n     */\n    static makeIpcFunctionProxy(channelName, functionName) {\n        return new Proxy({}, {\n            get(_target, methodName) {\n                return async (...args) => IpcApp.callIpcChannel(channelName, functionName, methodName, ...args);\n            },\n        });\n    }\n    /** @deprecated in 3.x. use [[appFunctionIpc]] */\n    static async callIpcHost(methodName, ...args) {\n        return this.callIpcChannel(ipcAppChannels.functions, methodName, ...args);\n    }\n    /** start an IpcApp.\n     * @note this should not be called directly. It is called by NativeApp.startup */\n    static async startup(ipc, opts) {\n        this._ipc = ipc;\n        IpcAppNotifyHandler.register(); // receives notifications from backend\n        await IModelApp.startup(opts?.iModelApp);\n    }\n    /** @internal */\n    static async shutdown() {\n        this._ipc = undefined;\n        await IModelApp.shutdown();\n    }\n}\n/** A Proxy to call one of the [IpcAppFunctions]($common) functions via IPC. */\nIpcApp.appFunctionIpc = IpcApp.makeIpcProxy(ipcAppChannels.functions);\nexport { IpcApp };\n/**\n * Base class for all implementations of an Ipc notification response interface. This class is implemented on your frontend to supply\n * methods to receive notifications from your backend.\n *\n * Create a subclass to implement your Ipc response interface. Your class should be declared like this:\n * ```ts\n * class MyNotificationHandler extends NotificationHandler implements MyNotifications\n * ```\n * to ensure all method names and signatures are correct. Your methods cannot have a return value.\n *\n * Then, call `MyNotificationHandler.register` at startup to connect your class to your channel.\n * @public\n * @extensions\n */\nexport class NotificationHandler {\n    registerImpl() {\n        return IpcApp.addListener(this.channelName, (_evt, funcName, ...args) => {\n            const func = this[funcName];\n            if (typeof func !== \"function\")\n                throw new IModelError(IModelStatus.FunctionNotFound, `Method \"${this.constructor.name}.${funcName}\" not found on NotificationHandler registered for channel: ${this.channelName}`);\n            func.call(this, ...args);\n        });\n    }\n    /**\n     * Register this class as the handler for notifications on its channel. This static method creates a new instance\n     * that becomes the notification handler and is `this` when its methods are called.\n     * @returns A function that can be called to remove the handler.\n     * @note this method should only be called once per channel. If it is called multiple times, multiple handlers are established.\n     */\n    static register() {\n        return new this().registerImpl(); // create an instance of subclass. \"as any\" is necessary because base class is abstract\n    }\n}\n/** IpcApp notifications from backend */\nclass IpcAppNotifyHandler extends NotificationHandler {\n    get channelName() { return ipcAppChannels.appNotify; }\n    notifyApp() { }\n}\n//# sourceMappingURL=IpcApp.js.map",
      "start": 1693508119338,
      "end": 1693508119551,
      "sourcemaps": null
    }
  ]
}
