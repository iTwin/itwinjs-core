{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/hypermodeling/lib/esm/HyperModelingDecorator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module HyperModeling\n */\nimport { Transform } from \"@itwin/core-geometry\";\nimport { IModelApp, ViewClipTool, } from \"@itwin/core-frontend\";\nimport { SectionMarker, SectionMarkerSet } from \"./SectionMarkers\";\nimport { SectionDrawingLocationState } from \"./SectionDrawingLocationState\";\nimport { createSectionGraphicsProvider } from \"./SectionGraphicsProvider\";\nimport { PopupToolbarManager } from \"./PopupToolbar\";\nimport { HyperModeling } from \"./HyperModeling\";\nasync function createMarkers(vp) {\n    if (!vp.view.isSpatialView())\n        return undefined;\n    const states = await SectionDrawingLocationState.queryAll(vp.iModel);\n    if (0 === states.length)\n        return undefined;\n    const markers = states.map((state) => new SectionMarker(state));\n    return new SectionMarkerSet(vp, markers);\n}\nclass MarkerToolbarProvider {\n    constructor(marker, decorator) {\n        this.marker = marker;\n        this._viewport = decorator.viewport;\n        this.toolbarProps = HyperModeling.markerHandler.getToolbarProps(marker, decorator);\n        this.onToolbarItemExecuted = (id) => HyperModeling.markerHandler.executeCommand(id, marker, decorator); // eslint-disable-line @typescript-eslint/promise-function-async\n    }\n    get overToolbarHotspot() {\n        return this.marker.isHilited;\n    }\n    get toolbarLocation() {\n        return IModelApp.uiAdmin.createXAndY(this.marker.rect.right, this.marker.rect.top);\n    }\n    get htmlElement() {\n        return this._viewport.canvas;\n    }\n}\n/** A [Decorator]($frontend) that displays a [[SectionMarker]] for each [SectionDrawingLocation]($backend) in the view.\n * Clicking on a marker toggles the section and the display of associated 2d graphics.\n * Hovering over a marker opens a mini toolbar with additional interactions.\n * @see [[SectionMarkerHandler]] to customize the marker interactions.\n * @see [[HyperModeling.startOrStop]] to enable or disable the decorator for a viewport.\n * @public\n */\nexport class HyperModelingDecorator {\n    /** Create a new decorator and register it with the [ViewManager]($frontend). Typically invoked indirectly via [[HyperModeling.startOrStop]]. */\n    static async create(vp, config) {\n        const markers = await createMarkers(vp);\n        return undefined !== markers ? new HyperModelingDecorator(markers, config) : undefined;\n    }\n    /** Obtain the decorator associated with the specified viewport, if any. */\n    static getForViewport(vp) {\n        for (const decorator of IModelApp.viewManager.decorators)\n            if (decorator instanceof HyperModelingDecorator && decorator.viewport === vp)\n                return decorator;\n        return undefined;\n    }\n    /** The viewport into which this decorator draws its [[SectionMarker]]s. */\n    get viewport() {\n        return this.markers.viewport;\n    }\n    /** The currently active marker. A marker typically becomes active when the user clicks on it.\n     * @see [[setActiveMarker]] to change the active marker without user interaction.\n     */\n    get activeMarker() {\n        return this._activeMarker;\n    }\n    /** @internal */\n    get config() {\n        return this._config;\n    }\n    /** Replaces the current marker display configuration, overwriting all previous settings. Passing `undefined` resets all settings to defaults.\n     * @see [[updateConfiguration]] to override specific aspects of the configuration\n     * @see [[HyperModeling.replaceConfiguration]] to replace the global configuration.\n     */\n    replaceConfiguration(config) {\n        this._config = config ? { ...config } : {};\n        this.requestSync();\n    }\n    /** Overrides specific aspects of the current marker display configuration.\n     * Any field that is not `undefined` will be replaced in the current configuration; the rest will retain their current values.\n     * @see [[replaceConfiguration]] to override all settings.\n     * @see [[HyperModeling.updateConfiguration]] to update the global configuration.\n     */\n    updateConfiguration(config) {\n        this._config = {\n            ignoreModelSelector: config.ignoreModelSelector ?? this._config.ignoreModelSelector,\n            ignoreCategorySelector: config.ignoreCategorySelector ?? this._config.ignoreCategorySelector,\n            hiddenSectionTypes: config.hiddenSectionTypes ?? this._config.hiddenSectionTypes,\n        };\n        this.requestSync();\n    }\n    /** Sets the currently active marker. This function is invoked when the user clicks on a marker, but may also be called manually to produce the same result.\n     * Changing the active marker first deactivates the currently active marker, if any; then activates the specified marker, if supplied.\n     * Returns false if marker activation fails.\n     * @see [[activeMarker]] to obtain the currently active section marker.\n     * @see [[SectionMarkerHandler.activateMarker]] to control what happens when a marker is activated.\n     * @see [[SectionMarkerHandler.deactivateMarker]] to control what happens when a marker is deactivated.\n     */\n    async setActiveMarker(marker) {\n        if (marker === this.activeMarker)\n            return true;\n        if (this.activeMarker) {\n            this.activeMarker.setActive(false);\n            await HyperModeling.markerHandler.deactivateMarker(this.activeMarker, this);\n            this._activeMarker = undefined;\n        }\n        if (marker) {\n            if (!await HyperModeling.markerHandler.activateMarker(marker, this)) {\n                this.requestSync();\n                return false;\n            }\n            marker.setActive(true);\n            this._activeMarker = marker;\n        }\n        this.requestSync();\n        return true;\n    }\n    /** @internal */\n    decorate(context) {\n        if (this.viewport.view.is3d())\n            this.markers.addDecoration(context);\n    }\n    constructor(markers, config) {\n        this._removeEventListeners = new Array();\n        this._needSync = false;\n        /** @internal */\n        this.syncImmediately = false;\n        /** @internal */\n        this.useCachedDecorations = true;\n        this.markers = markers;\n        this._config = { ...config };\n        this._iModel = this.viewport.iModel;\n        this.viewport.onChangeView.addOnce(() => {\n            this.requestSync();\n        });\n        this._removeEventListeners.push(this.viewport.onViewportChanged.addListener((_, changeFlags) => this.onViewportChanged(changeFlags)));\n        this._removeEventListeners.push(this.viewport.onDisposed.addListener(() => this.dispose()));\n        for (const marker of markers.markers) {\n            marker.onMouseEnterEvent.addListener((mkr) => this.showToolbarAfterTimeout(mkr));\n            marker.onMouseButtonEvent.addListener((mkr) => this.toggleMarker(mkr)); // eslint-disable-line @typescript-eslint/promise-function-async\n        }\n        this.updateMarkerVisibility();\n        IModelApp.viewManager.addDecorator(this);\n    }\n    onViewportChanged(changeFlags) {\n        if (this.viewport.iModel !== this._iModel) {\n            this.dispose();\n            return;\n        }\n        if (changeFlags.viewedCategories || changeFlags.viewedModels || changeFlags.viewedCategoriesPerModel)\n            this.requestSync();\n        if (changeFlags.viewState) {\n            // If we're looking at a different view now, and we did not initiate that, turn off the active marker.\n            if (this.viewport.view !== this._appliedSpatialView)\n                this.setActiveMarker(undefined); // eslint-disable-line @typescript-eslint/no-floating-promises\n            else\n                this._appliedSpatialView = undefined;\n        }\n    }\n    async toggleMarker(marker) {\n        await this.setActiveMarker(marker === this.activeMarker ? undefined : marker);\n    }\n    dropTiledGraphicsProvider() {\n        if (undefined === this._tiledGraphicsProvider)\n            return;\n        this.viewport.dropTiledGraphicsProvider(this._tiledGraphicsProvider);\n        this._tiledGraphicsProvider = undefined;\n    }\n    /** @internal */\n    dispose() {\n        if (!IModelApp.viewManager.dropDecorator(this))\n            return;\n        for (const remove of this._removeEventListeners)\n            remove();\n        this.dropTiledGraphicsProvider();\n    }\n    showToolbarAfterTimeout(marker) {\n        if (this._toolbarProvider?.marker !== marker)\n            this._toolbarProvider = new MarkerToolbarProvider(marker, this);\n        PopupToolbarManager.showToolbarAfterTimeout(this._toolbarProvider);\n    }\n    /** Toggles whether the clip volume associated with the specified marker is applied to the view. */\n    toggleClipVolume(marker, enable) {\n        ViewClipTool.enableClipVolume(this.viewport);\n        ViewClipTool.setViewClip(this.viewport, enable ? marker.state.clip : undefined);\n    }\n    /** Toggles the specified section marker.\n     * Enabling the section applies the frustum and clip volume of the marker's spatial view to the viewport, and displays the 2d section graphics and sheet annotations.\n     * Disabling the section disables the clip volume and 2d graphics.\n     * @see [[toggleClipVolume]] to toggle only the clip volume.\n     * @see [[toggleAttachment]] to toggle only the attachment graphics.\n     */\n    async toggleSection(marker, enable) {\n        if (enable) {\n            if (this.viewport.view.is3d()) {\n                // Preserve the view settings; apply only the frustum and clip volume\n                const spatialView = await marker.state.tryLoadSpatialView();\n                if (!spatialView)\n                    return false;\n                const aligned = await this.alignToSpatialView(marker);\n                if (!aligned)\n                    return false;\n                this.toggleClipVolume(marker, true);\n            }\n            else if (!await this.applySpatialView(marker)) {\n                return false;\n            }\n        }\n        else {\n            this.toggleClipVolume(marker, false);\n        }\n        this.requestSync();\n        return this.toggleAttachment(marker, enable);\n    }\n    /** Toggles display of 2d section graphics and sheet annotations for the specified marker.\n     * @see [[toggleSection]] to apply the spatial view and clip volume in addition to the attachment graphics.\n     */\n    async toggleAttachment(marker, enable) {\n        this.dropTiledGraphicsProvider();\n        if (enable) {\n            this._tiledGraphicsProvider = await createSectionGraphicsProvider(marker.state);\n            this.viewport.addTiledGraphicsProvider(this._tiledGraphicsProvider);\n        }\n        return true;\n    }\n    /** Aligns the viewport to face the specified marker's section plane. */\n    alignView(marker) {\n        const placement = marker.state.placement.transform;\n        const origin = placement.origin;\n        const matrix = placement.matrix;\n        const vp = this.viewport;\n        const targetMatrix = matrix.multiplyMatrixMatrix(vp.rotation);\n        const rotateTransform = Transform.createFixedPointAndMatrix(origin, targetMatrix);\n        const startFrustum = vp.getFrustum();\n        const newFrustum = startFrustum.clone();\n        newFrustum.multiply(rotateTransform);\n        if (startFrustum.equals(newFrustum))\n            return;\n        vp.view.setupFromFrustum(newFrustum);\n        vp.synchWithView();\n        vp.animateFrustumChange();\n    }\n    /** Opens the marker's drawing view in the decorator's viewport. Returns false if the drawing view could not be loaded. */\n    async openSection(marker) {\n        const viewState = await marker.state.tryLoadDrawingView();\n        if (viewState)\n            this.viewport.changeView(viewState);\n        return undefined !== viewState;\n    }\n    /** Opens marker's sheet view in the decorator's viewport and zooms in on the associated [ViewAttachment]($backend). Returns false if no view\n     * attachment exists or the sheet view could not be loaded.\n     */\n    async openSheet(marker) {\n        if (undefined === marker.state.viewAttachment)\n            return false;\n        const viewState = await marker.state.tryLoadSheetView();\n        if (!viewState)\n            return false;\n        this.viewport.changeView(viewState);\n        await this.viewport.zoomToElements(marker.state.viewAttachment.id);\n        return true;\n    }\n    /** Aligns the view to match the frustum of the spatial view associated with the specified marker.\n     * @param marker The marker whose spatial view's frustum should be applied.\n     * @returns false if the frustum could not be applied, e.g. because the spatial view could not be loaded or the viewport is viewing a 2d model.\n     * @see [[alignView]] to align to the *section plane*, which may differ.\n     * @see [[toggleSection]] to also apply the clip volume.\n     */\n    async alignToSpatialView(marker) {\n        if (!this.viewport.view.is3d())\n            return false;\n        const spatialView = await marker.state.tryLoadSpatialView();\n        if (!spatialView)\n            return false;\n        this.viewport.view.setOrigin(spatialView.getOrigin());\n        this.viewport.view.setExtents(spatialView.getExtents());\n        this.viewport.view.setRotation(spatialView.getRotation());\n        this.viewport.synchWithView({ animateFrustumChange: true });\n        return true;\n    }\n    /** Applies the marker's spatial view - including its clip volume - to the decorator's viewport.\n     * Returns false if the spatial view could not be loaded.\n     * @see [[toggleSection]].\n     * @see [[toggleClipVolume]].\n     */\n    async applySpatialView(marker) {\n        const viewState = await marker.state.tryLoadSpatialView();\n        if (viewState) {\n            this._appliedSpatialView = viewState;\n            this.viewport.changeView(viewState);\n        }\n        return undefined !== viewState;\n    }\n    /** Request that the visibility of the section markers be recomputed. It is only necessary to call this if you have overridden [[SectionMarkerHandler.isMarkerVisible]]; if so, you should invoke\n     * this method when the criteria governing your `isMarkerVisible` method have changed.\n     */\n    requestSync() {\n        if (this.syncImmediately) {\n            this.sync();\n        }\n        else if (!this._needSync) {\n            this._needSync = true;\n            requestAnimationFrame(() => this.sync());\n        }\n    }\n    sync() {\n        this._needSync = false;\n        if (HyperModeling.isInitialized && this.viewport.view.is3d() && this.updateMarkerVisibility()) {\n            this.markers.markDirty();\n            this.viewport.invalidateCachedDecorations(this);\n        }\n    }\n    isMarkerVisible(marker) {\n        if (undefined !== this.activeMarker)\n            return marker === this.activeMarker;\n        return HyperModeling.markerHandler.isMarkerVisible(marker, this, this._config);\n    }\n    updateMarkerVisibility() {\n        let changed = false;\n        for (const marker of this.markers.markers) {\n            const wasVisible = marker.visible;\n            marker.visible = this.isMarkerVisible(marker);\n            changed = changed || (marker.visible !== wasVisible);\n        }\n        return changed;\n    }\n}\n//# sourceMappingURL=HyperModelingDecorator.js.map",
      "start": 1693508122870,
      "end": 1693508122963,
      "sourcemaps": null
    }
  ]
}
