{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/FeatureOverrides.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, dispose, Id64 } from \"@itwin/core-bentley\";\nimport { PackedFeature } from \"@itwin/core-common\";\nimport { DisplayParams } from \"../../common/render/primitives/DisplayParams\";\nimport { LineCode } from \"./LineCode\";\nimport { GL } from \"./GL\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { sync } from \"./Sync\";\nimport { System } from \"./System\";\nimport { Texture2DDataUpdater, TextureHandle } from \"./Texture\";\nfunction computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba = 0, nTables = 1) {\n    const maxSize = System.instance.maxTextureSize;\n    const nRgba = nEntries * nRgbaPerEntry * nTables + nExtraRgba;\n    if (nRgba < maxSize)\n        return { width: nRgba, height: 1 };\n    // Make roughly square to reduce unused space in last row\n    let width = Math.ceil(Math.sqrt(nRgba));\n    // Ensure a given entry's RGBA values all fit on the same row.\n    const remainder = width % nRgbaPerEntry;\n    if (0 !== remainder) {\n        width += nRgbaPerEntry - remainder;\n    }\n    // Compute height\n    const height = Math.ceil(nRgba / width);\n    assert(height <= maxSize);\n    assert(width <= maxSize);\n    assert(width * height >= nRgba);\n    assert(Math.floor(height) === height);\n    assert(Math.floor(width) === width);\n    // Row padding should never be necessary...\n    assert(0 === width % nRgbaPerEntry);\n    return { width, height };\n}\nexport function isFeatureHilited(feature, hilites, isModelHilited) {\n    if (hilites.isEmpty)\n        return false;\n    if (\"union\" === hilites.modelSubCategoryMode)\n        return isModelHilited || hilites.elements.hasPair(feature.elementId) || hilites.subcategories.hasPair(feature.subCategoryId);\n    return hilites.elements.hasPair(feature.elementId) || (isModelHilited && hilites.subcategories.hasPair(feature.subCategoryId));\n}\nconst scratchPackedFeature = PackedFeature.createWithIndex();\n/** @internal */\nexport class FeatureOverrides {\n    get anyOverridden() { return this._anyOverridden; }\n    get allHidden() { return this._allHidden; }\n    get anyTranslucent() { return this._anyTranslucent; }\n    get anyViewIndependentTranslucent() { return this._anyViewIndependentTranslucent; }\n    get anyOpaque() { return this._anyOpaque; }\n    get anyHilited() { return this._anyHilited; }\n    /** For tests. */\n    get lutData() { return this._lut?.dataBytes; }\n    get byteLength() { return undefined !== this._lut ? this._lut.bytesUsed : 0; }\n    get isUniform() { return 2 === this._lutParams[0] && 1 === this._lutParams[1]; }\n    updateUniformSymbologyFlags() {\n        this._uniformSymbologyFlags = 0 /* EmphasisFlags.None */;\n        if (!this.isUniform || !this._lut)\n            return;\n        let flags = this._lut.dataBytes[0];\n        if (0 !== (flags & 16 /* OvrFlags.Flashed */))\n            this._uniformSymbologyFlags |= 4 /* EmphasisFlags.Flashed */;\n        if (0 !== (flags & 32 /* OvrFlags.NonLocatable */))\n            this._uniformSymbologyFlags |= 8 /* EmphasisFlags.NonLocatable */;\n        if (!this._anyHilited)\n            return;\n        flags = this._lut.dataBytes[1] << 8;\n        if (0 !== (flags & 256 /* OvrFlags.Hilited */))\n            this._uniformSymbologyFlags |= 1 /* EmphasisFlags.Hilite */;\n        if (0 !== (flags & 512 /* OvrFlags.Emphasized */))\n            this._uniformSymbologyFlags |= 2 /* EmphasisFlags.Emphasized */;\n    }\n    getUniformOverrides() {\n        assert(this.isUniform);\n        assert(undefined !== this._lut);\n        assert(undefined !== this._lut.dataBytes);\n        return this._lut.dataBytes;\n    }\n    _initialize(map, ovrs, hilite, flashed) {\n        const nFeatures = map.numFeatures;\n        const dims = computeWidthAndHeight(nFeatures, 2);\n        const width = dims.width;\n        const height = dims.height;\n        assert(width * height >= nFeatures);\n        this._lutParams[0] = width;\n        this._lutParams[1] = height;\n        const data = new Uint8Array(width * height * 4);\n        const creator = new Texture2DDataUpdater(data);\n        this.buildLookupTable(creator, map, ovrs, flashed, hilite);\n        return TextureHandle.createForData(width, height, data, true, GL.Texture.WrapMode.ClampToEdge);\n    }\n    _update(map, lut, flashed, hilites, ovrs) {\n        const updater = new Texture2DDataUpdater(lut.dataBytes);\n        if (undefined === ovrs) {\n            this.updateFlashedAndHilited(updater, map, flashed, hilites);\n        }\n        else {\n            assert(undefined !== hilites);\n            this.buildLookupTable(updater, map, ovrs, flashed, hilites);\n        }\n        lut.update(updater);\n    }\n    buildLookupTable(data, map, ovr, flashedIdParts, hilites) {\n        const allowHilite = true !== this._options.noHilite;\n        const allowFlash = true !== this._options.noFlash;\n        const allowEmphasis = true !== this._options.noEmphasis;\n        let isModelHilited = false;\n        const prevModelId = { lower: -1, upper: -1 };\n        this._anyOpaque = this._anyTranslucent = this._anyViewIndependentTranslucent = this._anyHilited = false;\n        let nHidden = 0;\n        let nOverridden = 0;\n        // NB: We currently use 2 RGBA values per feature as follows:\n        //  [0]\n        //      RG = override flags (see OvrFlags enum)\n        //      B = line code\n        //      A = line weight (if we need an extra byte in future, could combine code+weight into a single byte).\n        //  [1]\n        //      RGB = rgb\n        //      A = alpha\n        for (const feature of map.iterable(scratchPackedFeature)) {\n            const i = feature.index;\n            const dataIndex = i * 4 * 2;\n            if (prevModelId.lower !== feature.modelId.lower || prevModelId.upper !== feature.modelId.upper) {\n                prevModelId.lower = feature.modelId.lower;\n                prevModelId.upper = feature.modelId.upper;\n                isModelHilited = allowHilite && hilites.models.hasPair(feature.modelId);\n            }\n            const app = this.target.currentBranch.getFeatureAppearance(ovr, feature.elementId.lower, feature.elementId.upper, feature.subCategoryId.lower, feature.subCategoryId.upper, feature.geometryClass, feature.modelId.lower, feature.modelId.upper, map.type, feature.animationNodeId);\n            // NB: If the appearance is fully transparent, then:\n            //  - For normal (\"primary\") models, getAppearance() returns undefined.\n            //  - For classifier models, getAppearance() returns the appearance, and classification shader will discard fully-transparent classified pixels.\n            // (The latter is how we clip the classified model using the classifiers).\n            if (undefined === app) {\n                // The feature is not visible. We don't care about any of the other overrides, because we're not going to render it.\n                data.setOvrFlagsAtIndex(dataIndex, 1 /* OvrFlags.Visibility */);\n                nHidden++;\n                nOverridden++;\n                continue;\n            }\n            let flags = app.nonLocatable ? 32 /* OvrFlags.NonLocatable */ : 0 /* OvrFlags.None */;\n            if (allowHilite && isFeatureHilited(feature, hilites, isModelHilited)) {\n                flags |= 256 /* OvrFlags.Hilited */;\n                this._anyHilited = true;\n            }\n            if (allowEmphasis && app.emphasized) {\n                flags |= 512 /* OvrFlags.Emphasized */;\n                this._anyHilited = true;\n            }\n            if (app.overridesRgb && app.rgb) {\n                flags |= 2 /* OvrFlags.Rgb */;\n                const rgb = app.rgb;\n                data.setByteAtIndex(dataIndex + 4, rgb.r);\n                data.setByteAtIndex(dataIndex + 5, rgb.g);\n                data.setByteAtIndex(dataIndex + 6, rgb.b);\n            }\n            if (undefined !== app.transparency) {\n                // transparency in range [0, 1]...convert to byte and invert so 0=transparent...\n                flags |= 4 /* OvrFlags.Alpha */;\n                let alpha = 1.0 - app.transparency;\n                alpha = Math.floor(0xff * alpha + 0.5);\n                if ((0xff - alpha) < DisplayParams.minTransparency)\n                    alpha = 0xff;\n                data.setByteAtIndex(dataIndex + 7, alpha);\n                if (0xff === alpha) {\n                    this._anyOpaque = true;\n                }\n                else {\n                    this._anyTranslucent = true;\n                    if (!app.viewDependentTransparency) {\n                        flags |= 1024 /* OvrFlags.ViewIndependentTransparency */;\n                        this._anyViewIndependentTranslucent = true;\n                    }\n                }\n            }\n            if (app.overridesWeight && app.weight) {\n                flags |= 128 /* OvrFlags.Weight */;\n                let weight = app.weight;\n                weight = Math.min(31, weight);\n                weight = Math.max(1, weight);\n                data.setByteAtIndex(dataIndex + 3, weight);\n            }\n            if (app.overridesLinePixels && app.linePixels) {\n                flags |= 64 /* OvrFlags.LineCode */;\n                const lineCode = LineCode.valueFromLinePixels(app.linePixels);\n                data.setByteAtIndex(dataIndex + 2, lineCode);\n            }\n            if (app.ignoresMaterial)\n                flags |= 8 /* OvrFlags.IgnoreMaterial */;\n            if (allowFlash && undefined !== flashedIdParts && feature.elementId.lower === flashedIdParts.lower && feature.elementId.upper === flashedIdParts.upper)\n                flags |= 16 /* OvrFlags.Flashed */;\n            data.setOvrFlagsAtIndex(dataIndex, flags);\n            if (0 /* OvrFlags.None */ !== flags)\n                nOverridden++;\n        }\n        this._allHidden = (nHidden === map.numFeatures);\n        this._anyOverridden = (nOverridden > 0);\n        this.updateUniformSymbologyFlags();\n    }\n    // NB: If hilites is undefined, it means that the hilited set has not changed.\n    updateFlashedAndHilited(data, map, flashed, hilites) {\n        if (!hilites || true === this._options.noHilite) {\n            this.updateFlashed(data, map, flashed);\n            return;\n        }\n        const allowFlash = true !== this._options.noFlash;\n        const intersect = \"intersection\" === hilites.modelSubCategoryMode;\n        this._anyOverridden = this._anyHilited = false;\n        for (const feature of map.iterable(scratchPackedFeature)) {\n            const dataIndex = feature.index * 4 * 2;\n            const oldFlags = data.getOvrFlagsAtIndex(dataIndex);\n            if (0 /* OvrFlags.None */ !== (oldFlags & 1 /* OvrFlags.Visibility */)) {\n                // If it's invisible, none of the other flags matter. We can't flash it and don't want to hilite it.\n                this._anyOverridden = true;\n                continue;\n            }\n            const isModelHilited = hilites.models.hasPair(feature.modelId);\n            let isHilited = isModelHilited && !intersect;\n            if (!isHilited)\n                isHilited = hilites.elements.hasPair(feature.elementId);\n            if (!isHilited)\n                if (isModelHilited || !intersect)\n                    isHilited = hilites.subcategories.hasPair(feature.subCategoryId);\n            let isFlashed = false;\n            if (flashed && allowFlash)\n                isFlashed = feature.elementId.lower === flashed.lower && feature.elementId.upper === flashed.upper;\n            let newFlags = isFlashed ? (oldFlags | 16 /* OvrFlags.Flashed */) : (oldFlags & ~16 /* OvrFlags.Flashed */);\n            newFlags = isHilited ? (newFlags | 256 /* OvrFlags.Hilited */) : (newFlags & ~256 /* OvrFlags.Hilited */);\n            data.setOvrFlagsAtIndex(dataIndex, newFlags);\n            if (0 /* OvrFlags.None */ !== newFlags) {\n                this._anyOverridden = true;\n                this._anyHilited = this._anyHilited || isHilited || 0 /* OvrFlags.None */ !== (newFlags & 512 /* OvrFlags.Emphasized */);\n            }\n        }\n        this.updateUniformSymbologyFlags();\n    }\n    updateFlashed(data, map, flashed) {\n        if (true === this._options.noFlash)\n            return;\n        this._anyOverridden = false;\n        const elemId = { lower: 0, upper: 0 };\n        for (let i = 0; i < map.numFeatures; i++) {\n            const dataIndex = i * 4 * 2;\n            const oldFlags = data.getOvrFlagsAtIndex(dataIndex);\n            if (0 /* OvrFlags.None */ !== (oldFlags & 1 /* OvrFlags.Visibility */)) {\n                // If it's invisible, none of the other flags matter and we can't flash it.\n                this._anyOverridden = true;\n                continue;\n            }\n            let isFlashed = false;\n            if (flashed) {\n                map.getElementIdPair(i, elemId);\n                isFlashed = elemId.lower === flashed.lower && elemId.upper === flashed.upper;\n            }\n            const newFlags = isFlashed ? (oldFlags | 16 /* OvrFlags.Flashed */) : (oldFlags & ~16 /* OvrFlags.Flashed */);\n            data.setOvrFlagsAtIndex(dataIndex, newFlags);\n            if (0 /* OvrFlags.None */ !== newFlags)\n                this._anyOverridden = true;\n        }\n        this.updateUniformSymbologyFlags();\n    }\n    constructor(target, options, cleanup) {\n        this._lastFlashId = Id64.invalid;\n        this._hiliteSyncObserver = {};\n        this._anyOverridden = true;\n        this._allHidden = true;\n        this._anyTranslucent = true;\n        this._anyViewIndependentTranslucent = true;\n        this._anyOpaque = true;\n        this._anyHilited = true;\n        this._lutParams = new Float32Array(2);\n        this._uniformSymbologyFlags = 0 /* EmphasisFlags.None */;\n        this.target = target;\n        this._options = options;\n        this._cleanup = cleanup;\n    }\n    static createFromTarget(target, options, cleanup) {\n        return new FeatureOverrides(target, options, cleanup);\n    }\n    get isDisposed() { return undefined === this._lut; }\n    dispose() {\n        this._lut = dispose(this._lut);\n        if (this._cleanup) {\n            this._cleanup();\n            this._cleanup = undefined;\n        }\n    }\n    initFromMap(map) {\n        const nFeatures = map.numFeatures;\n        assert(0 < nFeatures);\n        this._lut = dispose(this._lut);\n        const ovrs = this.target.currentFeatureSymbologyOverrides;\n        this._mostRecentSymbologyOverrides = ovrs;\n        const hilite = this.target.hilites;\n        this._lut = this._initialize(map, ovrs, hilite, this.target.flashed);\n        this._lastFlashId = Id64.invalid;\n        this._hiliteSyncObserver = {};\n    }\n    update(features) {\n        let ovrs = this.target.currentFeatureSymbologyOverrides;\n        const ovrsUpdated = ovrs !== this._mostRecentSymbologyOverrides;\n        if (ovrsUpdated)\n            this._mostRecentSymbologyOverrides = ovrs;\n        else\n            ovrs = undefined;\n        const flashedId = this.target.flashedId;\n        const hiliteSyncTarget = this.target.hiliteSyncTarget;\n        const hiliteUpdated = !sync(hiliteSyncTarget, this._hiliteSyncObserver);\n        const hilite = this.target.hilites;\n        if (ovrsUpdated || hiliteUpdated || flashedId !== this._lastFlashId) {\n            // _lut can be undefined if context was lost, (gl.createTexture returns null)\n            if (this._lut)\n                this._update(features, this._lut, this.target.flashed, undefined !== ovrs || hiliteUpdated ? hilite : undefined, ovrs);\n            this._lastFlashId = flashedId;\n        }\n    }\n    bindLUTParams(uniform) {\n        uniform.setUniform2fv(this._lutParams);\n    }\n    bindLUT(uniform) {\n        if (this._lut)\n            this._lut.bindSampler(uniform, TextureUnit.FeatureSymbology);\n    }\n    bindUniformSymbologyFlags(uniform) {\n        uniform.setUniform1f(this._uniformSymbologyFlags);\n    }\n}\n//# sourceMappingURL=FeatureOverrides.js.map",
      "start": 1693508124708,
      "end": 1693508124798,
      "sourcemaps": null
    }
  ]
}
