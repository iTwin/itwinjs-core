{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/PlanarMaskTools.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { PlanarClipMaskMode, PlanarClipMaskPriority, PlanarClipMaskSettings } from \"@itwin/core-common\";\nimport { EventHandled, IModelApp, LocateFilterStatus, LocateResponse, PrimitiveTool, Tool, } from \"@itwin/core-frontend\";\nimport { parseBoolean } from \"./parseBoolean\";\n/** Set Map Masking by selected models.\n * @beta\n */\nclass SetMapHigherPriorityMasking extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    async run(transparency, invert) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return false;\n        vp.changeBackgroundMapProps({ planarClipMask: { mode: PlanarClipMaskMode.Priority, priority: PlanarClipMaskPriority.BackgroundMap, transparency, invert } });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n    async parseAndRun(...args) {\n        const transparency = parseFloat(args[0]);\n        let invert;\n        if (args.length > 1)\n            invert = parseBoolean(args[1]);\n        return this.run((transparency !== undefined && transparency < 1.0) ? transparency : 0, invert === true);\n    }\n}\nSetMapHigherPriorityMasking.toolId = \"SetMapHigherPriorityMask\";\nexport { SetMapHigherPriorityMasking };\n/** Unmask Mask.\n * @beta\n */\nclass UnmaskMapTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 0; }\n    async run() {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return false;\n        vp.changeBackgroundMapProps({ planarClipMask: { mode: PlanarClipMaskMode.None, transparency: 0, invert: false } });\n        vp.invalidateRenderPlan();\n        return true;\n    }\n}\nUnmaskMapTool.toolId = \"UnmaskMap\";\nexport { UnmaskMapTool };\n/** Base class for the reality model planar masking tools.\n * @beta\n */\nexport class PlanarMaskBaseTool extends PrimitiveTool {\n    constructor() {\n        super(...arguments);\n        this._acceptedModelIds = new Set();\n        this._acceptedSubCategoryIds = new Set();\n        this._acceptedElementIds = new Set();\n        this._transparency = 0;\n        this._useSelection = false;\n        this._invert = false;\n    }\n    requireWriteableTarget() { return false; }\n    async onPostInstall() {\n        await super.onPostInstall();\n        this.setupAndPromptForNextAction();\n    }\n    async onUnsuspend() { this.showPrompt(); }\n    setupAndPromptForNextAction() {\n        this._useSelection = (undefined !== this.targetView && this.iModel.selectionSet.isActive);\n        this.initLocateElements(!this._useSelection || (this.targetModelRequired() && !this._targetMaskModel));\n        IModelApp.locateManager.options.allowDecorations = true; // So we can select \"contextual\" reality models.\n        this.showPrompt();\n    }\n    targetModelRequired() { return true; }\n    elementRequired() { return true; }\n    allowSelection() { return true; }\n    clearIds() {\n        this._acceptedElementIds.clear();\n        this._acceptedModelIds.clear();\n    }\n    async exitTool() {\n        await super.exitTool();\n        this._transparency = 0;\n    }\n    async onRestartTool() {\n        this.clearIds();\n        this._acceptedSubCategoryIds.clear();\n        const tool = this.createToolInstance();\n        if (!await tool.run())\n            await this.exitTool();\n    }\n    async parseAndRun(...args) {\n        const transparency = parseFloat(args[0]);\n        this._transparency = (transparency !== undefined && transparency < 1.0) ? transparency : 0;\n        if (args.length > 1)\n            this._invert = parseBoolean(args[1]) === true;\n        return this.run();\n    }\n    async onCleanup() {\n        if (0 !== this._acceptedElementIds.size)\n            this.iModel.hilited.setHilite(this._acceptedElementIds, false);\n        this.clearIds();\n    }\n    async filterHit(hit, _out) {\n        if (!hit.modelId)\n            return LocateFilterStatus.Reject;\n        if (undefined === this._targetMaskModel && this.targetModelRequired()) {\n            if (undefined !== hit.viewport.displayStyle.contextRealityModelStates.find((x) => x.modelId === hit.modelId))\n                return LocateFilterStatus.Accept;\n            const model = this.iModel.models.getLoaded(hit.modelId)?.asSpatialModel;\n            return model?.isRealityModel ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n        }\n        else\n            return (hit.isElementHit && !hit.isModelHit && !this._acceptedElementIds.has(hit.sourceId)) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject;\n    }\n    async onDataButtonDown(ev) {\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return EventHandled.No;\n        if (undefined !== hit && undefined === this._targetMaskModel && this.targetModelRequired()) {\n            if (hit.modelId) {\n                this._targetMaskModel = hit.viewport.displayStyle.contextRealityModelStates.find((x) => x.modelId === hit.modelId) ?? hit.modelId;\n                if (!this.elementRequired()) {\n                    this.applyMask(vp);\n                    await this.onRestartTool();\n                }\n            }\n        }\n        else if (this._useSelection && this.iModel.selectionSet.isActive) {\n            const elements = await this.iModel.elements.getProps(this.iModel.selectionSet.elements);\n            for (const element of elements) {\n                if (element.id && element.model) {\n                    this._acceptedElementIds.add(element.id);\n                    this._acceptedModelIds.add(element.model);\n                }\n            }\n            this.applyMask(vp);\n            await this.exitTool();\n            return EventHandled.No;\n        }\n        else if (undefined !== hit && hit.isElementHit) {\n            const sourceId = hit.sourceId;\n            if (!this._acceptedElementIds.has(sourceId)) {\n                this._acceptedElementIds.add(sourceId);\n                this._acceptedModelIds.add(hit.modelId);\n                if (hit.subCategoryId)\n                    this._acceptedSubCategoryIds.add(hit.subCategoryId);\n                this.applyMask(vp);\n            }\n        }\n        this.setupAndPromptForNextAction();\n        return EventHandled.No;\n    }\n    createSubCategoryMask() {\n        return PlanarClipMaskSettings.create({\n            subCategoryIds: this._acceptedSubCategoryIds,\n            modelIds: this._acceptedModelIds,\n            transparency: this._transparency,\n            invert: this._invert,\n        });\n    }\n    createElementMask(option) {\n        return PlanarClipMaskSettings.create({\n            elementIds: this._acceptedElementIds,\n            exclude: \"exclude\" === option,\n            modelIds: this._acceptedModelIds,\n            transparency: this._transparency,\n            invert: this._invert,\n        });\n    }\n    createModelMask() {\n        return PlanarClipMaskSettings.create({ modelIds: this._acceptedModelIds, transparency: this._transparency, invert: this._invert });\n    }\n    setRealityModelMask(vp, mask) {\n        if (typeof this._targetMaskModel === \"string\")\n            vp.displayStyle.settings.planarClipMasks.set(this._targetMaskModel, mask);\n        else if (undefined !== this._targetMaskModel)\n            this._targetMaskModel.planarClipMaskSettings = mask;\n    }\n}\n/** Tool to mask background map by elements\n * @beta\n */\nclass MaskBackgroundMapByElementTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return false; }\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(`FrontendDevTools:tools.MaskBackgroundMapByElement.Prompts.${this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskElement\"}`);\n    }\n    createToolInstance() { return new MaskBackgroundMapByElementTool(); }\n    applyMask(vp) {\n        vp.changeBackgroundMapProps({ planarClipMask: this.createElementMask(\"include\").toJSON() });\n    }\n}\nMaskBackgroundMapByElementTool.toolId = \"MaskBackgroundMapByElement\";\nexport { MaskBackgroundMapByElementTool };\n/** Tool to mask background map by excluded elements\n * @beta\n */\nclass MaskBackgroundMapByExcludedElementTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return false; }\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(`FrontendDevTools:tools.MaskBackgroundMapByExcludedElement.Prompts.${this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskElement\"}`);\n    }\n    createToolInstance() { return new MaskBackgroundMapByExcludedElementTool(); }\n    applyMask(vp) {\n        vp.changeBackgroundMapProps({ planarClipMask: this.createElementMask(\"exclude\").toJSON() });\n    }\n}\nMaskBackgroundMapByExcludedElementTool.toolId = \"MaskBackgroundMapByExcludedElement\";\nexport { MaskBackgroundMapByExcludedElementTool };\n/** Tool to mask background map by SubCategories\n * @beta\n */\nclass MaskBackgroundMapBySubCategoryTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return false; }\n    allowSelection() { return false; } // Need picking to get subcategory.\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(\"FrontendDevTools:tools.MaskBackgroundMapBySubCategory.Prompts.IdentifyMaskSubCategory\");\n    }\n    createToolInstance() { return new MaskBackgroundMapBySubCategoryTool(); }\n    applyMask(vp) {\n        vp.changeBackgroundMapProps({ planarClipMask: this.createSubCategoryMask().toJSON() });\n    }\n}\nMaskBackgroundMapBySubCategoryTool.toolId = \"MaskBackgroundMapBySubCategory\";\nexport { MaskBackgroundMapBySubCategoryTool };\n/** Tool to mask background map by geometric models\n * @beta\n */\nclass MaskBackgroundMapByModelTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return false; }\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(`FrontendDevTools:tools.MaskBackgroundMapByModel.Prompts.${this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskModel\"}`);\n    }\n    createToolInstance() { return new MaskBackgroundMapByModelTool(); }\n    applyMask(vp) {\n        vp.changeBackgroundMapProps({ planarClipMask: this.createModelMask().toJSON() });\n    }\n}\nMaskBackgroundMapByModelTool.toolId = \"MaskBackgroundMapByModel\";\nexport { MaskBackgroundMapByModelTool };\n/** Tool to mask reality model by elements\n * @beta\n */\nclass MaskRealityModelByElementTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return true; }\n    showPrompt() {\n        const key = `FrontendDevTools:tools.MaskRealityModelByElement.Prompts.${this._targetMaskModel === undefined ? \"IdentifyRealityModel\" : (this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskElement\")}`;\n        IModelApp.notifications.outputPromptByKey(key);\n    }\n    createToolInstance() { return new MaskRealityModelByElementTool(); }\n    applyMask(vp) {\n        this.setRealityModelMask(vp, this.createElementMask(\"include\"));\n    }\n}\nMaskRealityModelByElementTool.toolId = \"MaskRealityModelByElement\";\nexport { MaskRealityModelByElementTool };\n/** Tool to mask reality model by excluded elements\n * @beta\n */\nclass MaskRealityModelByExcludedElementTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return true; }\n    showPrompt() {\n        const key = `FrontendDevTools:tools.MaskRealityModelByExcludedElement.Prompts.${this._targetMaskModel === undefined ? \"IdentifyRealityModel\" : (this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskElement\")}`;\n        IModelApp.notifications.outputPromptByKey(key);\n    }\n    createToolInstance() { return new MaskRealityModelByExcludedElementTool(); }\n    applyMask(vp) {\n        this.setRealityModelMask(vp, this.createElementMask(\"exclude\"));\n    }\n}\nMaskRealityModelByExcludedElementTool.toolId = \"MaskRealityModelByExcludedElement\";\nexport { MaskRealityModelByExcludedElementTool };\n/** Tool to mask reality model by geometric models\n * @beta\n */\nclass MaskRealityModelByModelTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return true; }\n    showPrompt() {\n        const key = `FrontendDevTools:tools.MaskRealityModelByModel.Prompts.${this._targetMaskModel === undefined ? \"IdentifyRealityModel\" : (this._useSelection ? \"AcceptSelection\" : \"IdentifyMaskModel\")}`;\n        IModelApp.notifications.outputPromptByKey(key);\n    }\n    createToolInstance() { return new MaskRealityModelByModelTool(); }\n    applyMask(vp) {\n        this.setRealityModelMask(vp, this.createModelMask());\n    }\n}\nMaskRealityModelByModelTool.toolId = \"MaskRealityModelByModel\";\nexport { MaskRealityModelByModelTool };\n/** Tool to mask reality model by SubCategories\n * @beta\n */\nclass MaskRealityModelBySubCategoryTool extends PlanarMaskBaseTool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 2; }\n    targetModelRequired() { return true; }\n    allowSelection() { return false; } // Need picking to get subcategory.\n    showPrompt() {\n        const key = `FrontendDevTools:tools.MaskRealityModelByModel.Prompts.${this._targetMaskModel === undefined ? \"IdentifyRealityModel\" : \"IdentifyMaskSubCategory\"}`;\n        IModelApp.notifications.outputPromptByKey(key);\n    }\n    createToolInstance() { return new MaskRealityModelBySubCategoryTool(); }\n    applyMask(vp) {\n        this.setRealityModelMask(vp, this.createSubCategoryMask());\n    }\n}\nMaskRealityModelBySubCategoryTool.toolId = \"MaskRealityModelBySubCategory\";\nexport { MaskRealityModelBySubCategoryTool };\n/** Tool to mask reality model by higher priority models.\n * @beta\n */\nclass SetHigherPriorityRealityModelMasking extends PlanarMaskBaseTool {\n    constructor() {\n        super(...arguments);\n        this._priority = 0;\n    }\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 3; }\n    targetModelRequired() { return true; }\n    elementRequired() { return false; }\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(\"FrontendDevTools:tools.SetHigherPriorityRealityModelMasking.Prompts.IdentifyRealityModel\");\n    }\n    createToolInstance() { return new SetHigherPriorityRealityModelMasking(); }\n    applyMask(vp) {\n        const basePriority = this._targetMaskModel === vp.displayStyle.getOSMBuildingRealityModel() ? PlanarClipMaskPriority.GlobalRealityModel : PlanarClipMaskPriority.RealityModel;\n        this.setRealityModelMask(vp, PlanarClipMaskSettings.create({ priority: basePriority + this._priority, transparency: this._transparency, invert: this._invert }));\n    }\n    async parseAndRun(...args) {\n        await super.parseAndRun(...args);\n        const priority = parseInt(args[0], 10);\n        this._priority = (priority === undefined || isNaN(priority)) ? 0 : priority;\n        if (args.length > 1) {\n            const value = parseInt(args[1], 10);\n            if (!isNaN(value) && value >= 0 && value <= 1)\n                this._transparency = value;\n        }\n        if (args.length > 2)\n            this._invert = parseBoolean(args[2]) === true;\n        return this.run();\n    }\n}\nSetHigherPriorityRealityModelMasking.toolId = \"SetHigherPriorityRealityModelMasking\";\nexport { SetHigherPriorityRealityModelMasking };\n/** Remove masks from reality model.\n * @beta\n */\nclass UnmaskRealityModelTool extends PlanarMaskBaseTool {\n    targetModelRequired() { return true; }\n    showPrompt() {\n        IModelApp.notifications.outputPromptByKey(\"FrontendDevTools:tools.UnmaskRealityModel.Prompts.IdentifyRealityModel\");\n    }\n    createToolInstance() { return new UnmaskRealityModelTool(); }\n    applyMask(vp) {\n        const settings = PlanarClipMaskSettings.create({ subCategoryIds: this._acceptedSubCategoryIds, modelIds: this._acceptedModelIds });\n        this.setRealityModelMask(vp, settings);\n    }\n    async onDataButtonDown(ev) {\n        const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n        if (hit?.modelId) {\n            const model = hit.viewport.displayStyle.contextRealityModelStates.find((x) => x.modelId === hit.modelId);\n            if (model)\n                model.planarClipMaskSettings = undefined;\n            else\n                hit.viewport.displayStyle.settings.planarClipMasks.delete(hit.modelId);\n            await this.onRestartTool();\n        }\n        return EventHandled.No;\n    }\n}\nUnmaskRealityModelTool.toolId = \"UnmaskRealityModel\";\nexport { UnmaskRealityModelTool };\n//# sourceMappingURL=PlanarMaskTools.js.map",
      "start": 1693508122692,
      "end": 1693508122771,
      "sourcemaps": null
    }
  ]
}
