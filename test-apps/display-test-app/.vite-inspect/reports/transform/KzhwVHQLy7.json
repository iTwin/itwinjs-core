{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/GrowableFloat64Array.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/**\n * A `GrowableFloat64Array` is Float64Array accompanied by a count of how many of the array's entries are considered in use.\n * * In C++ terms, this is like an std::vector\n * * As entries are added to the array, the buffer is reallocated as needed to accommodate.\n * * The reallocations leave unused space to accept further additional entries without reallocation.\n * * The `length` property returns the number of entries in use.\n * * the `capacity` property returns the (usually larger) length of the (over-allocated) Float64Array.\n * @public\n */\nexport class GrowableFloat64Array {\n    /** Construct a GrowableFloat64Array.\n     * @param initialCapacity initial capacity (default 8)\n     * @param growthFactor used by ensureCapacity to expand requested reallocation size (default 1.5)\n     */\n    constructor(initialCapacity = 8, growthFactor) {\n        this._data = new Float64Array(initialCapacity);\n        this._inUse = 0;\n        this._growthFactor = (undefined !== growthFactor && growthFactor >= 1.0) ? growthFactor : 1.5;\n    }\n    /** Copy data from source array. Does not reallocate or change active entry count.\n     * @param source array to copy from\n     * @param sourceCount copy the first sourceCount entries; all entries if undefined\n     * @param destOffset copy to instance array starting at this index; zero if undefined\n     * @return count and offset of entries copied\n     */\n    copyData(source, sourceCount, destOffset) {\n        let myOffset = destOffset ?? 0;\n        if (myOffset < 0)\n            myOffset = 0;\n        if (myOffset >= this._data.length)\n            return { count: 0, offset: 0 };\n        let myCount = sourceCount ?? source.length;\n        if (myCount > 0) {\n            if (myCount > source.length)\n                myCount = source.length;\n            if (myOffset + myCount > this._data.length)\n                myCount = this._data.length - myOffset;\n        }\n        if (myCount <= 0)\n            return { count: 0, offset: 0 };\n        if (myCount === source.length)\n            this._data.set(source, myOffset);\n        else if (source instanceof Float64Array)\n            this._data.set(source.subarray(0, myCount), myOffset);\n        else\n            this._data.set(source.slice(0, myCount), myOffset);\n        return { count: myCount, offset: myOffset };\n    }\n    /**\n     * Create a GrowableFloat64Array with given contents.\n     * @param contents data to copy into the array\n     */\n    static create(contents) {\n        const out = new GrowableFloat64Array(contents.length);\n        out.copyData(contents);\n        out._inUse = contents.length;\n        return out;\n    }\n    /** sort-compatible comparison.\n     * * Returns `(a-b)` which is\n     *   * negative if `a<b`\n     *   * zero if `a === b` (with exact equality)\n     *   * positive if `a>b`\n     */\n    static compare(a, b) {\n        return a - b;\n    }\n    /** Return a new array with\n     * * All active entries copied from this instance\n     * * optionally trimmed capacity to the active length or replicate the capacity and unused space.\n     */\n    clone(maintainExcessCapacity = false) {\n        const out = new GrowableFloat64Array(maintainExcessCapacity ? this.capacity() : this._inUse);\n        out.copyData(this._data, this._inUse);\n        out._inUse = this._inUse;\n        return out;\n    }\n    /**\n     * Returns the number of entries in use.\n     * * Note that this is typically smaller than the length of the length of the supporting `Float64Array`\n     */\n    get length() {\n        return this._inUse;\n    }\n    /**\n     * Set the value at specified index.\n     * @param index index of entry to set\n     * @param value value to set\n     */\n    setAtUncheckedIndex(index, value) {\n        this._data[index] = value;\n    }\n    /**\n     * Move the value at index i to index j.\n     * @param i source index\n     * @param j destination index.\n     */\n    move(i, j) {\n        this._data[j] = this._data[i];\n    }\n    /**\n     * swap the values at indices i and j\n     * @param i first index\n     * @param j second index\n     */\n    swap(i, j) {\n        const a = this._data[i];\n        this._data[i] = this._data[j];\n        this._data[j] = a;\n    }\n    /**\n     * append a single value to the array.\n     * @param toPush value to append to the active array.\n     */\n    push(toPush) {\n        this.ensureCapacity(this._inUse + 1);\n        this._data[this._inUse] = toPush;\n        this._inUse++;\n    }\n    /**\n     * Push each value from an array.\n     * @param data array of values to push\n     */\n    pushArray(data) {\n        this.ensureCapacity(this._inUse + data.length);\n        this.copyData(data, data.length, this._inUse);\n        this._inUse += data.length;\n    }\n    /** Push `numToCopy` consecutive values starting at `copyFromIndex`. */\n    pushBlockCopy(copyFromIndex, numToCopy) {\n        if (copyFromIndex >= 0 && copyFromIndex < this._inUse && numToCopy > 0 && copyFromIndex + numToCopy <= this._inUse) {\n            this.ensureCapacity(this._inUse + numToCopy);\n            this._data.copyWithin(this._inUse, copyFromIndex, copyFromIndex + numToCopy);\n            this._inUse += numToCopy;\n        }\n    }\n    /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */\n    clear() {\n        this._inUse = 0;\n    }\n    /**\n     * Returns the number of entries in the supporting Float64Array buffer.\n     * * This number can be larger than the `length` property.\n     */\n    capacity() {\n        return this._data.length;\n    }\n    /**\n     * * If the capacity (Float64Array length) is less than or equal to the requested newCapacity, do nothing.\n     * * If the requested newCapacity is larger than the existing capacity, reallocate to larger capacity, and copy existing values.\n     * @param newCapacity size of new array\n     * @param applyGrowthFactor whether to apply the growth factor to newCapacity when reallocating\n     */\n    ensureCapacity(newCapacity, applyGrowthFactor = true) {\n        if (newCapacity > this.capacity()) {\n            if (applyGrowthFactor)\n                newCapacity *= this._growthFactor;\n            const prevData = this._data;\n            this._data = new Float64Array(newCapacity);\n            this.copyData(prevData, this._inUse);\n        }\n    }\n    /**\n     * * If newLength is less than current length, just reset current length to newLength, effectively trimming active entries but preserving original capacity.\n     * * If newLength is greater than current length, reallocate to (exactly) newLength, copy existing entries, and pad with padValue up to newLength.\n     * @param newLength new data count\n     * @param padValue value to use for padding if the length increases.\n     */\n    resize(newLength, padValue = 0) {\n        if (newLength >= 0 && newLength < this._inUse)\n            this._inUse = newLength;\n        else if (newLength > this._inUse) {\n            this.ensureCapacity(newLength, false);\n            this._data.fill(padValue, this._inUse);\n            this._inUse = newLength;\n        }\n    }\n    /**\n     * * Reduce the length by one.\n     * * Note that there is no method return value -- use `back` to get that value before `pop()`\n     * * (As with std::vector, separating the `pop` from the value access eliminates error testing from `pop` call)\n     */\n    pop() {\n        // Could technically access outside of array, if filled and then reduced using pop (similar to C\n        // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten\n        if (this._inUse > 0) {\n            this._inUse--;\n        }\n    }\n    /** Access by index, without bounds check */\n    atUncheckedIndex(index) {\n        return this._data[index];\n    }\n    /** Access the 0-index member, without bounds check */\n    front() {\n        return this._data[0];\n    }\n    /** Access the final member, without bounds check */\n    back() {\n        return this._data[this._inUse - 1];\n    }\n    /** set a value by index */\n    reassign(index, value) {\n        this._data[index] = value;\n    }\n    /**\n     * * Sort the array entries.\n     * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays\n     * @param compareMethod comparison method\n     */\n    sort(compareMethod = (a, b) => GrowableFloat64Array.compare(a, b)) {\n        for (let i = 0; i < this._inUse; i++) {\n            for (let j = i + 1; j < this._inUse; j++) {\n                const tempI = this._data[i];\n                const tempJ = this._data[j];\n                if (compareMethod(tempI, tempJ) > 0) {\n                    this._data[i] = tempJ;\n                    this._data[j] = tempI;\n                }\n            }\n        }\n    }\n    /**\n     * * compress out values not within the [a,b] interval.\n     * * Note that if a is greater than b all values are rejected.\n     * @param a low value for accepted interval\n     * @param b high value for accepted interval\n     */\n    restrictToInterval(a, b) {\n        const data = this._data;\n        const n = data.length;\n        let numAccept = 0;\n        let q = 0;\n        for (let i = 0; i < n; i++) {\n            q = data[i];\n            if (q >= a && q <= b)\n                data[numAccept++] = q;\n        }\n        this._inUse = numAccept;\n    }\n    /**\n     * * compress out multiple copies of values.\n     * * this is done in the current order of the array.\n     */\n    compressAdjacentDuplicates(tolerance = 0.0) {\n        const data = this._data;\n        const n = this._inUse;\n        if (n === 0)\n            return;\n        let numAccepted = 1;\n        let a = data[0];\n        let b;\n        for (let i = 1; i < n; i++) {\n            b = data[i];\n            if (Math.abs(b - a) > tolerance) {\n                data[numAccepted++] = b;\n                a = b;\n            }\n        }\n        this._inUse = numAccepted;\n    }\n}\n//# sourceMappingURL=GrowableFloat64Array.js.map",
      "start": 1693508123055,
      "end": 1693508123258,
      "sourcemaps": null
    }
  ]
}
