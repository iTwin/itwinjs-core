{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/QuadId.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, compareNumbers } from \"@itwin/core-bentley\";\nimport { Angle, AngleSweep, Range2d } from \"@itwin/core-geometry\";\nimport { Cartographic } from \"@itwin/core-common\";\nconst scratchCartographic1 = Cartographic.createZero();\nconst scratchCartographic2 = Cartographic.createZero();\n/** Identifies a node within a [quad tree](https://en.wikipedia.org/wiki/Quadtree), such as a [[MapTile]] within a [[MapTileTree]].\n * A quad tree recursively sub-divides a two-dimensional space along the X and Y axes such that each node on level L has four child nodes on\n * level L+1.\n * @public\n */\nexport class QuadId {\n    /** @alpha */\n    get isValid() {\n        return this.level >= 0;\n    }\n    /** @alpha */\n    static createFromContentId(stringId) {\n        const idParts = stringId.split(\"_\");\n        assert(idParts.length === 3);\n        if (3 !== idParts.length)\n            return new QuadId(-1, -1, -1);\n        return new QuadId(parseInt(idParts[0], 10), parseInt(idParts[1], 10), parseInt(idParts[2], 10));\n    }\n    /** @alpha */\n    get contentId() {\n        return QuadId.getTileContentId(this.level, this.column, this.row);\n    }\n    /** @alpha */\n    static getTileContentId(level, column, row) {\n        return `${level}_${column}_${row}`;\n    }\n    /** @alpha */\n    get debugString() {\n        return `Level: ${this.level} Column: ${this.column} Row: ${this.row}`;\n    }\n    /** Construct a new QuadId. The inputs are expected to be non-negative integers. */\n    constructor(level, column, row) {\n        this.level = level;\n        this.column = column;\n        this.row = row;\n    }\n    /** Compute the QuadIds corresponding to this node's four child nodes. */\n    getChildIds(columnCount = 2, rowCount = 2) {\n        const childIds = [];\n        const level = this.level + 1;\n        const column = this.column * 2;\n        const row = this.row * 2;\n        for (let j = 0; j < rowCount; j++)\n            for (let i = 0; i < columnCount; i++)\n                childIds.push(new QuadId(level, column + i, row + j));\n        return childIds;\n    }\n    /** Compute the region of the surface of the Earth represented by this node according to the specified tiling scheme. */\n    getLatLongRangeDegrees(mapTilingScheme) {\n        return this._getLatLongRange(mapTilingScheme, \"degrees\");\n    }\n    /** Compute the region of the surface of the Earth represented by this node according to the specified tiling scheme. */\n    getLatLongRangeRadians(mapTilingScheme) {\n        return this._getLatLongRange(mapTilingScheme, \"radians\");\n    }\n    _getLatLongRange(mapTilingScheme, units) {\n        const range = Range2d.createNull();\n        const factor = \"degrees\" === units ? Angle.degreesPerRadian : 1;\n        mapTilingScheme.tileXYToCartographic(this.column, this.row, this.level, scratchCartographic1);\n        range.extendXY(scratchCartographic1.longitude * factor, scratchCartographic1.latitude * factor);\n        mapTilingScheme.tileXYToCartographic(this.column + 1, this.row + 1, this.level, scratchCartographic2);\n        range.extendXY(scratchCartographic2.longitude * factor, scratchCartographic2.latitude * factor);\n        return range;\n    }\n    /** @alpha */\n    getAngleSweep(mapTilingScheme) {\n        mapTilingScheme.tileXYToCartographic(this.column, this.row, this.level, scratchCartographic1);\n        mapTilingScheme.tileXYToCartographic(this.column + 1, this.row + 1, this.level, scratchCartographic2);\n        return {\n            longitude: AngleSweep.createStartEndRadians(scratchCartographic1.longitude, scratchCartographic2.longitude),\n            latitude: AngleSweep.createStartEndRadians(Cartographic.parametricLatitudeFromGeodeticLatitude(scratchCartographic1.latitude), Cartographic.parametricLatitudeFromGeodeticLatitude(scratchCartographic2.latitude)),\n        };\n    }\n    /** Returns true if this node is adjacent to the south pole according to the specified tiling scheme. */\n    bordersSouthPole(mapTilingScheme) {\n        return mapTilingScheme.tileBordersSouthPole(this.row, this.level);\n    }\n    /** Returns true if this node is adjacent to the north pole according to the specified tiling scheme. */\n    bordersNorthPole(mapTilingScheme) {\n        return mapTilingScheme.tileBordersNorthPole(this.row, this.level);\n    }\n    /** Compares this Id to another according to the conventions of an [OrderedComparator]($bentley). */\n    compare(other) {\n        return compareNumbers(this.level, other.level) ||\n            compareNumbers(this.row, other.row) ||\n            compareNumbers(this.column, other.column);\n    }\n}\n//# sourceMappingURL=QuadId.js.map",
      "start": 1693508121328,
      "end": 1693508121648,
      "sourcemaps": null
    }
  ]
}
