{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/ecrs/projection/LambertConical2SP.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { OperationMethod } from \"../OperationMethod\";\n/**\n * Class LambertConical2SP defines a Lambert Conical Conformal map projection with 2 standard parallels.\n *\n * The 'source' CRS is the geographic CRS.\n * The 'target' CRS is the projected CRS.\n *\n * Based on the following document:\n *\n * Coordinate Conversions and Transformations including Formulas\n * Guidance Note Number 7, part 2\n * Revised May 2005\n * Available at: http://www.epsg.org/\n *\n * Formulas: see 1.4.1.1 -> 1.4.1.4\n *\n * @version 1.0 July 2005\n */\n/** @internal */\nclass LambertConical2SP extends OperationMethod {\n    /**\n       * Create a new projection.\n       * @param parameters the values of the parameters.\n       */\n    constructor(parameters) {\n        super(LambertConical2SP.METHOD_CODE, \"Lambert Conic Conformal (2SP)\", parameters);\n        /* Store the parameters */\n        this._latF = parameters.getValue(8821);\n        this._lonF = parameters.getValue(8822);\n        this._lat1 = parameters.getValue(8823);\n        this._lat2 = parameters.getValue(8824);\n        this._eF = parameters.getValue(8826);\n        this._nF = parameters.getValue(8827);\n    }\n    /**\n       * Get the sign of a number.\n       */\n    static sign(v) {\n        return (v < 0.0) ? (-1.0) : (1.0);\n    }\n    /**\n       * Get the square of a number.\n       */\n    static square(v) {\n        return (v * v);\n    }\n    /**\n       * Calculate M.\n       */\n    static calcM(e, lat) {\n        return Math.cos(lat) / Math.sqrt(1.0 - LambertConical2SP.square(e * Math.sin(lat)));\n    }\n    /**\n       * Calculate T.\n       */\n    static calcT(e, lat) {\n        return Math.tan(Math.PI * 0.25 - lat * 0.5) / Math.pow((1.0 - e * Math.sin(lat)) / (1.0 + e * Math.sin(lat)), e * 0.5);\n    }\n    /**\n       * Calculate R.\n       */\n    static calcR(a, F, t, n) {\n        if (Math.abs(t) < 1.0e-6)\n            return 0.0;\n        return a * F * Math.pow(t, n);\n    }\n    /**\n       * Initialize the projection.\n       * @param ellipsoid the ellipsoid to use.\n       * @return this projection (for convenience).\n       */\n    initializeProjection(ellipsoid) {\n        /* Get the ellipsoid parameters */\n        this._e = ellipsoid.getE();\n        this._a = ellipsoid.getA();\n        /* Make the calculation */\n        this._m1 = LambertConical2SP.calcM(this._e, this._lat1);\n        this._m2 = LambertConical2SP.calcM(this._e, this._lat2);\n        this._t1 = LambertConical2SP.calcT(this._e, this._lat1);\n        this._t2 = LambertConical2SP.calcT(this._e, this._lat2);\n        this._tF = LambertConical2SP.calcT(this._e, this._latF);\n        this._n = (Math.log(this._m1) - Math.log(this._m2)) / (Math.log(this._t1) - Math.log(this._t2));\n        this._F = this._m1 / (this._n * Math.pow(this._t1, this._n));\n        this._rF = LambertConical2SP.calcR(this._a, this._F, this._tF, this._n);\n        /* Return the projection */\n        return this;\n    }\n    /**\n       * Do the projection.\n       * @param lon the longitude (radians).\n       * @param lat the latitude (radians).\n       * @param projected the target projected coordinate (X and Y will be set).\n       */\n    toProjection(lon, lat, projected) {\n        /* Make the calculation */\n        const t = LambertConical2SP.calcT(this._e, lat);\n        const r = LambertConical2SP.calcR(this._a, this._F, t, this._n);\n        const theta = this._n * (lon - this._lonF);\n        const E = this._eF + r * Math.sin(theta);\n        const N = this._nF + this._rF - r * Math.cos(theta);\n        /* Save the position */\n        projected.setX(E);\n        projected.setY(N);\n    }\n    /**\n       * Do the inverse projection.\n       * @param x the easting.\n       * @param y the northing.\n       * @param geographic the target geographic coordinate (X/Lon and Y/Lat will be set) (radians).\n       */\n    toGeoGraphic(x, y, geographic) {\n        /* Get the parameters */\n        const E = x;\n        const N = y;\n        /* Make the calculation */\n        const r_ = LambertConical2SP.sign(this._n) * Math.sqrt(LambertConical2SP.square(E - this._eF) + LambertConical2SP.square(this._rF - (N - this._nF)));\n        const t_ = Math.pow(r_ / (this._a * this._F), 1.0 / this._n);\n        const theta_ = Math.atan((E - this._eF) / (this._rF - (N - this._nF)));\n        let lat = LambertConical2SP.PI * 0.5 - 2.0 * Math.atan(t_);\n        const he = 0.5 * this._e;\n        for (let i = 0; i < 7; i++) // double-checked iteration count. LER, 24/11/2011\n         {\n            const eSin = this._e * Math.sin(lat);\n            lat = LambertConical2SP.hPI - 2.0 * Math.atan(t_ * Math.pow((1.0 - eSin) / (1.0 + eSin), he)); // recursive formula\n        }\n        const lon = (theta_) / this._n + this._lonF;\n        /* Save the position */\n        geographic.setX(lon);\n        geographic.setY(lat);\n    }\n    /**\n       * OperationMethod method.\n       * @see OperationMethod#initialize\n       */\n    initialize(operation) {\n        this.initializeProjection(operation.getSourceCRS().getEllipsoid());\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#forward\n       */\n    forward(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const lon = source.getX();\n        const lat = source.getY();\n        /* Do the projection */\n        this.toProjection(lon, lat, target);\n        target.setZ(source.getZ()); // Keep the Z value\n    }\n    /**\n       * OperationMethod interface method.\n       * @see OperationMethod#reverse\n       */\n    reverse(sourceCRS, source, targetCRS, target) {\n        /* Get the parameters */\n        const E = target.getX();\n        const N = target.getY();\n        /* Do the inverse projection */\n        this.toGeoGraphic(E, N, source);\n        source.setZ(target.getZ()); // Keep the Z value\n    }\n}\n/** The code of this method */\nLambertConical2SP.METHOD_CODE = 9802;\n/** The value of PI */\nLambertConical2SP.PI = Math.PI;\n/** The half value of PI */\nLambertConical2SP.hPI = 0.5 * Math.PI;\nexport { LambertConical2SP };\n//# sourceMappingURL=LambertConical2SP.js.map",
      "start": 1693508127372,
      "end": 1693508127424,
      "sourcemaps": null
    }
  ]
}
