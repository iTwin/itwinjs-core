{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapTileTree.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, compareBooleans, compareBooleansOrUndefined, compareNumbers, compareStrings, compareStringsOrUndefined, CompressedId64Set } from \"@itwin/core-bentley\";\nimport { Cartographic, FeatureAppearance, GeoCoordStatus, GlobeMode, MapLayerSettings, PlanarClipMaskPriority, TerrainHeightOriginMode, } from \"@itwin/core-common\";\nimport { Angle, AngleSweep, Constant, Ellipsoid, EllipsoidPatch, Point3d, Range1d, Range3d, Ray3d, Transform, Vector3d, } from \"@itwin/core-geometry\";\nimport { ApproximateTerrainHeights } from \"../../ApproximateTerrainHeights\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { PlanarClipMaskState } from \"../../PlanarClipMaskState\";\nimport { FeatureSymbology } from \"../../render/FeatureSymbology\";\nimport { BingElevationProvider, createDefaultViewFlagOverrides, createMapLayerTreeReference, EllipsoidTerrainProvider, GraphicsCollectorDrawArgs, ImageryMapTileTree, ImageryTileTreeState, MapCartoRectangle, MapLayerTileTreeReference, MapTile, MapTileLoader, ModelMapLayerTileTreeReference, PlanarTilePatch, QuadId, RealityTileDrawArgs, RealityTileTree, TileTreeLoadStatus, TileTreeReference, UpsampledMapTile, WebMercatorTilingScheme, } from \"../internal\";\nconst scratchPoint = Point3d.create();\nconst scratchCorners = [Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero()];\nconst scratchCorner = Point3d.createZero();\nconst scratchZNormal = Vector3d.create(0, 0, 1);\n/** Map tile tree scale range visibility values.\n * @beta */\nexport var MapTileTreeScaleRangeVisibility;\n(function (MapTileTreeScaleRangeVisibility) {\n    /** state is currently unknown (i.e. never been displayed)  */\n    MapTileTreeScaleRangeVisibility[MapTileTreeScaleRangeVisibility[\"Unknown\"] = 0] = \"Unknown\";\n    /** all currently selected tree tiles are visible (i.e within the scale range)  */\n    MapTileTreeScaleRangeVisibility[MapTileTreeScaleRangeVisibility[\"Visible\"] = 1] = \"Visible\";\n    /** all currently selected tree tiles are hidden (i.e outside the scale range)  */\n    MapTileTreeScaleRangeVisibility[MapTileTreeScaleRangeVisibility[\"Hidden\"] = 2] = \"Hidden\";\n    /** currently selected tree tiles are partially visible (i.e some tiles are within the scale range, and some are outside.) */\n    MapTileTreeScaleRangeVisibility[MapTileTreeScaleRangeVisibility[\"Partial\"] = 3] = \"Partial\";\n})(MapTileTreeScaleRangeVisibility || (MapTileTreeScaleRangeVisibility = {}));\n/** A [quad tree](https://en.wikipedia.org/wiki/Quadtree) consisting of [[MapTile]]s representing the map imagery draped onto the surface of the Earth.\n * A `MapTileTree` enables display of a globe or planar map with [map imagery](https://en.wikipedia.org/wiki/Tiled_web_map) obtained from any number of sources, such as\n * [Bing](https://learn.microsoft.com/en-us/bingmaps/), [OpenStreetMap](https://wiki.openstreetmap.org/wiki/API), and [GIS servers](https://wiki.openstreetmap.org/wiki/API).\n * The specific imagery displayed is determined by a [[Viewport]]'s [MapImagerySettings]($common) and [BackgroundMapSettings]($common).\n *\n * The map or globe may be smooth, or feature 3d geometry supplied by a [[TerrainProvider]].\n * The terrain displayed in a [[Viewport]] is determined by its [TerrainSettings]($common).\n * @public\n */\nclass MapTileTree extends RealityTileTree {\n    /** @internal */\n    constructor(params, ecefToDb, bimElevationBias, geodeticOffset, sourceTilingScheme, id, applyTerrain) {\n        super(params);\n        /** @internal */\n        this.layerImageryTrees = [];\n        this._layerSettings = new Map();\n        this._imageryTreeState = new Map();\n        this._modelIdToIndex = new Map();\n        /** @internal */\n        this.layerClassifiers = new Map();\n        this.ecefToDb = ecefToDb;\n        this.bimElevationBias = bimElevationBias;\n        this.geodeticOffset = geodeticOffset;\n        this.sourceTilingScheme = sourceTilingScheme;\n        this._mercatorTilingScheme = new WebMercatorTilingScheme();\n        this._mercatorFractionToDb = this._mercatorTilingScheme.computeMercatorFractionToDb(ecefToDb, bimElevationBias, params.iModel, applyTerrain);\n        const quadId = new QuadId(sourceTilingScheme.rootLevel, 0, 0);\n        this.globeOrigin = this.ecefToDb.getOrigin().clone();\n        this.earthEllipsoid = Ellipsoid.createCenterMatrixRadii(this.globeOrigin, this.ecefToDb.matrix, Constant.earthRadiusWGS84.equator, Constant.earthRadiusWGS84.equator, Constant.earthRadiusWGS84.polar);\n        const globalHeightRange = applyTerrain ? ApproximateTerrainHeights.instance.globalHeightRange : Range1d.createXX(0, 0);\n        const globalRectangle = MapCartoRectangle.createMaximum();\n        this.globeMode = id.globeMode;\n        this.isOverlay = id.isOverlay;\n        this.useDepthBuffer = id.useDepthBuffer;\n        this.terrainExaggeration = id.terrainExaggeration;\n        this.baseColor = id.baseColor;\n        this.baseTransparent = id.baseTransparent;\n        this.mapTransparent = id.mapTransparent;\n        if (applyTerrain) {\n            this.minEarthEllipsoid = Ellipsoid.createCenterMatrixRadii(this.globeOrigin, this.ecefToDb.matrix, Constant.earthRadiusWGS84.equator + globalHeightRange.low, Constant.earthRadiusWGS84.equator + globalHeightRange.low, Constant.earthRadiusWGS84.polar + globalHeightRange.low);\n            this.maxEarthEllipsoid = Ellipsoid.createCenterMatrixRadii(this.globeOrigin, this.ecefToDb.matrix, Constant.earthRadiusWGS84.equator + globalHeightRange.high, Constant.earthRadiusWGS84.equator + globalHeightRange.high, Constant.earthRadiusWGS84.polar + globalHeightRange.high);\n            this.produceGeometry = id.produceGeometry;\n        }\n        else {\n            this.minEarthEllipsoid = this.earthEllipsoid;\n            this.maxEarthEllipsoid = this.earthEllipsoid;\n        }\n        const rootPatch = EllipsoidPatch.createCapture(this.maxEarthEllipsoid, AngleSweep.createStartSweepRadians(0, Angle.pi2Radians), AngleSweep.createStartSweepRadians(-Angle.piOver2Radians, Angle.piRadians));\n        let range;\n        if (this.globeMode === GlobeMode.Ellipsoid) {\n            range = rootPatch.range();\n        }\n        else {\n            const corners = this.getFractionalTileCorners(quadId);\n            this._mercatorFractionToDb.multiplyPoint3dArrayInPlace(corners);\n            range = Range3d.createArray(MapTile.computeRangeCorners(corners, Vector3d.create(0, 0, 1), 0, scratchCorners, globalHeightRange));\n        }\n        this._rootTile = this.createGlobeChild({ contentId: quadId.contentId, maximumSize: 0, range }, quadId, range.corners(), globalRectangle, rootPatch, undefined);\n    }\n    /** @internal */\n    get parentsAndChildrenExclusive() {\n        // If we are not depth buffering we force parents and exclusive to false to cause the map tiles to be sorted\n        // by depth so that painters algorithm will approximate correct depth display.\n        return this.useDepthBuffer ? this.loader.parentsAndChildrenExclusive : false;\n    }\n    /** Return the imagery tile tree state of matching the provided imagery tree id.\n     * @internal\n     */\n    getImageryTreeState(imageryTreeId) {\n        return this._imageryTreeState.get(imageryTreeId);\n    }\n    /** Return a cloned dictionary of the imagery tile tree states\n     * @internal\n     */\n    cloneImageryTreeState() {\n        const clone = new Map();\n        for (const [treeId, state] of this._imageryTreeState) {\n            clone.set(treeId, state.clone());\n        }\n        return clone;\n    }\n    /** @internal */\n    tileFromQuadId(quadId) {\n        return this._rootTile.tileFromQuadId(quadId);\n    }\n    /** Add a new imagery tile tree / map-layer settings pair and initialize the imagery tile tree state.\n     * @internal\n     */\n    addImageryLayer(tree, settings, index, baseImageryLayer) {\n        this.layerImageryTrees.push({ tree, settings, baseImageryLayer });\n        this._layerSettings.set(tree.modelId, settings);\n        if (!this._imageryTreeState.has(tree.modelId))\n            this._imageryTreeState.set(tree.modelId, new ImageryTileTreeState());\n        this._modelIdToIndex.set(tree.modelId, index);\n    }\n    /** @internal */\n    addModelLayer(layerTreeRef, context) {\n        const classifier = context.addPlanarClassifier(`MapLayer ${this.modelId}-${layerTreeRef.layerIndex}`, layerTreeRef);\n        if (classifier)\n            this.layerClassifiers.set(layerTreeRef.layerIndex, classifier);\n    }\n    /** @internal */\n    collectClassifierGraphics(args, selectedTiles) {\n        super.collectClassifierGraphics(args, selectedTiles);\n        this.layerClassifiers.forEach((layerClassifier) => {\n            if (!(args instanceof GraphicsCollectorDrawArgs))\n                layerClassifier.collectGraphics(args.context, { modelId: this.modelId, tiles: selectedTiles, location: args.location, isPointCloud: this.isPointCloud });\n        });\n    }\n    /** @internal */\n    clearImageryTreesAndClassifiers() {\n        this.layerImageryTrees.length = 0;\n        this._layerSettings.clear();\n        this._modelIdToIndex.clear();\n        this.layerClassifiers.clear();\n    }\n    /** @internal */\n    get isTransparent() {\n        return this.mapTransparent || this.baseTransparent;\n    }\n    /** @internal */\n    get maxDepth() {\n        let maxDepth = this.loader.maxDepth;\n        this.layerImageryTrees?.forEach((layerImageryTree) => maxDepth = Math.max(maxDepth, layerImageryTree.tree.maxDepth));\n        return maxDepth;\n    }\n    /** @internal */\n    createPlanarChild(params, quadId, corners, normal, rectangle, chordHeight, heightRange) {\n        const childAvailable = this.mapLoader.isTileAvailable(quadId);\n        if (!childAvailable && this.produceGeometry)\n            return undefined;\n        const patch = new PlanarTilePatch(corners, normal, chordHeight);\n        const cornerNormals = this.getCornerRays(rectangle);\n        if (childAvailable)\n            return new MapTile(params, this, quadId, patch, rectangle, heightRange, cornerNormals);\n        assert(params.parent instanceof MapTile);\n        let loadableTile = params.parent;\n        while (loadableTile?.isUpsampled)\n            loadableTile = loadableTile.parent;\n        assert(undefined !== loadableTile);\n        return new UpsampledMapTile(params, this, quadId, patch, rectangle, heightRange, cornerNormals, loadableTile);\n    }\n    /** @internal */\n    createGlobeChild(params, quadId, _rangeCorners, rectangle, ellipsoidPatch, heightRange) {\n        return new MapTile(params, this, quadId, ellipsoidPatch, rectangle, heightRange, this.getCornerRays(rectangle));\n    }\n    /** @internal */\n    getChildHeightRange(quadId, rectangle, parent) {\n        return this.mapLoader.getChildHeightRange(quadId, rectangle, parent);\n    }\n    /** @internal */\n    clearLayers() {\n        this._rootTile.clearLayers();\n    }\n    /** @internal */\n    get mapLoader() { return this.loader; }\n    /** @internal */\n    getBaseRealityDepth(sceneContext) {\n        // If the view has ever had global scope then preload low level (global) tiles.\n        return (sceneContext.viewport.view.maxGlobalScopeFactor > 1) ? MapTileTree.minDisplayableDepth : -1;\n    }\n    /** @internal */\n    doCreateGlobeChildren(tile) {\n        if (this.globeMode !== GlobeMode.Ellipsoid)\n            return false;\n        const childDepth = tile.depth + 1;\n        if (childDepth < MapTileTree.maxGlobeDisplayDepth) // If the depth is too low (tile is too large) display as globe.\n            return true;\n        return false; // Display as globe if more than 100 KM from project.\n    }\n    /** @internal */\n    doReprojectChildren(tile) {\n        if (this._gcsConverter === undefined)\n            return false;\n        const childDepth = tile.depth + 1;\n        if (childDepth < MapTileTree.minReprojectionDepth) // If the depth is too low (tile is too large) omit reprojection.\n            return false;\n        return this.cartesianRange.intersectsRange(tile.range);\n    }\n    /** @internal */\n    getCornerRays(rectangle) {\n        const rays = new Array();\n        if (this.globeMode === GlobeMode.Ellipsoid) {\n            rays.push(this.earthEllipsoid.radiansToUnitNormalRay(rectangle.low.x, Cartographic.parametricLatitudeFromGeodeticLatitude(rectangle.high.y)));\n            rays.push(this.earthEllipsoid.radiansToUnitNormalRay(rectangle.high.x, Cartographic.parametricLatitudeFromGeodeticLatitude(rectangle.high.y)));\n            rays.push(this.earthEllipsoid.radiansToUnitNormalRay(rectangle.low.x, Cartographic.parametricLatitudeFromGeodeticLatitude(rectangle.low.y)));\n            rays.push(this.earthEllipsoid.radiansToUnitNormalRay(rectangle.high.x, Cartographic.parametricLatitudeFromGeodeticLatitude(rectangle.low.y)));\n        }\n        else {\n            const mercatorFractionRange = rectangle.getTileFractionRange(this._mercatorTilingScheme);\n            rays.push(Ray3d.createCapture(this._mercatorFractionToDb.multiplyXYZ(mercatorFractionRange.low.x, mercatorFractionRange.high.y), scratchZNormal));\n            rays.push(Ray3d.createCapture(this._mercatorFractionToDb.multiplyXYZ(mercatorFractionRange.high.x, mercatorFractionRange.high.y), scratchZNormal));\n            rays.push(Ray3d.createCapture(this._mercatorFractionToDb.multiplyXYZ(mercatorFractionRange.low.x, mercatorFractionRange.low.y), scratchZNormal));\n            rays.push(Ray3d.createCapture(this._mercatorFractionToDb.multiplyXYZ(mercatorFractionRange.high.x, mercatorFractionRange.low.y), scratchZNormal));\n        }\n        return rays;\n    }\n    /** @internal */\n    pointAboveEllipsoid(point) {\n        return this.earthEllipsoid.worldToLocal(point, scratchPoint).magnitude() > 1;\n    }\n    getMercatorFractionChildGridPoints(tile, columnCount, rowCount) {\n        const gridPoints = [];\n        const quadId = tile.quadId;\n        const deltaX = 1.0 / columnCount, deltaY = 1.0 / rowCount;\n        for (let row = 0; row <= rowCount; row++) {\n            for (let column = 0; column <= columnCount; column++) {\n                const xFraction = this.sourceTilingScheme.tileXToFraction(quadId.column + column * deltaX, quadId.level);\n                const yFraction = this.sourceTilingScheme.tileYToFraction(quadId.row + row * deltaY, quadId.level);\n                gridPoints.push(Point3d.create(xFraction, yFraction, 0));\n            }\n        }\n        // If not mercator already need to remap latitude...\n        if (!(this.sourceTilingScheme instanceof WebMercatorTilingScheme))\n            for (const gridPoint of gridPoints)\n                gridPoint.y = this._mercatorTilingScheme.latitudeToYFraction(this.sourceTilingScheme.yFractionToLatitude(gridPoint.y));\n        return gridPoints;\n    }\n    getChildCornersFromGridPoints(gridPoints, columnCount, rowCount) {\n        const childCorners = new Array();\n        for (let row = 0; row < rowCount; row++) {\n            for (let column = 0; column < columnCount; column++) {\n                const index0 = column + row * (columnCount + 1);\n                const index1 = index0 + (columnCount + 1);\n                childCorners.push([gridPoints[index0], gridPoints[index0 + 1], gridPoints[index1], gridPoints[index1 + 1]]);\n            }\n        }\n        return childCorners;\n    }\n    /** @internal */\n    getCachedReprojectedPoints(gridPoints) {\n        const requestProps = [];\n        for (const gridPoint of gridPoints)\n            requestProps.push({\n                x: this._mercatorTilingScheme.xFractionToLongitude(gridPoint.x) * Angle.degreesPerRadian,\n                y: this._mercatorTilingScheme.yFractionToLatitude(gridPoint.y) * Angle.degreesPerRadian,\n                z: this.bimElevationBias,\n            });\n        const iModelCoordinates = this._gcsConverter.getCachedIModelCoordinatesFromGeoCoordinates(requestProps);\n        if (iModelCoordinates.missing)\n            return undefined;\n        return iModelCoordinates.result.map((result) => !result || result.s ? undefined : Point3d.fromJSON(result.p));\n    }\n    /** Minimize reprojection requests by requesting this corners tile and a grid that will include all points for 4 levels of descendants.\n     * This greatly reduces the number of reprojection requests which currently require a roundtrip through the backend.\n     * @internal\n     */\n    async loadReprojectionCache(tile) {\n        const quadId = tile.quadId;\n        const xRange = Range1d.createXX(this.sourceTilingScheme.tileXToFraction(quadId.column, quadId.level), this.sourceTilingScheme.tileXToFraction(quadId.column + 1, quadId.level));\n        const yRange = Range1d.createXX(this.sourceTilingScheme.tileYToFraction(quadId.row, quadId.level), this.sourceTilingScheme.tileYToFraction(quadId.row + 1, quadId.level));\n        const cacheDepth = 4, cacheDimension = 2 ** cacheDepth;\n        const delta = 1.0 / cacheDimension;\n        const requestProps = [];\n        for (let row = 0; row <= cacheDimension; row++) {\n            for (let column = 0; column <= cacheDimension; column++) {\n                let yFraction = yRange.fractionToPoint(row * delta);\n                if (!(this.sourceTilingScheme instanceof WebMercatorTilingScheme))\n                    yFraction = this._mercatorTilingScheme.latitudeToYFraction(this.sourceTilingScheme.yFractionToLatitude(yFraction));\n                requestProps.push({\n                    x: this._mercatorTilingScheme.xFractionToLongitude(xRange.fractionToPoint(column * delta)) * Angle.degreesPerRadian,\n                    y: this._mercatorTilingScheme.yFractionToLatitude(yFraction) * Angle.degreesPerRadian,\n                    z: this.bimElevationBias,\n                });\n            }\n        }\n        await this._gcsConverter.getIModelCoordinatesFromGeoCoordinates(requestProps);\n    }\n    /** Get the corners for planar children.\n     * This generally will resolve immediately, but may require an asynchronous request for reprojecting the corners.\n     * @internal\n     */\n    getPlanarChildCorners(tile, columnCount, rowCount, resolve) {\n        const resolveCorners = (points, reprojected = undefined) => {\n            for (let i = 0; i < points.length; i++) {\n                const gridPoint = points[i];\n                this._mercatorFractionToDb.multiplyPoint3d(gridPoint, scratchCorner);\n                if (this.globeMode !== GlobeMode.Ellipsoid || this.cartesianRange.containsPoint(scratchCorner)) {\n                    if (reprojected !== undefined && reprojected[i] !== undefined)\n                        reprojected[i].clone(gridPoint);\n                    else\n                        scratchCorner.clone(gridPoint);\n                }\n                else {\n                    this._mercatorTilingScheme.fractionToCartographic(gridPoint.x, gridPoint.y, MapTileTree._scratchCarto);\n                    this.earthEllipsoid.radiansToPoint(MapTileTree._scratchCarto.longitude, Cartographic.parametricLatitudeFromGeodeticLatitude(MapTileTree._scratchCarto.latitude), gridPoint);\n                    const cartesianDistance = this.cartesianRange.distanceToPoint(scratchCorner);\n                    if (cartesianDistance < this.cartesianTransitionDistance)\n                        scratchCorner.interpolate(cartesianDistance / this.cartesianTransitionDistance, gridPoint, gridPoint);\n                }\n            }\n            resolve(this.getChildCornersFromGridPoints(points, columnCount, rowCount));\n        };\n        let reprojectedPoints;\n        const gridPoints = this.getMercatorFractionChildGridPoints(tile, columnCount, rowCount);\n        if (this.doReprojectChildren(tile)) {\n            reprojectedPoints = this.getCachedReprojectedPoints(gridPoints);\n            if (reprojectedPoints) {\n                // If the reprojected corners are in the cache, resolve immediately.\n                resolveCorners(gridPoints, reprojectedPoints);\n            }\n            else {\n                // If the reprojected corners are not in cache request them - but also request reprojection of a grid that will include descendent corners to ensure they can\n                // be reloaded without expensive reprojection requests.\n                this.loadReprojectionCache(tile).then(() => {\n                    const reprojected = this.getCachedReprojectedPoints(gridPoints);\n                    assert(reprojected !== undefined); // We just cached them... they better be there now.\n                    resolveCorners(gridPoints, reprojected);\n                }).catch((_error) => {\n                    resolveCorners(gridPoints);\n                });\n            }\n        }\n        else {\n            resolveCorners(gridPoints);\n        }\n    }\n    /** Scan the list of currently selected reality tiles, and fire the viewport's 'onMapLayerScaleRangeVisibilityChanged ' event\n     * if any scale range visibility change is detected for one more map-layer definition.\n     * @internal\n     */\n    reportTileVisibility(args, selected) {\n        const debugControl = args.context.target.debugControl;\n        const layersVisibilityBefore = this.cloneImageryTreeState();\n        const changes = new Array();\n        if (!layersVisibilityBefore)\n            return;\n        for (const [treeId] of layersVisibilityBefore) {\n            const treeVisibility = this.getImageryTreeState(treeId);\n            if (treeVisibility) {\n                treeVisibility.reset();\n            }\n        }\n        for (const selectedTile of selected) {\n            if (selectedTile instanceof MapTile) {\n                let selectedImageryTiles = selectedTile.imageryTiles;\n                if (selectedTile.hiddenImageryTiles) {\n                    selectedImageryTiles = selectedImageryTiles ? [...selectedImageryTiles, ...selectedTile.hiddenImageryTiles] : selectedTile.hiddenImageryTiles;\n                }\n                const leafTiles = selectedTile.highResolutionReplacementTiles;\n                if (leafTiles) {\n                    for (const tile of leafTiles) {\n                        const treeState = this.getImageryTreeState(tile.tree.id);\n                        treeState?.setScaleRangeVisibility(false);\n                    }\n                }\n                if (selectedImageryTiles) {\n                    for (const selectedImageryTile of selectedImageryTiles) {\n                        const treeState = this.getImageryTreeState(selectedImageryTile.tree.id);\n                        if (treeState) {\n                            if (selectedImageryTile.isOutOfLodRange) {\n                                treeState.setScaleRangeVisibility(false);\n                            }\n                            else {\n                                treeState.setScaleRangeVisibility(true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (const [treeId, prevState] of layersVisibilityBefore) {\n            const newState = this.getImageryTreeState(treeId);\n            if (newState) {\n                const prevVisibility = prevState.getScaleRangeVisibility();\n                const visibility = newState.getScaleRangeVisibility();\n                if (prevVisibility !== visibility) {\n                    if (debugControl && debugControl.logRealityTiles) {\n                        // eslint-disable-next-line no-console\n                        console.log(`ImageryTileTree '${treeId}' changed prev state: '${MapTileTreeScaleRangeVisibility[prevVisibility]}' new state: '${MapTileTreeScaleRangeVisibility[visibility]}'`);\n                    }\n                    const mapLayersIndexes = args.context.viewport.getMapLayerIndexesFromIds(this.id, treeId);\n                    for (const index of mapLayersIndexes) {\n                        changes.push({ index: index.index, isOverlay: index.isOverlay, visibility });\n                    }\n                }\n            }\n        }\n        if (changes.length !== 0) {\n            args.context.viewport.onMapLayerScaleRangeVisibilityChanged.raiseEvent(changes);\n        }\n    }\n    /** @internal */\n    getFractionalTileCorners(quadId) {\n        const corners = [];\n        corners.push(Point3d.create(this.sourceTilingScheme.tileXToFraction(quadId.column, quadId.level), this.sourceTilingScheme.tileYToFraction(quadId.row, quadId.level), 0.0));\n        corners.push(Point3d.create(this.sourceTilingScheme.tileXToFraction(quadId.column + 1, quadId.level), this.sourceTilingScheme.tileYToFraction(quadId.row, quadId.level), 0.0));\n        corners.push(Point3d.create(this.sourceTilingScheme.tileXToFraction(quadId.column, quadId.level), this.sourceTilingScheme.tileYToFraction(quadId.row + 1, quadId.level), 0.0));\n        corners.push(Point3d.create(this.sourceTilingScheme.tileXToFraction(quadId.column + 1, quadId.level), this.sourceTilingScheme.tileYToFraction(quadId.row + 1, quadId.level), 0.0));\n        return corners;\n    }\n    /** @internal */\n    getTileRectangle(quadId) {\n        return this.sourceTilingScheme.tileXYToRectangle(quadId.column, quadId.row, quadId.level);\n    }\n    /** @internal */\n    getLayerIndex(imageryTreeId) {\n        const index = this._modelIdToIndex.get(imageryTreeId);\n        return index === undefined ? -1 : index;\n    }\n    /** @internal */\n    getLayerTransparency(imageryTreeId) {\n        const layerSettings = this._layerSettings.get(imageryTreeId);\n        assert(undefined !== layerSettings);\n        return undefined === layerSettings || !layerSettings.transparency ? 0.0 : layerSettings.transparency;\n    }\n}\n/** Reprojection does not work with very large tiles so just do linear transform.\n * @internal\n */\nMapTileTree.minReprojectionDepth = 8;\n/** @internal */\nMapTileTree.maxGlobeDisplayDepth = 8;\n/** @internal */\nMapTileTree.minDisplayableDepth = 3;\nMapTileTree._scratchCarto = Cartographic.createZero();\nexport { MapTileTree };\n/** @internal */\nclass MapTileTreeProps {\n    get priority() { return this.loader.priority; }\n    constructor(modelId, loader, iModel, gcsConverterAvailable) {\n        this.gcsConverterAvailable = gcsConverterAvailable;\n        this.location = Transform.createIdentity();\n        this.yAxisUp = true;\n        this.is3d = true;\n        this.rootTile = { contentId: \"\", range: Range3d.createNull(), maximumSize: 0 };\n        this.id = this.modelId = modelId;\n        this.loader = loader;\n        this.iModel = iModel;\n    }\n}\nfunction createViewFlagOverrides(wantLighting, wantThematic) {\n    return createDefaultViewFlagOverrides({ clipVolume: false, lighting: wantLighting, thematic: wantThematic });\n}\nclass MapTreeSupplier {\n    constructor() {\n        this.isEcefDependent = true;\n    }\n    compareTileTreeIds(lhs, rhs) {\n        let cmp = compareNumbers(lhs.tileUserId, rhs.tileUserId);\n        if (0 === cmp) {\n            cmp = compareStringsOrUndefined(lhs.maskModelIds, rhs.maskModelIds);\n            if (0 === cmp) {\n                cmp = compareBooleans(lhs.isOverlay, rhs.isOverlay);\n                if (0 === cmp) {\n                    cmp = compareBooleans(lhs.wantSkirts, rhs.wantSkirts);\n                    if (0 === cmp) {\n                        cmp = compareBooleans(lhs.wantNormals, rhs.wantNormals);\n                        if (0 === cmp) {\n                            cmp = compareNumbers(lhs.globeMode, rhs.globeMode);\n                            if (0 === cmp) {\n                                cmp = compareNumbers(lhs.baseColor ? lhs.baseColor.tbgr : -1, rhs.baseColor ? rhs.baseColor.tbgr : -1);\n                                if (0 === cmp) {\n                                    cmp = compareBooleans(lhs.baseTransparent, rhs.baseTransparent);\n                                    if (0 === cmp) {\n                                        cmp = compareBooleans(lhs.mapTransparent, rhs.mapTransparent);\n                                        if (0 === cmp) {\n                                            cmp = compareBooleans(lhs.applyTerrain, rhs.applyTerrain);\n                                            if (0 === cmp) {\n                                                if (lhs.applyTerrain) {\n                                                    // Terrain-only settings.\n                                                    cmp = compareStrings(lhs.terrainProviderName, rhs.terrainProviderName);\n                                                    if (0 === cmp) {\n                                                        cmp = compareNumbers(lhs.terrainHeightOrigin, rhs.terrainHeightOrigin);\n                                                        if (0 === cmp) {\n                                                            cmp = compareNumbers(lhs.terrainHeightOriginMode, rhs.terrainHeightOriginMode);\n                                                            if (0 === cmp) {\n                                                                cmp = compareNumbers(lhs.terrainExaggeration, rhs.terrainExaggeration);\n                                                                if (0 === cmp)\n                                                                    cmp = compareBooleansOrUndefined(lhs.produceGeometry, rhs.produceGeometry);\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                                else {\n                                                    // Non-Terrain (flat) settings.\n                                                    cmp = compareNumbers(lhs.mapGroundBias, rhs.mapGroundBias);\n                                                    if (0 === cmp)\n                                                        cmp = compareBooleans(lhs.useDepthBuffer, rhs.useDepthBuffer);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return cmp;\n    }\n    async computeHeightBias(heightOrigin, heightOriginMode, exaggeration, iModel, elevationProvider) {\n        const projectCenter = iModel.projectExtents.center;\n        switch (heightOriginMode) {\n            case TerrainHeightOriginMode.Ground:\n                return heightOrigin + exaggeration * (await elevationProvider.getHeightValue(projectCenter, iModel, true));\n            case TerrainHeightOriginMode.Geodetic:\n                return heightOrigin;\n            case TerrainHeightOriginMode.Geoid:\n                return heightOrigin + await elevationProvider.getGeodeticToSeaLevelOffset(projectCenter, iModel);\n        }\n    }\n    async createTileTree(id, iModel) {\n        let bimElevationBias = 0, terrainProvider, geodeticOffset = 0;\n        let applyTerrain = id.applyTerrain;\n        const modelId = iModel.transientIds.getNext();\n        const gcsConverterAvailable = await getGcsConverterAvailable(iModel);\n        const terrainOpts = {\n            wantSkirts: id.wantSkirts,\n            exaggeration: id.terrainExaggeration,\n            wantNormals: id.wantNormals,\n        };\n        if (id.applyTerrain) {\n            await ApproximateTerrainHeights.instance.initialize();\n            const elevationProvider = new BingElevationProvider();\n            bimElevationBias = -await this.computeHeightBias(id.terrainHeightOrigin, id.terrainHeightOriginMode, id.terrainExaggeration, iModel, elevationProvider);\n            geodeticOffset = await elevationProvider.getGeodeticToSeaLevelOffset(iModel.projectExtents.center, iModel);\n            const provider = IModelApp.terrainProviderRegistry.find(id.terrainProviderName);\n            if (provider)\n                terrainProvider = await provider.createTerrainMeshProvider(terrainOpts);\n            if (!terrainProvider) {\n                applyTerrain = false;\n                geodeticOffset = 0;\n            }\n        }\n        if (!terrainProvider) {\n            terrainProvider = new EllipsoidTerrainProvider(terrainOpts);\n            bimElevationBias = id.mapGroundBias;\n        }\n        const loader = new MapTileLoader(iModel, modelId, bimElevationBias, terrainProvider);\n        const ecefToDb = iModel.getMapEcefToDb(bimElevationBias);\n        if (id.maskModelIds)\n            await iModel.models.load(CompressedId64Set.decompressSet(id.maskModelIds));\n        const treeProps = new MapTileTreeProps(modelId, loader, iModel, gcsConverterAvailable);\n        return new MapTileTree(treeProps, ecefToDb, bimElevationBias, geodeticOffset, terrainProvider.tilingScheme, id, applyTerrain);\n    }\n}\nconst mapTreeSupplier = new MapTreeSupplier();\n/** Specialization of tile tree that represents background map.\n * @internal\n */\nexport class MapTileTreeReference extends TileTreeReference {\n    constructor(settings, _baseLayerSettings, _layerSettings, iModel, tileUserId, isOverlay, _isDrape, _overrideTerrainDisplay) {\n        super();\n        this._baseLayerSettings = _baseLayerSettings;\n        this._layerSettings = _layerSettings;\n        this.isOverlay = isOverlay;\n        this._isDrape = _isDrape;\n        this._overrideTerrainDisplay = _overrideTerrainDisplay;\n        this._baseImageryLayerIncluded = false;\n        this._layerTrees = new Array();\n        this._baseTransparent = false;\n        this._tileUserId = tileUserId;\n        this._settings = settings;\n        this._iModel = iModel;\n        let tree;\n        if (!isOverlay && this._baseLayerSettings !== undefined) {\n            if (this._baseLayerSettings instanceof MapLayerSettings) {\n                tree = createMapLayerTreeReference(this._baseLayerSettings, 0, iModel);\n                this._baseTransparent = this._baseLayerSettings.transparency > 0;\n            }\n            else {\n                this._baseColor = this._baseLayerSettings;\n                this._baseTransparent = this._baseColor?.getTransparency() > 0;\n            }\n        }\n        if (this._baseImageryLayerIncluded = (undefined !== tree))\n            this._layerTrees.push(tree);\n        for (let i = 0; i < this._layerSettings.length; i++)\n            if (undefined !== (tree = createMapLayerTreeReference(this._layerSettings[i], i + 1, iModel)))\n                this._layerTrees.push(tree);\n        if (this._settings.planarClipMask && this._settings.planarClipMask.isValid)\n            this._planarClipMask = PlanarClipMaskState.create(this._settings.planarClipMask);\n        if (this._overrideTerrainDisplay && this._overrideTerrainDisplay()?.produceGeometry)\n            this.collectTileGeometry = (collector) => this._collectTileGeometry(collector);\n    }\n    forEachLayerTileTreeRef(func) {\n        for (const layerTree of this._layerTrees) {\n            assert(layerTree instanceof MapLayerTileTreeReference);\n            func(layerTree);\n        }\n    }\n    get isGlobal() { return true; }\n    get baseColor() { return this._baseColor; }\n    get planarclipMaskPriority() { return PlanarClipMaskPriority.BackgroundMap; }\n    _createGeometryTreeReference() {\n        if (!this._settings.applyTerrain || this._isDrape)\n            return undefined; // Don't bother generating non-terrain (flat) geometry.\n        const ref = new MapTileTreeReference(this._settings, undefined, [], this._iModel, this._tileUserId, false, false, () => {\n            return { produceGeometry: true };\n        });\n        assert(undefined !== ref.collectTileGeometry);\n        return ref;\n    }\n    /** Terrain  tiles do not contribute to the range used by \"fit view\". */\n    unionFitRange(_range) { }\n    get settings() { return this._settings; }\n    set settings(settings) {\n        this._settings = settings;\n        this._planarClipMask = settings.planarClipMask ? PlanarClipMaskState.create(settings.planarClipMask) : undefined;\n    }\n    setBaseLayerSettings(baseLayerSettings) {\n        assert(!this.isOverlay);\n        let tree;\n        this._baseLayerSettings = baseLayerSettings;\n        if (baseLayerSettings instanceof MapLayerSettings) {\n            tree = createMapLayerTreeReference(baseLayerSettings, 0, this._iModel);\n            this._baseColor = undefined;\n            this._baseTransparent = baseLayerSettings.transparency > 0;\n        }\n        else {\n            this._baseColor = baseLayerSettings;\n            this._baseTransparent = this._baseColor.getTransparency() > 0;\n        }\n        if (tree) {\n            if (this._baseImageryLayerIncluded)\n                this._layerTrees[0] = tree;\n            else\n                this._layerTrees.splice(0, 0, tree);\n        }\n        else {\n            if (this._baseImageryLayerIncluded)\n                this._layerTrees.shift();\n        }\n        this._baseImageryLayerIncluded = tree !== undefined;\n        this.clearLayers();\n    }\n    get layerSettings() {\n        return this._layerSettings;\n    }\n    setLayerSettings(layerSettings) {\n        this._layerSettings = layerSettings;\n        const baseLayerIndex = this._baseImageryLayerIncluded ? 1 : 0;\n        this._layerTrees.length = Math.min(layerSettings.length + baseLayerIndex, this._layerTrees.length); // Truncate if number of layers reduced.\n        for (let i = 0; i < layerSettings.length; i++) {\n            const treeIndex = i + baseLayerIndex;\n            if (treeIndex >= this._layerTrees.length || !this._layerTrees[treeIndex]?.layerSettings.displayMatches(layerSettings[i]))\n                this._layerTrees[treeIndex] = createMapLayerTreeReference(layerSettings[i], treeIndex, this._iModel);\n        }\n        this.clearLayers();\n    }\n    clearLayers() {\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree)\n            tree.clearLayers();\n    }\n    get castsShadows() {\n        return false;\n    }\n    get _isLoadingComplete() {\n        // Wait until drape tree is fully loaded too.\n        for (const drapeTree of this._layerTrees)\n            if (drapeTree && !drapeTree.isLoadingComplete)\n                return false;\n        return super._isLoadingComplete;\n    }\n    get useDepthBuffer() {\n        return !this.isOverlay && (this.settings.applyTerrain || this.settings.useDepthBuffer);\n    }\n    get treeOwner() {\n        let wantSkirts = (this.settings.applyTerrain || this.useDepthBuffer) && !this.settings.transparency && !this._baseTransparent;\n        if (wantSkirts) {\n            const maskTrans = this._planarClipMask?.settings.transparency;\n            wantSkirts = (undefined === maskTrans || maskTrans <= 0);\n        }\n        const id = {\n            tileUserId: this._tileUserId,\n            applyTerrain: this.settings.applyTerrain && !this._isDrape,\n            terrainProviderName: this.settings.terrainSettings.providerName,\n            terrainHeightOrigin: this.settings.terrainSettings.heightOrigin,\n            terrainHeightOriginMode: this.settings.terrainSettings.heightOriginMode,\n            terrainExaggeration: this.settings.terrainSettings.exaggeration,\n            mapGroundBias: this.settings.groundBias,\n            wantSkirts,\n            // Can set to this.settings.terrainSettings.applyLighting if we want to ever apply lighting to terrain again so that normals are retrieved when lighting is on.\n            wantNormals: false,\n            globeMode: this._isDrape ? GlobeMode.Plane : this.settings.globeMode,\n            isOverlay: this.isOverlay,\n            useDepthBuffer: this.useDepthBuffer,\n            baseColor: this._baseColor,\n            baseTransparent: this._baseTransparent,\n            mapTransparent: Number(this.settings.transparency) > 0,\n            maskModelIds: this._planarClipMask?.settings.compressedModelIds,\n            produceGeometry: false,\n        };\n        if (undefined !== this._overrideTerrainDisplay) {\n            const ovr = this._overrideTerrainDisplay();\n            if (undefined !== ovr) {\n                id.wantSkirts = ovr.wantSkirts ?? id.wantSkirts;\n                id.wantNormals = ovr.wantNormals ?? id.wantNormals;\n                id.produceGeometry = ovr.produceGeometry === true;\n            }\n        }\n        return this._iModel.tiles.getTileTreeOwner(id, mapTreeSupplier);\n    }\n    getLayerImageryTreeRef(index) {\n        const baseLayerIndex = this._baseImageryLayerIncluded ? 1 : 0;\n        const treeIndex = index + baseLayerIndex;\n        return index < 0 || treeIndex >= this._layerTrees.length ? undefined : this._layerTrees[treeIndex];\n    }\n    /** Return the map-layer scale range visibility for the provided map-layer index.\n   * @internal\n   */\n    getMapLayerScaleRangeVisibility(index) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree) {\n            const tileTreeRef = this.getLayerImageryTreeRef(index);\n            const treeId = tileTreeRef?.treeOwner.tileTree?.id;\n            if (treeId !== undefined) {\n                const treeState = tree.getImageryTreeState(treeId);\n                if (treeState !== undefined)\n                    return treeState.getScaleRangeVisibility();\n            }\n        }\n        return MapTileTreeScaleRangeVisibility.Unknown;\n    }\n    initializeLayers(context) {\n        const tree = this.treeOwner.load();\n        if (undefined === tree)\n            return false; // Not loaded yet.\n        tree.layerImageryTrees.length = 0;\n        if (0 === this._layerTrees.length)\n            return !this.isOverlay;\n        let treeIndex = this._layerTrees.length - 1;\n        // Start displaying at the highest completely opaque layer...\n        for (; treeIndex >= 1; treeIndex--) {\n            const layerTreeRef = this._layerTrees[treeIndex];\n            if (layerTreeRef?.isOpaque)\n                break; // This layer is completely opaque and will obscure all others so ignore lower ones.\n        }\n        for (; treeIndex < this._layerTrees.length; treeIndex++) {\n            const layerTreeRef = this._layerTrees[treeIndex];\n            // Load tile tree for each configured layer.\n            // Note: Non-visible layer are also added to allow proper tile tree scale range visibility reporting.\n            if (layerTreeRef && TileTreeLoadStatus.NotFound !== layerTreeRef.treeOwner.loadStatus\n                && !layerTreeRef.layerSettings.allSubLayersInvisible) {\n                const layerTree = layerTreeRef.treeOwner.load();\n                if (undefined === layerTree)\n                    return false; // Not loaded yet.\n                const baseImageryLayer = this._baseImageryLayerIncluded && (treeIndex === 0);\n                if (layerTree instanceof ImageryMapTileTree) {\n                    tree.addImageryLayer(layerTree, layerTreeRef.layerSettings, treeIndex, baseImageryLayer);\n                }\n                else if (layerTreeRef instanceof ModelMapLayerTileTreeReference)\n                    tree.addModelLayer(layerTreeRef, context);\n            }\n        }\n        return true;\n    }\n    /** Adds this reference's graphics to the scene. By default this invokes [[TileTree.drawScene]] on the referenced TileTree, if it is loaded. */\n    addToScene(context) {\n        if (!context.viewFlags.backgroundMap)\n            return;\n        const tree = this.treeOwner.load();\n        if (undefined === tree || !this.initializeLayers(context))\n            return; // Not loaded yet.\n        if (this._planarClipMask && this._planarClipMask.settings.isValid)\n            context.addPlanarClassifier(tree.modelId, undefined, this._planarClipMask);\n        const nonLocatable = this.settings.locatable ? undefined : true;\n        const transparency = this.settings.transparency ? this.settings.transparency : undefined;\n        this._symbologyOverrides = new FeatureSymbology.Overrides();\n        if (nonLocatable || transparency) {\n            this._symbologyOverrides.override({\n                modelId: tree.modelId,\n                appearance: FeatureAppearance.fromJSON({ transparency, nonLocatable }),\n            });\n        }\n        const args = this.createDrawArgs(context);\n        if (undefined !== args)\n            tree.draw(args);\n        tree.clearImageryTreesAndClassifiers();\n    }\n    createDrawArgs(context) {\n        const args = super.createDrawArgs(context);\n        if (undefined === args)\n            return undefined;\n        const tree = this.treeOwner.load();\n        return new RealityTileDrawArgs(args, args.worldToViewMap, args.frustumPlanes, undefined, tree?.layerClassifiers);\n    }\n    getViewFlagOverrides(_tree) {\n        return createViewFlagOverrides(false, this._settings.applyTerrain ? undefined : false);\n    }\n    getSymbologyOverrides(_tree) {\n        return this._symbologyOverrides;\n    }\n    discloseTileTrees(trees) {\n        super.discloseTileTrees(trees);\n        for (const imageryTree of this._layerTrees)\n            if (imageryTree)\n                trees.disclose(imageryTree);\n        if (this._planarClipMask)\n            this._planarClipMask.discloseTileTrees(trees);\n    }\n    imageryTreeFromTreeModelIds(mapTreeModelId, layerTreeModelId) {\n        const imageryTrees = [];\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree || tree.modelId !== mapTreeModelId)\n            return imageryTrees;\n        for (const imageryTree of this._layerTrees)\n            if (imageryTree && imageryTree.treeOwner.tileTree && imageryTree.treeOwner.tileTree.modelId === layerTreeModelId)\n                imageryTrees.push(imageryTree);\n        return imageryTrees;\n    }\n    layerFromTreeModelIds(mapTreeModelId, layerTreeModelId) {\n        const imageryTree = this.imageryTreeFromTreeModelIds(mapTreeModelId, layerTreeModelId);\n        return imageryTree.map((tree) => {\n            return { settings: tree.layerSettings, provider: tree.imageryProvider };\n        });\n    }\n    // Utility method that execute the provided function for every *imagery* tiles under a given HitDetail object.\n    async forEachImageryTileHit(hit, func) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree || hit.iModel !== tree.iModel || tree.modelId !== hit.modelId || !hit.viewport || !hit.viewport.view.is3d)\n            return undefined;\n        const backgroundMapGeometry = hit.viewport.displayStyle.getBackgroundMapGeometry();\n        if (undefined === backgroundMapGeometry)\n            return undefined;\n        const worldPoint = hit.hitPoint.clone();\n        let cartoGraphic;\n        try {\n            cartoGraphic = (await backgroundMapGeometry.dbToWGS84CartographicFromGcs([worldPoint]))[0];\n        }\n        catch {\n        }\n        if (!cartoGraphic) {\n            return undefined;\n        }\n        const imageryTreeRef = this.imageryTreeFromTreeModelIds(hit.modelId, hit.sourceId);\n        if (imageryTreeRef.length > 0) {\n            if (hit.tileId !== undefined) {\n                const terrainQuadId = QuadId.createFromContentId(hit.tileId);\n                const terrainTile = tree.tileFromQuadId(terrainQuadId);\n                for (const treeRef of imageryTreeRef) {\n                    const processedTileIds = [];\n                    if (terrainTile && terrainTile.imageryTiles) {\n                        const imageryTree = treeRef.treeOwner.tileTree;\n                        if (imageryTree) {\n                            for (const imageryTile of terrainTile.imageryTiles) {\n                                if (!processedTileIds.includes(imageryTile.contentId)\n                                    && imageryTree === imageryTile.imageryTree\n                                    && imageryTile.rectangle.containsCartographic(cartoGraphic)) {\n                                    processedTileIds.push(imageryTile.contentId);\n                                    try {\n                                        await func(treeRef, imageryTile.quadId, cartoGraphic, imageryTree);\n                                    }\n                                    catch {\n                                        // continue iterating even though we got a failure.\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    async getToolTip(hit) {\n        const tree = this.treeOwner.tileTree;\n        if (tree.modelId !== hit.modelId)\n            return undefined;\n        let carto;\n        const strings = [];\n        const getTooltipFunc = async (imageryTreeRef, quadId, cartoGraphic, imageryTree) => {\n            strings.push(`Imagery Layer: ${imageryTreeRef.layerSettings.name}`);\n            carto = cartoGraphic;\n            await imageryTree.imageryLoader.getToolTip(strings, quadId, cartoGraphic, imageryTree);\n        };\n        try {\n            await this.forEachImageryTileHit(hit, getTooltipFunc);\n        }\n        catch {\n            // No results added\n        }\n        if (carto) {\n            strings.push(`Latitude: ${carto.latitudeDegrees.toFixed(4)}`);\n            strings.push(`Longitude: ${carto.longitudeDegrees.toFixed(4)}`);\n            if (this.settings.applyTerrain && tree.terrainExaggeration !== 0.0) {\n                const geodeticHeight = (carto.height - tree.bimElevationBias) / tree.terrainExaggeration;\n                strings.push(`Height (Meters) Geodetic: ${geodeticHeight.toFixed(1)} Sea Level: ${(geodeticHeight - tree.geodeticOffset).toFixed(1)}`);\n            }\n        }\n        const div = document.createElement(\"div\");\n        div.innerHTML = strings.join(\"<br>\");\n        return div;\n    }\n    async getMapFeatureInfo(hit) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree || hit.iModel !== tree.iModel || tree.modelId !== hit.modelId || !hit.viewport || !hit.viewport.view.is3d)\n            return undefined;\n        const info = [];\n        const imageryTreeRef = this.imageryTreeFromTreeModelIds(hit.modelId, hit.sourceId);\n        if (imageryTreeRef !== undefined) {\n            const getFeatureInfoFunc = async (_imageryTreeRef, quadId, cartoGraphic, imageryTree) => {\n                try {\n                    await imageryTree.imageryLoader.getMapFeatureInfo(info, quadId, cartoGraphic, imageryTree, hit);\n                }\n                catch {\n                }\n            };\n            try {\n                await this.forEachImageryTileHit(hit, getFeatureInfoFunc);\n            }\n            catch {\n                // No results added\n            }\n        }\n        return info;\n    }\n    /** Add logo cards to logo div. */\n    addLogoCards(cards, vp) {\n        const tree = this.treeOwner.tileTree;\n        if (tree) {\n            tree.mapLoader.terrainProvider.addLogoCards(cards, vp);\n            for (const imageryTreeRef of this._layerTrees) {\n                if (imageryTreeRef?.layerSettings.visible) {\n                    const imageryTree = imageryTreeRef.treeOwner.tileTree;\n                    if (imageryTree instanceof ImageryMapTileTree)\n                        imageryTree.addLogoCards(cards, vp);\n                }\n            }\n        }\n    }\n}\n/** Returns whether a GCS converter is available.\n * @internal\n */\nexport async function getGcsConverterAvailable(iModel) {\n    if (iModel.noGcsDefined)\n        return false;\n    // Determine if we have a usable GCS.\n    const converter = iModel.geoServices.getConverter(\"WGS84\");\n    if (undefined === converter)\n        return false;\n    const requestProps = [{ x: 0, y: 0, z: 0 }];\n    let haveConverter;\n    try {\n        const responseProps = await converter.getIModelCoordinatesFromGeoCoordinates(requestProps);\n        haveConverter = responseProps.iModelCoords.length === 1 && responseProps.iModelCoords[0].s !== GeoCoordStatus.NoGCSDefined;\n    }\n    catch {\n        haveConverter = false;\n    }\n    return haveConverter;\n}\n//# sourceMappingURL=MapTileTree.js.map",
      "start": 1693508121983,
      "end": 1693508122080,
      "sourcemaps": null
    }
  ]
}
