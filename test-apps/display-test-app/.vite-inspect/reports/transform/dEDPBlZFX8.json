{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/ViewState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, BeEvent, dispose, Id64, JsonUtils } from \"@itwin/core-bentley\";\nimport { Angle, AxisOrder, Constant, Geometry, Map4d, Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Range2d, Range3d, Ray3d, Transform, Vector2d, Vector3d, YawPitchRollAngles, } from \"@itwin/core-geometry\";\nimport { Camera, Cartographic, Frustum, GlobeMode, GridOrientationType, IModelReadRpcInterface, Npc, ViewDetails, ViewDetails3d, } from \"@itwin/core-common\";\nimport { AuxCoordSystem2dState, AuxCoordSystem3dState, AuxCoordSystemState } from \"./AuxCoordSys\";\nimport { DisplayStyle3dState } from \"./DisplayStyleState\";\nimport { ElementState } from \"./EntityState\";\nimport { Frustum2d } from \"./Frustum2d\";\nimport { IModelApp } from \"./IModelApp\";\nimport { GeometricModel2dState } from \"./ModelState\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"./NotificationManager\";\nimport { StandardView } from \"./StandardView\";\nimport { DisclosedTileTreeSet } from \"./tile/internal\";\nimport { areaToEyeHeight, areaToEyeHeightFromGcs } from \"./ViewGlobalLocation\";\nimport { ViewingSpace } from \"./ViewingSpace\";\nimport { ViewPose2d, ViewPose3d } from \"./ViewPose\";\nimport { ViewStatus } from \"./ViewStatus\";\nimport { EnvironmentDecorations } from \"./EnvironmentDecorations\";\n/** Decorates the viewport with the view's grid. Graphics are cached as long as scene remains valid. */\nclass GridDecorator {\n    constructor(_view) {\n        this._view = _view;\n        this.useCachedDecorations = true;\n    }\n    decorate(context) {\n        const vp = context.viewport;\n        if (!vp.isGridOn)\n            return;\n        const orientation = this._view.getGridOrientation();\n        if (GridOrientationType.AuxCoord < orientation) {\n            return; // NEEDSWORK...\n        }\n        if (GridOrientationType.AuxCoord === orientation) {\n            this._view.auxiliaryCoordinateSystem.drawGrid(context);\n            return;\n        }\n        const isoGrid = false;\n        const gridsPerRef = this._view.getGridsPerRef();\n        const spacing = Point2d.createFrom(this._view.getGridSpacing());\n        const origin = Point3d.create();\n        const matrix = Matrix3d.createIdentity();\n        const fixedRepsAuto = Point2d.create();\n        this._view.getGridSettings(vp, origin, matrix, orientation);\n        context.drawStandardGrid(origin, matrix, spacing, gridsPerRef, isoGrid, orientation !== GridOrientationType.View ? fixedRepsAuto : undefined);\n    }\n}\nconst scratchCorners = Range3d.createNull().corners();\nconst scratchRay = Ray3d.createZero();\nconst unitRange2d = Range2d.createXYXY(0, 0, 1, 1);\nconst scratchRange2d = Range2d.createNull();\nconst scratchRange2dIntersect = Range2d.createNull();\n/** The front-end state of a [[ViewDefinition]] element.\n * A ViewState is typically associated with a [[Viewport]] to display the contents of the view on the screen. A ViewState being displayed by a Viewport is considered to be\n * \"attached\" to that viewport; a \"detached\" viewport is not being displayed by any viewport. Because the Viewport modifies the state of its attached ViewState, a ViewState\n * can only be attached to one Viewport at a time. Technically, two Viewports can display two different ViewStates that both use the same [[DisplayStyleState]], but this is\n * discouraged - changes made to the style by one Viewport will affect the contents of the other Viewport.\n * * @see [Views]($docs/learning/frontend/Views.md)\n * @public\n * @extensions\n */\nexport class ViewState extends ElementState {\n    static get className() { return \"ViewDefinition\"; }\n    /** Selects the categories that are display by this ViewState. */\n    get categorySelector() {\n        return this._categorySelector;\n    }\n    set categorySelector(selector) {\n        if (selector === this._categorySelector)\n            return;\n        const isAttached = this.isAttachedToViewport;\n        this.unregisterCategorySelectorListeners();\n        this._categorySelector = selector;\n        if (isAttached) {\n            this.registerCategorySelectorListeners();\n            this.onViewedCategoriesChanged.raiseEvent();\n        }\n    }\n    /** The style that controls how the contents of the view are displayed. */\n    get displayStyle() {\n        return this._displayStyle;\n    }\n    set displayStyle(style) {\n        if (style === this.displayStyle)\n            return;\n        if (this.isAttachedToViewport)\n            this.onDisplayStyleChanged.raiseEvent(style);\n        this._displayStyle = style;\n    }\n    /** @internal */\n    constructor(props, iModel, categoryOrClone, displayStyle) {\n        super(props, iModel);\n        this._unregisterCategorySelectorListeners = [];\n        /** An event raised when the set of categories viewed by this view changes, *only* if the view is attached to a [[Viewport]]. */\n        this.onViewedCategoriesChanged = new BeEvent();\n        /** An event raised just before assignment to the [[displayStyle]] property, *only* if the view is attached to a [[Viewport]].\n         * @see [[DisplayStyleSettings]] for events raised when properties of the display style change.\n         */\n        this.onDisplayStyleChanged = new BeEvent();\n        /** Event raised just before assignment to the [[modelDisplayTransformProvider]] property, *only* if the view is attached to a [[Viewport]].\n         * @beta\n         */\n        this.onModelDisplayTransformProviderChanged = new BeEvent();\n        this._maxGlobalScopeFactor = 0;\n        this.description = props.description;\n        this.isPrivate = props.isPrivate;\n        this._displayStyle = displayStyle;\n        this._categorySelector = categoryOrClone;\n        this._gridDecorator = new GridDecorator(this);\n        if (!(categoryOrClone instanceof ViewState)) // is this from the clone method?\n            return; // not from clone\n        // from clone, 3rd argument is source ViewState\n        const source = categoryOrClone;\n        this._categorySelector = source.categorySelector.clone();\n        this._displayStyle = source.displayStyle.clone();\n        this._extentLimits = source._extentLimits;\n        this._auxCoordSystem = source._auxCoordSystem;\n        this._modelDisplayTransformProvider = source._modelDisplayTransformProvider;\n    }\n    /** Create a new ViewState object from a set of properties. Generally this is called internally by [[IModelConnection.Views.load]] after the properties\n     * have been read from an iModel. But, it can also be used to create a ViewState in memory, from scratch or from properties stored elsewhere.\n     */\n    static createFromProps(_props, _iModel) { return undefined; }\n    /** Serialize this ViewState as a set of properties that can be used to recreate it via [[ViewState.createFromProps]]. */\n    toProps() {\n        return {\n            viewDefinitionProps: this.toJSON(),\n            categorySelectorProps: this.categorySelector.toJSON(),\n            displayStyleProps: this.displayStyle.toJSON(),\n        };\n    }\n    /** Flags controlling various aspects of this view's [[DisplayStyleState]].\n     * @see [DisplayStyleSettings.viewFlags]($common)\n     */\n    get viewFlags() {\n        return this.displayStyle.viewFlags;\n    }\n    set viewFlags(flags) {\n        this.displayStyle.viewFlags = flags;\n    }\n    /** See [DisplayStyleSettings.analysisStyle]($common). */\n    get analysisStyle() {\n        return this.displayStyle.settings.analysisStyle;\n    }\n    /** The [RenderSchedule.Script]($common) that animates the contents of the view, if any.\n     * @see [[DisplayStyleState.scheduleScript]].\n     */\n    get scheduleScript() {\n        return this.displayStyle.scheduleScript;\n    }\n    /** @internal */\n    get scheduleScriptReference() {\n        return this.displayStyle.scheduleScriptReference; // eslint-disable-line deprecation/deprecation\n    }\n    /** Get the globe projection mode.\n     * @internal\n     */\n    get globeMode() { return this.displayStyle.globeMode; }\n    /** Determine whether this ViewState exactly matches another. */\n    equals(other) { return super.equals(other) && this.categorySelector.equals(other.categorySelector) && this.displayStyle.equals(other.displayStyle); }\n    /** Convert to JSON representation. */\n    toJSON() {\n        const json = super.toJSON();\n        json.categorySelectorId = this.categorySelector.id;\n        json.displayStyleId = this.displayStyle.id;\n        json.isPrivate = this.isPrivate;\n        json.description = this.description;\n        return json;\n    }\n    /**\n     * Populates the hydrateRequest object stored on the ViewState with:\n     *  not loaded categoryIds based off of the ViewStates categorySelector.\n     *  Auxiliary coordinate system id if valid.\n     */\n    preload(hydrateRequest) {\n        const acsId = this.getAuxiliaryCoordinateSystemId();\n        if (Id64.isValid(acsId))\n            hydrateRequest.acsId = acsId;\n    }\n    /** Asynchronously load any required data for this ViewState from the backend.\n     * FINAL, No subclass should override load. If additional load behavior is needed, see preload and postload.\n     * @note callers should await the Promise returned by this method before using this ViewState.\n     * @see [Views]($docs/learning/frontend/Views.md)\n     */\n    async load() {\n        // If the iModel associated with the viewState is a blankConnection,\n        // then no data can be retrieved from the backend.\n        if (this.iModel.isBlank)\n            return;\n        const hydrateRequest = {};\n        this.preload(hydrateRequest);\n        const promises = [\n            IModelReadRpcInterface.getClientForRouting(this.iModel.routingContext.token).hydrateViewState(this.iModel.getRpcProps(), hydrateRequest).\n                then(async (hydrateResponse) => this.postload(hydrateResponse)),\n            this.displayStyle.load(),\n        ];\n        const subcategories = this.iModel.subcategories.load(this.categorySelector.categories);\n        if (undefined !== subcategories)\n            promises.push(subcategories.promise.then((_) => { }));\n        await Promise.all(promises);\n    }\n    async postload(hydrateResponse) {\n        if (hydrateResponse.acsElementProps)\n            this._auxCoordSystem = AuxCoordSystemState.fromProps(hydrateResponse.acsElementProps, this.iModel);\n    }\n    /** Returns true if all [[TileTree]]s required by this view have been loaded.\n     * Note that the map tile trees associated to the viewport rather than the view, to check the\n     * map tiles as well call [[Viewport.areAreAllTileTreesLoaded]].\n     */\n    get areAllTileTreesLoaded() {\n        let allLoaded = true;\n        this.forEachTileTreeRef((ref) => {\n            allLoaded = allLoaded && ref.isLoadingComplete;\n        });\n        return allLoaded;\n    }\n    /** Get the name of the [[ViewDefinition]] from which this ViewState originated. */\n    get name() {\n        return this.code.value;\n    }\n    /** Get this view's background color. */\n    get backgroundColor() {\n        return this.displayStyle.backgroundColor;\n    }\n    /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered using this ViewState.\n     * @param id The Id of the subcategory.\n     * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.\n     */\n    getSubCategoryOverride(id) {\n        return this.displayStyle.getSubCategoryOverride(id);\n    }\n    /** Query the symbology overrides applied to a model when rendered using this ViewState.\n     * @param id The Id of the model.\n     * @return The symbology overrides applied to the model, or undefined if no such overrides exist.\n     */\n    getModelAppearanceOverride(id) {\n        return this.displayStyle.settings.getModelAppearanceOverride(id);\n    }\n    /** @internal */\n    isSubCategoryVisible(id) {\n        const app = this.iModel.subcategories.getSubCategoryAppearance(id);\n        if (undefined === app)\n            return false;\n        const ovr = this.getSubCategoryOverride(id);\n        if (undefined === ovr || undefined === ovr.invisible)\n            return !app.invisible;\n        return !ovr.invisible;\n    }\n    /** Returns true if this ViewState is-a [[ViewState2d]] */\n    is2d() { return !this.is3d(); }\n    /** Returns true if this ViewState is-a [[SheetViewState]] */\n    isSheetView() { return false; }\n    /** set the center of this view to a new position. */\n    setCenter(center) {\n        const diff = center.minus(this.getCenter());\n        this.setOrigin(this.getOrigin().plus(diff));\n    }\n    /** Execute a function against each [[TileTreeReference]] associated with this view.\n     * @note This may include tile trees not associated with any [[GeometricModelState]] - e.g., context reality data.\n     */\n    forEachTileTreeRef(func) {\n        this.forEachModelTreeRef(func);\n        this.displayStyle.forEachTileTreeRef(func);\n    }\n    /** Disclose *all* TileTrees currently in use by this view. This set may include trees not reported by [[forEachTileTreeRef]] - e.g., those used by view attachments, map-draped terrain, etc.\n     * @internal\n     */\n    discloseTileTrees(trees) {\n        this.forEachTileTreeRef((ref) => trees.disclose(ref));\n    }\n    /** Discloses graphics memory consumed by viewed tile trees and other consumers like view attachments.\n     * @internal\n     */\n    collectStatistics(stats) {\n        const trees = new DisclosedTileTreeSet();\n        this.discloseTileTrees(trees);\n        for (const tree of trees)\n            tree.collectStatistics(stats);\n        this.collectNonTileTreeStatistics(stats);\n    }\n    /** Discloses graphics memory consumed by any consumers *other* than viewed tile trees, like view attachments.\n     * @internal\n     */\n    collectNonTileTreeStatistics(_stats) {\n        //\n    }\n    /** @internal */\n    createScene(context) {\n        this.forEachTileTreeRef((ref) => ref.addToScene(context));\n    }\n    /** Add view-specific decorations. The base implementation draws the grid. Subclasses must invoke super.decorate()\n     * @internal\n     */\n    decorate(context) {\n        this.drawGrid(context);\n    }\n    /** @internal */\n    static getStandardViewMatrix(id) {\n        return StandardView.getStandardRotation(id);\n    }\n    /** Orient this view to one of the [[StandardView]] rotations. */\n    setStandardRotation(id) { this.setRotation(ViewState.getStandardViewMatrix(id)); }\n    /** Orient this view to one of the [[StandardView]] rotations, if the the view is not viewing the project then the\n     * standard rotation is relative to the global position rather than the project.\n     */\n    setStandardGlobalRotation(id) {\n        const worldToView = ViewState.getStandardViewMatrix(id);\n        const globeToWorld = this.getGlobeRotation();\n        if (globeToWorld)\n            return this.setRotation(worldToView.multiplyMatrixMatrix(globeToWorld));\n        else\n            this.setRotation(worldToView);\n    }\n    /** Get the target point of the view. If there is no camera, center is returned. */\n    getTargetPoint(result) { return this.getCenter(result); }\n    /**  Get the point at the geometric center of the view. */\n    getCenter(result) {\n        const delta = this.getRotation().multiplyTransposeVector(this.getExtents());\n        return this.getOrigin().plusScaled(delta, 0.5, result);\n    }\n    /** @internal */\n    drawGrid(context) {\n        context.addFromDecorator(this._gridDecorator);\n    }\n    /** @internal */\n    computeWorldToNpc(viewRot, inOrigin, delta, enforceFrontToBackRatio = true) {\n        if (viewRot === undefined)\n            viewRot = this.getRotation();\n        const xVector = viewRot.rowX();\n        const yVector = viewRot.rowY();\n        const zVector = viewRot.rowZ();\n        if (delta === undefined)\n            delta = this.getExtents();\n        if (inOrigin === undefined)\n            inOrigin = this.getOrigin();\n        let frustFraction = 1.0;\n        let xExtent;\n        let yExtent;\n        let zExtent;\n        let origin;\n        // Compute root vectors along edges of view frustum.\n        if (this.is3d() && this.isCameraOn) {\n            const camera = this.camera;\n            const eyeToOrigin = Vector3d.createStartEnd(camera.eye, inOrigin); // vector from origin on backplane to eye\n            viewRot.multiplyVectorInPlace(eyeToOrigin); // align with view coordinates.\n            const focusDistance = camera.focusDist;\n            let zDelta = delta.z;\n            let zBack = eyeToOrigin.z; // Distance from eye to backplane.\n            let zFront = zBack + zDelta; // Distance from eye to frontplane.\n            const nearScale = IModelApp.renderSystem.supportsLogZBuffer ? ViewingSpace.nearScaleLog24 : ViewingSpace.nearScaleNonLog24;\n            if (enforceFrontToBackRatio && zFront / zBack < nearScale) {\n                // In this case we are running up against the zBuffer resolution limitation (currently 24 bits).\n                // Set back clipping plane at 10 kilometer which gives us a front clipping plane about 3 meters.\n                // Decreasing the maximumBackClip (MicroStation uses 1 kilometer) will reduce the minimum front\n                // clip, but also reduce the back clip (so far geometry may not be visible).\n                const maximumBackClip = 10 * Constant.oneKilometer;\n                if (-zBack > maximumBackClip) {\n                    zBack = -maximumBackClip;\n                    eyeToOrigin.z = zBack;\n                }\n                zFront = zBack * nearScale;\n                zDelta = zFront - eyeToOrigin.z;\n            }\n            // z out back of eye ===> origin z coordinates are negative.  (Back plane more negative than front plane)\n            const backFraction = -zBack / focusDistance; // Perspective fraction at back clip plane.\n            const frontFraction = -zFront / focusDistance; // Perspective fraction at front clip plane.\n            frustFraction = frontFraction / backFraction;\n            // delta.x,delta.y are view rectangle sizes at focus distance.  Scale to back plane:\n            xExtent = xVector.scale(delta.x * backFraction); // xExtent at back == delta.x * backFraction.\n            yExtent = yVector.scale(delta.y * backFraction); // yExtent at back == delta.y * backFraction.\n            // Calculate the zExtent in the View coordinate system.\n            zExtent = new Vector3d(eyeToOrigin.x * (frontFraction - backFraction), eyeToOrigin.y * (frontFraction - backFraction), zDelta);\n            viewRot.multiplyTransposeVectorInPlace(zExtent); // rotate back to root coordinates.\n            origin = new Point3d(eyeToOrigin.x * backFraction, // Calculate origin in eye coordinates\n            eyeToOrigin.y * backFraction, eyeToOrigin.z);\n            viewRot.multiplyTransposeVectorInPlace(origin); // Rotate back to root coordinates\n            origin.plus(camera.eye, origin); // Add the eye point.\n        }\n        else {\n            origin = inOrigin;\n            xExtent = xVector.scale(delta.x);\n            yExtent = yVector.scale(delta.y);\n            zExtent = zVector.scale(delta.z ? delta.z : 1.0);\n        }\n        // calculate the root-to-npc mapping (using expanded frustum)\n        return { map: Map4d.createVectorFrustum(origin, xExtent, yExtent, zExtent, frustFraction), frustFraction };\n    }\n    /** Calculate the world coordinate Frustum from the parameters of this ViewState.\n     * @param result Optional Frustum to hold result. If undefined a new Frustum is created.\n     * @returns The 8-point Frustum with the corners of this ViewState, or undefined if the parameters are invalid.\n     */\n    calculateFrustum(result) {\n        const val = this.computeWorldToNpc();\n        if (undefined === val.map)\n            return undefined;\n        const box = result ? result.initNpc() : new Frustum();\n        val.map.transform1.multiplyPoint3dArrayQuietNormalize(box.points);\n        return box;\n    }\n    calculateFocusCorners() {\n        const map = this.computeWorldToNpc().map;\n        const focusNpcZ = Geometry.clamp(map.transform0.multiplyPoint3dQuietNormalize(this.getTargetPoint()).z, 0, 1.0);\n        const pts = [new Point3d(0.0, 0.0, focusNpcZ), new Point3d(1.0, 0.0, focusNpcZ), new Point3d(0.0, 1.0, focusNpcZ), new Point3d(1.0, 1.0, focusNpcZ)];\n        map.transform1.multiplyPoint3dArrayQuietNormalize(pts);\n        return pts;\n    }\n    /** Initialize the origin, extents, and rotation from an existing Frustum\n     * This function is commonly used in the implementation of [[ViewTool]]s as follows:\n     *  1. Obtain the ViewState's initial frustum.\n     *  2. Modify the frustum based on user input.\n     *  3. Update the ViewState to match the modified frustum.\n     * @param frustum the input Frustum.\n     * @param opts for providing onExtentsError\n     * @return Success if the frustum was successfully updated, or an appropriate error code.\n     */\n    setupFromFrustum(inFrustum, opts) {\n        const frustum = inFrustum.clone(); // make sure we don't modify input frustum\n        frustum.fixPointOrder();\n        const frustPts = frustum.points;\n        const viewOrg = frustPts[Npc.LeftBottomRear];\n        // frustumX, frustumY, frustumZ are vectors along edges of the frustum. They are NOT unit vectors.\n        // X and Y should be perpendicular, and Z should be right handed.\n        const frustumX = Vector3d.createFrom(frustPts[Npc.RightBottomRear].minus(viewOrg));\n        const frustumY = Vector3d.createFrom(frustPts[Npc.LeftTopRear].minus(viewOrg));\n        const frustumZ = Vector3d.createFrom(frustPts[Npc.LeftBottomFront].minus(viewOrg));\n        const frustMatrix = Matrix3d.createRigidFromColumns(frustumX, frustumY, AxisOrder.XYZ);\n        if (!frustMatrix)\n            return ViewStatus.InvalidWindow;\n        // if we're close to one of the standard views, adjust to it to remove any \"fuzz\"\n        StandardView.adjustToStandardRotation(frustMatrix);\n        const xDir = frustMatrix.getColumn(0);\n        const yDir = frustMatrix.getColumn(1);\n        const zDir = frustMatrix.getColumn(2);\n        // set up view Rotation matrix as rows of frustum matrix.\n        const viewRot = frustMatrix.inverse();\n        if (!viewRot)\n            return ViewStatus.InvalidWindow;\n        // Left handed frustum?\n        const zSize = zDir.dotProduct(frustumZ);\n        if (zSize < 0.0)\n            return ViewStatus.InvalidWindow;\n        const viewDiagRoot = new Vector3d();\n        viewDiagRoot.plus2Scaled(xDir, xDir.dotProduct(frustumX), yDir, yDir.dotProduct(frustumY), viewDiagRoot); // vectors on the back plane\n        viewDiagRoot.plusScaled(zDir, zSize, viewDiagRoot); // add in z vector perpendicular to x,y\n        // use center of frustum and view diagonal for origin. Original frustum may not have been orthogonal\n        frustum.getCenter().plusScaled(viewDiagRoot, -0.5, viewOrg);\n        // delta is in view coordinates\n        const viewDelta = viewRot.multiplyVector(viewDiagRoot);\n        const status = this.adjustViewDelta(viewDelta, viewOrg, viewRot, undefined, opts);\n        if (ViewStatus.Success !== status)\n            return status;\n        this.setOrigin(viewOrg);\n        this.setExtents(viewDelta);\n        this.setRotation(viewRot);\n        this._updateMaxGlobalScopeFactor();\n        return ViewStatus.Success;\n    }\n    /** Get or set the largest and smallest values allowed for the extents for this ViewState\n     * The default limits vary based on the type of view:\n     *   - Spatial view extents cannot exceed the diameter of the earth.\n     *   - Drawing view extents cannot exceed twice the longest axis of the drawing model's range.\n     *   - Sheet view extents cannot exceed ten times the paper size of the sheet.\n     * Explicitly setting the extent limits overrides the default limits.\n     * @see [[resetExtentLimits]] to restore the default limits.\n     */\n    get extentLimits() { return undefined !== this._extentLimits ? this._extentLimits : this.defaultExtentLimits; }\n    set extentLimits(limits) { this._extentLimits = limits; }\n    /** Resets the largest and smallest values allowed for the extents of this ViewState to their default values.\n     * @see [[extentLimits]].\n     */\n    resetExtentLimits() { this._extentLimits = undefined; }\n    setDisplayStyle(style) { this.displayStyle = style; }\n    /** Adjust the y dimension of this ViewState so that its aspect ratio matches the supplied value.\n     * @internal\n     */\n    fixAspectRatio(windowAspect) {\n        const origExtents = this.getExtents();\n        const extents = origExtents.clone();\n        extents.y = extents.x / (windowAspect * this.getAspectRatioSkew());\n        if (extents.isAlmostEqual(origExtents))\n            return;\n        // adjust origin by half of the distance we modified extents to keep centered\n        const origin = this.getOrigin().clone();\n        origin.addScaledInPlace(this.getRotation().multiplyTransposeVector(extents.vectorTo(origExtents, origExtents)), .5);\n        this.setOrigin(origin);\n        this.setExtents(extents);\n    }\n    /** @internal */\n    outputStatusMessage(status) {\n        IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, IModelApp.localization.getLocalizedString(`iModelJs:Viewing.${ViewStatus[status]}`)));\n        return status;\n    }\n    /** @internal */\n    adjustViewDelta(delta, origin, rot, aspect, opts) {\n        const origDelta = delta.clone();\n        let status = ViewStatus.Success;\n        const limit = this.extentLimits;\n        const limitDelta = (val) => {\n            if (val < limit.min) {\n                val = limit.min;\n                status = ViewStatus.MinWindow;\n            }\n            else if (val > limit.max) {\n                val = limit.max;\n                status = ViewStatus.MaxWindow;\n            }\n            return val;\n        };\n        delta.x = limitDelta(delta.x);\n        delta.y = limitDelta(delta.y);\n        if (aspect) { // skip if either undefined or 0\n            aspect *= this.getAspectRatioSkew();\n            if (delta.x > (aspect * delta.y))\n                delta.y = delta.x / aspect;\n            else\n                delta.x = delta.y * aspect;\n        }\n        if (!delta.isAlmostEqual(origDelta))\n            origin.addScaledInPlace(rot.multiplyTransposeVector(delta.vectorTo(origDelta, origDelta)), .5);\n        return (status !== ViewStatus.Success && opts?.onExtentsError) ? opts.onExtentsError(status) : status;\n    }\n    /** Adjust the aspect ratio of this ViewState so it matches the supplied value. The adjustment is accomplished by increasing one dimension\n     * and leaving the other unchanged, depending on the ratio of this ViewState's current aspect ratio to the supplied one. This means the result\n     * always shows everything in the current volume, plus potentially more.\n     * @note The *automatic* adjustment that happens when ViewStates are used in Viewports **always** adjusts the Y axis (making\n     * it potentially smaller). That's so that process can be reversible if the view's aspect ratio changes repeatedly (as happens when panels slide in/out, etc.)\n     */\n    adjustAspectRatio(aspect) {\n        const extents = this.getExtents();\n        const origin = this.getOrigin();\n        this.adjustViewDelta(extents, origin, this.getRotation(), aspect);\n        this.setExtents(extents);\n        this.setOrigin(origin);\n    }\n    /** Set the CategorySelector for this view. */\n    setCategorySelector(categories) { this.categorySelector = categories; }\n    /** get the auxiliary coordinate system state object for this ViewState. */\n    get auxiliaryCoordinateSystem() {\n        if (!this._auxCoordSystem)\n            this._auxCoordSystem = this.createAuxCoordSystem(\"\");\n        return this._auxCoordSystem;\n    }\n    /** Get the Id of the auxiliary coordinate system for this ViewState */\n    getAuxiliaryCoordinateSystemId() {\n        return this.details.auxiliaryCoordinateSystemId;\n    }\n    /** Set or clear the AuxiliaryCoordinateSystem for this view.\n     * @param acs the new AuxiliaryCoordinateSystem for this view. If undefined, no AuxiliaryCoordinateSystem will be used.\n     */\n    setAuxiliaryCoordinateSystem(acs) {\n        this._auxCoordSystem = acs;\n        this.details.auxiliaryCoordinateSystemId = undefined !== acs ? acs.id : Id64.invalid;\n    }\n    /** Determine whether the specified Category is displayed in this view */\n    viewsCategory(id) {\n        return this.categorySelector.isCategoryViewed(id);\n    }\n    /**  Get the aspect ratio (width/height) of this view */\n    getAspectRatio() {\n        const extents = this.getExtents();\n        return extents.x / extents.y;\n    }\n    /** Get the aspect ratio skew (x/y, usually 1.0) that is used to exaggerate the y axis of the view. */\n    getAspectRatioSkew() {\n        return this.details.aspectRatioSkew;\n    }\n    /** Set the aspect ratio skew (x/y) for this view. To remove aspect ratio skew, pass 1.0 for val. */\n    setAspectRatioSkew(val) {\n        this.details.aspectRatioSkew = val;\n    }\n    /** Get the unit vector that points in the view X (left-to-right) direction.\n     * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n     */\n    getXVector(result) { return this.getRotation().getRow(0, result); }\n    /** Get the unit vector that points in the view Y (bottom-to-top) direction.\n     * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n     */\n    getYVector(result) { return this.getRotation().getRow(1, result); }\n    /** Get the unit vector that points in the view Z (front-to-back) direction.\n     * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n     */\n    getZVector(result) { return this.getRotation().getRow(2, result); }\n    /** Set or clear the clipping volume for this view.\n     * @param clip the new clipping volume. If undefined, clipping is removed from view.\n     * @note The ViewState takes ownership of the supplied ClipVector - it should not be modified after passing it to this function.\n     */\n    setViewClip(clip) {\n        this.details.clipVector = clip;\n    }\n    /** Get the clipping volume for this view, if defined\n     * @note Do *not* modify the returned ClipVector. If you wish to change the ClipVector, clone the returned ClipVector, modify it as desired, and pass the clone to [[setViewClip]].\n     */\n    getViewClip() {\n        return this.details.clipVector;\n    }\n    /** Set the grid settings for this view */\n    setGridSettings(orientation, spacing, gridsPerRef) {\n        switch (orientation) {\n            case GridOrientationType.WorldYZ:\n            case GridOrientationType.WorldXZ:\n                if (!this.is3d())\n                    return;\n                break;\n        }\n        this.details.gridOrientation = orientation;\n        this.details.gridsPerRef = gridsPerRef;\n        this.details.gridSpacing = spacing;\n    }\n    /** Populate the given origin and rotation with information from the grid settings from the grid orientation. */\n    getGridSettings(vp, origin, rMatrix, orientation) {\n        // start with global origin (for spatial views) and identity matrix\n        rMatrix.setIdentity();\n        origin.setFrom(vp.view.isSpatialView() ? vp.view.iModel.globalOrigin : Point3d.create());\n        switch (orientation) {\n            case GridOrientationType.View: {\n                const centerWorld = Point3d.create(0.5, 0.5, 0.5);\n                vp.npcToWorld(centerWorld, centerWorld);\n                rMatrix.setFrom(vp.rotation);\n                rMatrix.multiplyXYZtoXYZ(origin, origin);\n                origin.z = centerWorld.z;\n                rMatrix.multiplyTransposeVectorInPlace(origin);\n                break;\n            }\n            case GridOrientationType.WorldXY:\n                break;\n            case GridOrientationType.WorldYZ: {\n                const rowX = rMatrix.getRow(0);\n                const rowY = rMatrix.getRow(1);\n                const rowZ = rMatrix.getRow(2);\n                rMatrix.setRow(0, rowY);\n                rMatrix.setRow(1, rowZ);\n                rMatrix.setRow(2, rowX);\n                break;\n            }\n            case GridOrientationType.WorldXZ: {\n                const rowX = rMatrix.getRow(0);\n                const rowY = rMatrix.getRow(1);\n                const rowZ = rMatrix.getRow(2);\n                rMatrix.setRow(0, rowX);\n                rMatrix.setRow(1, rowZ);\n                rMatrix.setRow(2, rowY);\n                break;\n            }\n        }\n    }\n    /** Get the grid settings for this view */\n    getGridOrientation() {\n        return this.details.gridOrientation;\n    }\n    getGridsPerRef() {\n        return this.details.gridsPerRef;\n    }\n    getGridSpacing() {\n        return this.details.gridSpacing;\n    }\n    /** Change the volume that this view displays, keeping its current rotation.\n     * @param volume The new volume, in world-coordinates, for the view. The resulting view will show all of worldVolume, by fitting a\n     * view-axis-aligned bounding box around it. For views that are not aligned with the world coordinate system, this will sometimes\n     * result in a much larger volume than worldVolume.\n     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not\n     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.\n     * @param options for providing MarginPercent and onExtentsError\n     * @note for 2d views, only the X and Y values of volume are used.\n     */\n    lookAtVolume(volume, aspect, options) {\n        const rangeBox = Frustum.fromRange(volume).points;\n        this.getRotation().multiplyVectorArrayInPlace(rangeBox);\n        return this.lookAtViewAlignedVolume(Range3d.createArray(rangeBox), aspect, options);\n    }\n    /** Look at a volume of space defined by a range in view local coordinates, keeping its current rotation.\n     * @param volume The new volume, in view-aligned coordinates. The resulting view will show all of the volume.\n     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not\n     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.\n     * @param options for providing MarginPercent and onExtentsError\n     * @see lookAtVolume\n     */\n    lookAtViewAlignedVolume(volume, aspect, options) {\n        if (volume.isNull) // make sure volume is valid\n            return;\n        const viewRot = this.getRotation();\n        const newOrigin = volume.low.clone();\n        const newDelta = volume.diagonal();\n        const minimumDepth = Constant.oneMillimeter;\n        if (newDelta.z < minimumDepth) {\n            newOrigin.z -= (minimumDepth - newDelta.z) / 2.0;\n            newDelta.z = minimumDepth;\n        }\n        if (this.is3d() && this.isCameraOn) {\n            // If the camera is on, the only way to guarantee we can see the entire volume is to set delta at the front plane, not focus plane.\n            // That generally causes the view to be too large (objects in it are too small), since we can't tell whether the objects are at\n            // the front or back of the view. For this reason, don't attempt to add any \"margin\" to camera views.\n        }\n        else if (undefined !== options?.paddingPercent) {\n            let left, right, top, bottom;\n            const padding = options.paddingPercent;\n            if (typeof padding === \"number\") {\n                left = right = top = bottom = padding;\n            }\n            else {\n                left = padding.left ?? 0;\n                right = padding.right ?? 0;\n                top = padding.top ?? 0;\n                bottom = padding.bottom ?? 0;\n            }\n            const width = newDelta.x;\n            const height = newDelta.y;\n            newOrigin.x -= left * width;\n            newDelta.x += (right + left) * width;\n            newOrigin.y -= bottom * height;\n            newDelta.y += (top + bottom) * height;\n        }\n        else if (options?.marginPercent) {\n            // compute how much space we'll need for both of X and Y margins in root coordinates\n            const margin = options.marginPercent;\n            const wPercent = margin.left + margin.right;\n            const hPercent = margin.top + margin.bottom;\n            const marginHorizontal = wPercent / (1 - wPercent) * newDelta.x;\n            const marginVert = hPercent / (1 - hPercent) * newDelta.y;\n            // compute left and bottom margins in root coordinates\n            const marginLeft = margin.left / (1 - wPercent) * newDelta.x;\n            const marginBottom = margin.bottom / (1 - hPercent) * newDelta.y;\n            // add the margins to the range\n            newOrigin.x -= marginLeft;\n            newOrigin.y -= marginBottom;\n            newDelta.x += marginHorizontal;\n            newDelta.y += marginVert;\n        }\n        else {\n            const origDelta = newDelta.clone();\n            newDelta.scale(1.04, newDelta); // default \"dilation\"\n            newOrigin.addScaledInPlace(origDelta.minus(newDelta, origDelta), .5);\n        }\n        viewRot.multiplyTransposeVectorInPlace(newOrigin);\n        if (ViewStatus.Success !== this.adjustViewDelta(newDelta, newOrigin, viewRot, aspect, options))\n            return;\n        this.setExtents(newDelta);\n        this.setOrigin(newOrigin);\n        if (!this.is3d())\n            return;\n        const cameraDef = this.camera;\n        cameraDef.validateLens();\n        // move the camera back so the entire x,y range is visible at front plane\n        const frontDist = newDelta.x / (2.0 * Math.tan(cameraDef.getLensAngle().radians / 2.0));\n        const backDist = frontDist + newDelta.z;\n        cameraDef.setFocusDistance(frontDist); // do this even if the camera isn't currently on.\n        this.centerEyePoint(backDist); // do this even if the camera isn't currently on.\n        this.verifyFocusPlane(); // changes delta/origin\n    }\n    /** Set the rotation of this ViewState to the supplied rotation, by rotating it about a point.\n     * @param rotation The new rotation matrix for this ViewState.\n     * @param point The point to rotate about. If undefined, use the [[getTargetPoint]].\n     */\n    setRotationAboutPoint(rotation, point) {\n        if (undefined === point)\n            point = this.getTargetPoint();\n        const inverse = rotation.clone().inverse();\n        if (undefined === inverse)\n            return;\n        const targetMatrix = inverse.multiplyMatrixMatrix(this.getRotation());\n        const worldTransform = Transform.createFixedPointAndMatrix(point, targetMatrix);\n        const frustum = this.calculateFrustum();\n        if (undefined !== frustum) {\n            frustum.multiply(worldTransform);\n            this.setupFromFrustum(frustum);\n        }\n    }\n    /** Intended strictly as a temporary solution for interactive editing applications, until official support for such apps is implemented.\n     * Invalidates tile trees for all specified models (or all viewed models, if none specified), causing subsequent requests for tiles to make new requests to back-end for updated tiles.\n     * Returns true if any tile tree was invalidated.\n     * @internal\n     */\n    refreshForModifiedModels(modelIds) {\n        let refreshed = false;\n        this.forEachModelTreeRef((ref) => {\n            const tree = ref.treeOwner.tileTree;\n            if (undefined !== tree && (undefined === modelIds || Id64.has(modelIds, tree.modelId))) {\n                ref.treeOwner.dispose();\n                refreshed = true;\n            }\n        });\n        return refreshed;\n    }\n    /** Determine whether this ViewState has the same coordinate system as another one.\n     * They must be from the same iModel, and view a model in common.\n     */\n    hasSameCoordinates(other) {\n        if (this.iModel !== other.iModel)\n            return false;\n        // Spatial views view any number of spatial models all sharing one coordinate system.\n        if (this.isSpatialView() && other.isSpatialView())\n            return true;\n        // People sometimes mistakenly stick 2d models into spatial views' model selectors.\n        if (this.isSpatialView() || other.isSpatialView())\n            return false;\n        // Non-spatial views view exactly one model. If they view the same model, they share a coordinate system.\n        let allowView = false;\n        this.forEachModel((model) => {\n            allowView ||= other.viewsModel(model.id);\n        });\n        return allowView;\n    }\n    /** Compute the vector in the \"up\" direction of a specific point in world space.\n     * This is typically a unit Z vector. However, if the point is outside of the iModel's project extents and using ellipsoid [[globeMode]], an up-vector\n     * will be computed relative to the surface of the ellipsoid at that point.\n     */\n    getUpVector(point) {\n        if (!this.iModel.isGeoLocated || this.globeMode !== GlobeMode.Ellipsoid || this.iModel.projectExtents.containsPoint(point))\n            return Vector3d.unitZ();\n        const earthCenter = this.iModel.getMapEcefToDb(0).origin;\n        const normal = Vector3d.createStartEnd(earthCenter, point);\n        normal.normalizeInPlace();\n        return normal;\n    }\n    /** Return true if the view is looking at the current iModel project extents or\n     * false if the viewed area do does not include more than one percent of the project.\n     */\n    getIsViewingProject() {\n        if (!this.isSpatialView())\n            return false;\n        const worldToNpc = this.computeWorldToNpc();\n        if (!worldToNpc || !worldToNpc.map)\n            return false;\n        const expandedRange = this.iModel.projectExtents.clone();\n        expandedRange.expandInPlace(10E3);\n        const corners = expandedRange.corners(scratchCorners);\n        worldToNpc.map.transform0.multiplyPoint3dArrayQuietNormalize(corners);\n        scratchRange2d.setNull();\n        corners.forEach((corner) => scratchRange2d.extendXY(corner.x, corner.y));\n        const intersection = scratchRange2d.intersect(unitRange2d, scratchRange2dIntersect);\n        if (!intersection || intersection.isNull)\n            return false;\n        const area = (intersection.high.x - intersection.low.x) * (intersection.high.y - intersection.low.y);\n        return area > 1.0E-2;\n    }\n    /** If the view is not of the project as determined by [[getIsViewingProject]] then return\n     * the rotation from a global reference frame to world coordinates.  The global reference frame includes\n     * Y vector towards true north, X parallel to the equator and Z perpendicular to the ellipsoid surface\n     */\n    getGlobeRotation() {\n        if (!this.iModel.isGeoLocated || this.globeMode !== GlobeMode.Ellipsoid || this.getIsViewingProject())\n            return undefined;\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        if (!backgroundMapGeometry)\n            return undefined;\n        const targetRay = Ray3d.create(this.getCenter(), this.getRotation().rowZ().negate(), scratchRay);\n        const earthEllipsoid = backgroundMapGeometry.getEarthEllipsoid();\n        const intersectFractions = new Array(), intersectAngles = new Array();\n        if (earthEllipsoid.intersectRay(targetRay, intersectFractions, undefined, intersectAngles) < 2)\n            return undefined;\n        let minIndex = 0, minFraction = -1.0E10;\n        for (let i = 0; i < intersectFractions.length; i++) {\n            const fraction = intersectFractions[i];\n            if (fraction < minFraction) {\n                minFraction = fraction;\n                minIndex = i;\n            }\n        }\n        const angles = intersectAngles[minIndex];\n        const pointAndDeriv = earthEllipsoid.radiansToPointAndDerivatives(angles.longitudeRadians, angles.latitudeRadians, false);\n        return Matrix3d.createRigidFromColumns(pointAndDeriv.vectorU, pointAndDeriv.vectorV, AxisOrder.XYZ)?.transpose();\n    }\n    /** A value that represents the global scope of the view -- a value greater than one indicates that the scope of this view is global (viewing most of Earth). */\n    get globalScopeFactor() {\n        return this.getExtents().magnitudeXY() / Constant.earthRadiusWGS84.equator;\n    }\n    /** The maximum global scope is not persistent, but maintained as highest global scope factor. This can be used to determine\n     * if the view is of a limited area or if it has ever viewed the entire globe and therefore may be assumed to view it again\n     * and therefore may warrant resources for displaying the globe, such as an expanded viewing frustum and preloading globe map tiles.\n     * A value greater than one indicates that the viewport has been used to view globally at least once.\n     * @internal\n     */\n    get maxGlobalScopeFactor() { return this._maxGlobalScopeFactor; }\n    _updateMaxGlobalScopeFactor() { this._maxGlobalScopeFactor = Math.max(this._maxGlobalScopeFactor, this.globalScopeFactor); }\n    /** Return elevation applied to model when displayed. This is strictly relevant to plan projection models.\n     * @internal\n     */\n    getModelElevation(_modelId) { return 0; }\n    /** An object that can provide per-model transforms to be applied at display time.\n     * @note The transform is used for display purposes only. Operations upon geometry within the model may not take the display transform into account.\n     * @see [[computeDisplayTransform]] to compute a full display transform for a model or an element within it, which may include a transform supplied by this provider.\n     * @beta\n     */\n    get modelDisplayTransformProvider() {\n        return this._modelDisplayTransformProvider;\n    }\n    set modelDisplayTransformProvider(provider) {\n        if (provider === this.modelDisplayTransformProvider)\n            return;\n        if (this.isAttachedToViewport)\n            this.onModelDisplayTransformProviderChanged.raiseEvent(provider);\n        this._modelDisplayTransformProvider = provider;\n    }\n    /** Compute the transform applied to a model or element at display time, if any.\n     * The display transform may be constructed from any combination of the following:\n     *  - [PlanProjectionSettings.elevation]($common) applied to plan projection models by [DisplayStyle3dSettings.planProjectionSettings]($common);\n     *  - A per-model transform supplied by this view's [[modelDisplayTransformProvider]]; and/or\n     *  - A transform applied to an element by an [RenderSchedule.ElementTimeline]($common) defined by this view's [[scheduleScript]].\n     * @param args A description of how to compute the transform.\n     * @returns The computed transform, or `undefined` if no display transform is to be applied.\n     * @beta\n     */\n    computeDisplayTransform(args) {\n        const elevation = this.getModelElevation(args.modelId);\n        const modelTransform = this.modelDisplayTransformProvider?.getModelDisplayTransform(args.modelId);\n        // NB: A ModelTimeline can apply a transform to all elements in the model, but no code exists which actually applies that at display time.\n        // So for now we continue to only consider the ElementTimeline transform.\n        let scriptTransform;\n        if (this.scheduleScript && args.elementId) {\n            const idPair = Id64.getUint32Pair(args.elementId);\n            const modelTimeline = this.scheduleScript.find(args.modelId);\n            const elementTimeline = modelTimeline?.getTimelineForElement(idPair.lower, idPair.upper);\n            scriptTransform = elementTimeline?.getAnimationTransform(args.timePoint ?? this.displayStyle.settings.timePoint ?? 0);\n        }\n        if (0 === elevation && !modelTransform && !scriptTransform)\n            return undefined;\n        const transform = Transform.createIdentity(args.output);\n        transform.origin.z = elevation;\n        if (modelTransform)\n            transform.multiplyTransformTransform(modelTransform, transform);\n        if (scriptTransform)\n            transform.multiplyTransformTransform(scriptTransform, transform);\n        return transform;\n    }\n    /** Invoked when this view becomes the view displayed by the specified [[Viewport]].\n     * A ViewState can be attached to at most **one** Viewport at any given time.\n     * This method is invoked automatically by the viewport - there is generally no reason for applications to invoke it directly.\n     * @note If you override this method you **must** call `super.attachToViewport`.\n     * @throws Error if the view is already attached to any Viewport.\n     * @see [[detachFromViewport]] from the inverse operation.\n     */\n    attachToViewport(_args) {\n        if (this.isAttachedToViewport)\n            throw new Error(\"Attempting to attach a ViewState that is already attached to a Viewport\");\n        this.registerCategorySelectorListeners();\n    }\n    registerCategorySelectorListeners() {\n        const cats = this.categorySelector.observableCategories;\n        const event = () => this.onViewedCategoriesChanged.raiseEvent();\n        this._unregisterCategorySelectorListeners.push(cats.onAdded.addListener(event));\n        this._unregisterCategorySelectorListeners.push(cats.onDeleted.addListener(event));\n        this._unregisterCategorySelectorListeners.push(cats.onCleared.addListener(event));\n    }\n    /** Invoked when this view, previously attached to the specified [[Viewport]] via [[attachToViewport]], is no longer the view displayed by that Viewport.\n     * This method is invoked automatically by the viewport - there is generally no reason for applications to invoke it directly.\n     * @note If you override this method you **must** call `super.detachFromViewport`.\n     * @throws Error if the view is not attached to any Viewport.\n     */\n    detachFromViewport() {\n        if (!this.isAttachedToViewport)\n            throw new Error(\"Attempting to detach a ViewState from a Viewport to which it is not attached.\");\n        this.unregisterCategorySelectorListeners();\n    }\n    unregisterCategorySelectorListeners() {\n        this._unregisterCategorySelectorListeners.forEach((f) => f());\n        this._unregisterCategorySelectorListeners.length = 0;\n    }\n    /** Returns whether this view is currently being displayed by a [[Viewport]].\n     * @public\n     */\n    get isAttachedToViewport() {\n        // In attachToViewport, we register event listeners on the category selector. We remove them in detachFromViewport.\n        // So a non-empty list of event listener removal functions indicates we are currently attached to a viewport.\n        return this._unregisterCategorySelectorListeners.length > 0;\n    }\n    /** Returns an iterator over additional Viewports used to construct this view's scene. e.g., those used for ViewAttachments and section drawings.\n     * This exists chiefly for display-performance-test-app to determine when all tiles required for the view have been loaded.\n     * @internal\n     */\n    get secondaryViewports() {\n        return [];\n    }\n    /** Find the viewport that renders the contents of the view attachment with the specified element Id into this view.\n     * @internal\n     */\n    getAttachmentViewport(_id) {\n        return undefined;\n    }\n}\n/** Defines the state of a view of 3d models.\n * @see [ViewState Parameters]($docs/learning/frontend/views#viewstate-parameters)\n * @public\n * @extensions\n */\nclass ViewState3d extends ViewState {\n    static get className() { return \"ViewDefinition3d\"; }\n    /** Provides access to optional detail settings for this view. */\n    get details() {\n        return this._details;\n    }\n    allow3dManipulations() {\n        return this.details.allow3dManipulations;\n    }\n    /** Set whether [[ViewTool]]s are allowed to operate in 3 dimensions on this view. */\n    setAllow3dManipulations(allow) {\n        this.details.allow3dManipulations = allow;\n    }\n    constructor(props, iModel, categories, displayStyle) {\n        super(props, iModel, categories, displayStyle);\n        this._modelClips = [];\n        /** Minimum distance for front plane */\n        this.forceMinFrontDist = 0.0;\n        this._cameraOn = JsonUtils.asBool(props.cameraOn);\n        this.origin = Point3d.fromJSON(props.origin);\n        this.extents = Vector3d.fromJSON(props.extents);\n        this.rotation = YawPitchRollAngles.fromJSON(props.angles).toMatrix3d();\n        assert(this.rotation.isRigid());\n        this.camera = new Camera(props.camera);\n        // if the camera is on, make sure the eyepoint is centered.\n        if (this.is3d() && this.isCameraOn)\n            this.centerEyePoint();\n        this._details = new ViewDetails3d(this.jsonProperties);\n        this._details.onModelClipGroupsChanged.addListener((newGroups) => this.updateModelClips(newGroups));\n        this.updateModelClips(this._details.modelClipGroups);\n        this._updateMaxGlobalScopeFactor();\n    }\n    updateModelClips(groups) {\n        this._modelClips.length = 0;\n        for (const group of groups.groups) {\n            const clip = group.clip ? IModelApp.renderSystem.createClipVolume(group.clip) : undefined;\n            this._modelClips.push(clip);\n        }\n    }\n    /** @internal */\n    getModelClip(modelId) {\n        // ###TODO: ViewFlags.clipVolume is for the *view clip* only. Some tiles will want to ignore *all* clips (i.e., section-cut tiles).\n        const index = this.details.modelClipGroups.findGroupIndex(modelId);\n        return -1 !== index ? this._modelClips[index] : undefined;\n    }\n    /** Capture a copy of the viewed volume and camera parameters. */\n    savePose() { return new ViewPose3d(this); }\n    /** See [[ViewState.applyPose]]. */\n    applyPose(val) {\n        if (val instanceof ViewPose3d) {\n            this._cameraOn = val.cameraOn;\n            this.setOrigin(val.origin);\n            this.setExtents(val.extents);\n            this.rotation.setFrom(val.rotation);\n            this.camera.setFrom(val.camera);\n            this._updateMaxGlobalScopeFactor();\n        }\n        return this;\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.cameraOn = this._cameraOn;\n        val.origin = this.origin;\n        val.extents = this.extents;\n        val.angles = YawPitchRollAngles.createFromMatrix3d(this.rotation).toJSON();\n        val.camera = this.camera;\n        return val;\n    }\n    /** See [[ViewState.is3d]]. */\n    is3d() { return true; }\n    /** @internal */\n    isDrawingView() { return false; }\n    get isCameraOn() { return this._cameraOn; }\n    get isGlobalView() {\n        if (undefined === this.iModel.ecefLocation)\n            return false;\n        return this.globalScopeFactor >= 1;\n    }\n    /** A value that represents the global scope of the view -- a value greater than one indicates that the scope of this view is global.\n     * @see [[isGlobalView]].\n     */\n    get globalScopeFactor() {\n        const eyeHeight = this.getEyeCartographicHeight();\n        return (undefined === eyeHeight) ? (this.extents.magnitudeXY() / Constant.earthRadiusWGS84.equator) : (eyeHeight / ViewState3d._minGlobeEyeHeight);\n    }\n    /** A value representing the degree to which a view is viewing the globe as opposed to a specific location\n     * a value of zero or less indicates that the view is not global, a value between zero and one represent a semi\n     * global view.  Values greater than one indicate a global view.\n     *\n     * A Global view is arbitrarily designated as a camera view with the camera height greater than one fourth of the globe\n     * radius or an orthographic view with view diagonal greater than one fourth of the globe radius.\n     */\n    globalViewTransition() {\n        if (undefined === this.iModel.ecefLocation)\n            return 0.0;\n        let h = 0.0;\n        if (this.isCameraOn) {\n            const carto = this.rootToCartographic(this.getEyePoint(), ViewState3d._scratchGlobeCarto);\n            h = (undefined === carto ? 0.0 : carto.height);\n        }\n        else\n            h = this.extents.magnitudeXY();\n        const startTransition = 0.33333 * ViewState3d._minGlobeEyeHeight;\n        if (h > ViewState3d._minGlobeEyeHeight)\n            return 1.0;\n        else if (h < startTransition)\n            return 0.0;\n        else\n            return (h - startTransition) / (ViewState3d._minGlobeEyeHeight - startTransition);\n    }\n    getCartographicHeight(point) {\n        const ecefLocation = this.iModel.ecefLocation;\n        if (undefined === ecefLocation)\n            return undefined;\n        const carto = this.rootToCartographic(point, ViewState3d._scratchGlobeCarto);\n        return carto === undefined ? undefined : carto.height;\n    }\n    getEyeCartographicHeight() {\n        return this.isCameraOn ? this.getCartographicHeight(this.getEyePoint()) : undefined;\n    }\n    isEyePointGlobalView(eyePoint) {\n        const cartoHeight = this.getCartographicHeight(eyePoint);\n        return undefined === cartoHeight ? false : cartoHeight > ViewState3d._minGlobeEyeHeight;\n    }\n    /** Look at a global location, placing the camera's eye at the specified eye height above a viewed location.\n     *  If location is defined, its center position will be viewed using the specified eye height.\n     *  If location also has an area specified, the eye height will be adjusted to view the specified location based on that area.\n     *  Otherwise, this function views a point on the earth as if the current eye point was placed on the earth. If the eyePoint parameter is defined, instead this point will be placed on the earth and viewed.\n     *  Specify pitchAngleRadians to tilt the final view; this defaults to 0.\n     *  Returns the distance from original eye point to new eye point.\n     *  @public\n     */\n    lookAtGlobalLocation(eyeHeight, pitchAngleRadians = 0, location, eyePoint) {\n        if (!this.iModel.isGeoLocated)\n            return 0;\n        if (location !== undefined && location.area !== undefined)\n            eyeHeight = areaToEyeHeight(this, location.area, location.center.height);\n        const origEyePoint = eyePoint !== undefined ? eyePoint.clone() : this.getEyeOrOrthographicViewPoint().clone();\n        let targetPoint = origEyePoint;\n        const targetPointCartographic = location !== undefined ? location.center.clone() : this.rootToCartographic(targetPoint);\n        targetPointCartographic.height = 0.0;\n        targetPoint = this.cartographicToRoot(targetPointCartographic);\n        targetPointCartographic.height = eyeHeight;\n        const lEyePoint = this.cartographicToRoot(targetPointCartographic);\n        return this.finishLookAtGlobalLocation(targetPointCartographic, origEyePoint, lEyePoint, targetPoint, pitchAngleRadians);\n    }\n    /** Look at a global location, placing the camera's eye at the specified eye height above a viewed location using the GCS.\n     *  If location is defined, its center position will be viewed using the specified eye height.\n     *  If location also has an area specified, the eye height will be adjusted to view the specified location based on that area.\n     *  Otherwise, this function views a point on the earth as if the current eye point was placed on the earth. If the eyePoint parameter is defined, instead this point will be placed on the earth and viewed.\n     *  Specify pitchAngleRadians to tilt the final view; this defaults to 0.\n     *  Returns the distance from original eye point to new eye point.\n     *  @public\n     */\n    async lookAtGlobalLocationFromGcs(eyeHeight, pitchAngleRadians = 0, location, eyePoint) {\n        if (!this.iModel.isGeoLocated)\n            return 0;\n        if (location !== undefined && location.area !== undefined)\n            eyeHeight = await areaToEyeHeightFromGcs(this, location.area, location.center.height);\n        const origEyePoint = eyePoint !== undefined ? eyePoint.clone() : this.getEyeOrOrthographicViewPoint().clone();\n        let targetPoint = origEyePoint;\n        const targetPointCartographic = location !== undefined ? location.center.clone() : this.rootToCartographic(targetPoint);\n        targetPointCartographic.height = 0.0;\n        targetPoint = (await this.cartographicToRootFromGcs(targetPointCartographic));\n        targetPointCartographic.height = eyeHeight;\n        const lEyePoint = (await this.cartographicToRootFromGcs(targetPointCartographic));\n        return this.finishLookAtGlobalLocation(targetPointCartographic, origEyePoint, lEyePoint, targetPoint, pitchAngleRadians);\n    }\n    finishLookAtGlobalLocation(targetPointCartographic, origEyePoint, eyePoint, targetPoint, pitchAngleRadians) {\n        targetPointCartographic.latitude += .001;\n        const northOfEyePoint = this.cartographicToRoot(targetPointCartographic);\n        let upVector = targetPoint.unitVectorTo(northOfEyePoint);\n        if (this.globeMode === GlobeMode.Plane)\n            upVector = Vector3d.create(Math.abs(upVector.x), Math.abs(upVector.y), Math.abs(upVector.z));\n        if (0 !== pitchAngleRadians) {\n            const pitchAxis = upVector.unitCrossProduct(Vector3d.createStartEnd(targetPoint, eyePoint));\n            if (undefined !== pitchAxis) {\n                const pitchMatrix = Matrix3d.createRotationAroundVector(pitchAxis, Angle.createRadians(pitchAngleRadians));\n                const pitchTransform = Transform.createFixedPointAndMatrix(targetPoint, pitchMatrix);\n                eyePoint = pitchTransform.multiplyPoint3d(eyePoint);\n                pitchMatrix.multiplyVector(upVector, upVector);\n            }\n        }\n        const isCameraEnabled = this.isCameraOn;\n        this.lookAt({ eyePoint, targetPoint, upVector, lensAngle: this.camera.getLensAngle() });\n        if (!isCameraEnabled && this.isCameraOn)\n            this.turnCameraOff();\n        return eyePoint.distance(origEyePoint);\n    }\n    /** Convert a point in spatial coordinates to a cartographic coordinate. */\n    rootToCartographic(root, result) {\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        return backgroundMapGeometry ? backgroundMapGeometry.dbToCartographic(root, result) : undefined;\n    }\n    /** Convert a cartographic coordinate to a point in spatial coordinates. */\n    cartographicToRoot(cartographic, result) {\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        return backgroundMapGeometry ? backgroundMapGeometry.cartographicToDb(cartographic, result) : undefined;\n    }\n    /** Convert a point in spatial coordinates to a cartographic coordinate using the GCS reprojection.\n     * @see [[rootToCartographicUsingGcs]] to convert multiple points at once.\n     * @see [[cartographicToRootFromGcs]] for the inverse conversion.\n     */\n    async rootToCartographicFromGcs(root, result) {\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        if (!backgroundMapGeometry)\n            return undefined;\n        const carto = (await backgroundMapGeometry.dbToCartographicFromGcs([root]))[0];\n        return carto.clone(result);\n    }\n    /** Convert spatial coordinates to cartographic coordinates using the GCS reprojection.\n     * @param root Spatial coordinates to be converted\n     * @returns the converted coordinates of the same length and order as `root`, or `undefined` if the conversion cannot be performed.\n     * @see [[cartographicToRootUsingGcs]] for the inverse conversion.\n     */\n    async rootToCartographicUsingGcs(root) {\n        const bgmap = this.displayStyle.getBackgroundMapGeometry();\n        return bgmap?.dbToCartographicFromGcs(root);\n    }\n    /** Convert a cartographic coordinate to a point in spatial coordinates using the GCS reprojection.\n     * @see [[cartographicToRootUsingGcs]] to convert multiple points at once.\n     * @see [[rootToCartographicFromGcs]] for the inverse conversion.\n     */\n    async cartographicToRootFromGcs(cartographic, result) {\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        if (!backgroundMapGeometry)\n            return undefined;\n        const root = (await backgroundMapGeometry.cartographicToDbFromGcs([cartographic]))[0];\n        return root.clone(result);\n    }\n    /** Convert cartographic coordinates to spatial coordinates using the GCS reprojection.\n     * @param cartographic Cartographic coordinates to be converted\n     * @returns the converted coordinates of the same length and order as `cartographic`, or `undefined` if the conversion cannot be performed.\n     * @see [[rootToCartographicUsingGcs]] for the inverse conversion.\n     */\n    async cartographicToRootUsingGcs(cartographic) {\n        const bgmap = this.displayStyle.getBackgroundMapGeometry();\n        return bgmap?.cartographicToDbFromGcs(cartographic);\n    }\n    setupFromFrustum(frustum, opts) {\n        const stat = super.setupFromFrustum(frustum, opts);\n        if (ViewStatus.Success !== stat)\n            return stat;\n        this.turnCameraOff();\n        const frustPts = frustum.points;\n        // use comparison of back, front plane X sizes to indicate camera or flat view ...\n        const xBack = frustPts[Npc.LeftBottomRear].distance(frustPts[Npc.RightBottomRear]);\n        const xFront = frustPts[Npc.LeftBottomFront].distance(frustPts[Npc.RightBottomFront]);\n        const flatViewFractionTolerance = 1.0e-6;\n        if (xFront > xBack * (1.0 + flatViewFractionTolerance))\n            return ViewStatus.InvalidWindow;\n        // see if the frustum is tapered, and if so, set up camera eyepoint and adjust viewOrg and delta.\n        const compression = xFront / xBack;\n        if (compression >= (1.0 - flatViewFractionTolerance))\n            return ViewStatus.Success;\n        // the frustum has perspective, turn camera on\n        let viewOrg = frustPts[Npc.LeftBottomRear];\n        const viewDelta = this.getExtents().clone();\n        const zDir = this.getZVector();\n        const frustumZ = viewOrg.vectorTo(frustPts[Npc.LeftBottomFront]);\n        const frustOrgToEye = frustumZ.scale(1.0 / (1.0 - compression));\n        const eyePoint = viewOrg.plus(frustOrgToEye);\n        const backDistance = frustOrgToEye.dotProduct(zDir); // distance from eye to back plane of frustum\n        const focusDistance = this.camera.isFocusValid ? this.camera.focusDist : (backDistance - (viewDelta.z / 2.0));\n        const focalFraction = focusDistance / backDistance; // ratio of focus plane distance to back plane distance\n        viewOrg = eyePoint.plus2Scaled(frustOrgToEye, -focalFraction, zDir, focusDistance - backDistance); // now project that point onto back plane\n        viewDelta.x *= focalFraction; // adjust view delta for x and y so they are also at focus plane\n        viewDelta.y *= focalFraction;\n        this.setEyePoint(eyePoint);\n        this.setFocusDistance(focusDistance);\n        this.setOrigin(viewOrg);\n        this.setExtents(viewDelta);\n        this.setLensAngle(this.calcLensAngle());\n        this.enableCamera();\n        this._updateMaxGlobalScopeFactor();\n        return ViewStatus.Success;\n    }\n    static calculateMaxDepth(delta, zVec) {\n        const depthRatioLimit = 1.0E8; // Limit for depth Ratio.\n        const maxTransformRowRatio = 1.0E5;\n        const minXYComponent = Math.min(Math.abs(zVec.x), Math.abs(zVec.y));\n        const maxDepthRatio = (0.0 === minXYComponent) ? depthRatioLimit : Math.min((maxTransformRowRatio / minXYComponent), depthRatioLimit);\n        return Math.max(delta.x, delta.y) * maxDepthRatio;\n    }\n    getOrigin() { return this.origin; }\n    getExtents() { return this.extents; }\n    getRotation() { return this.rotation; }\n    setOrigin(origin) { this.origin.setFrom(origin); }\n    setExtents(extents) { this.extents.setFrom(extents); }\n    setRotation(rot) { this.rotation.setFrom(rot); }\n    /** @internal */\n    enableCamera() {\n        if (this.supportsCamera())\n            this._cameraOn = true;\n    }\n    supportsCamera() {\n        return this.allow3dManipulations();\n    }\n    minimumFrontDistance() {\n        return Math.max(15.2 * Constant.oneCentimeter, this.forceMinFrontDist);\n    }\n    isEyePointAbove(elevation) {\n        return !this._cameraOn ? (this.getZVector().z > 0) : (this.getEyePoint().z > elevation);\n    }\n    /** The style that controls how the contents of the view are displayed. */\n    get displayStyle() {\n        return this.getDisplayStyle3d();\n    }\n    set displayStyle(style) {\n        assert(style instanceof DisplayStyle3dState);\n        super.displayStyle = style;\n    }\n    /** The style that controls how the contents of the view are displayed.\n     * @see [[ViewState3d.displayStyle]].\n     */\n    getDisplayStyle3d() {\n        return super.displayStyle;\n    }\n    /** Turn the camera off for this view. After this call, the camera parameters in this view definition are ignored and views that use it will\n     * display with an orthographic (infinite focal length) projection of the view volume from the view direction.\n     * @note To turn the camera back on, call #lookAt\n     */\n    turnCameraOff() { this._cameraOn = false; }\n    /** Determine whether the camera is valid for this view */\n    get isCameraValid() { return this.camera.isValid; }\n    /** Calculate the lens angle formed by the current delta and focus distance */\n    calcLensAngle() {\n        return Angle.createRadians(2.0 * Math.atan2(this.extents.x * 0.5, this.camera.getFocusDistance()));\n    }\n    /** Get the target point of the view. If there is no camera, view center is returned. */\n    getTargetPoint(result) {\n        if (!this._cameraOn) {\n            const earthFocalPoint = this.getEarthFocalPoint();\n            return earthFocalPoint ? earthFocalPoint : super.getTargetPoint(result);\n        }\n        return this.getEyePoint().plusScaled(this.getZVector(), -1.0 * this.getFocusDistance(), result);\n    }\n    /** Setup view state for either perspective or orthographic view.\n     * @returns A [[ViewStatus]] indicating whether the camera was successfully positioned.\n     * @note If the aspect ratio of viewDelta does not match the aspect ratio of a Viewport into which this view is displayed, it will be\n     * adjusted when the [[Viewport]] is synchronized from this view.\n     */\n    lookAt(args) {\n        if (args.lensAngle) {\n            const lensAngle = args.lensAngle;\n            const eyePoint = Vector3d.createFrom(args.eyePoint);\n            const focus = eyePoint.vectorTo(args.targetPoint).magnitude(); // Set focus at target point\n            if (focus <= Constant.oneMillimeter) // eye and target are too close together\n                return ViewStatus.InvalidTargetPoint;\n            if (lensAngle.radians < .0001 || lensAngle.radians > Math.PI)\n                return ViewStatus.InvalidLens;\n            const width = 2.0 * Math.tan(lensAngle.radians / 2.0) * focus;\n            const newExtents = Vector2d.createFrom(args.newExtents ?? this.extents);\n            newExtents.scale(width / newExtents.x, newExtents);\n            args = { ...args, newExtents };\n        }\n        const isPerspective = undefined !== args.targetPoint;\n        if (isPerspective && !this.supportsCamera())\n            return ViewStatus.NotCameraView;\n        const eye = new Point3d(args.eyePoint.x, args.eyePoint.y, args.eyePoint.z);\n        const yVec = args.upVector.normalize();\n        if (!yVec) // up vector zero length?\n            return ViewStatus.InvalidUpVector;\n        const minFrontDist = this.minimumFrontDistance();\n        let zVec;\n        let focusDist;\n        if (args.targetPoint) {\n            zVec = Vector3d.createStartEnd(args.targetPoint, eye); // z defined by direction from eye to target\n            focusDist = zVec.normalizeWithLength(zVec).mag; // set focus at target point\n            if (focusDist <= minFrontDist) { // eye and target are too close together\n                args.opts?.onExtentsError?.(ViewStatus.InvalidTargetPoint);\n                return ViewStatus.InvalidTargetPoint;\n            }\n        }\n        else {\n            zVec = Vector3d.createFrom(args.viewDirection).negate();\n            if (!zVec.normalizeInPlace())\n                return ViewStatus.InvalidDirection;\n            focusDist = this.getFocusDistance();\n        }\n        const xVec = new Vector3d();\n        if (yVec.crossProduct(zVec).normalizeWithLength(xVec).mag < Geometry.smallMetricDistance)\n            return ViewStatus.InvalidUpVector; // up is parallel to z\n        if (zVec.crossProduct(xVec).normalizeWithLength(yVec).mag < Geometry.smallMetricDistance)\n            return ViewStatus.InvalidUpVector;\n        // we now have rows of the rotation matrix\n        const rotation = Matrix3d.createRows(xVec, yVec, zVec);\n        let backDist = args.backDistance ? args.backDistance : this.getBackDistance();\n        let frontDist = args.frontDistance ? args.frontDistance : this.getFrontDistance();\n        const delta = args.newExtents ? new Vector3d(Math.abs(args.newExtents.x), Math.abs(args.newExtents.y), this.extents.z) : this.extents.clone();\n        // The front/back distance are relatively arbitrary -- the frustum will be adjusted to include geometry.\n        // Set them here to reasonable in front of eye and just beyond target.\n        frontDist = Math.min(frontDist, (.5 * Constant.oneMeter));\n        backDist = Math.min(backDist, focusDist + (.5 * Constant.oneMeter));\n        if (backDist < focusDist) // make sure focus distance is in front of back distance.\n            backDist = focusDist + Constant.oneMillimeter;\n        if (frontDist > focusDist)\n            frontDist = focusDist - minFrontDist;\n        if (frontDist < minFrontDist)\n            frontDist = minFrontDist;\n        delta.z = (backDist - frontDist);\n        const stat = this.adjustViewDelta(delta, eye, rotation, undefined, args.opts);\n        if (ViewStatus.Success !== stat)\n            return stat;\n        if (delta.z > ViewState3d.calculateMaxDepth(delta, zVec)) // make sure we're not zoomed out too far\n            return ViewStatus.MaxDisplayDepth;\n        // The origin is defined as the lower left of the view rectangle on the focus plane, projected to the back plane.\n        // Start at eye point, and move to center of back plane, then move left half of width. and down half of height\n        const origin = eye.plus3Scaled(zVec, -backDist, xVec, -0.5 * delta.x, yVec, -0.5 * delta.y);\n        this.setEyePoint(args.eyePoint);\n        this.setRotation(rotation);\n        this.setFocusDistance(focusDist);\n        this.setOrigin(origin);\n        this.setExtents(delta);\n        this.setLensAngle(this.calcLensAngle());\n        if (isPerspective)\n            this.enableCamera();\n        else\n            this.turnCameraOff();\n        this._updateMaxGlobalScopeFactor();\n        return ViewStatus.Success;\n    }\n    /** Change the focus distance for this ViewState3d. Preserves the content of the view.\n     * @internal\n     */\n    changeFocusDistance(newDist) {\n        if (newDist <= Constant.oneMillimeter)\n            return ViewStatus.InvalidTargetPoint;\n        const oldExtents = this.extents.clone(); // save current extents so we can keep frustum unchanged\n        this.extents.x = 2.0 * Math.tan(this.camera.lens.radians / 2.0) * newDist; // new width based on focus distance and lens angle.\n        this.extents.y = this.extents.y * (this.extents.x / oldExtents.x); // preserve aspect ratio\n        this.origin.addScaledInPlace(this.rotation.multiplyTransposeVector(this.extents.vectorTo(oldExtents)), .5); // move origin by half the change in extents\n        this.camera.focusDist = newDist; // save new focus distance\n        return ViewStatus.Success;\n    }\n    /** Change the focus distance for this ViewState3d to be defined by the the supplied point, if it is in front of the camera.\n     * Preserves the content of the view.\n     * @internal\n     */\n    changeFocusFromPoint(pt) {\n        return this.changeFocusDistance(this.getZVector().dotProduct(pt.vectorTo(this.camera.eye)));\n    }\n    /** Move the camera relative to its current location by a distance in camera coordinates.\n     * @param distance to move camera. Length is in world units, direction relative to current camera orientation.\n     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n     */\n    moveCameraLocal(distance) {\n        const distWorld = this.rotation.multiplyTransposeVector(distance);\n        return this.moveCameraWorld(distWorld);\n    }\n    /** Move the camera relative to its current location by a distance in world coordinates.\n     * @param distance in world units.\n     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n     */\n    moveCameraWorld(distance) {\n        if (!this._cameraOn) {\n            this.origin.plus(distance, this.origin);\n            return ViewStatus.Success;\n        }\n        const targetPoint = this.getTargetPoint().plus(distance);\n        const eyePoint = this.getEyePoint().plus(distance);\n        return this.lookAt({ eyePoint, targetPoint, upVector: this.getYVector() });\n    }\n    /** Rotate the camera from its current location about an axis relative to its current orientation.\n     * @param angle The angle to rotate the camera.\n     * @param axis The axis about which to rotate the camera. The axis is a direction relative to the current camera orientation.\n     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place\n     *  (i.e. about the current eyePoint).\n     * @note Even though the axis is relative to the current camera orientation, the aboutPt is in world coordinates, \\b not relative to the camera.\n     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n     */\n    rotateCameraLocal(angle, axis, aboutPt) {\n        const axisWorld = this.getRotation().multiplyTransposeVector(axis);\n        return this.rotateCameraWorld(angle, axisWorld, aboutPt);\n    }\n    /** Rotate the camera from its current location about an axis in world coordinates.\n     * @param angle The angle to rotate the camera.\n     * @param axis The world-based axis (direction) about which to rotate the camera.\n     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place\n     *  (i.e. about the current eyePoint).\n     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n     */\n    rotateCameraWorld(angle, axis, aboutPt) {\n        const about = aboutPt ? aboutPt : this.getEyePoint();\n        const rotation = Matrix3d.createRotationAroundVector(axis, angle);\n        if (!rotation)\n            return ViewStatus.InvalidUpVector; // Invalid axis given\n        const trans = Transform.createFixedPointAndMatrix(about, rotation);\n        const targetPoint = trans.multiplyPoint3d(this.getTargetPoint());\n        const upVector = rotation.multiplyVector(this.getYVector());\n        return this.lookAt({ eyePoint: this.getEyePoint(), targetPoint, upVector });\n    }\n    /** Move camera about the global ellipsoid. This rotates the camera position about the center of the global ellipsoid maintaining the current height.\n     * @param fromPoint Point to pan from.\n     * @param point Point to point to.\n     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n     */\n    moveCameraGlobal(fromPoint, toPoint) {\n        if (!this.iModel.ecefLocation)\n            return ViewStatus.NotGeolocated;\n        if (this.globeMode !== GlobeMode.Ellipsoid)\n            return ViewStatus.NotEllipsoidGlobeMode;\n        const earthCenter = this.iModel.ecefLocation?.earthCenter;\n        const rMatrix = Matrix3d.createRotationVectorToVector(Vector3d.createStartEnd(earthCenter, toPoint), Vector3d.createStartEnd(earthCenter, fromPoint));\n        if (!rMatrix)\n            return ViewStatus.DegenerateGeometry;\n        const rotationTransform = Transform.createFixedPointAndMatrix(earthCenter, rMatrix);\n        const frustum = this.calculateFrustum();\n        if (!frustum)\n            return ViewStatus.DegenerateGeometry;\n        frustum.multiply(rotationTransform);\n        return this.setupFromFrustum(frustum);\n    }\n    /** Get the distance from the eyePoint to the front plane for this view. */\n    getFrontDistance() { return this.getBackDistance() - this.extents.z; }\n    /** Get the distance from the eyePoint to the back plane for this view. */\n    getBackDistance() {\n        // backDist is the z component of the vector from the origin to the eyePoint .\n        const eyeOrg = this.origin.vectorTo(this.getEyePoint());\n        this.getRotation().multiplyVector(eyeOrg, eyeOrg);\n        return eyeOrg.z;\n    }\n    /** Place the eyepoint of the camera so it is aligned with the center of the view. This removes any 1-point perspective skewing that may be\n     * present in the current view.\n     * @param backDistance If defined, the new the distance from the eyepoint to the back plane. Otherwise the distance from the\n     * current eyepoint is used.\n     */\n    centerEyePoint(backDistance) {\n        const eyePoint = this.getExtents().scale(0.5);\n        eyePoint.z = backDistance ? backDistance : this.getBackDistance();\n        const eye = this.getOrigin().plus(this.getRotation().multiplyTransposeXYZ(eyePoint.x, eyePoint.y, eyePoint.z));\n        this.camera.setEyePoint(eye);\n    }\n    /** Center the focus distance of the camera halfway between the front plane and the back plane, keeping the eyepoint,\n     * lens angle, rotation, back distance, and front distance unchanged.\n     * @note The focus distance, origin, and delta values are modified, but the view encloses the same volume and appears visually unchanged.\n     */\n    centerFocusDistance() {\n        const backDistance = this.getBackDistance();\n        const frontDistance = this.getFrontDistance();\n        const eyePoint = this.getEyePoint();\n        const targetPoint = eyePoint.plusScaled(this.getZVector(), frontDistance - backDistance);\n        this.lookAt({ eyePoint, targetPoint, upVector: this.getYVector(), lensAngle: this.getLensAngle(), frontDistance, backDistance });\n    }\n    /** Ensure the focus plane lies between the front and back planes. If not, center it. */\n    verifyFocusPlane() {\n        if (!this._cameraOn)\n            return;\n        let backDist = this.getBackDistance();\n        const frontDist = backDist - this.extents.z;\n        const camera = this.camera;\n        const extents = this.extents;\n        const rot = this.rotation;\n        if (backDist <= 0.0 || frontDist <= 0.0) {\n            // the camera location is invalid. Set it based on the view range.\n            const tanAngle = Math.tan(camera.lens.radians / 2.0);\n            backDist = extents.z / tanAngle;\n            camera.setFocusDistance(backDist / 2);\n            this.centerEyePoint(backDist);\n            return;\n        }\n        const focusDist = camera.focusDist;\n        if (focusDist > frontDist && focusDist < backDist)\n            return;\n        // put it halfway between front and back planes\n        camera.setFocusDistance((extents.z / 2.0) + frontDist);\n        // moving the focus plane means we have to adjust the origin and delta too (they're on the focus plane, see diagram above)\n        const ratio = camera.focusDist / focusDist;\n        extents.x *= ratio;\n        extents.y *= ratio;\n        camera.eye.plus3Scaled(rot.rowZ(), -backDist, rot.rowX(), -0.5 * extents.x, rot.rowY(), -0.5 * extents.y, this.origin); // this centers the camera too\n    }\n    /** Get the current location of the eyePoint for camera in this view. */\n    getEyePoint() { return this.camera.eye; }\n    /** Get the lens angle for this view. */\n    getLensAngle() { return this.camera.lens; }\n    /** Set the lens angle for this view.\n     *  @param angle The new lens angle in radians. Must be greater than 0 and less than pi.\n     *  @note This does not change the view's current field-of-view. Instead, it changes the lens that will be used if the view\n     *  is subsequently modified and the lens angle is used to position the eyepoint.\n     *  @note To change the field-of-view (i.e. \"zoom\") of a view, pass a new viewDelta to #lookAt\n     */\n    setLensAngle(angle) { this.camera.setLensAngle(angle); }\n    /** Change the location of the eyePoint for the camera in this view.\n     * @param pt The new eyepoint.\n     * @note This method is generally for internal use only. Moving the eyePoint arbitrarily can result in skewed or illegal perspectives.\n     * The most common method for user-level camera positioning is #lookAt.\n     */\n    setEyePoint(pt) { this.camera.setEyePoint(pt); }\n    /** Set the focus distance for this view.\n     *  @note Changing the focus distance changes the plane on which the delta.x and delta.y values lie. So, changing focus distance\n     *  without making corresponding changes to delta.x and delta.y essentially changes the lens angle, causing a \"zoom\" effect\n     */\n    setFocusDistance(dist) { this.camera.setFocusDistance(dist); }\n    /**  Get the distance from the eyePoint to the focus plane for this view. */\n    getFocusDistance() { return this.camera.focusDist; }\n    /** Obtain an \"eye\" point for this view. If the camera is on, this simply returns [[Camera.getEyePoint]].\n     * Otherwise, a pseudo-eye-point is computed from the view direction and a lens angle of PI/2.\n     */\n    getEyeOrOrthographicViewPoint() {\n        if (this.isCameraOn)\n            return this.camera.getEyePoint();\n        this.camera.validateLens();\n        const tanHalfAngle = Math.tan(this.camera.lens.radians / 2);\n        const halfDelta = this.getExtents().magnitudeXY();\n        const eyeDistance = tanHalfAngle ? (halfDelta / tanHalfAngle) : 0;\n        const zVector = this.getRotation().getRow(2);\n        return this.getCenter().plusScaled(zVector, -eyeDistance);\n    }\n    createAuxCoordSystem(acsName) { return AuxCoordSystem3dState.createNew(acsName, this.iModel); }\n    decorate(context) {\n        super.decorate(context);\n        if (this._environmentDecorations)\n            this._environmentDecorations.decorate(context);\n    }\n    /** Returns the ground elevation taken from the environment added with the global z position of this imodel. */\n    getGroundElevation() {\n        const env = this.getDisplayStyle3d().environment;\n        return env.ground.elevation + this.iModel.globalOrigin.z;\n    }\n    /** Return the ground extents, which will originate either from the viewport frustum or the extents of the imodel. */\n    getGroundExtents(vp) {\n        const displayStyle = this.getDisplayStyle3d();\n        const extents = new Range3d();\n        if (!displayStyle.environment.displayGround)\n            return extents; // Ground plane is not enabled\n        const elevation = this.getGroundElevation();\n        if (undefined !== vp) {\n            const viewRay = Ray3d.create(Point3d.create(), vp.rotation.rowZ());\n            const xyPlane = Plane3dByOriginAndUnitNormal.create(Point3d.create(0, 0, elevation), Vector3d.create(0, 0, 1));\n            // first determine whether the ground plane is displayed in the view\n            const worldFrust = vp.getFrustum();\n            for (const point of worldFrust.points) {\n                viewRay.origin = point; // We never modify the reference\n                const xyzPoint = Point3d.create();\n                const param = viewRay.intersectionWithPlane(xyPlane, xyzPoint);\n                if (param === undefined)\n                    return extents; // View does not show ground plane\n            }\n        }\n        extents.setFrom(this.iModel.projectExtents);\n        extents.low.z = extents.high.z = elevation;\n        const center = extents.low.interpolate(.5, extents.high);\n        const radius = extents.low.distance(extents.high);\n        extents.setNull();\n        extents.extendPoint(center); // Extents now contains single point\n        extents.low.addScaledInPlace(Vector3d.create(-1, -1, -1), radius);\n        extents.high.addScaledInPlace(Vector3d.create(1, 1, 1), radius);\n        extents.low.z = extents.high.z = elevation;\n        return extents;\n    }\n    /** @internal */\n    getModelElevation(modelId) {\n        const settings = this.getDisplayStyle3d().settings.getPlanProjectionSettings(modelId);\n        return settings && settings.elevation ? settings.elevation : 0;\n    }\n    /** If the background map is displayed, return the point on the globe in directly front of the eye (or in center of view if camera off)\n     *  This is generally a better target point for orthographic views than the view center which can be far from the area of interest.\n     * @public\n     */\n    getEarthFocalPoint() {\n        if (!this.iModel.ecefLocation || this.globeMode !== GlobeMode.Ellipsoid)\n            return undefined;\n        const backgroundMapGeometry = this.displayStyle.getBackgroundMapGeometry();\n        if (undefined === backgroundMapGeometry)\n            return undefined;\n        const earthEllipsoid = backgroundMapGeometry.getEarthEllipsoid();\n        const viewZ = this.getRotation().rowZ();\n        const center = this.getCenter();\n        const eye = this.isCameraOn ? this.camera.getEyePoint() : center.plusScaled(viewZ, Constant.diameterOfEarth);\n        const eyeRay = Ray3d.create(eye, viewZ);\n        const fractions = new Array(), points = new Array();\n        if (earthEllipsoid.intersectRay(eyeRay, fractions, points, undefined)) {\n            let fraction = -1.0E10, index = -1;\n            for (let i = 0; i < fractions.length; i++)\n                if (fractions[i] > fraction) {\n                    fraction = fractions[i];\n                    index = i;\n                }\n            return (index >= 0 && fraction < 0) ? points[index] : undefined;\n        }\n        else {\n            return eyeRay.projectPointToRay(center);\n        }\n    }\n    /**\n     * For a geoLocated project, align the view with the global ellipsoid by rotating\n     * around the supplied target point such that the view axis points toward the\n     * globe center. If the viewing height is below the global transition threshold.\n     * @param target The rotation target or pivot point.  This point will remain stationary in the view.\n     * @param transition If this is defined and true then the rotation is scaled by the [[ViewState.globalViewTransition]]  This\n     * will cause a smooth transition as a view is zoomed out from a specific location to a more global representation.\n     * @public\n     */\n    alignToGlobe(target, transition) {\n        if (!this.iModel.ecefLocation)\n            return ViewStatus.NotGeolocated;\n        if (this.globeMode !== GlobeMode.Ellipsoid)\n            return ViewStatus.NotEllipsoidGlobeMode;\n        const globalTransition = this.globalViewTransition();\n        if (globalTransition <= 0)\n            return ViewStatus.HeightBelowTransition;\n        const earthCenter = this.iModel.ecefLocation?.earthCenter;\n        const viewCenter = this.getCenter();\n        const viewZ = this.getRotation().rowZ();\n        const eye = this.isCameraOn ? this.camera.eye : viewCenter.plusScaled(viewZ, Constant.diameterOfEarth);\n        const centerToEye = earthCenter.unitVectorTo(eye);\n        if (!centerToEye)\n            return ViewStatus.DegenerateGeometry;\n        const axis = viewZ.unitCrossProduct(centerToEye);\n        if (!axis)\n            return ViewStatus.DegenerateGeometry;\n        const theta = viewZ.angleTo(centerToEye);\n        if (theta.radians > Angle.piOver2Radians)\n            return ViewStatus.DegenerateGeometry;\n        if (theta.isAlmostZero)\n            return ViewStatus.NoTransitionRequired;\n        const transitionRotation = Matrix3d.createRotationAroundVector(axis, transition ? theta.cloneScaled(globalTransition) : theta);\n        if (!transitionRotation)\n            return ViewStatus.DegenerateGeometry;\n        const transitionTransform = Transform.createFixedPointAndMatrix(target, transitionRotation);\n        const frustum = this.calculateFrustum();\n        if (!frustum)\n            return ViewStatus.DegenerateGeometry;\n        frustum.multiply(transitionTransform);\n        return this.setupFromFrustum(frustum);\n    }\n    /** See [[ViewState.attachToViewport]]. */\n    attachToViewport(args) {\n        super.attachToViewport(args);\n        const removeListener = this.displayStyle.settings.onEnvironmentChanged.addListener((env) => {\n            this._environmentDecorations?.setEnvironment(env);\n        });\n        this._environmentDecorations = new EnvironmentDecorations(this, () => args.invalidateDecorations(), () => removeListener());\n    }\n    /** See [[ViewState.detachFromViewport]]. */\n    detachFromViewport() {\n        super.detachFromViewport();\n        this._environmentDecorations = dispose(this._environmentDecorations);\n    }\n}\nViewState3d._minGlobeEyeHeight = Constant.earthRadiusWGS84.equator / 4; // View as globe if more than a quarter of earth radius from surface.\nViewState3d._scratchGlobeCarto = Cartographic.createZero();\nexport { ViewState3d };\n/** Defines the state of a view of a single 2d model.\n * @public\n * @extensions\n */\nexport class ViewState2d extends ViewState {\n    static get className() { return \"ViewDefinition2d\"; }\n    get baseModelId() { return this._baseModelId; }\n    /** @internal */\n    get _tileTreeRef() {\n        if (undefined === this._treeRef) {\n            const model = this.getViewedModel();\n            if (undefined !== model)\n                this._treeRef = model.createTileTreeReference(this);\n        }\n        return this._treeRef;\n    }\n    constructor(props, iModel, categories, displayStyle) {\n        super(props, iModel, categories, displayStyle);\n        this.origin = Point2d.fromJSON(props.origin);\n        this.delta = Point2d.fromJSON(props.delta);\n        this.angle = Angle.fromJSON(props.angle);\n        this._baseModelId = Id64.fromJSON(props.baseModelId);\n        this._details = new ViewDetails(this.jsonProperties);\n    }\n    toJSON() {\n        const val = super.toJSON();\n        val.origin = this.origin;\n        val.delta = this.delta;\n        val.angle = this.angle;\n        val.baseModelId = this.baseModelId;\n        return val;\n    }\n    /** See [[ViewState.is3d]]. */\n    is3d() { return false; }\n    /** @internal */\n    isSpatialView() { return false; }\n    /** Capture a copy of the viewed area. */\n    savePose() { return new ViewPose2d(this); }\n    /** See [[ViewState.applyPose]]. */\n    applyPose(val) {\n        if (val instanceof ViewPose2d) {\n            this.setOrigin(val.origin);\n            this.setExtents(val.delta);\n            this.angle.setFrom(val.angle);\n        }\n        return this;\n    }\n    /** Return the model for this 2d view. */\n    getViewedModel() {\n        const model = this.iModel.models.getLoaded(this.baseModelId);\n        if (model && !(model instanceof GeometricModel2dState))\n            return undefined;\n        return model;\n    }\n    /** Change the model viewed by this view.\n     * @note The new model should be of the same type (drawing or sheet) as the current viewed model.\n     * @throws Error if attempting to change the viewed model while the view is attached to a viewport.\n     * @see [[Viewport.changeViewedModel2d]].\n     * @public\n     */\n    async changeViewedModel(newViewedModelId) {\n        if (this.isAttachedToViewport)\n            throw new Error(\"Cannot change the viewed model of a view that is attached to a viewport.\");\n        this._baseModelId = newViewedModelId;\n        this._treeRef = undefined;\n        await this.load();\n    }\n    computeFitRange() {\n        return this.getViewedExtents();\n    }\n    /** @internal */\n    preload(hydrateRequest) {\n        super.preload(hydrateRequest);\n        if (this.iModel.models.getLoaded(this.baseModelId) === undefined)\n            hydrateRequest.baseModelId = this.baseModelId;\n    }\n    /** @internal */\n    async postload(hydrateResponse) {\n        const promises = [];\n        promises.push(super.postload(hydrateResponse));\n        if (hydrateResponse.baseModelProps !== undefined)\n            promises.push(this.iModel.models.updateLoadedWithModelProps([hydrateResponse.baseModelProps]));\n        await Promise.all(promises);\n    }\n    /** Provides access to optional detail settings for this view. */\n    get details() {\n        return this._details;\n    }\n    allow3dManipulations() { return false; }\n    getOrigin() { return new Point3d(this.origin.x, this.origin.y, Frustum2d.minimumZExtents.low); }\n    getExtents() { return new Vector3d(this.delta.x, this.delta.y, Frustum2d.minimumZExtents.length()); }\n    getRotation() { return Matrix3d.createRotationAroundVector(Vector3d.unitZ(), this.angle); }\n    setExtents(delta) { this.delta.set(delta.x, delta.y); }\n    setOrigin(origin) { this.origin.set(origin.x, origin.y); }\n    setRotation(rot) {\n        const xColumn = rot.getColumn(0);\n        this.angle.setRadians(Math.atan2(xColumn.y, xColumn.x));\n    }\n    viewsModel(modelId) { return this.baseModelId === modelId; }\n    forEachModel(func) {\n        const model = this.iModel.models.getLoaded(this.baseModelId);\n        if (undefined !== model && undefined !== model.asGeometricModel2d)\n            func(model);\n    }\n    /** @internal */\n    forEachModelTreeRef(func) {\n        const ref = this._tileTreeRef;\n        if (undefined !== ref)\n            func(ref);\n    }\n    createAuxCoordSystem(acsName) { return AuxCoordSystem2dState.createNew(acsName, this.iModel); }\n}\n//# sourceMappingURL=ViewState.js.map",
      "start": 1693508119595,
      "end": 1693508119818,
      "sourcemaps": null
    }
  ]
}
