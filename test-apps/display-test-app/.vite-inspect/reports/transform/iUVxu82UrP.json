{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/EnvironmentDecorations.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, Id64 } from \"@itwin/core-bentley\";\nimport { ColorDef, Gradient, GraphicParams, RenderTexture, SkyCube, SkySphere, TextureMapping, } from \"@itwin/core-common\";\nimport { Point2d, PolyfaceBuilder, StrokeOptions } from \"@itwin/core-geometry\";\nimport { tryImageElementFromUrl } from \"./common/ImageUtil\";\nimport { IModelApp } from \"./IModelApp\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\n/** @internal */\nexport class EnvironmentDecorations {\n    constructor(view, onLoaded, onDispose) {\n        this._environment = view.displayStyle.environment;\n        this._view = view;\n        this._onLoaded = onLoaded;\n        this._onDispose = onDispose;\n        this._sky = {};\n        this.loadSkyBox();\n        if (this._environment.displayGround)\n            this.loadGround();\n    }\n    dispose() {\n        this._ground = undefined;\n        this._sky.params = this._sky.promise = undefined;\n        this._onDispose();\n    }\n    setEnvironment(env) {\n        const prev = this._environment;\n        if (prev === env)\n            return;\n        this._environment = env;\n        // Update ground plane\n        if (!env.displayGround || env.ground !== prev.ground)\n            this._ground = undefined;\n        if (env.displayGround && !this._ground)\n            this.loadGround();\n        // Update sky box\n        if (env.sky !== prev.sky)\n            this.loadSkyBox();\n    }\n    decorate(context) {\n        const env = this._environment;\n        let sky;\n        if (env.displayAtmosphere) {\n            sky = IModelApp.renderSystem.createSkyBox(this.createSkyGradientParams());\n        }\n        else if (env.displaySky && this._sky.params) {\n            sky = IModelApp.renderSystem.createSkyBox(this._sky.params);\n        }\n        if (sky)\n            context.setSkyBox(sky);\n        if (!env.displayGround || !this._ground)\n            return;\n        const extents = this._view.getGroundExtents(context.viewport);\n        if (extents.isNull)\n            return;\n        const points = [extents.low.clone(), extents.low.clone(), extents.high.clone(), extents.high.clone()];\n        points[1].x = extents.high.x;\n        points[3].x = extents.low.x;\n        const aboveGround = this._view.isEyePointAbove(extents.low.z);\n        const params = aboveGround ? this._ground.aboveParams : this._ground.belowParams;\n        const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n        builder.activateGraphicParams(params);\n        const strokeOptions = new StrokeOptions();\n        strokeOptions.needParams = true;\n        const polyfaceBuilder = PolyfaceBuilder.create(strokeOptions);\n        polyfaceBuilder.toggleReversedFacetFlag();\n        const uvParams = [Point2d.create(0, 0), Point2d.create(1, 0), Point2d.create(1, 1), Point2d.create(0, 1)];\n        polyfaceBuilder.addQuadFacet(points, uvParams);\n        const polyface = polyfaceBuilder.claimPolyface(false);\n        builder.addPolyface(polyface, true);\n        context.addDecorationFromBuilder(builder);\n    }\n    loadGround() {\n        assert(undefined === this._ground);\n        const aboveParams = this.createGroundParams(true);\n        const belowParams = this.createGroundParams(false);\n        if (aboveParams && belowParams)\n            this._ground = { aboveParams, belowParams };\n    }\n    createGroundParams(above) {\n        // Create a gradient texture.\n        const ground = this._environment.ground;\n        const values = [0, 0.25, 0.5];\n        const color = above ? ground.aboveColor : ground.belowColor;\n        const alpha = above ? 0x80 : 0x85;\n        const groundColors = [color.withTransparency(0xff), color, color];\n        groundColors[1] = groundColors[2] = color.withTransparency(alpha);\n        const gradient = new Gradient.Symb();\n        gradient.mode = Gradient.Mode.Spherical;\n        gradient.keys = [{ color: groundColors[0], value: values[0] }, { color: groundColors[1], value: values[1] }, { color: groundColors[2], value: values[2] }];\n        const texture = IModelApp.renderSystem.getGradientTexture(gradient, this._view.iModel);\n        if (!texture)\n            return undefined;\n        // Create a material using the gradient texture\n        const material = IModelApp.renderSystem.createRenderMaterial({\n            diffuse: { color: ColorDef.white, weight: 0 },\n            textureMapping: {\n                texture,\n                transform: new TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0),\n            },\n        });\n        if (!material)\n            return undefined;\n        // Create GraphicParams using the material.\n        const params = new GraphicParams();\n        params.lineColor = gradient.keys[0].color;\n        params.fillColor = ColorDef.white; // Fill should be set to opaque white for gradient texture...\n        params.material = material;\n        return params;\n    }\n    loadSkyBox() {\n        const loader = this.loadSkyBoxParams();\n        if (undefined === loader.preload) {\n            this.setSky(loader.load());\n            return;\n        }\n        const promise = loader.preload;\n        this._sky.promise = promise;\n        loader.preload.then((loaded) => {\n            if (promise === this._sky.promise)\n                this.setSky(loaded ? loader.load() : undefined);\n        }).catch(() => {\n            if (promise === this._sky.promise)\n                this.setSky(undefined);\n        });\n    }\n    setSky(params) {\n        this._sky.promise = undefined;\n        this._sky.params = params ?? this.createSkyGradientParams();\n        this._onLoaded();\n    }\n    loadSkyBoxParams() {\n        let load;\n        let preload;\n        const sky = this._environment.sky;\n        if (sky instanceof SkyCube) {\n            const key = this.createCubeImageKey(sky);\n            load = () => {\n                const texture = IModelApp.renderSystem.findTexture(key, this._view.iModel);\n                return texture ? { type: \"cube\", texture } : undefined;\n            };\n            if (!IModelApp.renderSystem.findTexture(key, this._view.iModel)) {\n                // Some faces may use the same image. Only request each image once.\n                const promises = [];\n                const specs = new Set([sky.images.front, sky.images.back, sky.images.left, sky.images.right, sky.images.top, sky.images.bottom]);\n                for (const spec of specs)\n                    promises.push(this.imageFromSpec(spec));\n                preload = Promise.all(promises).then((images) => {\n                    const idToImage = new Map();\n                    let index = 0;\n                    for (const spec of specs) {\n                        const image = images[index++];\n                        if (!image)\n                            return false;\n                        else\n                            idToImage.set(spec, image);\n                    }\n                    // eslint-disable-next-line deprecation/deprecation\n                    const params = new RenderTexture.Params(key, RenderTexture.Type.SkyBox);\n                    const txImgs = [\n                        idToImage.get(sky.images.front), idToImage.get(sky.images.back), idToImage.get(sky.images.top),\n                        idToImage.get(sky.images.bottom), idToImage.get(sky.images.right), idToImage.get(sky.images.left),\n                    ];\n                    return undefined !== IModelApp.renderSystem.createTextureFromCubeImages(txImgs[0], txImgs[1], txImgs[2], txImgs[3], txImgs[4], txImgs[5], this._view.iModel, params);\n                });\n            }\n        }\n        else if (sky instanceof SkySphere) {\n            load = () => {\n                const texture = IModelApp.renderSystem.findTexture(sky.image, this._view.iModel);\n                return texture ? {\n                    type: \"sphere\",\n                    texture,\n                    rotation: 0,\n                    zOffset: this._view.iModel.globalOrigin.z,\n                } : undefined;\n            };\n            if (!IModelApp.renderSystem.findTexture(sky.image, this._view.iModel)) {\n                preload = this.imageFromSpec(sky.image).then((image) => {\n                    if (!image)\n                        return false;\n                    return undefined !== IModelApp.renderSystem.createTexture({\n                        image: { source: image },\n                        ownership: { iModel: this._view.iModel, key: sky.image },\n                    });\n                });\n            }\n        }\n        else {\n            load = () => this.createSkyGradientParams();\n        }\n        return { load, preload };\n    }\n    createCubeImageKey(sky) {\n        const i = sky.images;\n        return `skycube:${i.front}:${i.back}:${i.left}:${i.right}:${i.top}:${i.bottom}`;\n    }\n    createSkyGradientParams() {\n        return {\n            type: \"gradient\",\n            gradient: this._environment.sky.gradient,\n            zOffset: this._view.iModel.globalOrigin.z,\n        };\n    }\n    async imageFromSpec(spec) {\n        if (Id64.isValidId64(spec))\n            return (await IModelApp.renderSystem.loadTextureImage(spec, this._view.iModel))?.image;\n        return tryImageElementFromUrl(spec);\n    }\n}\n//# sourceMappingURL=EnvironmentDecorations.js.map",
      "start": 1693508119274,
      "end": 1693508119418,
      "sourcemaps": null
    }
  ]
}
