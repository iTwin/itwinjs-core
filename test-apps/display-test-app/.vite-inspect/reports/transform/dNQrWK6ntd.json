{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/clipping/internalContexts/LineStringOffsetClipperContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../../Geometry\";\nimport { UnionOfConvexClipPlaneSets } from \"../UnionOfConvexClipPlaneSets\";\nimport { ConvexClipPlaneSet } from \"../ConvexClipPlaneSet\";\nimport { ClipPlane } from \"../ClipPlane\";\n/**\n * Class for building clip sets for offset regions.\n * @internal\n */\nexport class LineStringOffsetClipperContext {\n    constructor(positiveOffsetLeft, positiveOffsetRight) {\n        this._positiveOffsetLeft = positiveOffsetLeft;\n        this._positiveOffsetRight = positiveOffsetRight;\n        this._turnDegrees = 60.0;\n    }\n    /**\n     * Create a unit vector from point i to point i+1.\n     * If closed, do point indexing with\n     *   * index less than 0 get final segment\n     *   * index at or beyond points.length-1 wraps to first segment\n     * @param points\n     * @param index0\n     * @param closed indicates that first and last points are identical and need wrap logic.\n     */\n    static createUnit(points, index0, closed, xyOnly = true) {\n        // pick two indices of active points, allowing for wrap if needed:\n        // normally use index0 and index0 + 1\n        // but apply wrap if appropriate, and shift ahead of needed.\n        let k0 = index0;\n        let k1 = index0 + 1;\n        const last = points.length - 1;\n        if (closed) {\n            if (index0 < 0) {\n                k0 = last - 1;\n                k1 = last;\n            }\n            else if (index0 >= last) {\n                k0 = 0;\n                k1 = 1;\n            }\n        }\n        else {\n            if (index0 === 0) {\n                k0 = 0;\n                k1 = 1;\n            }\n            else if (k1 > last) {\n                k0 = last - 1;\n                k1 = last;\n            }\n        }\n        const result = points.vectorIndexIndex(k0, k1);\n        if (result) {\n            if (xyOnly)\n                result.z = 0.0;\n            return result.normalize(result);\n        }\n        return undefined;\n    }\n    static createDirectedPlane(basePoint, vector, shift, normalScale, interior = false) {\n        return ClipPlane.createNormalAndPointXYZXYZ(vector.x * normalScale, vector.y * normalScale, vector.z * normalScale, basePoint.x + shift * vector.x, basePoint.y + shift * vector.y, basePoint.z + shift * vector.z, interior, interior);\n    }\n    /**\n     * Create (if needed) the chamfer cutback plane for a turn.\n     * @param clipSet set to receive the plane\n     * @param point central point\n     * @param unitA incoming vector\n     * @param unitB outgoing vector\n     */\n    createChamferCut(clipSet, point, unitA, unitB) {\n        const degreesA = unitA.angleToXY(unitB).degrees;\n        if (Math.abs(degreesA) > this._turnDegrees) {\n            const perpAB = unitA.interpolate(0.5, unitB);\n            perpAB.rotate90CCWXY(perpAB);\n            perpAB.normalizeInPlace();\n            if (degreesA > 0)\n                clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(point, perpAB, -this._positiveOffsetRight, 1.0, false));\n            else\n                clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(point, perpAB, this._positiveOffsetLeft, -1.0, false));\n        }\n    }\n    createOffsetFromSegment(pointA, pointB, unitA, unitB, unitC) {\n        if (unitB === undefined)\n            return undefined;\n        if (unitA === undefined)\n            unitA = unitB;\n        if (unitC === undefined)\n            unitC = unitB;\n        const unitAB = unitA.interpolate(0.5, unitB);\n        unitAB.normalizeInPlace();\n        const perpB = unitB.rotate90CCWXY();\n        const unitBC = unitB.interpolate(0.5, unitC);\n        unitBC.normalizeInPlace();\n        const clipSet = ConvexClipPlaneSet.createEmpty();\n        clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(pointA, perpB, this._positiveOffsetLeft, -1.0, false));\n        clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(pointA, perpB, -this._positiveOffsetRight, 1.0, false));\n        clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(pointA, unitAB, 0, 1.0, true));\n        clipSet.addPlaneToConvexSet(LineStringOffsetClipperContext.createDirectedPlane(pointB, unitBC, 0, -1.0, true));\n        this.createChamferCut(clipSet, pointA, unitA, unitB);\n        this.createChamferCut(clipSet, pointB, unitB, unitC);\n        /*\n        const degreesA = unitA.angleToXY(unitB).degrees;\n        if (Math.abs(degreesA) > this._turnDegrees) {\n          const perpAB = unitA.interpolate(0.5, unitB);\n          perpAB.rotate90CCWXY(perpAB);\n          perpAB.normalizeInPlace();\n          if (degreesA > 0)\n            clipSet.addPlaneToConvexSet(BuildingCodeRegionOffsetsOps.createDirectedPlane(pointA, perpAB, -this._positiveOffsetRight, 1.0));\n          else\n            clipSet.addPlaneToConvexSet(BuildingCodeRegionOffsetsOps.createDirectedPlane(pointA, perpAB, -this._positiveOffsetLeft, -1.0));\n        }\n        const degreesB = unitB.angleToXY(unitC).degrees;\n        if (Math.abs(degreesB) > this._turnDegrees) {\n          const perpBC = unitB.interpolate(0.5, unitC);\n          perpBC.rotate90CCWXY(perpBC);\n          perpBC.normalizeInPlace();\n          if (degreesB > 0)\n            clipSet.addPlaneToConvexSet(BuildingCodeRegionOffsetsOps.createDirectedPlane(pointB, perpBC, -this._positiveOffsetRight, 1.0));\n          else\n            clipSet.addPlaneToConvexSet(BuildingCodeRegionOffsetsOps.createDirectedPlane(pointB, perpBC, -this._positiveOffsetLeft, -1.0));\n        }\n        */\n        return clipSet;\n    }\n    /**\n     * @param points\n     * @param positiveOffsetLeft offset to left.  0 is clip on the path.\n     * @param positiveOffsetRight offset to the right.  0 is clip on the path.\n     * @param z0 z for lower clipping plane. If undefined, unbounded in positive z\n     * @param z1 z for upper clipping plane. If undefined, unbounded in negative z.\n     */\n    static createClipBetweenOffsets(points, positiveOffsetLeft, positiveOffsetRight, z0, z1) {\n        const context = new LineStringOffsetClipperContext(positiveOffsetLeft, positiveOffsetRight);\n        const result = UnionOfConvexClipPlaneSets.createEmpty();\n        if (points.length > 1) {\n            const closed = Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, points.length - 1));\n            for (let i = 0; i + 1 < points.length; i++) {\n                const unitVectorA = this.createUnit(points, i - 1, closed);\n                const unitVectorB = this.createUnit(points, i, closed);\n                const unitVectorC = this.createUnit(points, i + 1, closed);\n                const clipSet = context.createOffsetFromSegment(points.getPoint3dAtUncheckedPointIndex(i), points.getPoint3dAtUncheckedPointIndex(i + 1), unitVectorA, unitVectorB, unitVectorC);\n                clipSet?.addZClipPlanes(false, z0, z1);\n                if (clipSet)\n                    result.addConvexSet(clipSet);\n            }\n        }\n        else {\n            // make a singleton clipper with the z values.\n            const clipSet = ConvexClipPlaneSet.createEmpty();\n            clipSet?.addZClipPlanes(false, z0, z1);\n            if (clipSet.planes.length > 0)\n                result.addConvexSet(clipSet);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=LineStringOffsetClipperContext.js.map",
      "start": 1693508125187,
      "end": 1693508125357,
      "sourcemaps": null
    }
  ]
}
