{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/spatial/geom/Coordinate.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\n/**\n * Class Coordinate defines a 3D XYZ coordinate.\n */\n/** @internal */\nexport class Coordinate {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static create() {\n        return new Coordinate(0.0, 0.0, 0.0);\n    }\n    static fromXY(x, y) {\n        return new Coordinate(x, y, 0.0);\n    }\n    static fromXYZ(x, y, z) {\n        return new Coordinate(x, y, z);\n    }\n    getX() {\n        return this.x;\n    }\n    setX(x) {\n        this.x = x;\n    }\n    getY() {\n        return this.y;\n    }\n    setY(y) {\n        this.y = y;\n    }\n    getZ() {\n        return this.z;\n    }\n    setZ(z) {\n        this.z = z;\n    }\n    set(point) {\n        this.x = point.x;\n        this.y = point.y;\n        this.z = point.z;\n    }\n    setXYZ(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    clear() {\n        this.x = 0.0;\n        this.y = 0.0;\n        this.z = 0.0;\n    }\n    isZero() {\n        return (this.x == 0.0) && (this.y == 0.0) && (this.z == 0.0);\n    }\n    isNonZero() {\n        return (this.isZero() == false);\n    }\n    same(other) {\n        if (other.x != this.x)\n            return false;\n        if (other.y != this.y)\n            return false;\n        if (other.z != this.z)\n            return false;\n        return true;\n    }\n    same2D(other) {\n        if (other.x != this.x)\n            return false;\n        if (other.y != this.y)\n            return false;\n        return true;\n    }\n    distance3D(other) {\n        let dx = (other.x - this.x);\n        let dy = (other.y - this.y);\n        let dz = (other.z - this.z);\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    distance2D(other) {\n        let dx = (other.x - this.x);\n        let dy = (other.y - this.y);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    getLength() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    normalize0() {\n        let len = this.getLength();\n        if (len == 0.0)\n            return this;\n        return this.scale0(1.0 / len);\n    }\n    normalize() {\n        return this.copy().normalize0();\n    }\n    copy() {\n        return new Coordinate(this.x, this.y, this.z);\n    }\n    add0(point) {\n        this.x += point.x;\n        this.y += point.y;\n        this.z += point.z;\n        return this;\n    }\n    add(point) {\n        return this.copy().add0(point);\n    }\n    subtract0(point) {\n        this.x -= point.x;\n        this.y -= point.y;\n        this.z -= point.z;\n        return this;\n    }\n    subtract(point) {\n        return this.copy().subtract0(point);\n    }\n    scale0(f) {\n        this.x *= f;\n        this.y *= f;\n        this.z *= f;\n        return this;\n    }\n    scale(f) {\n        return this.copy().scale0(f);\n    }\n    crossProduct0(point) {\n        let cx = (this.y * point.z) - (this.z * point.y);\n        let cy = (this.z * point.x) - (this.x * point.z);\n        let cz = (this.x * point.y) - (this.y * point.x);\n        this.x = cx;\n        this.y = cy;\n        this.z = cz;\n        return this;\n    }\n    crossProduct(point) {\n        return this.copy().crossProduct0(point);\n    }\n    dotProduct(point) {\n        return (this.x * point.x) + (this.y * point.y) + (this.z * point.z);\n    }\n    toString() {\n        return \"(\" + this.x + \",\" + this.y + \",\" + this.z + \")\";\n    }\n    /**\n     * Get the angle between two directions.\n     * @param direction1 the first direction.\n     * @param direction2 the second direction.\n     * @return the angle between the directions, in radians from 0.0 to PI (never negative).\n     */\n    static getAngleRad(direction1, direction2) {\n        let length1 = direction1.getLength();\n        if (length1 == 0.0)\n            return 0.0;\n        let length2 = direction2.getLength();\n        if (length2 == 0.0)\n            return 0.0;\n        let cos = direction1.dotProduct(direction2) / length1 / length2;\n        if (cos >= 1.0)\n            return 0.0; // avoid rounding issues like acos(1.0000000000000002) = NaN\n        if (cos <= -1.0)\n            return Math.PI;\n        return Math.acos(cos);\n    }\n    /**\n     * Get the angle between two directions.\n     * @param direction1 the first direction.\n     * @param direction2 the second direction.\n     * @return the angle between the directions, in degrees from 0.0 to 180.0 (never negative).\n     */\n    static getAngleDeg(direction1, direction2) {\n        return Coordinate.getAngleRad(direction1, direction2) / Math.PI * 180.0;\n    }\n}\n//# sourceMappingURL=Coordinate.js.map",
      "start": 1693508126004,
      "end": 1693508126119,
      "sourcemaps": null
    }
  ]
}
