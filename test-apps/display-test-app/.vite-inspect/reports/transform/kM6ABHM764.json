{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/common/lib/esm/rpc/core/RpcRequest.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module RpcInterface\n */\nimport { BeEvent, BentleyStatus, Guid } from \"@itwin/core-bentley\";\nimport { BackendError, IModelError, NoContentError } from \"../../IModelError\";\nimport { RpcConfiguration } from \"./RpcConfiguration\";\nimport { RpcProtocolEvent, RpcRequestEvent, RpcRequestStatus } from \"./RpcConstants\";\nimport { RpcMarshaling } from \"./RpcMarshaling\";\nimport { RpcOperation } from \"./RpcOperation\";\nimport { RpcProtocol, RpcProtocolVersion } from \"./RpcProtocol\";\nimport { CURRENT_REQUEST } from \"./RpcRegistry\";\n/* eslint-disable @typescript-eslint/naming-convention */\n// cspell:ignore csrf\n/* eslint-disable deprecation/deprecation */\n/** @internal */\nexport const aggregateLoad = { lastRequest: 0, lastResponse: 0 };\n/** @internal */\nexport class ResponseLike {\n    get body() { return null; }\n    async arrayBuffer() { return this._data; }\n    async blob() { throw new IModelError(BentleyStatus.ERROR, \"Not implemented.\"); }\n    async formData() { throw new IModelError(BentleyStatus.ERROR, \"Not implemented.\"); }\n    async json() { return this._data; }\n    async text() { return this._data; }\n    get bodyUsed() { return false; }\n    get headers() { throw new IModelError(BentleyStatus.ERROR, \"Not implemented.\"); }\n    get ok() { return this.status >= 200 && this.status <= 299; }\n    get redirected() { return false; }\n    get status() { return 200; }\n    get statusText() { return \"\"; }\n    get trailer() { throw new IModelError(BentleyStatus.ERROR, \"Not implemented.\"); }\n    get type() { return \"basic\"; }\n    get url() { return \"\"; }\n    clone() { return { ...this }; }\n    constructor(data) {\n        this._data = Promise.resolve(data);\n    }\n}\nclass Cancellable {\n    cancel() { }\n    constructor(task) {\n        this.promise = new Promise((resolve, reject) => {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            this.cancel = () => resolve(undefined);\n            task.then(resolve, reject);\n        });\n    }\n}\n/** A RPC operation request.\n * @internal\n */\nclass RpcRequest {\n    /** All RPC requests that are currently in flight. */\n    static get activeRequests() { return this._activeRequests; }\n    /** The aggregate operations profile of all active RPC interfaces. */\n    static get aggregateLoad() { return aggregateLoad; }\n    /**\n     * The request for the current RPC operation.\n     * @note The return value of this function is only reliable if program control was received from a RPC interface class member function that directly returns the result of calling RpcInterface.forward.\n     */\n    static current(context) {\n        return context[CURRENT_REQUEST];\n    }\n    /** The status of this request. */\n    get status() { return this._status; }\n    /** Extended status information for this request (if available). */\n    get extendedStatus() { return this._extendedStatus; }\n    /** The last submission for this request. */\n    get lastSubmitted() { return this._lastSubmitted; }\n    /** The last status update received for this request. */\n    get lastUpdated() { return this._lastUpdated; }\n    /** Whether a connection is active for this request. */\n    get connecting() { return this._connecting; }\n    /** Whether this request is pending. */\n    get pending() {\n        switch (this.status) {\n            case RpcRequestStatus.Submitted:\n            case RpcRequestStatus.Pending: {\n                return true;\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    /** The elapsed time for this request. */\n    get elapsed() {\n        return this._lastUpdated - this._created;\n    }\n    /** An attempt-specific value for when to next retry this request. */\n    get retryAfter() { return this._retryAfter; }\n    /** Finds the first parameter of a given structural type if present. */\n    findParameterOfType(requiredProperties) {\n        for (const param of this.parameters) {\n            if (typeof (param) === \"object\" && param !== null) {\n                for (const prop of Object.getOwnPropertyNames(requiredProperties)) {\n                    if (param.hasOwnProperty(prop) && typeof (param[prop]) === requiredProperties[prop]) {\n                        return param;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    /** Finds the first IModelRpcProps parameter if present. */\n    findTokenPropsParameter() {\n        return this.findParameterOfType({ iModelId: \"string\" });\n    }\n    /** The raw implementation response for this request. */\n    get rawResponse() {\n        this._hasRawListener = true;\n        return this._rawPromise;\n    }\n    /** Constructs an RPC request. */\n    constructor(client, operation, parameters) {\n        this._resolve = () => undefined;\n        this._resolveRaw = () => undefined;\n        this._reject = () => undefined;\n        this._rejectRaw = () => undefined;\n        this._created = 0;\n        this._lastSubmitted = 0;\n        this._lastUpdated = 0;\n        /** @internal */\n        this._status = RpcRequestStatus.Unknown;\n        /** @internal */\n        this._extendedStatus = \"\";\n        this._connecting = false;\n        this._active = true;\n        this._hasRawListener = false;\n        this._raw = undefined;\n        this._attempts = 0;\n        this._retryAfter = null;\n        this._transientFaults = 0;\n        this._response = undefined;\n        this.responseProtocolVersion = RpcProtocolVersion.None;\n        this._created = new Date().getTime();\n        this.path = \"\";\n        this.method = \"\";\n        this.client = client;\n        this.protocol = client.configuration.protocol;\n        this.operation = RpcOperation.lookup(client.constructor, operation);\n        this.parameters = parameters;\n        this.retryInterval = this.operation.policy.retryInterval(client.configuration);\n        this.response = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._rawPromise = new Promise((resolve, reject) => {\n            this._resolveRaw = resolve;\n            this._rejectRaw = reject;\n        });\n        this.id = RpcConfiguration.requestContext.getId(this) || Guid.createValue();\n        this.setStatus(RpcRequestStatus.Created);\n        this.operation.policy.requestCallback(this);\n    }\n    /** Sets the last updated time for the request. */\n    setLastUpdatedTime() {\n        this._lastUpdated = new Date().getTime();\n    }\n    computeRetryAfter(attempts) {\n        return (((Math.pow(2, attempts) - 1) / 2) * 500) + 500;\n    }\n    recordTransientFault() {\n        ++this._transientFaults;\n    }\n    resetTransientFaultCount() {\n        this._transientFaults = 0;\n    }\n    supportsStatusCategory() {\n        if (!this.protocol.supportsStatusCategory) {\n            return false;\n        }\n        return RpcProtocol.protocolVersion >= RpcProtocolVersion.IntroducedStatusCategory && this.responseProtocolVersion >= RpcProtocolVersion.IntroducedStatusCategory;\n    }\n    /* @internal */\n    cancel() {\n        if (typeof (this._sending) === \"undefined\") {\n            return;\n        }\n        this._sending.cancel();\n        this._sending = undefined;\n        this._connecting = false;\n        RpcRequest._activeRequests.delete(this.id);\n        this.setStatus(RpcRequestStatus.Cancelled);\n    }\n    /* @internal */\n    async submit() {\n        if (!this._active)\n            return;\n        this._lastSubmitted = new Date().getTime();\n        this._retryAfter = null;\n        ++this._attempts;\n        if (this.status === RpcRequestStatus.Created || this.status === RpcRequestStatus.NotFound || this.status === RpcRequestStatus.Cancelled) {\n            this.setStatus(RpcRequestStatus.Submitted);\n        }\n        try {\n            this._connecting = true;\n            RpcRequest._activeRequests.set(this.id, this);\n            this.protocol.events.raiseEvent(RpcProtocolEvent.RequestCreated, this);\n            this._sending = new Cancellable(this.setHeaders().then(async () => this.send()));\n            this.operation.policy.sentCallback(this);\n            const response = await this._sending.promise;\n            if (typeof (response) === \"undefined\") {\n                return;\n            }\n            this._sending = undefined;\n            const status = this.protocol.getStatus(response);\n            if (this._hasRawListener && status === RpcRequestStatus.Resolved && typeof (this._response) !== \"undefined\") {\n                this._connecting = false;\n                RpcRequest._activeRequests.delete(this.id);\n                this.resolveRaw();\n            }\n            else {\n                this.protocol.events.raiseEvent(RpcProtocolEvent.ResponseLoading, this);\n                if (status === RpcRequestStatus.Unknown) {\n                    this._connecting = false;\n                    RpcRequest._activeRequests.delete(this.id);\n                    this.handleUnknownResponse(response);\n                    return;\n                }\n                const value = await this.load();\n                this.protocol.events.raiseEvent(RpcProtocolEvent.ResponseLoaded, this);\n                RpcRequest._activeRequests.delete(this.id);\n                this._connecting = false;\n                this.handleResponse(response, value);\n            }\n        }\n        catch (err) {\n            this.protocol.events.raiseEvent(RpcProtocolEvent.ConnectionErrorReceived, this, err);\n            RpcRequest._activeRequests.delete(this.id);\n            this._connecting = false;\n            this.reject(err);\n        }\n    }\n    handleUnknownResponse(code) {\n        this.reject(new IModelError(BentleyStatus.ERROR, `Unknown response ${code}.`));\n    }\n    handleResponse(code, value) {\n        const protocolStatus = this.protocol.getStatus(code);\n        const status = this.transformResponseStatus(protocolStatus, value);\n        if (RpcRequestStatus.isTransientError(status)) {\n            return this.handleTransientError(status);\n        }\n        switch (status) {\n            case RpcRequestStatus.Resolved: {\n                return this.handleResolved(value);\n            }\n            case RpcRequestStatus.Rejected: {\n                return this.handleRejected(value);\n            }\n            case RpcRequestStatus.Pending: {\n                return this.setPending(status, value.objects);\n            }\n            case RpcRequestStatus.NotFound: {\n                return this.handleNotFound(status, value);\n            }\n            case RpcRequestStatus.NoContent: {\n                return this.handleNoContent();\n            }\n        }\n    }\n    transformResponseStatus(protocolStatus, value) {\n        if (!this.supportsStatusCategory()) {\n            return protocolStatus;\n        }\n        let status = protocolStatus;\n        if (protocolStatus === RpcRequestStatus.Pending) {\n            status = RpcRequestStatus.Rejected;\n        }\n        else if (protocolStatus === RpcRequestStatus.NotFound) {\n            status = RpcRequestStatus.Rejected;\n        }\n        else if (protocolStatus === RpcRequestStatus.Unknown) {\n            status = RpcRequestStatus.Rejected;\n        }\n        if (value.objects.indexOf(\"iTwinRpcCoreResponse\") !== -1 && value.objects.indexOf(\"managedStatus\") !== -1) {\n            const managedStatus = JSON.parse(value.objects);\n            value.objects = managedStatus.responseValue;\n            if (managedStatus.managedStatus === \"pending\") {\n                status = RpcRequestStatus.Pending;\n            }\n            else if (managedStatus.managedStatus === \"notFound\") {\n                status = RpcRequestStatus.NotFound;\n            }\n        }\n        return status;\n    }\n    handleResolved(value) {\n        try {\n            this._raw = value.objects;\n            const result = RpcMarshaling.deserialize(this.protocol, value);\n            if (ArrayBuffer.isView(result)) {\n                this._raw = result.buffer;\n            }\n            return this.resolve(result);\n        }\n        catch (err) {\n            return this.reject(err);\n        }\n    }\n    handleRejected(value) {\n        this.protocol.events.raiseEvent(RpcProtocolEvent.BackendErrorReceived, this);\n        try {\n            const error = RpcMarshaling.deserialize(this.protocol, value);\n            const hasInfo = error && typeof (error) === \"object\" && error.hasOwnProperty(\"name\") && error.hasOwnProperty(\"message\");\n            const name = hasInfo ? error.name : \"\";\n            const message = hasInfo ? error.message : \"\";\n            const errorNumber = (hasInfo && error.hasOwnProperty(\"errorNumber\")) ? error.errorNumber : BentleyStatus.ERROR;\n            return this.reject(new BackendError(errorNumber, name, message, () => error));\n        }\n        catch (err) {\n            return this.reject(err);\n        }\n    }\n    handleNoContent() {\n        return this.reject(new NoContentError());\n    }\n    handleNotFound(status, value) {\n        const response = RpcMarshaling.deserialize(this.protocol, value);\n        this.setStatus(status);\n        let resubmitted = false;\n        RpcRequest.notFoundHandlers.raiseEvent(this, response, () => {\n            if (resubmitted)\n                throw new IModelError(BentleyStatus.ERROR, `Already resubmitted using this handler.`);\n            resubmitted = true;\n            this.submit(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }, (reason) => this.reject(reason));\n        return;\n    }\n    resolve(result) {\n        if (!this._active)\n            return;\n        this._active = false;\n        this.setLastUpdatedTime();\n        this._resolve(result);\n        if (this._hasRawListener) {\n            if (typeof (this._raw) === \"undefined\") {\n                throw new IModelError(BentleyStatus.ERROR, \"Cannot access raw response.\");\n            }\n            this._resolveRaw(new ResponseLike(this._raw));\n        }\n        this.setStatus(RpcRequestStatus.Resolved);\n        this.dispose();\n    }\n    resolveRaw() {\n        if (typeof (this._response) === \"undefined\") {\n            throw new IModelError(BentleyStatus.ERROR, \"Cannot access raw response.\");\n        }\n        this._active = false;\n        this.setLastUpdatedTime();\n        this._resolveRaw(this._response);\n        this.setStatus(RpcRequestStatus.Resolved);\n        this.dispose();\n    }\n    reject(reason) {\n        if (!this._active)\n            return;\n        this._active = false;\n        this.setLastUpdatedTime();\n        this._reject(reason);\n        if (this._hasRawListener) {\n            this._rejectRaw(reason);\n        }\n        this.setStatus(RpcRequestStatus.Rejected);\n        this.dispose();\n    }\n    /** @internal */\n    dispose() {\n        this.setStatus(RpcRequestStatus.Disposed);\n        this._raw = undefined;\n        this._response = undefined;\n        const client = this.client;\n        if (client[CURRENT_REQUEST] === this) {\n            client[CURRENT_REQUEST] = undefined;\n        }\n    }\n    setPending(status, extendedStatus) {\n        if (!this._active)\n            return;\n        this.setLastUpdatedTime();\n        this._extendedStatus = extendedStatus;\n        this.setStatus(status);\n        RpcRequest.events.raiseEvent(RpcRequestEvent.PendingUpdateReceived, this);\n    }\n    handleTransientError(status) {\n        if (!this._active)\n            return;\n        this.setLastUpdatedTime();\n        this._retryAfter = this.computeRetryAfter(this._attempts - 1);\n        if (this._transientFaults > this.protocol.configuration.transientFaultLimit) {\n            this.reject(new IModelError(BentleyStatus.ERROR, `Exceeded transient fault limit.`));\n        }\n        else {\n            this.setStatus(status);\n            RpcRequest.events.raiseEvent(RpcRequestEvent.TransientErrorReceived, this);\n        }\n    }\n    async setHeaders() {\n        const versionHeader = this.protocol.protocolVersionHeaderName;\n        if (versionHeader && RpcProtocol.protocolVersion)\n            this.setHeader(versionHeader, RpcProtocol.protocolVersion.toString());\n        const headerNames = this.protocol.serializedClientRequestContextHeaderNames;\n        const headerValues = await RpcConfiguration.requestContext.serialize(this);\n        if (headerNames.id)\n            this.setHeader(headerNames.id, headerValues.id || this.id); // Cannot be empty\n        if (headerNames.applicationVersion)\n            this.setHeader(headerNames.applicationVersion, headerValues.applicationVersion);\n        if (headerNames.applicationId)\n            this.setHeader(headerNames.applicationId, headerValues.applicationId);\n        if (headerNames.sessionId)\n            this.setHeader(headerNames.sessionId, headerValues.sessionId);\n        if (headerNames.authorization && headerValues.authorization)\n            this.setHeader(headerNames.authorization, headerValues.authorization);\n        if (headerValues.csrfToken)\n            this.setHeader(headerValues.csrfToken.headerName, headerValues.csrfToken.headerValue);\n    }\n    setStatus(status) {\n        if (this._status === status)\n            return;\n        this._status = status;\n        RpcRequest.events.raiseEvent(RpcRequestEvent.StatusChanged, this);\n    }\n}\nRpcRequest._activeRequests = new Map();\n/** Events raised by RpcRequest. See [[RpcRequestEvent]] */\nRpcRequest.events = new BeEvent();\n/** Resolvers for \"not found\" requests. See [[RpcRequestNotFoundHandler]] */\nRpcRequest.notFoundHandlers = new BeEvent();\nexport { RpcRequest };\n/** @internal */\nexport const initializeRpcRequest = (() => {\n    let initialized = false;\n    return () => {\n        if (initialized) {\n            return;\n        }\n        initialized = true;\n        RpcRequest.events.addListener((type, request) => {\n            if (type !== RpcRequestEvent.StatusChanged)\n                return;\n            switch (request.status) {\n                case RpcRequestStatus.Submitted: {\n                    aggregateLoad.lastRequest = request.lastSubmitted;\n                    break;\n                }\n                case RpcRequestStatus.Pending:\n                case RpcRequestStatus.Resolved:\n                case RpcRequestStatus.Rejected: {\n                    aggregateLoad.lastResponse = request.lastUpdated;\n                    break;\n                }\n            }\n        });\n        RpcProtocol.events.addListener((type) => {\n            const now = new Date().getTime();\n            switch (type) {\n                case RpcProtocolEvent.RequestReceived: {\n                    aggregateLoad.lastRequest = now;\n                    break;\n                }\n                case RpcProtocolEvent.BackendReportedPending:\n                case RpcProtocolEvent.BackendErrorOccurred:\n                case RpcProtocolEvent.BackendResponseCreated: {\n                    aggregateLoad.lastResponse = now;\n                    break;\n                }\n            }\n        });\n    };\n})();\n//# sourceMappingURL=RpcRequest.js.map",
      "start": 1693508121030,
      "end": 1693508121090,
      "sourcemaps": null
    }
  ]
}
