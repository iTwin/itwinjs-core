{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/markup/lib/esm/SvgJsExt.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module MarkupApp\n */\nimport { Transform } from \"@itwin/core-geometry\";\nimport { Box, extend, G, Element as MarkupElement, Matrix, nodeOrNew, Rect, register, Text } from \"@svgdotjs/svg.js\";\nimport { MarkupApp } from \"./Markup\";\nconst OLDCOLOR = \"Color\";\n/** this is the SVG.js way of adding methods to classes */\nextend(MarkupElement, {\n    forElementsOfGroup(fn) {\n        const me = this;\n        if (me instanceof G)\n            me.each((i, children) => { const child = children[i]; if (child instanceof MarkupElement)\n                fn(child); }, false);\n    },\n    cloneMarkup() {\n        const me = this;\n        const cloned = me.clone();\n        cloned.node.removeAttribute(\"id\");\n        cloned.resetColor();\n        return cloned;\n    },\n    overrideColor(color) {\n        const me = this;\n        me.forElementsOfGroup((child) => child.overrideColor(color)); // Do children first, getComputedStyle will inherit from group for unspecified values...\n        let oldColor = me.data(OLDCOLOR);\n        if (undefined === oldColor) {\n            const css = window.getComputedStyle(me.node);\n            const colorOrNone = (c) => (c && c !== \"none\") ? c : \"none\";\n            oldColor = { fill: colorOrNone(css.fill), stroke: colorOrNone(css.stroke) };\n            me.data(OLDCOLOR, oldColor);\n        }\n        const toColor = (val) => (!val || val === \"none\") ? \"none\" : color;\n        me.css({ fill: toColor(oldColor.fill), stroke: toColor(oldColor.stroke) });\n    },\n    resetColor() {\n        const me = this;\n        const oldColor = me.data(OLDCOLOR);\n        if (undefined !== oldColor)\n            me.css(oldColor).data(OLDCOLOR, null); // change to old color and remove data object\n        me.forElementsOfGroup((child) => child.resetColor());\n    },\n    hilite() { const me = this; if (!me.inSelection) {\n        me.overrideColor(MarkupApp.props.hilite.color);\n        me.inSelection = true;\n    } },\n    unHilite() { const me = this; if (me.inSelection) {\n        me.resetColor();\n        me.inSelection = undefined;\n    } },\n    flash() { const me = this; if (!me.inSelection)\n        me.overrideColor(MarkupApp.props.hilite.flash); },\n    unFlash() { const me = this; if (!me.inSelection)\n        me.resetColor(); },\n    markupStretch(w, h, x, y, _mtx) { const me = this; me.size(w, h).move(x, y); },\n    isChildOf(svg) {\n        const parent = this.parent();\n        return (parent === svg) ? true : (parent instanceof MarkupElement) ? parent.isChildOf(svg) : false;\n    },\n    getChildOrGroupOf(svg) {\n        const me = this;\n        const parents = me.parents(svg.parent());\n        if (0 === parents.length || parents[parents.length - 1].node !== svg.node)\n            return undefined;\n        if (parents.length > 1) {\n            for (let index = parents.length - 2; index >= 0; --index)\n                if (parents[index] instanceof G || parents[index] instanceof Text)\n                    return parents[index];\n        }\n        return me;\n    },\n    getNpcToVp() {\n        const me = this;\n        const bb = me.bbox();\n        return new Matrix().scaleO(bb.w, bb.h).translateO(bb.x, bb.y).lmultiplyO(me.matrixify());\n    },\n    getOutline(expand) {\n        const me = this;\n        const box = me.bbox();\n        if (expand === undefined)\n            expand = 0;\n        return new Rect().move(box.x - expand, box.y - expand).size(box.w + (expand * 2), box.h + (expand * 2)).transform(me.matrixify());\n    },\n});\nextend(G, {\n    markupStretch(_w, _h, _x, _y, mtx) { this.attr(\"transform\", mtx); },\n});\nextend(Text, {\n    getFontSize() { const me = this; return parseFloat(window.getComputedStyle(me.node).fontSize); },\n    markupStretch(_w, _h, _x, _y, mtx) { this.attr(\"transform\", mtx); },\n    getMarkup() {\n        const node = this.node;\n        let text = \"\";\n        node.childNodes.forEach((child) => {\n            if (child.nodeName === \"tspan\" || child.nodeName === \"#text\") {\n                if (text.length !== 0)\n                    text += \"\\n\";\n                text += child.textContent;\n            }\n        });\n        return text;\n    },\n    createMarkup(val, spacing) {\n        spacing = spacing ? spacing : 1;\n        const me = this;\n        me.clear();\n        if (val === \"\")\n            return;\n        const lines = val.split(\"\\n\");\n        me.plain(lines[0]);\n        const x = me.attr(\"x\");\n        me.build(true);\n        for (let i = 1; i < lines.length; ++i) {\n            const tspan = me.tspan(lines[i]);\n            tspan.dy(spacing);\n            tspan.x(x);\n        }\n        me.build(false);\n        me.dom = {};\n    },\n    // override for Text so that empty text will return a size\n    getOutline(expand) {\n        const me = this;\n        const node = me.node;\n        const content = node.textContent;\n        if (content !== null && content.length > 0)\n            return MarkupElement.prototype.getOutline.call(me, expand);\n        node.textContent = \"M\";\n        const outline = MarkupElement.prototype.getOutline.call(me, expand);\n        node.textContent = content;\n        return outline;\n    },\n    writeDataToDom() {\n        const me = this;\n        const dom = me.dom; // strip off useless \"leading\" data\n        me.dom = {};\n        MarkupElement.prototype.writeDataToDom.call(me);\n        me.dom = dom;\n        return me;\n    },\n});\nextend(Matrix, {\n    toIModelTransform() {\n        const m = this;\n        return Transform.createRowValues(m.a, m.c, 0, m.e, m.b, m.d, 0, m.f, 0, 0, 1, 0);\n    },\n    fromIModelTransform(t) {\n        const m = this;\n        const o = t.origin;\n        const mtx = t.matrix;\n        m.a = mtx.coffs[0];\n        m.b = mtx.coffs[3];\n        m.c = mtx.coffs[1];\n        m.d = mtx.coffs[4];\n        m.e = o.x;\n        m.f = o.y;\n        return this;\n    },\n});\n/** Dummy class so a <title> inside a <g> will work.\n * @internal\n */\nexport class Title extends MarkupElement {\n    constructor(node) { super(nodeOrNew(\"title\", node)); }\n    scale() { return this; }\n    size() { return this; }\n    move() { return this; }\n    dmove() { return this; }\n    bbox() { return new Box(); }\n    screenCTM() { return new Matrix(); }\n}\nregister(Title, \"Title\");\n/** only for tests\n *  @internal\n */\nexport function initSvgExt() { }\n//# sourceMappingURL=SvgJsExt.js.map",
      "start": 1693508125584,
      "end": 1693508125765,
      "sourcemaps": null
    }
  ]
}
