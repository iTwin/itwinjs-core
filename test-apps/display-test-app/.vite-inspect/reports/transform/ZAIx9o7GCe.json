{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/glsl/Polyline.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { AttributeMap } from \"../AttributeMap\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { ProgramBuilder, } from \"../ShaderBuilder\";\nimport { System } from \"../System\";\nimport { addColor } from \"./Color\";\nimport { addEdgeContrast } from \"./Edge\";\nimport { addFrustum, addShaderFlags } from \"./Common\";\nimport { unquantize2d } from \"./Decode\";\nimport { addHiliter } from \"./FeatureSymbology\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { addLineCode as addLineCodeUniform, addLineWeight, addModelViewMatrix, addProjectionMatrix, addSamplePosition, } from \"./Vertex\";\nimport { addModelToWindowCoordinates, addViewport } from \"./Viewport\";\nconst checkForDiscard = \"return discardByLineCode;\";\nconst applyLineCode = `\r\n  if (v_texc.x >= 0.0) { // v_texc = (-1,-1) for solid lines - don't bother with any of this\r\n    vec4 texColor = TEXTURE(u_lineCodeTexture, v_texc);\r\n    discardByLineCode = (0.0 == texColor.r);\r\n  }\r\n\r\n  if (v_lnInfo.w > 0.5) { // line needs pixel trimming\r\n    // calculate pixel distance from pixel center to expected line center, opposite dir from major\r\n    vec2 dxy = gl_FragCoord.xy - v_lnInfo.xy;\r\n    if (v_lnInfo.w < 1.5)  // not x-major\r\n      dxy = dxy.yx;\r\n\r\n    float dist = v_lnInfo.z * dxy.x - dxy.y;\r\n    float distA = abs(dist);\r\n    if (distA > 0.5 || (distA == 0.5 && dist < 0.0))\r\n      discardByLineCode = true;  // borrow this flag to force discard\r\n  }\r\n\r\n  return baseColor;\r\n`;\nconst computeTextureCoord = `\r\nvec2 computeLineCodeTextureCoords(vec2 windowDir, vec4 projPos, float adjust) {\r\n  vec2 texc;\r\n  float lineCode = computeLineCode();\r\n  if (0.0 == lineCode) {\r\n    // Solid line - tell frag shader not to bother.\r\n    texc = vec2(-1.0, -1.0);\r\n  } else {\r\n    const float imagesPerPixel = 1.0/32.0;\r\n    const float textureCoordinateBase = 8192.0; // Temp workardound for clipping problem in perspective views (negative values don't seem to interpolate correctly).\r\n\r\n    if (abs(windowDir.x) > abs(windowDir.y))\r\n      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.x + adjust * windowDir.x);\r\n    else\r\n      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.y + adjust * windowDir.y);\r\n\r\n    const float numLineCodes = 16.0; // NB: Actually only 10, but texture is 16px tall because it needs to be a power of 2.\r\n    const float rowsPerCode = 1.0;\r\n    const float numRows = numLineCodes*rowsPerCode;\r\n    const float centerY = 0.5/numRows;\r\n    const float stepY = rowsPerCode/numRows;\r\n    texc.y = stepY * lineCode + centerY;\r\n  }\r\n\r\n  return texc;\r\n}\r\n`;\n/** @internal */\nexport const adjustWidth = `\r\nvoid adjustWidth(inout float width, vec2 d2, vec2 org) {\r\n  if (u_aaSamples > 1) {\r\n    if (width < 5.0)\r\n      width += (5.0 - width) * 0.125;\r\n    return;\r\n  }\r\n\r\n  // calculate slope based width adjustment for non-AA lines, widths 1 to 4\r\n  vec2 d2A = abs(d2);\r\n  const float s_myFltEpsilon = 0.0001;  // limit test resolution to 4 digits in case 24 bit (s16e7) is used in hardware\r\n  if (d2A.y > s_myFltEpsilon && width < 4.5) {\r\n    float len = length(d2A);\r\n    float tan = d2A.x / d2A.y;\r\n\r\n    if (width < 1.5) { // width 1\r\n      if (tan <= 1.0)\r\n        width = d2A.y;\r\n      else\r\n        width = d2A.x;\r\n      // width 1 requires additional adjustment plus trimming in frag shader using v_lnInfo\r\n      width *= 1.01;\r\n      v_lnInfo.xy = org;\r\n      v_lnInfo.w = 1.0; // set flag to do trimming\r\n      // set slope in v_lnInfo.z\r\n      if (d2A.x - d2A.y > s_myFltEpsilon) {\r\n        v_lnInfo.z = d2.y / d2.x;\r\n        v_lnInfo.w += 2.0; // add in x-major flag\r\n      } else\r\n        v_lnInfo.z = d2.x / d2.y;\r\n\r\n    } else if (width < 2.5) { // width 2\r\n      if (tan <= 0.5)\r\n        width = 2.0 * d2A.y;\r\n      else\r\n        width = (d2A.y + 2.0 * d2A.x);\r\n\r\n    } else if (width < 3.5) { // width 3\r\n        if (tan <= 1.0)\r\n            width = (3.0 * d2A.y + d2A.x);\r\n        else\r\n            width = (d2A.y + 3.0 * d2A.x);\r\n\r\n    } else { // if (width < 4.5) // width 4\r\n      if (tan <= 0.5)\r\n        width = (4.0 * d2A.y + d2A.x);\r\n      else if (tan <= 2.0)\r\n        width = (3.0 * d2A.y + 3.0 * d2A.x);\r\n      else\r\n        width = (d2A.y + 4.0 * d2A.x);\r\n    }\r\n    width /= len;\r\n  }\r\n}\r\n`;\n/** @internal */\nexport function addAdjustWidth(vert) {\n    vert.addUniform(\"u_aaSamples\", 1 /* VariableType.Int */, (prog) => {\n        prog.addGraphicUniform(\"u_aaSamples\", (attr, params) => {\n            const numSamples = System.instance.frameBufferStack.currentFbMultisampled ? params.target.compositor.antialiasSamples : 1;\n            attr.setUniform1i(numSamples);\n        });\n    });\n    vert.addFunction(adjustWidth);\n}\n/** @internal */\nexport function addLineCodeTexture(frag) {\n    frag.addUniform(\"u_lineCodeTexture\", 8 /* VariableType.Sampler2D */, (prog) => {\n        prog.addProgramUniform(\"u_lineCodeTexture\", (uniform) => {\n            const lct = System.instance.lineCodeTexture;\n            assert(undefined !== lct);\n            if (undefined !== lct)\n                lct.bindSampler(uniform, TextureUnit.LineCode);\n        });\n    });\n}\n/** @internal */\nexport function addLineCode(prog, args) {\n    const vert = prog.vert;\n    const frag = prog.frag;\n    addLineCodeUniform(vert);\n    const funcCall = `computeLineCodeTextureCoords(${args})`;\n    prog.addFunctionComputedVaryingWithArgs(\"v_texc\", 3 /* VariableType.Vec2 */, funcCall, computeTextureCoord);\n    addFrustum(prog);\n    addLineCodeTexture(prog.frag);\n    frag.set(3 /* FragmentShaderComponent.FinalizeBaseColor */, applyLineCode);\n    frag.set(4 /* FragmentShaderComponent.CheckForDiscard */, checkForDiscard);\n    frag.addGlobal(\"discardByLineCode\", 0 /* VariableType.Boolean */, \"false\");\n}\nfunction polylineAddLineCode(prog) {\n    addLineCode(prog, lineCodeArgs);\n    addModelViewMatrix(prog.vert);\n}\nfunction addCommon(prog) {\n    const vert = prog.vert;\n    addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation\n    addProjectionMatrix(vert);\n    addModelViewMatrix(vert);\n    addViewport(vert);\n    vert.addGlobal(\"g_windowPos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"g_prevPos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"g_nextPos\", 5 /* VariableType.Vec4 */);\n    vert.addGlobal(\"g_windowDir\", 3 /* VariableType.Vec2 */);\n    vert.addInitializer(decodeAdjacentPositions);\n    vert.addFunction(unquantize2d);\n    addLineWeight(vert);\n    vert.addGlobal(\"miterAdjust\", 2 /* VariableType.Float */, \"0.0\");\n    prog.addVarying(\"v_eyeSpace\", 4 /* VariableType.Vec3 */);\n    vert.set(10 /* VertexShaderComponent.ComputePosition */, computePosition);\n    prog.addVarying(\"v_lnInfo\", 5 /* VariableType.Vec4 */);\n    addAdjustWidth(vert);\n    addSamplePosition(vert);\n    vert.addFunction(decodePosition);\n}\nconst decodePosition = `\r\nvec4 decodePosition(vec3 baseIndex) {\r\n  float index = decodeUInt24(baseIndex);\r\n  return samplePosition(index);\r\n}\r\n`;\nconst decodeAdjacentPositions = `\r\n  g_prevPos = decodePosition(a_prevIndex);\r\n  g_nextPos = decodePosition(a_nextIndex);\r\n`;\nconst computePosition = `\r\n  const float kNone = 0.0,\r\n              kSquare = 1.0*3.0,\r\n              kMiter = 2.0*3.0,\r\n              kMiterInsideOnly = 3.0*3.0,\r\n              kJointBase = 4.0*3.0,\r\n              kNegatePerp = 8.0*3.0,\r\n              kNegateAlong = 16.0*3.0,\r\n              kNoneAdjWt = 32.0*3.0;\r\n\r\n  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false\r\n\r\n  vec4 next = g_nextPos;\r\n  vec4 pos;\r\n  g_windowPos = modelToWindowCoordinates(rawPos, next, pos, v_eyeSpace);\r\n  if (g_windowPos.w == 0.0)\r\n    return g_windowPos;\r\n\r\n  float param = a_param;\r\n  float weight = computeLineWeight();\r\n  float scale = 1.0, directionScale = 1.0;\r\n\r\n  if (param >= kNoneAdjWt)\r\n    param -= kNoneAdjWt;\r\n\r\n  if (param >= kNegateAlong) {\r\n    directionScale = -directionScale;\r\n    param -= kNegateAlong;\r\n  }\r\n\r\n  if (param >= kNegatePerp) {\r\n    scale = -1.0;\r\n    param -= kNegatePerp;\r\n  }\r\n\r\n  vec4 otherPos;\r\n  vec3 otherMvPos;\r\n  vec4 projNext = modelToWindowCoordinates(next, rawPos, otherPos, otherMvPos);\r\n  g_windowDir = projNext.xy - g_windowPos.xy;\r\n\r\n  if (param < kJointBase) {\r\n    vec2 dir = (directionScale > 0.0) ? g_windowDir : -g_windowDir;\r\n    vec2 pos = (directionScale > 0.0) ? g_windowPos.xy : projNext.xy;\r\n    adjustWidth(weight, dir, pos);\r\n  }\r\n\r\n  if (kNone != param) {\r\n    vec2 delta = vec2(0.0);\r\n    vec4 prev   = g_prevPos;\r\n    vec4 projPrev = modelToWindowCoordinates(prev, rawPos, otherPos, otherMvPos);\r\n    vec2 prevDir   = g_windowPos.xy - projPrev.xy;\r\n    float thisLength = sqrt(g_windowDir.x * g_windowDir.x + g_windowDir.y * g_windowDir.y);\r\n    const float s_minNormalizeLength = 1.0E-5;  // avoid normalizing zero length vectors.\r\n    float dist = weight / 2.0;\r\n\r\n    if (thisLength > s_minNormalizeLength) {\r\n      g_windowDir /= thisLength;\r\n\r\n      float prevLength = sqrt(prevDir.x * prevDir.x + prevDir.y * prevDir.y);\r\n\r\n      if (prevLength > s_minNormalizeLength) {\r\n        prevDir /= prevLength;\r\n        const float     s_minParallelDot= -.9999, s_maxParallelDot = .9999;\r\n        float           prevNextDot  = dot(prevDir, g_windowDir);\r\n\r\n        if (prevNextDot < s_minParallelDot || prevNextDot > s_maxParallelDot)    // No miter if parallel or antiparallel.\r\n          param = kSquare;\r\n      } else\r\n        param = kSquare;\r\n    } else {\r\n      g_windowDir = -normalize(prevDir);\r\n      param = kSquare;\r\n    }\r\n\r\n    vec2 perp = scale * vec2(-g_windowDir.y, g_windowDir.x);\r\n\r\n    if (param == kSquare) {\r\n      delta = perp;\r\n    } else {\r\n      vec2 bisector = normalize(prevDir - g_windowDir);\r\n      float dotP = dot (bisector, perp);\r\n\r\n      if (dotP != 0.0) { // Should never occur - but avoid divide by zero.\r\n        const float maxMiter = 3.0;\r\n        float miterDistance = 1.0/dotP;\r\n\r\n        if (param == kMiter) { // Straight miter.\r\n          delta = (abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;\r\n\r\n        } else if (param == kMiterInsideOnly) { // Miter at inside, square at outside (to make room for joint).\r\n          delta = (dotP  > 0.0 || abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;\r\n\r\n        } else {\r\n          const float jointTriangleCount = 3.0;\r\n          float ratio = (param - kJointBase) / jointTriangleCount; // 3 triangles per half-joint as defined in Graphics.cpp\r\n          delta = normalize((1.0 - ratio) * bisector + (dotP < 0.0 ? -ratio : ratio) * perp); // Miter/Straight combination.\r\n        }\r\n      }\r\n    }\r\n\r\n    miterAdjust = dot(g_windowDir, delta) * dist; // Not actually used for hilite shader but meh.\r\n    pos.x += dist * delta.x * 2.0 * pos.w / u_viewport.x;\r\n    pos.y += dist * delta.y * 2.0 * pos.w / u_viewport.y;\r\n  }\r\n\r\n  return pos;\r\n`;\nconst lineCodeArgs = \"g_windowDir, g_windowPos, miterAdjust\";\n/** @internal */\nexport function createPolylineBuilder(isInstanced, positionType) {\n    const instanced = 1 /* IsInstanced.Yes */ === isInstanced;\n    const attrMap = AttributeMap.findAttributeMap(1 /* TechniqueId.Polyline */, instanced);\n    const builder = new ProgramBuilder(attrMap, { positionType, instanced });\n    addShaderFlags(builder);\n    addCommon(builder);\n    polylineAddLineCode(builder);\n    addColor(builder);\n    addEdgeContrast(builder.vert);\n    addWhiteOnWhiteReversal(builder.frag);\n    return builder;\n}\n/** @internal */\nexport function createPolylineHiliter(isInstanced, positionType) {\n    const instanced = 1 /* IsInstanced.Yes */ === isInstanced;\n    const attrMap = AttributeMap.findAttributeMap(1 /* TechniqueId.Polyline */, instanced);\n    const builder = new ProgramBuilder(attrMap, { positionType, instanced });\n    addCommon(builder);\n    addFrustum(builder);\n    addHiliter(builder, true);\n    return builder;\n}\n//# sourceMappingURL=Polyline.js.map",
      "start": 1693508125913,
      "end": 1693508126018,
      "sourcemaps": null
    }
  ]
}
