{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/EmbeddedAttributeReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { LittleEndian } from \"../../../system/buffer/LittleEndian\";\nimport { ABufferInStream } from \"../../../system/io/ABufferInStream\";\nimport { ALong } from \"../../../system/runtime/ALong\";\nimport { AttributeValue } from \"../../model/AttributeValue\";\nimport { PointAttribute } from \"../../model/PointAttribute\";\nimport { StandardAttributes } from \"../../model/StandardAttributes\";\nimport { AttributeReader } from \"./AttributeReader\";\n/**\n * Class EmbeddedAttributeReader reads attribute data.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nexport class EmbeddedAttributeReader extends AttributeReader {\n    /**\n     * Create a new reader.\n     * @param container the container.\n     * @param index the index.\n     * @param levelCount the number of levels.\n     */\n    constructor(container, index, levelCount) {\n        super();\n        /* Store the parameters */\n        this._container = container;\n        this._index = index;\n        this._levelCount = levelCount;\n        /* Clear */\n        this._attribute = null;\n        this._minValue = null;\n        this._maxValue = null;\n        this._standardColor = false;\n        this._standardIntensity = false;\n        /* Find the data parts */\n        this._pointDataParts = new Array(levelCount);\n        this._blockDataParts = new Array(levelCount);\n        this._tileDataParts = new Array(levelCount);\n        for (let i = 0; i < levelCount; i++)\n            this._pointDataParts[i] = container.getPart(\"\" + i + \".attribute.\" + this._index + \".pointdata\");\n        for (let i = 0; i < levelCount; i++)\n            this._blockDataParts[i] = container.getPart(\"\" + i + \".attribute.\" + this._index + \".blockdata\");\n        for (let i = 0; i < levelCount; i++)\n            this._tileDataParts[i] = container.getPart(\"\" + i + \".attribute.\" + this._index + \".tiledata\");\n    }\n    /**\n     * Read the attribute information.\n     * @param data the attribute data.\n     */\n    readAttribute(data) {\n        /* Read the definition */\n        this._minValue = new AttributeValue();\n        this._maxValue = new AttributeValue();\n        let input = new ABufferInStream(data, 0, data.size());\n        this._attribute = EmbeddedAttributeReader.readDefinition(input, this._minValue, this._maxValue);\n        input.close();\n        /* Standard attribute? */\n        this._standardColor = (StandardAttributes.COLOR.hasName(this._attribute.getName()));\n        if (this._standardColor)\n            this._attribute.setStandardAttribute(true);\n        this._standardIntensity = (StandardAttributes.INTENSITY.hasName(this._attribute.getName()));\n        if (this._standardIntensity)\n            this._attribute.setStandardAttribute(true);\n    }\n    /**\n     * Load the data.\n     * @return the reader.\n     */\n    loadData(fileContents) {\n        /* Get the part */\n        let definitionPart = this._container.getPart(\"attribute.\" + this._index + \".definition\");\n        let fileAccess = definitionPart.getFileAccess();\n        /* Request the data? */\n        if (fileContents.isAvailable() == false) {\n            /* Add the range */\n            fileContents.requestFilePart(definitionPart.getOffset(), definitionPart.getSize().toInt());\n            return null;\n        }\n        /* Get the data */\n        let data = fileContents.getFilePart(definitionPart.getOffset(), definitionPart.getSize().toInt());\n        /* Read the attribute */\n        this.readAttribute(data);\n        /* Return the reader */\n        return this;\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#close\n     */\n    close() {\n    }\n    /**\n     * Get the container.\n     * @return the container.\n     */\n    getContainer() {\n        return this._container;\n    }\n    /**\n     * Get the index.\n     * @return the index.\n     */\n    getIndex() {\n        return this._index;\n    }\n    /**\n     * Read the definition of the attribute.\n     */\n    static readDefinition(input, minValue, maxValue) {\n        /* Read the definition */\n        let name = LittleEndian.readStreamString(input);\n        let description = LittleEndian.readStreamString(input);\n        let type = LittleEndian.readStreamInt(input);\n        let defaultValue = AttributeValue.readFromStream(input, type);\n        let attribute = new PointAttribute(name, description, type, defaultValue);\n        /* Read the value range */\n        let minValue2 = AttributeValue.readFromStream(input, type);\n        minValue2.copyTo(minValue);\n        let maxValue2 = AttributeValue.readFromStream(input, type);\n        maxValue2.copyTo(maxValue);\n        /* Return the attribute */\n        return attribute;\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#getAttribute\n     */\n    getAttribute() {\n        return this._attribute;\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#getMinimumValue\n     */\n    getMinimumValue() {\n        return this._minValue;\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#getMaximumValue\n     */\n    getMaximumValue() {\n        return this._maxValue;\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#readTileData2\n     */\n    readTileData2(level, tile, pointOffset, pointCount, tileBuffer, bufferIndex, readRequest, fileContents) {\n        /* Get the right part */\n        let pointDataPart = this._pointDataParts[level];\n        /* Get the file extent */\n        let fileName = pointDataPart.getFileAccess().getFileName();\n        let fileSize = this._container.getFileLength();\n        let offset = pointDataPart.getOffset().add(this._attribute.getTypeByteSizeForLongCount(tile.pointIndex.add(pointOffset)));\n        let size = this._attribute.getTypeByteSizeForCount(pointCount);\n        pointDataPart.rangeCheck(offset, ALong.fromInt(size));\n        /* Request the data? */\n        if (fileContents.isAvailable() == false) {\n            /* Add the range */\n            fileContents.requestFilePart(offset, size);\n            return;\n        }\n        /* Add the statistics */\n        readRequest.addDataSize(size);\n        /* Read the content */\n        let data = fileContents.getFilePart(offset, size);\n        tileBuffer.setAttributeBuffer(bufferIndex, data);\n    }\n    /**\n     * AttributeReader abstract method.\n     * @see AttributeReader#getPointData\n     */\n    getPointData(level, tile, tileBuffer, bufferIndex, pointIndex, cloudPoint) {\n        /* Get the buffer */\n        let buffer = tileBuffer.getAttributeBuffer(bufferIndex);\n        let offset = this._attribute.getTypeByteSizeForCount(pointIndex);\n        /* Read the value */\n        let attribute = cloudPoint.getAttribute(bufferIndex);\n        let value = cloudPoint.getAttributeValue(bufferIndex);\n        AttributeValue.readFromBufferTo(buffer, offset, attribute.getType(), value);\n        /* Standard attribute? */\n        if (this._standardColor)\n            cloudPoint.setColor(value.getColor());\n        if (this._standardIntensity)\n            cloudPoint.setIntensity(value.getInt2());\n    }\n}\n//# sourceMappingURL=EmbeddedAttributeReader.js.map",
      "start": 1693508127197,
      "end": 1693508127254,
      "sourcemaps": null
    }
  ]
}
