{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/bspline/BezierCurve3dH.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Bspline\n */\nimport { Geometry } from \"../Geometry\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Point4d } from \"../geometry4d/Point4d\";\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\nimport { BezierCurveBase } from \"./BezierCurveBase\";\n/** 3d curve with homogeneous weights.\n * * A control point with weight w and cartesian (projected) coordinates x,y,z has the weight multiplied into the coordinates,\n *    hence the control point as stored is (xw, yw, zw, w).\n * @public\n */\nexport class BezierCurve3dH extends BezierCurveBase {\n    /** test if `other` is also a BezierCurve3dH. */\n    isSameGeometryClass(other) { return other instanceof BezierCurve3dH; }\n    /**\n     * Apply (multiply by) an affine transform\n     * @param transform\n     */\n    tryTransformInPlace(transform) {\n        const data = this._workData0;\n        for (let i = 0; i < this._polygon.order; i++) {\n            this._polygon.getPolygonPoint(i, data);\n            transform.multiplyXYZWToFloat64Array(data[0], data[1], data[2], data[3], data);\n            this._polygon.setPolygonPoint(i, data);\n        }\n        return true;\n    }\n    /**\n     * Apply (multiply by) a perspective transform\n     * @param matrix\n     */\n    tryMultiplyMatrix4dInPlace(matrix) {\n        matrix.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData);\n    }\n    /** Return a specific pole as a full `[x,y,z,x] Point4d` */\n    getPolePoint4d(i, result) {\n        const data = this._polygon.getPolygonPoint(i, this._workData0);\n        if (data)\n            return Point4d.create(data[0], data[1], data[2], data[3], result);\n        return undefined;\n    }\n    /** Return a specific pole normalized to weight 1\n     */\n    getPolePoint3d(i, result) {\n        const data = this._polygon.getPolygonPoint(i, this._workData0);\n        if (data)\n            return Point3d.createFromPackedXYZW(data, 0, result);\n        return undefined;\n    }\n    /**\n     * Returns true if all weights are within tolerance of 1.0\n     */\n    isUnitWeight(tolerance) {\n        if (tolerance === undefined)\n            tolerance = Geometry.smallAngleRadians;\n        const aLow = 1.0 - tolerance;\n        const aHigh = 1.0 + tolerance;\n        const data = this._polygon.packedData;\n        const n = data.length;\n        let a;\n        for (let i = 3; i < n; i += 4) {\n            a = data[i];\n            if (a < aLow || a > aHigh)\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Capture a polygon as the data for a new `BezierCurve3dH`\n     * @param polygon complete packed data and order.\n     */\n    constructor(polygon) {\n        super(4, polygon);\n        this._workRay0 = Ray3d.createXAxis();\n        this._workRay1 = Ray3d.createXAxis();\n    }\n    /** Create a curve with given points.\n     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\n     * * If input is `Point3d[]`, the points are promoted with w=1`\n     *\n     */\n    static create(data) {\n        if (data.length < 1)\n            return undefined;\n        const polygon = new Float64Array(data.length * 4);\n        if (data[0] instanceof Point3d) {\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = p.z;\n                polygon[i++] = 1.0;\n            }\n            return new BezierCurve3dH(polygon);\n        }\n        else if (data[0] instanceof Point4d) {\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = p.z;\n                polygon[i++] = p.w;\n            }\n            return new BezierCurve3dH(polygon);\n        }\n        else if (data[0] instanceof Point2d) {\n            let i = 0;\n            for (const p of data) {\n                polygon[i++] = p.x;\n                polygon[i++] = p.y;\n                polygon[i++] = 0.0;\n                polygon[i++] = 1.0;\n            }\n            return new BezierCurve3dH(polygon);\n        }\n        return undefined;\n    }\n    /** create a bezier curve of specified order, filled with zeros */\n    static createOrder(order) {\n        const polygonArray = new Float64Array(order * 4); // and we trust that this is all zeros !!!\n        return new BezierCurve3dH(polygonArray);\n    }\n    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\n    loadSpan3dPolesWithWeight(data, spanIndex, weight) {\n        this._polygon.loadSpanPolesWithWeight(data, 3, spanIndex, weight);\n    }\n    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\n    loadSpan4dPoles(data, spanIndex) {\n        this._polygon.loadSpanPoles(data, spanIndex);\n    }\n    /** Clone the entire curve. */\n    clone() {\n        return new BezierCurve3dH(this._polygon.clonePolygon());\n    }\n    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\n    fractionToPoint(fraction, result) {\n        this._polygon.evaluate(fraction, this._workData0);\n        result = Point3d.createFromPackedXYZW(this._workData0, 0, result);\n        return result ? result : Point3d.createZero();\n    }\n    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\n    fractionToPoint4d(fraction, result) {\n        this._polygon.evaluate(fraction, this._workData0);\n        return Point4d.createFromPackedXYZW(this._workData0, 0, result);\n    }\n    /** Return the cartesian point and derivative vector. */\n    fractionToPointAndDerivative(fraction, result) {\n        this._polygon.evaluate(fraction, this._workData0);\n        this._polygon.evaluateDerivative(fraction, this._workData1);\n        result = Ray3d.createWeightedDerivative(this._workData0, this._workData1, result);\n        if (result)\n            return result;\n        // Bad. Very Bad.  Return origin and x axis.   Should be undefined, but usual cartesian types do not allow that\n        return Ray3d.createXAxis();\n    }\n    /** Construct a plane with\n     * * origin at the fractional position along the arc\n     * * x axis is the first derivative, i.e. tangent along the arc\n     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\n     * If the arc is circular, the second derivative is directly towards the center\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        const epsilon = 1.0e-8;\n        const a = 1.0 / (2.0 * epsilon);\n        if (!result)\n            result = Plane3dByOriginAndVectors.createXYPlane();\n        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\n        result.origin.setFrom(ray.origin);\n        result.vectorU.setFrom(ray.direction);\n        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\n        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\n        Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\n        return result;\n    }\n    /** test for nearly equal control points */\n    isAlmostEqual(other) {\n        if (other instanceof BezierCurve3dH) {\n            return this._polygon.isAlmostEqual(other._polygon);\n        }\n        return false;\n    }\n    /** Second step of double dispatch:  call `handler.handleBezierCurve3dH(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleBezierCurve3dH(this);\n    }\n    /**\n     * Form dot products of each pole with given coefficients. Return as entries in products array.\n     * @param products array of (scalar) dot products\n     * @param ax x coefficient\n     * @param ay y coefficient\n     * @param az z coefficient\n     * @param aw w coefficient\n     */\n    poleProductsXYZW(products, ax, ay, az, aw) {\n        const n = this.numPoles;\n        const data = this._polygon.packedData;\n        for (let i = 0, k = 0; i < n; i++, k += 4)\n            products[i] = ax * data[k] + ay * data[k + 1] + az * data[k + 2] + aw * data[k + 3];\n    }\n    /** Find the closest point within the bezier span, using true perpendicular test (but no endpoint test)\n     * * If closer than previously recorded, update the CurveLocationDetail\n     * * This assumes this bezier is saturated.\n     * @param spacePoint point being projected\n     * @param detail pre-allocated detail to record (evolving) closest point.\n     * @returns true if an updated occurred, false if either (a) no perpendicular projections or (b) perpendiculars were not closer.\n     */\n    updateClosestPointByTruePerpendicular(spacePoint, detail, testAt0 = false, testAt1 = false) {\n        let numUpdates = 0;\n        let roots;\n        if (this.isUnitWeight()) {\n            // unweighted !!!\n            const productOrder = 2 * this.order - 2;\n            this.allocateAndZeroBezierWorkData(productOrder, 0, 0);\n            const bezier = this._workBezier;\n            // closestPoint condition is:\n            //   (spacePoint - curvePoint) DOT curveTangent = 0;\n            // Each product (x,y,z) of the DOT is the product of two bezier polynomials\n            BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 0, -spacePoint.x, 0);\n            BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 1, -spacePoint.y, 1);\n            BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 2, -spacePoint.z, 2);\n            roots = bezier.roots(0.0, true);\n        }\n        else {\n            // This bezier has weights.\n            // The pure cartesian closest point condition is\n            //   (spacePoint - X/w) DOT (X' w - w' X)/ w^2 = 0\n            // ignoring denominator and using bezier coefficient differences for the derivative, making the numerator 0 is\n            //   (w * spacePoint - X) DOT ( DELTA X * w - DELTA w * X) = 0\n            const orderA = this.order;\n            const orderB = 2 * this.order - 2; // products of component and component difference.\n            const productOrder = orderA + orderB - 1;\n            this.allocateAndZeroBezierWorkData(productOrder, orderA, orderB);\n            const bezier = this._workBezier;\n            const workA = this._workCoffsA;\n            const workB = this._workCoffsB;\n            const packedData = this._polygon.packedData;\n            for (let i = 0; i < 3; i++) {\n                // x representing loop pass:   (w * spacePoint.x - curve.x(s)) * (curveDelta.x(s) * curve.w(s) - curve.x(s) * curveDelta.w(s))\n                // (and p.w is always 1)\n                for (let k = 0; k < workA.length; k++)\n                    workA[k] = 0;\n                for (let k = 0; k < workB.length; k++)\n                    workB[k] = 0;\n                BezierPolynomialAlgebra.scaledComponentSum(workA, packedData, 4, orderA, 3, spacePoint.at(i), // w * spacePoint.x\n                i, -1.0); // curve.x(s) * 1.0\n                BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, 1.0, 3, 0.0, i);\n                BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, -1.0, i, 0.0, 3);\n                BezierPolynomialAlgebra.accumulateProduct(bezier.coffs, workA, workB);\n            }\n            roots = bezier.roots(0.0, true);\n        }\n        if (roots) {\n            for (const fraction of roots) {\n                const xyz = this.fractionToPoint(fraction);\n                const a = xyz.distance(spacePoint);\n                numUpdates += detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a) ? 1 : 0;\n            }\n        }\n        if (testAt0)\n            numUpdates += this.updateDetailAtFraction(detail, 0.0, spacePoint) ? 1 : 0;\n        if (testAt1)\n            numUpdates += this.updateDetailAtFraction(detail, 1.0, spacePoint) ? 1 : 0;\n        return numUpdates > 0;\n    }\n    updateDetailAtFraction(detail, fraction, spacePoint) {\n        const xyz = this.fractionToPoint(fraction);\n        const a = xyz.distance(spacePoint);\n        return detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a);\n    }\n    /** Extend `rangeToExtend`, using candidate extrema at\n     * * both end points\n     * * any internal extrema in x,y,z\n     */\n    extendRange(rangeToExtend, transform) {\n        const order = this.order;\n        if (!transform) {\n            this.allocateAndZeroBezierWorkData(order * 2 - 2, 0, 0);\n            const bezier = this._workBezier;\n            const data = this._polygon.packedData;\n            this.getPolePoint3d(0, this._workPoint0);\n            rangeToExtend.extend(this._workPoint0);\n            this.getPolePoint3d(order - 1, this._workPoint0);\n            rangeToExtend.extend(this._workPoint0);\n            // Example:\n            // For x component ...\n            //     coefficients of (weighted x) are at axisIndex=0\n            //     deweighted polynomial is (x(s)/w(s))\n            //    its derivative (to be zeroed) is\n            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\n            // The coefficients of the derivatives are (degree times) differences of successive coffs.\n            // Make the numerator zero to get extrema\n            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\n                bezier.zero();\n                BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, 1.0, axisIndex, 0.0, 3);\n                BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, -1.0, 3, 0.0, axisIndex);\n                const roots = bezier.roots(0.0, true);\n                if (roots) {\n                    for (const r of roots) {\n                        this.fractionToPoint(r, this._workPoint0);\n                        rangeToExtend.extend(this._workPoint0);\n                    }\n                }\n            }\n        }\n        else {\n            this.allocateAndZeroBezierWorkData(order * 2 - 2, order, order);\n            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.\n            const weightCoffs = this._workCoffsB; // to hold weights\n            const bezier = this._workBezier;\n            this.getPolePoint3d(0, this._workPoint0);\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n            this.getPolePoint3d(order - 1, this._workPoint0);\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n            const data = this._polygon.packedData; // Example:\n            // For x component ...\n            //     coefficients of (weighted x) are at axisIndex=0\n            //     deweighted polynomial is (x(s)/w(s))\n            //    its derivative (to be zeroed) is\n            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\n            // The coefficients of the derivatives are (degree times) differences of successive coffs.\n            // Make the numerator zero to get extrema\n            // apply one row of the transform to get the transformed coff by itself\n            let weight;\n            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\n                bezier.zero();\n                for (let i = 0, k = 0; i < order; i++, k += 4) {\n                    weight = data[k + 3];\n                    componentCoffs[i] = transform.multiplyComponentXYZW(axisIndex, data[k], data[k + 1], data[k + 2], weight);\n                    weightCoffs[i] = weight;\n                }\n                BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, componentCoffs, weightCoffs, 1.0);\n                BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, weightCoffs, componentCoffs, -1.0);\n                const roots = bezier.roots(0.0, true);\n                if (roots && roots.length > 0) {\n                    for (const r of roots) {\n                        this.fractionToPoint(r, this._workPoint0);\n                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=BezierCurve3dH.js.map",
      "start": 1693508123841,
      "end": 1693508123967,
      "sourcemaps": null
    }
  ]
}
