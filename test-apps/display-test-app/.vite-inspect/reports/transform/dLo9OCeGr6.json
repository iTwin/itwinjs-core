{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/GeoServices.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module IModelConnection\n */\n// cspell:ignore GCRS\nimport { assert, BeEvent, Dictionary, Logger, SortedArray, } from \"@itwin/core-bentley\";\nimport { GeoCoordStatus, IModelReadRpcInterface, } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"./common/FrontendLoggerCategory\";\nfunction compareXYAndZ(lhs, rhs) {\n    return lhs.x - rhs.x || lhs.y - rhs.y || lhs.z - rhs.z;\n}\nfunction cloneXYAndZ(xyz) {\n    return { x: xyz.x, y: xyz.y, z: xyz.z };\n}\n/** Performs conversion of coordinates from one coordinate system to another.\n * A [[GeoConverter]] has a pair of these for converting between iModel coordinates and geographic coordinates.\n * Uses a cache to avoid repeatedly requesting the same points, and a batching strategy to avoid making frequent small requests.\n * The cache stores every point that was ever converted by [[convert]]. It is currently permitted to grow to unbounded size.\n * The batching works as follows:\n *  When a conversion is requested via [[convert]], if all the requested points are in the cache, they are returned immediately.\n *  Otherwise, any points not in the cache and not in the current in-flight request (if any) are placed onto the queue of pending requests.\n *  A pending request is scheduled if one hasn't already been scheduled, via requestAnimationFrame.\n *  In the animation frame callback, the pending requests are split into batches of no more than options.maxPointsPerRequest and dispatched to the backend.\n *  Once the response is received, the results are loaded into and returned from the cache.\n *  If more calls to convert occurred while the request was in flight, another request is dispatched.\n * @internal exported strictly for tests.\n */\nexport class CoordinateConverter {\n    get isIdle() {\n        return \"idle\" === this._state;\n    }\n    toXYAndZ(input, output) {\n        if (Array.isArray(input)) {\n            output.x = input[0] ?? 0;\n            output.y = input[1] ?? 0;\n            output.z = input[2] ?? 0;\n        }\n        else {\n            output.x = input.x ?? 0;\n            output.y = input.y ?? 0;\n            output.z = input.z ?? 0;\n        }\n        return output;\n    }\n    constructor(opts) {\n        this._state = \"idle\";\n        // An event fired when the next request completes.\n        this._onCompleted = new BeEvent();\n        // Used for creating cache keys (XYAndZ) from XYZProps without having to allocate temporary objects.\n        this._scratchXYZ = { x: 0, y: 0, z: 0 };\n        // If true, [[dispatch]] will schedule another dispatch after it receives a response.\n        // This is needed when all the points requested after the most recent dispatch were included in the currently-in-flight request -\n        // _pending will be empty but new callers will be awaiting the results of the in-flight request.\n        this._redispatchOnCompletion = false;\n        this._maxPointsPerRequest = Math.max(1, opts.maxPointsPerRequest ?? 300);\n        this._isIModelClosed = opts.isIModelClosed;\n        this._requestPoints = opts.requestPoints;\n        this._cache = new Dictionary(compareXYAndZ, cloneXYAndZ);\n        this._pending = new SortedArray(compareXYAndZ, false, cloneXYAndZ);\n        this._inflight = new SortedArray(compareXYAndZ, false, cloneXYAndZ);\n    }\n    async dispatch() {\n        assert(this._state === \"scheduled\");\n        if (this._isIModelClosed() || this._pending.isEmpty) {\n            this._state = \"idle\";\n            this._onCompleted.raiseEvent();\n            return;\n        }\n        this._state = \"in-flight\";\n        // Ensure subsequently-enqueued requests listen for the *next* response to be received.\n        const onCompleted = this._onCompleted;\n        this._onCompleted = new BeEvent();\n        // Pending requests are now in flight. Start a new list of pending requests. It's cheaper to swap than to allocate new objects.\n        const inflight = this._pending;\n        this._pending = this._inflight;\n        assert(this._pending.isEmpty);\n        this._inflight = inflight;\n        // Split requests if necessary to avoid requesting more than the maximum allowed number of points.\n        const promises = [];\n        for (let i = 0; i < inflight.length; i += this._maxPointsPerRequest) {\n            const requests = inflight.slice(i, i + this._maxPointsPerRequest).extractArray();\n            const promise = this._requestPoints(requests).then((results) => {\n                if (this._isIModelClosed())\n                    return;\n                if (results.length !== requests.length)\n                    Logger.logError(`${FrontendLoggerCategory.Package}.geoservices`, `requested conversion of ${requests.length} points, but received ${results.length} points`);\n                for (let j = 0; j < results.length; j++) {\n                    if (j < requests.length)\n                        this._cache.set(requests[j], results[j]);\n                }\n            }).catch((err) => {\n                Logger.logException(`${FrontendLoggerCategory.Package}.geoservices`, err);\n            });\n            promises.push(promise);\n        }\n        await Promise.all(promises);\n        assert(this._state === \"in-flight\");\n        this._state = \"idle\";\n        this._inflight.clear();\n        // If any more pending conversions arrived while awaiting this request, schedule another request.\n        if (!this._pending.isEmpty || this._redispatchOnCompletion) {\n            this._redispatchOnCompletion = false;\n            this.scheduleDispatch(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n        // Resolve promises of all callers who were awaiting this request.\n        onCompleted.raiseEvent();\n    }\n    // Add any points not present in cache to pending request list.\n    // Return the number of points present in cache.\n    enqueue(points) {\n        let numInCache = 0;\n        for (const point of points) {\n            const xyz = this.toXYAndZ(point, this._scratchXYZ);\n            if (this._cache.get(xyz))\n                ++numInCache;\n            else if (this._inflight.contains(xyz))\n                this._redispatchOnCompletion = true;\n            else\n                this._pending.insert(xyz);\n        }\n        return numInCache;\n    }\n    // Obtain converted points from the cache. The assumption is that every point in `inputs` is already present in the cache.\n    // Any point not present will be returned unconverted with an error status.\n    getFromCache(inputs) {\n        const outputs = [];\n        for (const input of inputs) {\n            const xyz = this.toXYAndZ(input, this._scratchXYZ);\n            let output = this._cache.get(xyz);\n            if (!output)\n                output = { p: { ...xyz }, s: GeoCoordStatus.CSMapError };\n            outputs.push(output);\n        }\n        return outputs;\n    }\n    async scheduleDispatch() {\n        if (\"idle\" === this._state) {\n            this._state = \"scheduled\";\n            requestAnimationFrame(() => {\n                this.dispatch(); // eslint-disable-line @typescript-eslint/no-floating-promises\n            });\n        }\n        return new Promise((resolve) => {\n            this._onCompleted.addOnce(() => resolve());\n        });\n    }\n    async convert(inputs) {\n        const fromCache = this.enqueue(inputs);\n        assert(fromCache >= 0);\n        assert(fromCache <= inputs.length);\n        if (fromCache === inputs.length)\n            return { points: this.getFromCache(inputs), fromCache };\n        await this.scheduleDispatch();\n        return { points: this.getFromCache(inputs), fromCache };\n    }\n    findCached(inputs) {\n        const result = [];\n        let missing;\n        for (const input of inputs) {\n            const key = this.toXYAndZ(input, this._scratchXYZ);\n            const output = this._cache.get(key);\n            result.push(output);\n            if (!output) {\n                if (!missing)\n                    missing = [];\n                missing.push(input);\n            }\n        }\n        return { result, missing };\n    }\n}\n/** An object capable of communicating with the backend to convert between coordinates in a geographic coordinate system and coordinates in an [[IModelConnection]]'s own coordinate system.\n * @see [[GeoServices.getConverter]] to obtain a converter.\n * @see [GeographicCRS]($common) for more information about geographic coordinate reference systems.\n * @public\n */\nexport class GeoConverter {\n    /** @internal */\n    constructor(opts) {\n        /** Used for removing this converter from GeoServices' cache after all requests are completed.\n         * @internal\n         */\n        this.onAllRequestsCompleted = new BeEvent();\n        const isIModelClosed = opts.isIModelClosed;\n        this._geoToIModel = new CoordinateConverter({\n            isIModelClosed,\n            requestPoints: async (geoCoords) => opts.toIModelCoords({ source: opts.datum, geoCoords }),\n        });\n        this._iModelToGeo = new CoordinateConverter({\n            isIModelClosed,\n            requestPoints: async (iModelCoords) => opts.fromIModelCoords({ target: opts.datum, iModelCoords }),\n        });\n    }\n    /** Convert the specified geographic coordinates into iModel coordinates. */\n    async convertToIModelCoords(geoPoints) {\n        const result = await this.getIModelCoordinatesFromGeoCoordinates(geoPoints);\n        return result.iModelCoords;\n    }\n    /** Convert the specified iModel coordinates into geographic coordinates. */\n    async convertFromIModelCoords(iModelCoords) {\n        const result = await this.getGeoCoordinatesFromIModelCoordinates(iModelCoords);\n        return result.geoCoords;\n    }\n    /** @internal */\n    async getIModelCoordinatesFromGeoCoordinates(geoPoints) {\n        const result = await this._geoToIModel.convert(geoPoints);\n        this.checkCompletion();\n        return {\n            iModelCoords: result.points,\n            fromCache: result.fromCache,\n        };\n    }\n    /** @internal */\n    async getGeoCoordinatesFromIModelCoordinates(iModelPoints) {\n        const result = await this._iModelToGeo.convert(iModelPoints);\n        this.checkCompletion();\n        return {\n            geoCoords: result.points,\n            fromCache: result.fromCache,\n        };\n    }\n    checkCompletion() {\n        if (this._geoToIModel.isIdle && this._iModelToGeo.isIdle)\n            this.onAllRequestsCompleted.raiseEvent();\n    }\n    /** @internal */\n    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints) {\n        return this._geoToIModel.findCached(geoPoints);\n    }\n}\n/** The Geographic Services available for an [[IModelConnection]].\n * @see [[IModelConnection.geoServices]] to obtain the GeoServices for a specific iModel.\n * @public\n */\nexport class GeoServices {\n    /** @internal */\n    constructor(options) {\n        /** Each GeoConverter has its own independent request queue and cache of previously-converted points.\n         * Some callers like RealityTileTree obtain a single GeoConverter and reuse it throughout their own lifetime. Therefore they benefit from both batching and caching, and\n         * the cache gets deleted once the RealityTileTree becomes disused.\n         *\n         * Other callers like IModelConnection.spatialToCartographic obtain a new GeoConverter every time they need one, use it to convert a single point(!), and then discard the converter.\n         * This entirely prevents batching - e.g., calling spatialToCartographic 20 times in one frame results in 20 http requests.\n         * To address that, we cache each GeoConverter returned by getConverter until it has converted at least one point and has no further outstanding conversion requests.\n         * In this way, the converter lives for as long as (and no longer than) any caller is awaiting conversion to/from its datum - it and its cache are deleted once it becomes disused.\n         * This makes the coordinate caching generally less useful, but at least bounded - and maximizes batching of requests.\n         */\n        this._cache = new Map();\n        this._options = options;\n    }\n    /** @internal */\n    static createForIModel(iModel) {\n        return new GeoServices({\n            isIModelClosed: () => iModel.isClosed,\n            toIModelCoords: async (request) => {\n                const rpc = IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token);\n                const response = await rpc.getIModelCoordinatesFromGeoCoordinates(iModel.getRpcProps(), request);\n                return response.iModelCoords;\n            },\n            fromIModelCoords: async (request) => {\n                const rpc = IModelReadRpcInterface.getClientForRouting(iModel.routingContext.token);\n                const response = await rpc.getGeoCoordinatesFromIModelCoordinates(iModel.getRpcProps(), request);\n                return response.geoCoords;\n            },\n        });\n    }\n    /** Obtain a converter that can convert between a geographic coordinate system and the iModel's own coordinate system.\n     * @param datumOrGCRS The name or JSON representation of the geographic coordinate system datum - for example, \"WGS84\".\n     * @returns a converter, or `undefined` if the iModel is not open.\n     * @note A [[BlankConnection]] has no connection to a backend, so it is never \"open\"; therefore it always returns `undefined`.\n     */\n    getConverter(datumOrGCRS) {\n        if (this._options.isIModelClosed())\n            return undefined;\n        const datum = (typeof datumOrGCRS === \"object\" ? JSON.stringify(datumOrGCRS) : datumOrGCRS) ?? \"\";\n        let converter = this._cache.get(datum);\n        if (!converter) {\n            converter = new GeoConverter({ ...this._options, datum });\n            this._cache.set(datum, converter);\n            converter.onAllRequestsCompleted.addOnce(() => {\n                if (converter === this._cache.get(datum))\n                    this._cache.delete(datum);\n            });\n        }\n        return converter;\n    }\n}\n//# sourceMappingURL=GeoServices.js.map",
      "start": 1693508119294,
      "end": 1693508119451,
      "sourcemaps": null
    }
  ]
}
