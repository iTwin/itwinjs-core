{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/LineSegment3d.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../Geometry\";\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Order2Bezier } from \"../numerics/BezierPolynomials\";\nimport { CurveExtendOptions } from \"./CurveExtendMode\";\nimport { CurveIntervalRole, CurveLocationDetail } from \"./CurveLocationDetail\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { PlaneAltitudeRangeContext } from \"./internalContexts/PlaneAltitudeRangeContext\";\nimport { OffsetOptions } from \"./OffsetOptions\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * A LineSegment3d is:\n * * A 3d line segment represented by its start and end coordinates\n *   * startPoint\n *   * endPoint\n * * The segment is parameterized with fraction 0 at the start and fraction 1 at the end, i.e. each of these\n * equivalent forms maps fraction `f` to a point `X(f)`:\n * ```\n * equation\n *  X(f) = P_0 + f*(P_1 - P_0)\\newline\n *  X(f) = (1-f)*P_0 + f*P_1\n * ```\n * @public\n */\nexport class LineSegment3d extends CurvePrimitive {\n    /** Test if `other` is of class `LineSegment3d` */\n    isSameGeometryClass(other) {\n        return other instanceof LineSegment3d;\n    }\n    /**\n     * Return REFERENCE to the start point of this segment.\n     * * This is distinct from the `CurvePrimitive` abstract method `startPoint()` which creates a returned point.\n     */\n    get point0Ref() {\n        return this._point0;\n    }\n    /**\n     * Return REFERENCE to the end point of this segment.\n     * * This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point.\n     */\n    get point1Ref() {\n        return this._point1;\n    }\n    /** A LineSegment3d extends along its infinite line. */\n    get isExtensibleFractionSpace() {\n        return true;\n    }\n    /**\n     * CAPTURE point references as a `LineSegment3d`\n     * @param point0\n     * @param point1\n     */\n    constructor(point0, point1) {\n        super();\n        /** String name for schema properties */\n        this.curvePrimitiveType = \"lineSegment\";\n        this._point0 = point0;\n        this._point1 = point1;\n    }\n    /** Set the start and endpoints by capturing input references. */\n    setRefs(point0, point1) {\n        this._point0 = point0;\n        this._point1 = point1;\n    }\n    /** Set the start and endpoints by cloning the input parameters. */\n    set(point0, point1) {\n        this._point0 = point0.clone();\n        this._point1 = point1.clone();\n    }\n    /** Copy (clone) data from other */\n    setFrom(other) {\n        this._point0.setFrom(other._point0);\n        this._point1.setFrom(other._point1);\n    }\n    /** Return a (clone of) the start point (This is NOT a reference to the stored start point) */\n    startPoint(result) {\n        if (result) {\n            result.setFrom(this._point0);\n            return result;\n        }\n        return this._point0.clone();\n    }\n    /** Return a (clone of) the end point (This is NOT a reference to the stored end point) */\n    endPoint(result) {\n        if (result) {\n            result.setFrom(this._point1);\n            return result;\n        }\n        return this._point1.clone();\n    }\n    /** Return the point and derivative vector at fractional position along the line segment. */\n    fractionToPointAndDerivative(fraction, result) {\n        result = result ? result : Ray3d.createZero();\n        result.direction.setStartEnd(this._point0, this._point1);\n        this._point0.interpolate(fraction, this._point1, result.origin);\n        return result;\n    }\n    /**\n     * Construct a plane with\n     * * origin at the fractional position along the line segment\n     * * x axis is the first derivative, i.e. along the line segment\n     * * y axis is the second derivative, i.e. 000\n     */\n    fractionToPointAnd2Derivatives(fraction, result) {\n        result = result ? result : Plane3dByOriginAndVectors.createXYPlane();\n        result.vectorU.setStartEnd(this._point0, this._point1);\n        result.vectorV.set(0, 0, 0);\n        this._point0.interpolate(fraction, this._point1, result.origin);\n        return result;\n    }\n    /** Clone the LineSegment3d */\n    clone() {\n        return LineSegment3d.create(this._point0, this._point1);\n    }\n    /** Clone and apply transform to the clone. */\n    cloneTransformed(transform) {\n        const c = this.clone();\n        c.tryTransformInPlace(transform);\n        return c;\n    }\n    /** Create with start and end points.  The point contents are cloned into the LineSegment3d. */\n    static create(point0, point1, result) {\n        if (result) {\n            result.set(point0, point1); // and this will clone them !!\n            return result;\n        }\n        return new LineSegment3d(point0.clone(), point1.clone());\n    }\n    /** Create with start and end points.  The point contents are CAPTURED into the result */\n    static createCapture(point0, point1) {\n        return new LineSegment3d(point0, point1);\n    }\n    /**\n     * Create a LineSegment3d from xy coordinates of start and end, with common z.\n     * @param x0 start point x coordinate.\n     * @param y0 start point y coordinate.\n     * @param x1 end point x coordinate.\n     * @param y1 end point y coordinate.\n     * @param z z coordinate to use for both points.\n     * @param result optional existing LineSegment to be reinitialized.\n     */\n    static createXYXY(x0, y0, x1, y1, z = 0, result) {\n        if (result) {\n            result._point0.set(x0, y0, z);\n            result._point1.set(x1, y1, z);\n            return result;\n        }\n        return new LineSegment3d(Point3d.create(x0, y0, z), Point3d.create(x1, y1, z));\n    }\n    /**\n     * Create a LineSegment3d from xy coordinates of start and end, with common z.\n     * @param x0 start point x coordinate.\n     * @param y0 start point y coordinate.\n     * @param x1 end point x coordinate.\n     * @param y1 end point y coordinate.\n     * @param z z coordinate to use for both points.\n     * @param result optional existing LineSegment to be reinitialized.\n     */\n    static createXYZXYZ(x0, y0, z0, x1, y1, z1, result) {\n        if (result) {\n            result._point0.set(x0, y0, z0);\n            result._point1.set(x1, y1, z1);\n            return result;\n        }\n        return new LineSegment3d(Point3d.create(x0, y0, z0), Point3d.create(x1, y1, z1));\n    }\n    /** Return the point at fractional position along the line segment. */\n    fractionToPoint(fraction, result) {\n        return this._point0.interpolate(fraction, this._point1, result);\n    }\n    /** Return the length of the segment. */\n    curveLength() {\n        return this._point0.distance(this._point1);\n    }\n    /** Return the length of the partial segment between fractions. */\n    curveLengthBetweenFractions(fraction0, fraction1) {\n        return Math.abs(fraction1 - fraction0) * this._point0.distance(this._point1);\n    }\n    /** Return the length of the segment. */\n    quickLength() {\n        return this.curveLength();\n    }\n    /**\n     * Returns a curve location detail with both xyz and fractional coordinates of the closest point.\n     * @param spacePoint point in space\n     * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on\n     * the unbounded line that contains the bounded segment.\n     */\n    closestPoint(spacePoint, extend, result) {\n        let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);\n        fraction = CurveExtendOptions.correctFraction(extend, fraction);\n        result = CurveLocationDetail.create(this, result);\n        // remark: This can be done by result.setFP (fraction, thePoint, undefined, a)\n        //   but that creates a temporary point.\n        result.fraction = fraction;\n        this._point0.interpolate(fraction, this._point1, result.point);\n        result.vectorInCurveLocationDetail = undefined;\n        result.a = result.point.distance(spacePoint);\n        return result;\n    }\n    /** Swap the endpoint references. */\n    reverseInPlace() {\n        const a = this._point0;\n        this._point0 = this._point1;\n        this._point1 = a;\n    }\n    /** Transform the two endpoints of this LinSegment. */\n    tryTransformInPlace(transform) {\n        this._point0 = transform.multiplyPoint3d(this._point0, this._point0);\n        this._point1 = transform.multiplyPoint3d(this._point1, this._point1);\n        return true;\n    }\n    /** Test if both endpoints are in a plane (within tolerance) */\n    isInPlane(plane) {\n        return Geometry.isSmallMetricDistance(plane.altitude(this._point0))\n            && Geometry.isSmallMetricDistance(plane.altitude(this._point1));\n    }\n    /**\n     * Compute points of simple (transverse) with a plane.\n     * * Use isInPlane to test if the line segment is completely in the plane.\n     */\n    appendPlaneIntersectionPoints(plane, result) {\n        const h0 = plane.altitude(this._point0);\n        const h1 = plane.altitude(this._point1);\n        const fraction = Order2Bezier.solveCoffs(h0, h1);\n        let numIntersection = 0;\n        if (fraction !== undefined) {\n            numIntersection++;\n            const detail = CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));\n            detail.intervalRole = CurveIntervalRole.isolated;\n            result.push(detail);\n        }\n        return numIntersection;\n    }\n    /**\n     * Extend a range to include the (optionally transformed) line segment\n     * @param range range to extend\n     * @param transform optional transform to apply to the end points\n     */\n    extendRange(range, transform) {\n        if (transform) {\n            range.extendTransformedPoint(transform, this._point0);\n            range.extendTransformedPoint(transform, this._point1);\n        }\n        else {\n            range.extendPoint(this._point0);\n            range.extendPoint(this._point1);\n        }\n    }\n    /**\n     * Construct a line from either of these json forms:\n     *\n     * * object with named start and end:\n     * `{startPoint: pointValue, endPoint: pointValue}`\n     * * array of two point values:\n     * `[pointValue, pointValue]`\n     * The point values are any values accepted by the Point3d method setFromJSON.\n     * @param json data to parse.\n     */\n    setFromJSON(json) {\n        if (!json) {\n            this._point0.set(0, 0, 0);\n            this._point1.set(1, 0, 0);\n            return;\n        }\n        else if (json.startPoint && json.endPoint) { // {startPoint:json point, endPoint:json point}\n            this._point0.setFromJSON(json.startPoint);\n            this._point1.setFromJSON(json.endPoint);\n        }\n        else if (Array.isArray(json)\n            && json.length > 1) { // [json point, json point]\n            this._point0.setFromJSON(json[0]);\n            this._point1.setFromJSON(json[1]);\n        }\n    }\n    /** A simple line segment's fraction and distance are proportional. */\n    getFractionToDistanceScale() {\n        return this.curveLength();\n    }\n    /**\n     * Place the lineSegment3d start and points in a json object\n     * @return {*} [[x,y,z],[x,y,z]]\n     */\n    toJSON() {\n        return [this._point0.toJSON(), this._point1.toJSON()];\n    }\n    /** Create a new `LineSegment3d` with coordinates from json object.   See `setFromJSON` for object layout description. */\n    static fromJSON(json) {\n        const result = new LineSegment3d(Point3d.createZero(), Point3d.create());\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Near equality test with `other`. */\n    isAlmostEqual(other) {\n        if (other instanceof LineSegment3d) {\n            const ls = other;\n            return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);\n        }\n        return false;\n    }\n    /** Emit strokes to caller-supplied linestring */\n    emitStrokes(dest, options) {\n        const numStroke = this.computeStrokeCountForOptions(options);\n        dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0);\n    }\n    /** Emit strokes to caller-supplied handler */\n    emitStrokableParts(handler, options) {\n        handler.startCurvePrimitive(this);\n        const numStroke = this.computeStrokeCountForOptions(options);\n        handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);\n        handler.endCurvePrimitive(this);\n    }\n    /**\n     * Return the stroke count required for given options.\n     * @param options StrokeOptions that determine count\n     */\n    computeStrokeCountForOptions(options) {\n        let numStroke = 1;\n        if (options) {\n            if (options.maxEdgeLength)\n                numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\n            numStroke = options.applyMinStrokesPerPrimitive(numStroke);\n        }\n        return numStroke;\n    }\n    /** Second step of double dispatch: call `handler.handleLineSegment3d(this)` */\n    dispatchToGeometryHandler(handler) {\n        return handler.handleLineSegment3d(this);\n    }\n    /**\n     * Find intervals of this curve primitive that are interior to a clipper\n     * @param clipper clip structure (e.g. clip planes)\n     * @param announce function to be called announcing fractional intervals `announce(fraction0, fraction1, curvePrimitive)`\n     */\n    announceClipIntervals(clipper, announce) {\n        return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1, announce ? (fraction0, fraction1) => announce(fraction0, fraction1, this) : undefined);\n    }\n    /**\n     * Return (if possible) a curve primitive which is a portion of this curve.\n     * @param fractionA [in] start fraction\n     * @param fractionB [in] end fraction\n     */\n    clonePartialCurve(fractionA, fractionB) {\n        return LineSegment3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));\n    }\n    /**\n     * Returns a (high accuracy) range of the curve between fractional positions\n     * * Default implementation returns teh range of the curve from clonePartialCurve\n     */\n    rangeBetweenFractions(fraction0, fraction1, transform) {\n        // (This is cheap -- don't bother testing for fraction0===fraction1)\n        if (!transform) {\n            const range = Range3d.create();\n            range.extendInterpolated(this._point0, fraction0, this._point1);\n            range.extendInterpolated(this._point0, fraction1, this._point1);\n            return range;\n        }\n        const point0 = this.fractionToPoint(fraction0);\n        const point1 = this.fractionToPoint(fraction1);\n        if (transform) {\n            transform.multiplyPoint3d(point0, point0);\n            transform.multiplyPoint3d(point1, point1);\n        }\n        return Range3d.create(point0, point1);\n    }\n    /**\n     * Construct an offset of the instance curve as viewed in the xy-plane (ignoring z).\n     * @param offsetDistanceOrOptions offset distance (positive to left of the instance curve), or options object\n     */\n    constructOffsetXY(offsetDistanceOrOptions) {\n        const offsetVec = Vector3d.createStartEnd(this._point0, this._point1);\n        if (offsetVec.normalizeInPlace()) {\n            offsetVec.rotate90CCWXY(offsetVec);\n            const offsetDist = OffsetOptions.getOffsetDistance(offsetDistanceOrOptions);\n            return LineSegment3d.create(this._point0.plusScaled(offsetVec, offsetDist), this._point1.plusScaled(offsetVec, offsetDist));\n        }\n        return undefined;\n    }\n    /**\n     * Project instance geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of\n     * projection.\n     * @param ray ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with zero origin.\n     * @param lowHigh optional receiver for output\n     * @returns range of fractional projection parameters onto the ray, where 0.0 is start of the ray and 1.0 is the\n     * end of the ray.\n     */\n    projectedParameterRange(ray, lowHigh) {\n        return PlaneAltitudeRangeContext.findExtremeFractionsAlongDirection(this, ray, lowHigh);\n    }\n}\n//# sourceMappingURL=LineSegment3d.js.map",
      "start": 1693508123627,
      "end": 1693508123772,
      "sourcemaps": null
    }
  ]
}
