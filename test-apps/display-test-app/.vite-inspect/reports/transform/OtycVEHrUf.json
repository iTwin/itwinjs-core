{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/RegionOps.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolylineCompressionContext } from \"../geometry3d/PolylineCompressionByEdgeOffset\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { SortablePolygon } from \"../geometry3d/SortablePolygon\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { MomentData } from \"../geometry4d/MomentData\";\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\nimport { HalfEdgeMask } from \"../topology/Graph\";\nimport { HalfEdgeGraphSearch } from \"../topology/HalfEdgeGraphSearch\";\nimport { Triangulator } from \"../topology/Triangulation\";\nimport { BagOfCurves, CurveChain, CurveCollection } from \"./CurveCollection\";\nimport { CurveCurve } from \"./CurveCurve\";\nimport { CurveOps } from \"./CurveOps\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { CurveWireMomentsXYZ } from \"./CurveWireMomentsXYZ\";\nimport { GeometryQuery } from \"./GeometryQuery\";\nimport { ChainCollectorContext } from \"./internalContexts/ChainCollectorContext\";\nimport { PolygonWireOffsetContext } from \"./internalContexts/PolygonOffsetContext\";\nimport { LineString3d } from \"./LineString3d\";\nimport { Loop } from \"./Loop\";\nimport { OffsetOptions } from \"./OffsetOptions\";\nimport { ParityRegion } from \"./ParityRegion\";\nimport { Path } from \"./Path\";\nimport { ConsolidateAdjacentCurvePrimitivesContext } from \"./Query/ConsolidateAdjacentPrimitivesContext\";\nimport { CurveSplitContext } from \"./Query/CurveSplitContext\";\nimport { PointInOnOutContext } from \"./Query/InOutTests\";\nimport { PlanarSubdivision } from \"./Query/PlanarSubdivision\";\nimport { RegionMomentsXY } from \"./RegionMomentsXY\";\nimport { RegionBooleanContext, RegionGroupOpType, RegionOpsFaceToFaceSearch } from \"./RegionOpsClassificationSweeps\";\nimport { UnionRegion } from \"./UnionRegion\";\n/**\n * Enumeration of the binary operation types for a booleans among regions\n * @public\n */\nexport var RegionBinaryOpType;\n(function (RegionBinaryOpType) {\n    RegionBinaryOpType[RegionBinaryOpType[\"Union\"] = 0] = \"Union\";\n    RegionBinaryOpType[RegionBinaryOpType[\"Parity\"] = 1] = \"Parity\";\n    RegionBinaryOpType[RegionBinaryOpType[\"Intersection\"] = 2] = \"Intersection\";\n    RegionBinaryOpType[RegionBinaryOpType[\"AMinusB\"] = 3] = \"AMinusB\";\n    RegionBinaryOpType[RegionBinaryOpType[\"BMinusA\"] = 4] = \"BMinusA\";\n})(RegionBinaryOpType || (RegionBinaryOpType = {}));\n/**\n * Class `RegionOps` has static members for calculations on regions (areas).\n * * Regions are represented by these `CurveCollection` subclasses:\n *   * `Loop` -- a single loop\n *   * `ParityRegion` -- a collection of loops, interpreted by parity rules.\n * The common \"One outer loop and many Inner loops\" is a parity region.\n *   * `UnionRegion` -- a collection of `Loop` and `ParityRegion` objects understood as a (probably disjoint) union.\n * * **NOTE:** Most of the methods in this class ignore z-coordinates, so callers should ensure that input geometry has\n * been rotated parallel to the xy-plane.\n * @public\n */\nexport class RegionOps {\n    /**\n     * Return moment sums for a loop, parity region, or union region.\n     * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with\n     *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`\n     * @param root any Loop, ParityRegion, or UnionRegion.\n     */\n    static computeXYAreaMoments(root) {\n        const handler = new RegionMomentsXY();\n        const result = root.dispatchToGeometryHandler(handler);\n        if (result instanceof MomentData) {\n            result.shiftOriginAndSumsToCentroidOfSums();\n            return result;\n        }\n        return undefined;\n    }\n    /**\n     * Return an area tolerance for a given xy-range and optional distance tolerance.\n     * @param range range of planar region to tolerance\n     * @param distanceTolerance optional absolute distance tolerance\n    */\n    static computeXYAreaTolerance(range, distanceTolerance = Geometry.smallMetricDistance) {\n        // if A = bh and e is distance tolerance, then A' := (b+e/2)(h+e/2) = A + e/2(b+h+e/2), so A'-A = e/2(b+h+e/2).\n        const halfDistTol = 0.5 * distanceTolerance;\n        return halfDistTol * (range.xLength() + range.yLength() + halfDistTol);\n    }\n    /**\n     * Return an xy area for a loop, parity region, or union region.\n     * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with\n     *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`\n     * @param root any Loop, ParityRegion, or UnionRegion.\n     */\n    static computeXYArea(root) {\n        const handler = new RegionMomentsXY();\n        const result = root.dispatchToGeometryHandler(handler);\n        if (result instanceof MomentData) {\n            return result.quantitySum;\n        }\n        return undefined;\n    }\n    /**\n     * Return MomentData with the sums of wire moments.\n     * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with\n     *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`\n     * @param root any CurveCollection or CurvePrimitive.\n     */\n    static computeXYZWireMomentSums(root) {\n        const handler = new CurveWireMomentsXYZ();\n        handler.visitLeaves(root);\n        const result = handler.momentData;\n        result.shiftOriginAndSumsToCentroidOfSums();\n        return result;\n    }\n    /**\n     * Create loops in the graph.\n     * @internal\n     */\n    static addLoopsToGraph(graph, data, announceIsolatedLoop) {\n        if (data instanceof Loop) {\n            const points = data.getPackedStrokes();\n            if (points)\n                this.addLoopsToGraph(graph, points, announceIsolatedLoop);\n        }\n        else if (data instanceof ParityRegion) {\n            for (const child of data.children) {\n                const points = child.getPackedStrokes();\n                if (points)\n                    this.addLoopsToGraph(graph, points, announceIsolatedLoop);\n            }\n        }\n        else if (data instanceof IndexedXYZCollection) {\n            const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n            if (loopSeed !== undefined)\n                announceIsolatedLoop(graph, loopSeed);\n        }\n        else if (Array.isArray(data)) {\n            if (data.length > 0) {\n                if (Point3d.isAnyImmediatePointType(data[0])) {\n                    const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n                    if (loopSeed !== undefined)\n                        announceIsolatedLoop(graph, loopSeed);\n                }\n                else if (data[0] instanceof IndexedXYZCollection) {\n                    for (const loop of data) {\n                        const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loop);\n                        if (loopSeed !== undefined)\n                            announceIsolatedLoop(graph, loopSeed);\n                    }\n                }\n                else {\n                    for (const child of data) {\n                        if (Array.isArray(child))\n                            this.addLoopsToGraph(graph, child, announceIsolatedLoop);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Add multiple loops to a graph.\n     * * Apply edgeTag and mask to each edge.\n     * @internal\n     */\n    static addLoopsWithEdgeTagToGraph(graph, data, mask, edgeTag) {\n        const loopSeeds = [];\n        this.addLoopsToGraph(graph, data, (_graph, seed) => {\n            if (seed) {\n                loopSeeds.push(seed);\n                seed.setMaskAndEdgeTagAroundFace(mask, edgeTag, true);\n            }\n        });\n        if (loopSeeds.length > 0)\n            return loopSeeds;\n        return undefined;\n    }\n    /**\n     * Given a graph just produced by booleans, convert to a polyface\n     * * \"just produced\" implies exterior face markup.\n     * @param graph\n     * @param triangulate\n     */\n    static finishGraphToPolyface(graph, triangulate) {\n        if (graph) {\n            if (triangulate) {\n                Triangulator.triangulateAllPositiveAreaFaces(graph);\n                Triangulator.flipTriangles(graph);\n            }\n            return PolyfaceBuilder.graphToPolyface(graph);\n        }\n        return undefined;\n    }\n    /**\n     * Return a polyface containing the area intersection of two XY regions.\n     * * Within each region, in and out is determined by parity rules.\n     *   * Any face that is an odd number of crossings from the far outside is IN\n     *   * Any face that is an even number of crossings from the far outside is OUT\n     * @param loopsA first set of loops\n     * @param loopsB second set of loops\n     * @param triangulate whether to triangulate the result\n     */\n    static polygonXYAreaIntersectLoopsToPolyface(loopsA, loopsB, triangulate = false) {\n        const graph = RegionOpsFaceToFaceSearch.doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA && inB), this._graphCheckPointFunction);\n        return this.finishGraphToPolyface(graph, triangulate);\n    }\n    /**\n     * Return a polyface containing the area union of two XY regions.\n     * * Within each region, in and out is determined by parity rules.\n     *   * Any face that is an odd number of crossings from the far outside is IN\n     *   * Any face that is an even number of crossings from the far outside is OUT\n     * @param loopsA first set of loops\n     * @param loopsB second set of loops\n     * @param triangulate whether to triangulate the result\n     */\n    static polygonXYAreaUnionLoopsToPolyface(loopsA, loopsB, triangulate = false) {\n        const graph = RegionOpsFaceToFaceSearch.doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA || inB), this._graphCheckPointFunction);\n        return this.finishGraphToPolyface(graph, triangulate);\n    }\n    /**\n     * Return a polyface containing the area difference of two XY regions.\n     * * Within each region, in and out is determined by parity rules.\n     *   * Any face that is an odd number of crossings from the far outside is IN\n     *   * Any face that is an even number of crossings from the far outside is OUT\n     * @param loopsA first set of loops\n     * @param loopsB second set of loops\n     * @param triangulate whether to triangulate the result\n     */\n    static polygonXYAreaDifferenceLoopsToPolyface(loopsA, loopsB, triangulate = false) {\n        const graph = RegionOpsFaceToFaceSearch.doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA && !inB), this._graphCheckPointFunction);\n        return this.finishGraphToPolyface(graph, triangulate);\n    }\n    /**\n     * Return areas defined by a boolean operation.\n     * * If there are multiple regions in loopsA, they are treated as a union.\n     * * If there are multiple regions in loopsB, they are treated as a union.\n     * @param loopsA first set of loops\n     * @param loopsB second set of loops\n     * @param operation indicates Union, Intersection, Parity, AMinusB, or BMinusA\n     * @param mergeTolerance absolute distance tolerance for merging loops\n     * @returns a region resulting from merging input loops and the boolean operation. May contain bridge edges added\n     * to connect interior loops to exterior loops.\n     */\n    static regionBooleanXY(loopsA, loopsB, operation, mergeTolerance = Geometry.smallMetricDistance) {\n        const result = UnionRegion.create();\n        const context = RegionBooleanContext.create(RegionGroupOpType.Union, RegionGroupOpType.Union);\n        context.addMembers(loopsA, loopsB);\n        context.annotateAndMergeCurvesInGraph(mergeTolerance);\n        const range = context.groupA.range().union(context.groupB.range());\n        const areaTol = this.computeXYAreaTolerance(range, mergeTolerance);\n        context.runClassificationSweep(operation, (_graph, face, faceType, area) => {\n            // ignore danglers and null faces, but not 2-edge \"banana\" faces with nonzero area\n            if (face.countEdgesAroundFace() < 2)\n                return;\n            if (Math.abs(area) < areaTol)\n                return;\n            if (faceType === 1) {\n                const loop = PlanarSubdivision.createLoopInFace(face);\n                if (loop)\n                    result.tryAddChild(loop);\n            }\n        });\n        return result;\n    }\n    /**\n     * Return a polyface whose facets are a boolean operation between the input regions.\n     * * Each of the two inputs is an array of multiple loops or parity regions.\n     *   * Within each of these input arrays, the various entries (loop or set of loops) are interpreted as a union.\n     * * In each \"array of loops and parity regions\", each entry inputA[i] or inputB[i] is one of:\n     *    * A simple loop, e.g. array of Point3d.\n     *    * Several simple loops, each of which is an array of Point3d.\n     * @param inputA first set of loops\n     * @param operation indicates Union, Intersection, Parity, AMinusB, or BMinusA\n     * @param inputB second set of loops\n     * @param triangulate whether to triangulate the result\n     */\n    static polygonBooleanXYToPolyface(inputA, operation, inputB, triangulate = false) {\n        const graph = RegionOpsFaceToFaceSearch.doBinaryBooleanBetweenMultiLoopInputs(inputA, RegionGroupOpType.Union, operation, inputB, RegionGroupOpType.Union, true);\n        return this.finishGraphToPolyface(graph, triangulate);\n    }\n    /**\n     * Return loops of linestrings around areas of a boolean operation between the input regions.\n     * * Each of the two inputs is an array of multiple loops or parity regions.\n     *   * Within each of these input arrays, the various entries (loop or set of loops) are interpreted as a union.\n     * * In each \"array of loops and parity regions\", each entry inputA[i] or inputB[i] is one of:\n     *    * A simple loop, e.g. array of Point3d.\n     *    * Several simple loops, each of which is an array of Point3d.\n     * @param inputA first set of loops\n     * @param operation indicates Union, Intersection, Parity, AMinusB, or BMinusA\n     * @param inputB second set of loops\n     */\n    static polygonBooleanXYToLoops(inputA, operation, inputB) {\n        const graph = RegionOpsFaceToFaceSearch.doBinaryBooleanBetweenMultiLoopInputs(inputA, RegionGroupOpType.Union, operation, inputB, RegionGroupOpType.Union, true);\n        if (!graph)\n            return undefined;\n        const loopEdges = HalfEdgeGraphSearch.collectExtendedBoundaryLoopsInGraph(graph, HalfEdgeMask.EXTERIOR);\n        const allLoops = [];\n        for (const graphLoop of loopEdges) {\n            const points = new GrowableXYZArray();\n            for (const edge of graphLoop)\n                points.pushXYZ(edge.x, edge.y, edge.z);\n            points.pushWrap(1);\n            const loop = Loop.create();\n            loop.tryAddChild(LineString3d.createCapture(points));\n            allLoops.push(loop);\n        }\n        return RegionOps.sortOuterAndHoleLoopsXY(allLoops);\n    }\n    /**\n     * Construct a wire that is offset from the given polyline or polygon.\n     * * This is a simple wire offset, not an area offset.\n     * * Since z-coordinates are ignored, for best results the input points should lie in (a plane parallel to)\n     * the xy-plane.\n     * * The construction algorithm attempts to eliminate some self-intersections within the offsets, but does not\n     * guarantee a simple area offset.\n     * @param points a single loop or path\n     * @param wrap true to include wraparound\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or JointOptions\n     * object.\n     */\n    static constructPolygonWireXYOffset(points, wrap, offsetDistanceOrOptions) {\n        const context = new PolygonWireOffsetContext();\n        return context.constructPolygonWireXYOffset(points, wrap, offsetDistanceOrOptions);\n    }\n    /**\n     * Construct curves that are offset from a Path or Loop as viewed in xy-plane (ignoring z).\n     * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will\n     * not detect self intersection among widely separated edges.\n     * * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/Offset\n     * @param curves base curves.\n     * @param offsetDistanceOrOptions offset distance (positive to left of curve, negative to right) or options object.\n     */\n    static constructCurveXYOffset(curves, offsetDistanceOrOptions) {\n        const offsetOptions = OffsetOptions.create(offsetDistanceOrOptions);\n        return CurveOps.constructCurveXYOffset(curves, offsetOptions);\n    }\n    /**\n     * Test if point (x,y) is IN, OUT or ON a region.\n     * @return (1) for in, (-1) for OUT, (0) for ON\n     * @param curves input region\n     * @param x x coordinate of point to test\n     * @param y y coordinate of point to test\n     */\n    static testPointInOnOutRegionXY(curves, x, y) {\n        return PointInOnOutContext.testPointInOnOutRegionXY(curves, x, y);\n    }\n    /**\n     * Create curve collection of subtype determined by gaps between the input curves.\n     * * If (a) wrap is requested and (b) all curves connect head-to-tail (including wraparound), assemble as a `loop`.\n     * * If all curves connect head-to-tail except for closure, return a `Path`.\n     * * If there are internal gaps, return a `BagOfCurves`\n     * * If input array has zero length, return undefined.\n     * @param curves input curves\n     * @param wrap whether to create a Loop (true) or Path (false) if maximum gap is minimal\n     * @param consolidateAdjacentPrimitives whether to simplify the result by calling [[consolidateAdjacentPrimitives]]\n     */\n    static createLoopPathOrBagOfCurves(curves, wrap = true, consolidateAdjacentPrimitives = false) {\n        const n = curves.length;\n        if (n === 0)\n            return undefined;\n        let maxGap = 0.0;\n        let isPath = false;\n        if (wrap)\n            maxGap = Geometry.maxXY(maxGap, curves[0].startPoint().distance(curves[n - 1].endPoint()));\n        for (let i = 0; i + 1 < n; i++)\n            maxGap = Geometry.maxXY(maxGap, curves[i].endPoint().distance(curves[i + 1].startPoint()));\n        let collection;\n        if (Geometry.isSmallMetricDistance(maxGap)) {\n            collection = wrap ? Loop.create() : Path.create();\n            isPath = true;\n        }\n        else {\n            collection = BagOfCurves.create();\n        }\n        for (const c of curves)\n            collection.tryAddChild(c);\n        if (isPath && consolidateAdjacentPrimitives)\n            RegionOps.consolidateAdjacentPrimitives(collection);\n        return collection;\n    }\n    /**\n     * Announce Checkpoint function for use during booleans\n     * @internal\n     */\n    static setCheckPointFunction(f) {\n        this._graphCheckPointFunction = f;\n    }\n    /**\n     * Find all intersections among curves in `curvesToCut` and `cutterCurves` and return fragments of `curvesToCut`.\n     * * For a `Loop`, `ParityRegion`, or `UnionRegion` in `curvesToCut`:\n     *    * if it is never cut by any `cutter` curve, it will be left unchanged.\n     *    * if cut, the input is downgraded to a set of `Path` curves joining at the cut points.\n     * * All cutting is \"as viewed in the xy plane\"\n     * @param curvesToCut input curves to be fragmented at intersections with `cutterCurves`\n     * @param cutterCurves input curves to intersect with `curvesToCut`\n     */\n    static cloneCurvesWithXYSplits(curvesToCut, cutterCurves) {\n        return CurveSplitContext.cloneCurvesWithXYSplits(curvesToCut, cutterCurves);\n    }\n    /**\n     * Create paths assembled from many curves.\n     * * Assemble paths from consecutive curves NOT separated by either gaps or the split markup set by\n     * [[cloneCurvesWithXYSplits]].\n     * * Return simplest form -- single primitive, single path, or bag of curves.\n     */\n    static splitToPathsBetweenBreaks(source, makeClones) {\n        if (source === undefined)\n            return undefined;\n        if (source instanceof CurvePrimitive)\n            return source;\n        // source is a collection .  ..\n        const primitives = source.collectCurvePrimitives();\n        const chainCollector = new ChainCollectorContext(makeClones);\n        for (const primitive of primitives) {\n            chainCollector.announceCurvePrimitive(primitive);\n        }\n        return chainCollector.grabResult();\n    }\n    /**\n     * Restructure curve fragments as Paths and Loops, and construct xy-offsets of the chains.\n     * * If the inputs do not form Loop(s), the classification of offsets is suspect.\n     * * For best offset results, the inputs should be parallel to the xy-plane.\n     * @param fragments fragments to be chained and offset\n     * @param offsetDistance offset distance, applied to both sides of each fragment to produce inside and outside xy-offset curves.\n     * @param gapTolerance distance to be treated as \"effectively zero\" when assembling fragments head-to-tail\n     * @returns object with named chains, insideOffsets, outsideOffsets\n     */\n    static collectInsideAndOutsideOffsets(fragments, offsetDistance, gapTolerance) {\n        return CurveOps.collectInsideAndOutsideXYOffsets(fragments, offsetDistance, gapTolerance);\n    }\n    /**\n     * Restructure curve fragments as Paths and Loops.\n     * @param fragments fragments to be chained\n     * @param gapTolerance distance to be treated as \"effectively zero\" when assembling fragments head-to-tail\n     * @returns chains, possibly wrapped in a [[BagOfCurves]].\n     */\n    static collectChains(fragments, gapTolerance = Geometry.smallMetricDistance) {\n        return CurveOps.collectChains(fragments, gapTolerance);\n    }\n    /**\n     * Find all intersections among curves in `curvesToCut` against the boundaries of `region` and return fragments\n     * of `curvesToCut`.\n     * * Break `curvesToCut` into parts inside, outside, and coincident.\n     * @returns output object with all fragments split among `insideParts`, `outsideParts`, and `coincidentParts`\n     */\n    static splitPathsByRegionInOnOutXY(curvesToCut, region) {\n        const result = { insideParts: [], outsideParts: [], coincidentParts: [] };\n        const pathWithIntersectionMarkup = RegionOps.cloneCurvesWithXYSplits(curvesToCut, region);\n        const splitPaths = RegionOps.splitToPathsBetweenBreaks(pathWithIntersectionMarkup, true);\n        if (splitPaths instanceof CurveCollection) {\n            for (const child of splitPaths.children) {\n                const pointOnChild = CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(child);\n                if (pointOnChild) {\n                    const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);\n                    pushToInOnOutArrays(child, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);\n                }\n            }\n        }\n        else if (splitPaths instanceof CurvePrimitive) {\n            const pointOnChild = CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(splitPaths);\n            if (pointOnChild) {\n                const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);\n                pushToInOnOutArrays(splitPaths, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);\n            }\n        }\n        return result;\n    }\n    /**\n     * If `data` is one of several forms of a rectangle, return its edge Transform.\n     * * Points are considered a rectangle if, within the first 4 points:\n     *     * vectors from 0 to 1 and 0 to 3 are perpendicular and have a non-zero cross product\n     *     * vectors from 0 to 3 and 1 to 2 are the same\n     * @param data points in one of several formats:\n     *   * LineString\n     *   * Loop containing rectangle content\n     *   * Path containing rectangle content\n     *   * Array of Point3d[]\n     *   * IndexedXYZCollection\n     * @param requireClosurePoint whether to require a 5th point equal to the 1st point.\n     * @returns Transform with origin at one corner, x and y columns extending along two adjacent sides, and unit\n     * normal in z column. If not a rectangle, return undefined.\n     */\n    static rectangleEdgeTransform(data, requireClosurePoint = true) {\n        if (data instanceof LineString3d) {\n            return this.rectangleEdgeTransform(data.packedPoints);\n        }\n        else if (data instanceof IndexedXYZCollection) {\n            let dataToUse;\n            if (requireClosurePoint && data.length === 5) {\n                if (!Geometry.isSmallMetricDistance(data.distanceIndexIndex(0, 4)))\n                    return undefined;\n                dataToUse = data;\n            }\n            else if (!requireClosurePoint && data.length === 4) {\n                dataToUse = data;\n            }\n            else if (data.length < (requireClosurePoint ? 5 : 4)) {\n                return undefined;\n            }\n            else {\n                dataToUse = GrowableXYZArray.create(data);\n                PolylineCompressionContext.compressInPlaceByShortEdgeLength(dataToUse, Geometry.smallMetricDistance);\n                if (dataToUse.length < (requireClosurePoint ? 5 : 4))\n                    return undefined;\n            }\n            const vector01 = dataToUse.vectorIndexIndex(0, 1);\n            const vector03 = dataToUse.vectorIndexIndex(0, 3);\n            const vector12 = dataToUse.vectorIndexIndex(1, 2);\n            const normalVector = vector01.crossProduct(vector03);\n            if (normalVector.normalizeInPlace()\n                && vector12.isAlmostEqual(vector03)\n                && vector01.isPerpendicularTo(vector03)) {\n                return Transform.createOriginAndMatrixColumns(dataToUse.getPoint3dAtUncheckedPointIndex(0), vector01, vector03, normalVector);\n            }\n        }\n        else if (Array.isArray(data)) {\n            return this.rectangleEdgeTransform(new Point3dArrayCarrier(data), requireClosurePoint);\n        }\n        else if (data instanceof Loop && data.children.length === 1 && data.children[0] instanceof LineString3d) {\n            return this.rectangleEdgeTransform(data.children[0].packedPoints, true);\n        }\n        else if (data instanceof Path && data.children.length === 1 && data.children[0] instanceof LineString3d) {\n            return this.rectangleEdgeTransform(data.children[0].packedPoints, requireClosurePoint);\n        }\n        else if (data instanceof CurveChain) {\n            if (!data.checkForNonLinearPrimitives()) {\n                // const linestring = LineString3d.create();\n                const strokes = data.getPackedStrokes();\n                if (strokes) {\n                    return this.rectangleEdgeTransform(strokes);\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Look for and simplify:\n     * * Contiguous `LineSegment3d` and `LineString3d` objects.\n     *   * collect all points\n     *   * eliminate duplicated points\n     *   * eliminate points colinear with surrounding points\n     *   * contiguous concentric circular or elliptic arcs\n     *   * combine angular ranges\n     * * This function can be used to compress adjacent LineSegment3ds into a LineString3d\n     * @param curves Path or loop (or larger collection containing paths and loops) to be simplified\n     * @param options options for tolerance and selective simplification.\n     */\n    static consolidateAdjacentPrimitives(curves, options) {\n        const context = new ConsolidateAdjacentCurvePrimitivesContext(options);\n        curves.dispatchToGeometryHandler(context);\n    }\n    /**\n     * Reverse and reorder loops in the xy-plane for consistency and containment.\n     * @param loops multiple loops in any order and orientation, z-coordinates ignored\n     * @returns a region that captures the input pointers. This region is a:\n     * * `Loop` if there is exactly one input loop. It is oriented counterclockwise.\n     * * `ParityRegion` if input consists of exactly one outer loop with at least one hole loop.\n     * Its first child is an outer loop oriented counterclockwise; all subsequent children are holes oriented\n     * clockwise.\n     * * `UnionRegion` if any other input configuration. Its children are individually ordered/oriented as in\n     * the above cases.\n     * @see [[PolygonOps.sortOuterAndHoleLoopsXY]]\n     */\n    static sortOuterAndHoleLoopsXY(loops) {\n        const loopAndArea = [];\n        for (const candidate of loops) {\n            if (candidate instanceof Loop)\n                SortablePolygon.pushLoop(loopAndArea, candidate);\n            else if (candidate instanceof IndexedXYZCollection) {\n                const loop = Loop.createPolygon(candidate);\n                SortablePolygon.pushLoop(loopAndArea, loop);\n            }\n        }\n        return SortablePolygon.sortAsAnyRegion(loopAndArea);\n    }\n    /**\n     * Find all areas bounded by the unstructured, possibly intersecting curves.\n     * * A common use case of this method is to assemble the bounding \"exterior\" loop (or loops) containing the\n     * input curves.\n     * * This method does not add bridge edges to connect outer loops to inner loops. Each disconnected loop,\n     * regardless of its containment, is returned as its own SignedLoops object. Pre-process with [[regionBooleanXY]]\n     * to add bridge edges so that [[constructAllXYRegionLoops]] will return outer and inner loops in the same\n     * SignedLoops object.\n     * @param curvesAndRegions Any collection of curves. Each Loop/ParityRegion/UnionRegion contributes its curve\n     * primitives.\n     * @param tolerance optional distance tolerance for coincidence\n     * @returns array of [[SignedLoops]], each entry of which describes the faces in a single connected component:\n     *    * `positiveAreaLoops` contains \"interior\" loops, _including holes in ParityRegion input_. These loops have\n     * positive area and counterclockwise orientation.\n     *    * `negativeAreaLoops` contains (probably just one) \"exterior\" loop which is ordered clockwise.\n     *    * `slivers` contains sliver loops that have zero area, such as appear between coincident curves.\n     *    * `edges` contains a [[LoopCurveLoopCurve]] object for each component edge, collecting both loops adjacent\n     * to the edge and a constituent curve in each.\n     */\n    static constructAllXYRegionLoops(curvesAndRegions, tolerance = Geometry.smallMetricDistance) {\n        const primitives = RegionOps.collectCurvePrimitives(curvesAndRegions, undefined, true, true);\n        const range = this.curveArrayRange(primitives);\n        const areaTol = this.computeXYAreaTolerance(range, tolerance);\n        const intersections = CurveCurve.allIntersectionsAmongPrimitivesXY(primitives, tolerance);\n        const graph = PlanarSubdivision.assembleHalfEdgeGraph(primitives, intersections, tolerance);\n        return PlanarSubdivision.collectSignedLoopSetsInHalfEdgeGraph(graph, areaTol);\n    }\n    /**\n     * Collect all `CurvePrimitives` in loosely typed input.\n     * * Always recurses into primitives within explicit collections (Path, Loop, ParityRegion, UnionRegion).\n     * * Optionally recurses into hidden primitives if `smallestPossiblePrimitives` is true.\n     * @param candidates input curves\n     * @param collectorArray optional pre-defined output array. If defined, it is NOT cleared: primitives are appended.\n     * @param smallestPossiblePrimitives if true, recurse into the children of a [[CurveChainWithDistanceIndex]]. If\n     * false, push the [[CurveChainWithDistanceIndex]] instead.\n     * @param explodeLinestrings if true, push a [[LineSegment3d]] for each segment of a [[LineString3d]]. If false,\n     * push the [[LineString3d]] instead.\n     */\n    static collectCurvePrimitives(candidates, collectorArray, smallestPossiblePrimitives = false, explodeLinestrings = false) {\n        const results = collectorArray === undefined ? [] : collectorArray;\n        if (candidates instanceof CurvePrimitive) {\n            candidates.collectCurvePrimitives(results, smallestPossiblePrimitives, explodeLinestrings);\n        }\n        else if (candidates instanceof CurveCollection) {\n            candidates.collectCurvePrimitives(results, smallestPossiblePrimitives, explodeLinestrings);\n        }\n        else if (Array.isArray(candidates)) {\n            for (const c of candidates) {\n                this.collectCurvePrimitives(c, results, smallestPossiblePrimitives, explodeLinestrings);\n            }\n        }\n        return results;\n    }\n    /**\n     * Copy primitive pointers from candidates to result array, replacing each [[LineString3d]] by newly constructed\n     * instances of [[LineSegment3d]].\n     * @param candidates input curves\n     * @return copied (captured) inputs except for the linestrings, which are exploded\n     */\n    static expandLineStrings(candidates) {\n        const result = [];\n        for (const c of candidates) {\n            if (c instanceof LineString3d) {\n                for (let i = 0; i + 1 < c.packedPoints.length; i++) {\n                    const q = c.getIndexedSegment(i);\n                    if (q !== undefined)\n                        result.push(q);\n                }\n            }\n            else {\n                result.push(c);\n            }\n        }\n        return result;\n    }\n    /**\n     * Return the overall range of given curves.\n     * @param data candidate curves\n     * @param worldToLocal transform to apply to data before computing its range\n     */\n    static curveArrayRange(data, worldToLocal) {\n        const range = Range3d.create();\n        if (data instanceof GeometryQuery)\n            data.extendRange(range, worldToLocal);\n        else if (Array.isArray(data)) {\n            for (const c of data) {\n                if (c instanceof GeometryQuery)\n                    c.extendRange(range, worldToLocal);\n                else if (c instanceof Point3d)\n                    range.extendPoint(c, worldToLocal);\n                else if (c instanceof GrowableXYZArray)\n                    range.extendRange(c.getRange(worldToLocal));\n                else if (Array.isArray(c))\n                    range.extendRange(this.curveArrayRange(c, worldToLocal));\n            }\n        }\n        return range;\n    }\n}\n/** @internal */\nfunction pushToInOnOutArrays(curve, select, arrayNegative, array0, arrayPositive) {\n    if (select > 0)\n        arrayPositive.push(curve);\n    else if (select < 0)\n        arrayNegative.push(curve);\n    else\n        array0.push(curve);\n}\n//# sourceMappingURL=RegionOps.js.map",
      "start": 1693508123683,
      "end": 1693508123820,
      "sourcemaps": null
    }
  ]
}
