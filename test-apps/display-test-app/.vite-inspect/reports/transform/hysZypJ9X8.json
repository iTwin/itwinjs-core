{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/primitives/geometry/GeometryListBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { LineSegment3d, LineString3d, Loop, Path, Point3d, Range3d, Transform, } from \"@itwin/core-geometry\";\nimport { Feature, GraphicParams, PackedFeatureTable } from \"@itwin/core-common\";\nimport { GraphicBuilder } from \"../../GraphicBuilder\";\nimport { DisplayParams } from \"../../../common/render/primitives/DisplayParams\";\nimport { GeometryOptions } from \"../Primitives\";\nimport { GeometryAccumulator } from \"./GeometryAccumulator\";\nfunction copy2dTo3d(pts2d, depth) {\n    const pts3d = [];\n    for (const point of pts2d)\n        pts3d.push(Point3d.create(point.x, point.y, depth));\n    return pts3d;\n}\n/** @internal */\nexport class GeometryListBuilder extends GraphicBuilder {\n    constructor(system, options, accumulatorTransform = Transform.identity) {\n        super(options);\n        this.graphicParams = new GraphicParams();\n        this.accum = new GeometryAccumulator({\n            system,\n            transform: accumulatorTransform,\n            analysisStyleDisplacement: this.analysisStyle?.displacement,\n            viewIndependentOrigin: options.viewIndependentOrigin,\n        });\n        if (this.pickable)\n            this.activateFeature(new Feature(this.pickable.id, this.pickable.subCategoryId, this.pickable.geometryClass));\n    }\n    finish() {\n        const graphic = this.finishGraphic(this.accum);\n        this.accum.clear();\n        return graphic;\n    }\n    activateGraphicParams(graphicParams) {\n        graphicParams.clone(this.graphicParams);\n    }\n    _activateFeature(feature) {\n        this.accum.currentFeature = feature;\n    }\n    addArc2d(ellipse, isEllipse, filled, zDepth) {\n        if (0.0 === zDepth) {\n            this.addArc(ellipse, isEllipse, filled);\n        }\n        else {\n            const ell = ellipse;\n            ell.center.z = zDepth;\n            this.addArc(ell, isEllipse, filled);\n        }\n    }\n    addArc(ellipse, isEllipse, filled) {\n        let curve;\n        if (isEllipse || filled) {\n            curve = Loop.create(ellipse);\n        }\n        else {\n            curve = Path.create(ellipse);\n        }\n        if (filled && !isEllipse && !ellipse.sweep.isFullCircle) {\n            const gapSegment = LineSegment3d.create(ellipse.startPoint(), ellipse.endPoint());\n            gapSegment.markerBits = 0x00010000; // Set the CURVE_PRIMITIVE_BIT_GapCurve marker bit\n            curve.children.push(gapSegment);\n        }\n        const displayParams = curve.isAnyRegionType ? this.getMeshDisplayParams() : this.getLinearDisplayParams();\n        if (curve instanceof Loop)\n            this.accum.addLoop(curve, displayParams, this.placement, false);\n        else\n            this.accum.addPath(curve, displayParams, this.placement, false);\n    }\n    /** take ownership of input points and add as a line string to this builder */\n    addLineString(points) {\n        if (2 === points.length && points[0].isAlmostEqual(points[1]))\n            this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);\n        else\n            this.accum.addLineString(points, this.getLinearDisplayParams(), this.placement);\n    }\n    addLineString2d(points, zDepth) {\n        const pts3d = copy2dTo3d(points, zDepth);\n        this.addLineString(pts3d);\n    }\n    /** take ownership of input points and add as a point string to this builder */\n    addPointString(points) {\n        this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);\n    }\n    addPointString2d(points, zDepth) {\n        const pts3d = copy2dTo3d(points, zDepth);\n        this.addPointString(pts3d);\n    }\n    addShape(points) {\n        const loop = Loop.create(LineString3d.create(points));\n        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);\n    }\n    addShape2d(points, zDepth) {\n        const pts3d = copy2dTo3d(points, zDepth);\n        this.addShape(pts3d);\n    }\n    addPath(path) {\n        this.accum.addPath(path, this.getLinearDisplayParams(), this.placement, false);\n    }\n    addLoop(loop) {\n        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);\n    }\n    addPolyface(meshData) {\n        this.accum.addPolyface(meshData, this.getMeshDisplayParams(), this.placement);\n    }\n    addSolidPrimitive(primitive) {\n        this.accum.addSolidPrimitive(primitive, this.getMeshDisplayParams(), this.placement);\n    }\n    getGraphicParams() { return this.graphicParams; }\n    getDisplayParams(type) { return DisplayParams.createForType(type, this.graphicParams); }\n    getMeshDisplayParams() { return DisplayParams.createForMesh(this.graphicParams, !this.wantNormals, (grad) => this.resolveGradient(grad)); }\n    getLinearDisplayParams() { return DisplayParams.createForLinear(this.graphicParams); }\n    get textDisplayParams() { return DisplayParams.createForText(this.graphicParams); }\n    get system() { return this.accum.system; }\n    add(geom) { this.accum.addGeometry(geom); }\n    resolveGradient(gradient) {\n        return this.system.getGradientTexture(gradient, this.iModel);\n    }\n}\n// Set to true to add a range box to every graphic produced by PrimitiveBuilder.\nlet addDebugRangeBox = false;\n/** @internal */\nexport class PrimitiveBuilder extends GeometryListBuilder {\n    constructor() {\n        super(...arguments);\n        this.primitives = [];\n    }\n    finishGraphic(accum) {\n        let meshes;\n        let range;\n        let featureTable;\n        if (!accum.isEmpty) {\n            // Overlay decorations don't test Z. Tools like to layer multiple primitives on top of one another; they rely on the primitives rendering\n            // in that same order to produce correct results (e.g., a thin line rendered atop a thick line of another color).\n            // No point generating edges for graphics that are always rendered in smooth shade mode.\n            const options = GeometryOptions.createForGraphicBuilder(this);\n            const tolerance = this.computeTolerance(accum);\n            meshes = accum.saveToGraphicList(this.primitives, options, tolerance, this.pickable);\n            if (undefined !== meshes) {\n                if (meshes.features?.anyDefined)\n                    featureTable = meshes.features;\n                range = meshes.range;\n            }\n        }\n        let graphic = (this.primitives.length !== 1) ? this.accum.system.createGraphicList(this.primitives) : this.primitives.pop();\n        if (undefined !== featureTable) {\n            const batchRange = range ?? new Range3d();\n            const batchOptions = this._options.pickable;\n            graphic = this.accum.system.createBatch(graphic, PackedFeatureTable.pack(featureTable), batchRange, batchOptions);\n        }\n        if (addDebugRangeBox && range) {\n            addDebugRangeBox = false;\n            const builder = this.accum.system.createGraphic({ ...this._options });\n            builder.addRangeBox(range);\n            graphic = this.accum.system.createGraphicList([graphic, builder.finish()]);\n            addDebugRangeBox = true;\n        }\n        return graphic;\n    }\n    computeTolerance(accum) {\n        return this._computeChordTolerance({\n            graphic: this,\n            computeRange: () => accum.geometries.computeRange(),\n        });\n    }\n}\n//# sourceMappingURL=GeometryListBuilder.js.map",
      "start": 1693508119962,
      "end": 1693508120044,
      "sourcemaps": null
    }
  ]
}
