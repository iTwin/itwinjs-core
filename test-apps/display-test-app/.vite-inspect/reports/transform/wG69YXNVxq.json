{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/frontend-tiles/lib/esm/BatchedTileTreeReference.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { AnimationNodeId, formatAnimationBranchId, TileTreeReference, } from \"@itwin/core-frontend\";\n/** @internal */\nexport class BatchedTileTreeReference extends TileTreeReference {\n    constructor(treeOwner) {\n        super();\n        this._treeOwner = treeOwner;\n    }\n    get treeOwner() {\n        return this._treeOwner;\n    }\n    computeBaseTransform(tree) {\n        return super.computeTransform(tree);\n    }\n    computeTransform(tree) {\n        const baseTf = this.computeBaseTransform(tree);\n        // ###TODO this.view.modelDisplayTransformProvider?.getModelDisplayTransform(modelId...)\n        return baseTf;\n    }\n}\nexport class PrimaryBatchedTileTreeReference extends BatchedTileTreeReference {\n    constructor(treeOwner, models) {\n        super(treeOwner);\n        this._models = models;\n    }\n    unionFitRange(range) {\n        this._models.unionRange(range);\n    }\n    getAppearanceProvider() {\n        return this;\n    }\n    getFeatureAppearance(source, elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) {\n        if (!this._models.isViewed(modelLo, modelHi))\n            return undefined;\n        return source.getAppearance(elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId);\n    }\n    getAnimationTransformNodeId() {\n        return AnimationNodeId.Untransformed;\n    }\n}\nexport class AnimatedBatchedTileTreeReference extends BatchedTileTreeReference {\n    constructor(treeOwner, node) {\n        super(treeOwner);\n        this._node = node;\n        this._branchId = formatAnimationBranchId(node.timeline.modelId, node.nodeId);\n    }\n    getAnimationTransformNodeId() {\n        return this._node.nodeId;\n    }\n    computeBaseTransform(tree) {\n        const tf = super.computeBaseTransform(tree);\n        const animTf = this._node.timeline.getTransform(this._node.nodeId, this._node.getCurrentTimePoint());\n        if (animTf)\n            animTf.multiplyTransformTransform(tf, tf);\n        return tf;\n    }\n    createDrawArgs(context) {\n        const animBranch = context.viewport.target.animationBranches?.branchStates.get(this._branchId);\n        if (animBranch && animBranch.omit)\n            return undefined;\n        const args = super.createDrawArgs(context);\n        // ###TODO args.boundingRange = args.tree.getTransformNodeRange(this._animationTransformNodeId);\n        return args;\n    }\n}\n//# sourceMappingURL=BatchedTileTreeReference.js.map",
      "start": 1693508124811,
      "end": 1693508125016,
      "sourcemaps": null
    }
  ]
}
