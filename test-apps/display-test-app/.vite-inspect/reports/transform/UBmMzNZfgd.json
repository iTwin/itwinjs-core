{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/orbitgt/lib/esm/pointcloud/format/opc/PointReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module OrbitGT\n */\nimport { Uint8Buffer } from \"../../../system/buffer/Uint8Buffer\";\nimport { AList } from \"../../../system/collection/AList\";\nimport { ALong } from \"../../../system/runtime/ALong\";\nimport { CloudPoint } from \"../../model/CloudPoint\";\n/**\n * Class PointReader reads points from tiles.\n *\n * @version 1.0 January 2014\n */\n/** @internal */\nexport class PointReader {\n    /**\n     * No instances.\n     */\n    constructor() { }\n    /**\n     * Read the data of a tile.\n     * @param reader the file reader.\n     * @param readRequest the read request parameters.\n     * @param attributeMask the attribute mask for reading.\n     * @param level the index of the level to read from.\n     * @param tileRecord the tile record.\n     * @param tileBuffer the buffer to help reading.\n     */\n    static readTileData(reader, readRequest, attributeMask, level, tileRecord, pointOffset, pointCount, tileBuffer, fileContents) {\n        /* Should we read the geometry? */\n        let geometryReader = null;\n        if (readRequest.readGeometry()) {\n            /* Read all geometry data */\n            geometryReader = reader.getGeometryReader(level);\n            geometryReader.readTileData2(tileRecord, pointOffset, pointCount, tileBuffer, readRequest, fileContents);\n        }\n        /* Read all attribute data */\n        let attributeReaders = attributeMask.readers;\n        for (let i = 0; i < attributeReaders.size(); i++) {\n            let attributeReader = attributeReaders.get(i);\n            attributeReader.readTileData2(level, tileRecord, ALong.fromInt(pointOffset), pointCount, tileBuffer, i, readRequest, fileContents);\n        }\n    }\n    /**\n     * Parse the data of a tile.\n     * @return the parsed tile data.\n     */\n    static parseTileData(reader, readRequest, attributeMask, level, tileRecord, pointOffset, pointCount, tileBuffer, fileContents) {\n        /* We should have the file content */\n        if (fileContents.isAvailable() == false)\n            return null;\n        /* Should we read the geometry? */\n        let geometryReader = null;\n        if (readRequest.readGeometry()) {\n            /* Read all geometry data */\n            geometryReader = reader.getGeometryReader(level);\n        }\n        /* Read all attribute data */\n        let attributeReaders = attributeMask.readers;\n        /* Thinning? */\n        let thinning = readRequest.getThinning();\n        if (thinning < 2)\n            thinning = 0;\n        /* Process all points */\n        let cloudPointList = new AList();\n        for (let i = 0; i < pointCount; i++) {\n            /* Create a point */\n            let cloudPoint = CloudPoint.createWithAttributes(attributeMask.attributes);\n            /* Thinning? */\n            if ((thinning != 0) && (i % thinning != 0)) {\n                /* Skip */\n                continue;\n            }\n            /* Get the point index */\n            let pointIndex = tileRecord.pointIndex.addInt(pointOffset + i);\n            /* Set the index */\n            cloudPoint.setIndex(pointIndex);\n            /* Set the geometry */\n            if (readRequest.readGeometry())\n                geometryReader.getPointData(tileRecord, tileBuffer, i, cloudPoint);\n            /* Set the attributes */\n            for (let j = 0; j < attributeReaders.size(); j++) {\n                let attributeReader = attributeReaders.get(j);\n                attributeReader.getPointData(level, tileRecord, tileBuffer, j, i, cloudPoint);\n            }\n            /* Process the point */\n            cloudPointList.add(cloudPoint);\n        }\n        /* Return the list */\n        return cloudPointList;\n    }\n    /**\n     * Read some points of a tile.\n     * @param reader the file reader.\n     * @param readRequest the read request parameters.\n     * @param attributeMask the attribute mask for reading.\n     * @param level the index of the level to read from.\n     * @param tileRecord the tile record.\n     * @param tileBuffer the buffer to help reading.\n     * @param processor the point processor.\n     * @param fileContens the file contents.\n     * @return the tile points.\n     */\n    static readTilePoints(reader, readRequest, attributeMask, level, tileRecord, pointOffset, pointCount, tileBuffer, fileContens) {\n        /* Read the tile data */\n        PointReader.readTileData(reader, readRequest, attributeMask, level, tileRecord, pointOffset, pointCount, tileBuffer, fileContens);\n        /* Parse the tile data */\n        return PointReader.parseTileData(reader, readRequest, attributeMask, level, tileRecord, pointOffset, pointCount, tileBuffer, fileContens);\n    }\n    /**\n     * Parse the data of a tile.\n     * @return the parsed tile data.\n     */\n    static parseTileDataRaw(reader, readRequest, attributeMask, tileRecord, tileBuffer, pointData, fileContents) {\n        /* We should have the file content */\n        if (fileContents.isAvailable() == false)\n            return;\n        /* Read the geometry */\n        let geometryReader = reader.getGeometryReader(tileRecord.level);\n        geometryReader.getPointDataRaw(tileRecord, tileBuffer, pointData);\n        /* Read the color? */\n        if (tileBuffer.getAttributeCount() > 0) {\n            /* Little-endian encoding makes 24-bit RGB values to be written as BGR byte sequence */\n            pointData.colors = new Uint8Buffer(tileBuffer.getAttributeBuffer(0), 0, 3 * tileRecord.pointCount);\n        }\n    }\n    /**\n     * Read some points of a tile.\n     * @param reader the file reader.\n     * @param readRequest the read request parameters.\n     * @param attributeMask the attribute mask for reading.\n     * @param level the index of the level to read from.\n     * @param tileRecord the tile record.\n     * @param tileBuffer the buffer to help reading.\n     * @param processor the point processor.\n     * @param fileContens the file contents.\n     * @return the tile points.\n     */\n    static readTilePointsRaw(reader, readRequest, attributeMask, tileRecord, tileBuffer, pointData, fileContents) {\n        /* Read the tile data */\n        PointReader.readTileData(reader, readRequest, attributeMask, tileRecord.level, tileRecord, 0, tileRecord.pointCount, tileBuffer, fileContents);\n        /* Parse the tile data */\n        PointReader.parseTileDataRaw(reader, readRequest, attributeMask, tileRecord, tileBuffer, pointData, fileContents);\n    }\n}\n//# sourceMappingURL=PointReader.js.map",
      "start": 1693508126590,
      "end": 1693508126658,
      "sourcemaps": null
    }
  ]
}
