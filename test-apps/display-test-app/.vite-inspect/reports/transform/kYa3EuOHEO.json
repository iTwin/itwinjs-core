{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/CameraPaths.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Camera } from \"@itwin/core-common\";\r\nimport { IModelConnection, Viewport } from \"@itwin/core-frontend\";\r\nimport { Angle, AngleProps, Point3d, Vector3d, XYZProps } from \"@itwin/core-geometry\";\r\nimport { createButton, createTextBox } from \"@itwin/frontend-devtools\";\r\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\r\nimport { ToolBarDropDown } from \"./ToolBar\";\r\n\r\ninterface KeyframeProps {\r\n  time: number;\r\n  location: XYZProps;\r\n  target: XYZProps;\r\n  up: XYZProps;\r\n  lensAngle: AngleProps | undefined;\r\n  extents: XYZProps | undefined;\r\n}\r\n\r\nclass Keyframe {\r\n  /// Position in time (ms) of the keyframe\r\n  public time: number;\r\n\r\n  /// Location of the camera\r\n  public location: Point3d;\r\n\r\n  /// Point to look at\r\n  public target: Point3d;\r\n\r\n  /// Up vector\r\n  public up: Vector3d;\r\n\r\n  /// Lens angle, undefined for ortho camera\r\n  public lensAngle: Angle | undefined;\r\n\r\n  /// View extent, undefined for perspective camera\r\n  public extents: Vector3d | undefined;\r\n\r\n  constructor(time: number, location: Point3d, target: Point3d, up: Vector3d, lensAngle: Angle | undefined, extents: Vector3d | undefined) {\r\n    this.time = time;\r\n    this.location = location;\r\n    this.target = target;\r\n    this.up = up;\r\n    this.lensAngle = lensAngle;\r\n    this.extents = extents;\r\n  }\r\n\r\n  public clone(): Keyframe {\r\n    return new Keyframe(\r\n      this.time,\r\n      this.location.clone(),\r\n      this.target.clone(),\r\n      this.up.clone(),\r\n      this.lensAngle?.clone(),\r\n      this.extents?.clone(),\r\n    );\r\n  }\r\n\r\n  public static createZero(): Keyframe {\r\n    return new Keyframe(0, Point3d.createZero(), Point3d.createZero(), Vector3d.createZero(), undefined, undefined);\r\n  }\r\n\r\n  /**\r\n   * Perform linear interpolation of the keyframe with another keyframe.\r\n   */\r\n  public interpolate(fraction: number, other: Keyframe): Keyframe {\r\n    let lensAngle;\r\n    if (this.lensAngle === undefined) {\r\n      lensAngle = other.lensAngle;\r\n    } else {\r\n      lensAngle = other.lensAngle !== undefined ? Angle.createInterpolate(this.lensAngle, fraction, other.lensAngle) : this.lensAngle;\r\n    }\r\n\r\n    let extent;\r\n    if (this.extents === undefined) {\r\n      extent = other.extents;\r\n    } else {\r\n      extent = other.extents !== undefined ? this.extents.interpolate(fraction, other.extents) : other.extents;\r\n    }\r\n\r\n    return new Keyframe(\r\n      this.time + fraction * (other.time - this.time),\r\n      this.location.interpolate(fraction, other.location),\r\n      this.target.interpolate(fraction, other.target),\r\n      this.up.interpolate(fraction, other.up),\r\n      lensAngle,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  public static fromJSON(json?: KeyframeProps): Keyframe {\r\n    if (!json)\r\n      return Keyframe.createZero();\r\n\r\n    return new Keyframe(\r\n      json.time,\r\n      Point3d.fromJSON(json.location),\r\n      Point3d.fromJSON(json.target),\r\n      Vector3d.fromJSON(json.up),\r\n      json.lensAngle !== undefined ? Angle.fromJSON(json.lensAngle) : undefined,\r\n      json.extents !== undefined ? Vector3d.fromJSON(json.extents) : undefined);\r\n  }\r\n\r\n  public toJSON(): KeyframeProps {\r\n    return {\r\n      time: this.time,\r\n      location: this.location.toJSON(),\r\n      target: this.target.toJSON(),\r\n      up: this.up.toJSON(),\r\n      lensAngle: this.lensAngle?.toJSON(),\r\n      extents: this.extents?.toJSON(),\r\n    };\r\n  }\r\n}\r\n\r\ninterface CameraPathProps {\r\n  name: string;\r\n  duration: number;\r\n  keyframes: Array<KeyframeProps>;\r\n}\r\n\r\nclass CameraPath {\r\n  public name: string;\r\n  public duration: number;\r\n  private _keyframes = new Array<Keyframe>();\r\n\r\n  public get keyframes() {\r\n    return this._keyframes;\r\n  }\r\n\r\n  constructor(name: string, duration: number, keyframes?: Array<Keyframe>) {\r\n    this.name = name;\r\n    this.duration = duration;\r\n\r\n    if (!!keyframes) {\r\n      this._keyframes = keyframes;\r\n      this.sortKeyframes();\r\n    }\r\n  }\r\n\r\n  public clone(): CameraPath {\r\n    return new CameraPath(this.name, this.duration, this.keyframes.map((keyframe) => keyframe.clone()));\r\n  }\r\n\r\n  public static createEmpty(): CameraPath {\r\n    return new CameraPath(\"\", 0, []);\r\n  }\r\n\r\n  /**\r\n   * Ensure that keyframes are sorted by time\r\n   */\r\n  public sortKeyframes() {\r\n    this.keyframes.sort((a, b) => a.time - b.time);\r\n  }\r\n\r\n  /**\r\n   * Remove keyframes that can be reconstructed with interpolation within the given error range.\r\n   */\r\n  public simplifies(distanceThreshold: number, lensAngleThreshold: Angle, extentThreshold: number): void {\r\n    let i = 1;\r\n    while (i < this.keyframes.length - 1) {\r\n      const [before, current, after] = this.keyframes.slice(i - 1, i + 2);\r\n      const fraction =  (current.time - before.time) / (after.time - before.time);\r\n      const interpolated = before.interpolate(fraction, after);\r\n\r\n      // Check if the distances between the reconstructed keyframe and the original is acceptable\r\n      const sameCameraType = (interpolated.lensAngle === undefined) === (current.lensAngle === undefined);\r\n      const locationDistance = interpolated.location.distance(current.location);\r\n      const targetDistance = interpolated.target.distance(current.target);\r\n      const lensAngleDistance = (interpolated.lensAngle === undefined || !sameCameraType) ? 0 : Math.abs(interpolated.lensAngle.degrees - current.lensAngle!.degrees);\r\n      const extentDistance = (interpolated.extents !== undefined && current.extents !== undefined) ? interpolated.extents.distance(current.extents) : 0;\r\n\r\n      if (sameCameraType\r\n        && locationDistance < distanceThreshold\r\n        && targetDistance < distanceThreshold\r\n        && lensAngleDistance < lensAngleThreshold.degrees\r\n        && extentDistance < extentThreshold) {\r\n        this.keyframes.splice(i, 1);\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the interpolated keyframe at a given time in the path.\r\n   * @param time In ms, the location in the timeline to get the keyframe at.\r\n   * @returns the interpolated keyframe.\r\n   */\r\n  public getKeyframeAtTime(time: number): Keyframe {\r\n    const {before, after} = this.getKeyframeRangeAtTime(time);\r\n\r\n    // Only one keyframe, use it directly\r\n    if (after === undefined)\r\n      return before;\r\n\r\n    // Two keyframes: interpolate between them\r\n    const timeDifference = after.time - before.time;\r\n    const fraction = timeDifference !== 0 ? (time - before.time) / timeDifference : 0.0;\r\n\r\n    return before.interpolate(fraction, after);\r\n  }\r\n\r\n  /**\r\n   * Get the two closest keyframes to a given time in the path. One before, one after.\r\n   * @param time In ms, the location in the timeline to get the keyframe at.\r\n   * @returns an object with the keyframes. ``before`` will always be set, but ``after`` can be missing.\r\n   */\r\n  private getKeyframeRangeAtTime(time: number): {before: Keyframe, after?: Keyframe} {\r\n    if (this.keyframes.length <= 0)\r\n      throw new Error(\"Selected path has no keyframes.\");\r\n\r\n    // Only one keyframe or before first keyframe\r\n    if (this.keyframes.length === 1 || time < this.keyframes[0].time) {\r\n      return {before: this.keyframes[0]};\r\n    }\r\n\r\n    // Between two keyframes\r\n    for (let i = 1; i < this.keyframes.length; i++) {\r\n      if (time < this.keyframes[i].time)\r\n        return {before: this.keyframes[i - 1], after: this.keyframes[i]};\r\n    }\r\n\r\n    // After the last keyframe\r\n    return {before: this.keyframes[this.keyframes.length - 1]};\r\n  }\r\n\r\n  public static fromJSON(json?: CameraPathProps): CameraPath {\r\n    if (!json)\r\n      return CameraPath.createEmpty();\r\n\r\n    return new CameraPath(\r\n      json.name,\r\n      json.duration,\r\n      json.keyframes.map((keyframeProps) => Keyframe.fromJSON(keyframeProps)),\r\n    );\r\n  }\r\n\r\n  public toJSON(): CameraPathProps {\r\n    return {\r\n      name: this.name,\r\n      duration: this.duration,\r\n      keyframes: this.keyframes.map((frame) => frame.toJSON()),\r\n    };\r\n  }\r\n}\r\n\r\nexport class CameraPathsMenu extends ToolBarDropDown {\r\n  private readonly _element: HTMLElement;\r\n  private readonly _viewport: Viewport;\r\n  private _imodel: IModelConnection;\r\n\r\n  private _paths: Array<CameraPath>;\r\n  private _selectedPath?: CameraPath | undefined;\r\n  private _onStateChanged = () => {};\r\n  private _newPathName: string;\r\n\r\n  private _isPlaying: boolean;\r\n  private _isRecording: boolean;\r\n\r\n  private _animID: number;\r\n  private _previousAnimationFrame: number | undefined;\r\n  private _currentAnimationTime: number;\r\n\r\n  public get selectedPath(): CameraPath | undefined {\r\n    return this._selectedPath;\r\n  }\r\n\r\n  public set selectedPath(value: CameraPath | undefined) {\r\n    this._selectedPath = value;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  public constructor(viewport: Viewport, parent: HTMLElement) {\r\n    super();\r\n\r\n    this._viewport = viewport;\r\n    this._imodel = viewport.iModel;\r\n\r\n    this._newPathName = \"\";\r\n    this._paths = [];\r\n\r\n    this._isPlaying = false;\r\n    this._isRecording = false;\r\n    this._animID = 0;\r\n    this._previousAnimationFrame = undefined;\r\n    this._currentAnimationTime = 0;\r\n\r\n    this._element = document.createElement(\"div\");\r\n    this._element.className = \"toolMenu\";\r\n    this._element.style.display = \"block\";\r\n    this._element.style.width = \"300px\";\r\n    this._element.style.overflowX = \"none\";\r\n\r\n    parent.appendChild(this._element);\r\n  }\r\n\r\n  public get isOpen() { return \"none\" !== this._element.style.display; }\r\n  protected _open() { this._element.style.display = \"block\"; }\r\n  protected _close() { this._element.style.display = \"none\"; }\r\n\r\n  public override get onViewChanged(): Promise<void> | undefined {\r\n    if (this._imodel !== this._viewport.iModel) {\r\n      this._imodel = this._viewport.iModel;\r\n      return this.populate();\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public async populate(): Promise<void> {\r\n    if (!this._viewport.iModel.isOpen)\r\n      return;\r\n\r\n    await this.loadPathsFromExternalFile();\r\n\r\n    await this.populateFromPathList();\r\n  }\r\n\r\n  private async populateFromPathList(): Promise<void> {\r\n    this.clearContent();\r\n\r\n    const pathNameTextBox = createTextBox({\r\n      id: \"txt_pathName\",\r\n      parent: this._element,\r\n      tooltip: \"Name of new camera path to create\",\r\n      keypresshandler: async (_tb, ev): Promise<void> => {\r\n        ev.stopPropagation();\r\n        if (\"Enter\" === ev.key) {\r\n          if (await this.appendNewPathToPathList())\r\n            await this.savePathsToExternalFile();\r\n        }\r\n      },\r\n    });\r\n\r\n    pathNameTextBox.div.style.marginLeft = pathNameTextBox.div.style.marginRight = \"3px\";\r\n    pathNameTextBox.textbox.size = 36;\r\n    pathNameTextBox.textbox.value = this._newPathName;\r\n    this._element.appendChild(document.createElement(\"hr\"));\r\n\r\n    const pathsList = document.createElement(\"select\");\r\n    // If only 1 entry in list, input becomes a combo box and can't select the view...\r\n    pathsList.size = 1 === this._paths.length ? 2 : Math.min(15, this._paths.length);\r\n    pathsList.style.width = \"100%\";\r\n    pathsList.style.display = 0 < this._paths.length ? \"\" : \"none\";\r\n\r\n    this._element.appendChild(pathsList);\r\n    this._element.onchange = () => this.selectedPath = pathsList.value ? this.findPath(pathsList.value) : undefined;\r\n    pathsList.addEventListener(\"keyup\", async (ev) => {\r\n      if (ev.key === \"Delete\")\r\n        await this.deletePath();\r\n    });\r\n\r\n    for (const path of this._paths) {\r\n      const option = document.createElement(\"option\");\r\n      option.value = option.innerText = path.name;\r\n      if (path.duration === 0 || path.keyframes.length === 0) {\r\n        option.style.color = \"grey\";\r\n        option.title = \"This path is empty. Please use the record button to record it.\";\r\n      }\r\n      pathsList.appendChild(option);\r\n    }\r\n\r\n    const buttonDiv = document.createElement(\"div\");\r\n    buttonDiv.style.textAlign = \"center\";\r\n\r\n    const createPathButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_createCameraPath\",\r\n      value: \"Create\",\r\n      handler: async () => {\r\n        if (await this.appendNewPathToPathList())\r\n          await this.savePathsToExternalFile();\r\n      },\r\n      tooltip: \"Create a new camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const deletePathButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_deleteCameraPath\",\r\n      value: \"Delete\",\r\n      handler: async () => {\r\n        if (await this.deletePath())\r\n          await this.savePathsToExternalFile();\r\n      },\r\n      tooltip: \"Delete selected camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    buttonDiv.appendChild(document.createElement(\"hr\"));\r\n\r\n    const recordButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_recordCameraPath\",\r\n      value: \"Record\",\r\n      handler: async () => this.play(true),\r\n      tooltip: \"Record a camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const playButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_playCameraPath\",\r\n      value: \"Play\",\r\n      handler: async () => this.play(false),\r\n      tooltip: \"Play selected camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const stopButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_stopCameraPath\",\r\n      value: \"Stop\",\r\n      handler: async () => this.stop(),\r\n      tooltip: \"Stop running camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const setCreatePathButtonDisabled = () => {\r\n      const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\r\n      const isPathNameValid = this._newPathName.length > 0 && !pathExist;\r\n\r\n      pathNameTextBox.textbox.style.color = isPathNameValid ? \"\" : \"red\";\r\n      createPathButton.disabled = !isPathNameValid;\r\n    };\r\n\r\n    pathNameTextBox.textbox.onkeyup = () => {\r\n      this._newPathName = pathNameTextBox.textbox.value;\r\n      setCreatePathButtonDisabled();\r\n    };\r\n\r\n    this._onStateChanged = () => {\r\n      if (this.selectedPath === undefined) {\r\n        playButton.disabled = recordButton.disabled = stopButton.disabled = deletePathButton.disabled = true;\r\n        pathsList.disabled = false;\r\n      } else {\r\n        const canRecord = this.selectedPath.duration === 0 || this.selectedPath.keyframes.length === 0;\r\n        playButton.disabled = this._isPlaying || canRecord;\r\n        recordButton.disabled = this._isPlaying || !canRecord;\r\n        stopButton.disabled = !this._isPlaying;\r\n        pathsList.disabled = this._isPlaying;\r\n        deletePathButton.disabled = false;\r\n      }\r\n\r\n      setCreatePathButtonDisabled();\r\n    };\r\n\r\n    this._onStateChanged();\r\n\r\n    this._element.appendChild(buttonDiv);\r\n  }\r\n\r\n  private clearContent(): void {\r\n    while (this._element.hasChildNodes())\r\n      this._element.removeChild(this._element.firstChild!);\r\n    this._onStateChanged = () => {};\r\n  }\r\n\r\n  private async deletePath(): Promise<boolean> {\r\n    if (this.selectedPath === undefined)\r\n      return false;\r\n\r\n    const index = this._paths.indexOf(this.selectedPath);\r\n    if (index > -1) {\r\n      this._paths.splice(index, 1);\r\n      this.selectedPath = undefined;\r\n      await this.populateFromPathList();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private async appendNewPathToPathList(): Promise<boolean> {\r\n    const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\r\n    if (this._newPathName.length > 0 && !pathExist) {\r\n      this._paths.push(CameraPath.createEmpty());\r\n      this.selectedPath = this._paths[this._paths.length - 1];\r\n      this.selectedPath.name = this._newPathName;\r\n      this._newPathName = \"\";\r\n      await this.populateFromPathList();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private async loadPathsFromExternalFile() {\r\n    const filename = this._viewport.view.iModel.key;\r\n    const externalCameraPathsString = await DtaRpcInterface.getClient().readExternalCameraPaths(filename);\r\n\r\n    try {\r\n      this._paths = JSON.parse(externalCameraPathsString).map((path: CameraPathProps) => CameraPath.fromJSON(path));\r\n    } catch (_e) {\r\n      this._paths = [];\r\n    }\r\n  }\r\n\r\n  private async savePathsToExternalFile(): Promise<void> {\r\n    const filename = this._viewport.view.iModel.key;\r\n    if (undefined === filename)\r\n      return;\r\n\r\n    const namedViews = JSON.stringify(this._paths.map((path) => path.toJSON()));\r\n    await DtaRpcInterface.getClient().writeExternalCameraPaths(filename, namedViews);\r\n  }\r\n\r\n  private findPath(name: string): CameraPath | undefined {\r\n    const index = this._paths.findIndex((path) => name === path.name);\r\n    return -1 !== index ? this._paths[index]! : undefined;\r\n\r\n  }\r\n\r\n  public prepareView(record = false): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    this._viewport.setAnimator(undefined);\r\n\r\n    if (!record) {\r\n      // This line prevents a bug that occurs in orthographic views if no camera has been set before.\r\n      // If not using a perspective camera, it will be turned off at the first frame.\r\n      this._viewport.turnCameraOn();\r\n    }\r\n\r\n    this._viewport.synchWithView();\r\n  }\r\n\r\n  public play(record = false): void {\r\n    if (this._isPlaying)\r\n      this.stop();\r\n\r\n    this._previousAnimationFrame = undefined;\r\n    this._currentAnimationTime = 0;\r\n\r\n    if (this.selectedPath === undefined)\r\n      return;\r\n\r\n    this.selectedPath.sortKeyframes();\r\n\r\n    const animate = (timestamp: number) => {\r\n      const elapsed = this._previousAnimationFrame ? timestamp - this._previousAnimationFrame : 0;\r\n      this._currentAnimationTime += elapsed;\r\n\r\n      this.computeAnimationFrame();\r\n\r\n      this._previousAnimationFrame = timestamp;\r\n\r\n      if (this._isPlaying)\r\n        this._animID = requestAnimationFrame(animate);\r\n    };\r\n\r\n    this.prepareView(record);\r\n    this._animID = requestAnimationFrame(animate);\r\n\r\n    this._isPlaying = true;\r\n    this._isRecording = record;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  public stop(): void {\r\n\r\n    if (this._animID) {\r\n      cancelAnimationFrame(this._animID);\r\n    }\r\n\r\n    // End of recording\r\n    if (this._isPlaying && this._isRecording) {\r\n      if (!this.selectedPath)\r\n        throw new Error(\"No valid camera path loaded\");\r\n\r\n      this.selectedPath.duration = this._currentAnimationTime;\r\n\r\n      // Remove keyframes that we can easily interpolate with a decent error range\r\n      this.selectedPath.simplifies(0.005, Angle.createDegrees(1.0), 0.01);\r\n\r\n      void this.savePathsToExternalFile();\r\n      void this.populateFromPathList();\r\n    }\r\n\r\n    this._animID = 0;\r\n    this._isPlaying = false;\r\n    this._isRecording = false;\r\n    this._currentAnimationTime = 0;\r\n    this._previousAnimationFrame = undefined;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  private computeAnimationFrame(): void {\r\n    if (!this.selectedPath) {\r\n      this.endAnimation();\r\n      return;\r\n    }\r\n\r\n    if (this._isRecording) {\r\n      this.recordAnimationFrame();\r\n    } else {\r\n      this.playAnimationFrame();\r\n\r\n      if (this._currentAnimationTime > this.selectedPath.duration)\r\n        this.endAnimation();\r\n    }\r\n\r\n  }\r\n\r\n  private playAnimationFrame(): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    this._viewport.setAnimator(undefined);\r\n    const keyframe = this.selectedPath.getKeyframeAtTime(this._currentAnimationTime);\r\n    this.setCameraPosition(keyframe);\r\n  }\r\n\r\n  private recordAnimationFrame(): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    const view = this._viewport.view;\r\n    if (!view.is3d() || !view.supportsCamera())\r\n      throw new Error(\"Invalid view for camera path\");\r\n\r\n    // TODO: Handle global coordinates\r\n    const location = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 1.0));\r\n    const target = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 0.0));\r\n\r\n    // Location and target are the same, the keyframe will be invalid\r\n    if (target.distance(location) <= Number.EPSILON)\r\n      return;\r\n\r\n    const topScreen = this._viewport.npcToWorld(new Point3d(0.5, 1.0, 0.0));\r\n    const up = location.unitVectorTo(topScreen);\r\n    if (up === undefined)\r\n      return;\r\n\r\n    const lensAngle = view.isCameraOn ? view.camera.getLensAngle().clone() : undefined;\r\n    const extents = view.isCameraOn ? undefined : view.getExtents().clone();\r\n\r\n    this.selectedPath.keyframes.push(new Keyframe(this._currentAnimationTime, location, target, up, lensAngle, extents));\r\n  }\r\n\r\n  private endAnimation(): void {\r\n    this.stop();\r\n  }\r\n\r\n  private setCameraPosition(keyframe: Keyframe) {\r\n    const view = this._viewport.view;\r\n    if (!view.is3d() || !view.supportsCamera())\r\n      throw new Error(\"Invalid view for camera path\");\r\n\r\n    // TODO: Handle global coordinates\r\n    if (keyframe.lensAngle !== undefined) {\r\n      const lensAngle = keyframe.lensAngle.clone();\r\n      Camera.validateLensAngle(lensAngle);\r\n\r\n      // Perspective\r\n      view.lookAt(\r\n        {\r\n          eyePoint: keyframe.location,\r\n          targetPoint: keyframe.target,\r\n          upVector: keyframe.up,\r\n          lensAngle,\r\n        },\r\n      );\r\n\r\n    } else {\r\n      if (keyframe.extents === undefined)\r\n        throw new Error(\"Invalid keyframe for camera: path should specifies either lensAngle or extents.\");\r\n\r\n      // Orthographic camera\r\n      view.lookAt(\r\n        {\r\n          eyePoint: keyframe.location,\r\n          viewDirection: (keyframe.target.minus(keyframe.location)),\r\n          upVector: keyframe.up,\r\n          newExtents: keyframe.extents,\r\n        },\r\n      );\r\n    }\r\n\r\n    this._viewport.synchWithView({noSaveInUndo: true});\r\n  }\r\n}\r\n",
      "start": 1693508124572,
      "end": 1693508124718,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { Camera } from \"@itwin/core-common\";\nimport { Angle, Point3d, Vector3d } from \"@itwin/core-geometry\";\nimport { createButton, createTextBox } from \"@itwin/frontend-devtools\";\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\nimport { ToolBarDropDown } from \"./ToolBar\";\nclass Keyframe {\n  constructor(time, location, target, up, lensAngle, extents) {\n    this.time = time;\n    this.location = location;\n    this.target = target;\n    this.up = up;\n    this.lensAngle = lensAngle;\n    this.extents = extents;\n  }\n  clone() {\n    return new Keyframe(\n      this.time,\n      this.location.clone(),\n      this.target.clone(),\n      this.up.clone(),\n      this.lensAngle?.clone(),\n      this.extents?.clone()\n    );\n  }\n  static createZero() {\n    return new Keyframe(0, Point3d.createZero(), Point3d.createZero(), Vector3d.createZero(), void 0, void 0);\n  }\n  /**\n   * Perform linear interpolation of the keyframe with another keyframe.\n   */\n  interpolate(fraction, other) {\n    let lensAngle;\n    if (this.lensAngle === void 0) {\n      lensAngle = other.lensAngle;\n    } else {\n      lensAngle = other.lensAngle !== void 0 ? Angle.createInterpolate(this.lensAngle, fraction, other.lensAngle) : this.lensAngle;\n    }\n    let extent;\n    if (this.extents === void 0) {\n      extent = other.extents;\n    } else {\n      extent = other.extents !== void 0 ? this.extents.interpolate(fraction, other.extents) : other.extents;\n    }\n    return new Keyframe(\n      this.time + fraction * (other.time - this.time),\n      this.location.interpolate(fraction, other.location),\n      this.target.interpolate(fraction, other.target),\n      this.up.interpolate(fraction, other.up),\n      lensAngle,\n      extent\n    );\n  }\n  static fromJSON(json) {\n    if (!json)\n      return Keyframe.createZero();\n    return new Keyframe(\n      json.time,\n      Point3d.fromJSON(json.location),\n      Point3d.fromJSON(json.target),\n      Vector3d.fromJSON(json.up),\n      json.lensAngle !== void 0 ? Angle.fromJSON(json.lensAngle) : void 0,\n      json.extents !== void 0 ? Vector3d.fromJSON(json.extents) : void 0\n    );\n  }\n  toJSON() {\n    return {\n      time: this.time,\n      location: this.location.toJSON(),\n      target: this.target.toJSON(),\n      up: this.up.toJSON(),\n      lensAngle: this.lensAngle?.toJSON(),\n      extents: this.extents?.toJSON()\n    };\n  }\n}\nclass CameraPath {\n  constructor(name, duration, keyframes) {\n    this._keyframes = new Array();\n    this.name = name;\n    this.duration = duration;\n    if (!!keyframes) {\n      this._keyframes = keyframes;\n      this.sortKeyframes();\n    }\n  }\n  get keyframes() {\n    return this._keyframes;\n  }\n  clone() {\n    return new CameraPath(this.name, this.duration, this.keyframes.map((keyframe) => keyframe.clone()));\n  }\n  static createEmpty() {\n    return new CameraPath(\"\", 0, []);\n  }\n  /**\n   * Ensure that keyframes are sorted by time\n   */\n  sortKeyframes() {\n    this.keyframes.sort((a, b) => a.time - b.time);\n  }\n  /**\n   * Remove keyframes that can be reconstructed with interpolation within the given error range.\n   */\n  simplifies(distanceThreshold, lensAngleThreshold, extentThreshold) {\n    let i = 1;\n    while (i < this.keyframes.length - 1) {\n      const [before, current, after] = this.keyframes.slice(i - 1, i + 2);\n      const fraction = (current.time - before.time) / (after.time - before.time);\n      const interpolated = before.interpolate(fraction, after);\n      const sameCameraType = interpolated.lensAngle === void 0 === (current.lensAngle === void 0);\n      const locationDistance = interpolated.location.distance(current.location);\n      const targetDistance = interpolated.target.distance(current.target);\n      const lensAngleDistance = interpolated.lensAngle === void 0 || !sameCameraType ? 0 : Math.abs(interpolated.lensAngle.degrees - current.lensAngle.degrees);\n      const extentDistance = interpolated.extents !== void 0 && current.extents !== void 0 ? interpolated.extents.distance(current.extents) : 0;\n      if (sameCameraType && locationDistance < distanceThreshold && targetDistance < distanceThreshold && lensAngleDistance < lensAngleThreshold.degrees && extentDistance < extentThreshold) {\n        this.keyframes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n  }\n  /**\n   * Get the interpolated keyframe at a given time in the path.\n   * @param time In ms, the location in the timeline to get the keyframe at.\n   * @returns the interpolated keyframe.\n   */\n  getKeyframeAtTime(time) {\n    const { before, after } = this.getKeyframeRangeAtTime(time);\n    if (after === void 0)\n      return before;\n    const timeDifference = after.time - before.time;\n    const fraction = timeDifference !== 0 ? (time - before.time) / timeDifference : 0;\n    return before.interpolate(fraction, after);\n  }\n  /**\n   * Get the two closest keyframes to a given time in the path. One before, one after.\n   * @param time In ms, the location in the timeline to get the keyframe at.\n   * @returns an object with the keyframes. ``before`` will always be set, but ``after`` can be missing.\n   */\n  getKeyframeRangeAtTime(time) {\n    if (this.keyframes.length <= 0)\n      throw new Error(\"Selected path has no keyframes.\");\n    if (this.keyframes.length === 1 || time < this.keyframes[0].time) {\n      return { before: this.keyframes[0] };\n    }\n    for (let i = 1; i < this.keyframes.length; i++) {\n      if (time < this.keyframes[i].time)\n        return { before: this.keyframes[i - 1], after: this.keyframes[i] };\n    }\n    return { before: this.keyframes[this.keyframes.length - 1] };\n  }\n  static fromJSON(json) {\n    if (!json)\n      return CameraPath.createEmpty();\n    return new CameraPath(\n      json.name,\n      json.duration,\n      json.keyframes.map((keyframeProps) => Keyframe.fromJSON(keyframeProps))\n    );\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      duration: this.duration,\n      keyframes: this.keyframes.map((frame) => frame.toJSON())\n    };\n  }\n}\nexport class CameraPathsMenu extends ToolBarDropDown {\n  constructor(viewport, parent) {\n    super();\n    this._onStateChanged = () => {\n    };\n    this._viewport = viewport;\n    this._imodel = viewport.iModel;\n    this._newPathName = \"\";\n    this._paths = [];\n    this._isPlaying = false;\n    this._isRecording = false;\n    this._animID = 0;\n    this._previousAnimationFrame = void 0;\n    this._currentAnimationTime = 0;\n    this._element = document.createElement(\"div\");\n    this._element.className = \"toolMenu\";\n    this._element.style.display = \"block\";\n    this._element.style.width = \"300px\";\n    this._element.style.overflowX = \"none\";\n    parent.appendChild(this._element);\n  }\n  get selectedPath() {\n    return this._selectedPath;\n  }\n  set selectedPath(value) {\n    this._selectedPath = value;\n    this._onStateChanged();\n  }\n  get isOpen() {\n    return \"none\" !== this._element.style.display;\n  }\n  _open() {\n    this._element.style.display = \"block\";\n  }\n  _close() {\n    this._element.style.display = \"none\";\n  }\n  get onViewChanged() {\n    if (this._imodel !== this._viewport.iModel) {\n      this._imodel = this._viewport.iModel;\n      return this.populate();\n    } else {\n      return void 0;\n    }\n  }\n  async populate() {\n    if (!this._viewport.iModel.isOpen)\n      return;\n    await this.loadPathsFromExternalFile();\n    await this.populateFromPathList();\n  }\n  async populateFromPathList() {\n    this.clearContent();\n    const pathNameTextBox = createTextBox({\n      id: \"txt_pathName\",\n      parent: this._element,\n      tooltip: \"Name of new camera path to create\",\n      keypresshandler: async (_tb, ev) => {\n        ev.stopPropagation();\n        if (\"Enter\" === ev.key) {\n          if (await this.appendNewPathToPathList())\n            await this.savePathsToExternalFile();\n        }\n      }\n    });\n    pathNameTextBox.div.style.marginLeft = pathNameTextBox.div.style.marginRight = \"3px\";\n    pathNameTextBox.textbox.size = 36;\n    pathNameTextBox.textbox.value = this._newPathName;\n    this._element.appendChild(document.createElement(\"hr\"));\n    const pathsList = document.createElement(\"select\");\n    pathsList.size = 1 === this._paths.length ? 2 : Math.min(15, this._paths.length);\n    pathsList.style.width = \"100%\";\n    pathsList.style.display = 0 < this._paths.length ? \"\" : \"none\";\n    this._element.appendChild(pathsList);\n    this._element.onchange = () => this.selectedPath = pathsList.value ? this.findPath(pathsList.value) : void 0;\n    pathsList.addEventListener(\"keyup\", async (ev) => {\n      if (ev.key === \"Delete\")\n        await this.deletePath();\n    });\n    for (const path of this._paths) {\n      const option = document.createElement(\"option\");\n      option.value = option.innerText = path.name;\n      if (path.duration === 0 || path.keyframes.length === 0) {\n        option.style.color = \"grey\";\n        option.title = \"This path is empty. Please use the record button to record it.\";\n      }\n      pathsList.appendChild(option);\n    }\n    const buttonDiv = document.createElement(\"div\");\n    buttonDiv.style.textAlign = \"center\";\n    const createPathButton = createButton({\n      parent: buttonDiv,\n      id: \"btn_createCameraPath\",\n      value: \"Create\",\n      handler: async () => {\n        if (await this.appendNewPathToPathList())\n          await this.savePathsToExternalFile();\n      },\n      tooltip: \"Create a new camera path\",\n      inline: true\n    }).button;\n    const deletePathButton = createButton({\n      parent: buttonDiv,\n      id: \"btn_deleteCameraPath\",\n      value: \"Delete\",\n      handler: async () => {\n        if (await this.deletePath())\n          await this.savePathsToExternalFile();\n      },\n      tooltip: \"Delete selected camera path\",\n      inline: true\n    }).button;\n    buttonDiv.appendChild(document.createElement(\"hr\"));\n    const recordButton = createButton({\n      parent: buttonDiv,\n      id: \"btn_recordCameraPath\",\n      value: \"Record\",\n      handler: async () => this.play(true),\n      tooltip: \"Record a camera path\",\n      inline: true\n    }).button;\n    const playButton = createButton({\n      parent: buttonDiv,\n      id: \"btn_playCameraPath\",\n      value: \"Play\",\n      handler: async () => this.play(false),\n      tooltip: \"Play selected camera path\",\n      inline: true\n    }).button;\n    const stopButton = createButton({\n      parent: buttonDiv,\n      id: \"btn_stopCameraPath\",\n      value: \"Stop\",\n      handler: async () => this.stop(),\n      tooltip: \"Stop running camera path\",\n      inline: true\n    }).button;\n    const setCreatePathButtonDisabled = () => {\n      const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\n      const isPathNameValid = this._newPathName.length > 0 && !pathExist;\n      pathNameTextBox.textbox.style.color = isPathNameValid ? \"\" : \"red\";\n      createPathButton.disabled = !isPathNameValid;\n    };\n    pathNameTextBox.textbox.onkeyup = () => {\n      this._newPathName = pathNameTextBox.textbox.value;\n      setCreatePathButtonDisabled();\n    };\n    this._onStateChanged = () => {\n      if (this.selectedPath === void 0) {\n        playButton.disabled = recordButton.disabled = stopButton.disabled = deletePathButton.disabled = true;\n        pathsList.disabled = false;\n      } else {\n        const canRecord = this.selectedPath.duration === 0 || this.selectedPath.keyframes.length === 0;\n        playButton.disabled = this._isPlaying || canRecord;\n        recordButton.disabled = this._isPlaying || !canRecord;\n        stopButton.disabled = !this._isPlaying;\n        pathsList.disabled = this._isPlaying;\n        deletePathButton.disabled = false;\n      }\n      setCreatePathButtonDisabled();\n    };\n    this._onStateChanged();\n    this._element.appendChild(buttonDiv);\n  }\n  clearContent() {\n    while (this._element.hasChildNodes())\n      this._element.removeChild(this._element.firstChild);\n    this._onStateChanged = () => {\n    };\n  }\n  async deletePath() {\n    if (this.selectedPath === void 0)\n      return false;\n    const index = this._paths.indexOf(this.selectedPath);\n    if (index > -1) {\n      this._paths.splice(index, 1);\n      this.selectedPath = void 0;\n      await this.populateFromPathList();\n      return true;\n    }\n    return false;\n  }\n  async appendNewPathToPathList() {\n    const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\n    if (this._newPathName.length > 0 && !pathExist) {\n      this._paths.push(CameraPath.createEmpty());\n      this.selectedPath = this._paths[this._paths.length - 1];\n      this.selectedPath.name = this._newPathName;\n      this._newPathName = \"\";\n      await this.populateFromPathList();\n      return true;\n    }\n    return false;\n  }\n  async loadPathsFromExternalFile() {\n    const filename = this._viewport.view.iModel.key;\n    const externalCameraPathsString = await DtaRpcInterface.getClient().readExternalCameraPaths(filename);\n    try {\n      this._paths = JSON.parse(externalCameraPathsString).map((path) => CameraPath.fromJSON(path));\n    } catch (_e) {\n      this._paths = [];\n    }\n  }\n  async savePathsToExternalFile() {\n    const filename = this._viewport.view.iModel.key;\n    if (void 0 === filename)\n      return;\n    const namedViews = JSON.stringify(this._paths.map((path) => path.toJSON()));\n    await DtaRpcInterface.getClient().writeExternalCameraPaths(filename, namedViews);\n  }\n  findPath(name) {\n    const index = this._paths.findIndex((path) => name === path.name);\n    return -1 !== index ? this._paths[index] : void 0;\n  }\n  prepareView(record = false) {\n    if (!this.selectedPath)\n      throw new Error(\"No valid camera path loaded\");\n    this._viewport.setAnimator(void 0);\n    if (!record) {\n      this._viewport.turnCameraOn();\n    }\n    this._viewport.synchWithView();\n  }\n  play(record = false) {\n    if (this._isPlaying)\n      this.stop();\n    this._previousAnimationFrame = void 0;\n    this._currentAnimationTime = 0;\n    if (this.selectedPath === void 0)\n      return;\n    this.selectedPath.sortKeyframes();\n    const animate = (timestamp) => {\n      const elapsed = this._previousAnimationFrame ? timestamp - this._previousAnimationFrame : 0;\n      this._currentAnimationTime += elapsed;\n      this.computeAnimationFrame();\n      this._previousAnimationFrame = timestamp;\n      if (this._isPlaying)\n        this._animID = requestAnimationFrame(animate);\n    };\n    this.prepareView(record);\n    this._animID = requestAnimationFrame(animate);\n    this._isPlaying = true;\n    this._isRecording = record;\n    this._onStateChanged();\n  }\n  stop() {\n    if (this._animID) {\n      cancelAnimationFrame(this._animID);\n    }\n    if (this._isPlaying && this._isRecording) {\n      if (!this.selectedPath)\n        throw new Error(\"No valid camera path loaded\");\n      this.selectedPath.duration = this._currentAnimationTime;\n      this.selectedPath.simplifies(5e-3, Angle.createDegrees(1), 0.01);\n      void this.savePathsToExternalFile();\n      void this.populateFromPathList();\n    }\n    this._animID = 0;\n    this._isPlaying = false;\n    this._isRecording = false;\n    this._currentAnimationTime = 0;\n    this._previousAnimationFrame = void 0;\n    this._onStateChanged();\n  }\n  computeAnimationFrame() {\n    if (!this.selectedPath) {\n      this.endAnimation();\n      return;\n    }\n    if (this._isRecording) {\n      this.recordAnimationFrame();\n    } else {\n      this.playAnimationFrame();\n      if (this._currentAnimationTime > this.selectedPath.duration)\n        this.endAnimation();\n    }\n  }\n  playAnimationFrame() {\n    if (!this.selectedPath)\n      throw new Error(\"No valid camera path loaded\");\n    this._viewport.setAnimator(void 0);\n    const keyframe = this.selectedPath.getKeyframeAtTime(this._currentAnimationTime);\n    this.setCameraPosition(keyframe);\n  }\n  recordAnimationFrame() {\n    if (!this.selectedPath)\n      throw new Error(\"No valid camera path loaded\");\n    const view = this._viewport.view;\n    if (!view.is3d() || !view.supportsCamera())\n      throw new Error(\"Invalid view for camera path\");\n    const location = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 1));\n    const target = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 0));\n    if (target.distance(location) <= Number.EPSILON)\n      return;\n    const topScreen = this._viewport.npcToWorld(new Point3d(0.5, 1, 0));\n    const up = location.unitVectorTo(topScreen);\n    if (up === void 0)\n      return;\n    const lensAngle = view.isCameraOn ? view.camera.getLensAngle().clone() : void 0;\n    const extents = view.isCameraOn ? void 0 : view.getExtents().clone();\n    this.selectedPath.keyframes.push(new Keyframe(this._currentAnimationTime, location, target, up, lensAngle, extents));\n  }\n  endAnimation() {\n    this.stop();\n  }\n  setCameraPosition(keyframe) {\n    const view = this._viewport.view;\n    if (!view.is3d() || !view.supportsCamera())\n      throw new Error(\"Invalid view for camera path\");\n    if (keyframe.lensAngle !== void 0) {\n      const lensAngle = keyframe.lensAngle.clone();\n      Camera.validateLensAngle(lensAngle);\n      view.lookAt(\n        {\n          eyePoint: keyframe.location,\n          targetPoint: keyframe.target,\n          upVector: keyframe.up,\n          lensAngle\n        }\n      );\n    } else {\n      if (keyframe.extents === void 0)\n        throw new Error(\"Invalid keyframe for camera: path should specifies either lensAngle or extents.\");\n      view.lookAt(\n        {\n          eyePoint: keyframe.location,\n          viewDirection: keyframe.target.minus(keyframe.location),\n          upVector: keyframe.up,\n          newExtents: keyframe.extents\n        }\n      );\n    }\n    this._viewport.synchWithView({ noSaveInUndo: true });\n  }\n}\n",
      "start": 1693508124718,
      "end": 1693508124818,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/CameraPaths.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Camera } from \"@itwin/core-common\";\r\nimport { IModelConnection, Viewport } from \"@itwin/core-frontend\";\r\nimport { Angle, AngleProps, Point3d, Vector3d, XYZProps } from \"@itwin/core-geometry\";\r\nimport { createButton, createTextBox } from \"@itwin/frontend-devtools\";\r\nimport { DtaRpcInterface } from \"../common/DtaRpcInterface\";\r\nimport { ToolBarDropDown } from \"./ToolBar\";\r\n\r\ninterface KeyframeProps {\r\n  time: number;\r\n  location: XYZProps;\r\n  target: XYZProps;\r\n  up: XYZProps;\r\n  lensAngle: AngleProps | undefined;\r\n  extents: XYZProps | undefined;\r\n}\r\n\r\nclass Keyframe {\r\n  /// Position in time (ms) of the keyframe\r\n  public time: number;\r\n\r\n  /// Location of the camera\r\n  public location: Point3d;\r\n\r\n  /// Point to look at\r\n  public target: Point3d;\r\n\r\n  /// Up vector\r\n  public up: Vector3d;\r\n\r\n  /// Lens angle, undefined for ortho camera\r\n  public lensAngle: Angle | undefined;\r\n\r\n  /// View extent, undefined for perspective camera\r\n  public extents: Vector3d | undefined;\r\n\r\n  constructor(time: number, location: Point3d, target: Point3d, up: Vector3d, lensAngle: Angle | undefined, extents: Vector3d | undefined) {\r\n    this.time = time;\r\n    this.location = location;\r\n    this.target = target;\r\n    this.up = up;\r\n    this.lensAngle = lensAngle;\r\n    this.extents = extents;\r\n  }\r\n\r\n  public clone(): Keyframe {\r\n    return new Keyframe(\r\n      this.time,\r\n      this.location.clone(),\r\n      this.target.clone(),\r\n      this.up.clone(),\r\n      this.lensAngle?.clone(),\r\n      this.extents?.clone(),\r\n    );\r\n  }\r\n\r\n  public static createZero(): Keyframe {\r\n    return new Keyframe(0, Point3d.createZero(), Point3d.createZero(), Vector3d.createZero(), undefined, undefined);\r\n  }\r\n\r\n  /**\r\n   * Perform linear interpolation of the keyframe with another keyframe.\r\n   */\r\n  public interpolate(fraction: number, other: Keyframe): Keyframe {\r\n    let lensAngle;\r\n    if (this.lensAngle === undefined) {\r\n      lensAngle = other.lensAngle;\r\n    } else {\r\n      lensAngle = other.lensAngle !== undefined ? Angle.createInterpolate(this.lensAngle, fraction, other.lensAngle) : this.lensAngle;\r\n    }\r\n\r\n    let extent;\r\n    if (this.extents === undefined) {\r\n      extent = other.extents;\r\n    } else {\r\n      extent = other.extents !== undefined ? this.extents.interpolate(fraction, other.extents) : other.extents;\r\n    }\r\n\r\n    return new Keyframe(\r\n      this.time + fraction * (other.time - this.time),\r\n      this.location.interpolate(fraction, other.location),\r\n      this.target.interpolate(fraction, other.target),\r\n      this.up.interpolate(fraction, other.up),\r\n      lensAngle,\r\n      extent,\r\n    );\r\n  }\r\n\r\n  public static fromJSON(json?: KeyframeProps): Keyframe {\r\n    if (!json)\r\n      return Keyframe.createZero();\r\n\r\n    return new Keyframe(\r\n      json.time,\r\n      Point3d.fromJSON(json.location),\r\n      Point3d.fromJSON(json.target),\r\n      Vector3d.fromJSON(json.up),\r\n      json.lensAngle !== undefined ? Angle.fromJSON(json.lensAngle) : undefined,\r\n      json.extents !== undefined ? Vector3d.fromJSON(json.extents) : undefined);\r\n  }\r\n\r\n  public toJSON(): KeyframeProps {\r\n    return {\r\n      time: this.time,\r\n      location: this.location.toJSON(),\r\n      target: this.target.toJSON(),\r\n      up: this.up.toJSON(),\r\n      lensAngle: this.lensAngle?.toJSON(),\r\n      extents: this.extents?.toJSON(),\r\n    };\r\n  }\r\n}\r\n\r\ninterface CameraPathProps {\r\n  name: string;\r\n  duration: number;\r\n  keyframes: Array<KeyframeProps>;\r\n}\r\n\r\nclass CameraPath {\r\n  public name: string;\r\n  public duration: number;\r\n  private _keyframes = new Array<Keyframe>();\r\n\r\n  public get keyframes() {\r\n    return this._keyframes;\r\n  }\r\n\r\n  constructor(name: string, duration: number, keyframes?: Array<Keyframe>) {\r\n    this.name = name;\r\n    this.duration = duration;\r\n\r\n    if (!!keyframes) {\r\n      this._keyframes = keyframes;\r\n      this.sortKeyframes();\r\n    }\r\n  }\r\n\r\n  public clone(): CameraPath {\r\n    return new CameraPath(this.name, this.duration, this.keyframes.map((keyframe) => keyframe.clone()));\r\n  }\r\n\r\n  public static createEmpty(): CameraPath {\r\n    return new CameraPath(\"\", 0, []);\r\n  }\r\n\r\n  /**\r\n   * Ensure that keyframes are sorted by time\r\n   */\r\n  public sortKeyframes() {\r\n    this.keyframes.sort((a, b) => a.time - b.time);\r\n  }\r\n\r\n  /**\r\n   * Remove keyframes that can be reconstructed with interpolation within the given error range.\r\n   */\r\n  public simplifies(distanceThreshold: number, lensAngleThreshold: Angle, extentThreshold: number): void {\r\n    let i = 1;\r\n    while (i < this.keyframes.length - 1) {\r\n      const [before, current, after] = this.keyframes.slice(i - 1, i + 2);\r\n      const fraction =  (current.time - before.time) / (after.time - before.time);\r\n      const interpolated = before.interpolate(fraction, after);\r\n\r\n      // Check if the distances between the reconstructed keyframe and the original is acceptable\r\n      const sameCameraType = (interpolated.lensAngle === undefined) === (current.lensAngle === undefined);\r\n      const locationDistance = interpolated.location.distance(current.location);\r\n      const targetDistance = interpolated.target.distance(current.target);\r\n      const lensAngleDistance = (interpolated.lensAngle === undefined || !sameCameraType) ? 0 : Math.abs(interpolated.lensAngle.degrees - current.lensAngle!.degrees);\r\n      const extentDistance = (interpolated.extents !== undefined && current.extents !== undefined) ? interpolated.extents.distance(current.extents) : 0;\r\n\r\n      if (sameCameraType\r\n        && locationDistance < distanceThreshold\r\n        && targetDistance < distanceThreshold\r\n        && lensAngleDistance < lensAngleThreshold.degrees\r\n        && extentDistance < extentThreshold) {\r\n        this.keyframes.splice(i, 1);\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the interpolated keyframe at a given time in the path.\r\n   * @param time In ms, the location in the timeline to get the keyframe at.\r\n   * @returns the interpolated keyframe.\r\n   */\r\n  public getKeyframeAtTime(time: number): Keyframe {\r\n    const {before, after} = this.getKeyframeRangeAtTime(time);\r\n\r\n    // Only one keyframe, use it directly\r\n    if (after === undefined)\r\n      return before;\r\n\r\n    // Two keyframes: interpolate between them\r\n    const timeDifference = after.time - before.time;\r\n    const fraction = timeDifference !== 0 ? (time - before.time) / timeDifference : 0.0;\r\n\r\n    return before.interpolate(fraction, after);\r\n  }\r\n\r\n  /**\r\n   * Get the two closest keyframes to a given time in the path. One before, one after.\r\n   * @param time In ms, the location in the timeline to get the keyframe at.\r\n   * @returns an object with the keyframes. ``before`` will always be set, but ``after`` can be missing.\r\n   */\r\n  private getKeyframeRangeAtTime(time: number): {before: Keyframe, after?: Keyframe} {\r\n    if (this.keyframes.length <= 0)\r\n      throw new Error(\"Selected path has no keyframes.\");\r\n\r\n    // Only one keyframe or before first keyframe\r\n    if (this.keyframes.length === 1 || time < this.keyframes[0].time) {\r\n      return {before: this.keyframes[0]};\r\n    }\r\n\r\n    // Between two keyframes\r\n    for (let i = 1; i < this.keyframes.length; i++) {\r\n      if (time < this.keyframes[i].time)\r\n        return {before: this.keyframes[i - 1], after: this.keyframes[i]};\r\n    }\r\n\r\n    // After the last keyframe\r\n    return {before: this.keyframes[this.keyframes.length - 1]};\r\n  }\r\n\r\n  public static fromJSON(json?: CameraPathProps): CameraPath {\r\n    if (!json)\r\n      return CameraPath.createEmpty();\r\n\r\n    return new CameraPath(\r\n      json.name,\r\n      json.duration,\r\n      json.keyframes.map((keyframeProps) => Keyframe.fromJSON(keyframeProps)),\r\n    );\r\n  }\r\n\r\n  public toJSON(): CameraPathProps {\r\n    return {\r\n      name: this.name,\r\n      duration: this.duration,\r\n      keyframes: this.keyframes.map((frame) => frame.toJSON()),\r\n    };\r\n  }\r\n}\r\n\r\nexport class CameraPathsMenu extends ToolBarDropDown {\r\n  private readonly _element: HTMLElement;\r\n  private readonly _viewport: Viewport;\r\n  private _imodel: IModelConnection;\r\n\r\n  private _paths: Array<CameraPath>;\r\n  private _selectedPath?: CameraPath | undefined;\r\n  private _onStateChanged = () => {};\r\n  private _newPathName: string;\r\n\r\n  private _isPlaying: boolean;\r\n  private _isRecording: boolean;\r\n\r\n  private _animID: number;\r\n  private _previousAnimationFrame: number | undefined;\r\n  private _currentAnimationTime: number;\r\n\r\n  public get selectedPath(): CameraPath | undefined {\r\n    return this._selectedPath;\r\n  }\r\n\r\n  public set selectedPath(value: CameraPath | undefined) {\r\n    this._selectedPath = value;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  public constructor(viewport: Viewport, parent: HTMLElement) {\r\n    super();\r\n\r\n    this._viewport = viewport;\r\n    this._imodel = viewport.iModel;\r\n\r\n    this._newPathName = \"\";\r\n    this._paths = [];\r\n\r\n    this._isPlaying = false;\r\n    this._isRecording = false;\r\n    this._animID = 0;\r\n    this._previousAnimationFrame = undefined;\r\n    this._currentAnimationTime = 0;\r\n\r\n    this._element = document.createElement(\"div\");\r\n    this._element.className = \"toolMenu\";\r\n    this._element.style.display = \"block\";\r\n    this._element.style.width = \"300px\";\r\n    this._element.style.overflowX = \"none\";\r\n\r\n    parent.appendChild(this._element);\r\n  }\r\n\r\n  public get isOpen() { return \"none\" !== this._element.style.display; }\r\n  protected _open() { this._element.style.display = \"block\"; }\r\n  protected _close() { this._element.style.display = \"none\"; }\r\n\r\n  public override get onViewChanged(): Promise<void> | undefined {\r\n    if (this._imodel !== this._viewport.iModel) {\r\n      this._imodel = this._viewport.iModel;\r\n      return this.populate();\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  public async populate(): Promise<void> {\r\n    if (!this._viewport.iModel.isOpen)\r\n      return;\r\n\r\n    await this.loadPathsFromExternalFile();\r\n\r\n    await this.populateFromPathList();\r\n  }\r\n\r\n  private async populateFromPathList(): Promise<void> {\r\n    this.clearContent();\r\n\r\n    const pathNameTextBox = createTextBox({\r\n      id: \"txt_pathName\",\r\n      parent: this._element,\r\n      tooltip: \"Name of new camera path to create\",\r\n      keypresshandler: async (_tb, ev): Promise<void> => {\r\n        ev.stopPropagation();\r\n        if (\"Enter\" === ev.key) {\r\n          if (await this.appendNewPathToPathList())\r\n            await this.savePathsToExternalFile();\r\n        }\r\n      },\r\n    });\r\n\r\n    pathNameTextBox.div.style.marginLeft = pathNameTextBox.div.style.marginRight = \"3px\";\r\n    pathNameTextBox.textbox.size = 36;\r\n    pathNameTextBox.textbox.value = this._newPathName;\r\n    this._element.appendChild(document.createElement(\"hr\"));\r\n\r\n    const pathsList = document.createElement(\"select\");\r\n    // If only 1 entry in list, input becomes a combo box and can't select the view...\r\n    pathsList.size = 1 === this._paths.length ? 2 : Math.min(15, this._paths.length);\r\n    pathsList.style.width = \"100%\";\r\n    pathsList.style.display = 0 < this._paths.length ? \"\" : \"none\";\r\n\r\n    this._element.appendChild(pathsList);\r\n    this._element.onchange = () => this.selectedPath = pathsList.value ? this.findPath(pathsList.value) : undefined;\r\n    pathsList.addEventListener(\"keyup\", async (ev) => {\r\n      if (ev.key === \"Delete\")\r\n        await this.deletePath();\r\n    });\r\n\r\n    for (const path of this._paths) {\r\n      const option = document.createElement(\"option\");\r\n      option.value = option.innerText = path.name;\r\n      if (path.duration === 0 || path.keyframes.length === 0) {\r\n        option.style.color = \"grey\";\r\n        option.title = \"This path is empty. Please use the record button to record it.\";\r\n      }\r\n      pathsList.appendChild(option);\r\n    }\r\n\r\n    const buttonDiv = document.createElement(\"div\");\r\n    buttonDiv.style.textAlign = \"center\";\r\n\r\n    const createPathButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_createCameraPath\",\r\n      value: \"Create\",\r\n      handler: async () => {\r\n        if (await this.appendNewPathToPathList())\r\n          await this.savePathsToExternalFile();\r\n      },\r\n      tooltip: \"Create a new camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const deletePathButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_deleteCameraPath\",\r\n      value: \"Delete\",\r\n      handler: async () => {\r\n        if (await this.deletePath())\r\n          await this.savePathsToExternalFile();\r\n      },\r\n      tooltip: \"Delete selected camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    buttonDiv.appendChild(document.createElement(\"hr\"));\r\n\r\n    const recordButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_recordCameraPath\",\r\n      value: \"Record\",\r\n      handler: async () => this.play(true),\r\n      tooltip: \"Record a camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const playButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_playCameraPath\",\r\n      value: \"Play\",\r\n      handler: async () => this.play(false),\r\n      tooltip: \"Play selected camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const stopButton = createButton({\r\n      parent: buttonDiv,\r\n      id: \"btn_stopCameraPath\",\r\n      value: \"Stop\",\r\n      handler: async () => this.stop(),\r\n      tooltip: \"Stop running camera path\",\r\n      inline: true,\r\n    }).button;\r\n\r\n    const setCreatePathButtonDisabled = () => {\r\n      const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\r\n      const isPathNameValid = this._newPathName.length > 0 && !pathExist;\r\n\r\n      pathNameTextBox.textbox.style.color = isPathNameValid ? \"\" : \"red\";\r\n      createPathButton.disabled = !isPathNameValid;\r\n    };\r\n\r\n    pathNameTextBox.textbox.onkeyup = () => {\r\n      this._newPathName = pathNameTextBox.textbox.value;\r\n      setCreatePathButtonDisabled();\r\n    };\r\n\r\n    this._onStateChanged = () => {\r\n      if (this.selectedPath === undefined) {\r\n        playButton.disabled = recordButton.disabled = stopButton.disabled = deletePathButton.disabled = true;\r\n        pathsList.disabled = false;\r\n      } else {\r\n        const canRecord = this.selectedPath.duration === 0 || this.selectedPath.keyframes.length === 0;\r\n        playButton.disabled = this._isPlaying || canRecord;\r\n        recordButton.disabled = this._isPlaying || !canRecord;\r\n        stopButton.disabled = !this._isPlaying;\r\n        pathsList.disabled = this._isPlaying;\r\n        deletePathButton.disabled = false;\r\n      }\r\n\r\n      setCreatePathButtonDisabled();\r\n    };\r\n\r\n    this._onStateChanged();\r\n\r\n    this._element.appendChild(buttonDiv);\r\n  }\r\n\r\n  private clearContent(): void {\r\n    while (this._element.hasChildNodes())\r\n      this._element.removeChild(this._element.firstChild!);\r\n    this._onStateChanged = () => {};\r\n  }\r\n\r\n  private async deletePath(): Promise<boolean> {\r\n    if (this.selectedPath === undefined)\r\n      return false;\r\n\r\n    const index = this._paths.indexOf(this.selectedPath);\r\n    if (index > -1) {\r\n      this._paths.splice(index, 1);\r\n      this.selectedPath = undefined;\r\n      await this.populateFromPathList();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private async appendNewPathToPathList(): Promise<boolean> {\r\n    const pathExist = this._paths.findIndex((path) => path.name === this._newPathName) !== -1;\r\n    if (this._newPathName.length > 0 && !pathExist) {\r\n      this._paths.push(CameraPath.createEmpty());\r\n      this.selectedPath = this._paths[this._paths.length - 1];\r\n      this.selectedPath.name = this._newPathName;\r\n      this._newPathName = \"\";\r\n      await this.populateFromPathList();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private async loadPathsFromExternalFile() {\r\n    const filename = this._viewport.view.iModel.key;\r\n    const externalCameraPathsString = await DtaRpcInterface.getClient().readExternalCameraPaths(filename);\r\n\r\n    try {\r\n      this._paths = JSON.parse(externalCameraPathsString).map((path: CameraPathProps) => CameraPath.fromJSON(path));\r\n    } catch (_e) {\r\n      this._paths = [];\r\n    }\r\n  }\r\n\r\n  private async savePathsToExternalFile(): Promise<void> {\r\n    const filename = this._viewport.view.iModel.key;\r\n    if (undefined === filename)\r\n      return;\r\n\r\n    const namedViews = JSON.stringify(this._paths.map((path) => path.toJSON()));\r\n    await DtaRpcInterface.getClient().writeExternalCameraPaths(filename, namedViews);\r\n  }\r\n\r\n  private findPath(name: string): CameraPath | undefined {\r\n    const index = this._paths.findIndex((path) => name === path.name);\r\n    return -1 !== index ? this._paths[index]! : undefined;\r\n\r\n  }\r\n\r\n  public prepareView(record = false): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    this._viewport.setAnimator(undefined);\r\n\r\n    if (!record) {\r\n      // This line prevents a bug that occurs in orthographic views if no camera has been set before.\r\n      // If not using a perspective camera, it will be turned off at the first frame.\r\n      this._viewport.turnCameraOn();\r\n    }\r\n\r\n    this._viewport.synchWithView();\r\n  }\r\n\r\n  public play(record = false): void {\r\n    if (this._isPlaying)\r\n      this.stop();\r\n\r\n    this._previousAnimationFrame = undefined;\r\n    this._currentAnimationTime = 0;\r\n\r\n    if (this.selectedPath === undefined)\r\n      return;\r\n\r\n    this.selectedPath.sortKeyframes();\r\n\r\n    const animate = (timestamp: number) => {\r\n      const elapsed = this._previousAnimationFrame ? timestamp - this._previousAnimationFrame : 0;\r\n      this._currentAnimationTime += elapsed;\r\n\r\n      this.computeAnimationFrame();\r\n\r\n      this._previousAnimationFrame = timestamp;\r\n\r\n      if (this._isPlaying)\r\n        this._animID = requestAnimationFrame(animate);\r\n    };\r\n\r\n    this.prepareView(record);\r\n    this._animID = requestAnimationFrame(animate);\r\n\r\n    this._isPlaying = true;\r\n    this._isRecording = record;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  public stop(): void {\r\n\r\n    if (this._animID) {\r\n      cancelAnimationFrame(this._animID);\r\n    }\r\n\r\n    // End of recording\r\n    if (this._isPlaying && this._isRecording) {\r\n      if (!this.selectedPath)\r\n        throw new Error(\"No valid camera path loaded\");\r\n\r\n      this.selectedPath.duration = this._currentAnimationTime;\r\n\r\n      // Remove keyframes that we can easily interpolate with a decent error range\r\n      this.selectedPath.simplifies(0.005, Angle.createDegrees(1.0), 0.01);\r\n\r\n      void this.savePathsToExternalFile();\r\n      void this.populateFromPathList();\r\n    }\r\n\r\n    this._animID = 0;\r\n    this._isPlaying = false;\r\n    this._isRecording = false;\r\n    this._currentAnimationTime = 0;\r\n    this._previousAnimationFrame = undefined;\r\n    this._onStateChanged();\r\n  }\r\n\r\n  private computeAnimationFrame(): void {\r\n    if (!this.selectedPath) {\r\n      this.endAnimation();\r\n      return;\r\n    }\r\n\r\n    if (this._isRecording) {\r\n      this.recordAnimationFrame();\r\n    } else {\r\n      this.playAnimationFrame();\r\n\r\n      if (this._currentAnimationTime > this.selectedPath.duration)\r\n        this.endAnimation();\r\n    }\r\n\r\n  }\r\n\r\n  private playAnimationFrame(): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    this._viewport.setAnimator(undefined);\r\n    const keyframe = this.selectedPath.getKeyframeAtTime(this._currentAnimationTime);\r\n    this.setCameraPosition(keyframe);\r\n  }\r\n\r\n  private recordAnimationFrame(): void {\r\n    if (!this.selectedPath)\r\n      throw new Error(\"No valid camera path loaded\");\r\n\r\n    const view = this._viewport.view;\r\n    if (!view.is3d() || !view.supportsCamera())\r\n      throw new Error(\"Invalid view for camera path\");\r\n\r\n    // TODO: Handle global coordinates\r\n    const location = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 1.0));\r\n    const target = this._viewport.npcToWorld(new Point3d(0.5, 0.5, 0.0));\r\n\r\n    // Location and target are the same, the keyframe will be invalid\r\n    if (target.distance(location) <= Number.EPSILON)\r\n      return;\r\n\r\n    const topScreen = this._viewport.npcToWorld(new Point3d(0.5, 1.0, 0.0));\r\n    const up = location.unitVectorTo(topScreen);\r\n    if (up === undefined)\r\n      return;\r\n\r\n    const lensAngle = view.isCameraOn ? view.camera.getLensAngle().clone() : undefined;\r\n    const extents = view.isCameraOn ? undefined : view.getExtents().clone();\r\n\r\n    this.selectedPath.keyframes.push(new Keyframe(this._currentAnimationTime, location, target, up, lensAngle, extents));\r\n  }\r\n\r\n  private endAnimation(): void {\r\n    this.stop();\r\n  }\r\n\r\n  private setCameraPosition(keyframe: Keyframe) {\r\n    const view = this._viewport.view;\r\n    if (!view.is3d() || !view.supportsCamera())\r\n      throw new Error(\"Invalid view for camera path\");\r\n\r\n    // TODO: Handle global coordinates\r\n    if (keyframe.lensAngle !== undefined) {\r\n      const lensAngle = keyframe.lensAngle.clone();\r\n      Camera.validateLensAngle(lensAngle);\r\n\r\n      // Perspective\r\n      view.lookAt(\r\n        {\r\n          eyePoint: keyframe.location,\r\n          targetPoint: keyframe.target,\r\n          upVector: keyframe.up,\r\n          lensAngle,\r\n        },\r\n      );\r\n\r\n    } else {\r\n      if (keyframe.extents === undefined)\r\n        throw new Error(\"Invalid keyframe for camera: path should specifies either lensAngle or extents.\");\r\n\r\n      // Orthographic camera\r\n      view.lookAt(\r\n        {\r\n          eyePoint: keyframe.location,\r\n          viewDirection: (keyframe.target.minus(keyframe.location)),\r\n          upVector: keyframe.up,\r\n          newExtents: keyframe.extents,\r\n        },\r\n      );\r\n    }\r\n\r\n    this._viewport.synchWithView({noSaveInUndo: true});\r\n  }\r\n}\r\n"
        ],
        "mappings": "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",
        "names": []
      }
    }
  ]
}
