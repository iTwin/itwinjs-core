{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/StrokeOptions.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\n/* eslint-disable @typescript-eslint/naming-convention, no-empty */\n/**\n * Tolerance blob for various stroking methods.\n *\n * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength\n * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.\n * * angle is the angle between two contiguous strokes or across a facet edge.\n * * maxEdgeLength is the length of a stroke or a edge of a facet.\n *\n * It is rare for all three to be active at once:\n * * Nearly all stroke and facet use cases will apply an angle tolerance.\n * * * For curves, 15 degrees is typical\n * * * For facets, 22.5 degrees is typical.\n * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.\n * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.\n * * When creating output for devices such as 3D printing will want a chord tolerance.\n * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.\n * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.\n * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the small number of long quads usually used for graphics.\n * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.\n * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.\n * @public\n */\nexport class StrokeOptions {\n    constructor() {\n        /** Whether or not to triangulate each added facet */\n        this.shouldTriangulate = false;\n        /** Default number of strokes for a circle. */\n        this.defaultCircleStrokes = 16;\n    }\n    /** Whether params are requested. */\n    get needParams() {\n        return this._needParams !== undefined ? this._needParams : false;\n    }\n    set needParams(value) {\n        this._needParams = value;\n    }\n    /** Whether normals are requested */\n    get needNormals() {\n        return this._needNormals !== undefined ? this._needNormals : false;\n    }\n    set needNormals(value) {\n        this._needNormals = value;\n    }\n    /** Whether twoSided is requested. */\n    get needTwoSided() {\n        return this._needTwoSided !== undefined ? this._needTwoSided : false;\n    }\n    set needTwoSided(value) {\n        this._needTwoSided = value;\n    }\n    /** Ask if angleTol is specified */\n    get hasAngleTol() {\n        return this.angleTol !== undefined && Math.abs(this.angleTol.radians) > 0.0;\n    }\n    /** Ask if chordTol is specified */\n    get hasChordTol() {\n        return this.chordTol !== undefined && this.chordTol > 0.0;\n    }\n    /** Ask if maxEdgeLength is specified */\n    get hasMaxEdgeLength() {\n        return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0;\n    }\n    /** Return a deep clone  */\n    clone() {\n        const options = new StrokeOptions();\n        options.chordTol = this.chordTol;\n        options.angleTol = this.angleTol?.clone();\n        options.maxEdgeLength = this.maxEdgeLength;\n        options.needConvexFacets = this.needConvexFacets;\n        options.minStrokesPerPrimitive = this.minStrokesPerPrimitive;\n        options.shouldTriangulate = this.shouldTriangulate;\n        options._needNormals = this._needNormals;\n        options._needTwoSided = this._needTwoSided;\n        options._needParams = this._needParams;\n        options.needColors = this.needColors;\n        options.defaultCircleStrokes = this.defaultCircleStrokes;\n        return options;\n    }\n    /** Return stroke count which is the larger of the minCount or count needed for edge length condition. */\n    applyMaxEdgeLength(minCount, totalLength) {\n        totalLength = Math.abs(totalLength);\n        if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {\n            minCount = Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);\n        }\n        return minCount;\n    }\n    /**\n     * Return stroke count which is the larger of the existing count or count needed for angle condition for given\n     * sweepRadians.\n     * * defaultStepRadians is assumed to be larger than zero.\n     */\n    applyAngleTol(minCount, sweepRadians, defaultStepRadians) {\n        return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);\n    }\n    /**\n     * Return stroke count which is the larger of minCount and the count required to turn sweepRadians, using tolerance\n     * from the options.\n     */\n    static applyAngleTol(options, minCount, sweepRadians, defaultStepRadians) {\n        sweepRadians = Math.abs(sweepRadians);\n        let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;\n        if (options && options.angleTol && options.angleTol.radians > 0.0)\n            stepRadians = options.angleTol.radians;\n        if (minCount * stepRadians < sweepRadians)\n            minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\n        return minCount;\n    }\n    /**\n     * Return the number of strokes needed for given edgeLength curve.\n     * @param options\n     * @param minCount smallest allowed count\n     * @param edgeLength\n     */\n    static applyMaxEdgeLength(options, minCount, edgeLength) {\n        if (edgeLength < 0)\n            edgeLength = -edgeLength;\n        if (minCount < 1)\n            minCount = 1;\n        if (options && options.maxEdgeLength && options.maxEdgeLength * minCount < edgeLength) {\n            minCount = Geometry.stepCount(options.maxEdgeLength, edgeLength, minCount);\n        }\n        return minCount;\n    }\n    /**\n     * Determine a stroke count for a (partial) circular arc of given radius. This considers angle, maxEdgeLength,\n     * chord, and minimum stroke.\n     */\n    applyTolerancesToArc(radius, sweepRadians = Math.PI * 2) {\n        let numStrokes = 1;\n        numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);\n        numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);\n        numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);\n        numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);\n        return numStrokes;\n    }\n    /** Return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition. */\n    applyChordTol(minCount, radius, sweepRadians) {\n        if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {\n            const a = this.chordTol;\n            const stepRadians = 2.0 * Math.acos((1.0 - a / radius));\n            minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\n        }\n        return minCount;\n    }\n    /**\n     * Return stroke count which is the larger of existing count or count needed for circular arc chord tol with given\n     * arc length and radians\n     */\n    applyChordTolToLengthAndRadians(minCount, length, sweepRadians) {\n        if (this.chordTol && this.chordTol > 0.0) {\n            const radius = Geometry.conditionalDivideFraction(length, sweepRadians);\n            if (radius !== undefined)\n                return this.applyChordTol(minCount, radius, sweepRadians);\n        }\n        return minCount;\n    }\n    /** Return stroke count which is the larger of existing count or `this.minStrokesPerPrimitive` */\n    applyMinStrokesPerPrimitive(minCount) {\n        if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)\n            && this.minStrokesPerPrimitive > minCount)\n            minCount = this.minStrokesPerPrimitive;\n        return minCount;\n    }\n    /**\n     * Create `StrokeOptions` with defaults appropriate for curves.\n     * * angle tolerance of 15 degrees.\n     * * all others inactive.\n     */\n    static createForCurves() {\n        const options = new StrokeOptions();\n        options.angleTol = Angle.createDegrees(15.0);\n        return options;\n    }\n    /**\n     * Create `StrokeOptions` with defaults appropriate for surfaces facets\n     * * angle tolerance of 22.5 degrees.\n     * * all others inactive.\n     */\n    static createForFacets() {\n        const options = new StrokeOptions();\n        options.angleTol = Angle.createDegrees(22.5);\n        return options;\n    }\n}\n//# sourceMappingURL=StrokeOptions.js.map",
      "start": 1693508123705,
      "end": 1693508123818,
      "sourcemaps": null
    }
  ]
}
