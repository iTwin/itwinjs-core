{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/TileTreeReference.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, BeTimePoint } from \"@itwin/core-bentley\";\nimport { Range3d } from \"@itwin/core-geometry\";\nimport { PlanarClipMaskPriority } from \"@itwin/core-common\";\nimport { TileDrawArgs, TileTreeLoadStatus, } from \"./internal\";\n/** Describes the type of graphics produced by a [[TileTreeReference]].\n * @public\n * @extensions\n */\nexport var TileGraphicType;\n(function (TileGraphicType) {\n    /** Rendered behind all other geometry without depth. */\n    TileGraphicType[TileGraphicType[\"BackgroundMap\"] = 0] = \"BackgroundMap\";\n    /** Rendered with normal scene graphics. */\n    TileGraphicType[TileGraphicType[\"Scene\"] = 1] = \"Scene\";\n    /** Rendered in front of all other geometry. */\n    TileGraphicType[TileGraphicType[\"Overlay\"] = 2] = \"Overlay\";\n})(TileGraphicType || (TileGraphicType = {}));\n/** A reference to a [[TileTree]] suitable for drawing within a [[Viewport]]. The reference does not *own* its tile tree - it merely refers to it by\n * way of the tree's [[TileTreeOwner]].\n * The specific [[TileTree]] referenced by this object may change based on the current state of the Viewport in which it is drawn - for example,\n * as a result of changing the RenderMode, or animation settings, or classification settings, etc.\n * A reference to a TileTree is typically associated with a [[ViewState]], a [[DisplayStyleState]], or a [[Viewport]].\n * Multiple TileTreeReferences can refer to the same TileTree with different parameters and logic - for example, the same background map tiles can be displayed in two viewports with\n * differing levels of transparency.\n * @see [[TiledGraphicsProvider]] to supply custom [[TileTreeReference]]s to be drawn within a [[Viewport]].\n * @public\n * @extensions\n */\nexport class TileTreeReference /* implements RenderMemory.Consumer */ {\n    /** Force a new tree owner / tile tree to be created for the current tile tree reference\n    /* @internal */\n    resetTreeOwner() { }\n    /** Disclose *all* TileTrees use by this reference. This may include things like map tiles used for draping on terrain.\n     * Override this and call super if you have such auxiliary trees.\n     * @note Any tree *NOT* disclosed becomes a candidate for *purging* (being unloaded from memory along with all of its tiles and graphics).\n     */\n    discloseTileTrees(trees) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree)\n            trees.add(tree);\n    }\n    /** Adds this reference's graphics to the scene. By default this invokes [[draw]]. */\n    addToScene(context) {\n        const args = this.createDrawArgs(context);\n        if (undefined !== args)\n            this.draw(args);\n    }\n    /** Adds this reference's graphics to the scene. By default this invokes [[TileTree.draw]] on the referenced TileTree, if it is loaded. */\n    draw(args) {\n        args.tree.draw(args);\n    }\n    /** Optionally return a tooltip describing the hit. */\n    async getToolTip(_hit) { return undefined; }\n    /** Optionally return a MapLayerFeatureInfo object describing the hit.].\n     * @alpha\n     */\n    async getMapFeatureInfo(_hit) { return undefined; }\n    /** Optionally add any decorations specific to this reference. For example, map tile trees may add a logo image and/or copyright attributions.\n     * @note This is currently only invoked for background maps and TiledGraphicsProviders - others have no decorations, but if they did implement this it would not be called.\n     */\n    decorate(_context) { }\n    /** Unions this reference's range with the supplied range to help compute a volume in world space for fitting a viewport to its contents.\n     * Override this function if a reference's range should not be included in the fit range, or a range different from its tile tree's range should be used.\n     */\n    unionFitRange(union) {\n        const contentRange = this.computeWorldContentRange();\n        if (!contentRange.isNull)\n            union.extendRange(contentRange);\n    }\n    /** Record graphics memory consumed by this tile tree reference. */\n    collectStatistics(stats) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree)\n            tree.collectStatistics(stats);\n    }\n    /** Return true if the tile tree is fully loaded and ready to draw.\n     * The default implementation returns true if the tile tree loading process completed (whether it resulted in success or failure).\n     * @note Do *not* override this property - override [[_isLoadingComplete]] instead..\n     * @public\n     */\n    get isLoadingComplete() {\n        switch (this.treeOwner.loadStatus) {\n            case TileTreeLoadStatus.NotLoaded:\n            case TileTreeLoadStatus.Loading:\n                return false;\n            case TileTreeLoadStatus.NotFound:\n                return true; // we tried, and failed, to load.\n            case TileTreeLoadStatus.Loaded:\n                return this._isLoadingComplete;\n        }\n    }\n    /** Override if additional asynchronous loading is required after the tile tree is successfully loaded, to indicate when that loading has completed.\n     * @public\n     */\n    get _isLoadingComplete() {\n        return true;\n    }\n    /** Create context for drawing the tile tree, if it is ready for drawing.\n     * TileTreeReferences can override individual portions of the context, e.g. apply their own transform.\n     * Returns undefined if, e.g., the tile tree is not yet loaded.\n     */\n    createDrawArgs(context) {\n        const tree = this.treeOwner.load();\n        if (undefined === tree)\n            return undefined;\n        return new TileDrawArgs({\n            context,\n            tree,\n            now: BeTimePoint.now(),\n            location: this.computeTransform(tree),\n            viewFlagOverrides: this.getViewFlagOverrides(tree),\n            clipVolume: this.getClipVolume(tree),\n            parentsAndChildrenExclusive: tree.parentsAndChildrenExclusive,\n            symbologyOverrides: this.getSymbologyOverrides(tree),\n            appearanceProvider: this.getAppearanceProvider(tree),\n            hiddenLineSettings: this.getHiddenLineSettings(tree),\n            animationTransformNodeId: this.getAnimationTransformNodeId(tree),\n        });\n    }\n    /** @internal */\n    getAnimationTransformNodeId(_tree) {\n        return undefined;\n    }\n    /** Supply transform from this tile tree reference's location to iModel coordinate space.\n     * @returns undefined if the TileTree is not yet loaded.\n     */\n    getLocation() {\n        const tree = this.treeOwner.load();\n        return undefined !== tree ? this.computeTransform(tree) : undefined;\n    }\n    /** Compute a transform from this tile tree reference's coordinate space to the [[IModelConnection]]'s coordinate space. */\n    computeTransform(tree) {\n        return tree.iModelTransform.clone();\n    }\n    /** Compute the range of this tile tree's contents in world coordinates.\n     * @returns The content range in world coodinates, or a null range if the tile tree is not loaded or has a null content range.\n     */\n    computeWorldContentRange() {\n        const range = new Range3d();\n        const tree = this.treeOwner.tileTree;\n        if (undefined !== tree && !tree.rootTile.contentRange.isNull)\n            this.computeTransform(tree).multiplyRange(tree.rootTile.contentRange, range);\n        return range;\n    }\n    /** Return the clip volume applied to this reference's tile tree, if any. */\n    getClipVolume(tree) {\n        return tree.clipVolume;\n    }\n    /** Supply overrides that should be applied to the [[ViewState]]'s [ViewFlags]($common) when drawing this tile tree reference. */\n    getViewFlagOverrides(tree) {\n        return tree.viewFlagOverrides;\n    }\n    /** Return overrides that *replace* any defined for the view. */\n    getSymbologyOverrides(_tree) {\n        return undefined;\n    }\n    /** Return a provider that can supplement the view's symbology overrides. */\n    getAppearanceProvider(_tree) {\n        return undefined;\n    }\n    /** Return hidden line settings to replace those defined for the view. */\n    getHiddenLineSettings(_tree) {\n        return undefined;\n    }\n    /* Extend range to include transformed range of this tile tree.\n     * @internal\n     */\n    accumulateTransformedRange(range, matrix, frustumPlanes) {\n        const tree = this.treeOwner.tileTree;\n        if (undefined === tree)\n            return;\n        const location = this.computeTransform(tree);\n        tree.accumulateTransformedRange(range, matrix, location, frustumPlanes);\n    }\n    /** @internal */\n    getTerrainHeight(_terrainHeights) { }\n    /** Return whether the geometry exposed by this tile tree reference should cast shadows on other geometry. */\n    get castsShadows() {\n        return true;\n    }\n    /** Return whether this reference has global coverage.  Mapping data is global and some non-primary models such as the OSM building layer have global coverage */\n    get isGlobal() { return false; }\n    /**  Return the clip mask priority for this model - models will be clipped by any other viewed model with a higher proirity.\n     * BIM models have highest prioirty and are never clipped.\n     * @alpha\n     */\n    get planarclipMaskPriority() { return PlanarClipMaskPriority.DesignModel; }\n    /** Add attribution logo cards for the tile tree source logo cards to the viewport's logo div. */\n    addLogoCards(_cards, _vp) { }\n    /** Create a tile tree reference equivalent to this one that also supplies an implementation of [[GeometryTileTreeReference.collectTileGeometry]].\n     * Return `undefined` if geometry collection is not supported.\n     * @see [[createGeometryTreeReference]].\n     * @beta\n     */\n    _createGeometryTreeReference() {\n        return undefined;\n    }\n    /** A function that can be assigned to [[collectTileGeometry]] to enable geometry collection for references to tile trees that support geometry collection.\n     * @beta\n     */\n    _collectTileGeometry(collector) {\n        const tree = this.treeOwner.load();\n        switch (this.treeOwner.loadStatus) {\n            case TileTreeLoadStatus.Loaded:\n                assert(undefined !== tree);\n                tree.collectTileGeometry(collector);\n                break;\n            case TileTreeLoadStatus.Loading:\n                collector.markLoading();\n                break;\n        }\n    }\n    /** Obtain a tile tree reference equivalent to this one that also supplies an implementation of [[GeometryTileTreeReference.collectTileGeometry]], or\n     * undefined if geometry collection is not supported.\n     * Currently, only terrain and reality model tiles support geometry collection.\n     * @note Do not override this method - override [[_createGeometryTreeReference]] instead.\n     * @beta\n     */\n    createGeometryTreeReference() {\n        if (this.collectTileGeometry) {\n            // Unclear why compiler doesn't detect that `this` satisfies the GeometryTileTreeReference interface...it must be looking only at the types, not this particular instance.\n            return this;\n        }\n        return this._createGeometryTreeReference();\n    }\n}\n//# sourceMappingURL=TileTreeReference.js.map",
      "start": 1693508121631,
      "end": 1693508121778,
      "sourcemaps": null
    }
  ]
}
