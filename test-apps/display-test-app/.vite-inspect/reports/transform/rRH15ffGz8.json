{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/internalContexts/PlaneAltitudeRangeContext.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { Geometry } from \"../../Geometry\";\nimport { Angle } from \"../../geometry3d/Angle\";\nimport { RecurseToCurvesGeometryHandler } from \"../../geometry3d/GeometryHandler\";\nimport { GrowableXYZArray } from \"../../geometry3d/GrowableXYZArray\";\nimport { Plane3dByOriginAndUnitNormal } from \"../../geometry3d/Plane3dByOriginAndUnitNormal\";\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\nimport { Range1d } from \"../../geometry3d/Range\";\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\nimport { GeometryQuery } from \"../GeometryQuery\";\nimport { LineSegment3d } from \"../LineSegment3d\";\nimport { LineString3d } from \"../LineString3d\";\nimport { StrokeOptions } from \"../StrokeOptions\";\n/**\n * Accumulator context for searching for extrema of geometry along a plane.\n * @internal\n */\nexport class PlaneAltitudeRangeContext extends RecurseToCurvesGeometryHandler {\n    constructor(plane) {\n        super();\n        this.plane = plane;\n        this.range = Range1d.createNull();\n        this.resetRange();\n    }\n    resetRange() {\n        this.range.setNull();\n    }\n    announcePoint(point) {\n        const h = this.plane.altitude(point);\n        if (this.range.extendLow(h))\n            this.lowPoint = point.clone(this.lowPoint);\n        if (this.range.extendHigh(h))\n            this.highPoint = point.clone(this.highPoint);\n    }\n    announcePoints(points) {\n        for (let i = 0; i < points.length; i++) {\n            const h = points.evaluateUncheckedIndexPlaneAltitude(i, this.plane);\n            if (this.range.extendLow(h))\n                this.lowPoint = points.getPoint3dAtUncheckedPointIndex(i, this.lowPoint);\n            if (this.range.extendHigh(h))\n                this.highPoint = points.getPoint3dAtUncheckedPointIndex(i, this.highPoint);\n        }\n    }\n    static createCapture(plane) {\n        const context = new PlaneAltitudeRangeContext(plane);\n        return context;\n    }\n    handleLineSegment3d(segment) {\n        this.announcePoint(segment.point0Ref);\n        this.announcePoint(segment.point1Ref);\n    }\n    handleLineString3d(lineString) {\n        this.announcePoints(lineString.packedPoints);\n    }\n    initStrokeOptions() {\n        // TODO: compute the exact extrema; until then stroke aggressively\n        if (undefined === this._strokeOptions) {\n            this._strokeOptions = new StrokeOptions();\n            this._strokeOptions.angleTol = Angle.createDegrees(1);\n        }\n    }\n    handleBSplineCurve3d(bcurve) {\n        // ugh.   The point MUST be on the curve -- usual excess-range of poles is not ok.\n        this.initStrokeOptions();\n        const ls = LineString3d.create();\n        bcurve.emitStrokes(ls, this._strokeOptions);\n        this.handleLineString3d(ls);\n    }\n    handleBSplineCurve3dH(bcurve) {\n        // ugh.   The point MUST be on the curve -- usual excess-range of poles is not ok.\n        this.initStrokeOptions();\n        const ls = LineString3d.create();\n        bcurve.emitStrokes(ls, this._strokeOptions);\n        this.handleLineString3d(ls);\n    }\n    handleArc3d(g) {\n        this._sineCosinePolynomial = g.getPlaneAltitudeSineCosinePolynomial(this.plane, this._sineCosinePolynomial);\n        let radians = this._sineCosinePolynomial.referenceMinMaxRadians();\n        if (g.sweep.isRadiansInSweep(radians))\n            this.announcePoint((this._workPoint = g.radiansToPoint(radians, this._workPoint)));\n        radians += Math.PI;\n        if (g.sweep.isRadiansInSweep(radians))\n            this.announcePoint((this._workPoint = g.radiansToPoint(radians, this._workPoint)));\n        this.announcePoint((this._workPoint = g.startPoint(this._workPoint)));\n        this.announcePoint((this._workPoint = g.endPoint(this._workPoint)));\n    }\n    static findExtremesInDirection(geometry, direction) {\n        const origin = direction instanceof Ray3d ? direction.origin : Point3d.createZero();\n        const vector = direction instanceof Ray3d ? direction.direction : direction;\n        const plane = Plane3dByOriginAndUnitNormal.create(origin, vector); // vector is normalized, so altitudes are distances\n        if (plane) {\n            const context = new PlaneAltitudeRangeContext(plane);\n            if (geometry instanceof GeometryQuery) {\n                geometry.dispatchToGeometryHandler(context);\n            }\n            else if (geometry instanceof GrowableXYZArray) {\n                context.announcePoints(geometry);\n            }\n            else {\n                for (const pt of geometry)\n                    context.announcePoint(pt);\n            }\n            return context;\n        }\n        return undefined;\n    }\n    /**\n     * Compute altitudes for the geometry (via dispatch) over the plane defined by the given direction, and\n     * return points at min and max altitude, packed into a `LineSegment3d`.\n     * @param geometry geometry to project\n     * @param direction vector or ray on which to project the instance. A `Vector3d` is treated as a `Ray3d` with\n     * zero origin.\n     * @param lowHigh optional receiver for output\n    */\n    static findExtremePointsInDirection(geometry, direction, lowHigh) {\n        const context = this.findExtremesInDirection(geometry, direction);\n        if (context && context.highPoint && context.lowPoint)\n            return LineSegment3d.create(context.lowPoint, context.highPoint, lowHigh);\n        return undefined;\n    }\n    /**\n     * Compute altitudes for the geometry (via dispatch) over the plane defined by the given direction, and return\n     * the min and max altitudes, packed into a Range1d.\n     * @param geometry geometry to project\n     * @param direction vector or ray on which to project the instance. A `Vector3d` is treated as a `Ray3d` with\n     * zero origin.\n     * @param lowHigh optional receiver for output\n    */\n    static findExtremeAltitudesInDirection(geometry, direction, lowHigh) {\n        const context = this.findExtremesInDirection(geometry, direction);\n        if (context && !context.range.isNull)\n            return Range1d.createFrom(context.range, lowHigh);\n        return undefined;\n    }\n    /**\n     * Project geometry (via dispatch) onto the given ray, and return the extreme fractional parameters of projection.\n     * @param geometry geometry to project\n     * @param direction vector or ray onto which the instance is projected. A `Vector3d` is treated as a `Ray3d` with\n     * zero origin.\n     * @param lowHigh optional receiver for output\n     */\n    static findExtremeFractionsAlongDirection(geometry, direction, lowHigh) {\n        const range = this.findExtremeAltitudesInDirection(geometry, direction, lowHigh);\n        if (undefined !== range) {\n            const mag = (direction instanceof Vector3d) ? direction.magnitude() : direction.direction.magnitude();\n            const scaleToFraction = Geometry.conditionalDivideCoordinate(1.0, mag);\n            if (undefined !== scaleToFraction) {\n                range.low *= scaleToFraction;\n                range.high *= scaleToFraction;\n                return range;\n            }\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=PlaneAltitudeRangeContext.js.map",
      "start": 1693508125190,
      "end": 1693508125367,
      "sourcemaps": null
    }
  ]
}
