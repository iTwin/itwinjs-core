{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/RealityMeshParams.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, Uint16ArrayBuilder, UintArrayBuilder } from \"@itwin/core-bentley\";\nimport { IndexedPolyface, Point2d, Point3d, Range2d, Vector3d, } from \"@itwin/core-geometry\";\nimport { OctEncodedNormal, QPoint2d, QPoint2dBufferBuilder, QPoint3d, QPoint3dBufferBuilder, } from \"@itwin/core-common\";\nimport { MeshPrimitiveType } from \"../common/render/primitives/MeshPrimitive\";\nfunction precondition(condition, message) {\n    if (condition)\n        return;\n    if (\"string\" !== typeof message)\n        message = message();\n    throw new Error(`Logic Error: ${message}`);\n}\n/** @public */\nexport var RealityMeshParams;\n(function (RealityMeshParams) {\n    /** @internal */\n    function fromGltfMesh(mesh) {\n        // The specialized reality mesh shaders expect a mesh with uvs and no edges.\n        if (mesh.primitive.type !== MeshPrimitiveType.Mesh || mesh.primitive.edges || !mesh.pointQParams || !mesh.uvQParams || !mesh.points || !mesh.uvs || !mesh.indices)\n            return undefined;\n        return {\n            indices: mesh.indices,\n            positions: {\n                params: mesh.pointQParams,\n                points: mesh.points,\n            },\n            uvs: {\n                params: mesh.uvQParams,\n                points: mesh.uvs,\n            },\n            normals: mesh.normals,\n            // featureID: 0,\n            texture: mesh.primitive.displayParams.textureMapping?.texture,\n        };\n    }\n    RealityMeshParams.fromGltfMesh = fromGltfMesh;\n    /** @alpha */\n    function toPolyface(params, options) {\n        const { positions, normals, uvs, indices } = params;\n        const includeNormals = options?.wantNormals && undefined !== normals;\n        const includeParams = options?.wantParams;\n        const polyface = IndexedPolyface.create(includeNormals, includeParams);\n        const points = positions.points;\n        const point = new Point3d();\n        const transform = options?.transform;\n        for (let i = 0; i < positions.points.length; i += 3) {\n            positions.params.unquantize(points[i], points[i + 1], points[i + 2], point);\n            transform?.multiplyPoint3d(point, point);\n            polyface.addPoint(point);\n        }\n        if (includeNormals) {\n            const normal = new Vector3d();\n            for (const oen of normals)\n                polyface.addNormal(OctEncodedNormal.decodeValue(oen, normal));\n        }\n        if (includeParams) {\n            const uv = new Point2d();\n            for (let i = 0; i < uvs.points.length; i += 2)\n                polyface.addParam(uvs.params.unquantize(uvs.points[i], uvs.points[i + 1], uv));\n        }\n        let j = 0;\n        indices.forEach((index) => {\n            polyface.addPointIndex(index);\n            if (includeNormals)\n                polyface.addNormalIndex(index);\n            if (includeParams)\n                polyface.addParamIndex(index);\n            if (0 === (++j % 3))\n                polyface.terminateFacet();\n        });\n        return polyface;\n    }\n    RealityMeshParams.toPolyface = toPolyface;\n})(RealityMeshParams || (RealityMeshParams = {}));\n/** Incrementally constructs a [[RealityMeshParams]].\n * The following simple example produces a rectangular mesh containing two triangles.\n * ```ts\n * [[include:Build_Reality_Mesh_Params]]\n * ```\n * @beta\n */\nexport class RealityMeshParamsBuilder {\n    /** Construct a builder from the specified options. */\n    constructor(options) {\n        // Scratch variables\n        this._q3d = new QPoint3d();\n        this._q2d = new QPoint2d();\n        let initialType;\n        if (undefined !== options.initialVertexCapacity && options.initialVertexCapacity > 0xff)\n            initialType = options.initialVertexCapacity > 0xffff ? Uint32Array : Uint16Array;\n        this.indices = new UintArrayBuilder({\n            initialCapacity: options.initialIndexCapacity,\n            initialType,\n        });\n        if (options.wantNormals)\n            this.normals = new Uint16ArrayBuilder({ initialCapacity: options.initialVertexCapacity });\n        this.positions = new QPoint3dBufferBuilder({\n            range: options.positionRange,\n            initialCapacity: options.initialVertexCapacity,\n        });\n        this.uvs = new QPoint2dBufferBuilder({\n            range: options.uvRange ?? new Range2d(0, 0, 1, 1),\n            initialCapacity: options.initialVertexCapacity,\n        });\n    }\n    /** Add a vertex to the mesh and return its index in [[positions]].\n     * @param position The 3d position, which will be quantized to the [[RealityMeshParamsBuilderOptions.positionRange]] supplied to the builder's constructor.\n     * @param uv The texture coordinates, which will be quantized to the [[RealityMeshParamsBuilderOptions.uvRange]] supplied to the builder's constructor.\n     * @param the normal vector, to be supplied if and only if [[RealityMeshParamsBuilderOptions.wantNormals]] was `true` when the builder was constructed.\n     * @see [[addQuantizedVertex]] if your vertex data is already quantized.\n     * @returns the index of the new vertex in [[positions]].\n     */\n    addUnquantizedVertex(position, uv, normal) {\n        this._q3d.init(position, this.positions.params);\n        this._q2d.init(uv, this.uvs.params);\n        const oen = normal ? OctEncodedNormal.encode(normal) : undefined;\n        return this.addQuantizedVertex(this._q3d, this._q2d, oen);\n    }\n    /** Original API had weird mix of quantized and unquantized, used by CesiumTerrainProvider.\n     * @internal\n     */\n    addVertex(position, uv, normal) {\n        this._q3d.init(position, this.positions.params);\n        this.addQuantizedVertex(this._q3d, uv, normal);\n    }\n    /** Add a vertex to the mesh and return its index in [[positions]].\n     * @param position The 3d position, quantized to the [[RealityMeshParamsBuilderOptions.positionRange]] supplied to the builder's constructor.\n     * @param uv The texture coordinates, quantized to the [[RealityMeshParamsBuilderOptions.uvRange]] supplied to the builder's constructor.\n     * @param normal The unsigned 16-bit [OctEncodedNormal]($common) integer representation of the normal vector, to be supplied if and only if\n     * [[RealityMeshParamsBuilderOptions.wantNormals]] was `true` when the builder was constructed.\n     * @see [[addUnquantizedVertex]] if your vertex data is not already quantized.\n     * @returns the index of the new vertex in [[positions]].\n     * @throws Error if `normal` is `undefined` but `wantNormals` was specified at construction of the builder, or vice-versa.\n     */\n    addQuantizedVertex(position, uv, normal) {\n        precondition((undefined === normal) === (undefined === this.normals), \"RealityMeshParams requires all vertices to have normals, or none.\");\n        this.positions.push(position);\n        this.uvs.push(uv);\n        if (undefined !== normal) {\n            assert(undefined !== this.normals);\n            this.normals.push(normal);\n        }\n        return this.positions.length - 1;\n    }\n    /** Add a triangle corresponding to the three specified vertices. */\n    addTriangle(i0, i1, i2) {\n        this.addIndex(i0);\n        this.addIndex(i1);\n        this.addIndex(i2);\n    }\n    /** Add two triangles sharing an edge. This is equivalent to calling `addTriangle(i0, i1, i2); addTriangle(i1, i3, i2);`. */\n    addQuad(i0, i1, i2, i3) {\n        this.addTriangle(i0, i1, i2);\n        this.addTriangle(i1, i3, i2);\n    }\n    /** Add all of the indices in `indices` to the index buffer. */\n    addIndices(indices) {\n        for (const index of indices)\n            this.addIndex(index);\n    }\n    addIndex(index) {\n        this.indices.push(index);\n    }\n    /** Extract the finished [[RealityMeshParams]].\n     * @throws Error if the mesh contains no triangles.\n     */\n    finish() {\n        precondition(this.positions.length >= 3 && this.indices.length >= 3, \"RealityMeshParams requires at least one triangle\");\n        return {\n            positions: this.positions.finish(),\n            uvs: this.uvs.finish(),\n            normals: this.normals?.toTypedArray(),\n            indices: this.indices.toTypedArray(),\n        };\n    }\n}\n//# sourceMappingURL=RealityMeshParams.js.map",
      "start": 1693508119870,
      "end": 1693508119950,
      "sourcemaps": null
    }
  ]
}
