{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/AngleSweep.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { Geometry } from \"../Geometry\";\nimport { Angle } from \"./Angle\";\n/**\n * An `AngleSweep` is a pair of angles at start and end of an interval.\n *\n * *  For stroking purposes, the \"included interval\" is all angles numerically reached\n * by theta = start + f*(end-start), where f is between 0 and 1.\n * *  This stroking formula is simple numbers -- 2PI shifts are not involved.\n * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.\n * *  If \"start < end\" the angle proceeds CCW around the unit circle.\n * *  If \"end < start\" the angle proceeds CW around the unit circle.\n * *  Angles beyond 360 are fine as endpoints.\n * *  (350,370) covers the same unit angles as (-10,10).\n * *  (370,350) covers the same unit angles as (10,-10).\n * *  math details related fraction API can be found at docs/learning/geometry/Angle.md\n *  * Visualization can be found at https://www.itwinjs.org/sandbox/SaeedTorabi/AngleSweep\n * @public\n */\nexport class AngleSweep {\n    /** Read-property for degrees at the start of this AngleSweep. */\n    get startDegrees() {\n        return Angle.radiansToDegrees(this._radians0);\n    }\n    /** Read-property for degrees at the end of this AngleSweep. */\n    get endDegrees() {\n        return Angle.radiansToDegrees(this._radians1);\n    }\n    /** Read-property for signed start-to-end sweep in degrees. */\n    get sweepDegrees() {\n        return Angle.radiansToDegrees(this._radians1 - this._radians0);\n    }\n    /** Read-property for degrees at the start of this AngleSweep. */\n    get startRadians() {\n        return this._radians0;\n    }\n    /** Read-property for degrees at the end of this AngleSweep. */\n    get endRadians() {\n        return this._radians1;\n    }\n    /** Read-property for signed start-to-end sweep in radians. */\n    get sweepRadians() {\n        return this._radians1 - this._radians0;\n    }\n    /** Return the (strongly typed) start angle */\n    get startAngle() {\n        return Angle.createRadians(this._radians0);\n    }\n    /** Return the (strongly typed) end angle */\n    get endAngle() {\n        return Angle.createRadians(this._radians1);\n    }\n    /**\n     * Create a sweep as one of\n     * * A clone of a given sweep\n     * * 0 to given angle\n     * * full circle if no arg given (sweep 0 to 360 degrees)\n     */\n    static create(data) {\n        if (data instanceof AngleSweep)\n            return data.clone();\n        if (data instanceof Angle)\n            return new AngleSweep(0, data.radians);\n        return AngleSweep.create360();\n    }\n    /**\n     * (private) constructor with start and end angles in radians.\n     * * Use explicitly named static methods to clarify intent and units of inputs:\n     *\n     * * createStartEndRadians (startRadians:number, endRadians:number)\n     * * createStartEndDegrees (startDegrees:number, endDegrees:number)\n     * * createStartEnd (startAngle:Angle, endAngle:Angle)\n     * * createStartSweepRadians (startRadians:number, sweepRadians:number)\n     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)\n     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)\n     */\n    constructor(startRadians = 0, endRadians = 0) {\n        this._radians0 = startRadians;\n        this._radians1 = endRadians;\n    }\n    /**\n     * Directly set the start and end angles in radians\n     * * If the difference between startRadians and endRadians is greater than 360, the function limits the angle sweep to 360.\n     */\n    setStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI) {\n        const delta = endRadians - startRadians;\n        if (Angle.isFullCircleRadians(delta)) {\n            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;\n        }\n        this._radians0 = startRadians;\n        this._radians1 = endRadians;\n    }\n    /** Directly set the start and end angles in degrees */\n    setStartEndDegrees(startDegrees = 0, endDegrees = 360.0) {\n        this.setStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees));\n    }\n    /**\n     * Create an AngleSweep from start and end angles given in radians.\n     * * If the difference between startRadians and endRadians is greater than 360, the function limits the angle sweep to 360.\n     */\n    static createStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI, result) {\n        result = result ? result : new AngleSweep();\n        result.setStartEndRadians(startRadians, endRadians);\n        return result;\n    }\n    /** Return the angle obtained by subtracting radians from this angle. */\n    cloneMinusRadians(radians) {\n        return new AngleSweep(this._radians0 - radians, this._radians1 - radians);\n    }\n    /** Create an AngleSweep from start and end angles given in degrees. */\n    static createStartEndDegrees(startDegrees = 0, endDegrees = 360, result) {\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees), result);\n    }\n    /** Create an angle sweep from strongly typed start and end angles */\n    static createStartEnd(startAngle, endAngle, result) {\n        result = result ? result : new AngleSweep();\n        result.setStartEndRadians(startAngle.radians, endAngle.radians);\n        return result;\n    }\n    /** Create an AngleSweep from start and end angles given in radians. */\n    static createStartSweepRadians(startRadians = 0, sweepRadians = Math.PI, result) {\n        result = result ? result : new AngleSweep();\n        result.setStartEndRadians(startRadians, startRadians + sweepRadians);\n        return result;\n    }\n    /** Create an AngleSweep from start and sweep given in degrees.  */\n    static createStartSweepDegrees(startDegrees = 0, sweepDegrees = 360, result) {\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(startDegrees + sweepDegrees), result);\n    }\n    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */\n    static createStartSweep(startAngle, sweepAngle, result) {\n        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);\n    }\n    /** Return a sweep with limits interpolated between this and other. */\n    interpolate(fraction, other) {\n        return new AngleSweep(Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry.interpolate(this._radians1, fraction, other._radians1));\n    }\n    /** Copy from other AngleSweep. */\n    setFrom(other) {\n        this._radians0 = other._radians0;\n        this._radians1 = other._radians1;\n    }\n    /** Create a full circle sweep (CCW). startRadians defaults to 0 */\n    static create360(startRadians) {\n        startRadians = startRadians ? startRadians : 0.0;\n        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);\n    }\n    /** Create a sweep from the south pole to the north pole (-90 to +90). */\n    static createFullLatitude() {\n        return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI);\n    }\n    /** Reverse the start and end angle in place. */\n    reverseInPlace() {\n        const tmp = this._radians0;\n        this._radians0 = this._radians1;\n        this._radians1 = tmp;\n    }\n    /**\n     * Return a sweep for the \"other\" part of the circle.\n     * @param reverseDirection true to move backwards (CW) from start to end, false to more forwards (CCW) from start to end.\n     */\n    cloneComplement(reverseDirection = false, result) {\n        const s = this.sweepRadians >= 0 ? 2.0 : -2.0;\n        if (reverseDirection)\n            return AngleSweep.createStartEndRadians(this.startRadians, this.endRadians - s * Math.PI, result);\n        else\n            return AngleSweep.createStartEndRadians(this.endRadians, this.startRadians + s * Math.PI, result);\n    }\n    /** Restrict start and end angles into the range (-90,+90) in degrees */\n    capLatitudeInPlace() {\n        const limit = 0.5 * Math.PI;\n        this._radians0 = Geometry.clampToStartEnd(this._radians0, -limit, limit);\n        this._radians1 = Geometry.clampToStartEnd(this._radians1, -limit, limit);\n    }\n    /** Ask if the sweep is counterclockwise, i.e. positive sweep */\n    get isCCW() {\n        return this._radians1 >= this._radians0;\n    }\n    /** Ask if the sweep is a full circle. */\n    get isFullCircle() {\n        return Angle.isFullCircleRadians(this.sweepRadians);\n    }\n    /** Ask if the sweep is a full sweep from south pole to north pole. */\n    get isFullLatitudeSweep() {\n        const a = Math.PI * 0.5;\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);\n    }\n    /** Return a clone of this sweep. */\n    clone() {\n        return new AngleSweep(this._radians0, this._radians1);\n    }\n    /** Convert fractional position in the sweep to radians. */\n    fractionToRadians(fraction) {\n        return fraction < 0.5 ?\n            this._radians0 + fraction * (this._radians1 - this._radians0) :\n            this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);\n    }\n    /** Convert fractional position in the sweep to strongly typed Angle object. */\n    fractionToAngle(fraction) {\n        return Angle.createRadians(this.fractionToRadians(fraction));\n    }\n    /**\n     * Return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).\n     * * This is the number of fractional intervals required to cover a whole circle.\n     */\n    fractionPeriod() {\n        return Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);\n    }\n    /**\n     * Return the fractionalized position of the given angle (as Angle) computed without consideration of\n     * 2PI period and without consideration of angle sweep direction (CW or CCW).\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  negative fraction for angles \"before\" the start angle if start < end\n     * *  fraction larger than one for angles \"after\" the end angle if start < end\n     * *  fraction larger than one for angles \"before\" the start angle if start > end\n     * *  negative fraction for angles \"after\" the end angle if start > end\n     * *  does not allow period shift\n     */\n    angleToUnboundedFraction(theta) {\n        return Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);\n    }\n    /**\n     * Return the fractionalized position of the given angle (as radians), computed with consideration of 2PI period.\n     * *  consider radians0 as `start` angle of the sweep and radians1 as `end` angle of the sweep\n     * *  fraction is always positive\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  all exterior angles are at fractions greater than 1\n     * *  allows period shift\n     */\n    static radiansToPositivePeriodicFractionStartEnd(radians, radians0, radians1, zeroSweepDefault = 0.0) {\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, radians0))\n            return 0.0;\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, radians1))\n            return 1.0;\n        const sweep = radians1 - radians0;\n        const delta = radians - radians0;\n        if (sweep > 0) {\n            const delta1 = Angle.adjustRadians0To2Pi(delta);\n            const fraction1 = Geometry.safeDivideFraction(delta1, sweep, zeroSweepDefault);\n            return fraction1;\n        }\n        const delta2 = Angle.adjustRadians0To2Pi(-delta);\n        const fraction2 = Geometry.safeDivideFraction(delta2, -sweep, zeroSweepDefault);\n        return fraction2;\n    }\n    /**\n     * Return the fractionalized position of the given angle (as radians), computed with consideration of 2PI period.\n     * *  fraction is always positive\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  all exterior angles are at fractions greater than 1\n     * *  allows period shift\n     */\n    radiansToPositivePeriodicFraction(radians, zeroSweepDefault = 0.0) {\n        return AngleSweep.radiansToPositivePeriodicFractionStartEnd(radians, this._radians0, this._radians1, zeroSweepDefault);\n    }\n    /**\n     * Return the fractionalized position of the given angle (as Angle), computed with consideration of 2PI period.\n     * *  fraction is always positive\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  all exterior angles are at fractions greater than 1\n     * *  allows period shift\n     */\n    angleToPositivePeriodicFraction(theta) {\n        return this.radiansToPositivePeriodicFraction(theta.radians);\n    }\n    /**\n     * Return the fractionalized position of the given array of angles (as radian), computed with consideration of 2PI period.\n     * *  fraction is always positive\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  all exterior angles are at fractions greater than 1\n     * *  allows period shift\n     */\n    radiansArrayToPositivePeriodicFractions(data) {\n        const n = data.length;\n        for (let i = 0; i < n; i++) {\n            data.reassign(i, this.radiansToPositivePeriodicFraction(data.atUncheckedIndex(i)));\n        }\n    }\n    /**\n     * Return the fractionalized position of the given angle (as radian) computed with consideration of\n     * 2PI period and with consideration of angle sweep direction (CW or CCW).\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  negative fraction for angles \"before\" the start angle\n     * *  fraction larger than one for angles \"after\" the end angle\n     * *  allows period shift\n     */\n    radiansToSignedPeriodicFraction(radians) {\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))\n            return 0.0;\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))\n            return 1.0;\n        const sweep = this._radians1 - this._radians0;\n        const delta = radians - this._radians0 - 0.5 * sweep; // measure from middle of interval\n        if (sweep > 0) {\n            const delta1 = Angle.adjustRadiansMinusPiPlusPi(delta);\n            const fraction1 = 0.5 + Geometry.safeDivideFraction(delta1, sweep, 0.0);\n            return fraction1;\n        }\n        const delta2 = Angle.adjustRadiansMinusPiPlusPi(-delta);\n        const fraction = 0.5 + Geometry.safeDivideFraction(delta2, -sweep, 0.0);\n        return fraction;\n    }\n    /**\n     * Return the fractionalized position of the given angle (as Angle) computed with consideration of\n     * 2PI period and with consideration of angle sweep direction (CW or CCW).\n     * *  the start angle is at fraction 0\n     * *  the end angle is at fraction 1\n     * *  interior angles are between 0 and 1\n     * *  negative fraction for angles \"before\" the start angle\n     * *  fraction larger than one for angles \"after\" the end angle\n     * *  allows period shift\n     */\n    angleToSignedPeriodicFraction(theta) {\n        return this.radiansToSignedPeriodicFraction(theta.radians);\n    }\n    /** Test if the given angle (as radians) is within sweep (between radians0 and radians1)   */\n    static isRadiansInStartEnd(radians, radians0, radians1, allowPeriodShift = true) {\n        const delta0 = radians - radians0;\n        const delta1 = radians - radians1;\n        if (delta0 * delta1 <= 0.0)\n            return true;\n        if (radians0 === radians1)\n            return allowPeriodShift ? Angle.isAlmostEqualRadiansAllowPeriodShift(radians, radians0) : Angle.isAlmostEqualRadiansNoPeriodShift(radians, radians0);\n        return allowPeriodShift ? this.radiansToPositivePeriodicFractionStartEnd(radians, radians0, radians1, 1000.0) <= 1.0 : false;\n    }\n    /** Test if the given angle (as radians) is within sweep  */\n    isRadiansInSweep(radians, allowPeriodShift = true) {\n        return AngleSweep.isRadiansInStartEnd(radians, this.startRadians, this.endRadians, allowPeriodShift);\n    }\n    /** Test if the given angle (as Angle) is within the sweep */\n    isAngleInSweep(angle) {\n        return this.isRadiansInSweep(angle.radians);\n    }\n    /**\n     * Set this AngleSweep from various sources:\n     * * if json is undefined, a full-circle sweep is returned.\n     * * If json is an AngleSweep object, it is cloned\n     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.\n     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.\n     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.\n     * * Otherwise, a full-circle sweep is returned.\n     */\n    setFromJSON(json) {\n        if (!json)\n            this.setStartEndRadians(); // default full circle\n        else if (json instanceof AngleSweep)\n            this.setFrom(json);\n        else if (Geometry.isNumberArray(json.degrees, 2))\n            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);\n        else if (Geometry.isNumberArray(json.radians, 2))\n            this.setStartEndRadians(json.radians[0], json.radians[1]);\n        else if (Geometry.isNumberArray(json, 2))\n            this.setStartEndDegrees(json[0], json[1]);\n        else\n            this.setStartEndRadians(); // default full circle\n    }\n    /** Create an AngleSweep from a json object. */\n    static fromJSON(json) {\n        const result = AngleSweep.create360();\n        result.setFromJSON(json);\n        return result;\n    }\n    /**\n     * Convert an AngleSweep to a JSON object.\n     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}\n     */\n    toJSON() {\n        return [this.startDegrees, this.endDegrees];\n    }\n    /**\n     * Test if this angle sweep and other angle sweep match with radians tolerance.\n     * * Period shifts are allowed.\n     */\n    isAlmostEqualAllowPeriodShift(other) {\n        // We compare angle sweeps by checking if start angle and sweep match. We cannot compare start and end because for\n        // example (0, 90) and (360, 90) have the same start (we allow period shift) and end but are not same angle sweeps.\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)\n            && Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\n    }\n    /**\n     * Test if this angle sweep and other angle sweep match with radians tolerance.\n     * * Period shifts are not allowed.\n     */\n    isAlmostEqualNoPeriodShift(other) {\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\n    }\n    /**\n     * Test if start and end angles match with radians tolerance.\n     * * Period shifts are not allowed.\n     * * This function is equivalent to isAlmostEqualNoPeriodShift. It is present for consistency with other classes.\n     * However, it is recommended to use isAlmostEqualNoPeriodShift which has a clearer name.\n     */\n    isAlmostEqual(other) {\n        return this.isAlmostEqualNoPeriodShift(other);\n    }\n}\n//# sourceMappingURL=AngleSweep.js.map",
      "start": 1693508122981,
      "end": 1693508123193,
      "sourcemaps": null
    }
  ]
}
