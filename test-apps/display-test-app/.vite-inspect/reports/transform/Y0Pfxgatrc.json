{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/quantity/lib/esm/Parser.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Quantity\n */\nimport { QuantityConstants } from \"./Constants\";\nimport { FormatTraits, FormatType } from \"./Formatter/FormatEnums\";\nimport { Quantity } from \"./Quantity\";\n/** Possible parser errors\n * @beta\n */\nexport var ParseError;\n(function (ParseError) {\n    ParseError[ParseError[\"UnableToGenerateParseTokens\"] = 1] = \"UnableToGenerateParseTokens\";\n    ParseError[ParseError[\"NoValueOrUnitFoundInString\"] = 2] = \"NoValueOrUnitFoundInString\";\n    ParseError[ParseError[\"UnitLabelSuppliedButNotMatched\"] = 3] = \"UnitLabelSuppliedButNotMatched\";\n    ParseError[ParseError[\"UnknownUnit\"] = 4] = \"UnknownUnit\";\n    ParseError[ParseError[\"UnableToConvertParseTokensToQuantity\"] = 5] = \"UnableToConvertParseTokensToQuantity\";\n    ParseError[ParseError[\"InvalidParserSpec\"] = 6] = \"InvalidParserSpec\";\n})(ParseError || (ParseError = {}));\n/** A ParseToken holds either a numeric or string token extracted from a string that represents a quantity value.\n * @beta\n */\nclass ParseToken {\n    constructor(value) {\n        if (typeof value === \"string\")\n            this.value = value.trim();\n        else\n            this.value = value;\n    }\n    get isString() { return typeof this.value === \"string\"; }\n    get isNumber() { return typeof this.value === \"number\"; }\n}\n/** A ScientificToken holds an index and string representing the exponent.\n * @beta\n */\nclass ScientificToken {\n    constructor(index, exponent) {\n        this.exponent = \"\";\n        this.index = index;\n        if (exponent)\n            this.exponent = exponent;\n    }\n}\n/** A FractionToken holds an index and the fraction value of numerator / denominator.\n * @beta\n */\nclass FractionToken {\n    constructor(index, fraction) {\n        this.fraction = 0.0;\n        this.exponent = \"\";\n        this.index = index;\n        if (fraction)\n            this.fraction = fraction;\n    }\n}\n/** A Parser class that is used to break a string that represents a quantity value into tokens.\n * @beta\n */\nclass Parser {\n    static isParsedQuantity(item) {\n        return item.ok;\n    }\n    static isParseError(item) {\n        return !item.ok;\n    }\n    static checkForScientificNotation(index, stringToParse, uomSeparatorToIgnore) {\n        let exponentString = \"\";\n        let i = index + 1;\n        for (; i < stringToParse.length; i++) {\n            const charCode = stringToParse.charCodeAt(i);\n            if (Parser.isDigit(charCode) || ((charCode === QuantityConstants.CHAR_MINUS || charCode === QuantityConstants.CHAR_PLUS) && (i === (index + 1)))) {\n                exponentString = exponentString.concat(stringToParse[i]);\n            }\n            else {\n                i = uomSeparatorToIgnore === charCode ? i : i - 1;\n                break;\n            }\n        }\n        if (exponentString.length > 1 || ((exponentString.length === 1) && (exponentString.charCodeAt(0) !== QuantityConstants.CHAR_MINUS) && (exponentString.charCodeAt(0) !== QuantityConstants.CHAR_PLUS)))\n            return new ScientificToken(i, exponentString);\n        return new ScientificToken(index);\n    }\n    static checkForFractions(index, stringToParse, uomSeparatorToIgnore, numeratorStr) {\n        let numeratorToken = \"\";\n        let denominatorToken = \"\";\n        let processingNumerator = true;\n        let i = index;\n        if (numeratorStr && numeratorStr.length > 0) {\n            numeratorToken = numeratorStr;\n            processingNumerator = false;\n        }\n        for (; i < stringToParse.length; i++) {\n            const charCode = stringToParse.charCodeAt(i);\n            if (Parser.isDigit(charCode)) {\n                if (processingNumerator) {\n                    numeratorToken = numeratorToken.concat(stringToParse[i]);\n                }\n                else {\n                    denominatorToken = denominatorToken.concat(stringToParse[i]);\n                }\n            }\n            else {\n                if (processingNumerator && (charCode === QuantityConstants.CHAR_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH)) {\n                    processingNumerator = false;\n                }\n                else {\n                    if (uomSeparatorToIgnore !== charCode)\n                        i = i - 1; // skip over uom separator after fraction\n                    break;\n                }\n            }\n        }\n        if (numeratorToken.length > 0 && denominatorToken.length > 0) {\n            const numerator = parseInt(numeratorToken, 10);\n            const denominator = parseInt(denominatorToken, 10);\n            if (denominator > 0)\n                return new FractionToken(i, numerator / denominator);\n            return new FractionToken(i);\n        }\n        return new FractionToken(index + 1);\n    }\n    static isDigit(charCode) {\n        return (charCode >= QuantityConstants.CHAR_DIGIT_ZERO) && (charCode <= QuantityConstants.CHAR_DIGIT_NINE);\n    }\n    static isDigitOrDecimalSeparator(charCode, format) {\n        return (charCode === format.decimalSeparator.charCodeAt(0)) || Parser.isDigit(charCode);\n    }\n    /** Parse the quantity string and return and array of ParseTokens that represent the component invariant values and unit labels.\n     * @param quantitySpecification The quantity string to ba parsed.\n     */\n    static parseQuantitySpecification(quantitySpecification, format) {\n        const tokens = [];\n        const str = quantitySpecification.trim();\n        let processingNumber = false;\n        let wipToken = \"\";\n        let signToken = \"\";\n        let uomSeparatorToIgnore = 0;\n        let fractionDashCode = 0;\n        const skipCodes = [format.thousandSeparator.charCodeAt(0)];\n        if (format.type === FormatType.Station && format.stationSeparator && format.stationSeparator.length === 1)\n            skipCodes.push(format.stationSeparator.charCodeAt(0));\n        if (format.type === FormatType.Fractional && format.hasFormatTraitSet(FormatTraits.FractionDash)) {\n            fractionDashCode = QuantityConstants.CHAR_MINUS;\n        }\n        if (format.uomSeparator && format.uomSeparator !== \" \" && format.uomSeparator.length === 1) {\n            uomSeparatorToIgnore = format.uomSeparator.charCodeAt(0);\n            skipCodes.push(uomSeparatorToIgnore);\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < str.length; i++) {\n            const charCode = str.charCodeAt(i);\n            if (Parser.isDigitOrDecimalSeparator(charCode, format)) {\n                if (!processingNumber) {\n                    if (wipToken.length > 0) {\n                        tokens.push(new ParseToken(wipToken));\n                        wipToken = \"\";\n                    }\n                    processingNumber = true;\n                }\n                wipToken = wipToken.concat(str[i]);\n            }\n            else {\n                if (processingNumber) {\n                    if (charCode === QuantityConstants.CHAR_SLASH || charCode === QuantityConstants.CHAR_FRACTION_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH) {\n                        const fractSymbol = Parser.checkForFractions(i + 1, str, uomSeparatorToIgnore, wipToken);\n                        let fraction = fractSymbol.fraction;\n                        i = fractSymbol.index;\n                        if (fractSymbol.fraction !== 0.0) {\n                            wipToken = \"\";\n                            if (signToken.length > 0) {\n                                if (signToken === \"-\")\n                                    fraction = 0 - fraction;\n                                signToken = \"\";\n                            }\n                            tokens.push(new ParseToken(fraction));\n                            processingNumber = false;\n                            continue;\n                        }\n                    }\n                    else {\n                        // a space may signify end of number or start of decimal\n                        if (charCode === QuantityConstants.CHAR_SPACE || charCode === fractionDashCode) {\n                            const fractSymbol = Parser.checkForFractions(i + 1, str, uomSeparatorToIgnore);\n                            let fraction = fractSymbol.fraction;\n                            if (fractSymbol.fraction !== 0.0) {\n                                i = fractSymbol.index;\n                                if (signToken.length > 0) {\n                                    wipToken = signToken + wipToken;\n                                    if (signToken === \"-\")\n                                        fraction = 0 - fraction;\n                                    signToken = \"\";\n                                }\n                                const valueWithFraction = parseFloat(wipToken) + fraction;\n                                tokens.push(new ParseToken(valueWithFraction));\n                                processingNumber = false;\n                                wipToken = \"\";\n                            }\n                            continue;\n                        }\n                        else {\n                            // an \"E\" or \"e\" may signify scientific notation\n                            if (charCode === QuantityConstants.CHAR_UPPER_E || charCode === QuantityConstants.CHAR_LOWER_E) {\n                                const exponentSymbol = Parser.checkForScientificNotation(i, str, uomSeparatorToIgnore);\n                                i = exponentSymbol.index;\n                                if (exponentSymbol.exponent && exponentSymbol.exponent.length > 0) {\n                                    if (signToken.length > 0) {\n                                        wipToken = signToken + wipToken;\n                                        signToken = \"\";\n                                    }\n                                    wipToken = `${wipToken}e${exponentSymbol.exponent}`;\n                                    const scientificValue = Number(wipToken);\n                                    tokens.push(new ParseToken(scientificValue));\n                                    processingNumber = false;\n                                    wipToken = \"\";\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n                    // ignore any codes in skipCodes\n                    if (skipCodes.findIndex((ref) => ref === charCode) !== -1)\n                        continue;\n                    if (signToken.length > 0) {\n                        wipToken = signToken + wipToken;\n                        signToken = \"\";\n                    }\n                    tokens.push(new ParseToken(parseFloat(wipToken)));\n                    wipToken = (i < str.length) ? str[i] : \"\";\n                    processingNumber = false;\n                }\n                else {\n                    // not processing a number\n                    if ((charCode === QuantityConstants.CHAR_PLUS || charCode === QuantityConstants.CHAR_MINUS)) {\n                        if (0 === tokens.length) // sign token only needed for left most value\n                            signToken = str[i];\n                        continue;\n                    }\n                    wipToken = wipToken.concat(str[i]);\n                }\n            }\n        }\n        // handle case where end of input string is reached.\n        if (wipToken.length > 0) {\n            if (processingNumber) {\n                if (signToken.length > 0) {\n                    wipToken = signToken + wipToken;\n                }\n                tokens.push(new ParseToken(parseFloat(wipToken)));\n            }\n            else {\n                tokens.push(new ParseToken(wipToken));\n            }\n        }\n        return tokens;\n    }\n    static async lookupUnitByLabel(unitLabel, format, unitsProvider, altUnitLabelsProvider) {\n        const defaultUnit = format.units && format.units.length > 0 ? format.units[0][0] : undefined;\n        const labelToFind = unitLabel.toLowerCase();\n        // First look in format for a label and matches\n        if (format.units && format.units.length > 0) {\n            const formatUnit = format.units.find(([unit, label]) => {\n                if (label && label.toLowerCase() === labelToFind)\n                    return true;\n                const alternateLabels = altUnitLabelsProvider?.getAlternateUnitLabels(unit);\n                // check any alternate labels that may be defined for the Unit\n                if (alternateLabels && alternateLabels.find((lbl) => lbl.toLowerCase() === labelToFind))\n                    return true;\n                return false;\n            });\n            if (formatUnit)\n                return formatUnit[0];\n        }\n        // now try to find a unit from the same family and system\n        let foundUnit = await unitsProvider.findUnit(unitLabel, defaultUnit ? defaultUnit.phenomenon : undefined, defaultUnit ? defaultUnit.system : undefined);\n        // if nothing found yet just limit to family\n        if (!foundUnit.isValid && defaultUnit)\n            foundUnit = await unitsProvider.findUnit(unitLabel, defaultUnit ? defaultUnit.phenomenon : undefined);\n        return foundUnit;\n    }\n    static async createQuantityFromParseTokens(tokens, format, unitsProvider, altUnitLabelsProvider) {\n        let defaultUnit = format.units && format.units.length > 0 ? format.units[0][0] : undefined;\n        // common case where single value is supplied\n        if (tokens.length === 1) {\n            if (tokens[0].isNumber) {\n                return new Quantity(defaultUnit, tokens[0].value);\n            }\n            else {\n                const unit = await this.lookupUnitByLabel(tokens[0].value, format, unitsProvider, altUnitLabelsProvider);\n                return new Quantity(unit);\n            }\n        }\n        // common case where single value and single label are supplied\n        if (tokens.length === 2) {\n            if (tokens[0].isNumber && tokens[1].isString) {\n                const unit = await this.lookupUnitByLabel(tokens[1].value, format, unitsProvider, altUnitLabelsProvider);\n                if (undefined === defaultUnit)\n                    defaultUnit = unit;\n                if (defaultUnit && defaultUnit.name === unit.name) {\n                    return new Quantity(defaultUnit, tokens[0].value);\n                }\n                else if (defaultUnit) {\n                    const conversion = await unitsProvider.getConversion(unit, defaultUnit);\n                    const mag = ((tokens[0].value * conversion.factor)) + conversion.offset;\n                    return new Quantity(defaultUnit, mag);\n                }\n            }\n            else { // unit specification comes before value (like currency)\n                if (tokens[1].isNumber && tokens[0].isString) {\n                    const unit = await this.lookupUnitByLabel(tokens[0].value, format, unitsProvider, altUnitLabelsProvider);\n                    if (undefined === defaultUnit)\n                        defaultUnit = unit;\n                    if (defaultUnit && defaultUnit.name === unit.name) {\n                        return new Quantity(defaultUnit, tokens[1].value);\n                    }\n                    else if (defaultUnit) {\n                        const conversion = await unitsProvider.getConversion(unit, defaultUnit);\n                        const mag = ((tokens[1].value * conversion.factor)) + conversion.offset;\n                        return new Quantity(defaultUnit, mag);\n                    }\n                }\n            }\n        }\n        // common case where there are multiple value/label pairs\n        if (tokens.length % 2 === 0) {\n            let mag = 0.0;\n            for (let i = 0; i < tokens.length; i = i + 2) {\n                if (tokens[i].isNumber && tokens[i + 1].isString) {\n                    const value = tokens[i].value;\n                    const unit = await this.lookupUnitByLabel(tokens[i + 1].value, format, unitsProvider, altUnitLabelsProvider);\n                    if (undefined === defaultUnit)\n                        defaultUnit = unit;\n                    if (0 === i) {\n                        if (defaultUnit.name === unit.name)\n                            mag = value;\n                        else {\n                            const conversion = await unitsProvider.getConversion(unit, defaultUnit);\n                            mag = ((value * conversion.factor)) + conversion.offset;\n                        }\n                    }\n                    else {\n                        if (defaultUnit) {\n                            const conversion = await unitsProvider.getConversion(unit, defaultUnit);\n                            if (mag < 0.0)\n                                mag = mag - ((value * conversion.factor)) + conversion.offset;\n                            else\n                                mag = mag + ((value * conversion.factor)) + conversion.offset;\n                        }\n                    }\n                }\n            }\n            return new Quantity(defaultUnit, mag);\n        }\n        return new Quantity(defaultUnit);\n    }\n    /** Async method to generate a Quantity given a string that represents a quantity value and likely a unit label.\n     *  @param inString A string that contains text represent a quantity.\n     *  @param format   Defines the likely format of inString.\n     *  @param unitsProvider required to look up units that may be specified in inString\n     */\n    static async parseIntoQuantity(inString, format, unitsProvider, altUnitLabelsProvider) {\n        const tokens = Parser.parseQuantitySpecification(inString, format);\n        if (tokens.length === 0)\n            return new Quantity();\n        return Parser.createQuantityFromParseTokens(tokens, format, unitsProvider, altUnitLabelsProvider);\n    }\n    /** method to get the Unit Conversion given a unit label */\n    static tryFindUnitConversion(unitLabel, unitsConversions, preferredUnit) {\n        if (unitsConversions.length > 0) {\n            const label = unitLabel.toLocaleLowerCase();\n            /* A preferred unit is used to target a unit if a unit label is used in more that one unit definition from the same unit family.\n             * An example is if \"ft\" is used as the unitLabel and the preferredUnit is \"SURVEY_FT\" since that unit has an alternate label of \"ft\" the\n             * conversion to \"SURVEY_FT\" is returned. If no preferredUnit is specified then the unit \"FT\" would likely to have been found first.\n             * If \"in\" is the unit label and \"SURVEY_FT\" is the preferredUnit then conversion to \"SURVEY_IN\" would be returned.\n            */\n            if (preferredUnit) {\n                // if there is a preferred unit defined see if unit label matched it or one of its alternates\n                const preferredConversion = unitsConversions.find((conversion) => conversion.name === preferredUnit.name);\n                if (preferredConversion && preferredConversion.parseLabels) {\n                    if (-1 !== preferredConversion.parseLabels.findIndex((lbl) => lbl === label))\n                        return preferredConversion.conversion;\n                }\n                // see if we can find a matching unitLabel in any unit within the same system as the preferred unit\n                const preferredSystemConversions = unitsConversions.filter((conversion) => conversion.system === preferredUnit.system);\n                for (const conversion of preferredSystemConversions) {\n                    if (conversion.parseLabels) {\n                        if (-1 !== conversion.parseLabels.findIndex((lbl) => lbl === label))\n                            return conversion.conversion;\n                    }\n                }\n            }\n            // if no unit found based on preferredUnit see if an unit label matches\n            for (const conversion of unitsConversions) {\n                if (conversion.parseLabels) {\n                    if (-1 !== conversion.parseLabels.findIndex((lbl) => lbl === label))\n                        return conversion.conversion;\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.log(\"ERROR: Parser expects to find parseLabels array populate with all possible unit labels for the unit.\");\n                }\n            }\n        }\n        return undefined;\n    }\n    static getQuantityValueFromParseTokens(tokens, format, unitsConversions) {\n        const defaultUnit = format.units && format.units.length > 0 ? format.units[0][0] : undefined;\n        // common case where single value is supplied\n        if (tokens.length === 1) {\n            if (tokens[0].isNumber) {\n                if (defaultUnit) {\n                    const conversion = Parser.tryFindUnitConversion(defaultUnit.label, unitsConversions, defaultUnit);\n                    if (conversion) {\n                        const value = tokens[0].value * conversion.factor + conversion.offset;\n                        return { ok: true, value };\n                    }\n                }\n                else {\n                    // if no conversion or no defaultUnit, just return parsed number\n                    return { ok: true, value: tokens[0].value };\n                }\n            }\n            else {\n                // only the unit label was specified so assume magnitude of 1\n                const conversion = Parser.tryFindUnitConversion(tokens[0].value, unitsConversions, defaultUnit);\n                if (undefined !== conversion)\n                    return { ok: true, value: conversion.factor + conversion.offset };\n                else\n                    return { ok: false, error: ParseError.NoValueOrUnitFoundInString };\n            }\n        }\n        // common case where single value and single label are supplied\n        if (tokens.length === 2) {\n            if (tokens[0].isNumber && tokens[1].isString) {\n                const conversion = Parser.tryFindUnitConversion(tokens[1].value, unitsConversions, defaultUnit);\n                if (conversion) {\n                    const value = tokens[0].value * conversion.factor + conversion.offset;\n                    return { ok: true, value };\n                }\n                // if no conversion, just return parsed number and ignore value in second token\n                return { ok: true, value: tokens[0].value };\n            }\n            else { // unit specification comes before value (like currency)\n                if (tokens[1].isNumber && tokens[0].isString) {\n                    const conversion = Parser.tryFindUnitConversion(tokens[0].value, unitsConversions, defaultUnit);\n                    if (conversion) {\n                        const value = tokens[1].value * conversion.factor + conversion.offset;\n                        return { ok: true, value };\n                    }\n                    // if no conversion, just return parsed number and ignore value in second token\n                    return { ok: true, value: tokens[1].value };\n                }\n            }\n        }\n        // common case where there are multiple value/label pairs\n        if (tokens.length % 2 === 0) {\n            let mag = 0.0;\n            for (let i = 0; i < tokens.length; i = i + 2) {\n                if (tokens[i].isNumber && tokens[i + 1].isString) {\n                    const value = tokens[i].value;\n                    const conversion = Parser.tryFindUnitConversion(tokens[i + 1].value, unitsConversions, defaultUnit);\n                    if (conversion) {\n                        if (mag < 0.0)\n                            mag = mag - ((value * conversion.factor)) + conversion.offset;\n                        else\n                            mag = mag + ((value * conversion.factor)) + conversion.offset;\n                    }\n                }\n            }\n            return { ok: true, value: mag };\n        }\n        return { ok: false, error: ParseError.UnableToConvertParseTokensToQuantity };\n    }\n    /** Method to generate a Quantity given a string that represents a quantity value.\n     *  @param inString A string that contains text represent a quantity.\n     *  @param parserSpec unit label if not explicitly defined by user. Must have matching entry in supplied array of unitsConversions.\n     *  @param defaultValue default value to return if parsing is un successful\n     */\n    static parseQuantityString(inString, parserSpec) {\n        return Parser.parseToQuantityValue(inString, parserSpec.format, parserSpec.unitConversions);\n    }\n    /** Method to generate a Quantity given a string that represents a quantity value and likely a unit label.\n     *  @param inString A string that contains text represent a quantity.\n     *  @param format   Defines the likely format of inString. Primary unit serves as a default unit if no unit label found in string.\n     *  @param unitsConversions dictionary of conversions used to convert from unit used in inString to output quantity\n     */\n    static parseToQuantityValue(inString, format, unitsConversions) {\n        // ensure any labels defined in composite unit definition are specified in unitConversions\n        if (format.units) {\n            format.units.forEach(([unit, label]) => {\n                if (label) {\n                    if (unit.label !== label) { // if default unit label does not match composite label ensure the label is in the list of parse labels for the conversion\n                        const unitConversion = unitsConversions.find((conversion) => conversion.name === unit.name);\n                        if (unitConversion && unitConversion.parseLabels && !unitConversion.parseLabels.find((entry) => entry === label))\n                            unitConversion.parseLabels.push(label);\n                    }\n                }\n            });\n        }\n        const tokens = Parser.parseQuantitySpecification(inString, format);\n        if (tokens.length === 0)\n            return { ok: false, error: ParseError.UnableToGenerateParseTokens };\n        if (Parser._log) {\n            // eslint-disable-next-line no-console\n            console.log(`Parse tokens`);\n            let i = 0;\n            for (const token of tokens) {\n                // eslint-disable-next-line no-console\n                console.log(`  [${i++}] isNumber=${token.isNumber} isString=${token.isString} token=${token.value}`);\n            }\n        }\n        return Parser.getQuantityValueFromParseTokens(tokens, format, unitsConversions);\n    }\n    /** Async Method used to create an array of UnitConversionSpec entries that can be used in synchronous calls to parse units. */\n    static async createUnitConversionSpecsForUnit(unitsProvider, outUnit, altUnitLabelsProvider) {\n        const unitConversionSpecs = [];\n        const familyUnits = await unitsProvider.getUnitsByFamily(outUnit.phenomenon);\n        for (const unit of familyUnits) {\n            const conversion = await unitsProvider.getConversion(unit, outUnit);\n            const parseLabels = [unit.label.toLocaleLowerCase()];\n            const alternateLabels = altUnitLabelsProvider?.getAlternateUnitLabels(unit);\n            // add any alternate labels that may be defined for the Unit\n            if (alternateLabels) {\n                alternateLabels.forEach((label) => {\n                    const potentialLabel = label.toLocaleLowerCase();\n                    if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n                        parseLabels.push(label.toLocaleLowerCase());\n                });\n            }\n            unitConversionSpecs.push({\n                name: unit.name,\n                label: unit.label,\n                conversion,\n                parseLabels,\n                system: unit.system,\n            });\n        }\n        return unitConversionSpecs;\n    }\n    /** Async Method used to create an array of UnitConversionSpec entries that can be used in synchronous calls to parse units. */\n    static async createUnitConversionSpecs(unitsProvider, outUnitName, potentialParseUnits, altUnitLabelsProvider) {\n        const unitConversionSpecs = [];\n        const outUnit = await unitsProvider.findUnitByName(outUnitName);\n        if (!outUnit || !outUnit.name || 0 === outUnit.name.length) {\n            // eslint-disable-next-line no-console\n            console.log(`[Parser.createUnitConversionSpecs] ERROR: Unable to locate out unit ${outUnitName}.`);\n            return unitConversionSpecs;\n        }\n        for (const potentialParseUnit of potentialParseUnits) {\n            const unit = await unitsProvider.findUnitByName(potentialParseUnit.unitName);\n            if (!unit || !unit.name || 0 === unit.name.length) {\n                // eslint-disable-next-line no-console\n                console.log(`[Parser.createUnitConversionSpecs] ERROR: Unable to locate potential unit ${potentialParseUnit.unitName}.`);\n                continue;\n            }\n            const conversion = await unitsProvider.getConversion(unit, outUnit);\n            const parseLabels = [unit.label.toLocaleLowerCase()];\n            const alternateLabels = altUnitLabelsProvider?.getAlternateUnitLabels(unit);\n            // add any alternate labels that may be defined for the Unit\n            if (alternateLabels) {\n                alternateLabels.forEach((label) => {\n                    const potentialLabel = label.toLocaleLowerCase();\n                    if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n                        parseLabels.push(label.toLocaleLowerCase());\n                });\n            }\n            // add any alternate labels that where provided by caller\n            if (potentialParseUnit.altLabels) {\n                potentialParseUnit.altLabels.forEach((label) => {\n                    const potentialLabel = label.toLocaleLowerCase();\n                    if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n                        parseLabels.push(label.toLocaleLowerCase());\n                });\n            }\n            unitConversionSpecs.push({\n                name: unit.name,\n                label: unit.label,\n                conversion,\n                parseLabels,\n                system: unit.system,\n            });\n        }\n        return unitConversionSpecs;\n    }\n}\nParser._log = false;\nexport { Parser };\n//# sourceMappingURL=Parser.js.map",
      "start": 1693508124077,
      "end": 1693508124363,
      "sourcemaps": null
    }
  ]
}
