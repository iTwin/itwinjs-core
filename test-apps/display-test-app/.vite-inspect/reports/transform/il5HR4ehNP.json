{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/FrustumAnimator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { Angle, Geometry, Matrix3d, Range3d, Transform } from \"@itwin/core-geometry\";\nimport { Tweens } from \"@itwin/core-common\";\nimport { ScreenViewport } from \"./Viewport\";\n/**\n * Compute an intermediate eye point as it swings around a moving target with rotating axes and varying distance to target.\n * (eye, target, distance) is redundant -- implementation problem is to figure out which to use for compatibility with subsequent view setup.\n */\nfunction interpolateSwingingEye(axes0, eye0, distance0, axes1, eye1, distance1, fraction, axesAtFraction) {\n    const z0 = axes0.rowZ();\n    const z1 = axes1.rowZ();\n    const zA = axesAtFraction.rowZ();\n    // back up from the eye points to the targets.\n    const target0 = eye0.plusScaled(z0, -distance0);\n    const target1 = eye1.plusScaled(z1, -distance1);\n    // RULE: Target point moves by simple interpolation\n    const targetA = target0.interpolate(fraction, target1);\n    // RULE: Distance from target to eye is simple interpolation\n    const distanceA = Geometry.interpolate(distance0, fraction, distance1);\n    // The interpolated target, interpolated distance, and specified axes give the intermediate eyepoint.\n    const eyeA = targetA.plusScaled(zA, distanceA);\n    return {\n        target: targetA,\n        eye: eyeA,\n        distance: distanceA,\n    };\n}\n/** Animates the transition of a [[Viewport]] from one [Frustum]($common) to another. The viewport will render as many frames as necessary during the supplied duration.\n * @see [[Viewport.animateFrustumChange]] to conveniently animate a viewport from one frustum to another.\n * @public\n * @extensions\n */\nexport class FrustumAnimator {\n    /** Construct an animator that animates from `begin` to `end`. */\n    constructor(options, viewport, begin, end) {\n        this.options = options;\n        this._tweens = new Tweens();\n        this._duration = 0;\n        const settings = ScreenViewport.animation;\n        const zoomSettings = settings.zoomOut;\n        let duration = undefined !== options.animationTime ? options.animationTime : settings.time.normal.milliseconds;\n        if (duration <= 0 || begin.cameraOn !== end.cameraOn) // no duration means skip animation. We can't animate if the camera toggles.\n            return;\n        this._duration = duration;\n        let extentBias;\n        let eyeBias;\n        const zVec = begin.zVec;\n        const view = viewport.view;\n        const view3 = view;\n        const begin3 = begin;\n        const end3 = end;\n        const beginTarget = begin.target;\n        const endTarget = end.target;\n        const axis = end.rotation.multiplyMatrixMatrixInverse(begin.rotation).getAxisAndAngleOfRotation(); // axis to rotate begin to get to end\n        const timing = { fraction: 0.0, height: 0, position: 0 }; // updated by tween.\n        // don't do \"zoom out\" if the two views aren't pointing in the same direction, or if they request cancelOnAbort (since that implies that the view\n        // is a linear interpolation from begin to end), or if it's disabled.\n        if (zoomSettings.enable && !options.cancelOnAbort && zVec.isAlmostEqual(end.zVec)) {\n            view.applyPose(end); // start with the pose at the end\n            const viewTransform = Transform.createOriginAndMatrix(undefined, view.getRotation());\n            const endRange = Range3d.createTransformedArray(viewTransform, view.calculateFocusCorners()); // get the view-aligned range of the focus plane at the end\n            const beginRange = Range3d.createTransformedArray(viewTransform, view.applyPose(begin).calculateFocusCorners()); // get the view-aligned range of the focus plane at the beginning\n            // do the starting and ending views (plus the margin) overlap? If not we need to zoom out to show how to get from one to the other\n            const expand = (range) => {\n                const r = range.clone();\n                r.scaleAboutCenterInPlace(zoomSettings.margin);\n                return r;\n            };\n            if (!expand(beginRange).intersectsRangeXY(expand(endRange))) {\n                view3.lookAtViewAlignedVolume(beginRange.union(endRange), viewport.viewRect.aspect); // set up a view that would show both extents\n                duration *= zoomSettings.durationFactor; // increase duration so the zooming isn't too fast\n                extentBias = view.getExtents().minus(begin.extents); // if the camera is off, the \"bias\" is the amount the union-ed view is larger than the starting view\n                if (begin.cameraOn)\n                    eyeBias = zVec.scaleToLength(zVec.dotProduct(begin3.camera.eye.vectorTo(view3.camera.eye))); // if the camera is on, the bias is the difference in height of the two eye positions\n            }\n        }\n        this._tweens.create(timing, {\n            to: { fraction: 1.0, height: zoomSettings.heights, position: zoomSettings.positions },\n            duration,\n            start: true,\n            easing: options.easingFunction ? options.easingFunction : settings.easing,\n            interpolation: zoomSettings.interpolation,\n            onComplete: () => viewport.setupFromView(end),\n            onUpdate: () => {\n                const fraction = extentBias ? timing.position : timing.fraction; // if we're zooming, fraction comes from position interpolation\n                const rot = Matrix3d.createRotationAroundVector(axis.axis, Angle.createDegrees(fraction * axis.angle.degrees)).multiplyMatrixMatrix(begin.rotation);\n                if (begin.cameraOn) {\n                    const newExtents = begin.extents.interpolate(fraction, end.extents);\n                    if (undefined !== eyeBias) {\n                        const eyePoint = begin3.camera.eye.interpolate(fraction, end3.camera.eye);\n                        eyePoint.plusScaled(eyeBias, timing.height, eyePoint);\n                        const targetPoint = eyePoint.plusScaled(rot.getRow(2), -1.0 * (Geometry.interpolate(begin3.camera.focusDist, fraction, end3.camera.focusDist)));\n                        view3.lookAt({ eyePoint, targetPoint, upVector: rot.getRow(1), newExtents });\n                    }\n                    else {\n                        const data = interpolateSwingingEye(begin3.rotation, begin3.camera.eye, begin3.camera.focusDist, end3.rotation, end3.camera.eye, end3.camera.focusDist, fraction, rot);\n                        view3.lookAt({ eyePoint: data.eye, targetPoint: data.target, upVector: rot.getRow(1), newExtents });\n                    }\n                }\n                else {\n                    const extents = begin.extents.interpolate(timing.fraction, end.extents);\n                    if (undefined !== extentBias)\n                        extents.plusScaled(extentBias, timing.height, extents); // no camera, zooming out expands extents\n                    view.setExtents(extents);\n                    view.setRotation(rot);\n                    view.setCenter(beginTarget.interpolate(fraction, endTarget)); // must be done last - depends on extents and rotation\n                }\n                viewport.setupFromView();\n            },\n        });\n    }\n    /** @internal */\n    animate() {\n        const didFinish = !this._tweens.update();\n        if (didFinish && this.options.animationFinishedCallback)\n            this.options.animationFinishedCallback(true);\n        return didFinish;\n    }\n    /** @internal */\n    interrupt() {\n        // We were interrupted. Either go to: the final frame (normally) or, add a small fraction of the total duration (30ms for a .5 second duration) to\n        // the current time for cancelOnAbort. That makes aborted animations show some progress, as happens when the mouse wheel rolls quickly.\n        this._tweens.update(this.options.cancelOnAbort ? Date.now() + (this._duration * .06) : Infinity);\n        if (this.options.animationFinishedCallback)\n            this.options.animationFinishedCallback(false);\n    }\n}\n//# sourceMappingURL=FrustumAnimator.js.map",
      "start": 1693508119287,
      "end": 1693508119439,
      "sourcemaps": null
    }
  ]
}
