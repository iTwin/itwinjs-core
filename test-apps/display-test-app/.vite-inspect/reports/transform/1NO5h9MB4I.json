{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/PerModelCategoryVisibility.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { compareStrings, Id64, SortedArray } from \"@itwin/core-bentley\";\n/** Per-model category visibility permits the visibility of categories within a [[Viewport]] displaying a [[SpatialViewState]] to be overridden in\n * the context of individual [[GeometricModelState]]s.\n * If a category's visibility is overridden for a given model, then elements belonging to that category within that model will be displayed or hidden regardless of the category's inclusion in the Viewport's [[CategorySelectorState]].\n * The override affects geometry on all subcategories belonging to the overridden category. That is, if the category is overridden to be visible, then geometry on all subcategories of the category\n * will be visible, regardless of any [SubCategoryOverride]($common)s applied by the view's [[DisplayStyleState]].\n * @see [[Viewport.perModelCategoryVisibility]] to define the per-model category visibility for a viewport.\n * @public\n * @extensions\n */\nexport var PerModelCategoryVisibility;\n(function (PerModelCategoryVisibility) {\n    /** Describes whether and how a category's visibility is overridden. */\n    let Override;\n    (function (Override) {\n        /** The category's visibility is not overridden; its visibility is wholly controlled by the [[Viewport]]'s [[CategorySelectorState]]. */\n        Override[Override[\"None\"] = 0] = \"None\";\n        /** The category is overridden to be visible. */\n        Override[Override[\"Show\"] = 1] = \"Show\";\n        /** The category is overridden to be invisible. */\n        Override[Override[\"Hide\"] = 2] = \"Hide\";\n    })(Override = PerModelCategoryVisibility.Override || (PerModelCategoryVisibility.Override = {}));\n    function createOverrides(viewport) {\n        return new PerModelCategoryVisibilityOverrides(viewport);\n    }\n    PerModelCategoryVisibility.createOverrides = createOverrides;\n})(PerModelCategoryVisibility || (PerModelCategoryVisibility = {}));\nclass PerModelCategoryVisibilityOverride {\n    constructor(modelId, categoryId, visible) {\n        this.modelId = modelId;\n        this.categoryId = categoryId;\n        this.visible = visible;\n    }\n    reset(modelId, categoryId, visible) {\n        this.modelId = modelId;\n        this.categoryId = categoryId;\n        this.visible = visible;\n    }\n}\nfunction compareCategoryOverrides(lhs, rhs) {\n    const cmp = compareStrings(lhs.modelId, rhs.modelId);\n    return 0 === cmp ? compareStrings(lhs.categoryId, rhs.categoryId) : cmp;\n}\n/** The Viewport-specific implementation of PerModelCategoryVisibility.Overrides. */\nclass PerModelCategoryVisibilityOverrides extends SortedArray {\n    constructor(vp) {\n        super(compareCategoryOverrides);\n        this._scratch = new PerModelCategoryVisibilityOverride(\"0\", \"0\", false);\n        this._vp = vp;\n    }\n    getOverride(modelId, categoryId) {\n        this._scratch.reset(modelId, categoryId, false);\n        const ovr = this.findEqual(this._scratch);\n        if (undefined !== ovr)\n            return ovr.visible ? PerModelCategoryVisibility.Override.Show : PerModelCategoryVisibility.Override.Hide;\n        else\n            return PerModelCategoryVisibility.Override.None;\n    }\n    /**\n     * set the overrides for multiple perModelCategoryVisibility props, loading categoryIds from the iModel if necessary.\n     * @see [[PerModelCategoryVisibility]]\n     * @param perModelCategoryVisibility array of model category visibility overrides @see [[PerModelCategoryVisibility.Props]]\n     * @param iModel Optional param iModel. If no iModel is provided, then the iModel associated with the viewport (used to construct this class) is used.\n     * This optional iModel param is useful for apps which may show multiple iModels at once. Passing in an iModel ensures that the subcategories cache for the provided iModel\n     * is populated as opposed to the iModel associated with the viewport which may or may not be an empty iModel.\n     * @returns a promise that resolves once the overrides have been applied.\n     */\n    async setOverrides(perModelCategoryVisibility, iModel) {\n        let anyChanged = false;\n        const catIdsToLoad = [];\n        const iModelToUse = iModel ? iModel : this._vp.iModel;\n        for (const override of perModelCategoryVisibility) {\n            const modelId = override.modelId;\n            // The caller may pass a single categoryId as a string, if we don't convert this to an array we will iterate\n            // over each individual character of that string, which is not the desired behavior.\n            const categoryIds = typeof override.categoryIds === \"string\" ? [override.categoryIds] : override.categoryIds;\n            const visOverride = override.visOverride;\n            for (const categoryId of categoryIds) {\n                if (this.findAndUpdateOverrideInArray(modelId, categoryId, visOverride)) {\n                    anyChanged = true;\n                    if (PerModelCategoryVisibility.Override.None !== visOverride) {\n                        catIdsToLoad.push(categoryId);\n                    }\n                }\n            }\n        }\n        if (anyChanged) {\n            this._vp.setViewedCategoriesPerModelChanged();\n            if (catIdsToLoad.length !== 0) {\n                this._vp.subcategories.push(iModelToUse.subcategories, catIdsToLoad, () => this._vp.setViewedCategoriesPerModelChanged());\n            }\n        }\n        return;\n    }\n    /** Find and update the override in the array of overrides. If override not found, adds it to the array.\n     *  If the array was changed, returns true. */\n    findAndUpdateOverrideInArray(modelId, categoryId, override) {\n        const ovr = this._scratch;\n        ovr.reset(modelId, categoryId, false);\n        let changed = false;\n        const index = this.indexOf(ovr);\n        if (-1 === index) {\n            if (PerModelCategoryVisibility.Override.None !== override) {\n                this.insert(new PerModelCategoryVisibilityOverride(modelId, categoryId, PerModelCategoryVisibility.Override.Show === override));\n                changed = true;\n            }\n        }\n        else {\n            if (PerModelCategoryVisibility.Override.None === override) {\n                this._array.splice(index, 1);\n                changed = true;\n            }\n            else if (this._array[index].visible !== (PerModelCategoryVisibility.Override.Show === override)) {\n                this._array[index].visible = (PerModelCategoryVisibility.Override.Show === override);\n                changed = true;\n            }\n        }\n        return changed;\n    }\n    setOverride(modelIds, categoryIds, override) {\n        let changed = false;\n        for (const modelId of Id64.iterable(modelIds)) {\n            for (const categoryId of Id64.iterable(categoryIds)) {\n                if (this.findAndUpdateOverrideInArray(modelId, categoryId, override))\n                    changed = true;\n            }\n        }\n        if (changed) {\n            this._vp.setViewedCategoriesPerModelChanged();\n            if (PerModelCategoryVisibility.Override.None !== override) {\n                // Ensure subcategories loaded.\n                this._vp.subcategories.push(this._vp.iModel.subcategories, categoryIds, () => this._vp.setViewedCategoriesPerModelChanged());\n            }\n        }\n    }\n    clearOverrides(modelIds) {\n        if (undefined === modelIds) {\n            if (0 < this.length) {\n                this.clear();\n                this._vp.setViewedCategoriesPerModelChanged();\n            }\n            return;\n        }\n        for (let i = 0; i < this.length;) {\n            const ovr = this._array[i];\n            let removed = false;\n            for (const modelId of Id64.iterable(modelIds)) {\n                if (modelId === ovr.modelId) {\n                    this._array.splice(i, 1);\n                    this._vp.setViewedCategoriesPerModelChanged();\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed)\n                ++i;\n        }\n    }\n    addOverrides(fs, ovrs) {\n        const cache = this._vp.iModel.subcategories;\n        for (const ovr of this._array) {\n            const subcats = cache.getSubCategories(ovr.categoryId);\n            if (undefined === subcats)\n                continue;\n            // It's pointless to override for models which aren't displayed...except if we do this, and then someone enables that model,\n            // we would need to regenerate our symbology overrides in response. Preferably people wouldn't bother overriding models that\n            // they don't want us to draw...\n            /* if (!this._vp.view.viewsModel(ovr.modelId))\n              continue; */\n            // ###TODO: Avoid recomputing upper and lower portions of modelId if modelId repeated.\n            // (Array is sorted first by modelId).\n            // Also avoid computing if no effective overrides.\n            const modelLo = Id64.getLowerUint32(ovr.modelId);\n            const modelHi = Id64.getUpperUint32(ovr.modelId);\n            for (const subcat of subcats) {\n                const subcatLo = Id64.getLowerUint32(subcat);\n                const subcatHi = Id64.getUpperUint32(subcat);\n                const vis = fs.isSubCategoryVisible(subcatLo, subcatHi);\n                if (vis !== ovr.visible) {\n                    // Only care if visibility differs from that defined for entire view\n                    let entry = ovrs.get(modelLo, modelHi);\n                    if (undefined === entry) {\n                        entry = new Id64.Uint32Set();\n                        ovrs.set(modelLo, modelHi, entry);\n                    }\n                    entry.add(subcatLo, subcatHi);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=PerModelCategoryVisibility.js.map",
      "start": 1693508119437,
      "end": 1693508119689,
      "sourcemaps": null
    }
  ]
}
