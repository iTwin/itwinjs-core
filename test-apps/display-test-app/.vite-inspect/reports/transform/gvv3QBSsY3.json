{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tile/map/MapTile.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tiles\n */\nimport { assert, dispose } from \"@itwin/core-bentley\";\nimport { ColorByName, ColorDef, FrustumPlanes, GlobeMode, PackedFeatureTable } from \"@itwin/core-common\";\nimport { AxisOrder, BilinearPatch, ClipPlane, ClipPrimitive, ClipShape, ClipVector, Constant, ConvexClipPlaneSet, EllipsoidPatch, LongitudeLatitudeNumber, Matrix3d, Point3d, PolygonOps, Range1d, Range2d, Range3d, Ray3d, Transform, Vector2d, Vector3d } from \"@itwin/core-geometry\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { RealityMeshParams } from \"../../render/RealityMeshParams\";\nimport { upsampleRealityMeshParams } from \"../../render/UpsampleRealityMeshParams\";\nimport { TerrainTexture } from \"../../render/RenderSystem\";\nimport { MapCartoRectangle, MapTileTree, QuadId, RealityTile, TileGraphicType, TileLoadStatus, TileTreeLoadStatus, } from \"../internal\";\n/** @internal */\nexport class PlanarTilePatch {\n    constructor(corners, normal, _chordHeight) {\n        this.corners = corners;\n        this.normal = normal;\n        this._chordHeight = _chordHeight;\n    }\n    getRangeCorners(heightRange, result) {\n        let index = 0;\n        for (const corner of this.corners)\n            corner.plusScaled(this.normal, heightRange.low - this._chordHeight, result[index++]);\n        for (const corner of this.corners)\n            corner.plusScaled(this.normal, heightRange.high + this._chordHeight, result[index++]);\n        return result;\n    }\n    getClipShape() {\n        return [this.corners[0], this.corners[1], this.corners[3], this.corners[2]];\n    }\n}\n/** Projects points within the rectangular region of a [[MapTile]] into 3d space.\n * @see [[MapTile.getProjection]] to obtain the projection for a [[MapTile]].\n * @public\n */\nexport class MapTileProjection {\n    /** @alpha */\n    get ellipsoidPatch() { return undefined; }\n    /** @alpha */\n    getGlobalPoint(u, v, z, result) {\n        const point = this.getPoint(u, v, z, result);\n        return this.transformFromLocal.multiplyPoint3d(point, point);\n    }\n}\n/** @alpha */\nclass EllipsoidProjection extends MapTileProjection {\n    constructor(_patch, heightRange) {\n        super();\n        this._patch = _patch;\n        this.transformFromLocal = Transform.createIdentity();\n        this.localRange = _patch.range();\n        this.localRange.expandInPlace(heightRange ? (heightRange.high - heightRange.low) : 0);\n    }\n    getPoint(u, v, height, result) {\n        const angles = this._patch.uvFractionToAngles(u, v, height, EllipsoidProjection._scratchAngles);\n        const ray = this._patch.anglesToUnitNormalRay(angles, EllipsoidProjection._scratchRay);\n        return Point3d.createFrom(ray.origin, result);\n    }\n    get ellipsoidPatch() { return this._patch; }\n}\nEllipsoidProjection._scratchAngles = LongitudeLatitudeNumber.createZero();\nEllipsoidProjection._scratchRay = Ray3d.createZero();\n/** @alpha */\nclass PlanarProjection extends MapTileProjection {\n    constructor(patch, heightRange) {\n        super();\n        this.transformFromLocal = Transform.createOriginAndMatrix(patch.corners[0], Matrix3d.createRigidHeadsUp(patch.normal, AxisOrder.ZYX));\n        const planeCorners = this.transformFromLocal.multiplyInversePoint3dArray([patch.corners[0], patch.corners[1], patch.corners[2], patch.corners[3]]);\n        this.localRange = Range3d.createArray(planeCorners);\n        this.localRange.low.z += heightRange ? heightRange.low : 0;\n        this.localRange.high.z += heightRange ? heightRange.high : 0;\n        this._bilinearPatch = new BilinearPatch(planeCorners[0], planeCorners[1], planeCorners[2], planeCorners[3]);\n    }\n    getPoint(u, v, z, result) {\n        result = this._bilinearPatch.uvFractionToPoint(u, v, result);\n        result.z += z;\n        return result;\n    }\n}\nconst scratchNormal = Vector3d.create();\nconst scratchViewZ = Vector3d.create();\nconst scratchPoint = Point3d.create();\nconst scratchClipPlanes = [ClipPlane.createNormalAndPoint(scratchNormal, scratchPoint), ClipPlane.createNormalAndPoint(scratchNormal, scratchPoint), ClipPlane.createNormalAndPoint(scratchNormal, scratchPoint), ClipPlane.createNormalAndPoint(scratchNormal, scratchPoint)];\nconst scratchCorners = [Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero(), Point3d.createZero()];\n/** A [[Tile]] belonging to a [[MapTileTree]] representing a rectangular region of a map of the Earth.\n * @public\n */\nclass MapTile extends RealityTile {\n    /** @internal */\n    get isReady() {\n        return super.isReady && this.baseImageryIsReady;\n    }\n    /** @internal */\n    get hasGraphics() {\n        return this._renderGeometry !== undefined;\n    }\n    /** @internal */\n    get renderGeometry() { return this._renderGeometry; }\n    /** @internal */\n    get mesh() { return this._mesh; }\n    /** @internal */\n    get loadableTerrainTile() { return this.loadableTile; }\n    /** @internal */\n    get isPlanar() { return this._patch instanceof PlanarTilePatch; }\n    /** @internal */\n    get imageryTiles() { return this._imageryTiles; }\n    /** List of selected tiles but are currently in hidden state (i.e. scale range visibility)\n     * @internal\n     */\n    get hiddenImageryTiles() { return this._hiddenTiles; }\n    /** List of leafs tiles that have been selected as a replacement for missing high resolution tiles.\n     * When this list is non-empty this means we are past the maximum LOD available of the tile tree.\n     * By using those tiles, you are likely to get a display where tiles looks pixelated..\n     * in some cases this is preferred to have no tile at all.\n     * @internal\n     */\n    get highResolutionReplacementTiles() { return this._highResolutionReplacementTiles; }\n    /** @internal */\n    constructor(params, mapTree, quadId, patch, rectangle, heightRange, cornerRays) {\n        super(params, mapTree);\n        /** @internal */\n        this.everLoaded = false; // If the tile is only required for availability metadata, load it once and then allow it to be unloaded.\n        this.mapTree = mapTree;\n        this.quadId = quadId;\n        this._patch = patch;\n        this.rectangle = rectangle;\n        this._cornerRays = cornerRays;\n        this._heightRange = heightRange?.clone();\n    }\n    /** @internal */\n    getRangeCorners(result) {\n        return this._patch instanceof PlanarTilePatch ? this._patch.getRangeCorners(this.heightRange, result) : this.range.corners(result);\n    }\n    /** @internal */\n    getSizeProjectionCorners() {\n        // Use only the first 4 corners -- On terrain tiles the height is initially exagerated to world height range which can cause excessive tile loading.\n        const rangeCorners = this.getRangeCorners(scratchCorners);\n        return rangeCorners.slice(0, 4);\n    }\n    /** @internal */\n    markUsed(args) {\n        super.markUsed(args);\n        if (this._imageryTiles)\n            for (const imageryTile of this._imageryTiles)\n                imageryTile.markUsed(args);\n    }\n    /** @internal */\n    get graphicType() {\n        if (this.mapTree.isOverlay)\n            return TileGraphicType.Overlay;\n        return (this.mapTree.useDepthBuffer || this._forceDepthBuffer) ? TileGraphicType.Scene : TileGraphicType.BackgroundMap;\n    }\n    /** @internal */\n    get mapLoader() { return this.realityRoot.loader; }\n    /** @internal */\n    get isUpsampled() { return false; }\n    /** @internal */\n    tileFromQuadId(quadId) {\n        if (0 === quadId.compare(this.quadId))\n            return this;\n        assert(quadId.level > this.quadId.level);\n        if (quadId.level <= this.quadId.level)\n            return undefined;\n        if (this.children) {\n            const shift = quadId.level - this.quadId.level - 1;\n            const childRow = quadId.row >> shift;\n            const childColumn = quadId.column >> shift;\n            for (const child of this.children) {\n                const mapChild = child;\n                const childQuadId = mapChild.quadId;\n                if (childQuadId.row === childRow && childQuadId.column === childColumn)\n                    return mapChild.tileFromQuadId(quadId);\n            }\n        }\n        return undefined;\n    }\n    get _forceDepthBuffer() {\n        // For large ellipsoidal globe tile force the depth buffer on to avoid anomalies at horizon.\n        return this.mapTree.globeMode === GlobeMode.Ellipsoid && this.depth < 8;\n    }\n    /** @internal */\n    addBoundingGraphic(builder, color) {\n        if (!this.isDisplayable)\n            return;\n        const heightRange = (this.heightRange === undefined) ? Range1d.createXX(-1, 1) : this.heightRange;\n        const lows = [], highs = [], reorder = [0, 1, 3, 2, 0];\n        const cornerRays = this._cornerRays;\n        if (this._patch instanceof PlanarTilePatch) {\n            const normal = this._patch.normal;\n            for (let i = 0; i < 5; i++) {\n                const corner = this._patch.corners[reorder[i]];\n                lows.push(corner.plusScaled(normal, heightRange.low));\n                highs.push(corner.plusScaled(normal, heightRange.high));\n            }\n        }\n        else {\n            for (let i = 0; i < 5; i++) {\n                const cornerRay = cornerRays[reorder[i]];\n                lows.push(cornerRay.origin.plusScaled(cornerRay.direction, heightRange.low));\n                highs.push(cornerRay.origin.plusScaled(cornerRay.direction, heightRange.high));\n            }\n        }\n        builder.setSymbology(color, color, 1);\n        builder.addLineString(lows);\n        builder.addLineString(highs);\n        for (let i = 0; i < 4; i++)\n            builder.addLineString([lows[i], highs[i]]);\n        const inColor = ColorDef.create(ColorByName.cornflowerBlue);\n        const outColor = ColorDef.create(ColorByName.chartreuse);\n        const transitionColor = ColorDef.create(ColorByName.aquamarine);\n        const inPoints = [], outPoints = [], transitionPoints = [];\n        for (const point of highs)\n            if (this.mapTree.cartesianRange.containsPoint(point))\n                inPoints.push(point);\n            else if (this.mapTree.cartesianRange.distanceToPoint(point) < this.mapTree.cartesianTransitionDistance)\n                transitionPoints.push(point);\n            else\n                outPoints.push(point);\n        builder.setSymbology(inColor, inColor, 15);\n        builder.addPointString(inPoints);\n        builder.setSymbology(outColor, outColor, 15);\n        builder.addPointString(outPoints);\n        builder.setSymbology(transitionColor, transitionColor, 31);\n        builder.addPointString(transitionPoints);\n    }\n    /** @internal */\n    getContentClip() {\n        const points = this.getClipShape();\n        if (points.length < 3)\n            return undefined;\n        if (this.mapTree.globeMode === GlobeMode.Ellipsoid) {\n            const normal = PolygonOps.areaNormal(points);\n            const globeOrigin = this.mapTree.globeOrigin;\n            const globeNormal = Vector3d.createStartEnd(globeOrigin, points[0]);\n            const negate = normal.dotProduct(globeNormal) < 0;\n            const clipPlanes = [];\n            for (let i = 0; i < 4; i++) {\n                const point = points[i];\n                const clipNormal = globeOrigin.crossProductToPoints(point, points[(i + 1) % 4], scratchNormal);\n                if (negate)\n                    clipNormal.negate(clipNormal);\n                const clipPlane = ClipPlane.createNormalAndPoint(clipNormal, point, false, false, scratchClipPlanes[i]);\n                if (clipPlane !== undefined) // Undefined at pole tiles...\n                    clipPlanes.push(clipPlane);\n            }\n            const planeSet = ConvexClipPlaneSet.createPlanes(clipPlanes);\n            const clipPrimitive = ClipPrimitive.createCapture(planeSet);\n            return ClipVector.createCapture([clipPrimitive]);\n        }\n        else {\n            return ClipVector.createCapture([ClipShape.createShape(points)]);\n        }\n    }\n    /** @internal */\n    setNotFound() {\n        super.setNotFound();\n        // For map tiles assume that an unfound tile implies descendants and siblings will also be unfound.\n        if (undefined !== this.parent)\n            this.parent.setLeaf();\n    }\n    /** @internal */\n    getGraphic(_system, _texture) {\n        return undefined;\n    }\n    /** For globe tiles displaying less then depth 2 appears distorted\n     * @internal\n     */\n    get isDisplayable() {\n        return this.mapTree.globeMode === GlobeMode.Ellipsoid ? (this.depth >= MapTileTree.minDisplayableDepth) : super.isDisplayable;\n    }\n    /** @internal */\n    isOccluded(viewingSpace) {\n        if (undefined === this._cornerRays || this.mapTree.globeMode !== GlobeMode.Ellipsoid)\n            return false;\n        if (viewingSpace.eyePoint !== undefined) {\n            if (!this.mapTree.pointAboveEllipsoid(viewingSpace.eyePoint))\n                return false;\n            for (const cornerNormal of this._cornerRays) {\n                const eyeNormal = Vector3d.createStartEnd(viewingSpace.eyePoint, cornerNormal.origin, scratchNormal);\n                eyeNormal.normalizeInPlace();\n                if (eyeNormal.dotProduct(cornerNormal.direction) < .01)\n                    return false;\n            }\n        }\n        else {\n            const viewZ = viewingSpace.rotation.getRow(2, scratchViewZ);\n            for (const cornerNormal of this._cornerRays)\n                if (cornerNormal.direction.dotProduct(viewZ) > 0)\n                    return false;\n        }\n        return true;\n    }\n    /** @internal */\n    _loadChildren(resolve, _reject) {\n        const mapTree = this.mapTree;\n        const childLevel = this.quadId.level + 1;\n        const rowCount = mapTree.sourceTilingScheme.getNumberOfYChildrenAtLevel(childLevel);\n        const columnCount = mapTree.sourceTilingScheme.getNumberOfXChildrenAtLevel(childLevel);\n        const resolveChildren = (children) => {\n            const childrenRange = Range3d.createNull();\n            for (const child of children)\n                childrenRange.extendRange(child.range);\n            if (!this.range.containsRange(childrenRange))\n                this.range.extendRange(childrenRange);\n            resolve(children);\n        };\n        if (mapTree.doCreateGlobeChildren(this)) {\n            this.createGlobeChildren(columnCount, rowCount, resolveChildren);\n            return;\n        }\n        const resolvePlanarChildren = (childCorners) => {\n            const level = this.quadId.level + 1;\n            const column = this.quadId.column * 2;\n            const row = this.quadId.row * 2;\n            const children = [];\n            const childrenAreLeaves = (this.depth + 1) === mapTree.loader.maxDepth;\n            const globeMode = this.mapTree.globeMode;\n            for (let j = 0; j < rowCount; j++) {\n                for (let i = 0; i < columnCount; i++) {\n                    const quadId = new QuadId(level, column + i, row + j);\n                    const corners = childCorners[j * columnCount + i];\n                    const rectangle = mapTree.getTileRectangle(quadId);\n                    const normal = PolygonOps.areaNormal([corners[0], corners[1], corners[3], corners[2]]);\n                    normal.normalizeInPlace();\n                    const heightRange = this.mapTree.getChildHeightRange(quadId, rectangle, this);\n                    const diagonal = Math.max(corners[0].distance(corners[3]), corners[1].distance(corners[2])) / 2.0;\n                    const chordHeight = globeMode === GlobeMode.Ellipsoid ? Math.sqrt(diagonal * diagonal + Constant.earthRadiusWGS84.equator * Constant.earthRadiusWGS84.equator) - Constant.earthRadiusWGS84.equator : 0.0;\n                    const rangeCorners = MapTile.computeRangeCorners(corners, normal, chordHeight, undefined, heightRange);\n                    const range = Range3d.createArray(rangeCorners);\n                    const child = this.mapTree.createPlanarChild({ contentId: quadId.contentId, maximumSize: 512, range, parent: this, isLeaf: childrenAreLeaves }, quadId, corners, normal, rectangle, chordHeight, heightRange);\n                    if (child)\n                        children.push(child);\n                }\n            }\n            resolveChildren(children);\n        };\n        mapTree.getPlanarChildCorners(this, columnCount, rowCount, resolvePlanarChildren);\n    }\n    createGlobeChildren(columnCount, rowCount, resolve) {\n        const level = this.quadId.level + 1;\n        const column = this.quadId.column * 2;\n        const row = this.quadId.row * 2;\n        const mapTree = this.mapTree;\n        const children = [];\n        for (let j = 0; j < rowCount; j++) {\n            for (let i = 0; i < columnCount; i++) {\n                const quadId = new QuadId(level, column + i, row + j);\n                const angleSweep = quadId.getAngleSweep(mapTree.sourceTilingScheme);\n                const ellipsoidPatch = EllipsoidPatch.createCapture(this.mapTree.earthEllipsoid, angleSweep.longitude, angleSweep.latitude);\n                const range = ellipsoidPatch.range();\n                const rectangle = mapTree.getTileRectangle(quadId);\n                const heightRange = this.mapTree.getChildHeightRange(quadId, rectangle, this);\n                if (undefined !== heightRange)\n                    range.expandInPlace(heightRange.high - heightRange.low);\n                children.push(this.mapTree.createGlobeChild({ contentId: quadId.contentId, maximumSize: 512, range, parent: this, isLeaf: false }, quadId, range.corners(), rectangle, ellipsoidPatch, heightRange));\n            }\n        }\n        resolve(children);\n        return children;\n    }\n    /** @internal */\n    static computeRangeCorners(corners, normal, chordHeight, result, heightRange) {\n        if (result === undefined) {\n            result = [];\n            for (let i = 0; i < 8; i++)\n                result.push(Point3d.create());\n        }\n        let index = 0;\n        assert(corners.length === 4);\n        const deltaLow = normal.scale(-chordHeight + (heightRange ? heightRange.low : 0));\n        const deltaHigh = normal.scale(chordHeight + (heightRange ? heightRange.high : 0));\n        for (const corner of corners)\n            corner.plus(deltaLow, result[index++]);\n        for (const corner of corners)\n            corner.plus(deltaHigh, result[index++]);\n        return result;\n    }\n    /** @internal */\n    isRegionCulled(args) {\n        return this.isContentCulled(args);\n    }\n    /** @internal */\n    isContentCulled(args) {\n        return FrustumPlanes.Containment.Outside === args.frustumPlanes.computeContainment(this.getRangeCorners(scratchCorners));\n    }\n    /** @internal */\n    clearLayers() {\n        this.clearImageryTiles();\n        this._graphic = undefined;\n        if (this.children)\n            for (const child of this.children)\n                child.clearLayers();\n    }\n    clearImageryTiles() {\n        if (this._imageryTiles) {\n            this._imageryTiles.forEach((tile) => tile.releaseMapTileUsage());\n            this._imageryTiles = undefined;\n        }\n        if (this._hiddenTiles) {\n            this._hiddenTiles = undefined;\n        }\n        if (this._highResolutionReplacementTiles) {\n            this._highResolutionReplacementTiles = undefined;\n        }\n    }\n    /** @internal */\n    produceGraphics() {\n        if (undefined !== this._graphic && this.imageryIsReady)\n            return this._graphic;\n        const geometry = this.renderGeometry;\n        if (undefined === geometry)\n            return undefined;\n        const textures = this.getDrapeTextures();\n        const { baseColor, baseTransparent, layerClassifiers } = this.mapTree;\n        const graphic = IModelApp.renderSystem.createRealityMeshGraphic({ realityMesh: geometry, projection: this.getProjection(), tileRectangle: this.rectangle, featureTable: PackedFeatureTable.pack(this.mapLoader.featureTable), tileId: this.contentId, baseColor, baseTransparent, textures, layerClassifiers }, true);\n        // If there are no layer classifiers then we can save this graphic for re-use.  If layer classifiers exist they are regenerated based on view and we must collate them with the imagery.\n        if (this.imageryIsReady && 0 === this.mapTree.layerClassifiers.size)\n            this._graphic = graphic;\n        return graphic;\n    }\n    /** @internal */\n    getClipShape() {\n        return (this._patch instanceof PlanarTilePatch) ? this._patch.getClipShape() : [this._cornerRays[0].origin, this._cornerRays[1].origin, this._cornerRays[3].origin, this._cornerRays[2].origin];\n    }\n    /** @internal */\n    _collectStatistics(stats) {\n        super._collectStatistics(stats);\n        this._renderGeometry?.collectStatistics(stats);\n        if (this._mesh) {\n            stats.addTerrain(this._mesh.indices.byteLength\n                + this._mesh.positions.points.byteLength\n                + this._mesh.uvs.points.byteLength\n                + (this._mesh.normals ? this._mesh.normals.byteLength : 0));\n        }\n    }\n    /** Height range is along with the tile corners to detect if tile intersects view frustum.\n     * Range will be single value fo ron-terrain tiles -- if terrain tile is not loaded it will\n     * inherit height from ancestors.\n     * @internal\n     */\n    get heightRange() {\n        if (undefined !== this._heightRange)\n            return this._heightRange;\n        for (let parent = this.parent; undefined !== parent; parent = parent.parent) {\n            const mapParent = parent;\n            if (undefined !== mapParent._heightRange)\n                return mapParent._heightRange;\n        }\n        assert(false);\n        return Range1d.createNull();\n    }\n    /** @internal */\n    get mapTilingScheme() {\n        return this.mapTree.sourceTilingScheme;\n    }\n    /** Adjust the minimum and maximum elevations of the terrain within this tile. */\n    adjustHeights(minHeight, maxHeight) {\n        if (undefined === this._heightRange)\n            this._heightRange = Range1d.createXX(minHeight, maxHeight);\n        else {\n            this._heightRange.low = Math.max(this.heightRange.low, minHeight);\n            this._heightRange.high = Math.min(this.heightRange.high, maxHeight);\n        }\n        if (this.rangeCorners && this._patch instanceof PlanarTilePatch)\n            this._patch.getRangeCorners(this.heightRange, this.rangeCorners);\n    }\n    /** Obtain a [[MapTileProjection]] to project positions within this tile's area into 3d space. */\n    getProjection(heightRange) {\n        return this._patch instanceof PlanarTilePatch ? new PlanarProjection(this._patch, heightRange) : new EllipsoidProjection(this._patch, heightRange);\n    }\n    /** @internal */\n    get baseImageryIsReady() {\n        if (undefined !== this.mapTree.baseColor || 0 === this.mapTree.layerImageryTrees.length)\n            return true;\n        if (undefined === this._imageryTiles)\n            return false;\n        const baseTreeId = this.mapTree.layerImageryTrees[0].tree.modelId;\n        return this._imageryTiles.every((imageryTile) => imageryTile.imageryTree.modelId !== baseTreeId || imageryTile.isReady);\n    }\n    /** @internal */\n    get imageryIsReady() {\n        if (undefined === this._imageryTiles)\n            return 0 === this.mapTree.layerImageryTrees.length;\n        return this._imageryTiles.every((tile) => tile.isReady);\n    }\n    /** Select secondary (imagery) tiles\n     * @internal\n     */\n    selectSecondaryTiles(args, context) {\n        if (0 === this.mapTree.layerImageryTrees.length || this.imageryIsReady)\n            return;\n        this.clearImageryTiles();\n        this._imageryTiles = new Array();\n        this._hiddenTiles = new Array();\n        this._highResolutionReplacementTiles = new Array();\n        for (const layerImageryTree of this.mapTree.layerImageryTrees) {\n            let tmpTiles = new Array();\n            const tmpLeafTiles = new Array();\n            if (TileTreeLoadStatus.Loaded !== layerImageryTree.tree.selectCartoDrapeTiles(tmpTiles, tmpLeafTiles, this, args)) {\n                this._imageryTiles = undefined;\n                return;\n            }\n            // When the base layer is zoomed-in beyond it's max resolution,\n            // we display leaf tiles and stretched them if needed.\n            // We don't want the same behavior non-base layers, in the case,\n            // the layer will simply disappear past its max resolution.\n            // Note: Replacement leaf tiles are kept as a mean to determine which\n            // imagery tree has reached it's maximum zoom level.\n            if (layerImageryTree.baseImageryLayer) {\n                tmpTiles = [...tmpTiles, ...tmpLeafTiles];\n            }\n            else {\n                this._highResolutionReplacementTiles = [...this._highResolutionReplacementTiles, ...tmpLeafTiles];\n            }\n            // MapTileTree might include a non-visible imagery tree, we need to check for that.\n            if (layerImageryTree.settings.visible && !layerImageryTree.settings.allSubLayersInvisible) {\n                for (const imageryTile of tmpTiles) {\n                    imageryTile.markMapTileUsage();\n                    if (imageryTile.isReady)\n                        args.markReady(imageryTile);\n                    else\n                        context.missing.push(imageryTile);\n                    this._imageryTiles.push(imageryTile);\n                }\n            }\n            else {\n                // Even though those selected imagery tile are not visible,\n                // we keep track of them for scale range reporting.\n                for (const imageryTile of tmpTiles) {\n                    this._hiddenTiles.push(imageryTile);\n                }\n            }\n        }\n    }\n    /** The height range for terrain tiles is not known until the tiles are unloaded.  We use \"ApproximateTerrainHeight\" for first 6 levels but below\n     * that the tiles inherit height range from parents.  This is problematic as tiles with large height range will be unnecessarily selected as\n     * they apparently intersect view frustum.   To avoid this force loading of terrain tiles if they exceed \"_maxParentHightDepth\".\n     * @internal\n     */\n    forceSelectRealityTile() {\n        let parentHeightDepth = 0;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        for (let parent = this; parent !== undefined && parent._heightRange === undefined; parent = parent.parent)\n            parentHeightDepth++;\n        return parentHeightDepth > MapTile._maxParentHeightDepth;\n    }\n    /** @internal */\n    minimumVisibleFactor() {\n        // if minimumVisibleFactor is more than 0, it stops parents from loading when children are not ready, to fill in gaps\n        return 0.0;\n    }\n    /** @internal */\n    getDrapeTextures() {\n        if (undefined === this._imageryTiles)\n            return undefined;\n        const drapeTextures = [];\n        const thisRectangle = this.loadableTerrainTile.rectangle;\n        const thisDiagonal = thisRectangle.diagonal(MapTile._scratchThisDiagonal);\n        const bordersNorthPole = this.quadId.bordersNorthPole(this.mapTree.sourceTilingScheme);\n        const bordersSouthPole = this.quadId.bordersSouthPole(this.mapTree.sourceTilingScheme);\n        for (const imageryTile of this._imageryTiles) {\n            if (imageryTile.texture) {\n                drapeTextures.push(this.computeDrapeTexture(thisRectangle, thisDiagonal, imageryTile, imageryTile.rectangle));\n                if ((bordersNorthPole && imageryTile.quadId.bordersNorthPole(imageryTile.tilingScheme) && imageryTile.rectangle.high.y < thisRectangle.high.y) ||\n                    (bordersSouthPole && imageryTile.quadId.bordersSouthPole(imageryTile.tilingScheme) && imageryTile.rectangle.low.y > thisRectangle.low.y)) {\n                    // Add separate texture stretching last sliver of tile imagery to cover pole.\n                    const sliverRectangle = imageryTile.rectangle.clone(MapTile._scratchRectangle1);\n                    const clipRectangle = thisRectangle.clone(MapTile._scratchRectangle2);\n                    const sliverHeight = sliverRectangle.high.y - sliverRectangle.low.y;\n                    if (bordersSouthPole) {\n                        clipRectangle.high.y = sliverRectangle.low.y;\n                        sliverRectangle.low.y = thisRectangle.low.y;\n                        sliverRectangle.high.y += 1 / sliverHeight;\n                    }\n                    else {\n                        clipRectangle.low.y = sliverRectangle.high.y;\n                        sliverRectangle.high.y = thisRectangle.high.y;\n                        sliverRectangle.low.y -= 1 / sliverHeight;\n                    }\n                    drapeTextures.push(this.computeDrapeTexture(thisRectangle, thisDiagonal, imageryTile, sliverRectangle, clipRectangle));\n                }\n            }\n            else {\n                for (let parent = imageryTile.parent; undefined !== parent; parent = parent.parent) {\n                    const mapTile = parent;\n                    if (mapTile.texture) {\n                        drapeTextures.push(this.computeDrapeTexture(thisRectangle, thisDiagonal, mapTile, mapTile.rectangle, imageryTile.rectangle));\n                        break;\n                    }\n                }\n            }\n        }\n        return drapeTextures.length > 0 ? drapeTextures : undefined;\n    }\n    computeDrapeTexture(thisRectangle, thisDiagonal, imageryTile, drapeRectangle, clipRectangle) {\n        assert(imageryTile.texture !== undefined);\n        // Compute transformation from the terrain tile texture coordinates (0-1) to the drape tile texture coordinates.\n        const drapeDiagonal = drapeRectangle.diagonal(MapTile._scratchDrapeDiagonal);\n        const translate = Vector2d.create((thisRectangle.low.x - drapeRectangle.low.x) / drapeDiagonal.x, (thisRectangle.low.y - drapeRectangle.low.y) / drapeDiagonal.y);\n        const scale = Vector2d.create(thisDiagonal.x / drapeDiagonal.x, thisDiagonal.y / drapeDiagonal.y);\n        const featureIndex = this.mapLoader.getFeatureIndex(imageryTile.imageryTree.modelId);\n        let clipRect;\n        if (undefined !== clipRectangle) {\n            const intersect = clipRectangle.intersect(drapeRectangle, MapTile._scratchIntersectRange);\n            assert(!intersect.isNull);\n            clipRect = Range2d.createXYXY((intersect.low.x - drapeRectangle.low.x) / drapeDiagonal.x, (intersect.low.y - drapeRectangle.low.y) / drapeDiagonal.y, (intersect.high.x - drapeRectangle.low.x) / drapeDiagonal.x, (intersect.high.y - drapeRectangle.low.y) / drapeDiagonal.y);\n        }\n        const imageryModelId = imageryTile.tree.modelId;\n        return new TerrainTexture(imageryTile.texture, featureIndex, scale, translate, drapeRectangle, this.mapTree.getLayerIndex(imageryModelId), this.mapTree.getLayerTransparency(imageryModelId), clipRect);\n    }\n    /** @internal */\n    setContent(content) {\n        if (this.quadId.level < this.maxDepth) {\n            const childIds = this.quadId.getChildIds();\n            for (const childId of childIds) {\n                if (!this.mapLoader.isTileAvailable(childId)) {\n                    this._mesh = content.terrain?.mesh; // If a child is unavailable retain mesh for upsampling.\n                    break;\n                }\n            }\n        }\n        if (this.mapTree.produceGeometry) {\n            const iModelTransform = this.mapTree.iModelTransform;\n            const geometryTransform = content.terrain?.renderGeometry?.transform;\n            const transform = geometryTransform ? iModelTransform.multiplyTransformTransform(geometryTransform) : iModelTransform;\n            const polyface = content.terrain?.mesh ? RealityMeshParams.toPolyface(content.terrain.mesh, { transform }) : undefined;\n            this._geometry = polyface ? { polyfaces: [polyface] } : undefined;\n        }\n        else {\n            dispose(this._renderGeometry);\n            this._renderGeometry = content.terrain?.renderGeometry;\n        }\n        this.everLoaded = true;\n        if (undefined !== content.contentRange)\n            this._contentRange = content.contentRange;\n        this.setIsReady();\n    }\n    /** @internal */\n    freeMemory() {\n        // ###TODO MapTiles and ImageryMapTiles share resources and don't currently interact well with TileAdmin.freeMemory(). Opt out for now.\n    }\n    /** @internal */\n    disposeContents() {\n        super.disposeContents();\n        this._renderGeometry = dispose(this._renderGeometry);\n        this.clearImageryTiles();\n        // Note - don't dispose of mesh - these should only ever exist on terrain leaf tile and are required by children.  Let garbage collector handle them.\n    }\n}\nMapTile._maxParentHeightDepth = 4;\nMapTile._scratchRectangle1 = MapCartoRectangle.createZero();\nMapTile._scratchRectangle2 = MapCartoRectangle.createZero();\nMapTile._scratchThisDiagonal = Vector2d.create();\nMapTile._scratchDrapeDiagonal = Vector2d.create();\nMapTile._scratchIntersectRange = Range2d.createNull();\nexport { MapTile };\n/** A child tile that has no content of its own available. It instead produces content by up-sampling the content of an ancestor tile.\n * @internal\n  */\nexport class UpsampledMapTile extends MapTile {\n    constructor(params, mapTree, quadId, patch, rectangle, heightRange, cornerRays, loadableTile) {\n        super(params, mapTree, quadId, patch, rectangle, heightRange, cornerRays);\n        this._loadableTile = loadableTile;\n    }\n    get isUpsampled() { return true; }\n    get isEmpty() { return false; }\n    get loadableTile() { return this._loadableTile; }\n    upsampleFromParent() {\n        const parent = this.loadableTerrainTile;\n        const parentMesh = parent.mesh;\n        if (undefined === parentMesh) {\n            return undefined;\n        }\n        const thisId = this.quadId, parentId = parent.quadId;\n        const levelDelta = thisId.level - parentId.level;\n        const thisColumn = thisId.column - (parentId.column << levelDelta);\n        const thisRow = thisId.row - (parentId.row << levelDelta);\n        const scale = 1.0 / (1 << levelDelta);\n        const parentParameterRange = Range2d.createXYXY(scale * thisColumn, scale * thisRow, scale * (thisColumn + 1), scale * (thisRow + 1));\n        const upsample = upsampleRealityMeshParams(parentMesh, parentParameterRange);\n        this.adjustHeights(upsample.heightRange.low, upsample.heightRange.high);\n        return upsample;\n    }\n    get renderGeometry() {\n        if (undefined === this._renderGeometry) {\n            const upsample = this.upsampleFromParent();\n            const projection = this.loadableTerrainTile.getProjection(this.heightRange);\n            if (upsample)\n                this._renderGeometry = IModelApp.renderSystem.createTerrainMesh(upsample.mesh, projection.transformFromLocal, true);\n        }\n        return this._renderGeometry;\n    }\n    get isLoading() { return this.loadableTile.isLoading; }\n    get isQueued() { return this.loadableTile.isQueued; }\n    get isNotFound() { return this.loadableTile.isNotFound; }\n    get isReady() { return (this._renderGeometry !== undefined || this.loadableTile.loadStatus === TileLoadStatus.Ready) && this.baseImageryIsReady; }\n    markUsed(args) {\n        args.markUsed(this);\n        args.markUsed(this.loadableTile);\n    }\n}\n//# sourceMappingURL=MapTile.js.map",
      "start": 1693508122020,
      "end": 1693508122134,
      "sourcemaps": null
    }
  ]
}
