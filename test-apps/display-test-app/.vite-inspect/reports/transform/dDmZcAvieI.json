{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/NativeApp.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module NativeApp\n */\nvar _a;\nimport { BeEvent, Logger } from \"@itwin/core-bentley\";\nimport { IModelVersion, InternetConnectivityStatus, nativeAppIpcStrings, OverriddenBy, SyncMode, } from \"@itwin/core-common\";\nimport { FrontendLoggerCategory } from \"./common/FrontendLoggerCategory\";\nimport { IpcApp, NotificationHandler } from \"./IpcApp\";\nimport { NativeAppLogger } from \"./NativeAppLogger\";\n/** NativeApp notifications from backend */\nclass NativeAppNotifyHandler extends NotificationHandler {\n    get channelName() { return nativeAppIpcStrings.notifyChannel; }\n    notifyInternetConnectivityChanged(status) {\n        Logger.logInfo(FrontendLoggerCategory.NativeApp, \"Internet connectivity changed\");\n        NativeApp.onInternetConnectivityChanged.raiseEvent(status);\n    }\n}\n/**\n * The frontend of a native application\n * @see [Native Applications]($docs/learning/NativeApps.md)\n * @public\n */\nclass NativeApp {\n    /** @deprecated in 3.x. use nativeAppIpc */\n    static async callNativeHost(methodName, ...args) {\n        return IpcApp.callIpcChannel(nativeAppIpcStrings.channelName, methodName, ...args);\n    }\n    static async setConnectivity(by, status) {\n        await this.nativeAppIpc.overrideInternetConnectivity(by, status);\n    }\n    static hookBrowserConnectivityEvents() {\n        if (typeof window === \"object\" && window.ononline && window.onoffline) {\n            window.addEventListener(\"online\", this._onOnline);\n            window.addEventListener(\"offline\", this._onOffline);\n        }\n    }\n    static unhookBrowserConnectivityEvents() {\n        if (typeof window === \"object\" && window.ononline && window.onoffline) {\n            window.removeEventListener(\"online\", this._onOnline);\n            window.removeEventListener(\"offline\", this._onOffline);\n        }\n    }\n    /** determine whether the app currently has internet connectivity, if known */\n    static async checkInternetConnectivity() {\n        return this.nativeAppIpc.checkInternetConnectivity();\n    }\n    /** @internal */\n    static async overrideInternetConnectivity(status) {\n        return this.nativeAppIpc.overrideInternetConnectivity(OverriddenBy.User, status);\n    }\n    static get isValid() { return this._isValid; }\n    /**\n     * This is called by either ElectronApp.startup or MobileApp.startup - it should not be called directly\n     * @internal\n     */\n    static async startup(ipc, opts) {\n        await IpcApp.startup(ipc, opts);\n        if (this._isValid)\n            return;\n        this._isValid = true;\n        this._removeAppNotify = NativeAppNotifyHandler.register(); // receives notifications from backend\n        NativeApp.hookBrowserConnectivityEvents();\n        // initialize current online state.\n        if (window.navigator.onLine) {\n            await this.setConnectivity(OverriddenBy.Browser, window.navigator.onLine ? InternetConnectivityStatus.Online : InternetConnectivityStatus.Offline);\n        }\n    }\n    /** @internal */\n    static async shutdown() {\n        this._removeAppNotify?.();\n        NativeApp.unhookBrowserConnectivityEvents();\n        await NativeAppLogger.flush();\n        await IpcApp.shutdown();\n        this._isValid = false;\n    }\n    static async requestDownloadBriefcase(iTwinId, iModelId, downloadOptions, asOf = IModelVersion.latest(), progress) {\n        const shouldReportProgress = !!progress || !!downloadOptions.progressCallback;\n        let stopProgressEvents = () => { };\n        if (shouldReportProgress) {\n            const handleProgress = (_evt, data) => {\n                progress?.(data);\n                downloadOptions.progressCallback?.(data);\n            };\n            stopProgressEvents = IpcApp.addListener(`nativeApp.progress-${iModelId}`, handleProgress);\n        }\n        const briefcaseId = (undefined !== downloadOptions.briefcaseId) ? downloadOptions.briefcaseId :\n            (downloadOptions.syncMode === SyncMode.PullOnly ? 0 : await this.nativeAppIpc.acquireNewBriefcaseId(iModelId));\n        const fileName = downloadOptions.fileName ?? await this.getBriefcaseFileName({ briefcaseId, iModelId });\n        const requestProps = { iModelId, briefcaseId, iTwinId, asOf: asOf.toJSON(), fileName };\n        const doDownload = async () => {\n            try {\n                await this.nativeAppIpc.downloadBriefcase(requestProps, shouldReportProgress, downloadOptions.progressInterval);\n            }\n            finally {\n                stopProgressEvents();\n            }\n        };\n        const requestCancel = async () => {\n            const status = await this.nativeAppIpc.requestCancelDownloadBriefcase(fileName);\n            if (status)\n                stopProgressEvents();\n            return status;\n        };\n        return { briefcaseId, fileName, downloadPromise: doDownload(), requestCancel };\n    }\n    /** Get the full path filename for a briefcase within the briefcase cache */\n    static async getBriefcaseFileName(props) {\n        return this.nativeAppIpc.getBriefcaseFileName(props);\n    }\n    /** Delete an existing briefcase\n     * @param fileName the briefcase fileName\n     */\n    static async deleteBriefcase(fileName) {\n        await this.nativeAppIpc.deleteBriefcaseFiles(fileName);\n    }\n    /** Get a list of all briefcase files held in the local briefcase cache directory */\n    static async getCachedBriefcases(iModelId) {\n        return this.nativeAppIpc.getCachedBriefcases(iModelId);\n    }\n    /**\n     * Open a [[Storage]]. Creates a new Storage with that name if it does not already exist.\n     * @param name Should be a local filename without an extension.\n     * @returns a Promise for the [[Storage]].\n     */\n    static async openStorage(name) {\n        if (this._storages.has(name))\n            return this._storages.get(name);\n        const storage = new Storage(await this.nativeAppIpc.storageMgrOpen(name));\n        this._storages.set(storage.id, storage);\n        return storage;\n    }\n    /**\n     * Close a Storage and optionally delete it.\n     * @param storage normally not call directly instead use Storage.close()\n     * @param deleteStorage if true, delete the storage from disk after closing it.\n     */\n    static async closeStorage(storage, deleteStorage = false) {\n        if (!this._storages.has(storage.id))\n            throw new Error(`Storage [Id=${storage.id}] not open`);\n        await this.nativeAppIpc.storageMgrClose(storage.id, deleteStorage);\n        this._storages.delete(storage.id);\n    }\n    /** Get the list of existing Storages on the local disk. */\n    static async getStorageNames() {\n        return NativeApp.nativeAppIpc.storageMgrNames();\n    }\n}\n_a = NativeApp;\n/** A Proxy to call one of the [NativeAppFunctions]($common) functions via IPC. */\nNativeApp.nativeAppIpc = IpcApp.makeIpcProxy(nativeAppIpcStrings.channelName);\nNativeApp._storages = new Map();\nNativeApp._onOnline = async () => {\n    await NativeApp.setConnectivity(OverriddenBy.Browser, InternetConnectivityStatus.Online);\n};\nNativeApp._onOffline = async () => {\n    await NativeApp.setConnectivity(OverriddenBy.Browser, InternetConnectivityStatus.Offline);\n};\n/** event called when internet connectivity changes, if known */\nNativeApp.onInternetConnectivityChanged = new BeEvent();\nNativeApp._isValid = false;\nexport { NativeApp };\n/**\n *  A local disk-based cache for key value pairs for NativeApps.\n * @note This should be used only for local caching, since its not guaranteed to exist permanently.\n * @public\n */\nexport class Storage {\n    constructor(id) {\n        this.id = id;\n    }\n    /** get the type of a value for a key, or undefined if not present. */\n    async getValueType(key) {\n        return NativeApp.nativeAppIpc.storageGetValueType(this.id, key);\n    }\n    /** Get the value for a key */\n    async getData(key) {\n        return NativeApp.nativeAppIpc.storageGet(this.id, key);\n    }\n    /** Set value for a key */\n    async setData(key, value) {\n        return NativeApp.nativeAppIpc.storageSet(this.id, key, value);\n    }\n    /**\n     * Return an array of all keys in this Storage.\n     * @note This can be expensive, depending on the number of keys present.\n     */\n    async getKeys() {\n        return NativeApp.nativeAppIpc.storageKeys(this.id);\n    }\n    /** Remove a key and its data. */\n    async removeData(key) {\n        return NativeApp.nativeAppIpc.storageRemove(this.id, key);\n    }\n    /** Remove all keys and their data. */\n    async removeAll() {\n        return NativeApp.nativeAppIpc.storageRemoveAll(this.id);\n    }\n}\n//# sourceMappingURL=NativeApp.js.map",
      "start": 1693508119422,
      "end": 1693508119578,
      "sourcemaps": null
    }
  ]
}
