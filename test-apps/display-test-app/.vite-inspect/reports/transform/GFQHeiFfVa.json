{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/webgl/LayerCommands.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module WebGL\n */\nimport { assert, compareNumbers, compareStrings, SortedArray } from \"@itwin/core-bentley\";\nimport { PopBatchCommand, PopBranchCommand, } from \"./DrawCommand\";\nclass State {\n    constructor(map) {\n        this.map = map;\n    }\n    executeTransition(newState, func) {\n        this.map.state = newState;\n        func();\n        newState.exit();\n        this.map.state = this;\n    }\n    exit() { }\n    throwStateError(operation) {\n        // Using assert because these are intended for developers.\n        assert(false, `Invalid layer command: operation '${operation}' unimplemented for state '${this.opcode}'`);\n    }\n    processLayers(_container, _func) {\n        this.throwStateError(\"processLayers\");\n    }\n    pushAndPop(push, _pop, func) {\n        if (\"pushBatch\" === push.opcode)\n            this.processBatch(push, func);\n        else if (\"pushBranch\" === push.opcode)\n            this.processBranch(push, func);\n        else\n            this.throwStateError(\"unhandled push command\");\n    }\n    processBranch(_push, _func) {\n        this.throwStateError(\"processBranch\");\n    }\n    processBatch(_push, _func) {\n        this.throwStateError(\"processBatch\");\n    }\n    set currentLayer(_layer) {\n        this.throwStateError(\"setCurrentLayer\");\n    }\n    addCommands(_commands) {\n        this.throwStateError(\"addCommands\");\n    }\n}\nclass IdleState extends State {\n    get opcode() { return \"Idle\"; }\n    constructor(map) {\n        super(map);\n    }\n    processLayers(container, func) {\n        this.executeTransition(new ContainerState(this, container), func);\n    }\n}\nclass ContainerState extends State {\n    get opcode() { return \"Container\"; }\n    constructor(idle, container) {\n        super(idle.map);\n        this.elevation = container.elevation;\n    }\n    processBranch(push, func) {\n        this.executeTransition(new BranchState(this, push), func);\n    }\n}\nclass BranchState extends State {\n    get opcode() { return \"Branch\"; }\n    constructor(containerState, pushCommand) {\n        super(containerState.map);\n        this._layerCommands = new Set();\n        this.containerState = containerState;\n        this.pushCommand = pushCommand;\n    }\n    processBatch(push, func) {\n        this.executeTransition(new BatchState(this, push), func);\n    }\n    markLayer(cmds) {\n        if (!this._layerCommands.has(cmds)) {\n            cmds.commands.push(this.pushCommand);\n            this._layerCommands.add(cmds);\n        }\n    }\n    exit() {\n        for (const cmds of this._layerCommands)\n            cmds.commands.push(PopBranchCommand.instance);\n    }\n}\nclass BatchState extends State {\n    get opcode() { return \"Batch\"; }\n    constructor(branchState, pushCommand) {\n        super(branchState.map);\n        this.branchState = branchState;\n        this.pushCommand = pushCommand;\n    }\n    set currentLayer(layer) {\n        if (undefined === layer)\n            this.throwStateError(\"currentLayer = undefined\");\n        else\n            this.map.state = new LayerState(this, layer);\n    }\n}\nclass LayerState extends State {\n    get opcode() { return \"Layer\"; }\n    constructor(batchState, layer) {\n        super(batchState.map);\n        this._batchState = batchState;\n        this.commands = this.map.getCommands(layer, batchState.branchState.containerState.elevation);\n        this._batchState.branchState.markLayer(this.commands);\n        this.commands.commands.push(batchState.pushCommand);\n    }\n    set currentLayer(layer) {\n        if (undefined === layer) {\n            this.commands.commands.push(PopBatchCommand.instance);\n            this.map.state = this._batchState;\n        }\n        else {\n            this.throwStateError(\"currentLayer != undefined\");\n        }\n    }\n    pushAndPop(push, pop, func) {\n        this.commands.commands.push(push);\n        func();\n        this.commands.commands.push(pop);\n    }\n    addCommands(commands) {\n        for (const command of commands)\n            this.commands.commands.push(command);\n    }\n}\n/** DrawCommands associated with one Layer, drawn during the Layers render pass. */\nclass LayerCommands {\n    constructor(layerId, priority, elevation) {\n        this.commands = [];\n        this.layerId = layerId;\n        this.priority = priority;\n        this.elevation = elevation;\n    }\n}\nclass LayerCommandMap extends SortedArray {\n    constructor(target) {\n        // Layers with different view Z draw in ascending order by Z.\n        // Layers with same elevation draw in ascending order by priority.\n        // Layers with same elevation and priority draw in indeterminate order.\n        super((lhs, rhs) => {\n            let cmp = compareNumbers(lhs.elevation, rhs.elevation);\n            if (0 === cmp) {\n                cmp = compareNumbers(lhs.priority, rhs.priority);\n                if (0 === cmp)\n                    cmp = compareStrings(lhs.layerId, rhs.layerId);\n            }\n            return cmp;\n        });\n        this.target = target;\n        this.state = new IdleState(this);\n    }\n    clear() {\n        super.clear();\n        assert(this.state instanceof IdleState);\n    }\n    getCommands(layer, elevation) {\n        for (const entry of this._array)\n            if (entry.layerId === layer.layerId && entry.elevation === elevation)\n                return entry;\n        const cmds = new LayerCommands(layer.layerId, layer.getPriority(this.target), elevation);\n        this.insert(cmds);\n        return cmds;\n    }\n    outputCommands(cmds) {\n        for (const entry of this._array)\n            for (const cmd of entry.commands)\n                cmds.push(cmd);\n    }\n}\n/** @internal */\nexport class LayerCommandLists {\n    constructor(cmds) {\n        this._maps = [];\n        this._renderCommands = cmds;\n    }\n    clear() {\n        this._maps.length = 0;\n    }\n    processLayers(container, func) {\n        assert(undefined === this._activeMap);\n        const pass = container.renderPass;\n        this._activeMap = this._maps[pass];\n        if (undefined === this._activeMap) {\n            this._activeMap = new LayerCommandMap(this._renderCommands.target);\n            this._maps[pass] = this._activeMap;\n        }\n        this._activeMap.state.processLayers(container, func);\n        this._activeMap = undefined;\n    }\n    set currentLayer(layer) {\n        assert(undefined !== this._activeMap);\n        this._activeMap.state.currentLayer = layer;\n    }\n    addCommands(cmds) {\n        assert(undefined !== this._activeMap);\n        this._activeMap.state.addCommands(cmds);\n    }\n    pushAndPop(push, pop, func) {\n        assert(undefined !== this._activeMap);\n        this._activeMap.state.pushAndPop(push, pop, func);\n    }\n    outputCommands() {\n        this.outputCommandsForPass(1 /* RenderPass.OpaqueLayers */);\n        this.outputCommandsForPass(7 /* RenderPass.TranslucentLayers */);\n        this.outputCommandsForPass(11 /* RenderPass.OverlayLayers */);\n    }\n    outputCommandsForPass(pass) {\n        const map = this._maps[pass];\n        if (undefined !== map)\n            map.outputCommands(this._renderCommands.getCommands(pass));\n    }\n}\n//# sourceMappingURL=LayerCommands.js.map",
      "start": 1693508126116,
      "end": 1693508126252,
      "sourcemaps": null
    }
  ]
}
