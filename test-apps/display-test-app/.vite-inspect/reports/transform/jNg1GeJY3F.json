{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/GrowableBlockedArray.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module ArraysAndInterfaces\n */\n/**\n * Array of contiguous doubles, indexed by block number and index within block.\n * * This is essentially a rectangular matrix (two dimensional array), with each block being a row of the matrix.\n * @public\n */\nexport class GrowableBlockedArray {\n    /**\n     * Construct an array whose contents are in blocked (row-major) order, possibly with extra capacity.\n     * * Total capacity is `this._data.length`\n     * * Actual in-use count is `this._inUse * this._blockSize`\n     * @param blockSize number of entries in each block, i.e., row size\n     * @param initialBlocks initial capacity in blocks (default 8)\n     * @param growthFactor used by ensureBlockCapacity to expand requested reallocation size (default 1.5)\n     */\n    constructor(blockSize, initialBlocks = 8, growthFactor) {\n        this._data = new Float64Array(initialBlocks * blockSize);\n        this._inUse = 0;\n        this._blockSize = blockSize > 0 ? blockSize : 1;\n        this._growthFactor = (undefined !== growthFactor && growthFactor >= 1.0) ? growthFactor : 1.5;\n    }\n    /** Copy data from source array. Does not reallocate or change active block count.\n     * @param source array to copy from\n     * @param sourceCount copy the first sourceCount blocks; all blocks if undefined\n     * @param destOffset copy to instance array starting at this block index; zero if undefined\n     * @return count and offset of blocks copied\n     */\n    copyData(source, sourceCount, destOffset) {\n        // validate inputs and convert from blocks to entries\n        let myOffset = (undefined !== destOffset) ? destOffset * this.numPerBlock : 0;\n        if (myOffset < 0)\n            myOffset = 0;\n        if (myOffset >= this._data.length)\n            return { count: 0, offset: 0 };\n        let myCount = (undefined !== sourceCount) ? sourceCount * this.numPerBlock : source.length;\n        if (myCount > 0) {\n            if (myCount > source.length)\n                myCount = source.length;\n            if (myOffset + myCount > this._data.length)\n                myCount = this._data.length - myOffset;\n            if (myCount % this.numPerBlock !== 0)\n                myCount -= myCount % this.numPerBlock;\n        }\n        if (myCount <= 0)\n            return { count: 0, offset: 0 };\n        if (myCount === source.length)\n            this._data.set(source, myOffset);\n        else if (source instanceof Float64Array)\n            this._data.set(source.subarray(0, myCount), myOffset);\n        else\n            this._data.set(source.slice(0, myCount), myOffset);\n        return { count: myCount / this.numPerBlock, offset: myOffset / this.numPerBlock };\n    }\n    /**\n     * Make a copy of the (active) blocks in this array.\n     * (The clone does NOT get excess capacity)\n     */\n    clone() {\n        const newBlocks = new GrowableBlockedArray(this.numPerBlock, this.numBlocks, this._growthFactor);\n        newBlocks.copyData(this._data, this.numBlocks);\n        newBlocks._inUse = this.numBlocks;\n        return newBlocks;\n    }\n    /** computed property: length (in blocks, not doubles) */\n    get length() { return this._inUse; }\n    /** computed property: length (in blocks, not doubles) */\n    get numBlocks() { return this._inUse; }\n    /** property: number of data values per block */\n    get numPerBlock() { return this._blockSize; }\n    /**\n     * Return a single value indexed within a block. Indices are unchecked.\n     * @param blockIndex index of block to read\n     * @param indexInBlock  offset within the block\n     */\n    getWithinBlock(blockIndex, indexWithinBlock) {\n        return this._data[blockIndex * this._blockSize + indexWithinBlock];\n    }\n    /** clear the block count to zero, but maintain the allocated memory */\n    clear() { this._inUse = 0; }\n    /** Return the capacity in blocks (not doubles) */\n    blockCapacity() {\n        return this._data.length / this._blockSize;\n    }\n    /** ensure capacity (in blocks, not doubles) */\n    ensureBlockCapacity(blockCapacity, applyGrowthFactor = true) {\n        if (blockCapacity > this.blockCapacity()) {\n            if (applyGrowthFactor)\n                blockCapacity *= this._growthFactor;\n            const prevData = this._data;\n            this._data = new Float64Array(blockCapacity * this._blockSize);\n            this.copyData(prevData, this._inUse);\n        }\n    }\n    /** Add a new block of data.\n     * * If newData has fewer than numPerBlock entries, the remaining part of the new block is zeros.\n     * * If newData has more entries, only the first numPerBlock are taken.\n     */\n    addBlock(newData) {\n        const k0 = this.newBlockIndex();\n        let numValue = newData.length;\n        if (numValue > this._blockSize)\n            numValue = this._blockSize;\n        for (let i = 0; i < numValue; i++)\n            this._data[k0 + i] = newData[i];\n    }\n    /**\n     * Return the starting index of a block of (zero-initialized) doubles at the end.\n     *\n     * * this.data is reallocated if needed to include the new block.\n     * * The inUse count is incremented to include the new block.\n     * * The returned block is an index to the Float64Array (not a block index)\n     */\n    newBlockIndex() {\n        const index = this._blockSize * this._inUse;\n        if ((index + 1) > this._data.length)\n            this.ensureBlockCapacity(1 + this._inUse);\n        this._inUse++;\n        for (let i = index; i < index + this._blockSize; i++)\n            this._data[i] = 0.0;\n        return index;\n    }\n    /** reduce the block count by one. */\n    popBlock() {\n        if (this._inUse > 0)\n            this._inUse--;\n    }\n    /** convert a block index to the simple index to the underlying Float64Array. */\n    blockIndexToDoubleIndex(blockIndex) { return this._blockSize * blockIndex; }\n    /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */\n    checkedComponent(blockIndex, componentIndex) {\n        if (blockIndex >= this._inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this._blockSize)\n            return undefined;\n        return this._data[this._blockSize * blockIndex + componentIndex];\n    }\n    /** Access a single double at offset within a block.  This has no index checking. */\n    component(blockIndex, componentIndex) {\n        return this._data[this._blockSize * blockIndex + componentIndex];\n    }\n    /** compare two blocks in simple lexical order.\n     * @param data data array\n     * @param blockSize number of items to compare\n     * @param ia raw index (not block index) of first block\n     * @param ib raw index (not block index) of second block\n     */\n    static compareLexicalBlock(data, blockSize, ia, ib) {\n        let ax = 0;\n        let bx = 0;\n        for (let i = 0; i < blockSize; i++) {\n            ax = data[ia + i];\n            bx = data[ib + i];\n            if (ax > bx)\n                return 1;\n            if (ax < bx)\n                return -1;\n        }\n        return ia - ib; // so original order is maintained among duplicates !!!!\n    }\n    /** Return an array of block indices sorted per compareLexicalBlock function */\n    sortIndicesLexical(compareBlocks = (dataArray, size, iA, iB) => GrowableBlockedArray.compareLexicalBlock(dataArray, size, iA, iB)) {\n        const n = this._inUse;\n        // let numCompare = 0;\n        const result = new Uint32Array(n);\n        const data = this._data;\n        const blockSize = this._blockSize;\n        for (let i = 0; i < n; i++)\n            result[i] = i;\n        result.sort((blockIndexA, blockIndexB) => {\n            // numCompare++;\n            return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);\n        });\n        // console.log (n, numCompare);\n        return result;\n    }\n    /** Return the distance (hypotenuse=sqrt(summed squares)) between indicated blocks */\n    distanceBetweenBlocks(blockIndexA, blockIndexB) {\n        let dd = 0.0;\n        let iA = this.blockIndexToDoubleIndex(blockIndexA);\n        let iB = this.blockIndexToDoubleIndex(blockIndexB);\n        let a = 0;\n        const data = this._data;\n        for (let i = 0; i < this._blockSize; i++) {\n            a = data[iA++] - data[iB++];\n            dd += a * a;\n        }\n        return Math.sqrt(dd);\n    }\n    /** Return the distance (hypotenuse=sqrt(summed squares)) between block entries `iBegin <= i < iEnd` of indicated blocks */\n    distanceBetweenSubBlocks(blockIndexA, blockIndexB, iBegin, iEnd) {\n        let dd = 0.0;\n        const iA = this.blockIndexToDoubleIndex(blockIndexA);\n        const iB = this.blockIndexToDoubleIndex(blockIndexB);\n        let a = 0;\n        const data = this._data;\n        for (let i = iBegin; i < iEnd; i++) {\n            a = data[iA + i] - data[iB + i];\n            dd += a * a;\n        }\n        return Math.sqrt(dd);\n    }\n}\n//# sourceMappingURL=GrowableBlockedArray.js.map",
      "start": 1693508123038,
      "end": 1693508123255,
      "sourcemaps": null
    }
  ]
}
