{
  "resolvedId": "D:/hub2023A/itwinjs-core/common/temp/node_modules/.pnpm/@itwin+reality-data-client@0.9.0_mdtbcqczpmeuv6yjzfaigjndwi/node_modules/@itwin/reality-data-client/lib/esm/RealityData.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { BentleyError } from \"@itwin/core-bentley\";\nimport { getRequestConfig } from \"./RequestOptions\";\nimport axios from \"axios\";\n/**\n * Cache parameters for reality data access. Contains the blob url, the timestamp to refresh (every 50 minutes) the url and the root document path.\n * Cache contains one value for the read permission url, and one of the write permission.\n * */\nclass ContainerCache {\n    getCache(access) {\n        if (access === \"Read\")\n            return this._containerRead;\n        else\n            return this._containerWrite;\n    }\n    setCache(containerCacheValue, access) {\n        if (access === \"Read\")\n            this._containerRead = containerCacheValue;\n        else\n            this._containerWrite = containerCacheValue;\n    }\n}\n/** RealityData\n * This class implements a Reality Data instance.\n * Data is accessed directly through methods of the reality data instance.\n * Access to the data required a properly entitled token though the access to the blob is controlled through\n * an Azure blob URL, the token may be required to obtain this Azure blob URL or refresh it.\n * The Azure blob URL is considered valid for an hour and is refreshed after 50 minutes.\n * In addition to the reality data properties, and Azure blob URL and internal states, a reality data also contains\n * the identification of the iTwin to be used for access permissions and\n * may contain a RealityDataClient to obtain the specialization to communicate with Reality Data API (to obtain the Azure blob URL).\n * @beta\n */\nexport class ITwinRealityData {\n    /**\n     * Creates an instance of RealityData.\n     * @beta\n     */\n    constructor(client, realityData, iTwinId) {\n        this.client = client;\n        this._containerCache = new ContainerCache();\n        if (realityData) {\n            this.id = realityData.id;\n            this.displayName = realityData.displayName;\n            this.dataset = realityData.dataset;\n            this.group = realityData.group;\n            this.dataCenterLocation = realityData.dataCenterLocation;\n            this.description = realityData.description;\n            this.rootDocument = realityData.rootDocument;\n            if (realityData.acquisition) {\n                this.acquisition = realityData.acquisition;\n                this.acquisition.startDateTime = new Date(realityData.acquisition.startDateTime);\n                this.acquisition.endDateTime = realityData.acquisition.endDateTime ? new Date(realityData.acquisition.endDateTime) : undefined;\n                this.acquisition.acquirer = realityData.acquisition.acquirer ? realityData.acquisition.acquirer : undefined;\n            }\n            this.size = realityData.size;\n            this.authoring = realityData.authoring;\n            this.classification = realityData.classification;\n            this.type = realityData.type;\n            this.extent = realityData.extent;\n            this.accessControl = realityData.accessControl;\n            this.modifiedDateTime = new Date(realityData.modifiedDateTime);\n            this.lastAccessedDateTime = new Date(realityData.lastAccessedDateTime);\n            this.createdDateTime = new Date(realityData.createdDateTime);\n        }\n        if (iTwinId)\n            this.iTwinId = iTwinId;\n    }\n    /**\n       * Gets string url to fetch blob data from. Access is read-only.\n       * @param accessToken The client request context.\n       * @param blobPath name or path of tile\n       * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access. The realitydata:modify scope is required to grant the \"write\" access.\n       * @returns string url for blob data\n       * @beta\n       */\n    async getBlobUrl(accessToken, blobPath, writeAccess = false) {\n        const accessTokenResolved = await this.resolveAccessToken(accessToken);\n        const url = await this.getContainerUrl(accessTokenResolved, writeAccess);\n        if (blobPath === undefined)\n            return url;\n        const host = `${url.origin + url.pathname}/`;\n        const query = url.search;\n        return new URL(`${host}${blobPath}${query}`);\n    }\n    /**\n     * Try to use authorizationClient in RealityDataClientOptions to get the access token\n     * otherwise, will return the input token\n     * This is a workaround to support different authorization client for the reality data client and iTwin-core.\n     */\n    async resolveAccessToken(accessToken) {\n        var _a;\n        return ((_a = this.client) === null || _a === void 0 ? void 0 : _a.authorizationClient) ? this.client.authorizationClient.getAccessToken() : accessToken;\n    }\n    /**\n       * Gets a tile access url URL object\n       * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access.\n       * @returns app URL object for blob url\n       * @beta\n       */\n    async getContainerUrl(accessToken, writeAccess = false) {\n        if (!this.client)\n            throw new BentleyError(422, `Invalid container request (RealityDataAccessClient is not set).`);\n        const access = (writeAccess === true ? \"Write\" : \"Read\");\n        const accessTokenResolved = await this.resolveAccessToken(accessToken);\n        try {\n            const containerCache = this._containerCache.getCache(access);\n            const blobUrlRequiresRefresh = !(containerCache === null || containerCache === void 0 ? void 0 : containerCache.timeStamp) || (Date.now() - (containerCache === null || containerCache === void 0 ? void 0 : containerCache.timeStamp.getTime())) > 3000000; // 3 million milliseconds or 50 minutes\n            if (undefined === (containerCache === null || containerCache === void 0 ? void 0 : containerCache.url) || blobUrlRequiresRefresh) {\n                const url = this.iTwinId ? `${this.client.baseUrl}/${this.id}/container/?projectId=${this.iTwinId}&access=${access}`\n                    : `${this.client.baseUrl}/${this.id}/container/?&access=${access}`;\n                const requestOptions = getRequestConfig(accessTokenResolved, \"GET\", url, this.client.apiVersion);\n                const response = await axios.get(url, requestOptions);\n                if (!response.data.container) {\n                    throw new BentleyError(422, `Invalid container request (API returned an unexpected response).`);\n                }\n                // update cache\n                const newContainerCacheValue = {\n                    url: new URL(response.data.container._links.containerUrl.href),\n                    timeStamp: new Date(Date.now()),\n                };\n                this._containerCache.setCache(newContainerCacheValue, access);\n            }\n            return this._containerCache.getCache(access).url;\n        }\n        catch (errorResponse) {\n            throw new BentleyError(422, `Invalid container request.`);\n        }\n    }\n}\n//# sourceMappingURL=RealityData.js.map",
      "start": 1693508122856,
      "end": 1693508122941,
      "sourcemaps": null
    }
  ]
}
