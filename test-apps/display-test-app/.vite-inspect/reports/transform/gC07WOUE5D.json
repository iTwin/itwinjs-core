{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend-devtools/lib/esm/tools/RealityTransitionTool.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { Vector3d } from \"@itwin/core-geometry\";\nimport { RenderSchedule } from \"@itwin/core-common\";\nimport { IModelApp, Tool } from \"@itwin/core-frontend\";\nvar FadeMode;\n(function (FadeMode) {\n    FadeMode[FadeMode[\"X\"] = 0] = \"X\";\n    FadeMode[FadeMode[\"Y\"] = 1] = \"Y\";\n    FadeMode[FadeMode[\"Z\"] = 2] = \"Z\";\n    FadeMode[FadeMode[\"Transparent\"] = 3] = \"Transparent\";\n})(FadeMode || (FadeMode = {}));\n/** This tool applies a transition in X, Y, Z, or transparency.\n * @beta\n */\nclass RealityTransitionTool extends Tool {\n    static get minArgs() { return 0; }\n    static get maxArgs() { return 1; }\n    /** This method runs the tool, applying a transition in X, Y, Z, or transparency.\n     * @param fadeMode whether to apply the transition in X, Y, Z, or transparency\n     */\n    async run(fadeMode = FadeMode.X) {\n        const vp = IModelApp.viewManager.selectedView;\n        if (undefined === vp)\n            return true;\n        const displayStyle = vp.displayStyle;\n        const view = vp.view;\n        const timeNow = Date.now(), timeEnd = timeNow + 1000.0 * 60.0 * 60.0;\n        const range = vp.iModel.projectExtents;\n        const directions = [Vector3d.create(1, 0, 0), Vector3d.create(0, 1, 0), Vector3d.create(0, 0, 1)];\n        const modelInTimeline = { modelId: \"\", elementTimelines: [] };\n        const modelOutTimeline = { modelId: \"\", elementTimelines: [] };\n        switch (fadeMode) {\n            case FadeMode.Transparent: {\n                const fadeInTimeline = new Array();\n                fadeInTimeline.push({ time: timeNow, interpolation: 2, value: 100.0 });\n                fadeInTimeline.push({ time: timeEnd, interpolation: 2, value: 0.0 });\n                const fadeOutTimeline = new Array();\n                fadeOutTimeline.push({ time: timeNow, interpolation: 2, value: 0.0 });\n                fadeOutTimeline.push({ time: timeEnd, interpolation: 2, value: 100.0 });\n                modelInTimeline.visibilityTimeline = fadeInTimeline;\n                modelOutTimeline.visibilityTimeline = fadeOutTimeline;\n                break;\n            }\n            default: {\n                const direction = directions[fadeMode - FadeMode.X];\n                const clipInTimeline = new Array();\n                clipInTimeline.push({ time: timeNow, interpolation: 2, value: { position: [range.low.x, range.low.y, range.low.z], direction: [direction.x, direction.y, direction.z] } });\n                clipInTimeline.push({ time: timeEnd, interpolation: 2, value: { position: [range.high.x, range.high.y, range.high.z], direction: [direction.x, direction.y, direction.z] } });\n                const clipOutTimeline = new Array();\n                clipOutTimeline.push({ time: timeNow, interpolation: 2, value: { position: [range.low.x, range.low.y, range.low.z], direction: [-direction.x, -direction.y, -direction.z] } });\n                clipOutTimeline.push({ time: timeEnd, interpolation: 2, value: { position: [range.high.x, range.high.y, range.high.z], direction: [-direction.x, -direction.y, -direction.z] } });\n                modelInTimeline.cuttingPlaneTimeline = clipInTimeline;\n                modelOutTimeline.cuttingPlaneTimeline = clipOutTimeline;\n                break;\n            }\n        }\n        const scriptProps = [];\n        view.forEachModel((model) => {\n            scriptProps.push({\n                ...(model.jsonProperties.tilesetUrl ? modelOutTimeline : modelInTimeline),\n                modelId: model.id,\n            });\n        });\n        displayStyle.forEachRealityModel((model) => {\n            const modelId = model.treeRef?.treeOwner.tileTree?.modelId;\n            if (modelId) {\n                scriptProps.push({\n                    ...modelOutTimeline,\n                    modelId,\n                    realityModelUrl: model.url,\n                });\n            }\n        });\n        const script = RenderSchedule.Script.fromJSON(scriptProps);\n        if (script) {\n            displayStyle.scheduleScript = script;\n            vp.timePoint = script.duration.low;\n        }\n        return true;\n    }\n    /** Executes this tool's run method.\n     * @param args the first entry of this array contains either \"x\", \"y\", \"z\", or \"transparent\", indicating the type of transition to apply.\n     * @see [[run]]\n     */\n    async parseAndRun(...args) {\n        const transitionNames = [\n            \"x\",\n            \"y\",\n            \"z\",\n            \"transparent\",\n        ];\n        let fade = FadeMode.X;\n        if (0 !== args.length) {\n            const arg = args[0].toLowerCase();\n            for (let i = 0; i < transitionNames.length; i++) {\n                if (arg === transitionNames[i]) {\n                    fade = i;\n                    break;\n                }\n            }\n        }\n        return this.run(fade);\n    }\n}\nRealityTransitionTool.toolId = \"RealityTransition\";\nexport { RealityTransitionTool };\n//# sourceMappingURL=RealityTransitionTool.js.map",
      "start": 1693508122705,
      "end": 1693508122804,
      "sourcemaps": null
    }
  ]
}
