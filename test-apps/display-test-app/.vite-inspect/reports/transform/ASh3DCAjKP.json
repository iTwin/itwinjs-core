{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/DisplayStyleState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Views\n */\nimport { assert, BeEvent, Id64 } from \"@itwin/core-bentley\";\nimport { Range1d } from \"@itwin/core-geometry\";\nimport { BackgroundMapProvider, BaseMapLayerSettings, ColorDef, DisplayStyle3dSettings, DisplayStyleSettings, GlobeMode, ImageMapLayerSettings, MapLayerSettings, RenderSchedule, SubCategoryOverride, TerrainHeightOriginMode, ThematicDisplay, ThematicDisplayMode, ThematicGradientMode, } from \"@itwin/core-common\";\nimport { ApproximateTerrainHeights } from \"./ApproximateTerrainHeights\";\nimport { BackgroundMapGeometry } from \"./BackgroundMapGeometry\";\nimport { ContextRealityModelState } from \"./ContextRealityModelState\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelApp } from \"./IModelApp\";\nimport { PlanarClipMaskState } from \"./PlanarClipMaskState\";\nimport { getCesiumOSMBuildingsUrl } from \"./tile/internal\";\n/** @internal */\nexport class TerrainDisplayOverrides {\n}\n/** A DisplayStyle defines the parameters for 'styling' the contents of a [[ViewState]].\n * @public\n * @extensions\n */\nexport class DisplayStyleState extends ElementState {\n    static get className() { return \"DisplayStyle\"; }\n    /** Construct a new DisplayStyleState from its JSON representation.\n     * @param props JSON representation of the display style.\n     * @param iModel IModelConnection containing the display style.\n     * @param source If the constructor is being invoked from [[EntityState.clone]], the display style that is being cloned.\n     */\n    constructor(props, iModel, source) {\n        super(props, iModel);\n        this._attachedRealityModelPlanarClipMasks = new Map();\n        this._assigningScript = false;\n        /** Event raised just before the [[scheduleScriptReference]] property is changed.\n         * @deprecated in 3.x. use [[onScheduleScriptChanged]].\n         */\n        this.onScheduleScriptReferenceChanged = new BeEvent();\n        /** Event raised just before the [[scheduleScript]] property is changed. */\n        this.onScheduleScriptChanged = new BeEvent();\n        /** Event raised just after [[setOSMBuildingDisplay]] changes the enabled state of the OSM buildings. */\n        this.onOSMBuildingDisplayChanged = new BeEvent();\n        const styles = this.jsonProperties.styles;\n        if (source)\n            this._scriptReference = source._scriptReference;\n        if (styles) {\n            // ###TODO Use DisplayStyleSettings.planarClipMasks\n            if (styles.planarClipOvr)\n                for (const planarClipOvr of styles.planarClipOvr)\n                    if (Id64.isValid(planarClipOvr.modelId))\n                        this._attachedRealityModelPlanarClipMasks.set(planarClipOvr.modelId, PlanarClipMaskState.fromJSON(planarClipOvr));\n        }\n    }\n    /** Ensures all of the data required by the display style is loaded. This method is invoked for you by [[ViewState.load]], but if\n     * you obtain a display style by some other means you should `await` this method before using the display style.\n     */\n    async load() {\n        // If we were cloned, we may already have a valid schedule state, and our display style Id may be invalid / different.\n        // Preserve it if still usable.\n        if (this._scriptReference) {\n            if (this.settings.renderTimeline === this._scriptReference.sourceId) {\n                // The script came from the same RenderTimeline element. Keep it.\n                return;\n            }\n            if (undefined === this.settings.renderTimeline) {\n                // The script came from a display style's JSON properties. Keep it if (1) this style is not persistent or (2) this style has the same Id\n                if (this.id === this._scriptReference.sourceId || !Id64.isValidId64(this.id))\n                    return;\n            }\n        }\n        // The schedule script stored in JSON properties takes precedence over the RenderTimeline if both are defined.\n        if (this.settings.scheduleScriptProps)\n            this.loadScriptReferenceFromScript(this.settings.scheduleScriptProps);\n        else\n            await this.loadScriptReferenceFromTimeline(this.settings.renderTimeline);\n    }\n    loadScriptReferenceFromScript(scriptProps) {\n        let newState;\n        try {\n            const script = RenderSchedule.Script.fromJSON(scriptProps);\n            if (script)\n                newState = new RenderSchedule.ScriptReference(this.id, script);\n        }\n        catch (_) {\n            // schedule state is undefined.\n        }\n        if (newState !== this._scriptReference) {\n            this.onScheduleScriptReferenceChanged.raiseEvent(newState); // eslint-disable-line deprecation/deprecation\n            this.onScheduleScriptChanged.raiseEvent(newState?.script);\n            this._scriptReference = newState;\n        }\n    }\n    async loadScriptReferenceFromTimeline(timelineId) {\n        let newState;\n        if (timelineId && Id64.isValidId64(timelineId)) {\n            try {\n                // If a subsequent call to loadScriptReferenceFromTimeline is made while we're awaiting this one, we'll abort this one.\n                const promise = this._queryRenderTimelinePropsPromise = this.queryRenderTimelineProps(timelineId);\n                const timeline = await promise;\n                if (promise !== this._queryRenderTimelinePropsPromise)\n                    return;\n                if (timeline) {\n                    const scriptProps = JSON.parse(timeline.script);\n                    const script = RenderSchedule.Script.fromJSON(scriptProps);\n                    if (script)\n                        newState = new RenderSchedule.ScriptReference(timelineId, script);\n                }\n            }\n            catch (_) {\n                // schedule state is undefined.\n            }\n        }\n        this._queryRenderTimelinePropsPromise = undefined;\n        if (newState !== this._scriptReference) {\n            this.onScheduleScriptReferenceChanged.raiseEvent(newState); // eslint-disable-line deprecation/deprecation\n            this.onScheduleScriptChanged.raiseEvent(newState?.script);\n            this._scriptReference = newState;\n        }\n    }\n    /** @internal */\n    async queryRenderTimelineProps(timelineId) {\n        try {\n            const omitScriptElementIds = !IModelApp.tileAdmin.enableFrontendScheduleScripts;\n            return await this.iModel.elements.loadProps(timelineId, { renderTimeline: { omitScriptElementIds } });\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    /** @internal */\n    get displayTerrain() {\n        return this.viewFlags.backgroundMap && this.settings.backgroundMap.applyTerrain;\n    }\n    /** @internal */\n    get globeMode() { return this.settings.backgroundMap.globeMode; }\n    /** Settings controlling how the base map is displayed within a view.\n     *  The base map can be provided by any map imagery source or set to be a single color.\n     */\n    get backgroundMapBase() {\n        return this.settings.mapImagery.backgroundBase;\n    }\n    set backgroundMapBase(base) {\n        this.settings.mapImagery.backgroundBase = base;\n        this._synchBackgroundMapImagery();\n    }\n    /** The settings controlling how a background map is displayed within a view.\n     * @see [[ViewFlags.backgroundMap]] for toggling display of the map on or off.\n     */\n    get backgroundMapSettings() { return this.settings.backgroundMap; }\n    set backgroundMapSettings(settings) {\n        this.settings.backgroundMap = settings;\n    }\n    /** Modify a subset of the background map display settings.\n     * @param name props JSON representation of the properties to change. Any properties not present will retain their current values in `this.backgroundMapSettings`.\n     * @see [[ViewFlags.backgroundMap]] for toggling display of the map.\n     * @see [[changeBackgroundMapProvider]] to change the type of map imagery displayed.\n     *\n     * Example that changes only the elevation, leaving the provider and type unchanged:\n     * ``` ts\n     *  style.changeBackgroundMapProps({ groundBias: 16.2 });\n     * ```\n     * @public\n     */\n    changeBackgroundMapProps(props) {\n        const newSettings = this.backgroundMapSettings.clone(props);\n        this.backgroundMapSettings = newSettings;\n    }\n    /** Change aspects of the [BackgroundMapProvider]($common) from which background map imagery is obtained.\n     * Any properties not explicitly specified by `props` will retain their current values.\n     * @public\n     */\n    changeBackgroundMapProvider(props) {\n        const base = this.settings.mapImagery.backgroundBase;\n        if (base instanceof ColorDef) {\n            this.settings.mapImagery.backgroundBase = BaseMapLayerSettings.fromProvider(BackgroundMapProvider.fromJSON(props));\n        }\n        else {\n            const provider = base.provider ? base.provider.clone(props) : BackgroundMapProvider.fromJSON(props);\n            this.settings.mapImagery.backgroundBase = base.cloneWithProvider(provider);\n        }\n        this._synchBackgroundMapImagery();\n    }\n    /** Call a function for each reality model attached to this display style.\n     * @see [DisplayStyleSettings.contextRealityModels]($common).\n     */\n    forEachRealityModel(func) {\n        for (const model of this.settings.contextRealityModels.models) {\n            assert(model instanceof ContextRealityModelState);\n            func(model);\n        }\n    }\n    /** @internal */\n    forEachRealityTileTreeRef(func) {\n        this.forEachRealityModel((model) => func(model.treeRef));\n    }\n    /** @internal */\n    forEachTileTreeRef(func) {\n        this.forEachRealityTileTreeRef(func);\n    }\n    /** Performs logical comparison against another display style. Two display styles are logically equivalent if they have the same name, Id, and settings.\n     * @param other The display style to which to compare.\n     * @returns true if the specified display style is logically equivalent to this display style - i.e., both styles have the same values for all of their settings.\n     */\n    equalState(other) {\n        if (this.name !== other.name || this.id !== other.id)\n            return false;\n        else\n            return JSON.stringify(this.settings) === JSON.stringify(other.settings);\n    }\n    /** The name of this DisplayStyle */\n    get name() { return this.code.value; }\n    /** Change the Id of the [RenderTimeline]($backend) element that hosts the [RenderSchedule.Script]($common) to be applied by this display style for\n     * animating the contents of the view, and update [[scheduleScript]] using the script associated with the [RenderTimeline]($backend) element.\n     * @see [DisplayStyleSettings.renderTimeline]($common).\n     */\n    async changeRenderTimeline(timelineId) {\n        // Potentially trigger async loading of new schedule state.\n        this.settings.renderTimeline = timelineId;\n        // Await async loading if necessary.\n        // Note the `await` in loadScriptReferenceFromTimeline will resolve before this one [per the spec](https://262.ecma-international.org/6.0/#sec-triggerpromisereactions).\n        if (this._queryRenderTimelinePropsPromise)\n            await this._queryRenderTimelinePropsPromise;\n    }\n    /** The [RenderSchedule.Script]($common) that animates the contents of the view, if any.\n     * @see [[changeRenderTimeline]] to change the script.\n     */\n    get scheduleScript() {\n        return this._scriptReference?.script;\n    }\n    set scheduleScript(script) {\n        if (script === this.scheduleScript)\n            return;\n        try {\n            const scriptRef = script ? new RenderSchedule.ScriptReference(script) : undefined;\n            this.onScheduleScriptReferenceChanged.raiseEvent(scriptRef); // eslint-disable-line deprecation/deprecation\n            this.onScheduleScriptChanged.raiseEvent(script);\n            this._scriptReference = scriptRef;\n            this._assigningScript = true;\n            this.settings.scheduleScriptProps = script?.toJSON();\n            if (!script)\n                this.loadScriptReferenceFromTimeline(this.settings.renderTimeline); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n        finally {\n            this._assigningScript = false;\n        }\n    }\n    /** The [RenderSchedule.Script]($common) that animates the contents of the view, if any, along with the Id of the element that hosts the script.\n     * @note The host element may be a [RenderTimeline]($backend) or a [DisplayStyle]($backend).\n     * @deprecated in 3.x. Use [[scheduleScript]].\n     */\n    get scheduleScriptReference() {\n        return this._scriptReference;\n    }\n    /** Attach a [ContextRealityModel]($common) to this display style.\n     * @see [DisplayStyleSettings.contextRealityModels]($common).\n     * @see [ContextRealityModels.add]($common)\n     */\n    attachRealityModel(props) {\n        const model = this.settings.contextRealityModels.add(props);\n        assert(model instanceof ContextRealityModelState);\n        return model;\n    }\n    /** Detach the first [ContextRealityModel]($common) that matches the specified name and url.\n     * @see [DisplayStyleSettings.contextRealityModels]($common)\n     * @see [ContextRealityModels.delete]($common)\n     */\n    detachRealityModelByNameAndUrl(name, url) {\n        const model = this.settings.contextRealityModels.models.find((x) => x.matchesNameAndUrl(name, url));\n        return undefined !== model && this.settings.contextRealityModels.delete(model);\n    }\n    /** Get the [[ContextRealityModelState]] that displays the OpenStreetMap worldwide building layer, if enabled.\n     * @see [[setOSMBuildingDisplay]]\n     */\n    getOSMBuildingRealityModel() {\n        if (!this.iModel.isGeoLocated || this.globeMode !== GlobeMode.Ellipsoid) // The OSM tile tree is ellipsoidal.\n            return undefined;\n        const url = getCesiumOSMBuildingsUrl();\n        if (undefined === url)\n            return undefined;\n        return this.contextRealityModelStates.find((x) => x.url === url);\n    }\n    /** Set the display of the OpenStreetMap worldwide building layer in this display style by attaching or detaching the reality model displaying the buildings.\n     * The OSM buildings are displayed from a reality model aggregated and served from Cesium ion.<(https://cesium.com/content/cesium-osm-buildings/>\n     * The options [[OsmBuildingDisplayOptions]] control the display and appearance overrides.\n     */\n    setOSMBuildingDisplay(options) {\n        if (!this.iModel.isGeoLocated || this.globeMode !== GlobeMode.Ellipsoid) // The OSM tile tree is ellipsoidal.\n            return false;\n        const url = getCesiumOSMBuildingsUrl();\n        if (undefined === url)\n            return false;\n        let model = this.settings.contextRealityModels.models.find((x) => x.url === url);\n        if (options.onOff === false) {\n            const turnedOff = undefined !== model && this.settings.contextRealityModels.delete(model);\n            if (turnedOff)\n                this.onOSMBuildingDisplayChanged.raiseEvent(false);\n            return turnedOff;\n        }\n        if (!model) {\n            const name = IModelApp.localization.getLocalizedString(\"iModelJs:RealityModelNames.OSMBuildings\");\n            model = this.attachRealityModel({ tilesetUrl: url, name });\n            this.onOSMBuildingDisplayChanged.raiseEvent(true);\n        }\n        if (options.appearanceOverrides)\n            model.appearanceOverrides = options.appearanceOverrides;\n        return true;\n    }\n    /** Return if a context reality model is attached.\n     * @see [[ContextRealityModelProps]].\n     */\n    hasAttachedRealityModel(name, url) {\n        return undefined !== this.settings.contextRealityModels.models.find((x) => x.matchesNameAndUrl(name, url));\n    }\n    /** @internal */\n    getMapLayers(isOverlay) { return isOverlay ? this.settings.mapImagery.overlayLayers : this.settings.mapImagery.backgroundLayers; }\n    /** Attach a map layer to display style.\n     * @param Settings representing the map layer.\n     * @param mapLayerIndex the [[MapLayerIndex]] where the map layer should be attached.\n     * @public\n     */\n    attachMapLayer(options) {\n        const layerSettings = options.settings.clone({});\n        if (undefined === layerSettings)\n            return;\n        const isOverlay = options.mapLayerIndex.isOverlay;\n        const insertIndex = options.mapLayerIndex.index;\n        const layers = this.getMapLayers(isOverlay);\n        if (insertIndex < 0 || insertIndex > (layers.length - 1)) {\n            this.getMapLayers(isOverlay).push(layerSettings);\n        }\n        else {\n            layers.splice(insertIndex, 0, layerSettings);\n        }\n        this._synchBackgroundMapImagery();\n    }\n    /**\n     * @param mapLayerIndex the [[MapLayerIndex]] where the map layer should be attached.\n     * @internal\n     */\n    attachMapLayerProps(options) {\n        const settings = MapLayerSettings.fromJSON(options.props);\n        if (undefined === settings)\n            return;\n        this.attachMapLayer({ settings, mapLayerIndex: options.mapLayerIndex });\n    }\n    /** @internal */\n    hasAttachedMapLayer(name, source, isOverlay) {\n        return -1 !== this.findMapLayerIndexByNameAndSource(name, source, isOverlay);\n    }\n    /** @internal */\n    detachMapLayerByNameAndSource(name, source, isOverlay) {\n        const index = this.findMapLayerIndexByNameAndSource(name, source, isOverlay);\n        if (-1 !== index)\n            this.detachMapLayerByIndex({ index, isOverlay });\n    }\n    /** Detach map layer at index (-1 to remove all layers)\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer to detach.\n     * @public\n     */\n    detachMapLayerByIndex(mapLayerIndex) {\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        const index = mapLayerIndex.index;\n        if (index < 0)\n            layers.length = 0;\n        else\n            layers.splice(index, 1);\n        this._synchBackgroundMapImagery();\n    }\n    /**\n     * Lookup a maplayer index by name and source.\n     * @param name Name of of the layer.\n     * @param source Unique string identifying the layer.\n     * @param isOverlay true if layer is overlay, otherwise layer is background. Defaults to false.\n     * @public\n     *\n     */\n    findMapLayerIndexByNameAndSource(name, source, isOverlay) {\n        return this.getMapLayers(isOverlay).findIndex((layer) => layer.matchesNameAndSource(name, source));\n    }\n    /** Return the map layer settings for a map layer at the provided index.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer.\n     * @public\n     */\n    mapLayerAtIndex(mapLayerIndex) {\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        const index = mapLayerIndex.index;\n        return (index < 0 || index >= layers.length) ? undefined : layers[index];\n    }\n    /** Return map base transparency as a number between 0 and 1.\n     * @public\n     */\n    get baseMapTransparency() {\n        return this.settings.mapImagery.baseTransparency;\n    }\n    /** Change the map base transparency as a number between 0 and 1.\n     * @public\n     */\n    changeBaseMapTransparency(transparency) {\n        if (this.settings.mapImagery.backgroundBase instanceof ColorDef) {\n            this.settings.mapImagery.backgroundBase = this.settings.mapImagery.backgroundBase.withTransparency(transparency * 255);\n        }\n        else {\n            this.settings.mapImagery.backgroundBase = this.settings.mapImagery.backgroundBase.clone({ transparency });\n        }\n        this._synchBackgroundMapImagery();\n    }\n    /** Modify a subset of a map layer settings.\n     * @param props props JSON representation of the properties to change. Any properties not present will retain their current values.\n     * @param mapLayerIndex the [[MapLayerIndex]] where the map layer should be inserted.\n     *\n     * Example that changes only the visibility of the first overlay map layer.\n     * ``` ts\n     *  style.changeMapLayerProps({ visible: false }, 0, false);\n     * ```\n     * @public\n     */\n    changeMapLayerProps(props, mapLayerIndex) {\n        const index = mapLayerIndex.index;\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        if (index < 0 || index >= layers.length)\n            return;\n        layers[index] = layers[index].clone(props);\n        this._synchBackgroundMapImagery();\n    }\n    /** Change the credentials for a map layer.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer to change the credentials of.\n     * @public\n     */\n    changeMapLayerCredentials(mapLayerIndex, userName, password) {\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        const index = mapLayerIndex.index;\n        if (index < 0 || index >= layers.length)\n            return;\n        const layer = layers[index];\n        if (layer instanceof ImageMapLayerSettings) {\n            layer.setCredentials(userName, password);\n            this._synchBackgroundMapImagery();\n        }\n    }\n    /** Modify a subset of a sub-layer settings.\n     * @param props props JSON representation of the properties to change. Any properties not present will retain their current values.\n     * @param subLayerId Id of the sub-layer that should be modified.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer that contains the sub-layer to be modified.\n     *\n     * @public\n     */\n    changeMapSubLayerProps(props, subLayerId, mapLayerIndex) {\n        const mapLayerSettings = this.mapLayerAtIndex(mapLayerIndex);\n        if (undefined === mapLayerSettings)\n            return;\n        if (!(mapLayerSettings instanceof ImageMapLayerSettings)) {\n            assert(false);\n            return;\n        }\n        const subLayers = new Array();\n        for (const subLayer of mapLayerSettings.subLayers) {\n            subLayers.push((subLayerId === -1 || subLayer.id === subLayerId) ? subLayer.clone(props).toJSON() : subLayer.toJSON());\n        }\n        this.changeMapLayerProps({ subLayers }, mapLayerIndex);\n    }\n    /* @internal */\n    _synchBackgroundMapImagery() {\n        this.settings.synchMapImagery();\n    }\n    /** Move map layer to top.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer to move.\n     * @public\n     *\n     */\n    moveMapLayerToTop(mapLayerIndex) {\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        const index = mapLayerIndex.index;\n        if (index >= 0 && index < layers.length - 1) {\n            const layer = layers.splice(index, 1);\n            layers.push(layer[0]);\n            this._synchBackgroundMapImagery();\n        }\n    }\n    /** Move map layer to bottom.\n     * @param mapLayerIndex the [[MapLayerIndex]] of the map layer to move.\n     * @public\n     */\n    moveMapLayerToBottom(mapLayerIndex) {\n        const layers = this.getMapLayers(mapLayerIndex.isOverlay);\n        const index = mapLayerIndex.index;\n        if (index > 0 && index < layers.length) {\n            const layer = layers.splice(index, 1);\n            layers.unshift(layer[0]);\n            this._synchBackgroundMapImagery();\n        }\n    }\n    /** Reorder map layers\n     * @param fromIndex index of map layer to move\n     * @param toIndex insert index. If equal to length of map array the map layer is moved to end of array.\n     * @param isOverlay true if map-layer is part of the overlay map, otherwise it is part of the background map.\n     * @public\n     */\n    moveMapLayerToIndex(fromIndex, toIndex, isOverlay) {\n        const layers = this.getMapLayers(isOverlay);\n        if (fromIndex === toIndex)\n            return;\n        if (fromIndex < 0 || fromIndex >= layers.length || toIndex > layers.length)\n            return;\n        const layer = layers.splice(fromIndex, 1);\n        layers.splice(toIndex, 0, layer[0]); // note: if toIndex === settings.mapImagery.backgroundLayers.length item is appended\n        this._synchBackgroundMapImagery();\n    }\n    /** Flags controlling various aspects of the display style.\n     * @see [DisplayStyleSettings.viewFlags]($common)\n     */\n    get viewFlags() { return this.settings.viewFlags; }\n    set viewFlags(flags) { this.settings.viewFlags = flags; }\n    /** The background color for this DisplayStyle */\n    get backgroundColor() { return this.settings.backgroundColor; }\n    set backgroundColor(val) { this.settings.backgroundColor = val; }\n    /** The color used to draw geometry in monochrome mode.\n     * @see [ViewFlags.monochrome]($common) for enabling monochrome mode.\n     */\n    get monochromeColor() { return this.settings.monochromeColor; }\n    set monochromeColor(val) { this.settings.monochromeColor = val; }\n    /** @internal */\n    anyMapLayersVisible(overlay) {\n        const layers = this.getMapLayers(overlay);\n        for (const mapLayer of layers)\n            if (mapLayer.visible)\n                return true;\n        return false;\n    }\n    /** @internal */\n    getIsBackgroundMapVisible() {\n        return undefined !== this.iModel.ecefLocation && (this.viewFlags.backgroundMap || this.anyMapLayersVisible(false));\n    }\n    /** @internal */\n    get backgroundMapElevationBias() {\n        if (this.backgroundMapSettings.applyTerrain) {\n            const terrainSettings = this.backgroundMapSettings.terrainSettings;\n            switch (terrainSettings.heightOriginMode) {\n                case TerrainHeightOriginMode.Ground:\n                    return (undefined === this.iModel.projectCenterAltitude) ? undefined : terrainSettings.heightOrigin + terrainSettings.exaggeration * this.iModel.projectCenterAltitude;\n                case TerrainHeightOriginMode.Geodetic:\n                    return terrainSettings.heightOrigin;\n                case TerrainHeightOriginMode.Geoid:\n                    return (undefined === this.iModel.geodeticToSeaLevel) ? undefined : terrainSettings.heightOrigin + this.iModel.geodeticToSeaLevel;\n            }\n        }\n        else {\n            return this.backgroundMapSettings.groundBias;\n        }\n    }\n    /** @internal */\n    getBackgroundMapGeometry() {\n        if (undefined === this.iModel.ecefLocation)\n            return undefined;\n        const bimElevationBias = this.backgroundMapElevationBias;\n        if (undefined === bimElevationBias)\n            return undefined;\n        const globeMode = this.globeMode;\n        if (undefined === this._backgroundMapGeometry || this._backgroundMapGeometry.globeMode !== globeMode || this._backgroundMapGeometry.bimElevationBias !== bimElevationBias) {\n            const geometry = new BackgroundMapGeometry(bimElevationBias, globeMode, this.iModel);\n            this._backgroundMapGeometry = { bimElevationBias, geometry, globeMode };\n        }\n        return this._backgroundMapGeometry.geometry;\n    }\n    /** [[ContextRealityModelState]]s attached to this display style.\n     * @see [DisplayStyleSettings.contextRealityModels]($common).\n     */\n    get contextRealityModelStates() {\n        return this.settings.contextRealityModels.models;\n    }\n    /** @internal */\n    getGlobalGeometryAndHeightRange() {\n        let geometry = this.getIsBackgroundMapVisible() ? this.getBackgroundMapGeometry() : undefined;\n        const terrainRange = ApproximateTerrainHeights.instance.globalHeightRange;\n        let heightRange = this.displayTerrain ? terrainRange : Range1d.createXX(-1, 1);\n        if (this.globeMode === GlobeMode.Ellipsoid && this.contextRealityModelStates.find((model) => model.isGlobal)) {\n            if (!geometry) {\n                if (!this._ellipsoidMapGeometry)\n                    this._ellipsoidMapGeometry = new BackgroundMapGeometry(0, GlobeMode.Ellipsoid, this.iModel);\n                geometry = this._ellipsoidMapGeometry;\n            }\n            heightRange = terrainRange;\n        }\n        return geometry ? { geometry, heightRange } : undefined;\n    }\n    /** Returns true if this is a 3d display style. */\n    is3d() { return this instanceof DisplayStyle3dState; }\n    /** Customize the way geometry belonging to a [[SubCategory]] is drawn by this display style.\n     * @param id The ID of the SubCategory whose appearance is to be overridden.\n     * @param ovr The overrides to apply to the [[SubCategoryAppearance]].\n     * @see [[dropSubCategoryOverride]]\n     */\n    overrideSubCategory(id, ovr) { this.settings.overrideSubCategory(id, ovr); }\n    /** Remove any [[SubCategoryOverride]] applied to a [[SubCategoryAppearance]] by this style.\n     * @param id The ID of the [[SubCategory]].\n     * @see [[overrideSubCategory]]\n     */\n    dropSubCategoryOverride(id) { this.settings.dropSubCategoryOverride(id); }\n    /** Returns true if an [[SubCategoryOverride]]s are defined by this style. */\n    get hasSubCategoryOverride() { return this.settings.hasSubCategoryOverride; }\n    /** Obtain the overrides applied to a [[SubCategoryAppearance]] by this style.\n     * @param id The ID of the [[SubCategory]].\n     * @returns The corresponding SubCategoryOverride, or undefined if the SubCategory's appearance is not overridden.\n     * @see [[overrideSubCategory]]\n     */\n    getSubCategoryOverride(id) { return this.settings.getSubCategoryOverride(id); }\n    /** For each subcategory belonging to any of the specified categories, make it visible by turning off the \"invisible\" flag in its subcategory appearance.\n     * This requires that the categories and subcategories have been previously loaded by, e.g., a call to IModelConnection.querySubCategories.\n     * @returns true if the visibility of any subcategory was modified.\n     * @see Viewport.changeCategoryDisplay\n     * @see ViewCreator3dOptions.allSubCategoriesVisible\n     * @internal\n     */\n    enableAllLoadedSubCategories(categoryIds) {\n        let anyChanged = false;\n        for (const categoryId of Id64.iterable(categoryIds)) {\n            const subCategoryIds = this.iModel.subcategories.getSubCategories(categoryId);\n            if (undefined !== subCategoryIds)\n                for (const subCategoryId of subCategoryIds)\n                    if (this.setSubCategoryVisible(subCategoryId, true))\n                        anyChanged = true;\n        }\n        return anyChanged;\n    }\n    /** Change the \"invisible\" flag for the given subcategory's appearance.\n     * This requires that the subcategory appearance has been previously loaded by, e.g., a call to IModelConnection.Categories.getSubCategoryInfo.\n     * @returns true if the visibility of any subcategory was modified.\n     * @see [[enableAllLoadedSubCategories]]\n     * @internal\n     */\n    setSubCategoryVisible(subCategoryId, visible) {\n        const app = this.iModel.subcategories.getSubCategoryAppearance(subCategoryId);\n        if (undefined === app)\n            return false; // category not enabled or subcategory not found\n        const curOvr = this.getSubCategoryOverride(subCategoryId);\n        const isAlreadyVisible = undefined !== curOvr && undefined !== curOvr.invisible ? !curOvr.invisible : !app.invisible;\n        if (isAlreadyVisible === visible)\n            return false;\n        // Preserve existing overrides - just flip the visibility flag.\n        const json = undefined !== curOvr ? curOvr.toJSON() : {};\n        json.invisible = !visible;\n        this.overrideSubCategory(subCategoryId, SubCategoryOverride.fromJSON(json));\n        return true;\n    }\n    /** Returns true if solar shadow display is enabled by this display style. */\n    get wantShadows() {\n        return this.is3d() && this.viewFlags.shadows && false !== IModelApp.renderSystem.options.displaySolarShadows;\n    }\n    /** @internal */\n    registerSettingsEventListeners() {\n        this.settings.onScheduleScriptPropsChanged.addListener((scriptProps) => {\n            if (this._assigningScript)\n                return;\n            try {\n                this._assigningScript = true;\n                if (scriptProps)\n                    this.loadScriptReferenceFromScript(scriptProps);\n                else\n                    this.loadScriptReferenceFromTimeline(this.settings.renderTimeline); // eslint-disable-line @typescript-eslint/no-floating-promises\n            }\n            finally {\n                this._assigningScript = false;\n            }\n        });\n        this.settings.onRenderTimelineChanged.addListener((newTimeline) => {\n            // Cancel any in-progress loading of script from timeline.\n            this._queryRenderTimelinePropsPromise = undefined;\n            if (!this.settings.scheduleScriptProps)\n                this.loadScriptReferenceFromTimeline(newTimeline); // eslint-disable-line @typescript-eslint/no-floating-promises\n        });\n        this.settings.onPlanarClipMaskChanged.addListener((id, newSettings) => {\n            if (newSettings)\n                this._attachedRealityModelPlanarClipMasks.set(id, PlanarClipMaskState.create(newSettings));\n            else\n                this._attachedRealityModelPlanarClipMasks.delete(id);\n        });\n    }\n    /** @internal */\n    createRealityModel(props) {\n        return new ContextRealityModelState(props, this.iModel, this);\n    }\n    /** @internal */\n    getPlanarClipMaskState(modelId) {\n        const model = this.iModel.models.getLoaded(modelId)?.asSpatialModel;\n        return (model && model.isRealityModel) ? this._attachedRealityModelPlanarClipMasks.get(modelId) : undefined;\n    }\n}\n/** A display style that can be applied to 2d views.\n * @public\n * @extensions\n */\nexport class DisplayStyle2dState extends DisplayStyleState {\n    static get className() { return \"DisplayStyle2d\"; }\n    get settings() { return this._settings; }\n    /** @internal */\n    overrideTerrainDisplay() { return undefined; }\n    constructor(props, iModel) {\n        super(props, iModel);\n        this._settings = new DisplayStyleSettings(this.jsonProperties, {\n            createContextRealityModel: (modelProps) => this.createRealityModel(modelProps),\n            deferContextRealityModels: true,\n        });\n        this._settings.contextRealityModels.populate();\n        this.registerSettingsEventListeners();\n    }\n}\n/** A [[DisplayStyleState]] that can be applied to spatial views.\n * @public\n * @extensions\n */\nexport class DisplayStyle3dState extends DisplayStyleState {\n    static get className() { return \"DisplayStyle3d\"; }\n    get settings() { return this._settings; }\n    constructor(props, iModel, source) {\n        super(props, iModel, source);\n        this._settings = new DisplayStyle3dSettings(this.jsonProperties, {\n            createContextRealityModel: (modelProps) => this.createRealityModel(modelProps),\n            deferContextRealityModels: true,\n        });\n        this._settings.contextRealityModels.populate();\n        this.registerSettingsEventListeners();\n    }\n    get environment() {\n        return this.settings.environment;\n    }\n    set environment(env) {\n        this.settings.environment = env;\n    }\n    get lights() { return this.settings.lights; }\n    set lights(lights) { this.settings.lights = lights; }\n    /** The direction of the solar light. */\n    get sunDirection() {\n        return this.settings.lights.solar.direction;\n    }\n    /** Set the solar light direction based on time value\n     * @param time The time in unix time milliseconds.\n     * @see [DisplayStyle3dSettings.sunTime]($common) to obtain the current sun time.\n     * @see [DisplayStyle3dSettings.setSunTime]($common).\n     */\n    setSunTime(time) {\n        this.settings.setSunTime(time, this.iModel);\n    }\n    /** Settings controlling shadow display. */\n    get solarShadows() {\n        return this.settings.solarShadows;\n    }\n    set solarShadows(settings) {\n        this.settings.solarShadows = settings;\n    }\n    /** @internal */\n    registerSettingsEventListeners() {\n        super.registerSettingsEventListeners();\n        this.settings.onOverridesApplied.addListener((overrides) => {\n            if (overrides.thematic && this.settings.thematic.displayMode === ThematicDisplayMode.Height && undefined === overrides.thematic.range) {\n                // Use the project extents as reasonable default height range.\n                // NB: assumes using Z axis...\n                const extents = this.iModel.projectExtents;\n                const props = { ...overrides.thematic };\n                props.range = { low: extents.zLow, high: extents.zHigh };\n                this.settings.thematic = ThematicDisplay.fromJSON(props);\n            }\n        });\n    }\n    /** @internal */\n    overrideTerrainDisplay() {\n        if (undefined !== this.settings.thematic) {\n            const ovr = new TerrainDisplayOverrides();\n            if (this.viewFlags.thematicDisplay && ThematicGradientMode.IsoLines === this.settings.thematic.gradientSettings.mode)\n                ovr.wantSkirts = false;\n            if (this.viewFlags.thematicDisplay && (ThematicDisplayMode.Slope === this.settings.thematic.displayMode || ThematicDisplayMode.HillShade === this.settings.thematic.displayMode))\n                ovr.wantNormals = true;\n            return ovr;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=DisplayStyleState.js.map",
      "start": 1693508119244,
      "end": 1693508119343,
      "sourcemaps": null
    }
  ]
}
