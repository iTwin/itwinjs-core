{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/render/GraphicBuilder.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert } from \"@itwin/core-bentley\";\nimport { Box, Path, Transform, } from \"@itwin/core-geometry\";\nimport { Feature, Frustum, GraphicParams, LinePixels, Npc } from \"@itwin/core-common\";\n/**\n * Describes the type of a [[GraphicBuilder]], which defines the coordinate system in which the builder's geometry is defined and\n * controls the behavior of the [[RenderGraphic]] produced by the builder.\n * @note For those types for which depth-testing is disabled, the order in which the individual geometric primitives are drawn determines which geometry draws on top of other geometry.\n *  - Within a [[GraphicList]], each [[RenderGraphic]] is rendered in the order in which it appears in the list; and\n *  - Within a single [[RenderGraphic]], each geometric primitive is rendered in the ordered in which it was added to the GraphicBuilder.\n * @public\n * @extensions\n */\nexport var GraphicType;\n(function (GraphicType) {\n    /**\n     * Renders behind all other graphics. For example, the border of a [[SheetViewState]] is of this type.\n     * Coordinates: [[CoordSystem.View]].\n     * [[RenderMode]]: [[RenderMode.SmoothShade]].\n     * Lighting: none.\n     * Depth-testing: disabled.\n     * @see [[Decorations.viewBackground]]\n     */\n    GraphicType[GraphicType[\"ViewBackground\"] = 0] = \"ViewBackground\";\n    /** Used for the scene itself, dynamics, and 'normal' decorations. */\n    /**\n     * Renders as if it were part of the scene. All of the [[ViewFlags]] applied to the view's normal geometry also applies to these types of decorations.\n     * Coordinates: [[CoordSystem.World]].\n     * Lighting and [[RenderMode]]: from view.\n     * Depth-testing: enabled.\n     * @see [[Decorations.normal]].\n     */\n    GraphicType[GraphicType[\"Scene\"] = 1] = \"Scene\";\n    /** Renders within the scene. Coordinates: world. RenderMode: smooth. Lighting: default. Z-testing: enabled */\n    /** Renders within the scene, but ignores the view's [[ViewFlags]].\n     * Coordinates: [[CoordSystem.World]].\n     * Lighting: default.\n     * [[RenderMode]]: [[RenderMode.SmoothShade]].\n     * Depth-testing: enabled.\n     * @see [[Decorations.world]].\n     */\n    GraphicType[GraphicType[\"WorldDecoration\"] = 2] = \"WorldDecoration\";\n    /**\n     * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldDecoration]] only in that depth-testing is disabled.\n     * For example, the ACS triad and [[WindowAreaTool]] decorations are of this type.\n     * Coordinates: [[CoordSystem.World]].\n     * [[RenderMode]]: [[RenderMode.SmoothShade]]\n     * Lighting: default.\n     * Depth-testing: disabled.\n     * Renders atop the scene. Coordinates: world. RenderMode: smooth. Lighting: none. Z-testing: disabled\n     * @note Overlay decorations typically employ some degree of transparency to ensure that they do not fully obscure the scene.\n     * @see [[Decorations.worldOverlay]]\n     */\n    GraphicType[GraphicType[\"WorldOverlay\"] = 3] = \"WorldOverlay\";\n    /**\n     * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldOverlay]] only in that their geometry is defined in view coordinates rather than world.\n     * Coordinates: [[CoordSystem.View]].\n     * [[RenderMode]]: [[RenderMode.SmoothShade]]\n     * Lighting: default.\n     * Depth-testing: disabled.\n     * @note For more flexibility in defining view overlay decorations, consider using a [[CanvasDecorationList]].\n     * @see [[Decorations.viewOverlay]]\n     */\n    GraphicType[GraphicType[\"ViewOverlay\"] = 4] = \"ViewOverlay\";\n})(GraphicType || (GraphicType = {}));\n/** Provides methods for constructing a [[RenderGraphic]] from geometric primitives.\n * GraphicBuilder is primarily used for creating [[Decorations]] to be displayed inside a [[Viewport]].\n *\n * The typical process for constructing a [[RenderGraphic]] proceeds as follows:\n *  1. Use [[DecorateContext.createGraphic]] or [[RenderSystem.createGraphic]] to obtain a builder.\n *  2. Set up the symbology using [[GraphicBuilder.activateGraphicParams]] or [[GraphicBuilder.setSymbology]].\n *  3. Add one or more geometric primitives using methods like [[GraphicBuilder.addShape]] and [[GraphicBuilder.addLineString]], possibly setting new symbology in between.\n *  4. Use [[GraphicBuilder.finish]] to produce the finished [[RenderGraphic]].\n *\n * @note Most of the methods which add geometry to the builder take ownership of their inputs rather than cloning them.\n * So, for example, if you pass an array of points to addLineString(), you should not subsequently modify that array.\n *\n * @public\n * @extensions\n */\nexport class GraphicBuilder {\n    /** @internal */\n    constructor(options) {\n        // Stored for potential use later in creating a new GraphicBuilder from this one (see PrimitiveBuilder.finishGraphic).\n        this._options = options;\n        const vp = options.viewport;\n        this.placement = options.placement ?? Transform.createIdentity();\n        this.iModel = vp?.iModel ?? options.iModel;\n        this.type = options.type;\n        this.pickable = options.pickable;\n        this.wantEdges = options.generateEdges ?? (this.type === GraphicType.Scene && (!vp || vp.viewFlags.edgesRequired()));\n        this.wantNormals = options.wantNormals ?? (this.wantEdges || this.type === GraphicType.Scene);\n        this.preserveOrder = options.preserveOrder ?? (this.isOverlay || this.isViewBackground);\n        if (!options.viewport) {\n            this._computeChordTolerance = options.computeChordTolerance;\n            return;\n        }\n        this.analysisStyle = options.viewport.displayStyle.settings.analysisStyle;\n        this._computeChordTolerance = (args) => {\n            let pixelSize = 1;\n            if (!this.isViewCoordinates) {\n                // Compute the horizontal distance in meters between two adjacent pixels at the center of the geometry.\n                pixelSize = options.viewport.getPixelSizeAtPoint(args.computeRange().center);\n                pixelSize = options.viewport.target.adjustPixelSizeForLOD(pixelSize);\n                // Aspect ratio skew > 1.0 stretches the view in Y. In that case use the smaller vertical pixel distance for our stroke tolerance.\n                const skew = options.applyAspectRatioSkew ? options.viewport.view.getAspectRatioSkew() : 0;\n                if (skew > 1)\n                    pixelSize /= skew;\n            }\n            return pixelSize * 0.25;\n        };\n    }\n    /** The Id to be associated with the graphic for picking.\n     * @see [[GraphicBuilderOptions.pickable]] for more options.\n     * @deprecated in 3.x. This provides only the **first** pickable Id for this graphic - you should keep track of the **current** pickable Id yourself.\n     */\n    get pickId() {\n        return this.pickable?.id;\n    }\n    /** Whether the builder's geometry is defined in [[CoordSystem.View]] coordinates.\n     * @see [[isWorldCoordinates]].\n     */\n    get isViewCoordinates() {\n        return this.type === GraphicType.ViewBackground || this.type === GraphicType.ViewOverlay;\n    }\n    /** Whether the builder's geometry is defined in [[CoordSystem.World]] coordinates.\n     * @see [[isViewCoordinates]].\n     */\n    get isWorldCoordinates() {\n        return !this.isViewCoordinates;\n    }\n    /** True if the builder produces a graphic of [[GraphicType.Scene]]. */\n    get isSceneGraphic() {\n        return this.type === GraphicType.Scene;\n    }\n    /** True if the builder produces a graphic of [[GraphicType.ViewBackground]]. */\n    get isViewBackground() {\n        return this.type === GraphicType.ViewBackground;\n    }\n    /** True if the builder produces a graphic of [[GraphicType.WorldOverlay]] or [[GraphicType.ViewOerlay]]. */\n    get isOverlay() {\n        return this.type === GraphicType.ViewOverlay || this.type === GraphicType.WorldOverlay;\n    }\n    /** Called by [[activateFeature]] after validation to change the [Feature]($common) to be associated with subsequently-added geometry.\n     * This default implementation does nothing.\n     */\n    _activateFeature(_feature) { }\n    /** Change the [Feature]($common) to be associated with subsequently-added geometry. This permits multiple features to be batched together into a single graphic\n     * for more efficient rendering.\n     * @note This method has no effect if [[GraphicBuilderOptions.pickable]] was not supplied to the GraphicBuilder's constructor.\n     */\n    activateFeature(feature) {\n        assert(undefined !== this._options.pickable, \"GraphicBuilder.activateFeature has no effect if PickableGraphicOptions were not supplied\");\n        if (this._options.pickable)\n            this._activateFeature(feature);\n    }\n    /** Change the pickable Id to be associated with subsequently-added geometry. This permits multiple pickable objects to be batched  together into a single graphic\n     * for more efficient rendering. This method calls [[activateFeature]], using the subcategory Id and [GeometryClass]($common) specified in [[GraphicBuilder.pickable]]\n     * at construction, if any.\n     * @note This method has no effect if [[GraphicBuilderOptions.pickable]] was not supplied to the GraphicBuilder's constructor.\n     */\n    activatePickableId(id) {\n        const pick = this._options.pickable;\n        this.activateFeature(new Feature(id, pick?.subCategoryId, pick?.geometryClass));\n    }\n    /** Append a [CurvePrimitive]($core-geometry) to the builder. */\n    addCurvePrimitive(curve) {\n        switch (curve.curvePrimitiveType) {\n            case \"lineString\":\n                this.addLineString(curve.points);\n                break;\n            case \"lineSegment\":\n                this.addLineString([curve.startPoint(), curve.endPoint()]);\n                break;\n            case \"arc\":\n                this.addArc(curve, false, false);\n                break;\n            default:\n                const path = new Path();\n                if (path.tryAddChild(curve))\n                    this.addPath(path);\n                break;\n        }\n    }\n    /** Append any primitive to the builder.\n     * @param primitive The graphic primitive to append.\n     */\n    addPrimitive(primitive) {\n        switch (primitive.type) {\n            case \"linestring\":\n                this.addLineString(primitive.points);\n                break;\n            case \"linestring2d\":\n                this.addLineString2d(primitive.points, primitive.zDepth);\n                break;\n            case \"pointstring\":\n                this.addPointString(primitive.points);\n                break;\n            case \"pointstring2d\":\n                this.addPointString2d(primitive.points, primitive.zDepth);\n                break;\n            case \"shape\":\n                this.addShape(primitive.points);\n                break;\n            case \"shape2d\":\n                this.addShape2d(primitive.points, primitive.zDepth);\n                break;\n            case \"arc\":\n                this.addArc(primitive.arc, true === primitive.isEllipse, true === primitive.filled);\n                break;\n            case \"arc2d\":\n                this.addArc2d(primitive.arc, true === primitive.isEllipse, true === primitive.filled, primitive.zDepth);\n                break;\n            case \"path\":\n                this.addPath(primitive.path);\n                break;\n            case \"loop\":\n                this.addLoop(primitive.loop);\n                break;\n            case \"polyface\":\n                this.addPolyface(primitive.polyface, true === primitive.filled);\n                break;\n            case \"solidPrimitive\":\n                this.addSolidPrimitive(primitive.solidPrimitive);\n                break;\n        }\n    }\n    /** Add a box representing a volume of space. Typically used for debugging purposes.\n     * @param range The volume of space.\n     * @param solid If true, a [[Box]] solid primitive will be added; otherwise, a wireframe outline of the box will be added.\n     */\n    addRangeBox(range, solid = false) {\n        if (!solid) {\n            this.addFrustum(Frustum.fromRange(range));\n            return;\n        }\n        const box = Box.createRange(range, true);\n        if (box)\n            this.addSolidPrimitive(box);\n    }\n    /** Add Frustum edges. Useful for debugging. */\n    addFrustum(frustum) {\n        this.addRangeBoxFromCorners(frustum.points);\n    }\n    /** Add range edges from corner points */\n    addRangeBoxFromCorners(p) {\n        this.addLineString([\n            p[Npc.LeftBottomFront],\n            p[Npc.LeftTopFront],\n            p[Npc.RightTopFront],\n            p[Npc.RightBottomFront],\n            p[Npc.RightBottomRear],\n            p[Npc.RightTopRear],\n            p[Npc.LeftTopRear],\n            p[Npc.LeftBottomRear],\n            p[Npc.LeftBottomFront].clone(),\n            p[Npc.RightBottomFront].clone(),\n        ]);\n        this.addLineString([p[Npc.LeftTopFront].clone(), p[Npc.LeftTopRear].clone()]);\n        this.addLineString([p[Npc.RightTopFront].clone(), p[Npc.RightTopRear].clone()]);\n        this.addLineString([p[Npc.LeftBottomRear].clone(), p[Npc.RightBottomRear].clone()]);\n    }\n    /** Sets the current active symbology for this builder. Any new geometry subsequently added will be drawn using the specified symbology.\n     * @param lineColor The color in which to draw lines.\n     * @param fillColor The color in which to draw filled regions.\n     * @param lineWidth The width in pixels to draw lines. The renderer will clamp this value to an integer in the range [1, 32].\n     * @param linePixels The pixel pattern in which to draw lines.\n     * @see [[GraphicBuilder.activateGraphicParams]] for additional symbology options.\n     */\n    setSymbology(lineColor, fillColor, lineWidth, linePixels = LinePixels.Solid) {\n        this.activateGraphicParams(GraphicParams.fromSymbology(lineColor, fillColor, lineWidth, linePixels));\n    }\n    /** Set the current active symbology for this builder to be a blanking fill before adding a planar region.\n     * A planar region drawn with blanking fill renders behind other geometry in the same graphic.\n     * Blanking fill is not affected by the fill [[ViewFlags]] being disabled.\n     * An example would be to add a line to a graphic containing a shape with blanking fill so that the line is always shown in front of the fill.\n     * @param fillColor The color in which to draw filled regions.\n     */\n    setBlankingFill(fillColor) { this.activateGraphicParams(GraphicParams.fromBlankingFill(fillColor)); }\n}\n//# sourceMappingURL=GraphicBuilder.js.map",
      "start": 1693508119770,
      "end": 1693508119913,
      "sourcemaps": null
    }
  ]
}
