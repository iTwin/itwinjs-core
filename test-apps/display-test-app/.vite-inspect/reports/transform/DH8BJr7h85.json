{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveFactory.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\n// import { Geometry, Angle, AngleSweep } from \"../Geometry\";\nimport { AxisIndex, AxisOrder, Geometry } from \"../Geometry\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { PolylineOps } from \"../geometry3d/PolylineOps\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Segment1d } from \"../geometry3d/Segment1d\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\nimport { Cone } from \"../solid/Cone\";\nimport { RuledSweep } from \"../solid/RuledSweep\";\nimport { TorusPipe } from \"../solid/TorusPipe\";\nimport { Arc3d } from \"./Arc3d\";\nimport { CurveChain } from \"./CurveCollection\";\nimport { CurvePrimitive } from \"./CurvePrimitive\";\nimport { GeometryQuery } from \"./GeometryQuery\";\nimport { LineSegment3d } from \"./LineSegment3d\";\nimport { LineString3d } from \"./LineString3d\";\nimport { Loop } from \"./Loop\";\nimport { Path } from \"./Path\";\nimport { IntegratedSpiral3d } from \"./spiral/IntegratedSpiral3d\";\n/**\n * Enumeration of geometric output for [CurveFactory.createMiteredSweepSections].\n * @public\n */\nexport var MiteredSweepOutputSelect;\n(function (MiteredSweepOutputSelect) {\n    /** Output only the parallel arrays of planes and sections. */\n    MiteredSweepOutputSelect[MiteredSweepOutputSelect[\"Sections\"] = 0] = \"Sections\";\n    /** Output planes and sections, as well as the assembled ruled sweep. */\n    MiteredSweepOutputSelect[MiteredSweepOutputSelect[\"AlsoRuledSweep\"] = 1] = \"AlsoRuledSweep\";\n    /** Output planes and sections, as well as the assembled ruled sweep and its stroked mesh. */\n    MiteredSweepOutputSelect[MiteredSweepOutputSelect[\"AlsoMesh\"] = 2] = \"AlsoMesh\";\n})(MiteredSweepOutputSelect || (MiteredSweepOutputSelect = {}));\n/**\n * The `CurveFactory` class contains methods for specialized curve constructions.\n * @public\n */\nexport class CurveFactory {\n    /** (cautiously) construct and save a line segment between fractional positions. */\n    static addPartialSegment(path, allowBackup, pointA, pointB, fraction0, fraction1) {\n        if (allowBackup || (fraction1 > fraction0)) {\n            if (pointA !== undefined && pointB !== undefined && !Geometry.isAlmostEqualNumber(fraction0, fraction1))\n                path.tryAddChild(LineSegment3d.create(pointA.interpolate(fraction0, pointB), pointA.interpolate(fraction1, pointB)));\n        }\n    }\n    /**\n     * Create a circular arc from start point, tangent at start, and another point (endpoint) on the arc.\n     * @param pointA\n     * @param tangentA\n     * @param pointB\n     */\n    static createArcPointTangentPoint(pointA, tangentA, pointB) {\n        const vectorV = Vector3d.createStartEnd(pointA, pointB);\n        const frame = Matrix3d.createRigidFromColumns(tangentA, vectorV, AxisOrder.XYZ);\n        if (frame !== undefined) {\n            const vv = vectorV.dotProduct(vectorV);\n            const vw = frame.dotColumnY(vectorV);\n            const alpha = Geometry.conditionalDivideCoordinate(vv, 2 * vw);\n            if (alpha !== undefined) {\n                const vector0 = frame.columnY();\n                vector0.scaleInPlace(-alpha);\n                const vector90 = frame.columnX();\n                vector90.scaleInPlace(alpha);\n                const centerToEnd = vector0.plus(vectorV);\n                const sweepAngle = vector0.angleTo(centerToEnd);\n                let sweepRadians = sweepAngle.radians; // That's always positive and less than PI.\n                if (tangentA.dotProduct(centerToEnd) < 0.0) // ah, sweepRadians is the wrong way\n                    sweepRadians = 2.0 * Math.PI - sweepRadians;\n                const center = pointA.plusScaled(vector0, -1.0);\n                return Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, sweepRadians));\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Construct a sequence of alternating lines and arcs with the arcs creating tangent transition between consecutive edges.\n     *  * If the radius parameter is a number, that radius is used throughout.\n     *  * If the radius parameter is an array of numbers, `radius[i]` is applied at `point[i]`.\n     *    * Note that since no fillet is constructed at the initial or final point, those entries in `radius[]` are never referenced.\n     *    * A zero radius for any point indicates to leave the as a simple corner.\n     * @param points point source\n     * @param radius fillet radius or array of radii indexed to correspond to the points.\n     * @param allowBackupAlongEdge true to allow edges to be created going \"backwards\" along edges if needed to create the blend.\n     */\n    static createFilletsInLineString(points, radius, allowBackupAlongEdge = true) {\n        if (Array.isArray(points))\n            return this.createFilletsInLineString(new Point3dArrayCarrier(points), radius, allowBackupAlongEdge);\n        if (points instanceof LineString3d)\n            return this.createFilletsInLineString(points.packedPoints, radius, allowBackupAlongEdge);\n        const n = points.length;\n        if (n <= 1)\n            return undefined;\n        const pointA = points.getPoint3dAtCheckedPointIndex(0);\n        const pointB = points.getPoint3dAtCheckedPointIndex(1);\n        // remark: n=2 and n=3 cases should fall out from loop logic\n        const blendArray = [];\n        // build one-sided blends at each end . .\n        blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointA.clone() });\n        for (let i = 1; i + 1 < n; i++) {\n            const pointC = points.getPoint3dAtCheckedPointIndex(i + 1);\n            let thisRadius = 0;\n            if (Array.isArray(radius)) {\n                if (i < radius.length)\n                    thisRadius = radius[i];\n            }\n            else if (Number.isFinite(radius))\n                thisRadius = radius;\n            if (thisRadius !== 0.0)\n                blendArray.push(Arc3d.createFilletArc(pointA, pointB, pointC, thisRadius));\n            else\n                blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointB.clone() });\n            pointA.setFromPoint3d(pointB);\n            pointB.setFromPoint3d(pointC);\n        }\n        blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointB.clone() });\n        if (!allowBackupAlongEdge) {\n            // suppress arcs that have overlap with both neighbors or flood either neighbor ..\n            for (let i = 1; i + 1 < n; i++) {\n                const b = blendArray[i];\n                if (b.fraction10 > 1.0\n                    || b.fraction12 > 1.0\n                    || 1.0 - b.fraction10 < blendArray[i - 1].fraction12\n                    || b.fraction12 > 1.0 - blendArray[i + 1].fraction10) {\n                    b.fraction10 = 0.0;\n                    b.fraction12 = 0.0;\n                    blendArray[i].arc = undefined;\n                }\n            }\n            /* The \"1-b\" logic above prevents this loop from ever doing anything.\n            // on edge with conflict, suppress the arc with larger fraction\n            for (let i = 1; i < n; i++) {\n              const b0 = blendArray[i - 1];\n              const b1 = blendArray[i];\n              if (b0.fraction12 > 1 - b1.fraction10) {\n                const b = b0.fraction12 > b1.fraction12 ? b1 : b0;\n                b.fraction10 = 0.0;\n                b.fraction12 = 0.0;\n                blendArray[i].arc = undefined;\n              }\n            } */\n        }\n        const path = Path.create();\n        this.addPartialSegment(path, allowBackupAlongEdge, blendArray[0].point, blendArray[1].point, blendArray[0].fraction12, 1.0 - blendArray[1].fraction10);\n        // add each path and successor edge ...\n        for (let i = 1; i + 1 < points.length; i++) {\n            const b0 = blendArray[i];\n            const b1 = blendArray[i + 1];\n            path.tryAddChild(b0.arc);\n            this.addPartialSegment(path, allowBackupAlongEdge, b0.point, b1.point, b0.fraction12, 1.0 - b1.fraction10);\n        }\n        return path;\n    }\n    /** Create a `Loop` with given xy corners and fixed z.\n     * * The corners always proceed counter clockwise from lower left.\n     * * If the radius is too large for the outer rectangle size, it is reduced to half of the the smaller x or y size.\n    */\n    static createRectangleXY(x0, y0, x1, y1, z = 0, filletRadius) {\n        let radius = Geometry.correctSmallMetricDistance(filletRadius);\n        const xMin = Math.min(x0, x1);\n        const xMax = Math.max(x0, x1);\n        const yMin = Math.min(y0, y1);\n        const yMax = Math.max(y0, y1);\n        radius = Math.min(Math.abs(radius), 0.5 * (xMax - xMin), 0.5 * (yMax - yMin));\n        if (radius === 0.0)\n            return Loop.createPolygon([Point3d.create(xMin, yMin, z), Point3d.create(xMax, yMin, z), Point3d.create(xMax, yMax, z), Point3d.create(xMin, yMax, z), Point3d.create(xMin, yMin, z)]);\n        else {\n            const vectorU = Vector3d.create(radius, 0, 0);\n            const vectorV = Vector3d.create(0, radius, 0);\n            const x0A = xMin + radius;\n            const y0A = yMin + radius;\n            const x1A = xMax - radius;\n            const y1A = yMax - radius;\n            const centers = [Point3d.create(x1A, y1A, z), Point3d.create(x0A, y1A, z), Point3d.create(x0A, y0A, z), Point3d.create(x1A, y0A, z)];\n            const loop = Loop.create();\n            for (let i = 0; i < 4; i++) {\n                const center = centers[i];\n                const nextCenter = centers[(i + 1) % 4];\n                const edgeVector = Vector3d.createStartEnd(center, nextCenter);\n                const arc = Arc3d.create(center, vectorU, vectorV, AngleSweep.createStartEndDegrees(0, 90));\n                loop.tryAddChild(arc);\n                const arcEnd = arc.endPoint();\n                if (!edgeVector.isAlmostZero)\n                    loop.tryAddChild(LineSegment3d.create(arcEnd, arcEnd.plus(edgeVector)));\n                vectorU.rotate90CCWXY(vectorU);\n                vectorV.rotate90CCWXY(vectorV);\n            }\n            return loop;\n        }\n    }\n    /**\n     * If `arcB` is a continuation of `arcA`, extend `arcA` (in place) to include the range of `arcB`\n     * * This only succeeds if the two arcs are part of identical complete arcs and end of `arcA` matches the beginning of `arcB`.\n     * * \"Reversed\"\n     * @param arcA\n     * @param arcB\n     */\n    static appendToArcInPlace(arcA, arcB, allowReverse = false) {\n        if (arcA.center.isAlmostEqual(arcB.center)) {\n            const sweepSign = Geometry.split3WaySign(arcA.sweep.sweepRadians * arcB.sweep.sweepRadians, -1, 0, 1);\n            // evaluate derivatives wrt radians (not fraction!), but adjust direction for sweep signs\n            const endA = arcA.angleToPointAndDerivative(arcA.sweep.fractionToAngle(1.0));\n            if (arcA.sweep.sweepRadians < 0)\n                endA.direction.scaleInPlace(-1.0);\n            const startB = arcB.angleToPointAndDerivative(arcB.sweep.fractionToAngle(0.0));\n            if (arcB.sweep.sweepRadians < 0)\n                startB.direction.scaleInPlace(-1.0);\n            if (endA.isAlmostEqual(startB)) {\n                arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians + sweepSign * arcB.sweep.sweepRadians);\n                return true;\n            }\n            // Also ok if negated tangent . ..\n            if (allowReverse) {\n                startB.direction.scaleInPlace(-1.0);\n                if (endA.isAlmostEqual(startB)) {\n                    arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians - sweepSign * arcB.sweep.sweepRadians);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Return a `Path` containing arcs are on the surface of an ellipsoid and pass through a sequence of points.\n     * * Each arc passes through the two given endpoints and in the plane containing the true surface normal at given `fractionForIntermediateNormal`\n     * @param ellipsoid\n     * @param pathPoints\n     * @param fractionForIntermediateNormal fractional position for surface normal used to create the section plane.\n     */\n    static assembleArcChainOnEllipsoid(ellipsoid, pathPoints, fractionForIntermediateNormal = 0.5) {\n        const arcPath = Path.create();\n        for (let i = 0; i + 1 < pathPoints.length; i++) {\n            const arc = ellipsoid.sectionArcWithIntermediateNormal(pathPoints[i].toAngles(), fractionForIntermediateNormal, pathPoints[i + 1].toAngles());\n            arcPath.tryAddChild(arc);\n        }\n        return arcPath;\n    }\n    static appendGeometryQueryArray(candidate, result) {\n        if (candidate instanceof GeometryQuery)\n            result.push(candidate);\n        else if (Array.isArray(candidate)) {\n            for (const p of candidate)\n                this.appendGeometryQueryArray(p, result);\n        }\n    }\n    /**\n     * Create solid primitives for pipe segments (e.g. Cone or TorusPipe) around line and arc primitives.\n     * @param centerline centerline geometry/\n     * @param pipeRadius radius of pipe.\n     */\n    static createPipeSegments(centerline, pipeRadius) {\n        if (centerline instanceof LineSegment3d) {\n            return Cone.createAxisPoints(centerline.startPoint(), centerline.endPoint(), pipeRadius, pipeRadius, false);\n        }\n        else if (centerline instanceof Arc3d) {\n            return TorusPipe.createAlongArc(centerline, pipeRadius, false);\n        }\n        else if (centerline instanceof CurvePrimitive) {\n            const builder = PolyfaceBuilder.create();\n            builder.addMiteredPipes(centerline, pipeRadius);\n            return builder.claimPolyface();\n        }\n        else if (centerline instanceof CurveChain) {\n            const result = [];\n            for (const p of centerline.children) {\n                const pipe = this.createPipeSegments(p, pipeRadius);\n                this.appendGeometryQueryArray(pipe, result);\n            }\n            return result;\n        }\n        return undefined;\n    }\n    /**\n     * * Create section arcs for mitered pipe.\n     * * At each end of each pipe, the pipe is cut by the plane that bisects the angle between successive pipe centerlines.\n     * * The arc definitions are constructed so that lines between corresponding fractional positions on the arcs are\n     *     axial lines on the pipes.\n     * * This means that each arc definition axes (aka vector0 and vector90) are _not_ perpendicular to each other.\n     * * Circular or elliptical pipe cross sections can be specified by supplying either a radius, a pair of semi-axis lengths, or a full Arc3d.\n     *    * For semi-axis length input, x corresponds to an ellipse local axis nominally situated parallel to the xy-plane.\n     *    * The center of Arc3d input is translated to the centerline start point to act as initial cross section.\n     * @param centerline centerline of pipe\n     * @param sectionData circle radius, ellipse semi-axis lengths, or full Arc3d\n     */\n    static createMiteredPipeSections(centerline, sectionData) {\n        const arcs = [];\n        if (centerline.length < 2)\n            return [];\n        const vector0 = Vector3d.create();\n        const vector90 = Vector3d.create();\n        const vectorBC = Vector3d.create();\n        const currentCenter = Point3d.create();\n        centerline.vectorIndexIndex(0, 1, vectorBC);\n        centerline.getPoint3dAtUncheckedPointIndex(0, currentCenter);\n        let initialSection;\n        if (sectionData instanceof Arc3d) {\n            initialSection = sectionData.clone();\n            initialSection.center.setFrom(currentCenter);\n            vector0.setFrom(sectionData.vector0);\n            vector90.setFrom(sectionData.vector90);\n        }\n        else if (typeof sectionData === \"number\" || Point3d.isXAndY(sectionData)) {\n            const length0 = (typeof sectionData === \"number\") ? sectionData : sectionData.x;\n            const length90 = (typeof sectionData === \"number\") ? sectionData : sectionData.y;\n            const baseFrame = Matrix3d.createRigidHeadsUp(vectorBC, AxisOrder.ZXY);\n            baseFrame.columnX(vector0).scaleInPlace(length0);\n            baseFrame.columnY(vector90).scaleInPlace(length90);\n            initialSection = Arc3d.create(currentCenter, vector0, vector90, AngleSweep.create360());\n        }\n        else {\n            return [];\n        }\n        arcs.push(initialSection);\n        const vectorAB = Vector3d.create();\n        const bisector = Vector3d.create();\n        for (let i = 1; i < centerline.length; i++) {\n            vectorAB.setFromVector3d(vectorBC);\n            centerline.getPoint3dAtUncheckedPointIndex(i, currentCenter);\n            if (i + 1 < centerline.length) {\n                centerline.vectorIndexIndex(i, i + 1, vectorBC);\n            }\n            else {\n                vectorBC.setFromVector3d(vectorAB);\n            }\n            if (vectorAB.normalizeInPlace() && vectorBC.normalizeInPlace()) {\n                vectorAB.interpolate(0.5, vectorBC, bisector);\n                // On the end ellipse for this pipe section. ..\n                // center comes directly from centerline[i]\n                // vector0 and vector90 are obtained by sweeping the corresponding vectors of the start ellipse to the split plane.\n                moveVectorToPlane(vector0, vectorAB, bisector, vector0);\n                moveVectorToPlane(vector90, vectorAB, bisector, vector90);\n                arcs.push(Arc3d.create(currentCenter, vector0, vector90, AngleSweep.create360()));\n            }\n        }\n        return arcs;\n    }\n    /**\n     * Sweep the initialSection along each segment of the centerLine until it hits the bisector plane at the next vertex.\n     * * The caller should place the initialSection on a plane perpendicular to the first edge.\n     *   * This plane is commonly (but not necessarily) through the start point itself.\n     *   * If the geometry is not \"on a perpendicular plane\", the output geometry will still be flattened onto the various planes.\n     * * In the \"open path\" case (i.e when wrapIfPhysicallyClosed is false or the path does not have matched first and last points)\n     *       the first/last output plane will be at the start/end of the first/last edge and on a perpendicular plane.\n     * * In the \"closed path\" case, the output plane for the first and last point is the bisector of the start and end planes from the \"open path\" case,\n     *    and the first/last section geometry may be different from `initialSection`.\n     * * The centerline path does NOT have to be planar, however twisting effects effects will appear in the various bisector planes.\n     * @param centerline sweep path, e.g., as stroked from a smooth centerline curve\n     * @param initialSection profile curve to be swept. As noted above, this should be on a plane perpendicular to the first segment of the centerline.\n     * @param options options for computation and output\n     * @return array of sections, starting with `initialSection` projected along the first edge to the first plane.\n     */\n    static createMiteredSweepSections(centerline, initialSection, options) {\n        const sectionData = { sections: [], planes: [] };\n        const planes = PolylineOps.createBisectorPlanesForDistinctPoints(centerline, options.wrapIfPhysicallyClosed);\n        if (planes !== undefined && planes.length > 1) {\n            // Projection to target plane, constructing sweep direction from two given planes.\n            // If successful, push the target plane and swept section to the output arrays and return the swept section.\n            // If unsuccessful, leave the output arrays alone and return the input section.\n            const doSweepToPlane = function (edgePlane0, edgePlane1, targetPlane, section) {\n                const sweepVector = Vector3d.createStartEnd(edgePlane0.getOriginRef(), edgePlane1.getOriginRef());\n                const transform = Transform.createFlattenAlongVectorToPlane(sweepVector, targetPlane.getOriginRef(), targetPlane.getNormalRef());\n                if (transform === undefined)\n                    return section;\n                const section1 = section.cloneTransformed(transform);\n                if (section1 === undefined)\n                    return section;\n                sectionData.planes.push(targetPlane);\n                sectionData.sections.push(section1);\n                return section1;\n            };\n            let currentSection = doSweepToPlane(planes[0], planes[1], planes[0], initialSection);\n            for (let i = 1; i < planes.length; i++) {\n                currentSection = doSweepToPlane(planes[i - 1], planes[i], planes[i], currentSection);\n            }\n            if (options.outputSelect) {\n                const ruledSweep = RuledSweep.create(sectionData.sections, options.capped ?? false);\n                if (ruledSweep) {\n                    sectionData.ruledSweep = ruledSweep;\n                    if (MiteredSweepOutputSelect.AlsoMesh === options.outputSelect) {\n                        const builder = PolyfaceBuilder.create(options.strokeOptions);\n                        builder.addRuledSweep(ruledSweep);\n                        sectionData.mesh = builder.claimPolyface();\n                    }\n                }\n            }\n            return sectionData;\n        }\n        return undefined;\n    }\n    /**\n     * Create a circular arc from start point, tangent at start, radius, optional plane normal, arc sweep\n     * * The vector from start point to center is in the direction of upVector crossed with tangentA.\n     * @param pointA start point\n     * @param tangentA vector in tangent direction at the start\n     * @param radius signed radius.\n     * @param upVector optional out-of-plane vector.  Defaults to positive Z\n     * @param sweep angular range.  If single `Angle` is given, start angle is at 0 degrees (the start point).\n     *\n     */\n    static createArcPointTangentRadius(pointA, tangentA, radius, upVector, sweep) {\n        if (upVector === undefined)\n            upVector = Vector3d.unitZ();\n        const vector0 = upVector.unitCrossProduct(tangentA);\n        if (vector0 === undefined)\n            return undefined;\n        const center = pointA.plusScaled(vector0, radius);\n        // reverse the A-to-center vector and bring it up to scale ...\n        vector0.scaleInPlace(-radius);\n        const vector90 = tangentA.scaleToLength(Math.abs(radius)); // (Cannot fail -- prior unitCrossProduct would have failed first)\n        return Arc3d.create(center, vector0, vector90, AngleSweep.create(sweep));\n    }\n    /**\n     * Compute 2 spirals (all in XY) for a symmetric line-to-line transition.\n     * * First spiral begins at given start point.\n     * * first tangent aims at shoulder\n     * * outbound spiral joins line from shoulder to target.\n     * @param spiralType name of spiral type.  THIS MUST BE AN \"Integrated\" SPIRAL TYPE\n     * @param startPoint inbound start point.\n     * @param shoulder point target point for (both) spiral-to-line tangencies\n     * @return array with the computed spirals, or undefined if failure.\n     */\n    static createLineSpiralSpiralLine(spiralType, startPoint, shoulderPoint, targetPoint) {\n        const vectorAB = Vector3d.createStartEnd(startPoint, shoulderPoint);\n        const vectorBC0 = Vector3d.createStartEnd(shoulderPoint, targetPoint);\n        const referenceLength = vectorAB.magnitude();\n        const radiansAB = Math.atan2(vectorAB.y, vectorAB.x);\n        const lineTurnRadians = vectorAB.angleToXY(vectorBC0);\n        const spiralTurnRadians = 0.5 * lineTurnRadians.radians;\n        const radiansBC = radiansAB + lineTurnRadians.radians;\n        const axesA = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, Angle.createRadians(radiansAB));\n        const frameA = Transform.createRefs(startPoint.clone(), axesA);\n        // We know how much it has to turn, and but not the length or end radius.\n        // make a spiral of referenceLength and scale it back to the junction line\n        const spiralARefLength = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0.0, undefined, Angle.createRadians(0), Angle.createRadians(spiralTurnRadians), referenceLength, undefined, frameA);\n        if (spiralARefLength) {\n            const midPlanePerpendicularRadians = radiansAB + spiralTurnRadians;\n            const midPlanePerpendicularVector = Vector3d.createPolar(1.0, Angle.createRadians(midPlanePerpendicularRadians));\n            const altitudeB = midPlanePerpendicularVector.dotProductStartEnd(startPoint, shoulderPoint);\n            const altitudeSpiralEnd = midPlanePerpendicularVector.dotProductStartEnd(startPoint, spiralARefLength.endPoint());\n            const scaleFactor = altitudeB / altitudeSpiralEnd;\n            const spiralA = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0.0, undefined, Angle.createRadians(0), Angle.createRadians(spiralTurnRadians), referenceLength * scaleFactor, undefined, frameA);\n            const distanceAB = vectorAB.magnitude();\n            const vectorBC = Vector3d.createStartEnd(shoulderPoint, targetPoint);\n            vectorBC.scaleToLength(distanceAB, vectorBC);\n            const pointC = shoulderPoint.plus(vectorBC);\n            const axesC = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, Angle.createRadians(radiansBC + Math.PI));\n            const frameC = Transform.createRefs(pointC, axesC);\n            const spiralC = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, -spiralA.radius01.x1, Angle.zero(), undefined, spiralA.curveLength(), Segment1d.create(1, 0), frameC);\n            return [spiralA, spiralC];\n        }\n        return undefined;\n    }\n    /**\n     * Compute 2 spirals (all in XY) for a symmetric line-to-line transition.\n     * * Spiral length is given.\n     * * tangency points float on both lines.\n     * @param spiralType name of spiral type.  THIS MUST BE AN \"Integrated\" SPIRAL TYPE\n     * @param pointA inbound start point.\n     * @param shoulder point target point for (both) spiral-to-line tangencies\n     * @param spiralLength for each part of the spiral pair.\n     * @return array with the computed spirals, or undefined if failure.\n     */\n    static createLineSpiralSpiralLineWithSpiralLength(spiralType, pointA, pointB, pointC, spiralLength) {\n        const vectorAB = Vector3d.createStartEnd(pointA, pointB);\n        const vectorBC = Vector3d.createStartEnd(pointB, pointC);\n        const radiansAB = Math.atan2(vectorAB.y, vectorAB.x);\n        const lineTurnAngle = vectorAB.angleToXY(vectorBC);\n        const spiralTurnRadians = 0.5 * lineTurnAngle.radians;\n        const bisectorRadians = 0.5 * (Math.PI - lineTurnAngle.radians);\n        const radiansCB = Math.atan2(-vectorBC.y, -vectorBC.x);\n        const spiralAB0 = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, undefined, Angle.zero(), Angle.createRadians(spiralTurnRadians), spiralLength, undefined, Transform.createIdentity());\n        if (spiralAB0) {\n            const localEndPoint = spiralAB0.fractionToPoint(1);\n            const distanceAB = pointA.distance(pointB);\n            const distanceCB = pointC.distance(pointB);\n            // The spiral eventually has to end on the bisector, at localEndPoint.y height from the inbound line\n            // distance from shoulder to projection of that point to point E on the inbound line is\n            const distanceBE = localEndPoint.y / Math.tan(bisectorRadians);\n            const xFractionAB = Geometry.conditionalDivideFraction(distanceAB - distanceBE - localEndPoint.x, distanceAB);\n            const xFractionCB = Geometry.conditionalDivideFraction(distanceCB - distanceBE - localEndPoint.x, distanceCB);\n            if (xFractionAB !== undefined && xFractionCB !== undefined) {\n                const axesA = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, Angle.createRadians(radiansAB));\n                const frameAOrigin = pointA.interpolate(xFractionAB, pointB);\n                const frameA = Transform.createRefs(frameAOrigin, axesA);\n                const spiralAB = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, undefined, Angle.zero(), Angle.createRadians(spiralTurnRadians), spiralLength, undefined, frameA);\n                const axesB = Matrix3d.createRotationAroundAxisIndex(AxisIndex.Z, Angle.createRadians(radiansCB));\n                const frameBOrigin = pointC.interpolate(xFractionCB, pointB);\n                const frameB = Transform.createRefs(frameBOrigin, axesB);\n                const spiralBC = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, undefined, Angle.zero(), Angle.createRadians(-spiralTurnRadians), spiralLength, undefined, frameB);\n                return [spiralAB, spiralBC];\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Compute 2 spirals and an arc (all in XY) for a symmetric line-to-line transition.\n     * Spiral lengths and arc radius are given.   (e.g. from design speed standards.)\n     * @param spiralType name of spiral type.  THIS MUST BE AN \"Integrated\" SPIRAL TYPE\n     * @param pointA inbound start point.\n     * @param pointB shoulder (target)  point for (both) spiral-to-line tangencies\n     * @param lengthA inbound spiral length\n     * @param lengthB outbound spiral length\n     * @return array with the computed spirals, or undefined if failure.\n     */\n    static createLineSpiralArcSpiralLine(spiralType, pointA, pointB, pointC, lengthA, lengthB, arcRadius) {\n        const vectorAB = Vector3d.createStartEnd(pointA, pointB);\n        vectorAB.z = 0;\n        const vectorCB = Vector3d.createStartEnd(pointC, pointB);\n        vectorCB.z = 0;\n        const unitAB = vectorAB.normalize();\n        const unitCB = vectorCB.normalize();\n        if (unitAB === undefined || unitCB === undefined)\n            return undefined;\n        const unitPerpAB = unitAB.unitPerpendicularXY();\n        const unitPerpCB = unitCB.unitPerpendicularXY();\n        const thetaABC = vectorAB.angleToXY(vectorCB);\n        const sideA = Geometry.split3WaySign(thetaABC.radians, 1, -1, -1);\n        const sideB = -sideA;\n        const radiusA = sideA * Math.abs(arcRadius);\n        const radiusB = sideB * Math.abs(arcRadius);\n        const spiralA = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, radiusA, Angle.zero(), undefined, lengthA, undefined, Transform.createIdentity());\n        const spiralB = IntegratedSpiral3d.createFrom4OutOf5(spiralType, 0, radiusB, Angle.zero(), undefined, lengthB, undefined, Transform.createIdentity());\n        const spiralEndA = spiralA.fractionToPointAndUnitTangent(1.0);\n        const spiralEndB = spiralB.fractionToPointAndUnitTangent(1.0);\n        // From the end of spiral, step away to arc center (and this is in local coordinates of each spiral)\n        const sA = spiralEndA.origin.x - radiusA * spiralEndA.direction.y;\n        const tA = spiralEndA.origin.y + radiusA * spiralEndA.direction.x;\n        const sB = spiralEndB.origin.x - radiusB * spiralEndB.direction.y;\n        const tB = spiralEndB.origin.y + radiusB * spiralEndB.direction.x;\n        // Those local coordinates are rotated to unitAB and unitBC ...\n        const vectorA = Vector3d.createAdd2Scaled(unitAB, sA, unitPerpAB, tA);\n        const vectorB = Vector3d.createAdd2Scaled(unitCB, sB, unitPerpCB, tB);\n        const uv = Vector2d.create();\n        if (SmallSystem.linearSystem2d(unitAB.x, -unitCB.x, unitAB.y, -unitCB.y, vectorB.x - vectorA.x, vectorB.y - vectorA.y, uv)) {\n            const tangencyAB = pointB.plusScaled(unitAB, uv.x);\n            const tangencyCB = pointB.plusScaled(unitCB, uv.y);\n            const frameA = Transform.createOriginAndMatrixColumns(tangencyAB, unitAB, unitPerpAB, Vector3d.unitZ());\n            const frameB = Transform.createOriginAndMatrixColumns(tangencyCB, unitCB, unitPerpCB, Vector3d.unitZ());\n            spiralA.tryTransformInPlace(frameA);\n            spiralB.tryTransformInPlace(frameB);\n            const rayA1 = spiralA.fractionToPointAndUnitTangent(1.0);\n            const rayB0 = spiralB.fractionToPointAndUnitTangent(1.0);\n            rayB0.direction.scaleInPlace(-1.0);\n            const sweep = rayA1.direction.angleToXY(rayB0.direction);\n            if (radiusA < 0)\n                sweep.setRadians(-sweep.radians);\n            const arc = CurveFactory.createArcPointTangentRadius(rayA1.origin, rayA1.direction, radiusA, undefined, sweep);\n            return [spiralA, arc, spiralB];\n        }\n        return undefined;\n    }\n    /**\n     * Return the intersection point of 3 planes.\n     * @param planeA\n     * @param planeB\n     * @param planeC\n     */\n    static planePlaneIntersectionRay(planeA, planeB) {\n        const altitudeA = planeA.altitudeXYZ(0, 0, 0);\n        const altitudeB = planeB.altitudeXYZ(0, 0, 0);\n        const normalAx = planeA.normalX();\n        const normalAy = planeA.normalY();\n        const normalAz = planeA.normalZ();\n        const normalBx = planeB.normalX();\n        const normalBy = planeB.normalY();\n        const normalBz = planeB.normalZ();\n        const normalCx = Geometry.crossProductXYXY(normalAy, normalAz, normalBy, normalBz);\n        const normalCy = Geometry.crossProductXYXY(normalAz, normalAx, normalBz, normalBx);\n        const normalCz = Geometry.crossProductXYXY(normalAx, normalAy, normalBx, normalBy);\n        const rayOrigin = SmallSystem.linearSystem3d(normalAx, normalAy, normalAz, normalBx, normalBy, normalBz, normalCx, normalCy, normalCz, -altitudeA, -altitudeB, 0.0);\n        if (rayOrigin !== undefined) {\n            return Ray3d.createXYZUVW(rayOrigin.x, rayOrigin.y, rayOrigin.z, normalCx, normalCy, normalCz);\n        }\n        return undefined;\n    }\n}\n/**\n * Starting at vectorR, move parallel to vectorV until perpendicular to planeNormal\n */\nfunction moveVectorToPlane(vectorR, vectorV, planeNormal, result) {\n    // find s such that (vectorR + s * vectorV) DOT planeNormal = 0.\n    const dotRN = vectorR.dotProduct(planeNormal);\n    const dotVN = vectorV.dotProduct(planeNormal);\n    const s = Geometry.safeDivideFraction(dotRN, dotVN, 0.0);\n    return vectorR.plusScaled(vectorV, -s, result);\n}\n//# sourceMappingURL=CurveFactory.js.map",
      "start": 1693508123585,
      "end": 1693508123732,
      "sourcemaps": null
    }
  ]
}
