{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/polyface/FacetLocationDetail.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Polyface\n */\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { TriangleLocationDetail } from \"../geometry3d/BarycentricTriangle\";\nimport { Geometry } from \"../Geometry\";\nimport { PolygonLocationDetail, PolygonOps } from \"../geometry3d/PolygonOps\";\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\n/** Options for computing and processing facet intersection methods.\n * @see PolyfaceQuery.intersectRay3d\n * @public\n */\nexport class FacetIntersectOptions {\n    /** constructor with defaults */\n    constructor() {\n        this.distanceTolerance = Geometry.smallMetricDistance;\n        this.parameterTolerance = Geometry.smallFraction;\n    }\n}\n/**\n * Implementation of `FacetLocationDetail` for a triangular facet.\n * @public\n */\nexport class TriangularFacetLocationDetail {\n    /** captures the detail if provided */\n    constructor(facetIndex = -1, detail) {\n        this._facetIndex = facetIndex;\n        this._detail = detail ? detail : TriangleLocationDetail.create();\n    }\n    /** Invalidate this detail. */\n    invalidate(deep = true) {\n        this._facetIndex = -1;\n        if (deep)\n            this._detail.invalidate();\n        this._normal = undefined;\n        this._param = undefined;\n        this._color = undefined;\n    }\n    /** Create a detail.\n     * @param result optional pre-allocated object to fill and return\n     */\n    static create(facetIndex, detail, result) {\n        if (undefined === result)\n            return new TriangularFacetLocationDetail(facetIndex, detail);\n        result.invalidate(false); // detail might be owned by result!\n        result._facetIndex = facetIndex;\n        if (undefined !== detail)\n            result._detail.copyContentsFrom(detail);\n        return result;\n    }\n    /** Get the facet index. */\n    get facetIndex() {\n        return this._facetIndex;\n    }\n    /** Get the edge count of this facet. */\n    get edgeCount() {\n        return 3;\n    }\n    /** Get the world coordinates of the point. */\n    get point() {\n        return this._detail.world;\n    }\n    /** Get the application-specific number. */\n    get a() {\n        return this._detail.a;\n    }\n    /** Get the projection of the point onto the closest facet edge. */\n    get closestEdge() {\n        return { startVertexIndex: this._detail.closestEdgeIndex, edgeParam: this._detail.closestEdgeParam };\n    }\n    /** Test validity of fields other than _detail. */\n    get _isValid() {\n        return this._facetIndex >= 0;\n    }\n    /** Whether this instance specifies a valid location. */\n    get isValid() {\n        return this._isValid && this._detail.isValid;\n    }\n    /** Whether the facet is convex. */\n    get isConvex() {\n        return true;\n    }\n    /** Whether the point is inside or on the polygon. */\n    get isInsideOrOn() {\n        return this._isValid && this._detail.isInsideOrOn;\n    }\n    /** Get the code that classifies the location of the point with respect to the facet. */\n    get classify() {\n        return this._detail.classify;\n    }\n    /** Clone the instance */\n    clone() {\n        const detail = new TriangularFacetLocationDetail();\n        detail.copyContentsFrom(this);\n        return detail;\n    }\n    /** Set the instance contents from the other detail.\n     * @param other detail to clone\n     */\n    copyContentsFrom(other) {\n        this._facetIndex = other._facetIndex;\n        this._detail.copyContentsFrom(other._detail);\n        this._normal = other._normal?.clone();\n        this._param = other._param?.clone();\n        this._color = other._color;\n    }\n    /** Get normal interpolated from facet data.\n     * @param facetNormals used to compute the normal cache\n     * @returns reference to cached normal\n     */\n    getNormal(facetNormals) {\n        if (this._detail.isValid && undefined === this._normal && undefined !== facetNormals) {\n            this._normal = Vector3d.create();\n            const scales = [this._detail.local.x, this._detail.local.y, this._detail.local.z];\n            facetNormals.linearCombination(scales, this._normal);\n        }\n        return this._normal;\n    }\n    /** Get uv parameter interpolated from facet data.\n     * @param facetParams used to compute the uv parameter cache\n     * @returns reference to cached uv parameter\n     */\n    getParam(facetParams) {\n        if (this._detail.isValid && undefined === this._param && undefined !== facetParams) {\n            this._param = Point2d.create();\n            const scales = [this._detail.local.x, this._detail.local.y, this._detail.local.z];\n            facetParams.linearCombination(scales, this._param);\n        }\n        return this._param;\n    }\n    /** Get color interpolated from facet data.\n     * * Assumes barycentric coordinates are already computed in the TriangleLocationDetail member.\n     * @param facetColors used to compute the color cache\n     * @returns cached color\n     */\n    getColor(facetColors) {\n        if (this._detail.isValid && undefined === this._color && undefined !== facetColors) {\n            const scales = [this._detail.local.x, this._detail.local.y, this._detail.local.z];\n            this._color = NumberArray.linearCombinationOfColors(facetColors, scales);\n        }\n        return this._color;\n    }\n    /** Get the barycentric coordinates of this location.\n     * @returns cached barycentric coordinates\n    */\n    getBarycentricCoordinates() {\n        return [this._detail.local.x, this._detail.local.y, this._detail.local.z];\n    }\n}\n/**\n * Implementation of `FacetLocationDetail` for a non-convex facet.\n * * Facet vertex data interpolation is not available.\n * @public\n */\nexport class NonConvexFacetLocationDetail {\n    /** captures the detail if provided */\n    constructor(facetIndex = -1, edgeCount = 0, detail) {\n        this._facetIndex = facetIndex;\n        this._edgeCount = edgeCount;\n        this._detail = detail ? detail : PolygonLocationDetail.create();\n    }\n    /** Invalidate this detail. */\n    invalidate(deep = true) {\n        this._facetIndex = -1;\n        this._edgeCount = 0;\n        if (deep)\n            this._detail.invalidate();\n    }\n    /** Create a detail.\n     * @param result optional pre-allocated object to fill and return\n     */\n    static create(facetIndex, edgeCount, detail, result) {\n        if (undefined === result)\n            return new NonConvexFacetLocationDetail(facetIndex, edgeCount, detail);\n        result.invalidate(false); // detail might be owned by result!\n        result._facetIndex = facetIndex;\n        result._edgeCount = edgeCount;\n        if (undefined !== detail && result._detail !== detail)\n            result._detail.copyContentsFrom(detail);\n        return result;\n    }\n    /** Get the facet index. */\n    get facetIndex() {\n        return this._facetIndex;\n    }\n    /** Get the edge count of this facet. */\n    get edgeCount() {\n        return this._edgeCount;\n    }\n    /** Get the world coordinates of the point. */\n    get point() {\n        return this._detail.point;\n    }\n    /** Get the application-specific number. */\n    get a() {\n        return this._detail.a;\n    }\n    /** Get the projection of the point onto the closest facet edge. */\n    get closestEdge() {\n        return { startVertexIndex: this._detail.closestEdgeIndex, edgeParam: this._detail.closestEdgeParam };\n    }\n    /** Test validity of fields other than _detail. */\n    get _isValid() {\n        return this._facetIndex >= 0 && this._edgeCount >= 3;\n    }\n    /** Whether this instance specifies a valid location. */\n    get isValid() {\n        return this._isValid && this._detail.isValid;\n    }\n    /** Whether the facet is convex. */\n    get isConvex() {\n        return false;\n    }\n    /** Whether the point is inside or on the polygon. */\n    get isInsideOrOn() {\n        return this._isValid && this._detail.isInsideOrOn;\n    }\n    /** Get the code that classifies the location of the point with respect to the facet. */\n    get classify() {\n        return this._detail.code;\n    }\n    /** Clone the instance */\n    clone() {\n        const detail = new NonConvexFacetLocationDetail();\n        detail.copyContentsFrom(this);\n        return detail;\n    }\n    /** Set the instance contents from the other detail.\n     * @param other detail to clone\n     */\n    copyContentsFrom(other) {\n        this._facetIndex = other._facetIndex;\n        this._edgeCount = other._edgeCount;\n        this._detail.copyContentsFrom(other._detail);\n    }\n    /** Interpolated data is not defined for a non-convex facet.\n     * @returns undefined\n    */\n    getNormal() {\n        return undefined;\n    }\n    /** Interpolated data is not defined for a non-convex facet.\n     * @returns undefined\n    */\n    getParam() {\n        return undefined;\n    }\n    /** Interpolated data is not defined for a non-convex facet.\n     * @returns undefined\n    */\n    getColor() {\n        return undefined;\n    }\n    /** Barycentric coordinates are not defined for a non-convex facet.\n     * @returns undefined\n     */\n    getBarycentricCoordinates() {\n        return undefined;\n    }\n}\n/**\n * Implementation of `FacetLocationDetail` for a convex facet.\n * * If `edgeCount` is 3, `TriangularFacetLocationDetail` is more efficient.\n * @public\n */\nexport class ConvexFacetLocationDetail extends NonConvexFacetLocationDetail {\n    /** captures the detail if provided */\n    constructor(facetIndex = -1, edgeCount = 0, detail) {\n        super(facetIndex, edgeCount, detail);\n    }\n    /** Invalidate this detail. */\n    invalidate(deep = true) {\n        super.invalidate(deep);\n        this._normal = undefined;\n        this._param = undefined;\n        this._color = undefined;\n        this._barycentricCoordinates = undefined;\n    }\n    /** Create a detail.\n     * @param result optional pre-allocated object to fill and return\n     */\n    static create(facetIndex, edgeCount, detail, result) {\n        if (undefined === result)\n            return new ConvexFacetLocationDetail(facetIndex, edgeCount, detail);\n        return super.create(facetIndex, edgeCount, detail, result);\n    }\n    /** Whether the facet is convex. */\n    get isConvex() {\n        return true;\n    }\n    /** Clone the instance */\n    clone() {\n        const detail = new ConvexFacetLocationDetail();\n        detail.copyContentsFrom(this);\n        return detail;\n    }\n    /** Set the instance contents from the other detail.\n     * @param other detail to clone\n     */\n    copyContentsFrom(other) {\n        super.copyContentsFrom(other);\n        this._normal = other._normal?.clone();\n        this._param = other._param?.clone();\n        this._color = other._color;\n        this._barycentricCoordinates = other._barycentricCoordinates?.slice();\n    }\n    /** Get normal interpolated from facet data.\n     * @param facetNormals used to compute the normal cache\n     * @param facetVertices used to compute the barycentric coordinate cache\n     * @param distanceTolerance used to compute the barycentric coordinate cache\n     * @returns reference to cached normal\n     */\n    getNormal(facetNormals, facetVertices, distanceTolerance = Geometry.smallMetricDistance) {\n        if (this._detail.isValid && undefined === this._normal && undefined !== facetNormals) {\n            const scales = this.getBarycentricCoordinates(facetVertices, distanceTolerance);\n            if (undefined !== scales) {\n                this._normal = Vector3d.create();\n                facetNormals.linearCombination(scales, this._normal);\n            }\n        }\n        return this._normal;\n    }\n    /** Get uv parameter interpolated from facet data.\n     * @param facetParams used to compute the uv parameter cache\n     * @param facetVertices used to compute the barycentric coordinate cache\n     * @param distanceTolerance used to compute the barycentric coordinate cache\n     * @returns reference to cached uv parameter\n     */\n    getParam(facetParams, facetVertices, distanceTolerance = Geometry.smallMetricDistance) {\n        if (this._detail.isValid && undefined === this._param && undefined !== facetParams) {\n            const scales = this.getBarycentricCoordinates(facetVertices, distanceTolerance);\n            if (undefined !== scales) {\n                this._param = Point2d.create();\n                facetParams.linearCombination(scales, this._param);\n            }\n        }\n        return this._param;\n    }\n    /** Get color interpolated from facet data.\n     * @param facetColors used to compute the color cache\n     * @param facetVertices used to compute the barycentric coordinate cache\n     * @param distanceTolerance used to compute the barycentric coordinate cache\n     * @returns cached color\n     */\n    getColor(facetColors, facetVertices, distanceTolerance = Geometry.smallMetricDistance) {\n        if (this._detail.isValid && undefined === this._color && undefined !== facetColors) {\n            const scales = this.getBarycentricCoordinates(facetVertices, distanceTolerance);\n            if (undefined !== scales)\n                this._color = NumberArray.linearCombinationOfColors(facetColors, scales);\n        }\n        return this._color;\n    }\n    /** Get the barycentric coordinates of this location, if they have been computed.\n     * @param facetVertices used to compute the barycentric coordinate cache\n     * @param distanceTolerance used to compute the barycentric coordinate cache\n     * @returns cached barycentric coordinates\n    */\n    getBarycentricCoordinates(facetVertices, distanceTolerance = Geometry.smallMetricDistance) {\n        if (this._detail.isValid && undefined === this._barycentricCoordinates && undefined !== facetVertices) {\n            this._barycentricCoordinates = PolygonOps.convexBarycentricCoordinates(facetVertices, this._detail.point, distanceTolerance);\n        }\n        return this._barycentricCoordinates;\n    }\n}\n//# sourceMappingURL=FacetLocationDetail.js.map",
      "start": 1693508123909,
      "end": 1693508124065,
      "sourcemaps": null
    }
  ]
}
