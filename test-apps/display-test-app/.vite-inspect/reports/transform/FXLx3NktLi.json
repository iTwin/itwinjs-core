{
  "resolvedId": "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/TileSizeRecorder.ts",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Id64String } from \"@itwin/core-bentley\";\r\nimport { iModelTileTreeIdToString } from \"@itwin/core-common\";\r\nimport { IModelApp, IModelTileTree, TileAdmin, Tool } from \"@itwin/core-frontend\";\r\nimport { copyStringToClipboard, parseToggle } from \"@itwin/frontend-devtools\";\r\n\r\ninterface ContentId {\r\n  modelId: Id64String;\r\n  contentId: string;\r\n}\r\n\r\nclass TileSizeRecorder {\r\n  // Outer dictionary maps unique stringified ContentIds to tile trees for which that tile's content has been loaded since recording began.\r\n  // Inner dictionary maps stringified unique tile tree Ids to the tile's content size (prior to decoding) loaded by that tree.\r\n  private readonly _records = new Map<string, Map<string, number>>();\r\n\r\n  public record(contentId: ContentId, tree: IModelTileTree, size: number): void {\r\n    const id = `${tree.iModel.key}:${contentId.modelId}:${contentId.contentId}`;\r\n    let record = this._records.get(id);\r\n    if (!record)\r\n      this._records.set(id, record = new Map<string, number>());\r\n\r\n    // Note: use the same (fake) model Id for every tree Id for grouping - the actual model Ids are in the row labels.\r\n    const treeId = iModelTileTreeIdToString(\"1\", tree.iModelTileTreeId, IModelApp.tileAdmin);\r\n    record.set(treeId, size);\r\n  }\r\n\r\n  // Produce CSV of the format:\r\n  //  <empty>,  TreeId1,TreeId2,..., TreeIdN\r\n  //  contentId1,size1, size2, ,..., sizeN\r\n  //  contentId2, ...\r\n  //  ...\r\n  //  contentIdN, ...\r\n  // If a given content Id has no size recorded for a given tree Id, the value in that row and column is output as zero.\r\n  public toCSV(): string {\r\n    const headerRow = [\"Content Id\"];\r\n    const treeIdToColumnIndex = new Map<string, number>();\r\n    for (const map of this._records.values()) {\r\n      for (const treeId of map.keys()) {\r\n        if (!treeIdToColumnIndex.has(treeId)) {\r\n          treeIdToColumnIndex.set(treeId, treeIdToColumnIndex.size + 1); // first column is for row labels\r\n          headerRow.push(treeId);\r\n        }\r\n      }\r\n    }\r\n\r\n    const rows: Array<string[]> = [headerRow];\r\n    for (const [contentId, sizes] of this._records) {\r\n      const row = [contentId];\r\n      for (const [treeId, size] of sizes)\r\n        row[treeIdToColumnIndex.get(treeId)!] = size.toString(10);\r\n\r\n      rows.push(row);\r\n    }\r\n\r\n    // ###TODO aggregate values (min,max,sum,mean; absolute delta, % delta)\r\n    return rows.map((row) => row.join(\",\")).join(\"\\n\");\r\n  }\r\n}\r\n\r\nlet recorder: TileSizeRecorder | undefined;\r\n// eslint-disable-next-line @typescript-eslint/unbound-method\r\nconst generateTileContent = TileAdmin.prototype.generateTileContent;\r\n\r\n/** A quick and dirty tool to record the sizes of tiles loaded during a recording session.\r\n * The size recorded is that of the encoded data - not of the decoded graphics.\r\n * Key-in `dta record tilesize` once to begin a recording sessions.\r\n * Key it in again to stop the session and copy the results to the clipboard in CSV format (see comments on TileSizeRecorder.toCSV for details).\r\n * This is mainly useful when you're loading the same tile content from different versions of tile tree (e.g., one with edges enabled, one without) and want to compare\r\n * how the sizes differ between them.\r\n */\r\nexport class RecordTileSizesTool extends Tool {\r\n  public static override toolId = \"RecordTileSizes\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const enable = parseToggle(args[0]);\r\n    if (typeof enable !== \"string\")\r\n      return this.run(enable);\r\n\r\n    return false;\r\n  }\r\n\r\n  public override async run(enable?: boolean): Promise<boolean> {\r\n    const currentlyEnabled = undefined !== recorder;\r\n    enable = enable ?? !currentlyEnabled;\r\n    if (enable === currentlyEnabled)\r\n      return false;\r\n\r\n    if (enable) {\r\n      recorder = new TileSizeRecorder();\r\n      IModelApp.tileAdmin.generateTileContent = async (tile: { iModelTree: IModelTileTree, contentId: string, request?: { isCanceled: boolean } }): Promise<Uint8Array> => {\r\n        const content = await generateTileContent.bind(IModelApp.tileAdmin, tile)();\r\n        recorder?.record({ contentId: tile.contentId, modelId: tile.iModelTree.modelId }, tile.iModelTree, content.byteLength);\r\n        return content;\r\n      };\r\n\r\n      return true;\r\n    }\r\n\r\n    IModelApp.tileAdmin.generateTileContent = generateTileContent.bind(IModelApp.tileAdmin);\r\n    assert(undefined !== recorder);\r\n    copyStringToClipboard(recorder.toCSV());\r\n    recorder = undefined;\r\n    return true;\r\n  }\r\n}\r\n",
      "start": 1693508121254,
      "end": 1693508121320,
      "sourcemaps": null
    },
    {
      "name": "vite:esbuild",
      "result": "\"use strict\";\nimport { assert } from \"@itwin/core-bentley\";\nimport { iModelTileTreeIdToString } from \"@itwin/core-common\";\nimport { IModelApp, TileAdmin, Tool } from \"@itwin/core-frontend\";\nimport { copyStringToClipboard, parseToggle } from \"@itwin/frontend-devtools\";\nclass TileSizeRecorder {\n  constructor() {\n    // Outer dictionary maps unique stringified ContentIds to tile trees for which that tile's content has been loaded since recording began.\n    // Inner dictionary maps stringified unique tile tree Ids to the tile's content size (prior to decoding) loaded by that tree.\n    this._records = /* @__PURE__ */ new Map();\n  }\n  record(contentId, tree, size) {\n    const id = `${tree.iModel.key}:${contentId.modelId}:${contentId.contentId}`;\n    let record = this._records.get(id);\n    if (!record)\n      this._records.set(id, record = /* @__PURE__ */ new Map());\n    const treeId = iModelTileTreeIdToString(\"1\", tree.iModelTileTreeId, IModelApp.tileAdmin);\n    record.set(treeId, size);\n  }\n  // Produce CSV of the format:\n  //  <empty>,  TreeId1,TreeId2,..., TreeIdN\n  //  contentId1,size1, size2, ,..., sizeN\n  //  contentId2, ...\n  //  ...\n  //  contentIdN, ...\n  // If a given content Id has no size recorded for a given tree Id, the value in that row and column is output as zero.\n  toCSV() {\n    const headerRow = [\"Content Id\"];\n    const treeIdToColumnIndex = /* @__PURE__ */ new Map();\n    for (const map of this._records.values()) {\n      for (const treeId of map.keys()) {\n        if (!treeIdToColumnIndex.has(treeId)) {\n          treeIdToColumnIndex.set(treeId, treeIdToColumnIndex.size + 1);\n          headerRow.push(treeId);\n        }\n      }\n    }\n    const rows = [headerRow];\n    for (const [contentId, sizes] of this._records) {\n      const row = [contentId];\n      for (const [treeId, size] of sizes)\n        row[treeIdToColumnIndex.get(treeId)] = size.toString(10);\n      rows.push(row);\n    }\n    return rows.map((row) => row.join(\",\")).join(\"\\n\");\n  }\n}\nlet recorder;\nconst generateTileContent = TileAdmin.prototype.generateTileContent;\nexport class RecordTileSizesTool extends Tool {\n  static get minArgs() {\n    return 0;\n  }\n  static get maxArgs() {\n    return 1;\n  }\n  async parseAndRun(...args) {\n    const enable = parseToggle(args[0]);\n    if (typeof enable !== \"string\")\n      return this.run(enable);\n    return false;\n  }\n  async run(enable) {\n    const currentlyEnabled = void 0 !== recorder;\n    enable = enable ?? !currentlyEnabled;\n    if (enable === currentlyEnabled)\n      return false;\n    if (enable) {\n      recorder = new TileSizeRecorder();\n      IModelApp.tileAdmin.generateTileContent = async (tile) => {\n        const content = await generateTileContent.bind(IModelApp.tileAdmin, tile)();\n        recorder?.record({ contentId: tile.contentId, modelId: tile.iModelTree.modelId }, tile.iModelTree, content.byteLength);\n        return content;\n      };\n      return true;\n    }\n    IModelApp.tileAdmin.generateTileContent = generateTileContent.bind(IModelApp.tileAdmin);\n    assert(void 0 !== recorder);\n    copyStringToClipboard(recorder.toCSV());\n    recorder = void 0;\n    return true;\n  }\n}\nRecordTileSizesTool.toolId = \"RecordTileSizes\";\n",
      "start": 1693508121320,
      "end": 1693508121469,
      "order": "normal",
      "sourcemaps": {
        "version": 3,
        "sources": [
          "D:/hub2023A/itwinjs-core/test-apps/display-test-app/src/frontend/TileSizeRecorder.ts"
        ],
        "sourcesContent": [
          "/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\r\n* See LICENSE.md in the project root for license terms and full copyright notice.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { assert, Id64String } from \"@itwin/core-bentley\";\r\nimport { iModelTileTreeIdToString } from \"@itwin/core-common\";\r\nimport { IModelApp, IModelTileTree, TileAdmin, Tool } from \"@itwin/core-frontend\";\r\nimport { copyStringToClipboard, parseToggle } from \"@itwin/frontend-devtools\";\r\n\r\ninterface ContentId {\r\n  modelId: Id64String;\r\n  contentId: string;\r\n}\r\n\r\nclass TileSizeRecorder {\r\n  // Outer dictionary maps unique stringified ContentIds to tile trees for which that tile's content has been loaded since recording began.\r\n  // Inner dictionary maps stringified unique tile tree Ids to the tile's content size (prior to decoding) loaded by that tree.\r\n  private readonly _records = new Map<string, Map<string, number>>();\r\n\r\n  public record(contentId: ContentId, tree: IModelTileTree, size: number): void {\r\n    const id = `${tree.iModel.key}:${contentId.modelId}:${contentId.contentId}`;\r\n    let record = this._records.get(id);\r\n    if (!record)\r\n      this._records.set(id, record = new Map<string, number>());\r\n\r\n    // Note: use the same (fake) model Id for every tree Id for grouping - the actual model Ids are in the row labels.\r\n    const treeId = iModelTileTreeIdToString(\"1\", tree.iModelTileTreeId, IModelApp.tileAdmin);\r\n    record.set(treeId, size);\r\n  }\r\n\r\n  // Produce CSV of the format:\r\n  //  <empty>,  TreeId1,TreeId2,..., TreeIdN\r\n  //  contentId1,size1, size2, ,..., sizeN\r\n  //  contentId2, ...\r\n  //  ...\r\n  //  contentIdN, ...\r\n  // If a given content Id has no size recorded for a given tree Id, the value in that row and column is output as zero.\r\n  public toCSV(): string {\r\n    const headerRow = [\"Content Id\"];\r\n    const treeIdToColumnIndex = new Map<string, number>();\r\n    for (const map of this._records.values()) {\r\n      for (const treeId of map.keys()) {\r\n        if (!treeIdToColumnIndex.has(treeId)) {\r\n          treeIdToColumnIndex.set(treeId, treeIdToColumnIndex.size + 1); // first column is for row labels\r\n          headerRow.push(treeId);\r\n        }\r\n      }\r\n    }\r\n\r\n    const rows: Array<string[]> = [headerRow];\r\n    for (const [contentId, sizes] of this._records) {\r\n      const row = [contentId];\r\n      for (const [treeId, size] of sizes)\r\n        row[treeIdToColumnIndex.get(treeId)!] = size.toString(10);\r\n\r\n      rows.push(row);\r\n    }\r\n\r\n    // ###TODO aggregate values (min,max,sum,mean; absolute delta, % delta)\r\n    return rows.map((row) => row.join(\",\")).join(\"\\n\");\r\n  }\r\n}\r\n\r\nlet recorder: TileSizeRecorder | undefined;\r\n// eslint-disable-next-line @typescript-eslint/unbound-method\r\nconst generateTileContent = TileAdmin.prototype.generateTileContent;\r\n\r\n/** A quick and dirty tool to record the sizes of tiles loaded during a recording session.\r\n * The size recorded is that of the encoded data - not of the decoded graphics.\r\n * Key-in `dta record tilesize` once to begin a recording sessions.\r\n * Key it in again to stop the session and copy the results to the clipboard in CSV format (see comments on TileSizeRecorder.toCSV for details).\r\n * This is mainly useful when you're loading the same tile content from different versions of tile tree (e.g., one with edges enabled, one without) and want to compare\r\n * how the sizes differ between them.\r\n */\r\nexport class RecordTileSizesTool extends Tool {\r\n  public static override toolId = \"RecordTileSizes\";\r\n  public static override get minArgs() { return 0; }\r\n  public static override get maxArgs() { return 1; }\r\n\r\n  public override async parseAndRun(...args: string[]): Promise<boolean> {\r\n    const enable = parseToggle(args[0]);\r\n    if (typeof enable !== \"string\")\r\n      return this.run(enable);\r\n\r\n    return false;\r\n  }\r\n\r\n  public override async run(enable?: boolean): Promise<boolean> {\r\n    const currentlyEnabled = undefined !== recorder;\r\n    enable = enable ?? !currentlyEnabled;\r\n    if (enable === currentlyEnabled)\r\n      return false;\r\n\r\n    if (enable) {\r\n      recorder = new TileSizeRecorder();\r\n      IModelApp.tileAdmin.generateTileContent = async (tile: { iModelTree: IModelTileTree, contentId: string, request?: { isCanceled: boolean } }): Promise<Uint8Array> => {\r\n        const content = await generateTileContent.bind(IModelApp.tileAdmin, tile)();\r\n        recorder?.record({ contentId: tile.contentId, modelId: tile.iModelTree.modelId }, tile.iModelTree, content.byteLength);\r\n        return content;\r\n      };\r\n\r\n      return true;\r\n    }\r\n\r\n    IModelApp.tileAdmin.generateTileContent = generateTileContent.bind(IModelApp.tileAdmin);\r\n    assert(undefined !== recorder);\r\n    copyStringToClipboard(recorder.toCSV());\r\n    recorder = undefined;\r\n    return true;\r\n  }\r\n}\r\n"
        ],
        "mappings": ";AAKA,SAAS,cAA0B;AACnC,SAAS,gCAAgC;AACzC,SAAS,WAA2B,WAAW,YAAY;AAC3D,SAAS,uBAAuB,mBAAmB;AAOnD,MAAM,iBAAiB;AAAA,EAAvB;AAGE;AAAA;AAAA,SAAiB,WAAW,oBAAI,IAAiC;AAAA;AAAA,EAE1D,OAAO,WAAsB,MAAsB,MAAoB;AAC5E,UAAM,KAAK,GAAG,KAAK,OAAO,GAAG,IAAI,UAAU,OAAO,IAAI,UAAU,SAAS;AACzE,QAAI,SAAS,KAAK,SAAS,IAAI,EAAE;AACjC,QAAI,CAAC;AACH,WAAK,SAAS,IAAI,IAAI,SAAS,oBAAI,IAAoB,CAAC;AAG1D,UAAM,SAAS,yBAAyB,KAAK,KAAK,kBAAkB,UAAU,SAAS;AACvF,WAAO,IAAI,QAAQ,IAAI;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,QAAgB;AACrB,UAAM,YAAY,CAAC,YAAY;AAC/B,UAAM,sBAAsB,oBAAI,IAAoB;AACpD,eAAW,OAAO,KAAK,SAAS,OAAO,GAAG;AACxC,iBAAW,UAAU,IAAI,KAAK,GAAG;AAC/B,YAAI,CAAC,oBAAoB,IAAI,MAAM,GAAG;AACpC,8BAAoB,IAAI,QAAQ,oBAAoB,OAAO,CAAC;AAC5D,oBAAU,KAAK,MAAM;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,OAAwB,CAAC,SAAS;AACxC,eAAW,CAAC,WAAW,KAAK,KAAK,KAAK,UAAU;AAC9C,YAAM,MAAM,CAAC,SAAS;AACtB,iBAAW,CAAC,QAAQ,IAAI,KAAK;AAC3B,YAAI,oBAAoB,IAAI,MAAM,CAAE,IAAI,KAAK,SAAS,EAAE;AAE1D,WAAK,KAAK,GAAG;AAAA,IACf;AAGA,WAAO,KAAK,IAAI,CAAC,QAAQ,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,IAAI;AAAA,EACnD;AACF;AAEA,IAAI;AAEJ,MAAM,sBAAsB,UAAU,UAAU;AASzC,aAAM,4BAA4B,KAAK;AAAA,EAE5C,WAA2B,UAAU;AAAE,WAAO;AAAA,EAAG;AAAA,EACjD,WAA2B,UAAU;AAAE,WAAO;AAAA,EAAG;AAAA,EAEjD,MAAsB,eAAe,MAAkC;AACrE,UAAM,SAAS,YAAY,KAAK,CAAC,CAAC;AAClC,QAAI,OAAO,WAAW;AACpB,aAAO,KAAK,IAAI,MAAM;AAExB,WAAO;AAAA,EACT;AAAA,EAEA,MAAsB,IAAI,QAAoC;AAC5D,UAAM,mBAAmB,WAAc;AACvC,aAAS,UAAU,CAAC;AACpB,QAAI,WAAW;AACb,aAAO;AAET,QAAI,QAAQ;AACV,iBAAW,IAAI,iBAAiB;AAChC,gBAAU,UAAU,sBAAsB,OAAO,SAAoH;AACnK,cAAM,UAAU,MAAM,oBAAoB,KAAK,UAAU,WAAW,IAAI,EAAE;AAC1E,kBAAU,OAAO,EAAE,WAAW,KAAK,WAAW,SAAS,KAAK,WAAW,QAAQ,GAAG,KAAK,YAAY,QAAQ,UAAU;AACrH,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAEA,cAAU,UAAU,sBAAsB,oBAAoB,KAAK,UAAU,SAAS;AACtF,WAAO,WAAc,QAAQ;AAC7B,0BAAsB,SAAS,MAAM,CAAC;AACtC,eAAW;AACX,WAAO;AAAA,EACT;AACF;AApCa,oBACY,SAAS;",
        "names": []
      }
    }
  ]
}
