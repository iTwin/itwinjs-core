{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/curve/CurveLocationDetail.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Curve\n */\nimport { Geometry } from \"../Geometry\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\n/**\n * An enumeration of special conditions being described by a CurveLocationDetail.\n * @public\n */\nexport var CurveIntervalRole;\n(function (CurveIntervalRole) {\n    /** This point is an isolated point NOT at a primary vertex. */\n    CurveIntervalRole[CurveIntervalRole[\"isolated\"] = 0] = \"isolated\";\n    /** This point is an isolated vertex hit */\n    CurveIntervalRole[CurveIntervalRole[\"isolatedAtVertex\"] = 1] = \"isolatedAtVertex\";\n    /** This is the beginning of an interval */\n    CurveIntervalRole[CurveIntervalRole[\"intervalStart\"] = 10] = \"intervalStart\";\n    /** This is an interior point of an interval. */\n    CurveIntervalRole[CurveIntervalRole[\"intervalInterior\"] = 11] = \"intervalInterior\";\n    /** This is the end of an interval */\n    CurveIntervalRole[CurveIntervalRole[\"intervalEnd\"] = 12] = \"intervalEnd\";\n})(CurveIntervalRole || (CurveIntervalRole = {}));\n/**\n * Return code for CurvePrimitive method `moveSignedDistanceFromFraction`\n * @public\n */\nexport var CurveSearchStatus;\n(function (CurveSearchStatus) {\n    /** Unimplemented or zero length curve  */\n    CurveSearchStatus[CurveSearchStatus[\"error\"] = 0] = \"error\";\n    /** Complete success of search */\n    CurveSearchStatus[CurveSearchStatus[\"success\"] = 1] = \"success\";\n    /** Search ended prematurely (e.g. at incomplete distance moved) at start or end of curve */\n    CurveSearchStatus[CurveSearchStatus[\"stoppedAtBoundary\"] = 2] = \"stoppedAtBoundary\";\n})(CurveSearchStatus || (CurveSearchStatus = {}));\n/**\n * Use to update a vector in case where source and prior result are both possibly undefined.\n * * Any undefined source returns undefined.\n * * For defined source, reuse optional result if available.\n * @param source optional source\n * @param result optional result\n */\nfunction optionalVectorUpdate(source, result) {\n    if (source) {\n        return source.clone(result);\n    }\n    return undefined;\n}\n/**\n * CurveLocationDetail carries point and parameter data about a point evaluated on a curve.\n * * These are returned by a variety of queries.\n * * Particular contents can vary among the queries.\n * @public\n */\nexport class CurveLocationDetail {\n    /** Constructor */\n    constructor() {\n        this.pointQ = Point3d.createZero();\n        this.fraction = 0;\n        this.point = Point3d.createZero();\n        this.a = 0.0;\n    }\n    /** Set the (optional) intervalRole field */\n    setIntervalRole(value) {\n        this.intervalRole = value;\n    }\n    /** Set the (optional) fraction1 and point1, using direct assignment (capture!) to point1 */\n    captureFraction1Point1(fraction1, point1) {\n        this.fraction1 = fraction1;\n        this.point1 = point1;\n    }\n    /** Test if this pair has fraction1 defined */\n    get hasFraction1() {\n        return this.fraction1 !== undefined;\n    }\n    /** Test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */\n    get isIsolated() {\n        return this.intervalRole === undefined\n            || this.intervalRole === CurveIntervalRole.isolated\n            || this.intervalRole === CurveIntervalRole.isolatedAtVertex;\n    }\n    /** Return the fraction delta. (0 if no fraction1) */\n    get fractionDelta() {\n        return this.fraction1 !== undefined ? this.fraction1 - this.fraction : 0.0;\n    }\n    /**\n     * If (fraction1, point1) are defined, make them the primary (and only) data.\n     * * No action if undefined.\n     */\n    collapseToEnd() {\n        if (this.fraction1 !== undefined) {\n            this.fraction = this.fraction1;\n            this.fraction1 = undefined;\n        }\n        if (this.point1) {\n            this.point = this.point1;\n            this.point1 = undefined;\n        }\n    }\n    /**\n     * Make (fraction, point) the primary (and only) data.\n     * * No action if undefined.\n     */\n    collapseToStart() {\n        this.fraction1 = undefined;\n        this.point1 = undefined;\n    }\n    /**\n     * Return a complete copy, WITH CAVEATS . . .\n     * * curve member is copied as a reference.\n     * * point and vector members are cloned.\n     */\n    clone(result) {\n        if (result === this)\n            return result;\n        result = result ? result : new CurveLocationDetail();\n        result.curve = this.curve;\n        result.fraction = this.fraction;\n        result.fraction1 = this.fraction1;\n        result.point1 = this.point1;\n        result.point.setFromPoint3d(this.point);\n        result.vectorInCurveLocationDetail = optionalVectorUpdate(this.vectorInCurveLocationDetail, result.vectorInCurveLocationDetail);\n        result.a = this.a;\n        result.curveSearchStatus = this.curveSearchStatus;\n        return result;\n    }\n    /**\n     * Updated in this instance.\n     * * Note that if caller omits `vector` and `a`, those fields are updated to the call-list defaults (NOT left as-is)\n     * * point and vector updates are by data copy (not capture of pointers)\n     * @param fraction (required) fraction to install\n     * @param point  (required) point to install\n     * @param vector (optional) vector to install.\n     * @param a (optional) numeric value to install.\n     */\n    setFP(fraction, point, vector, a = 0.0) {\n        this.fraction = fraction;\n        this.point.setFrom(point);\n        this.vectorInCurveLocationDetail = optionalVectorUpdate(vector, this.vectorInCurveLocationDetail);\n        this.a = a;\n    }\n    /**\n     * Updated in this instance.\n     * * Note that if caller omits a`, that field is updated to the call-list default (NOT left as-is)\n     * * point and vector updates are by data copy (not capture of the ray members)\n     * @param fraction (required) fraction to install\n     * @param ray  (required) point and vector to install\n     * @param a (optional) numeric value to install.\n     */\n    setFR(fraction, ray, a = 0) {\n        return this.setFP(fraction, ray.origin, ray.direction, a);\n    }\n    /** Set the CurvePrimitive pointer, leaving all other properties untouched. */\n    setCurve(curve) {\n        this.curve = curve;\n    }\n    /** Record the distance from the CurveLocationDetail's point to the parameter point. */\n    setDistanceTo(point) {\n        this.a = this.point.distance(point);\n    }\n    /** Create with a CurvePrimitive pointer but no coordinate data. */\n    static create(curve, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        return result;\n    }\n    /** Create a new detail using CurvePrimitive pointer, fraction, and point coordinates. */\n    static createCurveFractionPoint(curve, fraction, point, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction;\n        result.point.setFromPoint3d(point);\n        result.vectorInCurveLocationDetail = undefined;\n        result.a = 0.0;\n        result.curveSearchStatus = undefined;\n        return result;\n    }\n    /** Create a new detail with only ray, fraction, and point. */\n    static createRayFractionPoint(ray, fraction, point, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.fraction = fraction;\n        result.ray = ray;\n        result.point.setFromPoint3d(point);\n        return result;\n    }\n    /** Create with CurvePrimitive pointer, fraction, and point coordinates */\n    static createCurveFractionPointDistanceCurveSearchStatus(curve, fraction, point, distance, status, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction;\n        result.point.setFromPoint3d(point);\n        result.vectorInCurveLocationDetail = undefined;\n        result.a = distance;\n        result.curveSearchStatus = status;\n        return result;\n    }\n    /** Create with curveSearchStatus affected by allowExtension. */\n    static createConditionalMoveSignedDistance(allowExtension, curve, startFraction, endFraction, requestedSignedDistance, result) {\n        let a = requestedSignedDistance;\n        let status = CurveSearchStatus.success;\n        if (!allowExtension && !Geometry.isIn01(endFraction)) {\n            // cap the movement at the endpoint\n            if (endFraction < 0.0) {\n                a = -curve.curveLengthBetweenFractions(startFraction, 0.0);\n                endFraction = 0.0;\n                status = CurveSearchStatus.stoppedAtBoundary;\n            }\n            else if (endFraction > 1.0) {\n                endFraction = 1.0;\n                a = curve.curveLengthBetweenFractions(startFraction, 1.0);\n                status = CurveSearchStatus.stoppedAtBoundary;\n            }\n        }\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = endFraction;\n        result.point = curve.fractionToPoint(endFraction, result.point);\n        result.vectorInCurveLocationDetail = undefined;\n        result.a = a;\n        result.curveSearchStatus = status;\n        return result;\n    }\n    /** Create with CurvePrimitive pointer and fraction for evaluation. */\n    static createCurveEvaluatedFraction(curve, fraction, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction;\n        result.point = curve.fractionToPoint(fraction);\n        result.vectorInCurveLocationDetail = undefined;\n        result.curveSearchStatus = undefined;\n        result.a = 0.0;\n        return result;\n    }\n    /** Create with CurvePrimitive pointer and fraction for evaluation. */\n    static createCurveEvaluatedFractionPointAndDerivative(curve, fraction, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction;\n        const ray = curve.fractionToPointAndDerivative(fraction);\n        result.point = ray.origin;\n        result.vectorInCurveLocationDetail = ray.direction;\n        result.curveSearchStatus = undefined;\n        result.a = 0.0;\n        return result;\n    }\n    /** Create with CurvePrimitive pointer and 2 fractions for evaluation. */\n    static createCurveEvaluatedFractionFraction(curve, fraction0, fraction1, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction0;\n        result.point = curve.fractionToPoint(fraction0);\n        result.fraction1 = fraction1;\n        result.point1 = curve.fractionToPoint(fraction1);\n        result.vectorInCurveLocationDetail = undefined;\n        result.curveSearchStatus = undefined;\n        result.a = 0.0;\n        return result;\n    }\n    /** Create with CurvePrimitive pointer, fraction, and point coordinates. */\n    static createCurveFractionPointDistance(curve, fraction, point, a, result) {\n        result = result ? result : new CurveLocationDetail();\n        result.curve = curve;\n        result.fraction = fraction;\n        result.point.setFromPoint3d(point);\n        result.vectorInCurveLocationDetail = undefined;\n        result.a = a;\n        result.curveSearchStatus = undefined;\n        return result;\n    }\n    /**\n     * Update or create if closer than current contents.\n     * @param curve candidate curve\n     * @param fraction candidate fraction\n     * @param point candidate point\n     * @param a candidate distance\n     * @returns true if the given distance is smaller (and hence this detail was updated.)\n     */\n    updateIfCloserCurveFractionPointDistance(curve, fraction, point, a) {\n        if (this.a < a)\n            return false;\n        CurveLocationDetail.createCurveFractionPointDistance(curve, fraction, point, a, this);\n        return true;\n    }\n    /**\n     * Exchange the (fraction,fraction1) and (point, point1) pairs.\n     * * (Skip each swap if its \"1\" value is undefined)\n     */\n    swapFractionsAndPoints() {\n        if (this.fraction1 !== undefined) {\n            const f = this.fraction;\n            this.fraction = this.fraction1;\n            this.fraction1 = f;\n        }\n        if (this.point1 !== undefined) {\n            const p = this.point;\n            this.point = this.point1;\n            this.point1 = p;\n        }\n    }\n    /**\n     * Return the fraction where f falls between fraction and fraction1.\n     * * ASSUME fraction1 defined\n     */\n    inverseInterpolateFraction(f, defaultFraction = 0) {\n        const a = Geometry.inverseInterpolate01(this.fraction, this.fraction1, f);\n        if (a === undefined)\n            return defaultFraction;\n        return a;\n    }\n    /**\n     * Return the detail with smaller `a` value -- detailA returned if equal.\n     * @param detailA first candidate\n     * @param detailB second candidate\n     */\n    static chooseSmallerA(detailA, detailB) {\n        if (detailA) {\n            if (!detailB)\n                return detailA;\n            return detailA.a <= detailB.a ? detailA : detailB;\n        }\n        return detailB;\n    }\n}\n/**\n * Enumeration of configurations for intersections and min/max distance-between-curve\n * @public\n */\nexport var CurveCurveApproachType;\n(function (CurveCurveApproachType) {\n    /** Intersection at a single point */\n    CurveCurveApproachType[CurveCurveApproachType[\"Intersection\"] = 0] = \"Intersection\";\n    /** Distinct points on the two curves, with each curve's tangent perpendicular to the chord between the points */\n    CurveCurveApproachType[CurveCurveApproachType[\"PerpendicularChord\"] = 1] = \"PerpendicularChord\";\n    /** Completely coincident geometry */\n    CurveCurveApproachType[CurveCurveApproachType[\"CoincidentGeometry\"] = 2] = \"CoincidentGeometry\";\n    /** Completely parallel geometry. */\n    CurveCurveApproachType[CurveCurveApproachType[\"ParallelGeometry\"] = 3] = \"ParallelGeometry\";\n})(CurveCurveApproachType || (CurveCurveApproachType = {}));\n/**\n * A pair of CurveLocationDetail.\n * @public\n */\nexport class CurveLocationDetailPair {\n    constructor(detailA, detailB) {\n        this.detailA = detailA ? detailA : new CurveLocationDetail();\n        this.detailB = detailB ? detailB : new CurveLocationDetail();\n    }\n    /** Create a curve detail pair using references to two CurveLocationDetails */\n    static createCapture(detailA, detailB, result) {\n        result = result ? result : new CurveLocationDetailPair();\n        result.detailA = detailA;\n        result.detailB = detailB;\n        return result;\n    }\n    /**\n     * Create a curve detail pair using references to two CurveLocationDetails.\n     * * optionally install in reversed positions\n     */\n    static createCaptureOptionalReverse(detailA, detailB, reversed, result) {\n        result = result ? result : new CurveLocationDetailPair();\n        if (reversed) {\n            result.detailA = detailA;\n            result.detailB = detailB;\n        }\n        else {\n            result.detailA = detailA;\n            result.detailB = detailB;\n        }\n        return result;\n    }\n    /** Make a deep copy of this CurveLocationDetailPair */\n    clone(result) {\n        result = result ? result : new CurveLocationDetailPair();\n        result.detailA = this.detailA.clone();\n        result.detailB = this.detailB.clone();\n        result.approachType = this.approachType;\n        return result;\n    }\n    /** Swap the details of A, B */\n    swapDetails() {\n        const q = this.detailA;\n        this.detailA = this.detailB;\n        this.detailB = q;\n    }\n}\n/**\n * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by [[CurveCurve.intersectionXYZ]].\n * @public\n */\nexport class CurveLocationDetailArrayPair {\n    constructor() {\n        this.dataA = [];\n        this.dataB = [];\n    }\n}\n//# sourceMappingURL=CurveLocationDetail.js.map",
      "start": 1693508123574,
      "end": 1693508123727,
      "sourcemaps": null
    }
  ]
}
