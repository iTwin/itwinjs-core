{
  "resolvedId": "D:/hub2023A/itwinjs-core/extensions/map-layers-formats/lib/esm/ArcGisFeature/ArcGisJsonFeatureReader.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\nimport { PropertyValueFormat, StandardTypeNames } from \"@itwin/appui-abstract\";\nimport { ArcGisGeometryReaderJSON } from \"@itwin/core-frontend\";\nimport { ArcGisBaseFeatureReader } from \"./ArcGisFeatureReader\";\n/** @internal */\nexport class ArcGisJsonFeatureReader extends ArcGisBaseFeatureReader {\n    constructor(settings, layerMetadata) {\n        super(settings, layerMetadata);\n    }\n    applySymbologyAttributes(attrSymbology, feature) {\n        if (attrSymbology && feature) {\n            const symbolFields = attrSymbology.rendererFields;\n            if (symbolFields && symbolFields.length > 0 && feature.attributes) {\n                const featureAttr = {};\n                for (const [attrKey, attrValue] of Object.entries(feature.attributes))\n                    if (symbolFields.includes(attrKey)) {\n                        featureAttr[attrKey] = attrValue;\n                    }\n                attrSymbology.setActiveFeatureAttributes(featureAttr);\n            }\n        }\n    }\n    async readAndRender(response, renderer) {\n        const responseObj = response.data;\n        if (responseObj.geometryType) {\n            const attrSymbology = renderer.attributeSymbology;\n            const geomReader = new ArcGisGeometryReaderJSON(responseObj.geometryType, renderer, renderer.transform === undefined);\n            for (const feature of responseObj.features) {\n                if (attrSymbology) {\n                    // Read attributes if needed (attribute driven symbology)\n                    this.applySymbologyAttributes(attrSymbology, feature);\n                }\n                await geomReader.readGeometry(feature.geometry);\n            }\n        }\n    }\n    async readFeatureInfo(response, featureInfos, renderer) {\n        const responseObj = response.data;\n        if (responseObj === undefined || !Array.isArray(responseObj.features))\n            return;\n        const layerInfo = { layerName: this._settings.name };\n        // Create a signature index for every field name / type.\n        const fieldsType = {};\n        for (const fieldInfo of responseObj.fields) {\n            fieldsType[fieldInfo.name] = fieldInfo.type;\n        }\n        const getStandardTypeName = (fieldType) => {\n            switch (fieldType) {\n                case \"esriFieldTypeInteger\":\n                case \"esriFieldTypeSmallInteger\":\n                case \"esriFieldTypeOID\":\n                    return StandardTypeNames.Integer;\n                case \"esriFieldTypeDouble\":\n                    return StandardTypeNames.Double;\n                case \"esriFieldTypeSingle\":\n                    return StandardTypeNames.Float;\n                case \"esriFieldTypeDate\":\n                    return StandardTypeNames.DateTime;\n                default:\n                    return StandardTypeNames.String;\n            }\n        };\n        const getRecordInfo = (fieldName, value) => {\n            const propertyValue = { valueFormat: PropertyValueFormat.Primitive };\n            if (value === null) {\n                value = undefined;\n            }\n            const strValue = `${value}`;\n            const fieldType = fieldsType[fieldName];\n            switch (fieldType) {\n                case \"esriFieldTypeInteger\":\n                case \"esriFieldTypeSmallInteger\":\n                case \"esriFieldTypeOID\":\n                    propertyValue.value = value;\n                    break;\n                case \"esriFieldTypeDouble\":\n                case \"esriFieldTypeSingle\":\n                    propertyValue.value = this.toFixedWithoutPadding(value);\n                    break;\n                case \"esriFieldTypeDate\":\n                    propertyValue.value = new Date(value);\n                    break;\n                default:\n                    if (value !== undefined)\n                        propertyValue.value = strValue;\n                    break;\n            }\n            const typename = getStandardTypeName(fieldType);\n            propertyValue.displayValue = this.getDisplayValue(typename, propertyValue.value);\n            return { value: propertyValue, property: { name: fieldName, displayLabel: fieldName, typename } };\n        };\n        let geomReader;\n        if (renderer && responseObj?.geometryType) {\n            geomReader = new ArcGisGeometryReaderJSON(responseObj.geometryType, renderer);\n        }\n        // Each feature response represent a single sub-layer, no need to check for existing entry.\n        const subLayerInfo = {\n            subLayerName: this._layerMetadata.name,\n            displayFieldName: this._layerMetadata.name,\n            features: [],\n        };\n        // Read all features attributes / geometries\n        for (const responseFeature of responseObj.features) {\n            const feature = { attributes: [] };\n            for (const [key, value] of Object.entries(responseFeature.attributes))\n                feature.attributes?.push(getRecordInfo(key, value));\n            if (geomReader) {\n                await geomReader.readGeometry(responseFeature.geometry);\n                const graphics = renderer.moveGraphics();\n                feature.geometries = graphics.map((graphic) => {\n                    return { graphic };\n                });\n            }\n            subLayerInfo.features.push(feature);\n        }\n        if (layerInfo.subLayerInfos === undefined)\n            layerInfo.subLayerInfos = [];\n        layerInfo.subLayerInfos.push(subLayerInfo);\n        featureInfos.push(layerInfo);\n    }\n}\n//# sourceMappingURL=ArcGisJsonFeatureReader.js.map",
      "start": 1693508125120,
      "end": 1693508125196,
      "sourcemaps": null
    }
  ]
}
