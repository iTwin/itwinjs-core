{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/common/render/primitives/VertexTableSplitter.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Rendering\n */\nimport { assert, Uint32ArrayBuilder, Uint8ArrayBuilder } from \"@itwin/core-bentley\";\nimport { ColorDef } from \"@itwin/core-common\";\nimport { calculateEdgeTableParams } from \"./EdgeParams\";\nimport { computeDimensions } from \"./VertexTable\";\nimport { VertexIndices } from \"./VertexIndices\";\nimport { createSurfaceMaterial } from \"./SurfaceParams\";\n/** Builds up a [[VertexIndices]].\n * Exported strictly for tests.\n * @internal\n */\nexport class IndexBuffer {\n    constructor(initialCapacity = 3) {\n        this._index32 = new Uint32Array(1);\n        this._index8 = new Uint8Array(this._index32.buffer, 0, 3);\n        this._builder = new Uint8ArrayBuilder({ initialCapacity: initialCapacity * 3 });\n    }\n    get numIndices() {\n        assert((this._builder.length % 3) === 0);\n        return this._builder.length / 3;\n    }\n    push(index) {\n        this._index32[0] = index;\n        this._builder.append(this._index8);\n    }\n    toVertexIndices() {\n        return new VertexIndices(this._builder.toTypedArray());\n    }\n}\n/** Builds up a [[VertexTable]]. */\nclass VertexBuffer {\n    /** `source` is the original table containing the vertex data from which individual vertices will be obtained. */\n    constructor(source) {\n        this._source = source;\n        this._builder = new Uint32ArrayBuilder({ initialCapacity: 3 * source.numRgbaPerVertex });\n    }\n    /** The number of vertices currently in the table. */\n    get length() {\n        assert((this._builder.length % this.vertexSize) === 0);\n        return this._builder.length / this.vertexSize;\n    }\n    /** The number of 32-bit unsigned integers (RGBA values) per vertex. */\n    get vertexSize() {\n        return this._source.numRgbaPerVertex;\n    }\n    /** Append a vertex. `vertex` must be of size [[vertexSize]]. */\n    push(vertex) {\n        assert(vertex.length === this.vertexSize);\n        this._builder.append(vertex);\n    }\n    /** Construct the finished vertex table. */\n    buildVertexTable(maxDimension, colorTable, materialAtlasTable) {\n        const source = this._source;\n        colorTable = colorTable ?? source.uniformColor;\n        assert(undefined !== colorTable);\n        const colorTableLength = colorTable instanceof Uint32Array ? colorTable.length : 0;\n        const materialAtlasTableLength = materialAtlasTable instanceof Uint32Array ? materialAtlasTable.length : 0;\n        const dimensions = computeDimensions(this.length, this.vertexSize, colorTableLength + materialAtlasTableLength, maxDimension);\n        let rgbaData = this._builder.toTypedArray();\n        if (dimensions.width * dimensions.height > rgbaData.length) {\n            const prevData = rgbaData;\n            rgbaData = new Uint32Array(dimensions.width * dimensions.height);\n            rgbaData.set(prevData, 0);\n        }\n        let tableSize = this.vertexSize * this.length;\n        if (colorTable instanceof Uint32Array) {\n            rgbaData.set(colorTable, tableSize);\n            tableSize += colorTable.length;\n        }\n        if (materialAtlasTable instanceof Uint32Array)\n            rgbaData.set(materialAtlasTable, tableSize);\n        return {\n            data: new Uint8Array(rgbaData.buffer, rgbaData.byteOffset, rgbaData.byteLength),\n            usesUnquantizedPositions: source.usesUnquantizedPositions,\n            qparams: source.qparams,\n            width: dimensions.width,\n            height: dimensions.height,\n            hasTranslucency: source.hasTranslucency,\n            uniformColor: colorTable instanceof ColorDef ? colorTable : undefined,\n            featureIndexType: source.featureIndexType,\n            uniformFeatureID: source.uniformFeatureID,\n            numVertices: this.length,\n            numRgbaPerVertex: source.numRgbaPerVertex,\n            uvParams: source.uvParams,\n        };\n    }\n}\n/** Remaps portions of a source color table into a filtered target color table. */\nclass ColorTableRemapper {\n    constructor(colorTable) {\n        this._remappedIndices = new Map();\n        this.colors = [];\n        this._32 = new Uint32Array(1);\n        this._16 = new Uint16Array(this._32.buffer);\n        this._colorTable = colorTable;\n    }\n    /** Extract the color index stored in `vertex`, ensure it is present in the remapped color table, and return its index in that table. */\n    remap(vertex, usesUnquantizedPositions) {\n        const vertIndex = usesUnquantizedPositions ? 4 : 1;\n        const shortIndex = usesUnquantizedPositions ? 0 : 1;\n        this._32[0] = vertex[vertIndex];\n        const oldIndex = this._16[shortIndex];\n        let newIndex = this._remappedIndices.get(oldIndex);\n        if (undefined === newIndex) {\n            newIndex = this.colors.length;\n            this._remappedIndices.set(oldIndex, newIndex);\n            const color = this._colorTable[oldIndex];\n            this.colors.push(color);\n        }\n        this._16[shortIndex] = newIndex;\n        vertex[vertIndex] = this._32[0];\n    }\n    /** Construct the finished color table. */\n    buildColorTable() {\n        assert(this.colors.length > 0);\n        return this.colors.length > 1 ? new Uint32Array(this.colors) : ColorDef.fromAbgr(this.colors[0]);\n    }\n}\nclass MaterialAtlasRemapper {\n    constructor(_atlasTable, createMaterial) {\n        this._remappedIndices = new Map();\n        this.materials = [];\n        this._32 = new Uint32Array(1);\n        this._8 = new Uint8Array(this._32.buffer);\n        this._atlasTable = _atlasTable;\n        this._createMaterial = createMaterial;\n    }\n    /** Extract the mat index stored in `vertex`, ensure it is present in the remapped atlas table, and return its index in that table. */\n    remap(vertex, usesUnquantizedPositions) {\n        const vertIndex = usesUnquantizedPositions ? 3 : 2;\n        this._32[0] = vertex[vertIndex];\n        const oldIndex = this._8[3];\n        let newIndex = this._remappedIndices.get(oldIndex);\n        if (undefined === newIndex) {\n            newIndex = this.materials.length / 4;\n            this._remappedIndices.set(oldIndex, newIndex);\n            let index = oldIndex * 4;\n            this.materials.push(this._atlasTable[index++]);\n            this.materials.push(this._atlasTable[index++]);\n            this.materials.push(this._atlasTable[index++]);\n            this.materials.push(this._atlasTable[index]);\n        }\n        this._8[3] = newIndex;\n        vertex[vertIndex] = this._32[0];\n    }\n    unpackFloat(value) {\n        this._32[0] = value;\n        const valUint32 = this._32[0];\n        const bias = 38.0;\n        const temp = (valUint32 >>> 24) / 2.0;\n        let exponent = Math.floor(temp);\n        let sign = (temp - exponent) * 2.0;\n        sign = -(sign * 2.0 - 1.0);\n        const base = sign * (valUint32 & 0xffffff) / 16777216.0;\n        exponent = exponent - bias;\n        return base * Math.pow(10.0, exponent);\n    }\n    materialFromAtlasEntry(entry) {\n        const rgbOverridden = (entry[1] & 0x1000000) !== 0;\n        const alphaOverridden = (entry[1] & 0x2000000) !== 0;\n        const args = {\n            alpha: alphaOverridden ? (entry[0] >>> 24) / 255.0 : undefined,\n            diffuse: {\n                color: rgbOverridden ? ColorDef.fromTbgr(entry[0] & 0xffffff) : undefined,\n                weight: (entry[1] >>> 8) / 255.0,\n            },\n            specular: {\n                color: ColorDef.fromTbgr(entry[2]),\n                weight: ((entry[1] >>> 16) & 0xff) / 255.0,\n                exponent: this.unpackFloat(entry[3]),\n            },\n        };\n        const material = this._createMaterial(args);\n        return createSurfaceMaterial(material);\n    }\n    /** Construct the finished color table. */\n    buildAtlasTable() {\n        assert(this.materials.length > 0);\n        const m = new Uint32Array(this.materials);\n        return this.materials.length > 4 ? m : this.materialFromAtlasEntry(m);\n    }\n}\n/** A node in a split vertex table. Each node corresponds to one or more elements. */\nclass Node {\n    /** `vertexTable` is the source table containing vertex data for all nodes, from which this node will extract the vertices belong to it. */\n    constructor(vertexTable, atlas) {\n        this.remappedIndices = new Map();\n        this.indices = new IndexBuffer();\n        this.vertices = new VertexBuffer(vertexTable);\n        if (undefined === vertexTable.uniformColor)\n            this.colors = new ColorTableRemapper(new Uint32Array(vertexTable.data.buffer, vertexTable.data.byteOffset + 4 * vertexTable.numVertices * vertexTable.numRgbaPerVertex));\n        if (atlas) {\n            const atlasOffset = (vertexTable.numVertices * vertexTable.numRgbaPerVertex + atlas.offset) * 4;\n            this.atlas = new MaterialAtlasRemapper(new Uint32Array(vertexTable.data.buffer, vertexTable.data.byteOffset + atlasOffset), atlas.createMaterial);\n        }\n        this.usesUnquantizedPositions = vertexTable.usesUnquantizedPositions;\n    }\n    addVertex(originalIndex, vertex) {\n        let newIndex = this.remappedIndices.get(originalIndex);\n        if (undefined === newIndex) {\n            newIndex = this.vertices.length;\n            this.remappedIndices.set(originalIndex, newIndex);\n            this.colors?.remap(vertex, this.usesUnquantizedPositions);\n            this.atlas?.remap(vertex, this.usesUnquantizedPositions);\n            this.vertices.push(vertex);\n        }\n        this.indices.push(newIndex);\n    }\n    buildOutput(maxDimension) {\n        const materialAtlas = this.atlas?.buildAtlasTable();\n        const material = (materialAtlas instanceof Uint32Array) ? undefined : materialAtlas;\n        return {\n            indices: this.indices.toVertexIndices(),\n            vertices: this.vertices.buildVertexTable(maxDimension, this.colors?.buildColorTable(), materialAtlas),\n            material,\n        };\n    }\n}\nclass VertexTableSplitter {\n    constructor(input, computeNodeId) {\n        this._nodes = new Map();\n        this._input = input;\n        this._computeNodeId = computeNodeId;\n    }\n    /** Split the source into one or more output nodes, returning a mapping of integer node Id to node. */\n    static split(source, computeNodeId) {\n        const splitter = new VertexTableSplitter(source, computeNodeId);\n        splitter.split();\n        return splitter._nodes;\n    }\n    split() {\n        // Track the most recent feature and corresponding node to avoid repeated lookups - vertices for\n        // individual features are largely contiguous.\n        const curState = {\n            featureIndex: -1,\n            node: undefined,\n        };\n        const vertSize = this._input.vertices.numRgbaPerVertex;\n        const vertex = new Uint32Array(vertSize);\n        const vertexTable = new Uint32Array(this._input.vertices.data.buffer, this._input.vertices.data.byteOffset, this._input.vertices.numVertices * vertSize);\n        for (const index of this._input.indices) {\n            // Extract the data for this vertex without allocating new typed arrays.\n            const vertexOffset = index * vertSize;\n            for (let i = 0; i < vertex.length; i++)\n                vertex[i] = vertexTable[vertexOffset + i];\n            // Determine to which element the vertex belongs and find the corresponding Node.\n            const featureIndex = vertex[2] & 0x00ffffff;\n            if (curState.featureIndex !== featureIndex) {\n                curState.featureIndex = featureIndex;\n                const nodeId = this._computeNodeId(featureIndex);\n                let node = this._nodes.get(nodeId);\n                if (undefined === node)\n                    this._nodes.set(nodeId, node = new Node(this._input.vertices, this._input.atlasInfo));\n                curState.node = node;\n            }\n            // Add the vertex to the appropriate node.\n            curState.node.addVertex(index, vertex);\n        }\n    }\n}\n/** Given a PointStringParams and a function that can associate a node Id with an element Id, produce a mapping of nodes to PointStringParams, splitting up\n * the input params as needed.\n * @internal\n */\nexport function splitPointStringParams(args) {\n    const nodes = VertexTableSplitter.split({\n        indices: args.params.indices,\n        vertices: args.params.vertices,\n        featureTable: args.featureTable,\n    }, args.computeNodeId);\n    const result = new Map();\n    for (const [id, node] of nodes) {\n        const { vertices, indices } = node.buildOutput(args.maxDimension);\n        result.set(id, { vertices, indices, weight: args.params.weight });\n    }\n    return result;\n}\nclass RemappedPolylineEdges {\n    constructor() {\n        this.indices = new IndexBuffer();\n        this.prevIndices = new IndexBuffer();\n        this.nextIndicesAndParams = new Uint32ArrayBuilder();\n    }\n}\nfunction remapIndex(out, srcIndex, nodes) {\n    for (const [id, node] of nodes) {\n        const index = node.remappedIndices.get(srcIndex);\n        if (undefined !== index) {\n            out.index = index;\n            out.node = node;\n            out.id = id;\n            return true;\n        }\n    }\n    assert(false);\n    return false;\n}\nfunction remapSegmentEdges(type, source, nodes, edges) {\n    const src = source[type];\n    if (!src)\n        return;\n    const srcEndPts = new Uint32Array(src.endPointAndQuadIndices.buffer, src.endPointAndQuadIndices.byteOffset, src.endPointAndQuadIndices.length / 4);\n    let srcNormalPairs;\n    if (type === \"silhouettes\") {\n        assert(undefined !== source.silhouettes);\n        srcNormalPairs = new Uint32Array(source.silhouettes.normalPairs.buffer, source.silhouettes.normalPairs.byteOffset, source.silhouettes.normalPairs.length / 4);\n    }\n    let curIndexIndex = 0;\n    const remappedIndex = {};\n    for (const srcIndex of src.indices) {\n        if (remapIndex(remappedIndex, srcIndex, nodes)) {\n            let endPointAndQuad = srcEndPts[curIndexIndex];\n            const otherIndex = (endPointAndQuad & 0x00ffffff) >>> 0;\n            const newOtherIndex = remappedIndex.node.remappedIndices.get(otherIndex);\n            assert(undefined !== newOtherIndex);\n            endPointAndQuad = (endPointAndQuad & 0xff000000) | newOtherIndex;\n            let entry = edges.get(remappedIndex.id);\n            if (!entry)\n                edges.set(remappedIndex.id, entry = {});\n            if (srcNormalPairs) {\n                if (!entry.silhouettes)\n                    entry.silhouettes = { indices: new IndexBuffer(), endPointAndQuadIndices: new Uint32ArrayBuilder(), normalPairs: new Uint32ArrayBuilder() };\n                entry.silhouettes.normalPairs.push(srcNormalPairs[curIndexIndex]);\n            }\n            else if (!entry.segments) {\n                entry.segments = { indices: new IndexBuffer(), endPointAndQuadIndices: new Uint32ArrayBuilder() };\n            }\n            const segments = entry[type];\n            assert(undefined !== segments);\n            segments.indices.push(remappedIndex.index);\n            segments.endPointAndQuadIndices.push(endPointAndQuad);\n        }\n        ++curIndexIndex;\n    }\n}\nfunction remapPolylineEdges(src, nodes, edges) {\n    const srcNextAndParam = new Uint32Array(src.nextIndicesAndParams.buffer, src.nextIndicesAndParams.byteOffset, src.nextIndicesAndParams.length / 4);\n    const prevIter = src.prevIndices[Symbol.iterator]();\n    let curIndexIndex = 0;\n    const remappedIndex = {};\n    for (const srcIndex of src.indices) {\n        if (remapIndex(remappedIndex, srcIndex, nodes)) {\n            const prevIndex = prevIter.next().value;\n            assert(undefined !== prevIndex);\n            const newPrevIndex = remappedIndex.node.remappedIndices.get(prevIndex);\n            assert(undefined !== newPrevIndex);\n            let nextAndParam = srcNextAndParam[curIndexIndex];\n            const nextIndex = (nextAndParam & 0x00ffffff) >>> 0;\n            const newNextIndex = remappedIndex.node.remappedIndices.get(nextIndex);\n            assert(undefined !== newNextIndex);\n            nextAndParam = (nextAndParam & 0xff000000) | newNextIndex;\n            let entry = edges.get(remappedIndex.id);\n            if (!entry)\n                edges.set(remappedIndex.id, entry = {});\n            if (!entry.polylines)\n                entry.polylines = new RemappedPolylineEdges();\n            entry.polylines.indices.push(remappedIndex.index);\n            entry.polylines.prevIndices.push(newPrevIndex);\n            entry.polylines.nextIndicesAndParams.push(nextAndParam);\n        }\n        ++curIndexIndex;\n    }\n}\nfunction remapIndexedEdges(src, nodes, edges) {\n    const srcEdgeData = src.edges.data;\n    const numSegments = src.edges.numSegments;\n    const silhouetteStartByteIndex = numSegments * 6 + src.edges.silhouettePadding;\n    function getUint24EdgePair(byteIndex) {\n        return [srcEdgeData[byteIndex + 0] | (srcEdgeData[byteIndex + 1] << 8) | srcEdgeData[byteIndex + 2] << 16,\n            srcEdgeData[byteIndex + 3] | (srcEdgeData[byteIndex + 4] << 8) | srcEdgeData[byteIndex + 5] << 16];\n    }\n    function setUint24EdgePair(indEdges, value1, value2) {\n        indEdges.edges.push(value1 & 0x0000ff);\n        indEdges.edges.push((value1 & 0x00ff00) >>> 8);\n        indEdges.edges.push((value1 & 0xff0000) >>> 16);\n        indEdges.edges.push(value2 & 0x0000ff);\n        indEdges.edges.push((value2 & 0x00ff00) >>> 8);\n        indEdges.edges.push((value2 & 0xff0000) >>> 16);\n    }\n    function getUint24SilPair(byteIndex) {\n        return [srcEdgeData[byteIndex + 0] | (srcEdgeData[byteIndex + 1] << 8) | srcEdgeData[byteIndex + 2] << 16,\n            srcEdgeData[byteIndex + 3] | (srcEdgeData[byteIndex + 4] << 8) | srcEdgeData[byteIndex + 5] << 16,\n            srcEdgeData[byteIndex + 6] | (srcEdgeData[byteIndex + 7] << 8), srcEdgeData[byteIndex + 8] | (srcEdgeData[byteIndex + 9] << 8)];\n    }\n    function setUint24SilPair(indSil, value1, value2, norm1, norm2) {\n        indSil.silhouettes.push(value1 & 0x0000ff);\n        indSil.silhouettes.push((value1 & 0x00ff00) >>> 8);\n        indSil.silhouettes.push((value1 & 0xff0000) >>> 16);\n        indSil.silhouettes.push(value2 & 0x0000ff);\n        indSil.silhouettes.push((value2 & 0x00ff00) >>> 8);\n        indSil.silhouettes.push((value2 & 0xff0000) >>> 16);\n        indSil.silhouettes.push(norm1 & 0x0000ff);\n        indSil.silhouettes.push((norm1 & 0x00ff00) >>> 8);\n        indSil.silhouettes.push(norm2 & 0x0000ff);\n        indSil.silhouettes.push((norm2 & 0x00ff00) >>> 8);\n    }\n    let maxIndex = 0;\n    for (const srcIndex of src.indices)\n        maxIndex = Math.max(srcIndex, maxIndex);\n    const remappedIndex = {};\n    let es1Index = 0, es2Index = 0, n1 = 0, n2 = 0;\n    for (let curSegment = 0, byteIndex = 0; curSegment <= maxIndex; ++curSegment) {\n        if (curSegment < numSegments) { // edges\n            [es1Index, es2Index] = getUint24EdgePair(byteIndex);\n            byteIndex += 6;\n        }\n        else { // silhouettes\n            byteIndex = silhouetteStartByteIndex + (curSegment - numSegments) * 10;\n            [es1Index, es2Index, n1, n2] = getUint24SilPair(byteIndex);\n        }\n        if (remapIndex(remappedIndex, es1Index, nodes)) {\n            let entry = edges.get(remappedIndex.id);\n            if (!entry)\n                edges.set(remappedIndex.id, entry = {});\n            if (!entry.indexed)\n                entry.indexed = { edges: new Uint8ArrayBuilder(), silhouettes: new Uint8ArrayBuilder() };\n            if (curSegment < numSegments) { // edges\n                const newE1Index = remappedIndex.node.remappedIndices.get(es1Index);\n                assert(undefined !== newE1Index);\n                const newE2Index = remappedIndex.node.remappedIndices.get(es2Index);\n                assert(undefined !== newE2Index);\n                setUint24EdgePair(entry.indexed, newE1Index, newE2Index);\n            }\n            else { // silhouettes\n                const newS1Index = remappedIndex.node.remappedIndices.get(es1Index);\n                assert(undefined !== newS1Index);\n                const newS2Index = remappedIndex.node.remappedIndices.get(es2Index);\n                assert(undefined !== newS2Index);\n                setUint24SilPair(entry.indexed, newS1Index, newS2Index, n1, n2);\n            }\n        }\n    }\n}\nfunction splitEdges(source, nodes, maxDimension) {\n    const edges = new Map();\n    remapSegmentEdges(\"segments\", source, nodes, edges);\n    remapSegmentEdges(\"silhouettes\", source, nodes, edges);\n    if (source.polylines)\n        remapPolylineEdges(source.polylines, nodes, edges);\n    if (source.indexed)\n        remapIndexedEdges(source.indexed, nodes, edges);\n    const result = new Map();\n    for (const [id, remappedEdges] of edges) {\n        if (!remappedEdges.segments && !remappedEdges.silhouettes && !remappedEdges.indexed)\n            continue;\n        let edgeTable = {};\n        let edgeIndices = {};\n        if (remappedEdges.indexed) {\n            const numSegmentEdges = remappedEdges.indexed.edges.length / 6;\n            const numSilhouettes = remappedEdges.indexed.silhouettes.length / 10;\n            const { width, height, silhouettePadding, silhouetteStartByteIndex } = calculateEdgeTableParams(numSegmentEdges, numSilhouettes, maxDimension);\n            const data = new Uint8Array(width * height * 4);\n            data.set(remappedEdges.indexed.edges.toTypedArray(), 0);\n            if (numSilhouettes > 0)\n                data.set(remappedEdges.indexed.silhouettes.toTypedArray(), silhouetteStartByteIndex + silhouettePadding);\n            const numTotalEdges = numSegmentEdges + numSilhouettes;\n            edgeIndices = new VertexIndices(new Uint8Array(numTotalEdges * 6 * 3));\n            for (let i = 0; i < numTotalEdges; i++)\n                for (let j = 0; j < 6; j++)\n                    edgeIndices.setNthIndex(i * 6 + j, i);\n            edgeTable = {\n                data,\n                width,\n                height,\n                numSegments: numSegmentEdges,\n                silhouettePadding,\n            };\n        }\n        result.set(id, {\n            weight: source.weight,\n            linePixels: source.linePixels,\n            segments: remappedEdges.segments ? {\n                indices: remappedEdges.segments.indices.toVertexIndices(),\n                endPointAndQuadIndices: remappedEdges.segments.endPointAndQuadIndices.toUint8Array(),\n            } : undefined,\n            silhouettes: remappedEdges.silhouettes ? {\n                indices: remappedEdges.silhouettes.indices.toVertexIndices(),\n                endPointAndQuadIndices: remappedEdges.silhouettes.endPointAndQuadIndices.toUint8Array(),\n                normalPairs: remappedEdges.silhouettes.normalPairs.toUint8Array(),\n            } : undefined,\n            polylines: remappedEdges.polylines ? {\n                indices: remappedEdges.polylines.indices.toVertexIndices(),\n                prevIndices: remappedEdges.polylines.prevIndices.toVertexIndices(),\n                nextIndicesAndParams: remappedEdges.polylines.nextIndicesAndParams.toUint8Array(),\n            } : undefined,\n            indexed: remappedEdges.indexed ? {\n                indices: edgeIndices,\n                edges: edgeTable,\n            } : undefined,\n        });\n    }\n    return result;\n}\n/** @internal */\nexport function splitMeshParams(args) {\n    const result = new Map();\n    const mat = args.params.surface.material;\n    const atlasOffset = undefined !== mat && mat.isAtlas ? mat.vertexTableOffset : undefined;\n    const atlasInfo = atlasOffset ? { offset: atlasOffset, createMaterial: args.createMaterial } : undefined;\n    const nodes = VertexTableSplitter.split({\n        indices: args.params.surface.indices,\n        vertices: args.params.vertices,\n        featureTable: args.featureTable,\n        atlasInfo,\n    }, args.computeNodeId);\n    const edges = args.params.edges ? splitEdges(args.params.edges, nodes, args.maxDimension) : undefined;\n    for (const [id, node] of nodes) {\n        const { vertices, indices, material } = node.buildOutput(args.maxDimension);\n        const params = {\n            vertices,\n            surface: {\n                type: args.params.surface.type,\n                indices,\n                fillFlags: args.params.surface.fillFlags,\n                hasBakedLighting: args.params.surface.hasBakedLighting,\n                textureMapping: args.params.surface.textureMapping,\n                material: material !== undefined ? material : args.params.surface.material,\n            },\n            edges: edges?.get(id),\n            isPlanar: args.params.isPlanar,\n            // ###TODO handle aux channels.......\n            auxChannels: args.params.auxChannels,\n        };\n        result.set(id, params);\n    }\n    return result;\n}\n/** @internal */\nexport function splitPolylineParams(args) {\n    const nodes = VertexTableSplitter.split({\n        indices: args.params.polyline.indices,\n        vertices: args.params.vertices,\n        featureTable: args.featureTable,\n    }, args.computeNodeId);\n    const src = args.params.polyline;\n    const srcNextAndParam = new Uint32Array(src.nextIndicesAndParams.buffer, src.nextIndicesAndParams.byteOffset, src.nextIndicesAndParams.length / 4);\n    let curIndexIndex = 0;\n    const remappedIndex = {};\n    for (const prevIndex of src.prevIndices) {\n        if (remapIndex(remappedIndex, prevIndex, nodes)) {\n            const node = remappedIndex.node;\n            if (!node.prevIndices) {\n                assert(undefined === node.nextIndicesAndParams);\n                node.prevIndices = new IndexBuffer(node.indices.numIndices);\n                node.nextIndicesAndParams = new Uint32ArrayBuilder({ initialCapacity: node.indices.numIndices });\n            }\n            else {\n                assert(undefined !== node.nextIndicesAndParams);\n            }\n            node.prevIndices.push(remappedIndex.index);\n            let nextAndParam = srcNextAndParam[curIndexIndex];\n            const nextIndex = (nextAndParam & 0x00ffffff) >>> 0;\n            const newNextIndex = remappedIndex.node.remappedIndices.get(nextIndex);\n            assert(undefined !== newNextIndex);\n            nextAndParam = (nextAndParam & 0xff000000) | newNextIndex;\n            node.nextIndicesAndParams.push(nextAndParam);\n        }\n        ++curIndexIndex;\n    }\n    const result = new Map();\n    for (const [id, node] of nodes) {\n        assert(undefined !== node.prevIndices && undefined !== node.nextIndicesAndParams);\n        const { vertices, indices } = node.buildOutput(args.maxDimension);\n        const params = {\n            ...args.params,\n            vertices,\n            polyline: {\n                indices,\n                prevIndices: node.prevIndices.toVertexIndices(),\n                nextIndicesAndParams: node.nextIndicesAndParams.toUint8Array(),\n            },\n        };\n        result.set(id, params);\n    }\n    return result;\n}\n//# sourceMappingURL=VertexTableSplitter.js.map",
      "start": 1693508119095,
      "end": 1693508119294,
      "sourcemaps": null
    }
  ]
}
