{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/frontend/lib/esm/tools/EditManipulator.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module Tools\n */\nimport { AxisOrder, Matrix3d, Point3d, Transform } from \"@itwin/core-geometry\";\nimport { AccuDrawHintBuilder } from \"../AccuDraw\";\nimport { IModelApp } from \"../IModelApp\";\nimport { BeButton, CoordinateLockOverrides, EventHandled, InputCollector, InputSource } from \"./Tool\";\nimport { ManipulatorToolEvent } from \"./ToolAdmin\";\n/** Classes and methods to create on screen control handles for interactive modification of element(s) and pickable decorations.\n * The basic flow is:\n * - Create a sub-class of [[EditManipulator.HandleProvider]] to listen for start of [[SelectTool]] or any other PrimitiveTool that supports handle providers.\n * - Respond to [[ManipulatorToolEvent.Start]] by adding a listener for [[SelectionSet]] change event.\n * - Respond to selection changed event to create control handles as pickable decorations when the desired element(s) or pickable decoration is selected.\n * - Respond to button events on the control handle decoration and run a sub-class of [[EditManipulator.HandleTool]] to modify.\n * @public\n * @extensions\n*/\nexport var EditManipulator;\n(function (EditManipulator) {\n    /** Specifies the event for [[EditManipulator.HandleProvider.onManipulatorEvent]] */\n    let EventType;\n    (function (EventType) {\n        /** Control handles should be created, updated, or cleared based on the active selection. */\n        EventType[EventType[\"Synch\"] = 0] = \"Synch\";\n        /** Control handle modification was cancelled by user. */\n        EventType[EventType[\"Cancel\"] = 1] = \"Cancel\";\n        /** Control handle modification was accepted by user. */\n        EventType[EventType[\"Accept\"] = 2] = \"Accept\";\n    })(EventType = EditManipulator.EventType || (EditManipulator.EventType = {}));\n    /** Interactive control handle modification is done by installing an [[InputCollector]].\n     * Modification typically is started from a click or press and drag while over the handle graphics.\n     * The HandleTool base class is set up to define an offset by 2 points. The second point is\n     * defined by either another click, or up event when initiated from press and drag.\n     * @see [[EditManipulator.HandleProvider]]\n     */\n    class HandleTool extends InputCollector {\n        constructor(manipulator) {\n            super();\n            this.manipulator = manipulator;\n        }\n        /** Establish the initial tool state for handle modification.\n         * Default implementation honors the active locks and enables AccuSnap; behavior suitable for a shape vertex handle.\n         * @note An InputCollector inherits the tool state of the suspended primitive tool.\n         */\n        init() {\n            // Set this.receivedDownEvent to still get up events sent to this tool instance when installed from another tool's down event (ex. onModelStartDrag).\n            this.receivedDownEvent = true;\n            // Override inherited tool state from suspended primitive tool.\n            IModelApp.accuSnap.onStartTool();\n            if (this.wantAccuSnap)\n                this.initLocateElements(false, true, undefined, CoordinateLockOverrides.None);\n            else\n                this.initLocateElements(false, false, undefined, CoordinateLockOverrides.All);\n        }\n        /** Whether to call [[AccuSnap.enableSnap]] for handle modification.\n         * @return true to enable snapping to elements.\n         */\n        get wantAccuSnap() { return true; }\n        /** Called from reset button up event to allow modification to be cancelled.\n         * @return true to cancel modification.\n         */\n        cancel(_ev) { return true; }\n        /** Called following cancel or accept to update the handle provider\n         * and return control to suspended PrimitiveTool.\n         */\n        async onComplete(_ev, event) {\n            await this.exitTool();\n            this.manipulator.onManipulatorEvent(event);\n            return EventHandled.Yes;\n        }\n        async onDataButtonDown(ev) {\n            if (!this.accept(ev))\n                return EventHandled.No;\n            return this.onComplete(ev, EventType.Accept);\n        }\n        async onResetButtonUp(ev) {\n            if (!this.cancel(ev))\n                return EventHandled.No;\n            return this.onComplete(ev, EventType.Cancel);\n        }\n        async onTouchMove(ev) { return IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }\n        async onTouchComplete(ev) { return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }\n        async onTouchCancel(ev) { return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset); }\n        async onPostInstall() {\n            await super.onPostInstall();\n            this.init();\n        }\n    }\n    HandleTool.toolId = \"Select.Manipulator\"; // Doesn't matter, not included in tool registry...\n    HandleTool.hidden = true;\n    EditManipulator.HandleTool = HandleTool;\n    /** A handle provider maintains a set of controls used to modify element(s) or pickable decorations.\n     * The provider works in conjunction with any PrimitiveTool that raises events for [[ToolAdmin.manipulatorToolEvent]].\n     * @see [[SelectTool]] The default PrimitiveTool that supports handle providers.\n     */\n    class HandleProvider {\n        /** Create a new handle provider to listen for [[ToolAdmin.manipulatorToolEvent]].\n         * Usually followed by a call to [[IModelApp.toolAdmin.startDefaultTool]] to immediately raise the [[ManipulatorToolEvent.Start]] event.\n         */\n        constructor(iModel) {\n            this.iModel = iModel;\n            this._isActive = false;\n            this._removeManipulatorToolListener = IModelApp.toolAdmin.manipulatorToolEvent.addListener((tool, event) => this.onManipulatorToolEvent(tool, event));\n        }\n        /** Call to clear this handle provider. */\n        stop() {\n            if (this._removeSelectionListener) {\n                this._removeSelectionListener();\n                this._removeSelectionListener = undefined;\n            }\n            if (this._removeManipulatorToolListener) {\n                this._removeManipulatorToolListener();\n                this._removeManipulatorToolListener = undefined;\n            }\n            this.clearControls();\n        }\n        /** Event raised by a PrimitiveTool that supports handle providers.\n         * Add listener for [[IModelConnection.selectionSet.onChanged]] on start event and remove on stop event.\n         * Control handles can be created from the active selection set, which may include persistent elements and pickable decorations.\n         * @see [[SelectionSet]]\n         */\n        onManipulatorToolEvent(_tool, event) {\n            switch (event) {\n                case ManipulatorToolEvent.Start: {\n                    if (this._removeSelectionListener)\n                        break;\n                    this._removeSelectionListener = this.iModel.selectionSet.onChanged.addListener((ev) => this.onSelectionChanged(ev));\n                    if (this.iModel.selectionSet.isActive)\n                        this.onManipulatorEvent(EventType.Synch); // Give opportunity to add controls when tool is started with an existing selection...\n                    break;\n                }\n                case ManipulatorToolEvent.Stop: {\n                    if (!this._removeSelectionListener)\n                        break;\n                    this._removeSelectionListener();\n                    this._removeSelectionListener = undefined;\n                    this.clearControls();\n                }\n            }\n        }\n        /** Event raised by [[SelectionSet]] when the active selection changes.\n         * Calls onManipulatorEvent to let the provider create, update, or clear it's set of controls as appropriate.\n         * @see [[SelectionSet]]\n         */\n        onSelectionChanged(ev) {\n            if (this.iModel === ev.set.iModel)\n                this.onManipulatorEvent(EventType.Synch);\n        }\n        /** Register for decorate event to start displaying control handles. */\n        updateDecorationListener(add) {\n            if (this._removeDecorationListener) {\n                if (!add) {\n                    this._removeDecorationListener();\n                    this._removeDecorationListener = undefined;\n                }\n                IModelApp.viewManager.invalidateDecorationsAllViews();\n            }\n            else if (add) {\n                if (!this._removeDecorationListener)\n                    this._removeDecorationListener = IModelApp.viewManager.addDecorator(this);\n                IModelApp.viewManager.invalidateDecorationsAllViews();\n            }\n        }\n        /** Sub-classes should override to display the pickable graphics for their controls. */\n        decorate(_context) { }\n        /* Call to stop displaying the the control handles */\n        clearControls() {\n            this.updateDecorationListener(this._isActive = false);\n        }\n        /* Create, update, or clear based on the current selection. */\n        async updateControls() {\n            const created = await this.createControls();\n            if (this._isActive && !created)\n                this.clearControls();\n            else\n                this.updateDecorationListener(this._isActive = created);\n        }\n        /* Update controls to reflect active selection or post-modification state. */\n        onManipulatorEvent(_eventType) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.updateControls();\n        }\n        /** Sub-classes can override to perform some operation for a double click on a handle. */\n        async onDoubleClick(_hit, _ev) { return EventHandled.No; }\n        /** Sub-classes can override to present a menu for a right click on a handle. */\n        async onRightClick(_hit, _ev) { return EventHandled.No; }\n        /** Sub-classes can override to respond to a touch tap on a handle. By default, handles are selected by touch drag and taps are ignored. */\n        async onTouchTap(_hit, _ev) { return EventHandled.Yes; }\n        /** Event raised by a PrimitiveTool that supports handle providers to allow a pickable decoration to respond to being located. */\n        async onDecorationButtonEvent(hit, ev) {\n            if (!this._isActive)\n                return EventHandled.No;\n            if (ev.isDoubleClick)\n                return this.onDoubleClick(hit, ev); // Allow double click on handle to override default operation (ex. fit view).\n            if (BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging)\n                return this.onRightClick(hit, ev); // Allow right click on handle to present a menu.\n            if (BeButton.Data !== ev.button)\n                return EventHandled.No;\n            if (ev.isControlKey)\n                return EventHandled.No; // Support ctrl+click to select multiple controls (ex. linestring vertices)...\n            if (InputSource.Touch === ev.inputSource && !ev.isDragging)\n                return this.onTouchTap(hit, ev); // Default is to select controls on touch drag only, ignore tap on control...\n            if (ev.isDown && !ev.isDragging)\n                return EventHandled.No; // Select controls on up event or down event only after drag started...\n            if (!await this.modifyControls(hit, ev))\n                return EventHandled.No;\n            // In case InputCollector was installed for handle modification, don't wait for motion to show dynamic frame adjusted for AccuDraw hints...\n            IModelApp.accuDraw.refreshDecorationsAndDynamics();\n            return EventHandled.Yes;\n        }\n    }\n    EditManipulator.HandleProvider = HandleProvider;\n    /** Utility methods for creating control handles and other decorations. */\n    class HandleUtils {\n        /** Adjust input color for contrast against view background.\n         * @param color The color to adjust.\n         * @param vp The viewport to compare.\n         * @return color adjusted for view background color or original color if view background color isn't being used.\n         */\n        static adjustForBackgroundColor(color, vp) {\n            if (vp.view.is3d() && vp.view.getDisplayStyle3d().environment.displaySky)\n                return color;\n            return color.adjustedForContrast(vp.view.backgroundColor);\n        }\n        /** Compute a transform that will try to orient a 2d shape (like an arrow) to face the camera.\n         * @param vp The viewport to get the rotation from.\n         * @param base The world coordinate point to pivot about.\n         * @param direction The world coordinate axis to tilt along.\n         * @param sizeInches The transform scale specified in screen inches.\n         * @returns transform or undefined when input direction is almost perpendicular to viewing direction.\n         * @see [[getArrowShape]]\n         */\n        static getArrowTransform(vp, base, direction, sizeInches) {\n            const boresite = AccuDrawHintBuilder.getBoresite(base, vp);\n            if (Math.abs(direction.dotProduct(boresite.direction)) >= 0.99)\n                return undefined;\n            const pixelSize = vp.pixelsFromInches(sizeInches);\n            const scale = vp.viewingSpace.getPixelSizeAtPoint(base) * pixelSize;\n            const matrix = Matrix3d.createRigidFromColumns(direction, boresite.direction, AxisOrder.XZY);\n            if (undefined === matrix)\n                return undefined;\n            matrix.scaleColumnsInPlace(scale, scale, scale);\n            return Transform.createRefs(base.clone(), matrix);\n        }\n        /** Return array of shape points representing a unit arrow in xy plane pointing in positive x direction. */\n        static getArrowShape(baseStart = 0.0, baseWidth = 0.15, tipStart = 0.55, tipEnd = 1.0, tipWidth = 0.3, flangeStart = tipStart, flangeWidth = baseWidth) {\n            const shapePts = [];\n            shapePts[0] = Point3d.create(tipEnd, 0.0);\n            shapePts[1] = Point3d.create(flangeStart, tipWidth);\n            shapePts[2] = Point3d.create(tipStart, flangeWidth);\n            shapePts[3] = Point3d.create(baseStart, baseWidth);\n            shapePts[4] = Point3d.create(baseStart, -baseWidth);\n            shapePts[5] = Point3d.create(tipStart, -flangeWidth);\n            shapePts[6] = Point3d.create(flangeStart, -tipWidth);\n            shapePts[7] = shapePts[0].clone();\n            return shapePts;\n        }\n    }\n    EditManipulator.HandleUtils = HandleUtils;\n})(EditManipulator || (EditManipulator = {}));\n//# sourceMappingURL=EditManipulator.js.map",
      "start": 1693508120001,
      "end": 1693508120180,
      "sourcemaps": null
    }
  ]
}
