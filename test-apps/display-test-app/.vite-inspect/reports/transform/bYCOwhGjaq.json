{
  "resolvedId": "D:/hub2023A/itwinjs-core/core/geometry/lib/esm/geometry3d/Plane3dByOriginAndVectors.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*---------------------------------------------------------------------------------------------\n* Copyright (c) Bentley Systems, Incorporated. All rights reserved.\n* See LICENSE.md in the project root for license terms and full copyright notice.\n*--------------------------------------------------------------------------------------------*/\n/** @packageDocumentation\n * @module CartesianGeometry\n */\nimport { AxisOrder, Geometry } from \"../Geometry\";\nimport { Plane3d } from \"./Plane3d\";\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\nimport { Ray3d } from \"./Ray3d\";\nimport { Transform } from \"./Transform\";\nimport { Matrix3d } from \"./Matrix3d\";\n/**\n * A Plane3dByOriginAndVectors is an origin and a pair of vectors.\n * This defines a plane with a (possibly skewed) uv coordinate grid\n * * The grid directions (`vectorU` and `vectorV`)\n *   * are NOT required to be unit vectors.\n *   * are NOT required to be perpendicular vectors.\n * * The skewed, non-uniform scaling of the grid directions is the primary focus of this class.\n * * Queries of altitude, velocity, normalX, normalY, and normalZ use the NORMALIZED cross product of vectorU\n * and vectorV as plane normal.\n *   * Hence these are cartesian distances.\n *   * If numerous calls to these are expected, the repeated normalization may be a performance issue.\n *   * Using a [[Plane3dByOriginAndUnitNormal]] or the rigid transform returned by [[toRigidFrame]] would provide\n * better performance.\n * @public\n */\nexport class Plane3dByOriginAndVectors extends Plane3d {\n    constructor(origin, vectorU, vectorV) {\n        super();\n        this.origin = origin;\n        this.vectorU = vectorU;\n        this.vectorV = vectorV;\n    }\n    /** Create a new plane from origin and 2 in-plane vectors. */\n    static createOriginAndVectors(origin, vectorU, vectorV, result) {\n        if (result) {\n            result.origin.setFrom(origin);\n            result.vectorU.setFrom(vectorU);\n            result.vectorV.setFrom(vectorV);\n            return result;\n        }\n        return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());\n    }\n    /** Clone to a new plane. */\n    clone(result) {\n        if (result !== undefined)\n            result.setOriginAndVectors(this.origin, this.vectorU, this.vectorV);\n        return new Plane3dByOriginAndVectors(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());\n    }\n    /**\n     * Create a new Plane3dByOriginAndVectors from a variety of plane types.\n     * * The input is NOT captured.\n     */\n    static createFrom(source, result) {\n        if (source instanceof Plane3dByOriginAndVectors)\n            return source.clone(result);\n        const normal = source.getUnitNormal();\n        if (normal === undefined)\n            return undefined;\n        const origin = source.getAnyPointOnPlane();\n        const vectorU = Matrix3d.createPerpendicularVectorFavorXYPlane(normal);\n        if (vectorU.tryNormalizeInPlace()) {\n            const vectorV = normal.unitCrossProduct(vectorU);\n            if (vectorV !== undefined)\n                return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);\n        }\n        return undefined;\n    }\n    /**\n     * Return a Plane3dByOriginAndVectors, with\n     * * origin is the translation (aka origin) from the Transform\n     * * vectorU is the X column of the transform\n     * * vectorV is the Y column of the transform.\n     * @param transform source transform\n     * @param xLength optional length to impose on vectorU.\n     * @param yLength optional length to impose on vectorV.\n     * @param result optional preexisting result\n     */\n    static createFromTransformColumnsXYAndLengths(transform, xLength, yLength, result) {\n        if (result) {\n            result.origin.setFrom(transform.getOrigin());\n            transform.matrix.columnX(result.vectorU);\n            transform.matrix.columnY(result.vectorV);\n        }\n        else {\n            result = new Plane3dByOriginAndVectors(transform.getOrigin(), transform.matrix.columnX(), transform.matrix.columnY());\n        }\n        if (xLength !== undefined)\n            result.vectorU.scaleToLength(xLength, result.vectorU);\n        if (yLength !== undefined)\n            result.vectorV.scaleToLength(yLength, result.vectorV);\n        return result;\n    }\n    /** Capture origin and directions in a new plane. */\n    static createCapture(origin, vectorU, vectorV, result) {\n        if (!result)\n            return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);\n        result.origin = origin;\n        result.vectorU = vectorU;\n        result.vectorV = vectorV;\n        return result;\n    }\n    /** Set all origin and both vectors from direct numeric parameters */\n    setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz) {\n        this.origin.set(x0, y0, z0);\n        this.vectorU.set(ux, uy, uz);\n        this.vectorV.set(vx, vy, vz);\n        return this;\n    }\n    /**\n     * Set all origin and both vectors from coordinates in given origin and vectors.\n     * * Note that coordinates are copied out of the parameters -- the given parameters are NOT retained by reference.\n     */\n    setOriginAndVectors(origin, vectorU, vectorV) {\n        this.origin.setFrom(origin);\n        this.vectorU.setFrom(vectorU);\n        this.vectorV.setFrom(vectorV);\n        return this;\n    }\n    /** Create a new plane from direct numeric parameters */\n    static createOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz, result) {\n        if (result)\n            return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);\n        return new Plane3dByOriginAndVectors(Point3d.create(x0, y0, z0), Vector3d.create(ux, uy, uz), Vector3d.create(vx, vy, vz));\n    }\n    /**\n     * Define a plane by three points in the plane.\n     * @param origin origin for the parameterization.\n     * @param targetU target point for the vectorU starting at the origin.\n     * @param targetV target point for the vectorV originating at the origin.\n     * @param result optional result.\n     */\n    static createOriginAndTargets(origin, targetU, targetV, result) {\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);\n    }\n    /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction. */\n    static createXYPlane(result) {\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);\n    }\n    /**\n     * Create a plane from data presented as Float64Arrays.\n     * @param origin x,y,z of origin.\n     * @param vectorU x,y,z of vectorU\n     * @param vectorV x,y,z of vectorV\n     */\n    static createOriginAndVectorsArrays(origin, vectorU, vectorV, result) {\n        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);\n    }\n    /**\n     * Create a plane from data presented as Float64Array with weights\n     * @param origin x,y,z,w of origin.\n     * @param vectorU x,y,z,w of vectorU\n     * @param vectorV x,y,z,w of vectorV\n     */\n    static createOriginAndVectorsWeightedArrays(originW, vectorUw, vectorVw, result) {\n        const w = originW[3];\n        result = Plane3dByOriginAndVectors.createXYPlane(result);\n        if (Geometry.isSmallMetricDistance(w))\n            return result;\n        const dw = 1.0 / w;\n        const au = vectorUw[3] * dw * dw;\n        const av = vectorVw[3] * dw * dw;\n        // for homogeneous function X, with w its weight:\n        // (X/w) is the cartesian point.\n        // (X/w)' = (X' w - X w')/(w*w)\n        //        = X'/w  - (X/w)(w'/w)\n        //        = X'/w  - X w'/w^2)\n        // The w parts of the formal xyzw sums are identically 0.\n        // Here the X' and its w' are taken from each vectorUw and vectorVw\n        result.origin.set(originW[0] * dw, originW[1] * dw, originW[2] * dw);\n        Vector3d.createAdd2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originW[0], originW[1], originW[2], -au, result.vectorU);\n        Vector3d.createAdd2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originW[0], originW[1], originW[2], -av, result.vectorV);\n        return result;\n    }\n    /**\n     * Evaluate a point a grid coordinates on the plane.\n     * * The computed point is `origin + vectorU * u + vectorV * v`\n     * @param u coordinate along vectorU\n     * @param v coordinate along vectorV\n     * @param result optional result destination.\n     * @returns Return the computed coordinate.\n     */\n    fractionToPoint(u, v, result) {\n        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);\n    }\n    /** Return the vector from the plane origin to parametric coordinate (u.v) */\n    fractionToVector(u, v, result) {\n        return Vector3d.createAdd2Scaled(this.vectorU, u, this.vectorV, v, result);\n    }\n    /** Set coordinates from a json object such as `{origin: [1,2,3], vectorU:[4,5,6], vectorV[3,2,1]}` */\n    setFromJSON(json) {\n        if (!json || !json.origin || !json.vectorV) {\n            this.origin.set(0, 0, 0);\n            this.vectorU.set(1, 0, 0);\n            this.vectorV.set(0, 1, 0);\n        }\n        else {\n            this.origin.setFromJSON(json.origin);\n            this.vectorU.setFromJSON(json.vectorU);\n            this.vectorV.setFromJSON(json.vectorV);\n        }\n    }\n    /**\n     * Convert an Angle to a JSON object.\n     * @return {*} [origin,normal]\n     */\n    toJSON() {\n        return {\n            origin: this.origin.toJSON(),\n            vectorU: this.vectorU.toJSON(),\n            vectorV: this.vectorV.toJSON(),\n        };\n    }\n    /** Create a new plane.   See `setFromJSON` for layout example. */\n    static fromJSON(json) {\n        const result = Plane3dByOriginAndVectors.createXYPlane();\n        result.setFromJSON(json);\n        return result;\n    }\n    /** Test origin and vectors for isAlmostEqual with `other` */\n    isAlmostEqual(other) {\n        return this.origin.isAlmostEqual(other.origin)\n            && this.vectorU.isAlmostEqual(other.vectorU)\n            && this.vectorV.isAlmostEqual(other.vectorV);\n    }\n    /**\n     * Normalize both `vectorU` and `vectorV` in place. This does NOT make them perpendicular.\n     * * Return true if both succeeded.\n     */\n    normalizeInPlace() {\n        const okU = this.vectorU.normalizeInPlace();\n        const okV = this.vectorV.normalizeInPlace();\n        return okU && okV;\n    }\n    /** Return (if possible) a unit normal to the plane */\n    getUnitNormal(result) {\n        return this.vectorU.unitCrossProduct(this.vectorV, result);\n    }\n    /**\n     * Return (if possible) a unit normal to the plane.\n     * * This method is the same as getUnitNormal, which was created later as part of the abstract base class Plane3d.\n     */\n    unitNormal(result) {\n        return this.vectorU.unitCrossProduct(this.vectorV, result);\n    }\n    /**\n     * Return some point on the plane.\n     */\n    getAnyPointOnPlane(result) {\n        // This function returns the plane origin. In general, a point x is on the plane if\n        // and only if x = o + a*u + b*v, where a and b are scalars.\n        return this.origin.clone(result);\n    }\n    /** Return (if possible) a ray with origin at plane origin, direction as unit normal to the plane */\n    unitNormalRay(result) {\n        if (!Plane3dByOriginAndVectors._workVector)\n            Plane3dByOriginAndVectors._workVector = Vector3d.create();\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV, Plane3dByOriginAndVectors._workVector);\n        if (unitNormal === undefined)\n            return undefined;\n        return Ray3d.create(this.origin, unitNormal, result);\n    }\n    /**\n     * Create a rigid frame (i.e. frenet frame) with\n     * * origin at the plane origin\n     * * x axis along the (normalized) vectorU\n     * * y axis normalized vectorU to vectorV plane, and perpendicular to x axis\n     * * z axis perpendicular to both.\n     * @param result optional result\n     */\n    toRigidFrame(result) {\n        return Transform.createRigidFromOriginAndColumns(this.origin, this.vectorU, this.vectorV, AxisOrder.XYZ, result);\n    }\n    /** Apply the transform to the origin and vectors in place */\n    transformInPlace(transform) {\n        transform.multiplyPoint3d(this.origin, this.origin);\n        transform.multiplyVector(this.vectorU, this.vectorU);\n        transform.multiplyVector(this.vectorV, this.vectorV);\n    }\n    /**\n     * Return x component of the (normalized!) {vectorU CROSS vectorV}.\n     * Return 0 if the cross product is zero.\n     */\n    normalX() {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        return unitNormal !== undefined ? unitNormal.x : 0.0;\n    }\n    /**\n     * Return y component of the (normalized!) {vectorU CROSS vectorV}.\n     * Return 0 if the cross product is zero.\n     */\n    normalY() {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        return unitNormal !== undefined ? unitNormal.y : 0.0;\n    }\n    /**\n     * Return z component of the (normalized!) {vectorU CROSS vectorV}.\n     * Return 0 if the cross product is zero.\n     */\n    normalZ() {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        return unitNormal !== undefined ? unitNormal.z : 0.0;\n    }\n    /** Return signed cartesian altitude perpendicular to the plane. This uses the normalized cross product as normal. */\n    altitude(xyz) {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        if (unitNormal === undefined)\n            return 0.0;\n        return Geometry.dotProductXYZXYZ((xyz.x - this.origin.x), (xyz.y - this.origin.y), (xyz.z - this.origin.z), unitNormal.x, unitNormal.y, unitNormal.z);\n    }\n    /** Return signed cartesian altitude perpendicular to the plane. This uses the normalized cross product as normal. */\n    altitudeXYZ(x, y, z) {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        if (unitNormal === undefined)\n            return 0.0;\n        return Geometry.dotProductXYZXYZ((x - this.origin.x), (y - this.origin.y), (z - this.origin.z), unitNormal.x, unitNormal.y, unitNormal.z);\n    }\n    /** Return signed projection of the input vector to the plane normal. This uses the normalized cross product as normal. */\n    velocity(xyzVector) {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        if (unitNormal === undefined)\n            return 0.0;\n        return Geometry.dotProductXYZXYZ(xyzVector.x, xyzVector.y, xyzVector.z, unitNormal.x, unitNormal.y, unitNormal.z);\n    }\n    /** Return signed projection of the input vector to the plane normal. This uses the normalized cross product as normal. */\n    velocityXYZ(x, y, z) {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        if (unitNormal === undefined)\n            return 0.0;\n        return Geometry.dotProductXYZXYZ(x, y, z, unitNormal.x, unitNormal.y, unitNormal.z);\n    }\n    /**\n     * Return triple product of homogeneous difference {(xyzw - w * origin)} with vectorU and vectorV.\n     * * In the usual manner of homogeneous calculations, this is proportional to true cartesian distance from the\n     * plane but is not a physical distance.\n     */\n    weightedAltitude(xyzw) {\n        const w = xyzw.w;\n        return Geometry.tripleProduct((xyzw.x - this.origin.x * w), (xyzw.y - this.origin.y * w), (xyzw.z - this.origin.z * w), this.vectorU.x, this.vectorU.y, this.vectorU.z, this.vectorV.x, this.vectorV.y, this.vectorV.z);\n    }\n    /**\n     * Return the projection of spacePoint onto the plane.\n     * If the plane is degenerate to a ray, project to the ray.\n     * If the plane is degenerate to its origin, return the point\n     */\n    projectPointToPlane(spacePoint, result) {\n        const unitNormal = this.vectorU.unitCrossProduct(this.vectorV);\n        if (unitNormal !== undefined) {\n            const w = unitNormal.dotProductStartEnd(this.origin, spacePoint);\n            return spacePoint.plusScaled(unitNormal, -w, result);\n        }\n        // uh oh.   vectorU and vectorV are colinear or zero.\n        // project to ray defined by the longer one, or just to origin.\n        const dotUU = this.vectorU.magnitudeSquared();\n        const dotVV = this.vectorV.magnitudeSquared();\n        if (dotUU >= dotVV) {\n            const dotUW = this.vectorU.dotProductStartEnd(this.origin, spacePoint);\n            const f = Geometry.conditionalDivideCoordinate(dotUW, dotUU, 0.0);\n            if (f !== undefined)\n                return spacePoint.plusScaled(this.vectorU, f, result);\n        }\n        else {\n            const dotVW = this.vectorV.dotProductStartEnd(this.origin, spacePoint);\n            const f = Geometry.conditionalDivideCoordinate(dotVW, dotVV, 0.0);\n            if (f !== undefined)\n                return spacePoint.plusScaled(this.vectorV, f, result);\n        }\n        return this.origin.clone(result);\n    }\n}\n//# sourceMappingURL=Plane3dByOriginAndVectors.js.map",
      "start": 1693508123189,
      "end": 1693508123339,
      "sourcemaps": null
    }
  ]
}
