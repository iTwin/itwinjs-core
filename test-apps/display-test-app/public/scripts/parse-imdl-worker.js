(()=>{"use strict";const t=!1;function e(e,i){if(t&&("boolean"!=typeof e&&(e=e()),!e))throw"string"!=typeof(i=i??"Programmer Error")&&(i=i()),new Error(`Assert: ${i}`)}function i(t,e){return t-e}function s(t,e){return t!==e?t<e?-1:1:0}function n(t,e){return t===e?0:t<e?-1:1}function r(t,e,i){return void 0===e?void 0===i?0:-1:void 0===i?1:t(e,i)}function o(t,e){return r(n,t,e)}function a(t){const e=parseInt(t,16);return Number.isNaN(e)?0:e}function c(t,e,i=!0){const s=t.charCodeAt(e);return s>=(i?48:49)&&s<=57||s>=97&&s<=102}function h(t,e,i){if(0===i)return!1;if(!c(t,e,!1))return!1;for(let s=1;s<i;s++)if(!c(t,e+s))return!1;return!0}var l,d,u,f,g,p,m,x,y,_,v,P,I,A,S,w,C,T,k,F,M,b,E,X,z,R,D,N,Y,O,B,V,L;!function(t){t.getLocalId=function(t){if(g(t))return 0;const e=t.length,i=e>12?e-10:2;return a(t.slice(i))},t.getBriefcaseId=function(t){if(g(t))return 0;const e=t.length;return e<=12?0:a(t.slice(2,e-10))},t.fromJSON=function(e){return"string"==typeof e?t.fromString(e):t.invalid},t.fromString=function(e){if("string"!=typeof e)return t.invalid;if(t.isId64(e))return e;const s=(e=e.toLowerCase().trim()).length;if(s<2||"0"!==e[0]||"x"!==e[1])return t.invalid;let n=0,r=0,o=2;return s>12&&(o=s-10,r=a(e.slice(2,o))),n=a(e.slice(o)),i(n,r)};const e=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(i,s){if("number"!=typeof i||"number"!=typeof s)return t.invalid;if(0===(i=Math.floor(i)))return t.invalid;s=Math.floor(s);const n=i.toString(16);return`0x${0===s?n:s.toString(16)+(e[n.length]+n)}`}t.fromLocalAndBriefcaseIds=i;const s=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function n(t){return t+(t<10?48:87)}function r(t,e,i){let s=0;for(let r=e;r<i;r++)s=(s|(n=t.charCodeAt(r))-(n>=87?87:48)<<(i-r-1<<2))>>>0;var n;return s}function o(e,i){if(0==(e>>>0)+4294967296*(255&i))return t.invalid;const r=s;let o=2;for(let t=7;t>=0;t--){const e=t<<2,s=(i&15<<e)>>>e;(o>2||0!==s)&&(r[o++]=n(s))}for(let t=7;t>=0;t--){const i=t<<2,s=(e&15<<i)>>>i;(o>2||0!==s)&&(r[o++]=n(s))}return r.length!==o&&(r.length=o),String.fromCharCode(...s)}function c(t){if(g(t))return 0;const e=t.length;return r(t,e>10?e-8:2,e)}function l(t){const e=t.length;return e<=10||g(t)?0:r(t,2,e-8)}function*d(t){if("string"==typeof t)yield t;else for(const e of t)yield e}function u(t){return 18===t.length&&t.startsWith("0xffffff")}function f(e){return t.invalid!==e&&t.isId64(e)}function g(e){return t.invalid===e}t.fromUint32Pair=o,t.fromUint32PairObject=function(t){return o(t.lower,t.upper)},t.isValidUint32Pair=function(t,e){return 0!==t||0!=(255&e)},t.getUint32Pair=function(t,e){return e||(e={lower:0,upper:0}),e.lower=c(t),e.upper=l(t),e},t.getLowerUint32=c,t.getUpperUint32=l,t.toIdSet=function(t,e=!1){if(t instanceof Set)return e?new Set(t):t;const i=new Set;return"string"==typeof t?i.add(t):Array.isArray(t)&&t.forEach((t=>{"string"==typeof t&&i.add(t)})),i},t.iterator=d,t.iterable=function(t){return{[Symbol.iterator]:()=>d(t)}},t.getFirst=function(t){return"string"==typeof t?t:Array.isArray(t)?t[0]:t.values().next().value},t.sizeOf=function(t){return"string"==typeof t?1:Array.isArray(t)?t.length:t.size},t.has=function(t,e){return"string"==typeof t?t===e:Array.isArray(t)?-1!==t.indexOf(e):t.has(e)},t.invalid="0",t.isTransient=u,t.isTransientId64=function(t){return f(t)&&u(t)},t.isId64=function(t){const e=t.length;if(0===e||18<e)return!1;if("0"!==t[0])return!1;if(1===e)return!0;if(2===e||"x"!==t[1])return!1;let i=2;if(e>12){if(i=e-10,!h(t,2,i-2))return!1;for(let s=i;s<e&&48===t.charCodeAt(s);s++)i++;if(i>=e)return!1}return h(t,i,e-i)},t.isValid=function(e){return t.invalid!==e},t.isValidId64=f,t.isInvalid=g,t.Uint32Set=class{constructor(t){this._map=new Map,void 0!==t&&this.addIds(t)}clear(){this._map.clear()}addId(e){this.add(t.getLowerUint32(e),t.getUpperUint32(e))}addIds(e){for(const i of t.iterable(e))this.addId(i)}hasId(e){return this.has(t.getLowerUint32(e),t.getUpperUint32(e))}add(t,e){let i=this._map.get(e);void 0===i&&(i=new Set,this._map.set(e,i)),i.add(t)}deleteId(e){this.delete(t.getLowerUint32(e),t.getUpperUint32(e))}deleteIds(e){for(const i of t.iterable(e))this.deleteId(i)}delete(t,e){const i=this._map.get(e);void 0!==i&&i.delete(t)}has(t,e){const i=this._map.get(e);return void 0!==i&&i.has(t)}hasPair(t){return this.has(t.lower,t.upper)}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}toId64Array(){const e=[];for(const i of this._map)for(const s of i[1])e.push(t.fromUint32Pair(s,i[0]));return e}toId64Set(){const e=new Set;for(const i of this._map)for(const s of i[1])e.add(t.fromUint32Pair(s,i[0]));return e}forEach(t){for(const e of this._map)for(const i of e[1])t(i,e[0])}},t.Uint32Map=class{constructor(){this._map=new Map}clear(){this._map.clear()}getById(e){return this.get(t.getLowerUint32(e),t.getUpperUint32(e))}setById(e,i){this.set(t.getLowerUint32(e),t.getUpperUint32(e),i)}set(t,e,i){let s=this._map.get(e);void 0===s&&(s=new Map,this._map.set(e,s)),s.set(t,i)}get(t,e){const i=this._map.get(e);return void 0!==i?i.get(t):void 0}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}forEach(t){for(const e of this._map)for(const i of e[1])t(i[0],e[0],i[1])}}}(l||(l={})),function(t){const e=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(t){return e.test(t)}t.empty="00000000-0000-0000-0000-000000000000",t.isGuid=i,t.isV4Guid=function(t){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(t)},t.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(t=>{const e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)}))},t.normalize=function(t){const e=t.toLowerCase().trim();if(i(e))return e;const s=e.replace(/-/g,""),n=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return n.test(s)?s.replace(n,((t,e,i,s,n,r)=>`${e}-${i}-${s}-${n}-${r}`)):t}}(d||(d={})),function(t){function i(t,e){return t.length!==e.length?t.length<e.length?-1:1:t!==e?t<e?-1:1:0}function*s(t){const e=t[Symbol.iterator]();let i,s=e.next();for(;!s.done;){const t=s.value;s=e.next(),t!==i&&(i=t,yield t)}}function*n(t,s){const n=t[Symbol.iterator](),r=s[Symbol.iterator]();let o,a=n.next(),c=r.next();for(;!a.done||!c.done;){const t=a.done?void 0:a.value,s=c.done?void 0:c.value;if(e(void 0!==t||void 0!==s),void 0===t&&void 0===s)break;let h;if(void 0===t)e(void 0!==s),h=s,c=r.next();else if(void 0===s)h=t,a=n.next();else{const e=i(t,s);e<=0?(h=t,a=n.next(),0===e&&(c=r.next())):(h=s,c=r.next())}o!==h&&(o=h,yield h)}}function*r(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done&&!a.done;){const t=o.value;if(o=s.next(),t===r)continue;r=t;let e=a.value,c=i(t,e);for(;c>0;){if(a=n.next(),a.done)return;e=a.value,c=i(t,e)}0===c&&(yield t)}}function*o(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r,o=s.next(),a=n.next();for(;!o.done;){const t=o.value;if(o=s.next(),t===r)continue;if(a.done){yield r=t;continue}let e=a.value,c=i(t,e);for(;c>0&&!a.done;)a=n.next(),a.done?yield r=t:(e=a.value,c=i(t,e));c<0&&(yield r=t)}}t.compare=i,t.sortArray=function(t){return t.sort(((t,e)=>i(t,e))),t},t.areEqualSets=function(t,e){const n=s(t),r=s(e);let o=n.next(),a=r.next();for(;!o.done&&!a.done;){if(0!==i(o.value,a.value))return!1;o=n.next(),a=r.next()}return!(!o.done||!a.done)},t.isEmptySet=function(t){return"string"==typeof t?""===t:!0===t[Symbol.iterator]().next().done},t.unique=function(t){return{[Symbol.iterator]:()=>s(t)}},t.uniqueIterator=s,t.union=function(t,e){return{[Symbol.iterator]:()=>n(t,e)}},t.intersection=function(t,e){return{[Symbol.iterator]:()=>r(t,e)}},t.difference=function(t,e){return{[Symbol.iterator]:()=>o(t,e)}},t.unionIterator=n,t.intersectionIterator=r,t.differenceIterator=o}(u||(u={})),function(t){function i(t){return t>=48&&t<=57||t>=65&&t<=70}function s(t,i){e(i>0);const s=`+${t.toString()}`;return i<=1?s:`${s}*${i.toString(16).toUpperCase()}`}function n(t){const e="string"==typeof t?[t]:Array.from(t);return u.sortArray(e),r(e)}function r(t){return o(t)}function o(t){if("string"==typeof t)return t;let e="";const i=new a,n=new a;let r=0;const o=new a,c=new a;for(const a of t){if(!l.isValidId64(a))continue;o.setFromId(a),c.setFromDifference(o,i);const t=i.compare(o);if(0!==t){if(t>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");i.copyFrom(o),0===r?(n.copyFrom(c),r=1):c.equals(n)?++r:(e+=s(n,r),n.copyFrom(c),r=1)}}return 0<r&&(e+=s(n,r)),e}t.compressSet=function(t){return n(t)},t.sortAndCompress=n,t.compressArray=r,t.compressIds=o;class a{static assertUint32(t){e(t>=0),e(t<a._base),e(Math.floor(t)===t)}assertConstraints(){a.assertUint32(this.lower),a.assertUint32(this.upper)}constructor(t=0,e=0){this.lower=t,this.upper=e,this.assertConstraints()}compare(t){const e=this.upper-t.upper;return 0===e?this.lower-t.lower:e}equals(t){return 0===this.compare(t)}isLessThan(t){return this.compare(t)<0}isGreaterThan(t){return this.compare(t)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(t,i){e(!i.isGreaterThan(t)),this.lower=t.lower-i.lower,this.upper=t.upper-i.upper,this.lower<0&&(this.lower+=a._base,this.upper-=1)}add(t){let e=t.lower,i=t.upper;e+this.lower>=a._base&&(e-=a._base,i+=1),this.lower+=e,this.upper+=i,this.assertConstraints()}setFromId(t){l.getUint32Pair(t,this)}copyFrom(t){this.lower=t.lower,this.upper=t.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const t=this.upper.toString(16),i=this.lower.toString(16).padStart(8,"0");return e(8===i.length),`${t}${i}`.toUpperCase()}toId64String(){return l.fromUint32Pair(this.lower,this.upper)}}function*c(t){if(0===t.length)return;if("+"!==t[0])throw new Error("Invalid CompressedId64Set");let s=1;const n=new a;function r(){let e=0,n=0;for(;s<t.length&&n<8;){++n;const r=t.charCodeAt(s);if(!i(r))break;e<<=4,e|=r>=65?r-65+10:r-48,e>>>=0,++s}return e}function o(n){let o=0,a=0;const c=s,h=r(),l=s-c;if(e(l<=8),8===l&&s+1<t.length&&i(t.charCodeAt(s+1))){const t=s,i=r(),n=s-t;e(n>0&&n<=8);const c=8-n;a=h>>>4*c,o=(i|h-(a<<4*c>>>0)<<4*n>>>0)>>>0}else o=h;n.lower=o,n.upper=a}const c=new a;for(;s<t.length;){let e=1;if(o(c),c.isZero)throw new Error("Invalid CompressedId64Set");if(s<t.length)switch(t[s++]){case"*":if(e=r(),0===e)throw new Error("Invalid CompressedId64Set");if(s!==t.length&&"+"!==t[s++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let t=0;t<e;t++)n.add(c),yield n.toId64String()}}function h(t){return{[Symbol.iterator]:()=>c(t)}}a._base=4294967296,t.iterator=c,t.iterable=h,t.decompressSet=function(t,e){const i=e??new Set;for(const e of h(t))i.add(e);return i},t.decompressArray=function(t,e){const i=e??[];for(const e of h(t))i.push(e);return i}}(f||(f={}));class U{constructor(t){this._inserted=new OrderedId64Array,this._deleted=new OrderedId64Array,this._ids=t??""}get ids(){return this.updateIds(),this._ids}add(t){if(!Id64.isValidId64(t))throw new Error("MutableCompressedId64Set.add: invalid Id");this._deleted.remove(t),this._inserted.insert(t)}delete(t){if(!Id64.isValidId64(t))throw new Error("MutableCompressedId64Set.delete: invalid Id");this._inserted.remove(t),this._deleted.insert(t)}clear(){this._ids="",this._inserted.clear(),this._deleted.clear()}reset(t){this.clear(),this._ids=t??""}[Symbol.iterator](){return f.iterator(this.ids)}computeUnion(t){return this.isEmpty?f.compressIds(t):OrderedId64Iterable.isEmptySet(t)||this.equals(t)?this.ids:f.compressIds(OrderedId64Iterable.union(this,t))}computeIntersection(t){return this.equals(t)?this.ids:this.isEmpty||OrderedId64Iterable.isEmptySet(t)?"":f.compressIds(OrderedId64Iterable.intersection(this,t))}computeDifference(t){return this.isEmpty||this.equals(t)?"":f.compressIds(OrderedId64Iterable.difference(this,t))}get isEmpty(){return OrderedId64Iterable.isEmptySet(this.ids)}equals(t){if(t instanceof U){if(t===this)return!0;"string"!=typeof t&&t.ids}return"string"==typeof t?t===this.ids:(this.updateIds(),OrderedId64Iterable.areEqualSets(this,t))}get _isDirty(){return!this._inserted.isEmpty||!this._deleted.isEmpty}updateIds(){if(!this._isDirty)return;const t=OrderedId64Iterable.difference(f.iterable(this._ids),this._deleted.ids),e={[Symbol.iterator]:()=>OrderedId64Iterable.unionIterator(t,this._inserted.ids)};this._ids=f.compressIds(e),this._inserted.clear(),this._deleted.clear()}}class Z{constructor(t=0,e){this._radians=t,this._degrees=e}clone(){return new Z(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(t){return new Z(Z.degreesToRadians(t),t)}static createRadians(t){return new Z(t)}static createInterpolate(t,e,i){return new Z(J.interpolate(t.radians,e,i.radians))}cloneScaled(t){return new Z(this.radians*t)}setRadians(t){this._radians=t,this._degrees=void 0}setDegrees(t){this._radians=Z.degreesToRadians(t),this._degrees=t}static create360(){return new Z(2*Math.PI,360)}static createAtan2(t,e){return new Z(Math.atan2(t,e))}setFrom(t){this._radians=t._radians,this._degrees=t._degrees}setFromJSON(t,e){this._radians=e||0,t&&("number"==typeof t?this.setDegrees(t):"number"==typeof t.degrees?this.setDegrees(t.degrees):"number"==typeof t._degrees?this.setDegrees(t._degrees):"number"==typeof t.radians?this.setRadians(t.radians):"number"==typeof t._radians&&this.setRadians(t._radians))}static fromJSON(t,e){const i=new Z;return i.setFromJSON(t,e),i}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:Z.radiansToDegrees(this._radians)}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){if(t<0)return-Z.radiansToDegrees(-t);const e=Math.PI;return t<=.25*e?180/e*t:t<.75*e?90+(t-.5*e)/e*180:t<=1.25*e?180+(t-e)/e*180:t<=1.75*e?270+(t-1.5*e)/e*180:360+(t-2*e)/e*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(t){return Math.abs(t)>=J.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(t){return Math.abs(Math.abs(t)-Math.PI)<=J.smallAngleRadians}get isFullCircle(){return Z.isFullCircleRadians(this._radians)}get isHalfCircle(){return Z.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(t){if(t>=0){const e=360;return t<e?t:t-Math.floor(t/e)*e}return t<0?360-Z.adjustDegrees0To360(-t):0}static adjustDegreesSigned180(t){if(Math.abs(t)<=180)return t;if(t>=0){const e=360;return t-(1+Math.floor((t-180)/e))*e}return t<0?-Z.adjustDegreesSigned180(-t):0}static adjustRadians0To2Pi(t){if(t>=0){const e=2*Math.PI;return t<e?t:t-Math.floor(t/e)*e}return t<0?2*Math.PI-Z.adjustRadians0To2Pi(-t):0}static adjustRadiansMinusPiPlusPi(t){if(Math.abs(t)<=Math.PI)return t;if(t>=0){const e=2*Math.PI;return t-(1+Math.floor((t-Math.PI)/e))*e}return t<0?-Z.adjustRadiansMinusPiPlusPi(-t):0}static zero(){return new Z(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<J.smallAngleRadians}get isAlmostNorthOrSouthPole(){return Z.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(t){return Z.createDegrees(Z.adjustDegrees0To360(t))}static createDegreesAdjustSigned180(t){return Z.createDegrees(Z.adjustDegreesSigned180(t))}static isAlmostEqualRadiansAllowPeriodShift(t,e,i=J.smallAngleRadians){const s=Math.abs(t-e);if(s<=i)return!0;const n=2*Math.PI;if(Math.abs(s-n)<=i)return!0;const r=s-Math.round(s/n)*n;return Math.abs(r)<=i}isAlmostEqualAllowPeriodShift(t,e=J.smallAngleRadians){return Z.isAlmostEqualRadiansAllowPeriodShift(this._radians,t._radians,e)}static isAlmostEqualRadiansNoPeriodShift(t,e,i=J.smallAngleRadians){return Math.abs(t-e)<i}isAlmostEqualNoPeriodShift(t,e=J.smallAngleRadians){return Z.isAlmostEqualRadiansNoPeriodShift(this._radians,t._radians,e)}isAlmostEqual(t,e=J.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(t,e)}static isPerpendicularDotSet(t,e,i){return t>J.smallMetricDistanceSquared&&e>J.smallMetricDistanceSquared&&i*i<=J.smallAngleRadiansSquared*t*e}static trigValuesToHalfAngleTrigValues(t,e){const i=J.hypotenuseXY(t,e);if(i<J.smallMetricDistance)return{c:1,s:0,radians:0};{let s,n=0;const r=t/i,o=e/i;return r>=0?(s=Math.sqrt(.5*(1+r)),n=o/(2*s)):(n=o>0?Math.sqrt(.5*(1-r)):-Math.sqrt(.5*(1-r)),s=o/(2*n)),{c:s,s:n,radians:Math.atan2(n,s)}}}static cleanupTrigValue(t,e=J.smallFloatingPoint){const i=Math.abs(t);if(i<=e)return 0;let s=Math.abs(i-.5);return s<=e?t<0?-.5:.5:(s=Math.abs(i-1),s<=e?t<0?-1:1:t)}static dotProductsToHalfAngleTrigValues(t,e,i,s=!0){const n=t-e,r=2*i;return s&&Math.abs(r)<J.smallAngleRadians*(Math.abs(t)+Math.abs(e))?{c:1,s:0,radians:0}:Z.trigValuesToHalfAngleTrigValues(n,r)}static radiansBetweenVectorsXYZ(t,e,i,s,n,r){const o=t*s+e*n+i*r;return Math.atan2(J.crossProductMagnitude(t,e,i,s,n,r),o)}static orientedRadiansBetweenVectorsXYZ(t,e,i,s,n,r,o,a,c,h=!1){const l=t*s+e*n+i*r,d=e*r-i*n,u=i*s-t*r,f=t*n-e*s,g=o*d+a*u+c*f,p=J.hypotenuseXYZ(d,u,f);return g<0?h?Math.PI+Math.atan2(p,-l):-Math.atan2(p,l):Math.atan2(p,l)}addMultipleOf2PiInPlace(t){void 0!==this._degrees?(this._degrees+=360*t,this._radians=Z.degreesToRadians(this._degrees)):this._radians+=t*Z.pi2Radians}}Z.piOver12Radians=.26179938779914946,Z.piOver4Radians=.7853981633974483,Z.piOver2Radians=1.5707963267948966,Z.piRadians=3.141592653589793,Z.pi2Radians=6.283185307179586,Z.degreesPerRadian=45/Z.piOver4Radians,Z.radiansPerDegree=Z.piOver4Radians/45;class q{set(t=0,e=0){this.x=t,this.y=e}setZero(){this.x=0,this.y=0}constructor(t=0,e=0){this.x=t,this.y=e}setFrom(t){t?(this.x=t.x,this.y=t.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(t,e){return J.isSameCoordinate(this.x,t.x,e)&&J.isSameCoordinate(this.y,t.y,e)}isAlmostEqualXY(t,e,i){return J.isSameCoordinate(this.x,t,i)&&J.isSameCoordinate(this.y,e,i)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0):t?this.set(t.x||0,t.y||0):this.set(0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}at(t){return t<.5?this.x:this.y}setAt(t,e){t<.5?this.x=e:this.y=e}indexOfMaxAbs(){let t=0;const e=Math.abs(this.x);return Math.abs(this.y)>e&&(t=1),t}get isAlmostZero(){return J.isSmallMetricDistance(this.x)&&J.isSmallMetricDistance(this.y)}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y}isAlmostEqualMetric(t,e=J.smallMetricDistance){return this.maxDiff(t)<=e}vectorTo(t,e){return G.create(t.x-this.x,t.y-this.y,e)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}static crossProductToPoints(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}}class W extends q{constructor(t=0,e=0){super(t,e)}clone(t){return W.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new W(t,e)}static fromJSON(t){const e=new W;return e.setFromJSON(t),e}static createFrom(t,e){return t?W.create(t.x,t.y,e):W.create(0,0,e)}static createZero(t){return W.create(0,0,t)}addForwardLeft(t,e,i){const s=i.x,n=i.y;return W.create(this.x+t*s-e*n,this.y+t*n+e*s)}forwardLeftInterpolate(t,e,i){const s=i.x-this.x,n=i.y-this.y;return W.create(this.x+t*s-e*n,this.y+t*n+e*s)}interpolate(t,e,i){if(t<=.5)return W.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),i);const s=t-1;return W.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),i)}interpolateXY(t,e,i,s){return W.create(J.interpolate(this.x,t,i.x),J.interpolate(this.y,e,i.y),s)}minus(t,e){return W.create(this.x-t.x,this.y-t.y,e)}plus(t,e){return W.create(this.x+t.x,this.y+t.y,e)}plusXY(t=0,e=0,i){return W.create(this.x+t,this.y+e,i)}plusScaled(t,e,i){return W.create(this.x+t.x*e,this.y+t.y*e,i)}plus2Scaled(t,e,i,s,n){return W.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,n)}plus3Scaled(t,e,i,s,n,r,o){return W.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)}crossProductToPoints(t,e){const i=t.x-this.x,s=t.y-this.y,n=e.x-this.x;return i*(e.y-this.y)-s*n}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<J.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class G extends q{constructor(t=0,e=0){super(t,e)}clone(t){return G.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new G(t,e)}static unitX(t=1){return new G(t,0)}static unitY(t=1){return new G(0,t)}static createZero(t){return G.create(0,0,t)}static createFrom(t,e){return t instanceof Float64Array?t.length>=2?G.create(t[0],t[1]):t.length>=1?G.create(t[0],0):G.create(0,0):G.create(t.x,t.y,e)}static fromJSON(t){const e=new G;return e.setFromJSON(t),e}static createPolar(t,e){return G.create(t*e.cos(),t*e.sin())}static createStartEnd(t,e,i){return G.create(e.x-t.x,e.y-t.y,i)}static createOffsetBisector(t,e,i){let s=t.plus(e);if(s=s.normalize(),s){const e=s.dotProduct(t);return s.scale(i,s),s.safeDivideOrNull(e)}}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalize(t){const e=J.correctSmallFraction(this.magnitude());return t=t||new G,this.safeDivideOrNull(e,t)}fractionOfProjectionToVector(t,e){const i=t.magnitudeSquared();return i<J.smallMetricDistanceSquared?e||0:this.dotProduct(t)/i}negate(t){return(t=t||new G).x=-this.x,t.y=-this.y,t}rotate90CCWXY(t){t=t||new G;const e=this.x,i=this.y;return t.x=-i,t.y=e,t}rotate90CWXY(t){t=t||new G;const e=this.x,i=this.y;return t.x=i,t.y=-e,t}unitPerpendicularXY(t){t=t||new G;const e=this.x,i=this.y;t.x=-i,t.y=e;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new G).x=n*s-r*i,e.y=n*i+r*s,e}interpolate(t,e,i){if(i=i||new G,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y)}return i}plus(t,e){return(e=e||new G).x=this.x+t.x,e.y=this.y+t.y,e}minus(t,e){return(e=e||new G).x=this.x-t.x,e.y=this.y-t.y,e}plusScaled(t,e,i){return(i=i||new G).x=this.x+t.x*e,i.y=this.y+t.y*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new G).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new G).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o}scale(t,e){return(e=e||new G).x=this.x*t,e.y=this.y*t,e}scaleToLength(t,e){const i=J.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}radiansTo(t){return Math.atan2(this.crossProduct(t),this.dotProduct(t))}angleTo(t){return Z.createRadians(this.radiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??J.smallAngleRadiansSquared,r=s?.distanceSquaredTol??J.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();if(o<r||a<r)return i;if(this.dotProduct(t)<0&&!e)return!1;const c=this.crossProduct(t);return c*c<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??J.smallAngleRadiansSquared,n=i?.distanceSquaredTol??J.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}!function(t){t[t.XYZ=0]="XYZ",t[t.YZX=1]="YZX",t[t.ZXY=2]="ZXY",t[t.XZY=4]="XZY",t[t.YXZ=5]="YXZ",t[t.ZYX=6]="ZYX"}(g||(g={})),function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z"}(p||(p={})),function(t){t[t.Top=1]="Top",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t[t.Right=4]="Right",t[t.Front=5]="Front",t[t.Back=6]="Back",t[t.Iso=7]="Iso",t[t.RightIso=8]="RightIso"}(m||(m={})),function(t){t[t.Unit=0]="Unit",t[t.LongestRangeDirection=1]="LongestRangeDirection",t[t.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(x||(x={})),function(t){t[t.Unknown=0]="Unknown",t[t.OnPolygonVertex=1]="OnPolygonVertex",t[t.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",t[t.InsidePolygon=3]="InsidePolygon",t[t.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",t[t.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",t[t.OutsidePolygon=6]="OutsidePolygon",t[t.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",t[t.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(y||(y={}));class J{static isLargeCoordinateResult(t){return t>this.largeCoordinateResult||t<-this.largeCoordinateResult}static isHugeCoordinate(t){return J.isLargeCoordinateResult(t)}static isOdd(t){return 1==(1&t)}static correctSmallMetricDistance(t,e=0){return void 0===t||Math.abs(t)<J.smallMetricDistance?e:t}static correctSmallFraction(t,e=0){return void 0===t||Math.abs(t)<J.smallFraction?e:t}static inverseMetricDistance(t){return Math.abs(t)<=J.smallMetricDistance?void 0:1/t}static inverseMetricDistanceSquared(t){return Math.abs(t)<=J.smallMetricDistanceSquared?void 0:1/t}static isSameCoordinate(t,e,i=J.smallMetricDistance){let s=t-e;return s<0&&(s=-s),s<=i}static isSameCoordinateWithToleranceFactor(t,e,i){return J.isSameCoordinate(t,e,i*J.smallMetricDistance)}static isSameCoordinateXY(t,e,i,s,n=J.smallMetricDistance){let r=i-t;return r<0&&(r=-r),!(r>n)&&(r=s-e,r<0&&(r=-r),r<=n)}static isSameCoordinateSquared(t,e,i=J.smallMetricDistance){return Math.abs(Math.sqrt(t)-Math.sqrt(e))<=i}static isSamePoint3d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSameXYZ(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSamePoint3dXY(t,e,i=J.smallMetricDistance){return t.distanceXY(e)<=i}static isSameVector3d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSamePoint2d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSameVector2d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static lexicalXYLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}static lexicalYXLessThan(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static lexicalXYZLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:t.z<e.z?-1:t.z>e.z?1:0}static isSmallRelative(t){return Math.abs(t)<J.smallFraction}static isSmallAngleRadians(t){return Math.abs(t)<J.smallAngleRadians}static isAlmostEqualOptional(t,e,i){if(void 0!==t&&void 0!==e){if(Math.abs(t-e)>i)return!1}else if(void 0!==t||void 0!==e)return!1;return!0}static isAlmostEqualNumber(t,e,i=J.smallAngleRadians){const s=1+Math.abs(t)+Math.abs(e);return Math.abs(t-e)<=i*s}static isAlmostEqualXAndY(t,e,i=J.smallAngleRadians){const s=i*(1+Math.abs(t.x)+Math.abs(e.x)+Math.abs(t.y)+Math.abs(e.y));return Math.abs(t.x-e.x)<=s&&Math.abs(t.y-e.y)<=s}static isDistanceWithinTol(t,e=J.smallMetricDistance){return Math.abs(t)<=e}static isSmallMetricDistance(t){return Math.abs(t)<=J.smallMetricDistance}static isSmallMetricDistanceSquared(t){return Math.abs(t)<=J.smallMetricDistanceSquared}static cyclic3dAxis(t){if(t>=0)return t<3?t:t<6?t-3:t%3;const e=t+3;return e>=0?e:2-(-t-1)%3}static axisIndexToRightHandedAxisOrder(t){return 0===t?g.XYZ:1===t?g.YZX:2===t?g.ZXY:J.axisIndexToRightHandedAxisOrder(J.cyclic3dAxis(t))}static maxXYZ(t,e,i){let s=t;return e>s&&(s=e),i>s&&(s=i),s}static minXYZ(t,e,i){let s=t;return e<s&&(s=e),i<s&&(s=i),s}static maxXY(t,e){let i=t;return e>i&&(i=e),i}static minXY(t,e){let i=t;return e<i&&(i=e),i}static maxAbsXYZ(t,e,i){return J.maxXYZ(Math.abs(t),Math.abs(e),Math.abs(i))}static maxAbsXY(t,e){return J.maxXY(Math.abs(t),Math.abs(e))}static maxAbsDiff(t,e,i){return Math.max(Math.abs(t-e),Math.abs(t-i))}static split3WaySign(t,e,i,s){return t<0?e:t>0?s:i}static split3Way01(t,e=J.smallMetricDistance){return t>e?1:t<-e?-1:0}static square(t){return t*t}static hypotenuseXY(t,e){return Math.sqrt(t*t+e*e)}static hypotenuseSquaredXY(t,e){return t*t+e*e}static hypotenuseXYZ(t,e,i){return Math.sqrt(t*t+e*e+i*i)}static hypotenuseSquaredXYZ(t,e,i){return t*t+e*e+i*i}static hypotenuseXYZW(t,e,i,s){return Math.sqrt(t*t+e*e+i*i+s*s)}static hypotenuseSquaredXYZW(t,e,i,s){return t*t+e*e+i*i+s*s}static distanceXYXY(t,e,i,s){return J.hypotenuseXY(i-t,s-e)}static distanceXYZXYZ(t,e,i,s,n,r){return J.hypotenuseXYZ(s-t,n-e,r-i)}static tripleProduct(t,e,i,s,n,r,o,a,c){return t*(n*c-r*a)+e*(r*o-s*c)+i*(s*a-n*o)}static determinant4x4(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g,p){return t*this.tripleProduct(r,o,a,h,l,d,f,g,p)-n*this.tripleProduct(e,i,s,h,l,d,f,g,p)+c*this.tripleProduct(e,i,s,r,o,a,f,g,p)-u*this.tripleProduct(e,i,s,r,o,a,h,l,d)}static tripleProductXYW(t,e,i,s,n,r){return J.tripleProduct(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r)}static tripleProductPoint4dXYW(t,e,i){return J.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w)}static crossProductXYXY(t,e,i,s){return t*s-e*i}static crossProductXYZXYZ(t,e,i,s,n,r,o){return j.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}static crossProductMagnitude(t,e,i,s,n,r){return J.hypotenuseXYZ(e*r-i*n,i*s-t*r,t*n-e*s)}static dotProductXYXY(t,e,i,s){return t*i+e*s}static dotProductXYZXYZ(t,e,i,s,n,r){return t*s+e*n+i*r}static meanCurvatureOfRadii(t,e){return.5*(this.safeDivideFraction(1,t,0)+this.safeDivideFraction(1,e,0))}static curvatureMagnitude(t,e,i,s,n,r){let o=e*r-i*n,a=o*o;o=i*s-t*r,a+=o*o,o=t*n-e*s,a+=o*o;const c=Math.sqrt(a),h=Math.sqrt(t*t+e*e+i*i),l=h*h*h;return l>J.smallAngleRadians*c?c/l:0}static clampToStartEnd(t,e,i){return e>i?J.clampToStartEnd(t,i,e):t<e?e:i<t?i:t}static clamp(t,e,i){return Math.max(e,Math.min(i,t))}static resolveNumber(t,e=0){return void 0!==t?t:e}static resolveValue(t,e){return void 0!==t?t:e}static resolveToUndefined(t,e){return t===e?void 0:t}static interpolate(t,e,i){return e<=.5?t+e*(i-t):i-(1-e)*(i-t)}static axisOrderToAxis(t,e){const i=t<=g.ZXY?t+e:t-g.XZY-e;return J.cyclic3dAxis(i)}static modulo(t,e){if(e<=0)return 0===e?t:-J.modulo(-t,-e);if(t>=0){if(t<e)return t;if(t<2*e)return t-e}else if((t+=e)>0)return t;return t-Math.floor(t/e)*e}static defined01(t){return void 0===t?0:1}static conditionalDivideFraction(t,e){if(Math.abs(e)*J.largeFractionResult>Math.abs(t))return t/e}static safeDivideFraction(t,e,i){const s=J.conditionalDivideFraction(t,e);return void 0!==s?s:i}static conditionalDivideCoordinate(t,e,i=J.largeCoordinateResult){if(Math.abs(e*i)>Math.abs(t))return t/e}static solveTrigForm(t,e,i){const s=e*e+i*i;let n;if(s>0){const r=1/s,o=1-t*t*r;if(o<-J.smallMetricDistanceSquared)return n;const a=-t*r,c=a*e,h=a*i;if(o<=0)n=[G.create(c,h)];else{const t=Math.sqrt(o*r);n=[G.create(c-t*i,h+t*e),G.create(c+t*i,h-t*e)]}}return n}static inverseInterpolate(t,e,i,s,n=0,r){const o=J.conditionalDivideFraction(n-e,s-e);return void 0!==o?J.interpolate(t,o,i):r}static inverseInterpolate01(t,e,i=0){return J.conditionalDivideFraction(i-t,e-t)}static isNumberArray(t,e=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Number.isFinite(e))return!1;return!0}return!1}static isArrayOfNumberArray(t,e,i=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!J.isNumberArray(e,i))return!1;return!0}return!1}static stepCount(t,e,i=1,s=101){if(t<=0)return i;if(t>=(e=Math.abs(e)))return i;const n=Math.floor((e+.999999*t)/t);return n<i?i:n>s?s:n}static isIn01(t,e=!0){return!e||t>=0&&t<=1}static isIn01WithTolerance(t,e){return t+e>=0&&t-e<=1}static restrictToInterval(t,e,i){return e<=i?t<e?e:t>i?i:t:t<i?i:t>e?e:t}static equalStringNoCase(t,e){return t.toUpperCase()===e.toUpperCase()}static exactEqualNumberArrays(t,e){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return!1}static almostEqualArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static almostEqualNumberArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(!i(t[s],e[s]))return!1;return!0}return!1}static areEqualAllowUndefined(t,e,i=!0){return void 0===t&&void 0===e?i:void 0!==t&&void 0!==e&&t===e}static cloneMembers(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}}J.smallMetricDistance=1e-6,J.smallMetricDistanceSquared=1e-12,J.smallAngleRadians=1e-12,J.smallAngleRadiansSquared=1e-24,J.smallAngleDegrees=57e-12,J.smallAngleSeconds=2e-7,J.smallFraction=1e-10,J.smallFloatingPoint=1e-15,J.fullCircleRadiansMinusSmallAngle=2*Math.PI-J.smallAngleRadians,J.largeFractionResult=1e10,J.largeCoordinateResult=1e13,J.hugeCoordinate=1e12,function(t){t.almostEqual=function(t,e,i){return J.isSameCoordinate(t.x,e.x,i)&&J.isSameCoordinate(t.y,e.y,i)&&J.isSameCoordinate(t.z,e.z,i)}}(_||(_={}));class H{set(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}setZero(){this.x=0,this.y=0,this.z=0}constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}static isXAndY(t){return void 0!==t.x&&void 0!==t.y}static hasZ(t){return void 0!==t.z}static isXYAndZ(t){return this.isXAndY(t)&&this.hasZ(t)}static isAnyImmediatePointType(t){return K.isXAndY(t)||J.isNumberArray(t,2)}static accessX(t,e){return void 0!==t.x?t.x:Array.isArray(t)&&t.length>0&&Number.isFinite(t[0])?t[0]:e}static accessY(t,e){return void 0!==t.y?t.y:Array.isArray(t)&&t.length>1&&Number.isFinite(t[1])?t[1]:e}static accessZ(t,e){return void 0!==t.z?t.z:Array.isArray(t)&&t.length>2&&Number.isFinite(t[2])?t[2]:e}setFrom(t){void 0===t?this.setZero():H.isXAndY(t)?(this.x=t.x,this.y=t.y,this.z=H.hasZ(t)?t.z:0):(this.x=t[0],this.y=t[1],this.z=t[2])}setFromPoint3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}setFromVector3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}isAlmostEqual(t,e){return _.almostEqual(this,t,e)}isAlmostEqualXYZ(t,e,i,s){return J.isSameCoordinate(this.x,t,s)&&J.isSameCoordinate(this.y,e,s)&&J.isSameCoordinate(this.z,i,s)}isAlmostEqualPointPlusScaledVector(t,e,i,s){return J.isSameCoordinate(this.x,t.x+e.x*i,s)&&J.isSameCoordinate(this.y,t.y+e.y*i,s)&&J.isSameCoordinate(this.z,t.z+e.z*i,s)}isAlmostEqualXY(t,e){return J.isSameCoordinate(this.x,t.x,e)&&J.isSameCoordinate(this.y,t.y,e)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0,t[2]||0):t?this.set(t.x||0,t.y||0,t.z||0):this.set(0,0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return Math.sqrt(e*e+i*i+s*s)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y,s=t.z-this.z;return e*e+i*i+s*s}distanceXY(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquaredXY(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y),Math.abs(this.z-t.z))}at(t){return t<.5?this.x:t>1.5?this.z:this.y}setAt(t,e){t<.5?this.x=e:t>1.5?this.z=e:this.y=e}indexOfMaxAbs(){let t=0,e=Math.abs(this.x),i=Math.abs(this.y);return i>e&&(t=1,e=i),i=Math.abs(this.z),i>e&&(t=2),t}get isAlmostZero(){return J.isSmallMetricDistance(this.x)&&J.isSmallMetricDistance(this.y)&&J.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isAlmostEqualMetric(t){return this.maxDiff(t)<=J.smallMetricDistance}addInPlace(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtractInPlace(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}addScaledInPlace(t,e){this.x+=e*t.x,this.y+=e*t.y,this.z+=e*t.z}scaleInPlace(t){this.x*=t,this.y*=t,this.z*=t}addXYZInPlace(t=0,e=0,i=0){this.x+=t,this.y+=e,this.z+=i}cloneAsPoint3d(){return K.create(this.x,this.y,this.z)}vectorTo(t,e){return j.create(t.x-this.x,t.y-this.y,t.z-this.z,e)}scaledVectorTo(t,e,i){return j.create(e*(t.x-this.x),e*(t.y-this.y),e*(t.z-this.z),i)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}freeze(){return Object.freeze(this)}static x(t,e=0){return void 0===t?e:Array.isArray(t)?t[0]:void 0!==t.x?t.x:e}static y(t,e=0){return void 0===t?e:Array.isArray(t)?t[1]:void 0!==t.y?t.y:e}static z(t,e=0){return void 0===t?e:Array.isArray(t)?t[2]:void 0!==t.z?t.z:e}}class K extends H{constructor(t=0,e=0,i=0){super(t,e,i)}static fromJSON(t){const e=new K;return e.setFromJSON(t),e}clone(t){return K.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new K(t,e,i)}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),K.create(i,s,n,e)}return K.create(t.x,t.y,H.hasZ(t)?t.z:0,e)}static createFromPacked(t,e,i){const s=3*e;if(s>=0&&s+2<t.length)return K.create(t[s],t[s+1],t[s+2],i)}static createFromPackedXYZW(t,e,i){const s=4*e;if(s>=0&&s+3<t.length){const e=t[s+3];if(!J.isSmallMetricDistance(e)){const n=1/e;return K.create(n*t[s],n*t[s+1],n*t[s+2],i)}}}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new K(t[i],t[i+1],t[i+2]));return e}static createZero(t){return K.create(0,0,0,t)}crossProductToPoints(t,e,i){return j.createCrossProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i)}crossProductToPointsMagnitude(t,e){return J.crossProductMagnitude(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z)}tripleProductToPoints(t,e,i){return J.tripleProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i.x-this.x,i.y-this.y,i.z-this.z)}crossProductToPointsXY(t,e){return J.crossProductXYXY(t.x-this.x,t.y-this.y,e.x-this.x,e.y-this.y)}interpolate(t,e,i){if(t<=.5)return K.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),i);const s=t-1;return K.create(e.x+s*(e.x-this.x),e.y+s*(e.y-this.y),e.z+s*(e.z-this.z),i)}interpolateXYZ(t,e,i,s,n){return K.create(J.interpolate(this.x,t,s.x),J.interpolate(this.y,e,s.y),J.interpolate(this.z,i,s.z),n)}interpolatePerpendicularXY(t,e,i,s){s=s||new K;const n=e.minus(this);return this.interpolate(t,e,s),s.x-=i*n.y,s.y+=i*n.x,s}minus(t,e){return K.create(this.x-t.x,this.y-t.y,this.z-t.z,e)}plus(t,e){return K.create(this.x+t.x,this.y+t.y,this.z+t.z,e)}plusXYZ(t=0,e=0,i=0,s){return K.create(this.x+t,this.y+e,this.z+i,s)}plusScaled(t,e,i){return K.create(this.x+t.x*e,this.y+t.y*e,this.z+t.z*e,i)}plus2Scaled(t,e,i,s,n){return K.create(this.x+t.x*e+i.x*s,this.y+t.y*e+i.y*s,this.z+t.z*e+i.z*s,n)}plus3Scaled(t,e,i,s,n,r,o){return K.create(this.x+t.x*e+i.x*s+n.x*r,this.y+t.y*e+i.y*s+n.y*r,this.z+t.z*e+i.z*s+n.z*r,o)}static createScale(t,e,i){return K.create(t.x*e,t.y*e,t.z*e,i)}static createAdd2Scaled(t,e,i,s,n){return K.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return K.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)+(t.z-this.z)*(e.z-this.z)}fractionOfProjectionToLine(t,e,i=0){const s=t.distanceSquared(e);return s<J.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/s}}class j extends H{constructor(t=0,e=0,i=0){super(t,e,i)}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new j(t[i],t[i+1],t[i+2]));return e}clone(t){return j.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,s){return s?(s.x=t,s.y=e,s.z=i,s):new j(t,e,i)}static createCrossProduct(t,e,i,s,n,r,o){return j.create(e*r-i*n,i*s-t*r,t*n-e*s,o)}addCrossProductToTargetsInPlace(t,e,i,s,n,r,o,a,c){const h=s-t,l=n-e,d=r-i,u=o-t,f=a-e,g=c-i;this.x+=l*g-d*f,this.y+=d*u-h*g,this.z+=h*f-l*u}static createCrossProductToPoints(t,e,i,s){return j.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createUnitCrossProductToPoints(t,e,i,s){return j.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s).normalize()}static createPolar(t,e,i){return j.create(t*e.cos(),t*e.sin(),i)}static createSpherical(t,e,i){const s=i.cos();return j.create(s*t*e.cos(),s*t*e.sin(),t*i.sin())}static fromJSON(t){const e=new j;return e.setFromJSON(t),e}static createFrom(t,e){if(t instanceof Float64Array){let i=0,s=0,n=0;return t.length>0&&(i=t[0]),t.length>1&&(s=t[1]),t.length>2&&(n=t[2]),j.create(i,s,n,e)}return Array.isArray(t)?j.create(t[0],t[1],t.length>2?t[2]:0):j.create(t.x,t.y,H.hasZ(t)?t.z:0,e)}static createStartEnd(t,e,i){const s=H.accessZ(t,0),n=H.accessZ(e,0)-s;return i?(i.set(e.x-t.x,e.y-t.y,n),i):new j(e.x-t.x,e.y-t.y,n)}static createStartEndXYZXYZ(t,e,i,s,n,r,o){return this.create(s-t,n-e,r-i,o)}static createRotateVectorAroundVector(t,e,i){const s=e.normalize();if(s){const e=s.crossProduct(t);let n,r;return i?(n=i.cos(),r=i.sin()):(n=0,r=1),j.createAdd3Scaled(t,n,e,r,s,s.dotProduct(t)*(1-n))}}setStartEnd(t,e){this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z}static createZero(t){return j.create(0,0,0,t)}static unitX(t=1){return new j(t,0,0)}static unitY(t=1){return new j(0,t,0)}static unitZ(t=1){return new j(0,0,t)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalizeWithLength(t){const e=this.magnitude(),i=J.correctSmallFraction(e);return t=t||new j,{v:this.safeDivideOrNull(i,t),mag:e}}normalize(t){return this.normalizeWithLength(t).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(t=0,e=0,i=0,s){if(void 0===s?s=j.create(t,e,i):s.set(t,e,i),s.normalizeInPlace())return s}fractionOfProjectionToVector(t,e=0){const i=this.dotProduct(t),s=t.magnitudeSquared();return s<J.smallMetricDistanceSquared?e:i/s}negate(t){return(t=t||new j).x=-this.x,t.y=-this.y,t.z=-this.z,t}rotate90CCWXY(t){t=t||new j;const e=this.x,i=this.y;return t.x=-i,t.y=e,t.z=this.z,t}rotate90CWXY(t){t=t||new j;const e=this.x,i=this.y;return t.x=i,t.y=-e,t.z=this.z,t}unitPerpendicularXY(t){t=t||new j;const e=this.x,i=this.y;t.x=-i,t.y=e,t.z=0;const s=e*e+i*i;if(0!==s){const e=1/Math.sqrt(s);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),s=t.cos(),n=this.x,r=this.y;return(e=e||new j).x=n*s-r*i,e.y=n*i+r*s,e.z=this.z,e}rotate90Towards(t,e){const i=this.crossProduct(t).normalize();return i?i.crossProduct(this,e):void 0}rotate90Around(t,e){const i=t.normalize();return i?i.crossProduct(this).plusScaled(i,i.dotProduct(this),e):void 0}interpolate(t,e,i){if(i=i||new j,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y),i.z=this.z+t*(e.z-this.z);else{const s=t-1;i.x=e.x+s*(e.x-this.x),i.y=e.y+s*(e.y-this.y),i.z=e.z+s*(e.z-this.z)}return i}plus(t,e){return(e=e||new j).x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}minus(t,e){return(e=e||new j).x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}plusScaled(t,e,i){return(i=i||new j).x=this.x+t.x*e,i.y=this.y+t.y*e,i.z=this.z+t.z*e,i}plus2Scaled(t,e,i,s,n){return(n=n||new j).x=this.x+t.x*e+i.x*s,n.y=this.y+t.y*e+i.y*s,n.z=this.z+t.z*e+i.z*s,n}plus3Scaled(t,e,i,s,n,r,o){return(o=o||new j).x=this.x+t.x*e+i.x*s+n.x*r,o.y=this.y+t.y*e+i.y*s+n.y*r,o.z=this.z+t.z*e+i.z*s+n.z*r,o}static createAdd2Scaled(t,e,i,s,n){return j.create(t.x*e+i.x*s,t.y*e+i.y*s,t.z*e+i.z*s,n)}static createAdd2ScaledXYZ(t,e,i,s,n,r,o,a,c){return j.create(t*s+n*a,e*s+r*a,i*s+o*a,c)}static createAdd3Scaled(t,e,i,s,n,r,o){return j.create(t.x*e+i.x*s+n.x*r,t.y*e+i.y*s+n.y*r,t.z*e+i.z*s+n.z*r,o)}scale(t,e){return(e=e||new j).x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scaleToLength(t,e){const i=J.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}unitCrossProduct(t,e){return this.crossProduct(t,e).normalize(e)}unitCrossProductWithDefault(t,e,i,s,n){const r=this.crossProduct(t,n).normalize(n);return void 0===r?j.create(e,i,s,n):r}normalizeWithDefault(t,e,i,s){return this.normalize(s)||((s=j.create(t,e,i,s)).normalizeInPlace()?s:j.create(1,0,0,s))}tryNormalizeInPlace(t=J.smallFraction){const e=this.magnitude();return!(e<t||0===e||(this.scaleInPlace(1/e),0))}sizedCrossProduct(t,e,i){if((i=this.crossProduct(t,i)).tryNormalizeInPlace())return i.scaleInPlace(e),i}crossProductMagnitudeSquared(t){const e=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,s=this.x*t.y-this.y*t.x;return e*e+i*i+s*s}crossProductMagnitude(t){return Math.sqrt(this.crossProductMagnitudeSquared(t))}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dotProductAsXYAndZ(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)+this.z*(e.z-t.z)}dotProductStart3dEnd4d(t,e){const i=e.w;return this.x*(e.x-t.x*i)+this.y*(e.y-t.y*i)+this.z*(e.z-t.z*i)}crossProductStartEnd(t,e,i){return j.createCrossProduct(this.x,this.y,this.z,e.x-t.x,e.y-t.y,e.z-t.z,i)}crossProductStartEndXY(t,e){return J.crossProductXYXY(this.x,this.y,e.x-t.x,e.y-t.y)}dotProductStartEndXYZ(t,e,i,s){return this.x*(e-t.x)+this.y*(i-t.y)+this.z*(s-t.z)}dotProductStartEndXY(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}dotProductStartEndXYZW(t,e,i,s,n){if(J.isSmallMetricDistance(n))return 0;const r=1/n;return this.x*(r*e-t.x)+this.y*(r*i-t.y)+this.z*(r*s-t.z)}dotProductXY(t){return this.x*t.x+this.y*t.y}dotProductXYZ(t,e,i=0){return this.x*t+this.y*e+this.z*i}tripleProduct(t,e){return J.tripleProduct(this.x,this.y,this.z,t.x,t.y,t.z,e.x,e.y,e.z)}crossProductXY(t){return this.x*t.y-this.y*t.x}crossProduct(t,e){return j.createCrossProduct(this.x,this.y,this.z,t.x,t.y,t.z,e)}crossProductXYZ(t,e,i,s){return j.createCrossProduct(this.x,this.y,this.z,t,e,i,s)}radiansTo(t){return Math.atan2(this.crossProductMagnitude(t),this.dotProduct(t))}angleTo(t){return Z.createRadians(this.radiansTo(t))}angleFromPerpendicular(t){return Z.createAtan2(this.dotProduct(t),this.crossProductMagnitude(t))}angleToXY(t){return Z.createAtan2(this.crossProductXY(t),this.dotProductXY(t))}signedRadiansTo(t,e){const i=this.crossProduct(t),s=Math.atan2(i.magnitude(),this.dotProduct(t));return e.dotProduct(i)<0?-s:s}signedAngleTo(t,e){return Z.createRadians(this.signedRadiansTo(t,e))}planarRadiansTo(t,e){const i=e.dotProduct(e);if(0===i)return 0;const s=1/i,n=this.plusScaled(e,-this.dotProduct(e)*s),r=t.plusScaled(e,-t.dotProduct(e)*s);return n.signedRadiansTo(r,e)}planarAngleTo(t,e){return Z.createRadians(this.planarRadiansTo(t,e))}smallerUnorientedRadiansTo(t){const e=this.dotProduct(t),i=this.crossProductMagnitude(t);return Math.atan2(Math.abs(i),Math.abs(e))}smallerUnorientedAngleTo(t){return Z.createRadians(this.smallerUnorientedRadiansTo(t))}isParallelTo(t,e=!1,i=!1,s){const n=s?.radianSquaredTol??J.smallAngleRadiansSquared,r=s?.distanceSquaredTol??J.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();return o<r||a<r?i:!(this.dotProduct(t)<0&&!e)&&this.crossProductMagnitudeSquared(t)<=n*o*a}isPerpendicularTo(t,e=!1,i){const s=i?.radianSquaredTol??J.smallAngleRadiansSquared,n=i?.distanceSquaredTol??J.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<n||o<n)return e;const a=this.dotProduct(t);return a*a<=s*r*o}}class Q{isPointInPlane(t,e=J.smallMetricDistance){return Math.abs(this.altitude(t))<=e}classifyAltitude(t,e=J.smallMetricDistance){return J.split3Way01(this.altitude(t),e)}classifyAltitudeXYZ(t,e,i,s=J.smallMetricDistance){return J.split3Way01(this.altitudeXYZ(t,e,i),s)}getUnitNormal(t){return j.createNormalized(this.normalX(),this.normalY(),this.normalZ(),t)}getAnyPointOnPlane(t){return this.projectPointToPlane(K.create(0,0,0),t)}}class ${constructor(t){this._curIndex=-1,this._collection=t}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class tt{vectorIndexXYAndZ(t,e,i){const s=this.vectorXYAndZIndex(e,t,i);return s?.negate(s)}dotProductIndexIndexIndex(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length||i<0||i>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(this.getXAtUncheckedPointIndex(i)-s)+(this.getYAtUncheckedPointIndex(e)-n)*(this.getYAtUncheckedPointIndex(i)-n)+(this.getZAtUncheckedPointIndex(e)-r)*(this.getZAtUncheckedPointIndex(i)-r)}dotProductIndexIndexXYAndZ(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),n=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-s)*(i.x-s)+(this.getYAtUncheckedPointIndex(e)-n)*(i.y-n)+(this.getZAtUncheckedPointIndex(e)-r)*(i.z-r)}crossProductIndexIndexXYAndZ(t,e,i,s){if(t<0||t>=this.length||e<0||e>=this.length)return;const n=this.getXAtUncheckedPointIndex(t),r=this.getYAtUncheckedPointIndex(t),o=this.getZAtUncheckedPointIndex(t);return j.createCrossProduct(this.getXAtUncheckedPointIndex(e)-n,this.getYAtUncheckedPointIndex(e)-r,this.getZAtUncheckedPointIndex(e)-o,i.x-n,i.y-r,i.z-o,s)}distanceSquaredIndexXYAndZ(t,e){if(!(t<0||t>=this.length))return J.hypotenuseSquaredXYZ(e.x-this.getXAtUncheckedPointIndex(t),e.y-this.getYAtUncheckedPointIndex(t),e.z-this.getZAtUncheckedPointIndex(t))}cyclicIndex(t){return t%this.length}getRange(){const t=lt.createNull(),e=this.length,i=K.create();for(let s=0;s<e;s++)this.getPoint3dAtUncheckedPointIndex(s,i),t.extendPoint(i);return t}findOrderedDuplicates(t=J.smallMetricDistance){const e=t*t,i=[];if(this.length>1)for(let t=0;t<this.length-1;){let s=t+1;for(;s<this.length;++s){const n=this.distanceSquaredIndexIndex(t,s);if(!(void 0!==n&&n<e))break;i.push(s)}t=s}return i}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof j?j.createZero(e):K.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e),s.z+=t[e]*this.getZAtUncheckedPointIndex(e);return s}interpolateIndexIndex(t,e,i,s){if(!(t<0||t>=this.length||i<0||i>=this.length))return K.create(J.interpolate(this.getXAtUncheckedPointIndex(t),e,this.getXAtUncheckedPointIndex(i)),J.interpolate(this.getYAtUncheckedPointIndex(t),e,this.getYAtUncheckedPointIndex(i)),J.interpolate(this.getZAtUncheckedPointIndex(t),e,this.getZAtUncheckedPointIndex(i)),s)}get points(){return new $(this)}getArray(){const t=[];for(const e of this.points)t.push(e);return t}}class et extends tt{}class it extends et{constructor(t=8,e){super(),this._data=new Float64Array(3*t),this._xyzInUse=0,this._xyzCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?3*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?3*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%3!=0&&(n-=n%3)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/3,offset:s/3})}get length(){return this._xyzInUse}set length(t){this.resize(t,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyzCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(3*t),this.copyData(i,this._xyzInUse),this._xyzCapacity=t}}resize(t,e){t>=0&&t<this._xyzInUse?this._xyzInUse=t:t>this._xyzInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=t)}clone(t){return t?(t.length!==this.length&&t.clear(),t.resize(this.length)):t=new it(this.length),t.copyData(this._data,this.length),t._xyzInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/3:t.length;e=new it(i)}return e.pushFrom(t),e}push(t){this.pushXYZ(t.x,t.y,t.z)}pushAll(t){this.ensureCapacity(this._xyzInUse+t.length,!1);for(const e of t)this.push(e)}pushFrom(t){if(t instanceof K)this.pushXYZ(t.x,t.y,t.z);else if(t instanceof it)this.pushFromGrowableXYZArray(t);else if(t instanceof W)this.pushXYZ(t.x,t.y,0);else if(J.isNumberArray(t,4)||t instanceof Float64Array){const e=Math.trunc(t.length/3);this.ensureCapacity(this._xyzInUse+e,!1),this.copyData(t,e,this._xyzInUse),this._xyzInUse+=e}else if(J.isNumberArray(t,3))this.pushXYZ(t[0],t[1],t[2]);else if(J.isNumberArray(t,2))this.pushXYZ(t[0],t[1],0);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if(K.isXYAndZ(t))this.pushXYZ(t.x,t.y,t.z);else if(K.isXAndY(t))this.pushXYZ(t.x,t.y,0);else if(t instanceof tt){const e=t.length;this.ensureCapacity(this._xyzInUse+e,!1);for(let i=0;i<e;i++)this.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyzInUse>=t){this.ensureCapacity(this._xyzInUse+t,!1);for(let e=0;e<t;e++){const t=3*e;this.pushXYZ(this._data[t],this._data[t+1],this._data[t+2])}}}pushXYZ(t,e,i){this.ensureCapacity(this._xyzInUse+1);const s=3*this._xyzInUse;this._data[s]=t,this._data[s+1]=e,this._data[s+2]=i,this._xyzInUse++}shiftForward(t){if(t<=0)return;this.ensureCapacity(this._xyzInUse+t);const e=3*t,i=3*this._xyzInUse;this._data.copyWithin(e,0,i),this._xyzInUse+=t}pushFrontXYZ(t,e,i){this.shiftForward(1),this._data[0]=t,this._data[1]=e,this._data[2]=i}pushFront(t){this.pushFrontXYZ(t.x,t.y,t.z)}moveIndexToIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){let i=3*t,s=3*e;this._data[s++]=this._data[i++],this._data[s++]=this._data[i++],this._data[s]=this._data[i]}}pop(){this._xyzInUse>0&&this._xyzInUse--}isIndexValid(t){return!(t>=this._xyzInUse||t<0)}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(t,e){const i=3*t;return K.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint2dAtUncheckedPointIndex(t,e){const i=3*t;return W.create(this._data[i],this._data[i+1],e)}getPoint3dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return K.create(this._data[i],this._data[i+1],this._data[i+2],e)}}getXAtUncheckedPointIndex(t){const e=3*t;return this._data[e]}getYAtUncheckedPointIndex(t){const e=3*t;return this._data[e+1]}getZAtUncheckedPointIndex(t){const e=3*t;return this._data[e+2]}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return W.create(this._data[i],this._data[i+1],e)}}getVector3dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return j.create(this._data[i],this._data[i+1],this._data[i+2],e)}}transferFromGrowableXYZArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=3*t,n=3*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],this._data[s+2]=e._data[n+2],!0}return!1}pushFromGrowableXYZArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyzInUse+=e,e}if(t.isIndexValid(e)){const i=3*e;return this.pushXYZ(t._data[i],t._data[i+1],t._data[i+2]),1}return 0}front(t){if(0!==this._xyzInUse)return this.getPoint3dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyzInUse<1))return this.getPoint3dAtUncheckedPointIndex(this._xyzInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;let i=3*t;return this._data[i++]=e.x,this._data[i++]=e.y,this._data[i]=e.z,!0}setXYZAtCheckedPointIndex(t,e,i,s){if(!this.isIndexValid(t))return!1;let n=3*t;return this._data[n++]=e,this._data[n++]=i,this._data[n]=s,!0}getPoint3dArray(){const t=3*this._xyzInUse,e=[],i=this._data;for(let s=0;s<t;s+=3)e.push(K.create(i[s],i[s+1],i[s+2]));return e}static multiplyTransformInPlace(t,e){if(Array.isArray(e))for(const i of e)i.multiplyTransformInPlace(t);else e.multiplyTransformInPlace(t)}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y,a=n.z;let c=0,h=0,l=0;for(let t=0;t+2<=i;t+=3)c=e[t],h=e[t+1],l=e[t+2],e[t]=s[0]*c+s[1]*h+s[2]*l+r,e[t+1]=s[3]*c+s[4]*h+s[5]*l+o,e[t+2]=s[6]*c+s[7]*h+s[8]*l+a}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=3*r,i=3*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0,o=0;for(let t=0;t+2<=i;t+=3)n=e[t],r=e[t+1],o=e[t+2],e[t]=s[0]*n+s[1]*r+s[2]*o,e[t+1]=s[3]*n+s[4]*r+s[5]*o,e[t+2]=s[6]*n+s[7]*r+s[8]*o}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t){const e=this._data,i=this.float64Length;if(!t.computeCachedInverse(!0))return!1;const s=t.inverseCoffs,n=J.smallFloatingPoint;let r,o,a,c,h,l=0,d=0,u=0,f=0;for(let t=0;t+2<=i;t+=3)l=e[t],d=e[t+1],u=e[t+2],r=s[0]*l+s[3]*d+s[6]*u,o=s[1]*l+s[4]*d+s[7]*u,a=s[2]*l+s[5]*d+s[8]*u,h=r*r+o*o+a*a,h<n?(r=l,o=d,a=u,f++):Math.abs(h-1)>n&&(c=1/Math.sqrt(h),r*=c,o*=c,a*=c),e[t]=r,e[t+1]=o,e[t+2]=a;return 0===f}multiplyMatrix4dAndQuietRenormalizeMatrix4d(t){const e=this._data,i=this.float64Length,s=K.create();for(let n=0;n+2<=i;n+=3)t.multiplyXYZWQuietRenormalize(e[n],e[n+1],e[n+2],1,s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y,c=r.z;let h=0,l=0,d=0;for(let t=0;t+2<i;t+=3)h=e[t]-o,l=e[t+1]-a,d=e[t+2]-c,e[t]=n[0]*h+n[1]*l+n[2]*d,e[t+1]=n[3]*h+n[4]*l+n[5]*d,e[t+2]=n[6]*h+n[7]*l+n[8]*d;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+2<i;n+=3)t.extendTransformedXYZ(e,s[n],s[n+1],s[n+2]);else for(let e=0;e+2<i;e+=3)t.extendXYZ(s[e],s[e+1],s[e+2])}getRange(t){const e=lt.createNull();return this.extendRange(e,t),e}setRange(t,e){t.setNull(),this.extendRange(t,e)}sumLengths(){let t=0;const e=3*(this._xyzInUse-1),i=this._data;for(let s=0;s<e;s+=3)t+=J.hypotenuseXYZ(i[s+3]-i[s],i[s+4]-i[s+1],i[s+5]-i[s+2]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}isCloseToPlane(t,e=J.smallMetricDistance){const i=3*this._xyzInUse,s=this._data;for(let n=0;n<i;n+=3)if(Math.abs(t.altitudeXYZ(s[n],s[n+1],s[n+2]))>e)return!1;return!0}forceClosure(t=J.smallMetricDistance){const e=this.distanceIndexIndex(0,this.length-1);if(void 0===e);else if(e>t)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(e>0){const t=this._data.length-3;for(let e=0;e<3;e++)this._data[t+e]=this._data[e]}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=3,i*=3,K.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],n*r[t+2]+e*r[i+2],s)}}pushInterpolatedFromGrowableXYZArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=3,s*=3,this.pushXYZ(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1],n*r[e+2]+i*r[s+2])}}areaXY(){let t=0;const e=3*this._xyzInUse;if(e>6){const i=this._data[e-3],s=this._data[e-2];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=3;c<e;c+=3,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=J.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=3,e*=3,j.create(s[e]-s[t],s[e+1]-s[t+1],s[e+2]-s[t+2],i)}vectorXYAndZIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=3,j.create(s[e]-t.x,s[e+1]-t.y,s[e+2]-t.z,i)}}crossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;return J.crossProductXYZXYZ(a[r]-a[n],a[r+1]-a[n+1],a[r+2]-a[n+2],a[o]-a[n],a[o+1]-a[n+1],a[o+2]-a[n+2],s)}}evaluateUncheckedIndexDotProductXYZ(t,e,i,s){const n=3*t,r=this._data;return r[n]*e+r[n+1]*i+r[n+2]*s}evaluateUncheckedIndexPlaneAltitude(t,e){const i=3*t,s=this._data;return e.altitudeXYZ(s[i],s[i+1],s[i+2])}accumulateCrossProductIndexIndexIndex(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*t,r=3*e,o=3*i,a=this._data;s.addCrossProductToTargetsInPlace(a[n],a[n+1],a[n+2],a[r],a[r+1],a[r+2],a[o],a[o+1],a[o+2])}}accumulateScaledXYZ(t,e,i){if(this.isIndexValid(t)){const s=3*t,n=this._data;i.x+=e*n[s],i.y+=e*n[s+1],i.z+=e*n[s+2]}}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isIndexValid(e)&&this.isIndexValid(i)){const n=3*e,r=3*i,o=this._data;return J.crossProductXYZXYZ(o[n]-t.x,o[n+1]-t.y,o[n+2]-t.z,o[r]-t.x,o[r+1]-t.y,o[r+2]-t.z,s)}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=3*t;return J.hypotenuseXYZ(e.x-this._data[i],e.y-this._data[i+1],e.z-this._data[i+2])}}distanceSquaredIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return J.hypotenuseSquaredXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}distanceIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,s=3*e;return J.hypotenuseXYZ(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1],this._data[s+2]-this._data[i+2])}}static distanceBetweenPointsIn2Arrays(t,e,i,s){if(t.isIndexValid(e)&&i.isIndexValid(s)){const n=3*e,r=3*s;return J.hypotenuseXYZ(i._data[r]-t._data[n],i._data[r+1]-t._data[n+1],i._data[r+2]-t._data[n+2])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint3dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyzInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<3;n++){if(i=this._data[3*t+n],s=this._data[3*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[3*t+e]}addSteppedPoints(t,e,i,s){const n=t._data;let r=3*e;const o=3*t.length;let a=0;for(this.ensureCapacity(this._xyzInUse+s,!1);r>=0&&r+2<o&&a<s;)this.pushXYZ(n[r],n[r+1],n[r+2]),r+=3*i,a++}static distanceRangeBetweenCorrespondingPoints(t,e){const i=t._data,s=e._data,n=Math.min(t.length,e.length);let r,o=0;const a=dt.createNull();for(;o<n;)r=3*o,a.extendX(J.hypotenuseXYZ(i[r]-s[r],i[r+1]-s[r+1],i[r+2]-s[r+2])),o++;return a}static removeClosure(t,e=J.smallMetricDistance){for(;t.length>1&&t.distanceIndexIndex(0,t.length-1)<e;)t.pop()}fillLocalXYTriangleFrame(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){let n=3*t;const r=this._data,o=r[n++],a=r[n++],c=r[n++];n=3*e;const h=r[n++]-o,l=r[n++]-a,d=r[n++]-c;n=3*i;const u=r[n++]-o,f=r[n++]-a,g=r[n++]-c;return(s=ft.createRowValues(h,u,0,o,l,f,0,a,d,g,1,c,s)).computeCachedInverse()?s:void 0}}mapComponent(t,e){const i=this._data.length;let s;for(let n=0;n+2<i;n+=3)s=e(this._data[n],this._data[n+1],this._data[n+2]),this._data[n+t]=s}}class st{startChain(t,e){}handleXYZ(t,e,i){}endChain(t,e){}}class nt extends st{handleXYZ(t,e,i){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,t,e,i),this._x0=t,this._y0=e,this._z0=i}startChain(t,e){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(t,e,i,s,n,r){}}class rt extends st{startChain(t,e){this._currentData=void 0}handleXYZ(t,e,i){this._currentData||(this._currentData=new it),this._currentData.pushXYZ(t,e,i)}endChain(t,e){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const t=this._pointArrays;return this._pointArrays=void 0,t}}class ot extends st{constructor(){super(...arguments),this._range=lt.createNull()}handleXYZ(t,e,i){this._range||(this._range=lt.createNull()),this._range.extendXYZ(t,e,i)}claimResult(){const t=this._range;return this._range=void 0,t||lt.createNull()}}class at{constructor(t){this._xyzFunction=t,this._resultStack=[],this._resultStack.push([])}startChain(t,e){this._resultStack.push([])}handleXYZ(t,e,i){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(t,e,i))}endChain(t,e){const i=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(i)}claimResult(){const t=this._resultStack[0];return 1===t.length?t[0]:t}}class ct{static streamXYZ(t,e){let i=0;if(Array.isArray(t))if(t.length>0&&K.isAnyImmediatePointType(t[0])){e.startChain(t,!0);for(const s of t){const t=K.accessX(s),n=K.accessY(s),r=K.accessZ(s,0);void 0!==t&&void 0!==n&&e.handleXYZ(t,n,r),i++}e.endChain(t,!0)}else{e.startChain(t,!1);for(const s of t)i+=this.streamXYZ(s,e);e.endChain(t,!1)}else if(t instanceof tt){e.startChain(t,!0);const s=ct._workPoint=K.create(0,0,0,ct._workPoint);for(let n=0;n<t.length;n++)t.getPoint3dAtCheckedPointIndex(n,s),i++,e.handleXYZ(s.x,s.y,s.z);e.endChain(t,!0)}return i}}class ht{static npcScaleFactor(t,e){return e<=t?0:1/(e-t)}static isExtremeValue(t){return Math.abs(t)>=ht._EXTREME_POSITIVE}static isExtremePoint3d(t){return ht.isExtremeValue(t.x)||ht.isExtremeValue(t.y)||ht.isExtremeValue(t.z)}static isExtremePoint2d(t){return ht.isExtremeValue(t.x)||ht.isExtremeValue(t.y)}static rangeToRangeAbsoluteDistance(t,e,i,s){return e<t||s<i?ht._EXTREME_POSITIVE:s<t?t-s:s<=e||i<=e?0:i-e}static coordinateToRangeAbsoluteDistance(t,e,i){return i<e?ht._EXTREME_POSITIVE:t<e?e-t:t>i?t-i:0}static multiplyIfPositive(t,e,i=0){return t>0?e*t:i}}ht._EXTREME_POSITIVE=1e200,ht._EXTREME_NEGATIVE=-1e200;class lt extends ht{setNull(){this.low.x=ht._EXTREME_POSITIVE,this.low.y=ht._EXTREME_POSITIVE,this.low.z=ht._EXTREME_POSITIVE,this.high.x=ht._EXTREME_NEGATIVE,this.high.y=ht._EXTREME_NEGATIVE,this.high.z=ht._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z)}toFloat64Array(){return lt.toFloat64Array(this)}static fromFloat64Array(t){if(6!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3],t[4],t[5])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=ht._EXTREME_POSITIVE,e=ht._EXTREME_POSITIVE,i=ht._EXTREME_POSITIVE,s=ht._EXTREME_NEGATIVE,n=ht._EXTREME_NEGATIVE,r=ht._EXTREME_NEGATIVE){super(),this.low=K.create(t,e,i),this.high=K.create(s,n,r)}isAlmostEqual(t,e){return this.low.isAlmostEqual(t.low,e)&&this.high.isAlmostEqual(t.high,e)||this.isNull&&t.isNull}setFrom(t){this.low.setFrom(t.low),this.high.setFrom(t.high)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYZXYZOrCorrectToNull(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z,e)}setFromJSON(t){if(!t)return;if(this.setNull(),Array.isArray(t)){const e=K.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=K.fromJSON(t.low),i=K.fromJSON(t.high);ht.isExtremePoint3d(e)||ht.isExtremePoint3d(i)||(this.extendPoint(e),this.extendPoint(i))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(t){const e=new this;return e.setFromJSON(t),e}setDirect(t,e,i,s,n,r,o){this.low.x=t,this.low.y=e,this.low.z=i,this.high.x=s,this.high.y=n,this.high.z=r,o&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.low.z+t.z,this.high.x+t.x,this.high.y+t.y,this.high.z+t.z,!1),e}static createNull(t){return(t=t||new this).setNull(),t}extend(...t){let e;for(e of t)this.extendPoint(e)}static create(...t){const e=lt.createNull();let i;for(i of t)e.extendPoint(i);return e}static createFromVariantData(t){const e=new ot;return ct.streamXYZ(t,e),e.claimResult()}static createTransformed(t,...e){const i=this.createNull();let s;for(s of e)i.extendTransformedXYZ(t,s.x,s.y,s.z);return i}static createTransformedArray(t,e){const i=this.createNull();return i.extendArray(e,t),i}static createInverseTransformedArray(t,e){const i=this.createNull();return i.extendInverseTransformedArray(e,t),i}setXYZ(t,e,i){this.low.x=this.high.x=t,this.low.y=this.high.y=e,this.low.z=this.high.z=i}static createXYZ(t,e,i,s){return(s=s||new this).setDirect(t,e,i,t,e,i,!1),s}static createXYZXYZ(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!1),o}static createXYZXYZOrCorrectToNull(t,e,i,s,n,r,o){return o=o||new this,t>s||e>n||i>r?this.createNull(o):(o.setDirect(Math.min(t,s),Math.min(e,n),Math.min(i,r),Math.max(t,s),Math.max(e,n),Math.max(i,r),!0),o)}static createRange2d(t,e=0,i){const s=i||new this;return s.setNull(),s.extendXYZ(t.low.x,t.low.y,e),s.extendXYZ(t.high.x,t.high.y,e),s}static createArray(t,e){let i;for(i of((e=e||new this).setNull(),t))e.extendPoint(i);return e}extendArray(t,e){if(Array.isArray(t))if(e)for(const i of t)this.extendTransformedXYZ(e,i.x,i.y,i.z);else for(const e of t)this.extendXYZ(e.x,e.y,e.z);else if(e)for(let i=0;i<t.length;i++)this.extendTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i));else for(let e=0;e<t.length;e++)this.extendXYZ(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e))}extendInverseTransformedArray(t,e){if(Array.isArray(t))for(const i of t)this.extendInverseTransformedXYZ(e,i.x,i.y,i.z);else for(let i=0;i<t.length;i++)this.extendInverseTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}extendTransformedXYZ(t,e,i,s){const n=t.origin,r=t.matrix.coffs;this.extendXYZ(n.x+r[0]*e+r[1]*i+r[2]*s,n.y+r[3]*e+r[4]*i+r[5]*s,n.z+r[6]*e+r[7]*i+r[8]*s)}extendTransformedXYZW(t,e,i,s,n){const r=t.origin,o=t.matrix.coffs;this.extendXYZW(r.x*n+o[0]*e+o[1]*i+o[2]*s,r.y*n+o[3]*e+o[4]*i+o[5]*s,r.z*n+o[6]*e+o[7]*i+o[8]*s,n)}extendInverseTransformedXYZ(t,e,i,s){const n=t.origin;if(!t.matrix.computeCachedInverse(!0))return!1;const r=t.matrix.inverseCoffs,o=e-n.x,a=i-n.y,c=s-n.z;return this.extendXYZ(r[0]*o+r[1]*a+r[2]*c,r[3]*o+r[4]*a+r[5]*c,r[6]*o+r[7]*a+r[8]*c),!0}extendTransformTransformedXYZ(t,e,i,s,n){const r=e.origin,o=e.matrix.coffs;this.extendTransformedXYZ(t,r.x+o[0]*i+o[1]*s+o[2]*n,r.y+o[3]*i+o[4]*s+o[5]*n,r.z+o[6]*i+o[7]*s+o[8]*n)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y||t.high.z<t.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}zLength(){const t=this.high.z-this.low.z;return t>0?t:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i=0,s){return this.low.interpolateXYZ(t,e,i,this.high,s)}localXYZToWorld(t,e,i,s){if(!this.isNull)return this.low.interpolateXYZ(t,e,i,this.high,s)}localToWorld(t,e){return this.localXYZToWorld(t.x,t.y,t.z,e)}localToWorldArrayInPlace(t){if(this.isNull)return!1;for(const e of t)this.low.interpolateXYZ(e.x,e.y,e.z,this.high,e);return!1}worldToLocal(t,e){const i=ht.npcScaleFactor(this.low.x,this.high.x),s=ht.npcScaleFactor(this.low.y,this.high.y),n=ht.npcScaleFactor(this.low.z,this.high.z);if(0!==i&&0!==s&&0!==n)return K.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,(t.z-this.low.z)*n,e)}worldToLocalArrayInPlace(t){const e=ht.npcScaleFactor(this.low.x,this.high.x),i=ht.npcScaleFactor(this.low.y,this.high.y),s=ht.npcScaleFactor(this.low.z,this.high.z);if(0===e||0===i||0===s)return!1;for(const n of t)K.create((n.x-this.low.x)*e,(n.y-this.low.y)*i,(n.z-this.low.z)*s,n);return!0}corners(t){return void 0!==t&&t.length>=8?(t[0].set(this.low.x,this.low.y,this.low.z),t[1].set(this.high.x,this.low.y,this.low.z),t[2].set(this.low.x,this.high.y,this.low.z),t[3].set(this.high.x,this.high.y,this.low.z),t[4].set(this.low.x,this.low.y,this.high.z),t[5].set(this.high.x,this.low.y,this.high.z),t[6].set(this.low.x,this.high.y,this.high.z),t[7].set(this.high.x,this.high.y,this.high.z),t.length=8,t):[K.create(this.low.x,this.low.y,this.low.z),K.create(this.high.x,this.low.y,this.low.z),K.create(this.low.x,this.high.y,this.low.z),K.create(this.high.x,this.high.y,this.low.z),K.create(this.low.x,this.low.y,this.high.z),K.create(this.high.x,this.low.y,this.high.z),K.create(this.low.x,this.high.y,this.high.z),K.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(t){return 0===t?[0,4,6,2]:1===t?[1,3,7,5]:2===t?[0,1,5,4]:3===t?[3,2,6,7]:4===t?[0,2,3,1]:[4,5,7,6]}rectangleXY(t=0,e=!0,i=!0){if(this.isNull)return;const s=[this.fractionToPoint(0,0,t),this.fractionToPoint(1,0,t),this.fractionToPoint(1,1,t),this.fractionToPoint(0,1,t)];return i&&s.push(s[0].clone()),e||s.reverse(),s}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return J.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return J.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return J.isSmallMetricDistance(this.zLength())}containsXYZ(t,e,i){return t>=this.low.x&&e>=this.low.y&&i>=this.low.z&&t<=this.high.x&&e<=this.high.y&&i<=this.high.z}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXYZ(t.x,t.y,t.z)}containsPointXY(t){return t.x>=this.low.x&&t.y>=this.low.y&&t.x<=this.high.x&&t.y<=this.high.y}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.low.z>=this.low.z&&t.high.x<=this.high.x&&t.high.y<=this.high.y&&t.high.z<=this.high.z}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||this.low.z>t.high.z||t.low.x>this.high.x||t.low.y>this.high.y||t.low.z>this.high.z)}intersectsRangeXY(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?ht._EXTREME_POSITIVE:Math.min(J.hypotenuseXYZ(ht.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),ht.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y),ht.coordinateToRangeAbsoluteDistance(t.z,this.low.z,this.high.z)),ht._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(J.hypotenuseXYZ(ht.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),ht.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y),ht.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,t.low.z,t.high.z)),ht._EXTREME_POSITIVE)}extendXYZ(t,e,i){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e),i<this.low.z&&(this.low.z=i),i>this.high.z&&(this.high.z=i)}extendInterpolated(t,e,i){if(e<.5)this.extendXYZ(t.x+e*(i.x-t.x),t.y+e*(i.y-t.y),t.z+e*(i.z-t.z));else{const s=1-e;this.extendXYZ(i.x+s*(t.x-i.x),i.y+s*(t.y-i.y),i.z+s*(t.z-i.z))}}extendXOnly(t){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t)}extendYOnly(t){t<this.low.y&&(this.low.y=t),t>this.high.y&&(this.high.y=t)}extendZOnly(t){t<this.low.z&&(this.low.z=t),t>this.high.z&&(this.high.z=t)}extendSingleAxis(t,e){e===p.X&&this.extendXOnly(t),e===p.Y&&this.extendYOnly(t),e===p.Z&&this.extendZOnly(t)}extendXYZW(t,e,i,s){J.isSmallMetricDistance(s)||this.extendXYZ(t/s,e/s,i/s)}extendPoint(t,e){e?this.extendTransformedXYZ(e,t.x,t.y,t.z):this.extendXYZ(t.x,t.y,t.z)}extendTransformedPoint(t,e){this.extendTransformedXYZ(t,e.x,e.y,e.z)}extendRange(t){lt.isNull(t)||(this.extendXYZ(t.low.x,t.low.y,t.low.z),this.extendXYZ(t.high.x,t.high.y,t.high.z))}extendWhenLarger(t,e){lt.isNull(t)||lt.isNull(this)||(this.high.x+=ht.multiplyIfPositive(this.high.x-t.high.x,e),this.high.y+=ht.multiplyIfPositive(this.high.y-t.high.y,e),this.high.z+=ht.multiplyIfPositive(this.high.z-t.high.z,e),this.low.x-=ht.multiplyIfPositive(t.low.x-this.low.x,e),this.low.y-=ht.multiplyIfPositive(t.low.y-this.low.y,e),this.low.z-=ht.multiplyIfPositive(t.low.z-this.low.z,e))}intersect(t,e){return this.intersectsRange(t)?lt.createXYZXYZOrCorrectToNull(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.max(this.low.z,t.low.z),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),Math.min(this.high.z,t.high.z),e):lt.createNull(e)}union(t,e){return this.isNull?t.clone(e):t.isNull?this.clone(e):lt.createXYZXYZOrCorrectToNull(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.min(this.low.z,t.low.z),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),Math.max(this.high.z,t.high.z),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y),s=.5*(this.low.z+this.high.z);this.high.x=J.interpolate(e,t,this.high.x),this.high.y=J.interpolate(i,t,this.high.y),this.high.z=J.interpolate(s,t,this.high.z),this.low.x=J.interpolate(e,t,this.low.x),this.low.y=J.interpolate(i,t,this.low.y),this.low.z=J.interpolate(s,t,this.low.z)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.low.z-t,this.high.x+t,this.high.y+t,this.high.z+t,!0)}getLocalToWorldTransform(t){return ft.createOriginAndMatrix(K.create(this.low.x,this.low.y,this.low.z),pt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),t)}getNpcToWorldRangeTransform(t){const e=this.getLocalToWorldTransform(t),i=e.matrix;return 0===i.coffs[0]&&(i.coffs[0]=1),0===i.coffs[4]&&(i.coffs[4]=1),0===i.coffs[8]&&(i.coffs[8]=1),e}ensureMinLengths(t=.001){let e=(t-this.xLength())/2;e>0&&(this.low.x-=e,this.high.x+=e),e=(t-this.yLength())/2,e>0&&(this.low.y-=e,this.high.y+=e),e=(t-this.zLength())/2,e>0&&(this.low.z-=e,this.high.z+=e)}}class dt extends ht{setNull(){this.low=ht._EXTREME_POSITIVE,this.high=ht._EXTREME_NEGATIVE}setDirect(t,e,i=!1){this.low=t,this.high=e,i&&t>e&&this.setNull()}constructor(t=ht._EXTREME_POSITIVE,e=ht._EXTREME_NEGATIVE){super(),this.low=t,this.high=e,this.setDirect(t,e)}isAlmostEqual(t){return J.isSameCoordinate(this.low,t.low)&&J.isSameCoordinate(this.high,t.high)||this.isNull&&t.isNull}setFrom(t){this.low=t.low,this.high=t.high}setFromJSON(t){if(this.setNull(),Array.isArray(t)){let e;for(e of t)Number.isFinite(e)&&this.extendX(e)}else void 0!==t.low&&Number.isFinite(t.low)&&void 0!==t.high&&Number.isFinite(t.high)&&(this.extendX(t.low),this.extendX(t.high))}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(t){return(t=t||new this.constructor).setDirect(this.low,this.high),t}static createFrom(t,e){return(e=e||new this).setDirect(t.low,t.high),e}static createNull(t){return(t=t||new this).setNull(),t}cloneTranslated(t,e){return(e=e||this.clone()).isNull||(e.low+=t,e.high+=t),e}setX(t){this.low=this.high=t}static createX(t,e){return(e=e||new this).setDirect(t,t),e}setXXUnordered(t,e){t<=e?(this.low=t,this.high=e):(this.low=e,this.high=t)}get isExact01(){return 0===this.low&&1===this.high}static createXX(t,e,i){return(i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i}static createXXOrCorrectToNull(t,e,i){return e<t?dt.createNull(i):((i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendX(i);return e}extendArray(t){let e;for(e of t)this.extendX(e)}extendArraySubset(t,e,i){const s=e+i;for(let i=e;i<s;i++)this.extendX(t[i])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const t=this.high-this.low;return t>0?t:0}fractionToPoint(t){return J.interpolate(this.low,t,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return J.isSmallMetricDistance(this.length())}containsX(t){return t>=this.low&&t<=this.high}containsRange(t){return t.low>=this.low&&t.high<=this.high}intersectsRange(t){return!(this.low>t.high||t.low>this.high)}intersectRangeXXInPlace(t,e){e<t||e<this.low||t>this.high?this.setNull():(e<this.high&&(this.high=e),t>this.low&&(this.low=t))}distanceToRange(t){return ht.rangeToRangeAbsoluteDistance(this.low,this.high,t.low,t.high)}distanceToX(t){return this.isNull?ht._EXTREME_POSITIVE:ht.coordinateToRangeAbsoluteDistance(t,this.low,this.high)}extendX(t){t<this.low&&(this.low=t),t>this.high&&(this.high=t)}extendRange(t){t.isNull||(this.extendX(t.low),this.extendX(t.high))}extendLow(t){return!!(this.isNull||t<this.low)&&(this.low=t,!0)}extendHigh(t){return!!(this.isNull||t>this.high)&&(this.high=t,!0)}intersect(t,e){return this.intersectsRange(t)?dt.createXXOrCorrectToNull(Math.max(this.low,t.low),Math.min(this.high,t.high),e):dt.createNull(e)}union(t,e){return dt.createXX(Math.min(this.low,t.low),Math.max(this.high,t.high),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low+this.high);this.high=J.interpolate(e,t,this.high),this.low=J.interpolate(e,t,this.low)}}expandInPlace(t){this.setDirect(this.low-t,this.high+t,!0)}clipLinearMapToInterval(t,e,i,s){if(s<i||this.high<this.low)return!1;const n=J.conditionalDivideFraction(i-t,e),r=J.conditionalDivideFraction(s-t,e);return void 0===n||void 0===r?i<=t&&t<=s||(this.setNull(),!1):(n<r?(n>this.low&&(this.low=n),r<this.high&&(this.high=r)):(n<this.high&&(this.high=n),r>this.low&&(this.low=r)),!(this.high<this.low&&(this.setNull(),1)))}}class ut extends ht{setNull(){this.low.x=ht._EXTREME_POSITIVE,this.low.y=ht._EXTREME_POSITIVE,this.high.x=ht._EXTREME_NEGATIVE,this.high.y=ht._EXTREME_NEGATIVE}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.high.x,t.high.y)}toFloat64Array(){return ut.toFloat64Array(this)}static fromFloat64Array(t){if(4!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=ut._EXTREME_POSITIVE,e=ut._EXTREME_POSITIVE,i=ut._EXTREME_NEGATIVE,s=ut._EXTREME_NEGATIVE){super(),this.low=W.create(t,e),this.high=W.create(i,s)}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.set(t.low.x,t.low.y),this.high.set(t.high.x,t.high.y)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYXYOrCorrectToNull(t.low.x,t.low.y,t.high.x,t.high.y,e)}setFromJSON(t){if(this.setNull(),Array.isArray(t)){const e=W.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=W.fromJSON(t.low),i=W.fromJSON(t.high);ht.isExtremePoint2d(e)||ht.isExtremePoint2d(i)||(this.extendPoint(e),this.extendPoint(i))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}setDirect(t,e,i,s,n){this.low.x=t,this.low.y=e,this.high.x=i,this.high.y=s,n&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),t}static createNull(t){return(t=t||new this).setNull(),t}setXY(t,e){this.low.x=this.high.x=t,this.low.y=this.high.y=e}static createXY(t,e,i){return(i=i||new this).setDirect(t,e,t,e,!1),i}static createXYXY(t,e,i,s,n){return(n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!1),n}static createXYXYXY(t,e,i,s,n,r,o){return(o=o||new this).setDirect(Math.min(t,i,n),Math.min(e,s,r),Math.max(t,i,n),Math.max(e,s,r),!1),o}static createXYXYOrCorrectToNull(t,e,i,s,n){return t>i||e>s?this.createNull(n):((n=n||new this).setDirect(Math.min(t,i),Math.min(e,s),Math.max(t,i),Math.max(e,s),!0),n)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendPoint(i);return e}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i){return this.low.interpolateXY(t,e,this.high,i)}corners3d(t=!1,e=0){return t?[K.create(this.low.x,this.low.y,e),K.create(this.high.x,this.low.y,e),K.create(this.high.x,this.high.y,e),K.create(this.low.x,this.high.y,e),K.create(this.low.x,this.low.y,e)]:[K.create(this.low.x,this.low.y,e),K.create(this.high.x,this.low.y,e),K.create(this.low.x,this.high.y,e),K.create(this.high.x,this.high.y,e)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return J.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return J.isSmallMetricDistance(this.yLength())}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXY(t.x,t.y)}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.high.x<=this.high.x&&t.high.y<=this.high.y}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?ut._EXTREME_POSITIVE:Math.min(J.hypotenuseXY(ht.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),ht.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y)),ut._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(J.hypotenuseXY(ht.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),ht.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y)),ut._EXTREME_POSITIVE)}extendXY(t,e){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e)}extendTransformedXY(t,e,i){const s=t.multiplyComponentXYZ(0,e,i,0),n=t.multiplyComponentXYZ(1,e,i,0);this.extendXY(s,n)}extendPoint(t){this.extendXY(t.x,t.y)}extendRange(t){ut.isNull(t)||(this.extendXY(t.low.x,t.low.y),this.extendXY(t.high.x,t.high.y))}intersect(t,e){return this.intersectsRange(t)?ut.createXYXY(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),e):ut.createNull(e)}union(t,e){return this.isNull?ut.createFrom(t,e):ut.isNull(t)?this.clone(e):ut.createXYXY(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y);this.high.x=J.interpolate(e,t,this.high.x),this.high.y=J.interpolate(i,t,this.high.y),this.low.x=J.interpolate(e,t,this.low.x),this.low.y=J.interpolate(i,t,this.low.y)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.high.x+t,this.high.y+t,!0)}worldToLocal(t,e){const i=ht.npcScaleFactor(this.low.x,this.high.x),s=ht.npcScaleFactor(this.low.y,this.high.y);if(0!==i&&0!==s)return W.create((t.x-this.low.x)*i,(t.y-this.low.y)*s,e)}}class ft{constructor(t,e){this._origin=t,this._matrix=e}static get identity(){return void 0===this._identity&&(this._identity=ft.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(t){this._origin.setFrom(t._origin),this._matrix.setFrom(t._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(t){if(t){if(t instanceof Object&&t.origin&&t.matrix)return this._origin.setFromJSON(t.origin),void this._matrix.setFromJSON(t.matrix);if(J.isArrayOfNumberArray(t,3,4)){const e=t;return this._matrix.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2]),void this._origin.set(e[0][3],e[1][3],e[2][3])}if(J.isNumberArray(t,12)){const e=t;return this._matrix.setRowValues(e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]),void this._origin.set(e[3],e[7],e[11])}}this.setIdentity()}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.matrix.isAlmostEqual(t.matrix)}isAlmostEqualAllowZRotation(t){return this._origin.isAlmostEqual(t._origin)&&this._matrix.isAlmostEqualAllowZRotation(t._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(t){const e=ft.createIdentity();return e.setFromJSON(t),e}clone(t){return t?(t._matrix.setFrom(this._matrix),t._origin.setFrom(this._origin),t):new ft(K.createFrom(this._origin),this._matrix.clone())}cloneRigid(t=g.XYZ){const e=pt.createRigidFromMatrix3d(this.matrix,t);if(e)return new ft(this.origin.cloneAsPoint3d(),e)}static createRefs(t,e,i){return t||(t=K.createZero()),i?(i._origin=t,i._matrix=e,i):new ft(t,e)}static createRowValues(t,e,i,s,n,r,o,a,c,h,l,d,u){return u?(u._origin.set(s,a,d),u._matrix.setRowValues(t,e,i,n,r,o,c,h,l),u):new ft(K.create(s,a,d),pt.createRowValues(t,e,i,n,r,o,c,h,l))}static createZero(t){return ft.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,t)}static createTranslationXYZ(t=0,e=0,i=0,s){return ft.createRefs(j.create(t,e,i),pt.createIdentity(),s)}static createTranslation(t,e){return ft.createRefs(t,pt.createIdentity(),e)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return K.createFrom(this._origin)}getTranslation(){return j.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(t){return t?(t._origin.setZero(),t._matrix.setIdentity(),t):ft.createRefs(K.createZero(),pt.createIdentity())}static createOriginAndMatrix(t,e,i){return i?(i._origin.setFromPoint3d(t),i._matrix.setFrom(e),i):ft.createRefs(t?t.cloneAsPoint3d():K.createZero(),void 0===e?pt.createIdentity():e.clone(),i)}setOriginAndMatrixColumns(t,e,i,s){void 0!==t&&this._origin.setFrom(t),this._matrix.setColumns(e,i,s)}static createOriginAndMatrixColumns(t,e,i,s,n){return n?n.setOriginAndMatrixColumns(t,e,i,s):n=ft.createRefs(j.createFrom(t),pt.createColumns(e,i,s)),n}static createRigidFromOriginAndColumns(t,e,i,s,n){const r=pt.createRigidFromColumns(e,i,s,n?n._matrix:void 0);if(r)return n?(n._origin.setFrom(t),n):((n=ft.createRefs(void 0,r))._origin.setFromPoint3d(t),n)}static createFixedPointAndMatrix(t,e,i){if(t){const s=pt.xyzMinusMatrixTimesXYZ(t,e,t);return ft.createRefs(s,e.clone(),i)}return ft.createRefs(void 0,e.clone())}static createMatrixPickupPutdown(t,e,i,s){const n=pt.xyzMinusMatrixTimesXYZ(i,t,e);return ft.createRefs(n,t.clone(),s)}static createScaleAboutPoint(t,e,i){const s=pt.createScale(e,e,e),n=pt.xyzMinusMatrixTimesXYZ(t,s,t);return ft.createRefs(n,s,i)}multiplyPoint2d(t,e){return pt.xyPlusMatrixTimesXY(this._origin,this._matrix,t,e)}multiplyPoint3d(t,e){return pt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t,e)}multiplyXYAndZInPlace(t){return pt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,t)}multiplyXYZ(t,e,i=0,s){return pt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,t,e,i,s)}multiplyComponentXYZ(t,e,i,s=0){const n=this._matrix.coffs,r=3*t;return this.origin.at(t)+n[r]*e+n[r+1]*i+n[r+2]*s}multiplyComponentXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=3*t;return this.origin.at(t)*n+r[o]*e+r[o+1]*i+r[o+2]*s}multiplyXYZW(t,e,i,s,n){return pt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZWToFloat64Array(t,e,i,s,n){return pt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s,n)}multiplyXYZToFloat64Array(t,e,i,s){return pt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,s)}multiplyTransposeXYZW(t,e,i,s,n){const r=this._matrix.coffs,o=this._origin;return bt.create(t*r[0]+e*r[3]+i*r[6],t*r[1]+e*r[4]+i*r[7],t*r[2]+e*r[5]+i*r[8],t*o.x+e*o.y+i*o.z+s,n)}multiplyPoint3dArrayInPlace(t){let e;for(e of t)pt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,e,e)}multiplyPoint3dArrayArrayInPlace(t){for(const e of t)this.multiplyPoint3dArrayInPlace(e)}multiplyInversePoint3d(t,e){return this._matrix.multiplyInverseXYZAsPoint3d(t.x-this._origin.x,t.y-this._origin.y,t.z-this._origin.z,e)}multiplyInversePoint4d(t,e){const i=t.w;return this._matrix.multiplyInverseXYZW(t.x-i*this.origin.x,t.y-i*this.origin.y,t.z-i*this.origin.z,i,e)}multiplyInverseXYZ(t,e,i,s){return this._matrix.multiplyInverseXYZAsPoint3d(t-this._origin.x,e-this._origin.y,i-this._origin.z,s)}computeCachedInverse(t=!0){return this._matrix.computeCachedInverse(t)}static matchArrayLengths(t,e,i){const s=t.length,n=e.length;if(s>n)for(let t=n;t<s;t++)e.push(i());else n>s&&(e.length=s);return s}multiplyInversePoint3dArray(t,e){if(!this._matrix.computeCachedInverse(!0))return;const i=this.origin.x,s=this.origin.y,n=this.origin.z;if(e){const r=ft.matchArrayLengths(t,e,K.createZero);for(let o=0;o<r;o++)this._matrix.multiplyInverseXYZAsPoint3d(t[o].x-i,t[o].y-s,t[o].z-n,e[o]);return e}e=[];for(const r of t)e.push(this._matrix.multiplyInverseXYZAsPoint3d(r.x-i,r.y-s,r.z-n));return e}multiplyInversePoint3dArrayInPlace(t){if(!this._matrix.computeCachedInverse(!0))return!1;for(const e of t)this._matrix.multiplyInverseXYZAsPoint3d(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,e);return!0}multiplyPoint2dArray(t,e){if(e){const i=ft.matchArrayLengths(t,e,W.createZero);for(let s=0;s<i;s++)pt.xyPlusMatrixTimesXY(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(pt.xyPlusMatrixTimesXY(this._origin,this._matrix,i));return e}multiplyPoint3dArray(t,e){if(e){const i=ft.matchArrayLengths(t,e,K.createZero);for(let s=0;s<i;s++)pt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t[s],e[s]);return e}e=[];for(const i of t)e.push(pt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,i));return e}multiplyVector(t,e){return this._matrix.multiplyVector(t,e)}multiplyVectorInPlace(t){this._matrix.multiplyVectorInPlace(t)}multiplyVectorXYZ(t,e,i,s){return this._matrix.multiplyXYZ(t,e,i,s)}setMultiplyTransformTransform(t,e){pt.xyzPlusMatrixTimesXYZ(t._origin,t._matrix,e._origin,this._origin),t._matrix.multiplyMatrixMatrix(e._matrix,this._matrix)}multiplyTransformTransform(t,e){return e?(e.setMultiplyTransformTransform(this,t),e):ft.createRefs(pt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t._origin),this._matrix.multiplyMatrixMatrix(t._matrix))}multiplyTransformMatrix3d(t,e){return e?(this._matrix.multiplyMatrixMatrix(t,e._matrix),e._origin.setFrom(this._origin),e):ft.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(t))}multiplyRange(t,e){if(t.isNull)return t.clone(e);const i=t.low.x,s=t.low.y,n=t.low.z,r=t.high.x,o=t.high.y,a=t.high.z;return(e=lt.createNull(e)).extendTransformedXYZ(this,i,s,n),e.extendTransformedXYZ(this,r,s,n),e.extendTransformedXYZ(this,i,o,n),e.extendTransformedXYZ(this,r,o,n),e.extendTransformedXYZ(this,i,s,a),e.extendTransformedXYZ(this,r,s,a),e.extendTransformedXYZ(this,i,o,a),e.extendTransformedXYZ(this,r,o,a),e}inverse(t){const e=this._matrix.inverse(t?t._matrix:void 0);if(e)return t?(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,t._origin),t):ft.createRefs(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),e)}static initFromRange(t,e,i,s){const n=e.minus(t);0===n.x&&(n.x=1),0===n.y&&(n.y=1),0===n.z&&(n.z=1);const r=new pt;if(i&&(pt.createScale(n.x,n.y,n.z,r),ft.createOriginAndMatrix(t,r,i)),s){const e=new K(-t.x/n.x,-t.y/n.y,-t.z/n.z);pt.createScale(1/n.x,1/n.y,1/n.z,r),ft.createOriginAndMatrix(e,r,s)}}}class gt{static loadMatrix(t,e,i,s,n,r,o,a,c,h){t[0]=e,t[1]=i,t[2]=s,t[3]=n,t[4]=r,t[5]=o,t[6]=a,t[7]=c,t[8]=h}static multiplyMatrixMatrix(t,e,i){return i||(i=new Float64Array(9)),gt.loadMatrix(i,t[0]*e[0]+t[1]*e[3]+t[2]*e[6],t[0]*e[1]+t[1]*e[4]+t[2]*e[7],t[0]*e[2]+t[1]*e[5]+t[2]*e[8],t[3]*e[0]+t[4]*e[3]+t[5]*e[6],t[3]*e[1]+t[4]*e[4]+t[5]*e[7],t[3]*e[2]+t[4]*e[5]+t[5]*e[8],t[6]*e[0]+t[7]*e[3]+t[8]*e[6],t[6]*e[1]+t[7]*e[4]+t[8]*e[7],t[6]*e[2]+t[7]*e[5]+t[8]*e[8]),i}static multiplyMatrixMatrixTranspose(t,e,i){return i||(i=new Float64Array(9)),gt.loadMatrix(i,t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8],t[3]*e[0]+t[4]*e[1]+t[5]*e[2],t[3]*e[3]+t[4]*e[4]+t[5]*e[5],t[3]*e[6]+t[4]*e[7]+t[5]*e[8],t[6]*e[0]+t[7]*e[1]+t[8]*e[2],t[6]*e[3]+t[7]*e[4]+t[8]*e[5],t[6]*e[6]+t[7]*e[7]+t[8]*e[8]),i}static multiplyMatrixTransposeMatrix(t,e,i){return i||(i=new Float64Array(9)),gt.loadMatrix(i,t[0]*e[0]+t[3]*e[3]+t[6]*e[6],t[0]*e[1]+t[3]*e[4]+t[6]*e[7],t[0]*e[2]+t[3]*e[5]+t[6]*e[8],t[1]*e[0]+t[4]*e[3]+t[7]*e[6],t[1]*e[1]+t[4]*e[4]+t[7]*e[7],t[1]*e[2]+t[4]*e[5]+t[7]*e[8],t[2]*e[0]+t[5]*e[3]+t[8]*e[6],t[2]*e[1]+t[5]*e[4]+t[8]*e[7],t[2]*e[2]+t[5]*e[5]+t[8]*e[8]),i}static transposeInPlace(t){let e=t[1];t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}static copyTransposed(t,e){return e===t?gt.transposeInPlace(e):(e||(e=new Float64Array(9)),e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]),e}static copy(t,e){return e!==t&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8]),e}}!function(t){t[t.unknown=0]="unknown",t[t.inverseStored=1]="inverseStored",t[t.singular=2]="singular"}(v||(v={}));class pt{static get identity(){return void 0===this._identity&&(this._identity=pt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(t){this.coffs=t||new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=v.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(t){if(this.inverseCoffs=void 0,t)if(Array.isArray(t))if(J.isArrayOfNumberArray(t,3,3)){const e=t;this.setRowValues(e[0][0],e[0][1],e[0][2],e[1][0],e[1][1],e[1][2],e[2][0],e[2][1],e[2][2])}else if(9!==t.length)if(4!==t.length)this.setRowValues(0,0,0,0,0,0,0,0,0);else{const e=t;this.setRowValues(e[0],e[1],0,e[2],e[3],0,0,0,1)}else{const e=t;this.setRowValues(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}else t instanceof pt&&this.setFrom(t);else this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(t){const e=pt.createIdentity();return e.setFromJSON(t),e}isAlmostEqual(t,e){return J.isDistanceWithinTol(this.maxDiff(t),e)}isAlmostEqualColumn(t,e,i){const s=J.maxAbsXYZ(this.coffs[t]-e.coffs[t],this.coffs[t+3]-e.coffs[t+3],this.coffs[t+6]-e.coffs[t+6]);return J.isDistanceWithinTol(s,i)}isAlmostEqualColumnXYZ(t,e,i,s,n){const r=J.maxAbsXYZ(this.coffs[t]-e,this.coffs[t+3]-i,this.coffs[t+6]-s);return J.isDistanceWithinTol(r,n)}isAlmostEqualAllowZRotation(t,e){if(this.isAlmostEqual(t,e))return!0;if(this.isAlmostEqualColumn(p.Z,t,e)){const i=Z.radiansBetweenVectorsXYZ(this.coffs[0],this.coffs[3],this.coffs[6],t.coffs[0],t.coffs[3],t.coffs[6]),s=Z.createRadians(i),n=this.columnX(),r=this.columnY(),o=this.columnZ();let a=j.createRotateVectorAroundVector(n,o,s);if(t.isAlmostEqualColumnXYZ(0,a.x,a.y,a.z,e))return a=j.createRotateVectorAroundVector(r,o,s),t.isAlmostEqualColumnXYZ(1,a.x,a.y,a.z,e)}return!1}isExactEqual(t){return 0===this.maxDiff(t)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(t){return t||new pt}static createRowValues(t,e,i,s,n,r,o,a,c,h){return(h=h||new pt).inverseState=v.unknown,h.coffs[0]=t,h.coffs[1]=e,h.coffs[2]=i,h.coffs[3]=s,h.coffs[4]=n,h.coffs[5]=r,h.coffs[6]=o,h.coffs[7]=a,h.coffs[8]=c,h}static createCapture(t,e){const i=new pt(t);return e?(i.inverseCoffs=e,i.inverseState=v.inverseStored):i.inverseState=v.unknown,i}static createColumnsInAxisOrder(t,e,i,s,n){return n||(n=new pt),t===g.YZX?n.setColumns(s,e,i):t===g.ZXY?n.setColumns(i,s,e):t===g.XZY?n.setColumns(e,s,i):t===g.YXZ?n.setColumns(i,e,s):t===g.ZYX?n.setColumns(s,i,e):n.setColumns(e,i,s),n}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=v.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const t=this.coffs;this.inverseState=v.inverseStored,this.inverseCoffs=Float64Array.from([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}setRowValues(t,e,i,s,n,r,o,a,c){this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=i,this.coffs[3]=s,this.coffs[4]=n,this.coffs[5]=r,this.coffs[6]=o,this.coffs[7]=a,this.coffs[8]=c,this.inverseState=v.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=v.singular}setFrom(t){if(void 0!==t){if(t!==this){for(let e=0;e<9;e++)this.coffs[e]=t.coffs[e];if(t.inverseState===v.inverseStored&&void 0!==t.inverseCoffs){this.createInverseCoffsWithZeros();for(let e=0;e<9;e++)this.inverseCoffs[e]=t.inverseCoffs[e];this.inverseState=v.inverseStored}else t.inverseState!==v.inverseStored?this.inverseState=t.inverseState:this.inverseState=v.unknown}}else this.setIdentity()}clone(t){return(t=t||new pt).setFrom(this),t}static createZero(){const t=new pt;return t.inverseState=v.singular,t}static createIdentity(t){return(t=t||new pt).setIdentity(),t}static createScale(t,e,i,s){return s?s.setZero():s=new pt,s.coffs[0]=t,s.coffs[4]=e,s.coffs[8]=i,0===t||0===e||0===i?s.inverseState=v.singular:(s.inverseState=v.inverseStored,s.inverseCoffs=Float64Array.from([1/t,0,0,0,1/e,0,0,0,1/i])),s}static createUniformScale(t){return pt.createScale(t,t,t)}static createPerpendicularVectorFavorXYPlane(t,e){const i=t.magnitude()/64;return Math.abs(t.x)<i&&Math.abs(t.y)<i?j.createCrossProduct(t.x,t.y,t.z,0,-1,0,e):j.createCrossProduct(0,0,1,t.x,t.y,t.z,e)}static createPerpendicularVectorFavorPlaneContainingZ(t,e){return e=pt.createPerpendicularVectorFavorXYPlane(t,e),t.crossProduct(e,e)}static createShuffledColumns(t,e,i,s,n){const r=pt._create(n);return r.setColumn(J.axisOrderToAxis(s,0),t),r.setColumn(J.axisOrderToAxis(s,1),e),r.setColumn(J.axisOrderToAxis(s,2),i),r}static createRigidFromColumns(t,e,i,s){const n=t.normalize();if(n){const r=n.unitCrossProduct(e);if(r){const e=r.unitCrossProduct(t);if(e){const t=pt.createShuffledColumns(n,e,r,i,s);return t.setupInverseTranspose(),t}}}}static createRigidHeadsUp(t,e=g.ZXY,i){const s=pt.createPerpendicularVectorFavorXYPlane(t),n=pt.createRigidFromColumns(t,s,e,i);return n?(n.setupInverseTranspose(),n):pt.createIdentity(i)}static createRotationAroundVector(t,e,i){const s=e.cos(),n=e.sin(),r=1-s,o=t.normalize();if(o){const t=pt.createRowValues(o.x*o.x*r+s,o.x*o.y*r-n*o.z,o.x*o.z*r+n*o.y,o.y*o.x*r+n*o.z,o.y*o.y*r+s,o.y*o.z*r-n*o.x,o.z*o.x*r-n*o.y,o.z*o.y*r+n*o.x,o.z*o.z*r+s,i);return t.setupInverseTranspose(),t}}static createRotationAroundAxisIndex(t,e,i){const s=e.cos(),n=e.sin();let r;return r=t===p.X?pt.createRowValues(1,0,0,0,s,-n,0,n,s,i):t===p.Y?pt.createRowValues(s,0,n,0,1,0,-n,0,s,i):pt.createRowValues(s,-n,0,n,s,0,0,0,1,i),r.setupInverseTranspose(),r}applyGivensRowOp(t,e,i,s){let n=3*t,r=3*e;const o=n+3;for(;n<o;n++,r++){const t=this.coffs[n],e=this.coffs[r];this.coffs[n]=t*i+e*s,this.coffs[r]=-t*s+e*i}}applyGivensColumnOp(t,e,i,s){const n=t+9;for(;t<n;t+=3,e+=3){const n=this.coffs[t],r=this.coffs[e];this.coffs[t]=n*i+r*s,this.coffs[e]=-n*s+r*i}}static createColumns(t,e,i,s){return pt.createRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z,s)}static createColumnsXYW(t,e,i,s,n,r,o){return pt.createRowValues(t.x,i.x,n.x,t.y,i.y,n.y,e,s,r,o)}static createViewedAxes(t,e,i=0,s=0){const n=t.crossProduct(e);if(n.normalizeInPlace()){const r=pt.createColumns(t,e,n);if(0!==i){let t=Math.sqrt(.5),e=i<0?-t:t;if(1!==Math.abs(i)){const s=Z.degreesToRadians(45*i);t=Math.cos(s),e=Math.sin(s)}r.applyGivensColumnOp(2,0,t,e)}if(0!==s){const t=s*Math.atan(Math.sqrt(.5)),e=Math.cos(t),i=Math.sin(t);r.applyGivensColumnOp(1,2,e,-i)}return r}}static createStandardWorldToView(t,e=!1,i){switch(t){case m.Bottom:i=pt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case m.Left:i=pt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case m.Right:i=pt.createRowValues(0,1,0,0,0,1,1,0,0);break;case m.Front:i=pt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case m.Back:i=pt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case m.Iso:i=pt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case m.RightIso:i=pt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case m.Top:default:i=pt.createIdentity(i)}return e&&i.transposeInPlace(),i}applySymmetricJacobi(t,e,i,s){const n=s.at(t,t),r=s.at(e,e),o=s.at(t,e);if(Math.abs(o)<J.smallFloatingPoint*(n+r))return 0;const a=Z.trigValuesToHalfAngleTrigValues(n-r,2*o),c=a.c,h=a.s;return Math.abs(h)<2e-15?0:(s.applyGivensRowOp(t,e,c,h),s.applyGivensColumnOp(t,e,c,h),i.applyGivensColumnOp(t,e,c,h),Math.abs(o))}symmetricEigenvalues(t,e){const i=this.clone();t.setIdentity(),i.coffs[3]=i.coffs[1],i.coffs[6]=i.coffs[2],i.coffs[7]=i.coffs[5];const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(this.applySymmetricJacobi(0,1,t,i)+this.applySymmetricJacobi(0,2,t,i)+this.applySymmetricJacobi(1,2,t,i)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}applyFastSymmetricJacobi(t,e,i,s){const n=4*t,r=4*e,o=3*t+e,a=3*e+t,c=3*t+i,h=3*i+t,l=3*e+i,d=3*i+e,u=this.coffs[n],f=this.coffs[r],g=this.coffs[o];if(Math.abs(g)<J.smallFloatingPoint*(u+f))return 0;const p=Z.trigValuesToHalfAngleTrigValues(u-f,2*g),m=p.c,x=p.s,y=m*m,_=x*x,v=2*m*x;this.coffs[n]=y*u+v*g+_*f,this.coffs[r]=_*u-v*g+y*f,this.coffs[o]=0,this.coffs[a]=0;const P=this.coffs[c],I=this.coffs[l];return this.coffs[c]=m*P+x*I,this.coffs[l]=-x*P+m*I,this.coffs[h]=this.coffs[c],this.coffs[d]=this.coffs[l],s.applyGivensColumnOp(t,e,m,x),Math.abs(g)}fastSymmetricEigenvalues(t,e){const i=this.clone();t.setIdentity();const s=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(i.applyFastSymmetricJacobi(0,1,2,t)+i.applyFastSymmetricJacobi(0,2,1,t)+i.applyFastSymmetricJacobi(1,2,0,t)<s)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const t=this.coffs[0]+this.coffs[4]+this.coffs[8],e=this.coffs[3]-this.coffs[1],i=this.coffs[7]-this.coffs[5],s=this.coffs[2]-this.coffs[6],n=(t-1)/2,r=J.hypotenuseXYZ(e,i,s)/2,o=n*n+r*r-1;if(Math.abs(o)>J.smallAngleRadians)return{axis:j.create(0,0,1),angle:Z.createRadians(0),ok:!1};if(Math.abs(r)<J.smallAngleRadians){if(n>0)return{axis:j.create(0,0,1),angle:Z.createRadians(0),ok:!0};const t=this.coffs[0],e=this.coffs[4],i=this.coffs[8];if(J.isAlmostEqualNumber(-1,e)&&J.isAlmostEqualNumber(-1,i))return{axis:j.create(1,0,0),angle:Z.createDegrees(180),ok:!0};if(J.isAlmostEqualNumber(-1,t)&&J.isAlmostEqualNumber(-1,i))return{axis:j.create(0,1,0),angle:Z.createDegrees(180),ok:!0};if(J.isAlmostEqualNumber(-1,t)&&J.isAlmostEqualNumber(-1,e))return{axis:j.create(0,0,1),angle:Z.createDegrees(180),ok:!0};const s=pt.createIdentity(),r=j.create(0,0,0);if(this.fastSymmetricEigenvalues(s,r)){for(let t=0;t<2;t++){const e=r.at(t);if(J.isAlmostEqualNumber(1,e))return{axis:s.getColumn(t),angle:Z.createDegrees(180),ok:!0}}return{axis:j.create(0,0,1),angle:Z.createRadians(0),ok:!1}}return{axis:j.create(0,0,1),angle:Z.createRadians(0),ok:!1}}const a=1/(2*r);return{axis:j.create(i*a,s*a,e*a),angle:Z.createAtan2(r,n),ok:!0}}applyJacobiColumnRotation(t,e,i){const s=this.coffs[t]*this.coffs[t]+this.coffs[t+3]*this.coffs[t+3]+this.coffs[t+6]*this.coffs[t+6],n=this.coffs[e]*this.coffs[e]+this.coffs[e+3]*this.coffs[e+3]+this.coffs[e+6]*this.coffs[e+6],r=this.coffs[t]*this.coffs[e]+this.coffs[t+3]*this.coffs[e+3]+this.coffs[t+6]*this.coffs[e+6],o=Z.trigValuesToHalfAngleTrigValues(s-n,2*r),a=o.c,c=o.s;return Math.abs(c)<2e-15?0:(this.applyGivensColumnOp(t,e,a,c),i.applyGivensRowOp(t,e,a,c),Math.abs(r))}factorPerpendicularColumns(t,e){t.setFrom(this),e.setIdentity();const i=1e-12*this.sumSquares();for(let s=0;s<7;s++)if(t.applyJacobiColumnRotation(0,1,e)+t.applyJacobiColumnRotation(0,2,e)+t.applyJacobiColumnRotation(1,2,e)<i)return!0;return!1}factorOrthogonalScaleOrthogonal(t,e,i){const s=pt.createZero();if(!this.factorPerpendicularColumns(s,i))return!1;const n=[];n.push(s.getColumn(0)),n.push(s.getColumn(1)),n.push(s.getColumn(2)),e.set(n[0].magnitude(),n[1].magnitude(),n[2].magnitude()),s.determinant()<0&&(e.z=-e.z);const r=J.smallFloatingPoint,o=Math.abs(e.x)<r,a=Math.abs(e.y)<r,c=Math.abs(e.z)<r;return o||a||c?o||a?o?t.setIdentity():t=pt.createRigidHeadsUp(n[0],g.XYZ,t):(n[0].scaleInPlace(1/e.x),n[1].scaleInPlace(1/e.y),n[2]=n[0].unitCrossProduct(n[1],n[2]),t.setColumns(n[0],n[1],n[2])):t=s.scaleColumns(1/e.x,1/e.y,1/e.z,t),!0}static createPartialRotationVectorToVector(t,e,i,s){let n=t.unitCrossProduct(i);return n?pt.createRotationAroundVector(n,Z.createRadians(e*t.planarAngleTo(i,n).radians)):J.isSmallMetricDistance(t.magnitude())||J.isSmallMetricDistance(i.magnitude())?void 0:t.dotProduct(i)>0?pt.createIdentity(s):(n=pt.createPerpendicularVectorFavorPlaneContainingZ(t,n),pt.createRotationAroundVector(n,Z.createRadians(e*Math.PI)))}static createRotationVectorToVector(t,e,i){return this.createPartialRotationVectorToVector(t,1,e,i)}static create90DegreeRotationAroundAxis(t){if(0===(t=J.cyclic3dAxis(t))){const t=pt.createRowValues(1,0,0,0,0,-1,0,1,0);return t.setupInverseTranspose(),t}if(1===t){const t=pt.createRowValues(0,0,1,0,1,0,-1,0,0);return t.setupInverseTranspose(),t}{const t=pt.createRowValues(0,-1,0,1,0,0,0,0,1);return t.setupInverseTranspose(),t}}columnX(t){return j.create(this.coffs[0],this.coffs[3],this.coffs[6],t)}columnY(t){return j.create(this.coffs[1],this.coffs[4],this.coffs[7],t)}columnZ(t){return j.create(this.coffs[2],this.coffs[5],this.coffs[8],t)}columnXMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return J.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return J.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return J.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return J.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return J.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return J.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return J.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(t,e,i,s){return this.coffs[t]*e+this.coffs[t+3]*i+this.coffs[t+6]*s}rowX(t){return j.create(this.coffs[0],this.coffs[1],this.coffs[2],t)}rowY(t){return j.create(this.coffs[3],this.coffs[4],this.coffs[5],t)}rowZ(t){return j.create(this.coffs[6],this.coffs[7],this.coffs[8],t)}dotColumnX(t){return t.x*this.coffs[0]+t.y*this.coffs[3]+t.z*this.coffs[6]}dotColumnY(t){return t.x*this.coffs[1]+t.y*this.coffs[4]+t.z*this.coffs[7]}dotColumnZ(t){return t.x*this.coffs[2]+t.y*this.coffs[5]+t.z*this.coffs[8]}dotRowX(t){return t.x*this.coffs[0]+t.y*this.coffs[1]+t.z*this.coffs[2]}dotRowY(t){return t.x*this.coffs[3]+t.y*this.coffs[4]+t.z*this.coffs[5]}dotRowZ(t){return t.x*this.coffs[6]+t.y*this.coffs[7]+t.z*this.coffs[8]}dotRowXXYZ(t,e,i){return t*this.coffs[0]+e*this.coffs[1]+i*this.coffs[2]}dotRowYXYZ(t,e,i){return t*this.coffs[3]+e*this.coffs[4]+i*this.coffs[5]}dotRowZXYZ(t,e,i){return t*this.coffs[6]+e*this.coffs[7]+i*this.coffs[8]}columnZCrossVector(t,e){return J.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],t.x,t.y,t.z,e)}setColumnsPoint4dXYZ(t,e,i){this.inverseState=v.unknown,this.setRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z)}setColumn(t,e){const i=J.cyclic3dAxis(t);this.inverseState=v.unknown,e?(this.coffs[i]=e.x,this.coffs[i+3]=e.y,this.coffs[i+6]=e.z):(this.coffs[i]=0,this.coffs[i+3]=0,this.coffs[i+6]=0)}setColumns(t,e,i){this.setColumn(0,t),this.setColumn(1,e),this.setColumn(2,i)}setRow(t,e){const i=3*J.cyclic3dAxis(t);this.coffs[i]=e.x,this.coffs[i+1]=e.y,this.coffs[i+2]=e.z,this.inverseState=v.unknown}getColumn(t,e){const i=J.cyclic3dAxis(t);return j.create(this.coffs[i],this.coffs[i+3],this.coffs[i+6],e)}getRow(t,e){const i=3*J.cyclic3dAxis(t);return j.create(this.coffs[i],this.coffs[i+1],this.coffs[i+2],e)}static createRows(t,e,i,s){return pt.createRowValues(t.x,t.y,t.z,e.x,e.y,e.z,i.x,i.y,i.z,s)}static createDirectionalScale(t,e,i){const s=t.normalize();if(s){const t=s.x,n=s.y,r=s.z,o=e-1;return pt.createRowValues(1+o*t*t,o*t*n,o*t*r,o*n*t,1+o*n*n,o*n*r,o*r*t,o*r*n,1+o*r*r,i)}return pt.createUniformScale(e)}multiplyPoint(t,e){const i=t.x,s=t.y,n=t.z;return K.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVector(t,e){const i=t.x,s=t.y,n=t.z;return j.create(this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e)}multiplyVectorArrayInPlace(t){for(const e of t)e.set(this.coffs[0]*e.x+this.coffs[1]*e.y+this.coffs[2]*e.z,this.coffs[3]*e.x+this.coffs[4]*e.y+this.coffs[5]*e.z,this.coffs[6]*e.x+this.coffs[7]*e.y+this.coffs[8]*e.z)}static xyzMinusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return K.create(t.x-(e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o),t.y-(e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o),t.z-(e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o),s)}static xyPlusMatrixTimesXY(t,e,i,s){const n=i.x,r=i.y;return W.create(t.x+e.coffs[0]*n+e.coffs[1]*r,t.y+e.coffs[3]*n+e.coffs[4]*r,s)}static xyzPlusMatrixTimesXYZ(t,e,i,s){const n=i.x,r=i.y,o=i.z;return K.create(t.x+e.coffs[0]*n+e.coffs[1]*r+e.coffs[2]*o,t.y+e.coffs[3]*n+e.coffs[4]*r+e.coffs[5]*o,t.z+e.coffs[6]*n+e.coffs[7]*r+e.coffs[8]*o,s)}static xyzPlusMatrixTimesXYZInPlace(t,e,i){const s=i.x,n=i.y,r=i.z;i.x=t.x+e.coffs[0]*s+e.coffs[1]*n+e.coffs[2]*r,i.y=t.y+e.coffs[3]*s+e.coffs[4]*n+e.coffs[5]*r,i.z=t.z+e.coffs[6]*s+e.coffs[7]*n+e.coffs[8]*r}static xyzPlusMatrixTimesCoordinates(t,e,i,s,n,r){return K.create(t.x+e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n,t.y+e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n,t.z+e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n,r)}static xyzPlusMatrixTimesWeightedCoordinates(t,e,i,s,n,r,o){return bt.create(e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,r,o)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(t,e,i,s,n,r,o){return o||(o=new Float64Array(4)),o[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x*r,o[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y*r,o[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z*r,o[3]=r,o}static xyzPlusMatrixTimesCoordinatesToFloat64Array(t,e,i,s,n,r){return r||(r=new Float64Array(3)),r[0]=e.coffs[0]*i+e.coffs[1]*s+e.coffs[2]*n+t.x,r[1]=e.coffs[3]*i+e.coffs[4]*s+e.coffs[5]*n+t.y,r[2]=e.coffs[6]*i+e.coffs[7]*s+e.coffs[8]*n+t.z,r}multiplyTransposeVector(t,e){e=e||new j;const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[3]*s+this.coffs[6]*n,e.y=this.coffs[1]*i+this.coffs[4]*s+this.coffs[7]*n,e.z=this.coffs[2]*i+this.coffs[5]*s+this.coffs[8]*n,e}multiplyXYZ(t,e,i,s){return(s=s||new j).x=this.coffs[0]*t+this.coffs[1]*e+this.coffs[2]*i,s.y=this.coffs[3]*t+this.coffs[4]*e+this.coffs[5]*i,s.z=this.coffs[6]*t+this.coffs[7]*e+this.coffs[8]*i,s}multiplyXYZtoXYZ(t,e){const i=t.x,s=t.y,n=t.z;return e.x=this.coffs[0]*i+this.coffs[1]*s+this.coffs[2]*n,e.y=this.coffs[3]*i+this.coffs[4]*s+this.coffs[5]*n,e.z=this.coffs[6]*i+this.coffs[7]*s+this.coffs[8]*n,e}multiplyXY(t,e,i){return(i=i||new j).x=this.coffs[0]*t+this.coffs[1]*e,i.y=this.coffs[3]*t+this.coffs[4]*e,i.z=this.coffs[6]*t+this.coffs[7]*e,i}originPlusMatrixTimesXY(t,e,i,s){return K.create(t.x+this.coffs[0]*e+this.coffs[1]*i,t.y+this.coffs[3]*e+this.coffs[4]*i,t.z+this.coffs[6]*e+this.coffs[7]*i,s)}multiplyVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[1]*i+this.coffs[2]*s,t.y=this.coffs[3]*e+this.coffs[4]*i+this.coffs[5]*s,t.z=this.coffs[6]*e+this.coffs[7]*i+this.coffs[8]*s}multiplyTransposeVectorInPlace(t){const e=t.x,i=t.y,s=t.z;t.x=this.coffs[0]*e+this.coffs[3]*i+this.coffs[6]*s,t.y=this.coffs[1]*e+this.coffs[4]*i+this.coffs[7]*s,t.z=this.coffs[2]*e+this.coffs[5]*i+this.coffs[8]*s}multiplyTransposeXYZ(t,e,i,s){return(s=s||new j).x=this.coffs[0]*t+this.coffs[3]*e+this.coffs[6]*i,s.y=this.coffs[1]*t+this.coffs[4]*e+this.coffs[7]*i,s.z=this.coffs[2]*t+this.coffs[5]*e+this.coffs[8]*i,s}multiplyInverse(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return j.create(this.inverseCoffs[0]*i+this.inverseCoffs[1]*s+this.inverseCoffs[2]*n,this.inverseCoffs[3]*i+this.inverseCoffs[4]*s+this.inverseCoffs[5]*n,this.inverseCoffs[6]*i+this.inverseCoffs[7]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseTranspose(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,s=t.y,n=t.z;return j.create(this.inverseCoffs[0]*i+this.inverseCoffs[3]*s+this.inverseCoffs[6]*n,this.inverseCoffs[1]*i+this.inverseCoffs[4]*s+this.inverseCoffs[7]*n,this.inverseCoffs[2]*i+this.inverseCoffs[5]*s+this.inverseCoffs[8]*n,e)}}multiplyInverseXYZAsVector3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return j.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}multiplyInverseXYZW(t,e,i,s,n){if(this.computeCachedInverse(!0),this.inverseCoffs)return bt.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s,n)}multiplyInverseXYZAsPoint3d(t,e,i,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return K.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,s)}finishInverseCoffs(t,e,i){e&&i?(this.createInverseCoffsWithZeros(),this.inverseState=v.inverseStored,t(e,i,this.inverseCoffs)):this.inverseState=v.unknown}multiplyMatrixMatrix(t,e){return e=e||new pt,gt.multiplyMatrixMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(gt.multiplyMatrixMatrix,t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixMatrixInverse(t,e){if(t.computeCachedInverse(!0))return e=e||new pt,gt.multiplyMatrixMatrix(this.coffs,t.inverseCoffs,pt._productBuffer),this.inverseState===v.inverseStored?e.finishInverseCoffs(gt.multiplyMatrixMatrix,t.coffs,this.inverseCoffs):e.inverseState=v.unknown,gt.copy(pt._productBuffer,e.coffs),e}multiplyMatrixInverseMatrix(t,e){if(this.computeCachedInverse(!0))return e=e||new pt,gt.multiplyMatrixMatrix(this.inverseCoffs,t.coffs,pt._productBuffer),t.inverseState===v.inverseStored?e.finishInverseCoffs(gt.multiplyMatrixMatrix,t.inverseCoffs,this.coffs):e.inverseState=v.unknown,gt.copy(pt._productBuffer,e.coffs),e}multiplyMatrixMatrixTranspose(t,e){return e=e||new pt,gt.multiplyMatrixMatrixTranspose(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(gt.multiplyMatrixTransposeMatrix,t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixTransposeMatrix(t,e){return e=e||new pt,gt.multiplyMatrixTransposeMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===v.inverseStored&&t.inverseState===v.inverseStored?e.finishInverseCoffs(gt.multiplyMatrixMatrixTranspose,t.inverseCoffs,this.inverseCoffs):this.inverseState===v.singular||t.inverseState===v.singular?e.inverseState=v.singular:e.inverseState=v.unknown,e}multiplyMatrixTransform(t,e){return e?(this.multiplyXYZtoXYZ(t.origin,e.origin),this.multiplyMatrixMatrix(t.matrix,e.matrix),e):ft.createRefs(this.multiplyXYZ(t.origin.x,t.origin.y,t.origin.z),this.multiplyMatrixMatrix(t.matrix))}transpose(t){return t||(t=new pt),gt.copyTransposed(this.coffs,t.coffs),void 0!==this.inverseCoffs?(t.inverseState=v.inverseStored,t.inverseCoffs=gt.copyTransposed(this.inverseCoffs,t.inverseCoffs)):(t.inverseState=this.inverseState,t.inverseCoffs=void 0),t}transposeInPlace(){gt.transposeInPlace(this.coffs),this.inverseCoffs&&gt.transposeInPlace(this.inverseCoffs)}inverse(t){if(this.computeCachedInverse(!0))return t===this?(gt.copy(this.coffs,pt._productBuffer),gt.copy(this.inverseCoffs,this.coffs),gt.copy(pt._productBuffer,this.inverseCoffs),t):(void 0===t&&(t=pt.createIdentity()),t.createInverseCoffsWithZeros(),gt.copy(this.coffs,t.inverseCoffs),gt.copy(this.inverseCoffs,t.coffs),t.inverseState=this.inverseState,t)}static rowColumnDot(t,e,i,s){return t[e]*i[s]+t[e+1]*i[s+3]+t[e+2]*i[s+6]}static indexedRowCrossProduct(t,e,i,s,n){s[n]=t[e+1]*t[i+2]-t[e+2]*t[i+1],s[n+3]=t[e+2]*t[i]-t[e]*t[i+2],s[n+6]=t[e]*t[i+1]-t[e+1]*t[i]}indexedColumnCrossProductInPlace(t,e,i){const s=this.coffs;s[i]=s[t+3]*s[e+6]-s[t+6]*s[e+3],s[i+3]=s[t+6]*s[e]-s[t]*s[e+6],s[i+6]=s[t]*s[e+3]-s[t+3]*s[e]}axisOrderCrossProductsInPlace(t){switch(t){case g.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case g.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case g.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case g.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case g.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case g.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(t){const e=this.columnXMagnitude(),i=this.columnYMagnitude(),s=this.columnZMagnitude();return t&&t.set(e,i,s),!(J.isSmallMetricDistance(e)||J.isSmallMetricDistance(i)||J.isSmallMetricDistance(s)||(this.scaleColumns(1/e,1/i,1/s,this),0))}normalizeRowsInPlace(t){const e=this.rowXMagnitude(),i=this.rowYMagnitude(),s=this.rowZMagnitude();return t&&t.set(e,i,s),!(J.isSmallMetricDistance(e)||J.isSmallMetricDistance(i)||J.isSmallMetricDistance(s)||(this.scaleRows(1/e,1/i,1/s,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=v.singular}computeCachedInverse(t){if(t&&pt.useCachedInverse&&this.inverseState!==v.unknown)return pt.numUseCache++,this.inverseState===v.inverseStored;this.inverseState=v.unknown,this.createInverseCoffsWithZeros();const e=this.coffs,i=this.inverseCoffs;pt.indexedRowCrossProduct(e,3,6,i,0),pt.indexedRowCrossProduct(e,6,0,i,1),pt.indexedRowCrossProduct(e,0,3,i,2),pt.numComputeCache++;const s=pt.rowColumnDot(e,0,i,0);if(0===s)return this.inverseState=v.singular,this.inverseCoffs=void 0,!1;const n=1/s;for(let t=0;t<9;t++)i[t]*=n;return this.inverseState=v.inverseStored,!0}static flatIndexOf(t,e){return 3*J.cyclic3dAxis(t)+J.cyclic3dAxis(e)}indexedColumnWithWeight(t,e,i){return t=J.cyclic3dAxis(t),bt.create(this.coffs[t],this.coffs[t+3],this.coffs[t+6],e,i)}at(t,e){return this.coffs[pt.flatIndexOf(t,e)]}setAt(t,e,i){this.coffs[pt.flatIndexOf(t,e)]=i,this.inverseState=v.unknown}scale(t,e){return pt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*t,this.coffs[4]*t,this.coffs[5]*t,this.coffs[6]*t,this.coffs[7]*t,this.coffs[8]*t,e)}scaleColumns(t,e,i,s){return pt.createRowValues(this.coffs[0]*t,this.coffs[1]*e,this.coffs[2]*i,this.coffs[3]*t,this.coffs[4]*e,this.coffs[5]*i,this.coffs[6]*t,this.coffs[7]*e,this.coffs[8]*i,s)}scaleColumnsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=e,this.coffs[2]*=i,this.coffs[3]*=t,this.coffs[4]*=e,this.coffs[5]*=i,this.coffs[6]*=t,this.coffs[7]*=e,this.coffs[8]*=i,this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs){const s=J.conditionalDivideFraction(1,t),n=J.conditionalDivideFraction(1,e),r=J.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=s,this.inverseCoffs[2]*=s,this.inverseCoffs[3]*=n,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=n,this.inverseCoffs[6]*=r,this.inverseCoffs[7]*=r,this.inverseCoffs[8]*=r):this.inverseState=v.singular}}scaleRows(t,e,i,s){return pt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*e,this.coffs[4]*e,this.coffs[5]*e,this.coffs[6]*i,this.coffs[7]*i,this.coffs[8]*i,s)}scaleRowsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=t,this.coffs[2]*=t,this.coffs[3]*=e,this.coffs[4]*=e,this.coffs[5]*=e,this.coffs[6]*=i,this.coffs[7]*=i,this.coffs[8]*=i,this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs){const s=J.conditionalDivideFraction(1,t),n=J.conditionalDivideFraction(1,e),r=J.conditionalDivideFraction(1,i);void 0!==s&&void 0!==n&&void 0!==r?(this.inverseCoffs[0]*=s,this.inverseCoffs[1]*=n,this.inverseCoffs[2]*=r,this.inverseCoffs[3]*=s,this.inverseCoffs[4]*=n,this.inverseCoffs[5]*=r,this.inverseCoffs[6]*=s,this.inverseCoffs[7]*=n,this.inverseCoffs[8]*=r):this.inverseState=v.singular}}addScaledInPlace(t,e){for(let i=0;i<9;i++)this.coffs[i]+=e*t.coffs[i];this.inverseState=v.unknown}addScaledOuterProductInPlace(t,e,i){this.coffs[0]+=i*t.x*e.x,this.coffs[1]+=i*t.x*e.y,this.coffs[2]+=i*t.x*e.z,this.coffs[3]+=i*t.y*e.x,this.coffs[4]+=i*t.y*e.y,this.coffs[5]+=i*t.y*e.z,this.coffs[6]+=i*t.z*e.x,this.coffs[7]+=i*t.z*e.y,this.coffs[8]+=i*t.z*e.z,this.inverseState=v.unknown}static createRigidViewAxesZTowardsEye(t,e,i,s){s=pt.createIdentity(s);const n=J.hypotenuseXY(t,e);if(J.isSmallMetricDistance(n))i<0&&s.scaleColumnsInPlace(1,-1,-1);else{const r=t/n,o=e/n;if(s.setRowValues(-o,0,r,r,0,o,0,1,0),0!==i){const r=J.hypotenuseXYZ(t,e,i),o=i/r,a=n/r;s.applyGivensColumnOp(1,2,a,-o)}}return s}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const t=Math.abs(this.determinant()),e=J.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+J.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+J.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return J.safeDivideFraction(t,e,0)}sumSquares(){let t=0;for(let e=0;e<9;e++)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonalSquares(){let t=0;for(let e=0;e<9;e+=4)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let t=0;for(let e=0;e<9;e++)t=Math.max(t,Math.abs(this.coffs[e]));return t}maxDiff(t){let e=0;for(let i=0;i<9;i++)e=Math.max(e,Math.abs(this.coffs[i]-t.coffs[i]));return e}get isIdentity(){return this.maxDiff(pt.identity)<J.smallAngleRadians}get isDiagonal(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);return Math.sqrt(i)<=J.smallAngleRadians*(1+Math.sqrt(t))}sumSkewSquares(){return J.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const t=this.sumSkewSquares();return Math.sqrt(t)<=J.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===v.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const t=this.sumSquares(),e=J.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(e)<=J.smallAngleRadians*(1+Math.sqrt(t))}get isLowerTriangular(){const t=this.sumSquares(),e=J.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(e)<=J.smallAngleRadians*(1+Math.sqrt(t))}sameDiagonalScale(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);if(Math.sqrt(i)<=J.smallAngleRadians*(1+Math.sqrt(t))&&J.isSameCoordinate(this.coffs[0],this.coffs[4])&&J.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(t=!1){return this.testPerpendicularUnitRowsAndColumns()&&(t||this.determinant()>0)}factorRigidWithSignedScale(t){const e=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===e||e<=0)return;const i=this.determinant()>0?Math.sqrt(e):-Math.sqrt(e),s=1/i;return{rigidAxes:this.scaleColumns(s,s,s,t),scale:i}}get isSignedPermutation(){let t=0;for(let e=0;e<3;e++)for(let i=0;i<3;i++){const s=this.at(e,i);if(0===s);else{if(1!==s&&-1!==s)return!1;if(t++,0!==this.at(e+1,i)||0!==this.at(e+2,i)||0!==this.at(e,i+1)||0!==this.at(e,i+2))return!1}}return 3===t}makeRigid(t=g.XYZ){const e=this.maxAbs();if(J.isSmallMetricDistance(e))return!1;const i=1/e;return this.scaleColumnsInPlace(i,i,i),this.axisOrderCrossProductsInPlace(t),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(t,e=g.XYZ,i){if((i=t.clone(i)).makeRigid(e))return i}static createFromQuaternion(t){const e=t.x*t.x,i=t.y*t.y,s=t.z*t.z,n=t.w*t.w,r=e+i+s+n;if(0===r)return pt.createIdentity();{const o=1/r;return pt.createRowValues(o*(n+e-i-s),2*o*(t.w*t.z+t.x*t.y),2*o*(t.x*t.z-t.w*t.y),2*o*(t.x*t.y-t.w*t.z),o*(n-e+i-s),2*o*(t.w*t.x+t.y*t.z),2*o*(t.x*t.z+t.w*t.y),2*o*(t.y*t.z-t.w*t.x),o*(n-e-i+s))}}static computeQuatTerm(t,e,i,s){let n;return s>.5?(n=.5*Math.sqrt(s),e*t<0&&(n=-n)):n=t*i,n}toQuaternion(){const t=bt.createZero(),e=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],i=e[0][0],s=e[1][1],n=e[2][2],r=[];let o;r[0]=1+i-s-n,r[1]=1-i+s-n,r[2]=1-i-s+n,r[3]=1+i+s+n;let a=0;for(let t=1;t<=3;t++)r[t]>r[a]&&(a=t);return 0===a?(t.x=.5*Math.sqrt(r[0]),o=1/(4*t.x),t.y=pt.computeQuatTerm(e[0][1]+e[1][0],t.x,o,r[1]),t.z=pt.computeQuatTerm(e[0][2]+e[2][0],t.x,o,r[2]),t.w=pt.computeQuatTerm(e[2][1]-e[1][2],t.x,o,r[3])):1===a?(t.y=.5*Math.sqrt(r[1]),o=1/(4*t.y),t.x=pt.computeQuatTerm(e[0][1]+e[1][0],t.y,o,r[0]),t.z=pt.computeQuatTerm(e[1][2]+e[2][1],t.y,o,r[2]),t.w=pt.computeQuatTerm(e[0][2]-e[2][0],t.y,o,r[3])):2===a?(t.z=.5*Math.sqrt(r[2]),o=1/(4*t.z),t.x=pt.computeQuatTerm(e[0][2]+e[2][0],t.z,o,r[0]),t.y=pt.computeQuatTerm(e[1][2]+e[2][1],t.z,o,r[1]),t.w=pt.computeQuatTerm(e[1][0]-e[0][1],t.z,o,r[3])):(t.w=.5*Math.sqrt(r[3]),o=1/(4*t.w),t.x=pt.computeQuatTerm(e[2][1]-e[1][2],t.w,o,r[0]),t.y=pt.computeQuatTerm(e[0][2]-e[2][0],t.w,o,r[1]),t.z=pt.computeQuatTerm(e[1][0]-e[0][1],t.w,o,r[2])),t}}pt.useCachedInverse=!0,pt.numUseCache=0,pt.numComputeCache=0,pt._productBuffer=new Float64Array(9);class mt extends Q{constructor(t,e){super(),this._origin=t,this._normal=e}static _create(t,e,i,s,n,r){return new mt(K.create(t,e,i),j.create(s,n,r))}static createXYPlane(t){return t?mt._create(t.x,t.y,t.z,0,0,1):mt._create(0,0,0,0,0,1)}static createYZPlane(t){return t?mt._create(t.x,t.y,t.z,1,0,0):mt._create(0,0,0,1,0,0)}static createZXPlane(t){return t?mt._create(t.x,t.y,t.z,0,1,0):mt._create(0,0,0,0,1,0)}static create(t,e,i){if(i){if(void 0===e.normalize(i._normal))return;return t.clone(i._origin),i}const s=e.normalize();if(void 0!==s)return new mt(t.clone(),s)}static createFrom(t,e){if(t instanceof mt)return t.clone(e);if(e){if(void 0===t.getUnitNormal(e._normal))return;return t.getAnyPointOnPlane(e._origin),e}const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane();return new mt(s,i)}static createXYZUVW(t,e,i,s,n,r,o){const a=J.hypotenuseXYZ(s,n,r);if(!(a<J.smallMetricDistance))return o?(o._origin.set(t,e,i),o._normal.set(s/a,n/a,r/a),o):new mt(K.create(t,e,i),j.create(s/a,n/a,r/a))}static createOriginAndTargetXY(t,e,i){const s=e.x-t.x,n=e.y-t.y;return this.createXYZUVW(t.x,t.y,0,n,-s,0,i)}static createXYAngle(t,e,i,s){return s?(s._origin.set(t,e,0),s._normal.set(i.cos(),i.sin(),0),s):new mt(K.create(t,e,0),j.create(i.cos(),i.sin()))}static createPointPointVectorInPlane(t,e,i){const s=i.crossProductStartEnd(t,e);if(s.tryNormalizeInPlace())return new mt(t,s)}static createOriginAndTargets(t,e,i){const s=t.crossProductToPoints(e,i);if(s.tryNormalizeInPlace())return new mt(t,s)}static createOriginAndVectors(t,e,i){const s=e.crossProduct(i);if(s.tryNormalizeInPlace())return new mt(t,s)}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._normal.isAlmostEqual(t._normal)}setFromJSON(t){t?(this._origin.setFromJSON(t.origin),this._normal.setFromJSON(t.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(t){const e=mt.createXYPlane();return e.setFromJSON(t),e}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const t=pt.createRigidHeadsUp(this._normal,g.ZXY);return ft.createRefs(this._origin.clone(),t)}getProjectionToPlane(){const t=pt.createIdentity();return t.addScaledOuterProductInPlace(this._normal,this._normal,-1),t.markSingular(),ft.createFixedPointAndMatrix(this._origin,t)}set(t,e){this._origin.setFrom(t),this._normal.setFrom(e)}clone(t){return t?(t.set(this._origin,this._normal),t):new mt(this._origin.clone(),this._normal.clone())}cloneTransformed(t,e=!1){const i=this.clone();if(e){if(t.multiplyInversePoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyTransposeVector(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}else if(t.multiplyPoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyInverseTranspose(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}setFrom(t){this.set(t._origin,t._normal)}altitude(t){return this._normal.dotProductStartEnd(this._origin,t)}altitudeXY(t,e){return(t-this._origin.x)*this._normal.x+(e-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(t){return this._normal.clone(t)}getAnyPointOnPlane(t){return this._origin.clone(t)}weightedAltitude(t){return this._normal.dotProductStart3dEnd4d(this._origin,t)}altitudeToPoint(t,e){return this._origin.plusScaled(this._normal,t,e)}velocityXYZ(t,e,i){return this._normal.dotProductXYZ(t,e,i)}velocity(t){return this._normal.dotProduct(t)}altitudeXYZ(t,e,i){return this._normal.dotProductStartEndXYZ(this._origin,t,e,i)}altitudeXYZW(t,e,i,s){return this._normal.dotProductStartEndXYZW(this._origin,t,e,i,s)}projectPointToPlane(t,e){return t.plusScaled(this._normal,-this._normal.dotProductStartEnd(this._origin,t),e)}isPointInPlane(t,e=J.smallMetricDistance){const i=this._normal.dotProductStartEnd(this._origin,t);return Math.abs(i)<=e}}function xt(t,e){if(t)return t.clone(e)}!function(t){t[t.isolated=0]="isolated",t[t.isolatedAtVertex=1]="isolatedAtVertex",t[t.intervalStart=10]="intervalStart",t[t.intervalInterior=11]="intervalInterior",t[t.intervalEnd=12]="intervalEnd"}(P||(P={})),function(t){t[t.error=0]="error",t[t.success=1]="success",t[t.stoppedAtBoundary=2]="stoppedAtBoundary"}(I||(I={}));class yt{constructor(){this.pointQ=K.createZero(),this.fraction=0,this.point=K.createZero(),this.a=0}setIntervalRole(t){this.intervalRole=t}captureFraction1Point1(t,e){this.fraction1=t,this.point1=e}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===P.isolated||this.intervalRole===P.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1,this.fraction1=void 0),this.point1&&(this.point=this.point1,this.point1=void 0)}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(t){return t===this||((t=t||new yt).curve=this.curve,t.fraction=this.fraction,t.fraction1=this.fraction1,t.point1=this.point1,t.point.setFromPoint3d(this.point),t.vectorInCurveLocationDetail=xt(this.vectorInCurveLocationDetail,t.vectorInCurveLocationDetail),t.a=this.a,t.curveSearchStatus=this.curveSearchStatus),t}setFP(t,e,i,s=0){this.fraction=t,this.point.setFrom(e),this.vectorInCurveLocationDetail=xt(i,this.vectorInCurveLocationDetail),this.a=s}setFR(t,e,i=0){return this.setFP(t,e.origin,e.direction,i)}setCurve(t){this.curve=t}setDistanceTo(t){this.a=this.point.distance(t)}static create(t,e){return(e=e||new yt).curve=t,e}static createCurveFractionPoint(t,e,i,s){return(s=s||new yt).curve=t,s.fraction=e,s.point.setFromPoint3d(i),s.vectorInCurveLocationDetail=void 0,s.a=0,s.curveSearchStatus=void 0,s}static createRayFractionPoint(t,e,i,s){return(s=s||new yt).fraction=e,s.ray=t,s.point.setFromPoint3d(i),s}static createCurveFractionPointDistanceCurveSearchStatus(t,e,i,s,n,r){return(r=r||new yt).curve=t,r.fraction=e,r.point.setFromPoint3d(i),r.vectorInCurveLocationDetail=void 0,r.a=s,r.curveSearchStatus=n,r}static createConditionalMoveSignedDistance(t,e,i,s,n,r){let o=n,a=I.success;return t||J.isIn01(s)||(s<0?(o=-e.curveLengthBetweenFractions(i,0),s=0,a=I.stoppedAtBoundary):s>1&&(s=1,o=e.curveLengthBetweenFractions(i,1),a=I.stoppedAtBoundary)),(r=r||new yt).curve=e,r.fraction=s,r.point=e.fractionToPoint(s,r.point),r.vectorInCurveLocationDetail=void 0,r.a=o,r.curveSearchStatus=a,r}static createCurveEvaluatedFraction(t,e,i){return(i=i||new yt).curve=t,i.fraction=e,i.point=t.fractionToPoint(e),i.vectorInCurveLocationDetail=void 0,i.curveSearchStatus=void 0,i.a=0,i}static createCurveEvaluatedFractionPointAndDerivative(t,e,i){(i=i||new yt).curve=t,i.fraction=e;const s=t.fractionToPointAndDerivative(e);return i.point=s.origin,i.vectorInCurveLocationDetail=s.direction,i.curveSearchStatus=void 0,i.a=0,i}static createCurveEvaluatedFractionFraction(t,e,i,s){return(s=s||new yt).curve=t,s.fraction=e,s.point=t.fractionToPoint(e),s.fraction1=i,s.point1=t.fractionToPoint(i),s.vectorInCurveLocationDetail=void 0,s.curveSearchStatus=void 0,s.a=0,s}static createCurveFractionPointDistance(t,e,i,s,n){return(n=n||new yt).curve=t,n.fraction=e,n.point.setFromPoint3d(i),n.vectorInCurveLocationDetail=void 0,n.a=s,n.curveSearchStatus=void 0,n}updateIfCloserCurveFractionPointDistance(t,e,i,s){return!(this.a<s||(yt.createCurveFractionPointDistance(t,e,i,s,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const t=this.fraction;this.fraction=this.fraction1,this.fraction1=t}if(void 0!==this.point1){const t=this.point;this.point=this.point1,this.point1=t}}inverseInterpolateFraction(t,e=0){const i=J.inverseInterpolate01(this.fraction,this.fraction1,t);return void 0===i?e:i}static chooseSmallerA(t,e){return t?e?t.a<=e.a?t:e:t:e}}!function(t){t[t.Intersection=0]="Intersection",t[t.PerpendicularChord=1]="PerpendicularChord",t[t.CoincidentGeometry=2]="CoincidentGeometry",t[t.ParallelGeometry=3]="ParallelGeometry"}(A||(A={}));class _t{constructor(t,e){this.detailA=t||new yt,this.detailB=e||new yt}static createCapture(t,e,i){return(i=i||new _t).detailA=t,i.detailB=e,i}static createCaptureOptionalReverse(t,e,i,s){return(s=s||new _t).detailA=t,s.detailB=e,s}clone(t){return(t=t||new _t).detailA=this.detailA.clone(),t.detailB=this.detailB.clone(),t.approachType=this.approachType,t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}}class vt{get startDegrees(){return Z.radiansToDegrees(this._radians0)}get endDegrees(){return Z.radiansToDegrees(this._radians1)}get sweepDegrees(){return Z.radiansToDegrees(this._radians1-this._radians0)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get startAngle(){return Z.createRadians(this._radians0)}get endAngle(){return Z.createRadians(this._radians1)}static create(t){return t instanceof vt?t.clone():t instanceof Z?new vt(0,t.radians):vt.create360()}constructor(t=0,e=0){this._radians0=t,this._radians1=e}setStartEndRadians(t=0,e=2*Math.PI){const i=e-t;Z.isFullCircleRadians(i)&&(e=t+(i>0?2:-2)*Math.PI),this._radians0=t,this._radians1=e}setStartEndDegrees(t=0,e=360){this.setStartEndRadians(Z.degreesToRadians(t),Z.degreesToRadians(e))}static createStartEndRadians(t=0,e=2*Math.PI,i){return(i=i||new vt).setStartEndRadians(t,e),i}cloneMinusRadians(t){return new vt(this._radians0-t,this._radians1-t)}static createStartEndDegrees(t=0,e=360,i){return vt.createStartEndRadians(Z.degreesToRadians(t),Z.degreesToRadians(e),i)}static createStartEnd(t,e,i){return(i=i||new vt).setStartEndRadians(t.radians,e.radians),i}static createStartSweepRadians(t=0,e=Math.PI,i){return(i=i||new vt).setStartEndRadians(t,t+e),i}static createStartSweepDegrees(t=0,e=360,i){return vt.createStartEndRadians(Z.degreesToRadians(t),Z.degreesToRadians(t+e),i)}static createStartSweep(t,e,i){return vt.createStartSweepRadians(t.radians,e.radians,i)}interpolate(t,e){return new vt(J.interpolate(this._radians0,t,e._radians0),J.interpolate(this._radians1,t,e._radians1))}setFrom(t){this._radians0=t._radians0,this._radians1=t._radians1}static create360(t){return new vt(t=t||0,t+2*Math.PI)}static createFullLatitude(){return vt.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const t=this._radians0;this._radians0=this._radians1,this._radians1=t}cloneComplement(t=!1,e){const i=this.sweepRadians>=0?2:-2;return t?vt.createStartEndRadians(this.startRadians,this.endRadians-i*Math.PI,e):vt.createStartEndRadians(this.endRadians,this.startRadians+i*Math.PI,e)}capLatitudeInPlace(){const t=.5*Math.PI;this._radians0=J.clampToStartEnd(this._radians0,-t,t),this._radians1=J.clampToStartEnd(this._radians1,-t,t)}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return Z.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const t=.5*Math.PI;return Z.isAlmostEqualRadiansNoPeriodShift(this._radians0,-t)&&Z.isAlmostEqualRadiansNoPeriodShift(this._radians1,t)}clone(){return new vt(this._radians0,this._radians1)}fractionToRadians(t){return t<.5?this._radians0+t*(this._radians1-this._radians0):this._radians1+(t-1)*(this._radians1-this._radians0)}fractionToAngle(t){return Z.createRadians(this.fractionToRadians(t))}fractionPeriod(){return J.safeDivideFraction(2*Math.PI,Math.abs(this._radians1-this._radians0),1)}angleToUnboundedFraction(t){return J.safeDivideFraction(t.radians-this._radians0,this._radians1-this._radians0,1)}static radiansToPositivePeriodicFractionStartEnd(t,e,i,s=0){if(Z.isAlmostEqualRadiansAllowPeriodShift(t,e))return 0;if(Z.isAlmostEqualRadiansAllowPeriodShift(t,i))return 1;const n=i-e,r=t-e;if(n>0){const t=Z.adjustRadians0To2Pi(r);return J.safeDivideFraction(t,n,s)}const o=Z.adjustRadians0To2Pi(-r);return J.safeDivideFraction(o,-n,s)}radiansToPositivePeriodicFraction(t,e=0){return vt.radiansToPositivePeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToPositivePeriodicFraction(t){return this.radiansToPositivePeriodicFraction(t.radians)}radiansArrayToPositivePeriodicFractions(t){const e=t.length;for(let i=0;i<e;i++)t.reassign(i,this.radiansToPositivePeriodicFraction(t.atUncheckedIndex(i)))}radiansToSignedPeriodicFraction(t){if(Z.isAlmostEqualRadiansAllowPeriodShift(t,this._radians0))return 0;if(Z.isAlmostEqualRadiansAllowPeriodShift(t,this._radians1))return 1;const e=this._radians1-this._radians0,i=t-this._radians0-.5*e;if(e>0){const t=Z.adjustRadiansMinusPiPlusPi(i);return.5+J.safeDivideFraction(t,e,0)}const s=Z.adjustRadiansMinusPiPlusPi(-i);return.5+J.safeDivideFraction(s,-e,0)}angleToSignedPeriodicFraction(t){return this.radiansToSignedPeriodicFraction(t.radians)}static isRadiansInStartEnd(t,e,i,s=!0){return(t-e)*(t-i)<=0||(e===i?s?Z.isAlmostEqualRadiansAllowPeriodShift(t,e):Z.isAlmostEqualRadiansNoPeriodShift(t,e):!!s&&this.radiansToPositivePeriodicFractionStartEnd(t,e,i,1e3)<=1)}isRadiansInSweep(t,e=!0){return vt.isRadiansInStartEnd(t,this.startRadians,this.endRadians,e)}isAngleInSweep(t){return this.isRadiansInSweep(t.radians)}setFromJSON(t){t?t instanceof vt?this.setFrom(t):J.isNumberArray(t.degrees,2)?this.setStartEndDegrees(t.degrees[0],t.degrees[1]):J.isNumberArray(t.radians,2)?this.setStartEndRadians(t.radians[0],t.radians[1]):J.isNumberArray(t,2)?this.setStartEndDegrees(t[0],t[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(t){const e=vt.create360();return e.setFromJSON(t),e}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(t){return Z.isAlmostEqualRadiansAllowPeriodShift(this._radians0,t._radians0)&&Z.isAlmostEqualRadiansAllowPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqualNoPeriodShift(t){return Z.isAlmostEqualRadiansNoPeriodShift(this._radians0,t._radians0)&&Z.isAlmostEqualRadiansNoPeriodShift(this._radians1-this._radians0,t._radians1-t._radians0)}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}}class Pt{constructor(t=8,e){this._data=new Float64Array(t),this._inUse=0,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=i??0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=e??t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n,offset:s})}static create(t){const e=new Pt(t.length);return e.copyData(t),e._inUse=t.length,e}static compare(t,e){return t-e}clone(t=!1){const e=new Pt(t?this.capacity():this._inUse);return e.copyData(this._data,this._inUse),e._inUse=this._inUse,e}get length(){return this._inUse}setAtUncheckedIndex(t,e){this._data[t]=e}move(t,e){this._data[e]=this._data[t]}swap(t,e){const i=this._data[t];this._data[t]=this._data[e],this._data[e]=i}push(t){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=t,this._inUse++}pushArray(t){this.ensureCapacity(this._inUse+t.length),this.copyData(t,t.length,this._inUse),this._inUse+=t.length}pushBlockCopy(t,e){t>=0&&t<this._inUse&&e>0&&t+e<=this._inUse&&(this.ensureCapacity(this._inUse+e),this._data.copyWithin(this._inUse,t,t+e),this._inUse+=e)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(t,e=!0){if(t>this.capacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t),this.copyData(i,this._inUse)}}resize(t,e=0){t>=0&&t<this._inUse?this._inUse=t:t>this._inUse&&(this.ensureCapacity(t,!1),this._data.fill(e,this._inUse),this._inUse=t)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(t){return this._data[t]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(t,e){this._data[t]=e}sort(t=Pt.compare){for(let e=0;e<this._inUse;e++)for(let i=e+1;i<this._inUse;i++){const s=this._data[e],n=this._data[i];t(s,n)>0&&(this._data[e]=n,this._data[i]=s)}}restrictToInterval(t,e){const i=this._data,s=i.length;let n=0,r=0;for(let o=0;o<s;o++)r=i[o],r>=t&&r<=e&&(i[n++]=r);this._inUse=n}compressAdjacentDuplicates(t=0){const e=this._data,i=this._inUse;if(0===i)return;let s,n=1,r=e[0];for(let o=1;o<i;o++)s=e[o],Math.abs(s-r)>t&&(e[n++]=s,r=s);this._inUse=n}}class It{constructor(t=0,e=0,i=0){this.coffs=[t,e,i]}static solveQuadratic(t,e,i){const s=J.conditionalDivideFraction(e,t),n=J.conditionalDivideFraction(i,t);if(void 0!==s&&void 0!==n){const t=s*s-4*n;if(t>0){const e=Math.sqrt(t);return[.5*(-s-e),.5*(-s+e)]}if(t<0)return;const e=-.5*s;return[e,e]}const r=J.conditionalDivideFraction(-i,e);if(void 0!==r)return[r]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,i=1){this.coffs[0]+=i*(t*t),this.coffs[1]+=i*(2*t*e),this.coffs[2]+=i*(e*e)}realRoots(){const t=It.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(t&&t.length>1&&t[0]>t[1]){const e=t[0];t[0]=t[1],t[1]=e}return t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*this.coffs[2])}evaluateDerivative(t){return this.coffs[1]+2*t*this.coffs[2]}tryGetVertexFactorization(){const t=J.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==t){const e=this.evaluate(t);return{c:this.coffs[2],x0:t,y0:e}}}static fromRootsAndC2(t,e,i=1){return new It(i*t*e,-i*(t+e),i)}}class At{static isZero(t){return Math.abs(t)<this._EQN_EPS}static isSmallRatio(t,e,i=1e-9,s=8e-16){return Math.abs(t)<=i||Math.abs(t)<s*Math.abs(e)}static cbrt(t){return t>0?Math.pow(t,1/3):t<0?-Math.pow(-t,1/3):0}static safeDivide(t,e,i,s=0,n){return Math.abs(i)>this._safeDivideFactor*Math.abs(e)?(t[n]=e/i,!0):(t[n]=s,!1)}static checkRootProximity(t,e){return 0===e?t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):e>0&&e+1<t.length?t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)&&t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)}static newtonMethodAdjustment(t,e,i){let s=t[i],n=0;for(let r=i-1;r>=0;r--)n=s+e*n,s=t[r]+e*s;if(Math.abs(n)>=1e-14*(1+Math.abs(e)))return s/n}static improveRoots(t,e,i,s){for(let n=0;n<i.length;n++){let r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e);if(void 0===r||0===r)continue;const o=i.atUncheckedIndex(n);let a=0,c=0;for(;void 0!==r&&0!==r&&a<12;){if(Math.abs(r)<1e-10*(1+Math.abs(i.atUncheckedIndex(n)))){if(++c>1)break}else c=0;const h=i.atUncheckedIndex(n)-r;if(i.reassign(n,h),s&&!this.checkRootProximity(i,n)){i.reassign(n,o);break}r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(n),e),a++}}}static appendSolution(t,e){void 0!==t&&e.push(t)}static append2Solutions(t,e,i){i.push(t),i.push(e)}static appendLinearRoot(t,e,i){At.appendSolution(J.conditionalDivideFraction(-t,e),i)}static mostDistantFromMean(t){if(!t||0===t.length)return 0;let e=0;for(let i=0;i<t.length;i++)e+=t.atUncheckedIndex(i);e/=t.length;let i=0,s=t.atUncheckedIndex(0);for(let n=0;n<t.length;n++){const r=Math.abs(t.atUncheckedIndex(n)-e);r>i&&(i=r,s=t.atUncheckedIndex(n))}return s}static appendQuadraticRoots(t,e){const i=J.conditionalDivideFraction(1,t[2]);if(!i)return void this.appendLinearRoot(t[0],t[1],e);const s=.5*t[1]*i,n=s*s-t[0]*i;if(this.isZero(n))this.appendSolution(-s,e);else if(!(n<0)&&n>0){const t=Math.sqrt(n);this.append2Solutions(t-s,-t-s,e)}}static addConstant(t,e){for(let i=0;i<e.length;i++)e.reassign(i,e.atUncheckedIndex(i)+t)}static signedCubeRoot(t){return t>=0?Math.pow(t,1/3):-Math.pow(-t,1/3)}static appendFullCubicSolutions(t,e,i,s,n){const r=(e*e-3*t*i)/(t*t*9),o=-e/(3*t),a=s+o*(i+o*(e+o*t)),c=4*t*t*r*r*r,h=a*a-c;if(h>0){const e=Math.sqrt(h),i=.5/t;n.push(o+this.signedCubeRoot(i*(-a+e))+this.signedCubeRoot(i*(-a-e)))}else if(h<0){let e=Math.sqrt(c);t<0&&(e=-e);const i=Math.acos(-a/e)/3,s=2*Math.sqrt(r),h=2*Math.PI/3;n.push(o+s*Math.cos(i)),n.push(o+s*Math.cos(i+h)),n.push(o+s*Math.cos(i-h))}else{const e=this.signedCubeRoot(.5*a/t),i=o+e;n.push(o-2*e),n.push(i),n.push(i)}}static appendCubicRoots(t,e){void 0!==J.conditionalDivideCoordinate(1,t[3])?(this.appendFullCubicSolutions(t[3],t[2],t[1],t[0],e),this.improveRoots(t,3,e,!1)):this.appendQuadraticRoots(t,e),e.sort()}static appendQuarticRoots(t,e){const i=new Float64Array(4);let s,n;const r=new Float64Array(1);if(!this.safeDivide(r,1,t[4],0,0))return void this.appendCubicRoots(t,e);const o=t[3]*r[0],a=t[2]*r[0],c=t[1]*r[0],h=-.25*o,l=o*o,d=-3/8*l+a,u=.125*l*o-.5*o*a+c,f=-3/256*l*l+1/16*l*a-1/4*o*c+t[0]*r[0],g=new Pt;if(this.isZero(f))return i[0]=u,i[1]=d,i[2]=0,i[3]=1,this.appendCubicRoots(i,e),e.push(0),void this.addConstant(h,e);{i[0]=.5*f*d-1/8*u*u,i[1]=-f,i[2]=-.5*d,i[3]=1,this.appendCubicRoots(i,g);const t=this.mostDistantFromMean(g);if(s=t*t-f,n=2*t-d,this.isSmallRatio(s,f))s=0;else{if(!(s>0))return;s=Math.sqrt(s)}if(this.isSmallRatio(n,d))n=0;else{if(!(n>0)){for(let t=0;t<g.length;t++)e.push(g.atUncheckedIndex(t));return}n=Math.sqrt(n)}i[0]=t-s,i[1]=u<0?-n:n,i[2]=1,this.appendQuadraticRoots(i,e),i[0]=t+s,i[1]=u<0?n:-n,i[2]=1,this.appendQuadraticRoots(i,e)}this.addConstant(h,e),e.sort(),this.improveRoots(t,4,e,!0)}static appendCosSinRadians(t,e,i,s,n){i&&i.push(t),s&&s.push(e),n&&n.push(Math.atan2(e,t))}static appendImplicitLineUnitCircleIntersections(t,e,i,s,n,r,o=1e-14){let a;const c=e*e+i*i;let h=0;if(a=o<0?0:2*o,c<=0)h=0===t?-2:-1;else{const o=-t/c,l=1-t*t/c;if(l<-a){const a=Math.sqrt(c),l=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*l,i*l,s,n,r),h=0}else if(l<a){const a=Math.sqrt(c),l=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,s,n,r),this.appendCosSinRadians(e*l,i*l,s,n,r),h=1}else{const t=Math.sqrt(l/c),a=o*e,d=o*i;this.appendCosSinRadians(a-t*i,d+t*e,s,n,r),this.appendCosSinRadians(a+t*i,d-t*e,s,n,r),h=2}}return h}}At._EQN_EPS=1e-9,At._safeDivideFactor=1e-14;class St{static degreeKnownEvaluate(t,e,i){if(e<0)return 0;let s=t[e];for(let n=e-1;n>=0;n--)s=i*s+t[n];return s}static evaluate(t,e){const i=t.length-1;return this.degreeKnownEvaluate(t,i,e)}static accumulate(t,e,i){let s=t.length-1;const n=e.length-1;for(let s=0;s<=n;s++)t[s]+=i*e[s];for(;s>=0&&0===t[s];)s--;return s}static zero(t){for(let e=0;e<t.length;e++)t[e]=0}}class wt{static solveAngles(t,e,i,s){let n,r=Math.abs(i);s.length=0;const o=this._smallAngle;for(let i=0;i<=e;i++)n=Math.abs(t[i]),n>r&&(r=n);const a=o*r;let c=e;for(;c>0&&Math.abs(t[c])<=a;)c--;const h=new Pt;if(-1===c);else if(0===c||(1===c?h.push(-t[0]/t[1]):2===c?At.appendQuadraticRoots(t,h):3===c?At.appendCubicRoots(t,h):4===c&&At.appendQuarticRoots(t,h)),h.length>0){for(let t=0;t<h.length;t++){const e=St.evaluate(this.S,h.atUncheckedIndex(t)),i=St.evaluate(this.C,h.atUncheckedIndex(t));s.push(Math.atan2(e,i))}c<e&&s.push(-.5*Math.PI)}return s.length>0}static solveUnitCircleImplicitQuadricIntersection(t,e,i,s,n,r,o){const a=new Float64Array(5);let c;St.zero(a),J.hypotenuseXYZ(t,e,i)>wt._coefficientRelTol*J.hypotenuseXYZ(s,n,r)?(St.accumulate(a,this.CW,s),St.accumulate(a,this.SW,n),St.accumulate(a,this.WW,r),St.accumulate(a,this.SS,i),St.accumulate(a,this.CC,t),St.accumulate(a,this.SC,e),c=4):(St.accumulate(a,this.C,s),St.accumulate(a,this.S,n),St.accumulate(a,this.W,r),c=2);let h=0;return h=Math.max(h,Math.abs(t),Math.abs(i),Math.abs(e),Math.abs(s),Math.abs(n),Math.abs(r)),this.solveAngles(a,c,h,o)}static solveUnitCircleEllipseIntersection(t,e,i,s,n,r,o,a){a.length=0;const c=i*i+s*s,h=2*(i*n+s*r),l=n*n+r*r,d=2*(i*t+s*e),u=2*(n*t+r*e),f=t*t+e*e-1,g=this.solveUnitCircleImplicitQuadricIntersection(c,h,l,d,u,f,o);for(const c of o){const o=Math.cos(c),h=Math.sin(c),l=t+i*o+n*h,d=e+s*o+r*h;a.push(Math.atan2(d,l))}return g}static solveUnitCircleHomogeneousEllipseIntersection(t,e,i,s,n,r,o,a,c,h,l){l.length=0;const d=s*s+n*n-r*r,u=2*(s*o+n*a-r*c),f=o*o+a*a-c*c,g=2*(s*t+n*e-r*i),p=2*(o*t+a*e-c*i),m=t*t+e*e-i*i,x=this.solveUnitCircleImplicitQuadricIntersection(d,u,f,g,p,m,h);for(const i of h){const r=Math.cos(i),c=Math.sin(i),h=t+s*r+o*c,d=e+n*r+a*c;l.push(Math.atan2(d,h))}return x}}wt._smallAngle=1e-11,wt.S=Float64Array.from([0,2,-2]),wt.C=Float64Array.from([1,-2]),wt.W=Float64Array.from([1,-2,2]),wt.CW=Float64Array.from([1,-4,6,-4]),wt.SW=Float64Array.from([0,2,-6,8,-4]),wt.SC=Float64Array.from([0,2,-6,4]),wt.SS=Float64Array.from([0,0,4,-8,4]),wt.CC=Float64Array.from([1,-4,4]),wt.WW=Float64Array.from([1,-4,8,-8,4]),wt.CCminusSS=Float64Array.from([1,-4,0,8,-4]),wt._coefficientRelTol=1e-12;class Ct{static lineSegment2dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=J.crossProductXYXY(r,o,a,c),u=J.crossProductXYXY(h,l,a,c),f=J.crossProductXYXY(r,o,h,l),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(t,e,i,s,n,r,o,a,c){const h=n-t,l=r-e,d=J.crossProductXYXY(i,s,o,a),u=J.crossProductXYXY(h,l,o,a),f=J.crossProductXYXY(i,s,h,l),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(c.set(g,-p),!0):(c.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=J.crossProductXYXY(r,o,a,c),u=J.crossProductXYXY(h,l,a,c),f=J.crossProductXYXY(r,o,h,l),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(n.set(g,-p),!0):(n.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(t,e,i,s,n){const r=J.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w),o=J.tripleProduct(t.x,e.x,s.x,t.y,e.y,s.y,t.w,e.w,s.w),a=J.conditionalDivideFraction(-r,o-r);if(void 0!==a){const r=J.tripleProduct(i.x,s.x,t.x,i.y,s.y,t.y,i.w,s.w,t.w),o=J.tripleProduct(i.x,s.x,e.x,i.y,s.y,e.y,i.w,s.w,e.w),c=J.conditionalDivideFraction(-r,o-r);if(void 0!==c)return G.create(c,a,n)}}static lineSegment3dHXYClosestPointUnbounded(t,e,i){const s=e.x*t.w-t.x*e.w,n=e.y*t.w-t.y*e.w,r=J.tripleProduct(t.x,-n,i.x,t.y,s,i.y,t.w,0,i.w),o=J.tripleProduct(e.x,-n,i.x,e.y,s,i.y,e.w,0,i.w);return J.conditionalDivideFraction(-r,o-r)}static lineSegment3dXYClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=s*s+n*n,o=s*(i.x-t.x)+n*(i.y-t.y);return J.conditionalDivideFraction(o,r)}static lineSegment3dClosestPointUnbounded(t,e,i){const s=e.x-t.x,n=e.y-t.y,r=e.z-t.z,o=s*s+n*n+r*r,a=s*(i.x-t.x)+n*(i.y-t.y)+r*(i.z-t.z);return J.conditionalDivideFraction(a,o)}static lineSegment3dClosestApproachUnbounded(t,e,i,s,n){return this.ray3dXYZUVWClosestApproachUnbounded(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x,i.y,i.z,s.x-i.x,s.y-i.y,s.z-i.z,n)}static ray3dXYZUVWClosestApproachUnbounded(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=o-t,g=a-e,p=c-i,m=J.hypotenuseSquaredXYZ(s,n,r),x=J.hypotenuseSquaredXYZ(h,l,d),y=J.dotProductXYZXYZ(s,n,r,h,l,d),_=J.dotProductXYZXYZ(f,g,p,s,n,r),v=J.dotProductXYZXYZ(f,g,p,h,l,d);return Ct.linearSystem2d(m,-y,y,-x,_,v,u)}static linearSystem2d(t,e,i,s,n,r,o){const a=J.crossProductXYXY(t,i,e,s),c=J.crossProductXYXY(n,r,e,s),h=J.crossProductXYXY(t,i,n,r),l=J.conditionalDivideFraction(c,a),d=J.conditionalDivideFraction(h,a);return void 0!==l&&void 0!==d?(o.set(l,d),!0):(o.set(0,0),!1)}static linearSystem3d(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=J.tripleProduct(t,s,o,e,n,a,i,r,c),g=J.tripleProduct(h,l,d,e,n,a,i,r,c),p=J.tripleProduct(t,s,o,h,l,d,i,r,c),m=J.tripleProduct(t,s,o,e,n,a,h,l,d),x=J.conditionalDivideFraction(g,f),y=J.conditionalDivideFraction(p,f),_=J.conditionalDivideFraction(m,f);if(void 0!==x&&void 0!==y&&void 0!==_)return j.create(x,y,_,u)}static intersect3Planes(t,e,i,s,n,r,o){return this.linearSystem3d(e.x,e.y,e.z,s.x,s.y,s.z,r.x,r.y,r.z,J.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z),J.dotProductXYZXYZ(i.x,i.y,i.z,s.x,s.y,s.z),J.dotProductXYZXYZ(n.x,n.y,n.z,r.x,r.y,r.z),o)}static eliminateFromPivot(t,e,i,s){const n=t.length;let r=J.conditionalDivideFraction(i[e],t[e]);if(void 0===r)return!1;r*=s;for(let s=e+1;s<n;s++)i[s]+=r*t[s];return!0}static solveBilinearPair(t,e,i,s,n,r,o,a){const c=J.crossProductXYXY(t,n,i,o),h=J.crossProductXYXY(e,r,i,o)+J.crossProductXYXY(t,n,s,a),l=J.crossProductXYXY(e,r,s,a),d=It.solveQuadratic(l,h,c);if(void 0===d)return;const u=[];for(const c of d){const h=J.conditionalDivideFraction(-(t+e*c),i+s*c),l=J.conditionalDivideFraction(-(n+r*c),o+a*c);void 0!==h?u.push(W.create(c,h)):void 0!==l&&u.push(W.create(c,l))}return u}}class Tt{constructor(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}set(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}evaluateRadians(t){return this.a+this.cosineCoff*Math.cos(t)+this.sineCoff*Math.sin(t)}range(t){const e=J.hypotenuseXY(this.cosineCoff,this.sineCoff);return dt.createXX(this.a-e,this.a+e,t)}rangeInStartEndRadians(t,e,i){if(Z.isFullCircleRadians(e-t))return this.range(i);i=dt.createXX(this.evaluateRadians(t),this.evaluateRadians(e),i);const s=Math.atan2(this.sineCoff,this.cosineCoff),n=s+Math.PI;return vt.isRadiansInStartEnd(s,t,e)&&i.extendX(this.evaluateRadians(s)),vt.isRadiansInStartEnd(n,t,e)&&i.extendX(this.evaluateRadians(n)),i}rangeInSweep(t,e){return this.rangeInStartEndRadians(t.startRadians,t.endRadians,e)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class kt{constructor(t,e){this.origin=t,this.direction=e,this.a=void 0}static _create(t,e,i,s,n,r){return new kt(K.create(t,e,i),j.create(s,n,r))}static createXAxis(){return kt._create(0,0,0,1,0,0)}static createYAxis(){return kt._create(0,0,0,0,1,0)}static createZAxis(){return kt._create(0,0,0,0,0,1)}static createZero(t){return t?(t.origin.setZero(),t.direction.setZero(),t):new kt(K.createZero(),j.createZero())}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.direction.isAlmostEqual(t.direction)}dotProductToPoint(t){return this.direction.dotProductStartEnd(this.origin,t)}pointToFraction(t){return J.safeDivideFraction(this.dotProductToPoint(t),this.direction.magnitudeSquared(),0)}projectPointToRay(t){return this.origin.plusScaled(this.direction,this.pointToFraction(t))}isAlmostEqualPointSet(t){if(!this.direction.isParallelTo(t.direction,!0))return!1;let e=this.projectPointToRay(t.origin);return!!t.origin.isAlmostEqualMetric(e)&&(e=t.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(e))}static create(t,e,i){return i?(i.set(t,e),i):new kt(t.clone(),e.clone())}static createWeightedDerivative(t,e,i){const s=t[3],n=e[3],r=t[0],o=t[1],a=t[2],c=e[0]*s-t[0]*n,h=e[1]*s-t[1]*n,l=e[2]*s-t[2]*n;if(J.isSmallMetricDistance(s))return;const d=1/s,u=d*d;return kt.createXYZUVW(r*d,o*d,a*d,c*u,h*u,l*u,i)}static createXYZUVW(t,e,i,s,n,r,o){return o?(o.getOriginRef().set(t,e,i),o.getDirectionRef().set(s,n,r),o):new kt(K.create(t,e,i),j.create(s,n,r))}static createCapture(t,e){return new kt(t,e)}static createPointVectorNumber(t,e,i,s){return s?(s.origin.setFrom(t),s.direction.setFrom(e),s.a=i,s):((s=new kt(t.clone(),e.clone())).a=i,s)}static createStartEnd(t,e,i){return i?(i.origin.setFrom(t),i.direction.setStartEnd(t,e),i):new kt(t.clone(),j.createStartEnd(t,e))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(t,e){this.origin.setFrom(t),this.direction.setFrom(e)}clone(t){return t?(t.set(this.origin.clone(),this.direction.clone()),t):new kt(this.origin.clone(),this.direction.clone())}cloneTransformed(t,e){return kt.create(t.multiplyPoint3d(this.origin,e?.origin),t.multiplyVector(this.direction,e?.direction),e)}cloneInverseTransformed(t,e){if(t.computeCachedInverse(!0))return kt.create(t.multiplyInversePoint3d(this.origin,e?.origin),t.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,e?.direction),e)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.direction,this.direction)}setFrom(t){this.set(t.origin,t.direction)}fractionToPoint(t,e){return this.origin.plusScaled(this.direction,t,e)}toRigidZFrame(){const t=pt.createRigidHeadsUp(this.direction,g.ZXY);return ft.createOriginAndMatrix(this.origin,t)}setFromJSON(t){if(!t)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(t.origin),this.direction.setFromJSON(t.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(t){const e=kt.createXAxis();return e.setFromJSON(t),e}trySetDirectionMagnitudeInPlace(t=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(t),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(t){const e=J.smallMetricDistanceSquared;return this.a=t,!!(Math.abs(t)>e&&this.direction.tryNormalizeInPlace(e))||(this.direction.setZero(),this.a=0,!1)}distance(t){const e=this.direction.magnitudeSquared(),i=this.dotProductToPoint(t),s=J.inverseMetricDistanceSquared(e);return s?Math.sqrt(this.origin.distanceSquared(t)-i*i*s):Math.sqrt(this.origin.distanceSquared(t))}intersectionWithPlane(t,e){const i=j.createStartEnd(t.getOriginRef(),this.origin),s=this.direction.dotProduct(t.getNormalRef()),n=this.direction.magnitudeSquared(),r=i.dotProduct(t.getNormalRef()),o=J.conditionalDivideFraction(-r,s);if(void 0!==o)return void 0!==J.conditionalDivideFraction(n,s)?(e&&this.origin.plusScaled(this.direction,o,e),o):void 0}intersectionWithRange3d(t,e){if(t.isNull)return dt.createNull(e);const i=dt.createXX(-J.largeCoordinateResult,J.largeCoordinateResult,e);return i.clipLinearMapToInterval(this.origin.x,this.direction.x,t.low.x,t.high.x)&&i.clipLinearMapToInterval(this.origin.y,this.direction.y,t.low.y,t.high.y)&&i.clipLinearMapToInterval(this.origin.z,this.direction.z,t.low.z,t.high.z),i}intersectionWithTriangle(t,e,i,s,n,r){(void 0===s||s<0)&&(s=J.smallMetricDistance),(void 0===n||n<0)&&(n=J.smallFloatingPoint);const o=kt._workVector0=j.createStartEnd(t,e,kt._workVector0),a=kt._workVector1=j.createStartEnd(t,i,kt._workVector1),c=kt._workVector2=this.direction.crossProduct(a,kt._workVector2),h=o.dotProduct(c);if(h>=-s&&h<=s)return;const l=1/h,d=kt._workVector3=j.createStartEnd(t,this.origin,kt._workVector3);let u=l*d.dotProduct(c);if(u<0){if(!(u>-n))return;u=0}else if(u>1){if(!(u<1+n))return;u=1}const f=kt._workVector4=d.crossProduct(o,kt._workVector4);let g=l*this.direction.dotProduct(f);if(g<0){if(!(g>-n))return;g=0}else if(u+g>1){if(!(u+g<1+n))return;g=1-u}const p=l*a.dotProduct(f);return p<=s?void 0:this.origin.plusScaled(this.direction,p,r)}perpendicularPartOfVectorToTarget(t,e){const i=j.createStartEnd(this.origin,t),s=this.direction.magnitudeSquared(),n=this.direction.dotProductStartEnd(this.origin,t),r=J.safeDivideFraction(n,s,0);return i.plusScaled(this.direction,-r,e)}static closestApproachRay3dRay3d(t,e){const i=G.create();let s,n,r,o,a;Ct.ray3dXYZUVWClosestApproachUnbounded(t.origin.x,t.origin.y,t.origin.z,t.direction.x,t.direction.y,t.direction.z,e.origin.x,e.origin.y,e.origin.z,e.direction.x,e.direction.y,e.direction.z,i)?(s=i.x,n=i.y,r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?A.Intersection:A.PerpendicularChord):(n=0,s=t.pointToFraction(e.origin),r=t.fractionToPoint(s),o=e.fractionToPoint(n),a=r.isAlmostEqualMetric(o)?A.CoincidentGeometry:A.ParallelGeometry);const c=_t.createCapture(yt.createRayFractionPoint(t,s,t.fractionToPoint(s)),yt.createRayFractionPoint(e,n,e.fractionToPoint(n)));return c.approachType=a,c}static interpolatePointAndTangent(t,e,i,s,n){n=n??kt.createZero();const r=i.x-t.x,o=i.y-t.y,a=i.z-t.z;if(n.direction.set(s*r,s*o,s*a),e<=.5)n.origin.set(t.x+e*r,t.y+e*o,t.z+e*a);else{const t=e-1;n.origin.set(i.x+t*r,i.y+t*o,i.z+t*a)}return n}}class Ft extends Q{constructor(t,e,i){super(),this.origin=t,this.vectorU=e,this.vectorV=i}static createOriginAndVectors(t,e,i,s){return s?(s.origin.setFrom(t),s.vectorU.setFrom(e),s.vectorV.setFrom(i),s):new Ft(t.clone(),e.clone(),i.clone())}clone(t){return void 0!==t&&t.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new Ft(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(t,e){if(t instanceof Ft)return t.clone(e);const i=t.getUnitNormal();if(void 0===i)return;const s=t.getAnyPointOnPlane(),n=pt.createPerpendicularVectorFavorXYPlane(i);if(n.tryNormalizeInPlace()){const t=i.unitCrossProduct(n);if(void 0!==t)return new Ft(s,n,t)}}static createFromTransformColumnsXYAndLengths(t,e,i,s){return s?(s.origin.setFrom(t.getOrigin()),t.matrix.columnX(s.vectorU),t.matrix.columnY(s.vectorV)):s=new Ft(t.getOrigin(),t.matrix.columnX(),t.matrix.columnY()),void 0!==e&&s.vectorU.scaleToLength(e,s.vectorU),void 0!==i&&s.vectorV.scaleToLength(i,s.vectorV),s}static createCapture(t,e,i,s){return s?(s.origin=t,s.vectorU=e,s.vectorV=i,s):new Ft(t,e,i)}setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c){return this.origin.set(t,e,i),this.vectorU.set(s,n,r),this.vectorV.set(o,a,c),this}setOriginAndVectors(t,e,i){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(i),this}static createOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c,h){return h?h.setOriginAndVectorsXYZ(t,e,i,s,n,r,o,a,c):new Ft(K.create(t,e,i),j.create(s,n,r),j.create(o,a,c))}static createOriginAndTargets(t,e,i,s){return Ft.createOriginAndVectorsXYZ(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,s)}static createXYPlane(t){return Ft.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,t)}static createOriginAndVectorsArrays(t,e,i,s){return Ft.createOriginAndVectorsXYZ(t[0],t[1],t[2],e[0],e[1],e[2],i[0],i[1],i[2],s)}static createOriginAndVectorsWeightedArrays(t,e,i,s){const n=t[3];if(s=Ft.createXYPlane(s),J.isSmallMetricDistance(n))return s;const r=1/n,o=e[3]*r*r,a=i[3]*r*r;return s.origin.set(t[0]*r,t[1]*r,t[2]*r),j.createAdd2ScaledXYZ(e[0],e[1],e[2],r,t[0],t[1],t[2],-o,s.vectorU),j.createAdd2ScaledXYZ(i[0],i[1],i[2],r,t[0],t[1],t[2],-a,s.vectorV),s}fractionToPoint(t,e,i){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,i)}fractionToVector(t,e,i){return j.createAdd2Scaled(this.vectorU,t,this.vectorV,e,i)}setFromJSON(t){t&&t.origin&&t.vectorV?(this.origin.setFromJSON(t.origin),this.vectorU.setFromJSON(t.vectorU),this.vectorV.setFromJSON(t.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(t){const e=Ft.createXYPlane();return e.setFromJSON(t),e}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}normalizeInPlace(){const t=this.vectorU.normalizeInPlace(),e=this.vectorV.normalizeInPlace();return t&&e}getUnitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}unitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}getAnyPointOnPlane(t){return this.origin.clone(t)}unitNormalRay(t){Ft._workVector||(Ft._workVector=j.create());const e=this.vectorU.unitCrossProduct(this.vectorV,Ft._workVector);if(void 0!==e)return kt.create(this.origin,e,t)}toRigidFrame(t){return ft.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,g.XYZ,t)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.vectorU,this.vectorU),t.multiplyVector(this.vectorV,this.vectorV)}normalX(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.x:0}normalY(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.y:0}normalZ(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.z:0}altitude(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:J.dotProductXYZXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,e.x,e.y,e.z)}altitudeXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:J.dotProductXYZXYZ(t-this.origin.x,e-this.origin.y,i-this.origin.z,s.x,s.y,s.z)}velocity(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:J.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z)}velocityXYZ(t,e,i){const s=this.vectorU.unitCrossProduct(this.vectorV);return void 0===s?0:J.dotProductXYZXYZ(t,e,i,s.x,s.y,s.z)}weightedAltitude(t){const e=t.w;return J.tripleProduct(t.x-this.origin.x*e,t.y-this.origin.y*e,t.z-this.origin.z*e,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(t,e){const i=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==i){const s=i.dotProductStartEnd(this.origin,t);return t.plusScaled(i,-s,e)}const s=this.vectorU.magnitudeSquared(),n=this.vectorV.magnitudeSquared();if(s>=n){const i=this.vectorU.dotProductStartEnd(this.origin,t),n=J.conditionalDivideCoordinate(i,s,0);if(void 0!==n)return t.plusScaled(this.vectorU,n,e)}else{const i=this.vectorV.dotProductStartEnd(this.origin,t),s=J.conditionalDivideCoordinate(i,n,0);if(void 0!==s)return t.plusScaled(this.vectorV,s,e)}return this.origin.clone(e)}}function Mt(t,e,i,s,n,r){return r*(t-2*n*e-s*i)}class bt extends Q{set(t=0,e=0,i=0,s=0){return this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s,this}setComponent(t,e){t>=0&&t<4&&(this.xyzw[t]=e)}get x(){return this.xyzw[0]}set x(t){this.xyzw[0]=t}get y(){return this.xyzw[1]}set y(t){this.xyzw[1]=t}get z(){return this.xyzw[2]}set z(t){this.xyzw[2]=t}get w(){return this.xyzw[3]}set w(t){this.xyzw[3]=t}constructor(t=0,e=0,i=0,s=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=s}static create(t=0,e=0,i=0,s=0,n){return n?n.set(t,e,i,s):new bt(t,e,i,s)}static createPlaneFrom(t){return new bt(t.normalX(),t.normalY(),t.normalZ(),t.altitudeXYZ(0,0,0))}setFrom(t){return this.xyzw[0]=t.xyzw[0],this.xyzw[1]=t.xyzw[1],this.xyzw[2]=t.xyzw[2],this.xyzw[3]=t.xyzw[3],this}clone(t){return t?t.setFrom(this):new bt(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(t){J.isNumberArray(t,4)?this.set(t[0],t[1],t[2],t[3]):this.set(0,0,0,0)}static fromJSON(t){const e=new bt;return e.setFromJSON(t),e}isAlmostEqual(t){return J.isSameCoordinate(this.x,t.x)&&J.isSameCoordinate(this.y,t.y)&&J.isSameCoordinate(this.z,t.z)&&J.isSameCoordinate(this.w,t.w)}isAlmostEqualXYZW(t,e,i,s){return J.isSameCoordinate(this.x,t)&&J.isSameCoordinate(this.y,e)&&J.isSameCoordinate(this.z,i)&&J.isSameCoordinate(this.w,s)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(t){return J.hypotenuseXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(t){return J.hypotenuseSquaredXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}realDistanceXY(t){const e=this.w,i=t.w;if(!J.isSmallMetricDistance(e)&&!J.isSmallMetricDistance(i))return J.hypotenuseXY(t.xyzw[0]/i-this.xyzw[0]/e,t.xyzw[1]/i-this.xyzw[1]/e)}maxDiff(t){return Math.max(Math.abs(t.xyzw[0]-this.xyzw[0]),Math.abs(t.xyzw[1]-this.xyzw[1]),Math.abs(t.xyzw[2]-this.xyzw[2]),Math.abs(t.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return J.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return J.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(t,e){return bt.create(this.xyzw[0]-t.xyzw[0],this.xyzw[1]-t.xyzw[1],this.xyzw[2]-t.xyzw[2],this.xyzw[3]-t.xyzw[3],e)}crossWeightedMinus(t,e){const i=this.xyzw[3],s=t.xyzw[3];return j.create(s*this.xyzw[0]-i*t.xyzw[0],s*this.xyzw[1]-i*t.xyzw[1],s*this.xyzw[2]-i*t.xyzw[2],e)}crossWeightedMinusPoint3d(t,e){const i=this.xyzw[3];return j.create(this.xyzw[0]-i*t.x,this.xyzw[1]-i*t.y,this.xyzw[2]-i*t.z,e)}plus(t,e){return bt.create(this.xyzw[0]+t.xyzw[0],this.xyzw[1]+t.xyzw[1],this.xyzw[2]+t.xyzw[2],this.xyzw[3]+t.xyzw[3],e)}get isAlmostZero(){return J.isSmallMetricDistance(this.maxAbs())}static createZero(){return new bt(0,0,0,0)}static createPlanePointPointZ(t,e,i){return bt.create(t.y*e.w-t.w*e.y,t.w*e.x-t.x*e.w,0,t.x*e.y-t.y*e.x,i)}static createFromPackedXYZW(t,e=0,i){return bt.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPointAndWeight(t,e){return new bt(t.x,t.y,t.z,e)}static createFromPoint(t){if(t instanceof W)return new bt(t.x,t.y,0,1);if(t instanceof K)return new bt(t.x,t.y,t.z,1);if(t instanceof bt)return t.clone();if(Array.isArray(t)){const e=t.length>0?t[0]:0,i=t.length>1?t[1]:0,s=t.length>2?t[2]:0,n=t.length>3?t[3]:1;return new bt(e,i,s,n)}const e=t.x,i=t.y,s=t.hasOwnProperty("z")?t.z:0,n=t.hasOwnProperty("w")?t.w:1;return new bt(e,i,s,n)}plusScaled(t,e,i){return bt.create(this.xyzw[0]+t.xyzw[0]*e,this.xyzw[1]+t.xyzw[1]*e,this.xyzw[2]+t.xyzw[2]*e,this.xyzw[3]+t.xyzw[3]*e,i)}interpolate(t,e,i){const s=1-t;return bt.create(this.xyzw[0]*s+e.xyzw[0]*t,this.xyzw[1]*s+e.xyzw[1]*t,this.xyzw[2]*s+e.xyzw[2]*t,this.xyzw[3]*s+e.xyzw[3]*t,i)}plus2Scaled(t,e,i,s,n){return bt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s,n)}plus3Scaled(t,e,i,s,n,r,o){return bt.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}static createAdd2Scaled(t,e,i,s,n){return bt.create(t.xyzw[0]*e+i.xyzw[0]*s,t.xyzw[1]*e+i.xyzw[1]*s,t.xyzw[2]*e+i.xyzw[2]*s,t.xyzw[3]*e+i.xyzw[3]*s,n)}static createAdd3Scaled(t,e,i,s,n,r,o){return bt.create(t.xyzw[0]*e+i.xyzw[0]*s+n.xyzw[0]*r,t.xyzw[1]*e+i.xyzw[1]*s+n.xyzw[1]*r,t.xyzw[2]*e+i.xyzw[2]*s+n.xyzw[2]*r,t.xyzw[3]*e+i.xyzw[3]*s+n.xyzw[3]*r,o)}dotVectorsToTargets(t,e){return(t.xyzw[0]-this.xyzw[0])*(e.xyzw[0]-this.xyzw[0])+(t.xyzw[1]-this.xyzw[1])*(e.xyzw[1]-this.xyzw[1])+(t.xyzw[2]-this.xyzw[2])*(e.xyzw[2]-this.xyzw[2])+(t.xyzw[3]-this.xyzw[3])*(e.xyzw[3]-this.xyzw[3])}dotProduct(t){return this.xyzw[0]*t.xyzw[0]+this.xyzw[1]*t.xyzw[1]+this.xyzw[2]*t.xyzw[2]+this.xyzw[3]*t.xyzw[3]}dotProductXYZW(t,e,i,s){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]*s}altitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]}altitudeXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]}weightedAltitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]*t.w}velocity(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z}velocityXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new bt(1,0,0,0)}static unitY(){return new bt(0,1,0,0)}static unitZ(){return new bt(0,0,1,0)}static unitW(){return new bt(0,0,0,1)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}projectPointToPlane(t,e){const i=this.altitude(t),s=this.magnitudeSquaredXYZ(),n=J.conditionalDivideCoordinate(-i,s);return void 0===n?t.clone(e):t.plusXYZ(n*this.x,n*this.y,n*this.z,e)}scale(t,e){return(e=e||new bt).xyzw[0]=this.xyzw[0]*t,e.xyzw[1]=this.xyzw[1]*t,e.xyzw[2]=this.xyzw[2]*t,e.xyzw[3]=this.xyzw[3]*t,e}negate(t){return(t=t||new bt).xyzw[0]=-this.xyzw[0],t.xyzw[1]=-this.xyzw[1],t.xyzw[2]=-this.xyzw[2],t.xyzw[3]=-this.xyzw[3],t}normalizeWeight(t){const e=J.correctSmallFraction(this.xyzw[3]);return t=t||new bt,this.safeDivideOrNull(e,t)}realPoint(t){const e=J.correctSmallFraction(this.xyzw[3]);if(0===e)return;const i=1/e;return K.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}realPointOrVector(){const t=J.correctSmallFraction(this.xyzw[3]);if(0===t)return j.create(this.x,this.y,this.z);const e=1/t;return K.create(this.x*e,this.y*e,this.z*e)}static createRealPoint3dDefault000(t,e,i,s,n){const r=J.correctSmallFraction(s),o=0===r?0:1/r;return K.create(t*o,e*o,i*o,n)}static createRealDerivativeRay3dDefault000(t,e,i,s,n,r,o,a,c){const h=J.correctSmallFraction(s),l=0===h?0:1/h,d=l*l;return kt.createXYZUVW(t*l,e*l,i*l,(n*s-a*t)*d,(r*s-a*e)*d,(o*s-a*i)*d,c)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(t,e,i,s,n,r,o,a,c,h,l,d,u){const f=J.correctSmallFraction(s),g=0===f?0:1/f,p=g*g,m=t*g,x=e*g,y=i*g,_=(n*s-a*t)*p,v=(r*s-a*e)*p,P=(o*s-a*i)*p;return Ft.createOriginAndVectorsXYZ(m,x,y,_,v,P,Mt(c,a,d,m,_,g),Mt(h,a,d,x,v,g),Mt(l,a,d,y,P,g),u)}realPointDefault000(t){const e=J.correctSmallFraction(this.xyzw[3]);if(0===e)return K.create(0,0,0,t);t=t||new K;const i=1/e;return K.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}normalizeXYZW(t){const e=J.correctSmallFraction(this.magnitudeXYZW());return t=t||new bt,this.safeDivideOrNull(e,t)}static determinantIndexed3X3(t,e,i,s,n,r){return J.tripleProduct(t.xyzw[s],t.xyzw[n],t.xyzw[r],e.xyzw[s],e.xyzw[n],e.xyzw[r],i.xyzw[s],i.xyzw[n],i.xyzw[r])}static perpendicularPoint4dPlane(t,e,i){return bt.create(bt.determinantIndexed3X3(t,e,i,1,2,3),-bt.determinantIndexed3X3(t,e,i,2,3,0),bt.determinantIndexed3X3(t,e,i,3,0,1),-bt.determinantIndexed3X3(t,e,i,0,1,2))}toPlane3dByOriginAndUnitNormal(t){return mt.createFrom(this,t)}normalizeQuaternion(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e,this.w*=e}return t}static interpolateQuaternions(t,e,i,s){if(s||(s=new bt),0===e)return t;if(1===e)return i;if(.5===e)return t.plus(i,s),s.normalizeQuaternion(),s;const n=t.clone(),r=i.clone();let o=t.dotProduct(i);if(o<0&&(r.negate(r),o=-o),o>.9995)return n.interpolate(e,r,s),s.normalizeQuaternion(),s;o<-1?o=-1:o>1&&(o=1);const a=new bt;r.plusScaled(n,-o,a),a.normalizeQuaternion();const c=Math.acos(o)*e;return bt.createAdd2Scaled(n,Math.cos(c),a,Math.sin(c))}radiansToPoint4dXYZW(t){const e=this.magnitudeXYZW(),i=t.magnitudeXYZW(),s=this.dotProduct(t),n=J.conditionalDivideFraction(s,e*i);if(void 0!==n)return Math.acos(n)}}class Et{constructor(){this._coffs=new Float64Array(16)}setFrom(t){for(let e=0;e<16;e++)this._coffs[e]=t._coffs[e]}clone(t){if(t===this)return this;void 0===t&&(t=new Et);for(let e=0;e<16;e++)t._coffs[e]=this._coffs[e];return t}setZero(){for(let t=0;t<16;t++)this._coffs[t]=0}setIdentity(){for(let t=0;t<16;t++)this._coffs[t]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(t,e,i,s,n){return Math.abs(t-1)<=n&&Math.abs(e)<=n&&Math.abs(i)<=n&&Math.abs(s)<=n}isIdentity(t=1e-10){return Et.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],t)&&Et.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],t)&&Et.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],t)&&Et.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],t)}static createZero(t){return t?(t.setZero(),t):new Et}static createRowValues(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g,p,m){return(m=m||new Et)._coffs[0]=t,m._coffs[1]=e,m._coffs[2]=i,m._coffs[3]=s,m._coffs[4]=n,m._coffs[5]=r,m._coffs[6]=o,m._coffs[7]=a,m._coffs[8]=c,m._coffs[9]=h,m._coffs[10]=l,m._coffs[11]=d,m._coffs[12]=u,m._coffs[13]=f,m._coffs[14]=g,m._coffs[15]=p,m}static createRows(t,e,i,s,n){return this.createRowValues(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,i.x,i.y,i.z,i.w,s.x,s.y,s.z,s.w,n)}setOriginAndVectors(t,e,i,s){this._coffs[0]=e.x,this._coffs[1]=i.x,this._coffs[2]=s.x,this._coffs[3]=t.x,this._coffs[4]=e.y,this._coffs[5]=i.y,this._coffs[6]=s.y,this._coffs[7]=t.y,this._coffs[8]=e.z,this._coffs[9]=i.z,this._coffs[10]=s.z,this._coffs[11]=t.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(t,e){const i=t.matrix,s=t.origin;return Et.createRowValues(i.coffs[0],i.coffs[1],i.coffs[2],s.x,i.coffs[3],i.coffs[4],i.coffs[5],s.y,i.coffs[6],i.coffs[7],i.coffs[8],s.z,0,0,0,1,e)}static createIdentity(t){return(t=Et.createZero(t))._coffs[0]=1,t._coffs[5]=1,t._coffs[10]=1,t._coffs[15]=1,t}static createTranslationXYZ(t,e,i,s){return(s=Et.createZero(s))._coffs[0]=1,s._coffs[5]=1,s._coffs[10]=1,s._coffs[15]=1,s._coffs[3]=t,s._coffs[7]=e,s._coffs[11]=i,s}plusScaled(t,e,i){i=this.clone(i);for(let s=0;s<16;s++)i._coffs[s]+=e*t._coffs[s];return i}static createTranslationAndScaleXYZ(t,e,i,s,n,r,o){return Et.createRowValues(s,0,0,t,0,n,0,e,0,0,r,i,0,0,0,1,o)}static createBoxToBox(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=e.z-t.z,c=s.x-i.x,h=s.y-i.y,l=s.z-i.z,d=J.conditionalDivideFraction(c,r),u=J.conditionalDivideFraction(h,o),f=J.conditionalDivideFraction(l,a);if(void 0!==d&&void 0!==u&&void 0!==f)return Et.createTranslationAndScaleXYZ(i.x-d*t.x,i.y-u*t.y,i.z-f*t.z,d,u,f,n)}setFromJSON(t){if(J.isArrayOfNumberArray(t,4,4))for(let e=0;e<4;++e)for(let i=0;i<4;++i)this._coffs[4*e+i]=t[e][i];else this.setZero()}maxDiff(t){let e=0;for(let i=0;i<16;i++)e=Math.max(e,Math.abs(this._coffs[i]-t._coffs[i]));return e}maxAbs(){let t=0;for(let e=0;e<16;e++)t=Math.max(t,Math.abs(this._coffs[e]));return t}isAlmostEqual(t){return J.isSmallMetricDistance(this.maxDiff(t))}isExactEqual(t){return 0===this.maxDiff(t)}toJSON(){const t=[];for(let e=0;e<4;++e){const i=4*e;t.push([this._coffs[i],this._coffs[i+1],this._coffs[i+2],this._coffs[i+3]])}return t}static fromJSON(t){const e=new Et;return e.setFromJSON(t),e}getSteppedPoint(t,e,i){return bt.create(this._coffs[t],this._coffs[t+e],this._coffs[t+2*e],this._coffs[t+3*e],i)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return pt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return ft.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(t,e){e=e&&e!==this&&e!==t?e:new Et;for(let i=0;i<16;i+=4)for(let s=0;s<4;s++)e._coffs[i+s]=this._coffs[i]*t._coffs[s]+this._coffs[i+1]*t._coffs[s+4]+this._coffs[i+2]*t._coffs[s+8]+this._coffs[i+3]*t._coffs[s+12];return e}multiplyMatrixMatrixTranspose(t,e){e=e&&e!==this&&e!==t?e:new Et;let i=0;for(let s=0;s<16;s+=4)for(let n=0;n<16;n+=4)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+1]*t._coffs[n+1]+this._coffs[s+2]*t._coffs[n+2]+this._coffs[s+3]*t._coffs[n+3];return e}multiplyMatrixTransposeMatrix(t,e){e=e&&e!==this&&e!==t?e:new Et;let i=0;for(let s=0;s<4;s+=1)for(let n=0;n<4;n+=1)e._coffs[i++]=this._coffs[s]*t._coffs[n]+this._coffs[s+4]*t._coffs[n+4]+this._coffs[s+8]*t._coffs[n+8]+this._coffs[s+12]*t._coffs[n+12];return e}cloneTransposed(t){return Et.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],t)}multiplyXYZW(t,e,i,s,n){return(n=n||bt.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s,this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s)}multiplyBlockedFloat64ArrayInPlace(t){const e=t.length;let i,s,n,r;for(let o=0;o+3<e;o+=4)i=t[o],s=t[o+1],n=t[o+2],r=t[o+3],t[o]=this._coffs[0]*i+this._coffs[1]*s+this._coffs[2]*n+this._coffs[3]*r,t[o+1]=this._coffs[4]*i+this._coffs[5]*s+this._coffs[6]*n+this._coffs[7]*r,t[o+2]=this._coffs[8]*i+this._coffs[9]*s+this._coffs[10]*n+this._coffs[11]*r,t[o+3]=this._coffs[12]*i+this._coffs[13]*s+this._coffs[14]*n+this._coffs[15]*r}multiplyPoint3d(t,e,i){return this.multiplyXYZW(t.x,t.y,t.z,e,i)}multiplyPoint3dArray(t,e,i=1){t.forEach(((t,s)=>{e[s]=this.multiplyXYZW(t.x,t.y,t.z,i,e[s])}))}multiplyTransposeXYZW(t,e,i,s,n){return(n=n||bt.createZero()).set(this._coffs[0]*t+this._coffs[4]*e+this._coffs[8]*i+this._coffs[12]*s,this._coffs[1]*t+this._coffs[5]*e+this._coffs[9]*i+this._coffs[13]*s,this._coffs[2]*t+this._coffs[6]*e+this._coffs[10]*i+this._coffs[14]*s,this._coffs[3]*t+this._coffs[7]*e+this._coffs[11]*i+this._coffs[15]*s)}rowDotColumn(t,e,i){const s=4*t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+4]+this._coffs[s+2]*e._coffs[n+8]+this._coffs[s+3]*e._coffs[n+12]}rowDotXYZW(t,e,i,s,n){const r=4*t;return this._coffs[r]*e+this._coffs[r+1]*i+this._coffs[r+2]*s+this._coffs[r+3]*n}rowDotRow(t,e,i){const s=4*t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+1]*e._coffs[n+1]+this._coffs[s+2]*e._coffs[n+2]+this._coffs[s+3]*e._coffs[n+3]}columnDotColumn(t,e,i){const s=t,n=i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+4]+this._coffs[s+8]*e._coffs[n+8]+this._coffs[s+12]*e._coffs[n+12]}columnDotRow(t,e,i){const s=t,n=4*i;return this._coffs[s]*e._coffs[n]+this._coffs[s+4]*e._coffs[n+1]+this._coffs[s+8]*e._coffs[n+2]+this._coffs[s+12]*e._coffs[n+3]}atIJ(t,e){return this._coffs[4*t+e]}setAtIJ(t,e,i){this._coffs[4*t+e]=i}multiplyXYZWQuietRenormalize(t,e,i,s,n){(n=n||K.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*s,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*s,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*s);const r=this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*s,o=J.conditionalDivideCoordinate(n.x,r),a=J.conditionalDivideCoordinate(n.y,r),c=J.conditionalDivideCoordinate(n.z,r);return void 0!==o&&void 0!==a&&void 0!==c&&(n.x=o,n.y=a,n.z=c),n}multiplyPoint4dArrayQuietRenormalize(t,e){t.forEach(((t,i)=>{e[i]=this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,t.w,e[i])}))}multiplyPoint4d(t,e){return this.multiplyXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyTransposePoint4d(t,e){return this.multiplyTransposeXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyPoint3dQuietNormalize(t,e){return this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,e)}multiplyPoint3dArrayQuietNormalize(t){t.forEach((t=>this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,t)))}addMomentsInPlace(t,e,i,s){this._coffs[0]+=t*t,this._coffs[1]+=t*e,this._coffs[2]+=t*i,this._coffs[3]+=t*s,this._coffs[4]+=e*t,this._coffs[5]+=e*e,this._coffs[6]+=e*i,this._coffs[7]+=e*s,this._coffs[8]+=i*t,this._coffs[9]+=i*e,this._coffs[10]+=i*i,this._coffs[11]+=i*s,this._coffs[12]+=s*t,this._coffs[13]+=s*e,this._coffs[14]+=s*i,this._coffs[15]+=s*s}addScaledInPlace(t,e=1){for(let i=0;i<16;i++)this._coffs[i]+=e*t._coffs[i]}rowOperation(t,e,i,s){if(0===s)return;let n=4*t+i,r=4*e+i;for(let t=i;t<4;t++,n++,r++)this._coffs[r]+=s*this._coffs[n]}determinant(){const t=this._coffs;return J.determinant4x4(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}createInverse(t){let e=this.columnX().maxAbs();if(0===e)return;const i=1/e;if(e=this.columnY().maxAbs(),0===e)return;const s=1/e;if(e=this.columnZ().maxAbs(),0===e)return;const n=1/e;if(e=this.columnW().maxAbs(),0===e)return;const r=1/e,o=this.columnX(),a=this.columnY(),c=this.columnZ(),h=this.columnW();o.scale(i,o),a.scale(s,a),c.scale(n,c),h.scale(r,h);const l=bt.perpendicularPoint4dPlane(a,c,h),d=bt.perpendicularPoint4dPlane(o,h,c),u=bt.perpendicularPoint4dPlane(h,o,a),f=bt.perpendicularPoint4dPlane(c,a,o);t=Et.createRows(l,d,u,f,t);const g=l.dotProduct(o),p=d.dotProduct(a),m=u.dotProduct(c),x=f.dotProduct(h),y=t.maxAbs();if(g*p>0&&g*m>0&&g*x>0&&void 0!==J.conditionalDivideCoordinate(y,g)){const e=1/g;return t.scaleRowsInPlace(i*e,s*e,n*e,r*e),t}}rowArrays(t){return t?[[t(this._coffs[0]),t(this._coffs[1]),t(this._coffs[2]),t(this._coffs[3])],[t(this._coffs[4]),t(this._coffs[5]),t(this._coffs[6]),t(this._coffs[7])],[t(this._coffs[8]),t(this._coffs[9]),t(this._coffs[10]),t(this._coffs[11])],[t(this._coffs[12]),t(this._coffs[13]),t(this._coffs[14]),t(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(t,e,i,s){for(let e=0;e<4;e++)this._coffs[e]*=t;for(let t=4;t<8;t++)this._coffs[t]*=e;for(let t=8;t<12;t++)this._coffs[t]*=i;for(let t=12;t<16;t++)this._coffs[t]*=s}addScaledOuterProductInPlace(t,e,i){let s=t.x*i;this._coffs[0]+=s*e.x,this._coffs[1]+=s*e.y,this._coffs[2]+=s*e.z,this._coffs[3]+=s*e.w,s=t.y*i,this._coffs[4]+=s*e.x,this._coffs[5]+=s*e.y,this._coffs[6]+=s*e.z,this._coffs[7]+=s*e.w,s=t.z*i,this._coffs[8]+=s*e.x,this._coffs[9]+=s*e.y,this._coffs[10]+=s*e.z,this._coffs[11]+=s*e.w,s=t.w*i,this._coffs[12]+=s*e.x,this._coffs[13]+=s*e.y,this._coffs[14]+=s*e.z,this._coffs[15]+=s*e.w}addTranslationSandwichInPlace(t,e,i,s,n){const r=t._coffs[3],o=t._coffs[7],a=t._coffs[11],c=t._coffs[12],h=t._coffs[13],l=t._coffs[14],d=t._coffs[15],u=e*d,f=i*d,g=s*d;this._coffs[0]+=n*(t._coffs[0]+e*r+c*e+e*u),this._coffs[1]+=n*(t._coffs[1]+i*r+h*e+e*f),this._coffs[2]+=n*(t._coffs[2]+s*r+l*e+e*g),this._coffs[3]+=n*(r+u),this._coffs[4]+=n*(t._coffs[4]+e*o+c*i+i*u),this._coffs[5]+=n*(t._coffs[5]+i*o+h*i+i*f),this._coffs[6]+=n*(t._coffs[6]+s*o+l*i+i*g),this._coffs[7]+=n*(o+f),this._coffs[8]+=n*(t._coffs[8]+e*a+c*s+s*u),this._coffs[9]+=n*(t._coffs[9]+i*a+h*s+s*f),this._coffs[10]+=n*(t._coffs[10]+s*a+l*s+s*g),this._coffs[11]+=n*(a+g),this._coffs[12]+=n*(c+u),this._coffs[13]+=n*(h+f),this._coffs[14]+=n*(l+g),this._coffs[15]+=n*d}multiplyTranslationSandwichInPlace(t,e,i){const s=this._coffs[3],n=this._coffs[7],r=this._coffs[11],o=this._coffs[12],a=this._coffs[13],c=this._coffs[14],h=this._coffs[15],l=t*h,d=e*h,u=i*h;this._coffs[0]+=t*s+o*t+t*l,this._coffs[1]+=e*s+a*t+t*d,this._coffs[2]+=i*s+c*t+t*u,this._coffs[3]+=l,this._coffs[4]+=t*n+o*e+e*l,this._coffs[5]+=e*n+a*e+e*d,this._coffs[6]+=i*n+c*e+e*u,this._coffs[7]+=d,this._coffs[8]+=t*r+o*i+i*l,this._coffs[9]+=e*r+a*i+i*d,this._coffs[10]+=i*r+c*i+i*u,this._coffs[11]+=u,this._coffs[12]+=l,this._coffs[13]+=d,this._coffs[14]+=u}}class Xt{constructor(t,e){this.xTest=t,this.yTest=e,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(t,e,i,s){return e!==this.yTest&&(this.u0=t-this.xTest,this.v0=e-this.yTest,this.u1=i-this.xTest,this.v1=s-this.yTest,!0)}advance(t,e){const i=t-this.xTest,s=e-this.yTest,n=s*this.v1;if(n>0)return this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0;if(n<0){const t=-this.v1/(s-this.v1),e=this.u1+t*(i-this.u1);return 0===e?(this.numHit++,!1):(e>0?this.numRightCrossing++:this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0)}if(0===s)return 0===this.v1?i*this.u1<=0?(this.numHit++,!1):(this.u1=i,this.v1=s,!0):(this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0);const r=this.v0*s;return this.u1>0?r<0&&this.numRightCrossing++:r<0&&this.numLeftCrossing++,this.u0=this.u1,this.v0=this.v1,this.u1=i,this.v1=s,!0}classifyCounts(){return this.numHit>0?0:1==(1&this.numLeftCrossing)?1:-1}}class zt{constructor(t,e,i,s,n){this.numStroke=t,this.curveLength=e,this.a0=i,this.a1=s,this.componentData=n}static createWithCurvePrimitive(t,e,i,s,n,r){const o=new zt(e,i,s,n,r);return o.primitive=t,o}static createWithComponentIndex(t=0,e=0,i=0,s=0,n=0){const r=new zt(e,i,s,n);return r.componentIndex=t,r}static createWithCurvePrimitiveAndOptionalParent(t,e,i){const s=e?e.a1:0,n=new zt(0,0,s,s,i);return n.primitive=t,n}addToCountAndLength(t,e){const i=this.a1+e;this.componentData&&this.componentData.push(new zt(t,e,this.a1,i)),this.numStroke+=t,this.curveLength+=e,this.a1=i}isCompatibleComponentStructure(t,e){if(e&&this.numStroke!==t.numStroke)return!1;if(void 0===this.componentData&&void 0===t.componentData)return!0;if(this.componentData&&t.componentData){if(this.componentData.length!==t.componentData.length)return!1;const i=this.componentData.length;for(let s=0;s<i;s++)if(!this.componentData[s].isCompatibleComponentStructure(t.componentData[s],e))return!1;return!0}return!1}clone(){const t=new zt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){t.componentData=[];for(const e of this.componentData)t.componentData.push(e.clone())}return t}fractionToA(t){return J.interpolate(this.a0,t,this.a1)}}class Rt{range(t,e){e&&e.setNull();const i=e||lt.createNull();return this.extendRange(i,t),i}tryTranslateInPlace(t,e=0,i=0){return this.tryTransformInPlace(ft.createTranslationXYZ(t,e,i))}get children(){}isAlmostEqual(t){if(this.isSameGeometryClass(t)){const e=this.children,i=t.children;if(e&&i){if(e.length!==i.length)return!1;for(let t=0;t<e.length;t++)if(!e[t].isAlmostEqual(i[t]))return!1;return!0}return!e&&!i}return!1}static areAlmostEqual(t,e){return t instanceof Rt&&e instanceof Rt?t.isAlmostEqual(e):void 0===t&&void 0===e}}class Dt{static getRow(t){const e=Dt._allRows;for(0===e.length&&(e.push(new Float64Array([1])),e.push(new Float64Array([1,1])),e.push(new Float64Array([1,2,1])),e.push(new Float64Array([1,3,3,1])),e.push(new Float64Array([1,4,6,4,1])),e.push(new Float64Array([1,5,10,10,5,1])),e.push(new Float64Array([1,6,15,20,15,6,1])),e.push(new Float64Array([1,7,21,35,35,21,7,1])));e.length<=t;){const t=e.length,i=e[t-1],s=new Float64Array(t+1);s[0]=1;for(let e=1;e<t;e++)s[e]=i[e-1]+i[e];s[t]=1,e.push(s)}return e[t]}static getBezierBasisValues(t,e,i){const s=t-1,n=Dt.getRow(s);(void 0===i||i.length<t)&&(i=new Float64Array(t));for(let e=0;e<t;e++)i[e]=n[e];let r=e;for(let s=1;s<t;s++,r*=e)i[s]*=r;const o=1-e;r=o;for(let e=t-2;e>=0;e--,r*=o)i[e]*=r;return i}static getBezierBasisDerivatives(t,e,i){const s=t-1;(i=this.getBezierBasisValues(t-1,e,i))[t-1]=s*i[t-2];for(let e=t-2;e>0;e--)i[e]=s*(i[e-1]-i[e]);return i[0]=-s*i[0],i}}Dt._allRows=[];class Nt{constructor(t){if(t instanceof Float64Array)this.coffs=t.slice();else if(Array.isArray(t)){this.coffs=new Float64Array(t.length);let e=0;for(const i of t)this.coffs[e++]=i}else this.coffs=new Float64Array(t)}allocateToOrder(t){this.coffs.length!==t?this.coffs=new Float64Array(t):this.coffs.fill(0)}createPeer(){return new Ot(this.order)}get order(){return this.coffs.length}copyFrom(t){if(this.order===t.order)for(let e=0;e<this.coffs.length;e++)this.coffs[e]=t.coffs[e];else this.coffs=t.coffs.slice()}scaleInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]*=t}addInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}roots(t,e){const i=Ot.create(this);return i.addInPlace(-t),Ot.deflateRoots01(i)}filter01(t,e=!1){if(!t||!e)return t;let i=!1;for(const e of t)if(J.isIn01(e)){i=!0;break}if(i){const e=[];for(const i of t)J.isIn01(i)&&e.push(i);return e}}zero(){this.coffs.fill(0)}subdivide(t,e,i){const s=this.order;if(e.order!==s||i.order!==s)return!1;const n=1-t;i.copyFrom(this);let r=s-1;for(let o=0;o<s;o++){e.coffs[o]=i.coffs[0];for(let e=0;e<r;e++)i.coffs[e]=n*i.coffs[e]+t*i.coffs[e+1];r--}return!0}static maxAbsDiff(t,e){const i=t.order;if(e.order!==i)return;let s,n=0;for(let r=0;r<i;r++)s=Math.abs(t.coffs[r]-e.coffs[r]),s>n&&(n=s);return n}}class Yt{static accumulateScaledShiftedComponentTimesComponentDelta(t,e,i,s,n,r,o,a){const c=s-1,h=s,l=s+c-1;if(t.length!==l)return;const d=Dt.getRow(h-1),u=Dt.getRow(c-1),f=Dt.getRow(l-1);let g;for(let s=0;s<h;s++){g=n*(o+e[r+s*i])*d[s];for(let n=0,r=a;n<c;n++,r+=i)t[s+n]+=g*u[n]*(e[r+i]-e[r])/f[s+n]}}static scaledComponentSum(t,e,i,s,n,r,o,a){const c=s;if(t.length===c)for(let s=0,h=0;s<c;s++,h+=i)t[s]=r*e[h+n]+a*e[h+o]}static componentDifference(t,e,i,s,n){const r=s-1;if(t.length===r)for(let s=0,o=n;s<r;o+=i,s++)t[s]=e[o+i]-e[o]}static accumulateProduct(t,e,i,s=1){const n=e.length,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,h;const l=Dt.getRow(n-1),d=Dt.getRow(r-1),u=Dt.getRow(o-1);for(a=0;a<n;a++)for(h=s*l[a]*e[a],c=0;c<r;c++)t[a+c]+=h*d[c]*i[c]/u[a+c]}static accumulateProductWithDifferences(t,e,i,s=1){const n=e.length-1,r=i.length,o=n+r-1;if(t.length!==o)return;let a,c,h;const l=Dt.getRow(n-1),d=Dt.getRow(r-1),u=Dt.getRow(o-1);for(a=0;a<n;a++)for(h=s*l[a]*(e[a+1]-e[a]),c=0;c<r;c++)t[a+c]+=h*d[c]*i[c]/u[a+c]}static univariateDifference(t,e){const i=e.length;if(e.length+1!==i)for(let s=0;s<i;s++)e[s]=t[s+1]-t[s]}static accumulate(t,e,i){if(i.length===e)for(let s=0;s<e;s++)i[s]+=t[s]}}class Ot extends Nt{get order(){return this._order}constructor(t){super(t),this._order=super.order}allocateOrder(t){this._order!==t&&(super.allocateToOrder(t),this._order=t),this.coffs.fill(0)}clone(t=!1){if(t){const t=new Ot(this.order);return t.coffs=this.coffs.slice(0,this.order),t}const e=new Ot(this.coffs.length);return e._order=this._order,e.coffs=this.coffs.slice(),e}static create(t){const e=new Ot(t.order);return e.coffs=t.coffs.slice(),e}static createCoffs(t){return new Ot(t)}static createArraySubset(t,e,i,s){s?s.order!==i&&s.allocateToOrder(i):s=new Ot(i);for(let n=0;n<i;n++)s.coffs[n]=t[e+n];return s}static createProduct(t,e){const i=new Ot(t.order+e.order-1),s=Dt.getRow(t.order-1),n=Dt.getRow(e.order-1),r=Dt.getRow(t.order+e.order-2);for(let o=0;o<t.order;o++){const a=t.coffs[o]*s[o];for(let t=0;t<e.order;t++){const s=e.coffs[t]*n[t],c=o+t,h=r[c];i.coffs[c]+=a*s/h}}return i}addSquaredSquaredBezier(t,e){const i=t.length,s=this.order;if(2*i!==s+1)return!1;const n=Dt.getRow(i-1),r=Dt.getRow(s-1),o=this.coffs;for(let s=0;s<i;s++){const a=t[s]*n[s]*e;for(let e=0;e<i;e++){const i=t[e]*n[e],c=s+e,h=r[c];o[c]+=a*i/h}}return!0}addConstant(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}basisFunctions(t,e){this._basisValues=Dt.getBezierBasisValues(this.order,t,this._basisValues),e&&e.length===this.order||(e=new Float64Array(this.order));let i=0;for(const t of this._basisValues)e[i++]=t;return e}static sumWeightedBlocks(t,e,i,s,n){for(let t=0;t<s;t++)n[t]=0;let r,o=0;for(let a=0;a<e;a++){const e=t[a];for(r=0;r<s;r++)n[r]+=e*i[o++]}}sumBasisFunctions(t,e,i,s){const n=this._order;return s||(s=new Float64Array(n)),this._basisValues=Dt.getBezierBasisValues(this.order,t,this._basisValues),Ot.sumWeightedBlocks(this._basisValues,n,e,i,s),s}sumBasisFunctionDerivatives(t,e,i,s){const n=this._order;return s||(s=new Float64Array(i)),this._basisValues=Dt.getBezierBasisDerivatives(this.order,t,this._basisValues),Ot.sumWeightedBlocks(this._basisValues,n,e,i,s),s}evaluate(t){this._basisValues=Dt.getBezierBasisValues(this.order,t,this._basisValues);let e=0;for(let t=0;t<this.order;t++)e+=this._basisValues[t]*this.coffs[t];return e}deflateLeft(){const t=this.order,e=t-1,i=Dt.getRow(e-1),s=Dt.getRow(t-1);let n;for(let t=0;t<e;t++)n=this.coffs[t+1],this.coffs[t]=n*s[t+1]/i[t];this._order--}deflateRight(){const t=this.order,e=t-1,i=Dt.getRow(e-1),s=Dt.getRow(t-1);let n,r;for(let t=0;t<e;t++)n=this.coffs[t],r=n*s[t]/i[t],this.coffs[t]=r;this._order--}deflateRoot(t){const e=this.order,i=e-1;if(1===e)return this._order=0,this.coffs[0];if(e<1)return this._order=0,0;const s=Dt.getRow(e-1),n=Dt.getRow(i-1),r=-t,o=1-t;let a=0;if(t>.5){let t,c,h=this.coffs[0]/r;this.coffs[0]=h;for(let e=1;e<i;e++)c=this.coffs[e]*s[e],t=(c-h*o)/r,this.coffs[e]=t/n[e],h=t;a=this.coffs[e-1]-h*o}else{let t,c,h=this.coffs[e-1]/o;this.coffs[e-1]=h;for(let i=e-2;i>0;i--)c=this.coffs[i]*s[i],t=(c-h*r)/o,this.coffs[i]=t/n[i-1],h=t;a=this.coffs[0]-h*r;for(let t=0;t<i;t++)this.coffs[t]=this.coffs[t+1]}return this._order=i,a}runNewton(t,e=1e-11){const i=this.order-1;let s,n,r=0,o=t;const a=this.order,c=this.coffs,h=a-1;for(let t=0;t++<10;){Ot._basisBuffer=Dt.getBezierBasisValues(a,o,Ot._basisBuffer),s=0;for(let t=0;t<a;t++)s+=c[t]*Ot._basisBuffer[t];Ot._basisBuffer1=Dt.getBezierBasisValues(h,o,Ot._basisBuffer1),n=0;for(let t=0;t<h;t++)n+=(c[t+1]-c[t])*Ot._basisBuffer1[t];if(n*=i,Math.abs(s)>10*Math.abs(n))return;const t=s/n;if(Math.abs(t)<e){if(r++,r>=2)return o-t}else r=0;o-=t}}static deflateRoots01(t){const e=[],i=t.coffs;let s,n,r,o,a;for(;t.order>1;){const c=t.order;if(0===i[0]){t.deflateLeft(),e.push(0);continue}let h=0,l=0;for(let d=1;d<c;d++)if(s=i[d-1],n=i[d],s*n<=0&&(h++,r=-s/(n-s),o=(d-1+r)/(c-1),a=t.runNewton(o,1e-10),void 0!==a)){e.push(a),t.deflateRoot(a),l++;break}if(!l)return e}return e}}class Bt extends Nt{constructor(t=0,e=0){super(2),this.coffs[0]=t,this.coffs[1]=e}clone(){return new Bt(this.coffs[0],this.coffs[1])}static solveCoffs(t,e){return J.conditionalDivideFraction(-t,e-t)}basisFunctions(t,e){return e||(e=new Float64Array(2)),e[0]=1-t,e[1]=t,e}sumBasisFunctions(t,e,i,s){s||(s=new Float64Array(i));const n=1-t;for(let r=0;r<i;r++)s[r]=n*e[r]+t*e[r+i];return s}sumBasisFunctionDerivatives(t,e,i,s){s||(s=new Float64Array(i));for(let t=0;t<i;t++)s[t]=e[t+i]-e[t];return s}evaluate(t){return(1-t)*this.coffs[0]+t*this.coffs[1]}solve(t){const e=this.coffs[1]-this.coffs[0];return J.conditionalDivideFraction(t-this.coffs[0],e)}roots(t,e){const i=this.solve(t);if(void 0!==i)return!e||J.isIn01(i)?[i]:void 0}}class Vt{constructor(t=1e-11,e=2,i=15){this._numAccepted=0,this.numIterations=0,this._stepSizeTolerance=t,this._successiveConvergenceTarget=e,this._maxIterations=i}testConvergence(t){return Math.abs(t)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class Lt{}class Ut extends Vt{constructor(t){super(),this._func=t,this.derivativeH=1e-8}setX(t){return this._currentX=t,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const e=this._func.currentF,i=J.conditionalDivideFraction(t,(e-t)/this.derivativeH);if(void 0!==i)return this._currentStep=i,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Zt{constructor(){this.currentF=Ft.createXYPlane()}}class qt extends Vt{constructor(t){super(),this._func=t,this._currentStep=G.createZero(),this._currentUV=W.createZero()}setUV(t,e){return this._currentUV.set(t,e),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(this._func.evaluate(this._currentUV.x,this._currentUV.y)){const t=this._func.currentF;if(Ct.linearSystem2d(t.vectorU.x,t.vectorV.x,t.vectorU.y,t.vectorV.y,t.origin.x,t.origin.y,this._currentStep))return!0}return!1}currentStepSize(){return J.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Wt extends Lt{constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(t){this._parentCurvePrimitive=t}endParentCurvePrimitive(t){this._parentCurvePrimitive=void 0}}class Gt extends Wt{effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._derivativeB=0,this._numThisCurve=0,this._plane=t,this._intersections=e,this.startCurvePrimitive(void 0),this._ray=kt.createZero(),this._newtonSolver=new Ut(this)}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=J.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._ray),this.announcePointTangent(this._ray.origin,e,this._ray.direction)}}announceSegmentInterval(t,e,i,s,n,r){const o=this._plane.altitude(e),a=this._plane.altitude(i);if(o*a>0)return;const c=Bt.solveCoffs(o,a);if(void 0!==c){const t=J.interpolate(n,c,r);this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(t){const e=this.effectiveCurve();e&&(this._ray=e.fractionToPointAndDerivative(t,this._ray),this._intersections.push(yt.createCurveFractionPoint(e,t,this._ray.origin)))}evaluate(t){const e=this.effectiveCurve();return!!e&&(this.currentF=this._plane.altitude(e.fractionToPoint(t)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=J.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e,i){this._functionB=this._plane.altitude(t),this._derivativeB=this._plane.velocity(i),this._fractionB=e}announcePointTangent(t,e,i){this.evaluateB(t,e,i),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(t){t[t.None=0]="None",t[t.OnTangent=1]="OnTangent",t[t.OnCurve=2]="OnCurve"}(S||(S={}));class Jt{static resolveVariantCurveExtendParameterToCurveExtendMode(t,e){return!1===t?S.None:!0===t?S.OnCurve:Array.isArray(t)?t[e]:t}static correctFraction(t,e){return e<0?Jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,0)===S.None&&(e=0):e>1&&Jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,1)===S.None&&(e=1),e}static resolveRadiansToSweepFraction(t,e,i){let s=i.radiansToSignedPeriodicFraction(e);if(!i.isRadiansInSweep(e)){const n=i.fractionPeriod(),r=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,0),o=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(t,1);r!==S.None?o!==S.None?s=i.radiansToSignedPeriodicFraction(e):s>1&&(s-=n):o!==S.None?s<0&&(s+=n):s=J.clamp(s,0,1)}return s}}class Ht extends Wt{constructor(t,e){super(),this._fractionA=0,this._functionA=0,this._functionB=0,this._fractionB=0,this._numThisCurve=0,this._spacePoint=t,this._workPoint=K.create(),this._workRay=kt.createZero(),this._closestPoint=void 0,this._extend=e,this.startCurvePrimitive(void 0),this._newtonSolver=new Ut(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let t=this._newtonSolver.getX();t=Jt.correctFraction(this._extend,t),this.announceSolutionFraction(t)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),this.announceSolutionFraction(0),this.announceSolutionFraction(1),e<1&&(e=1);const n=1/e;for(let r=0;r<=e;r++){const e=J.interpolate(i,r*n,s);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,i){const s=this._spacePoint.distance(i);this._closestPoint&&s>this._closestPoint.a||(this._closestPoint=yt.createCurveFractionPoint(t,e,i,this._closestPoint),this._closestPoint.a=s,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(t,e,i,s,n,r){let o=this._spacePoint.fractionOfProjectionToLine(e,i,0);this._extend?(0!==n&&(o=Math.max(o,0)),1!==r&&(o=Math.min(o,1))):o=J.clampToStartEnd(o,0,1),this._workPoint=e.interpolate(o,i);const a=J.interpolate(n,o,r);this.announceCandidate(t,a,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=J.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e){this._functionB=e.dotProductToPoint(this._spacePoint),this._fractionB=t}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluate(t){let e=this._curve;return this._parentCurvePrimitive&&(e=this._parentCurvePrimitive),!!e&&(this._workRay=e.fractionToPointAndDerivative(t,this._workRay),this.currentF=this._workRay.dotProductToPoint(this._spacePoint),!0)}announceRay(t,e){this.evaluateB(t,e),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(t,e,i){this._workRay.set(t,i),this.announceRay(e,this._workRay)}}class Kt{static mapWeights(t,e,i,s,n,r){const o=i.length;for(let a=0;a<o;a++)n[a]=t+e*i[a],r[a]=e*s[a];return o}static setupGauss1(t,e,i,s){return Kt.mapWeights(t,e-t,Kt.gaussX1Interval01,Kt.gaussW1Interval01,i,s)}static setupGauss2(t,e,i,s){return Kt.mapWeights(t,e-t,Kt.gaussX2Interval01,Kt.gaussW2Interval01,i,s)}static setupGauss3(t,e,i,s){return Kt.mapWeights(t,e-t,Kt.gaussX3Interval01,Kt.gaussW3Interval01,i,s)}static setupGauss5(t,e,i,s){return Kt.mapWeights(t,e-t,Kt.gaussX5Interval01,Kt.gaussW5Interval01,i,s)}static setupGauss4(t,e,i,s){return Kt.mapWeights(t,e-t,Kt.gaussX4Interval01,Kt.gaussW4Interval01,i,s)}static sum1(t,e,i,s){let n=0;for(let r=0;r<i;r++)n+=e[r]*s(t[r]);return n}static doGaussIntegral(t,e,i,s,n=5){const r=new jt(n);s<1&&(s=1);const o=1/s;let a=0;for(let n=1;n<=s;n++){const c=J.interpolate(t,(n-1)*o,e),h=n===s?e:J.interpolate(t,n*o,e),l=r.mapXAndW(c,h);for(let t=0;t<l;t++)a+=r.gaussW[t]*i(r.gaussX[t])}return a}}Kt.gaussX1Interval01=new Float64Array([.5]),Kt.gaussW1Interval01=new Float64Array([1]),Kt.gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]),Kt.gaussW2Interval01=new Float64Array([.5,.5]),Kt.gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]),Kt.gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]),Kt.gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]),Kt.gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]),Kt.gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]),Kt.gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);class jt{mapXAndW(t,e){return this.mapXAndWFunction(t,e,this.gaussX,this.gaussW)}constructor(t){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(t>5||t<1)&&(t=5),t){case 1:this.mapXAndWFunction=Kt.setupGauss1;break;case 2:this.mapXAndWFunction=Kt.setupGauss2;break;case 3:this.mapXAndWFunction=Kt.setupGauss3;break;case 4:this.mapXAndWFunction=Kt.setupGauss4;break;default:this.mapXAndWFunction=Kt.setupGauss5}}}class Qt{tangentMagnitude(t){return this._ray=this._curve.fractionToPointAndDerivative(t,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(t=0,e=1,i=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=kt.createZero(),t<e?(this._fraction0=t,this._fraction1=e):(this._fraction0=e,this._fraction1=t),this._gaussMapper=new jt(i)}startCurvePrimitive(t){this._curve=t}startParentCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,s){const n=dt.createXX(i,s);if(n.intersectRangeXXInPlace(this._fraction0,this._fraction1),!n.isNull){this.startCurvePrimitive(t),e<1&&(e=1);const i=1/e;for(let t=1;t<=e;t++){const s=n.fractionToPoint((t-1)*i),r=t===e?n.high:n.fractionToPoint(t*i),o=this._gaussMapper.mapXAndW(s,r);for(let t=0;t<o;t++)this._summedLength+=this._gaussMapper.gaussW[t]*this.tangentMagnitude(this._gaussMapper.gaussX[t])}}}announceSegmentInterval(t,e,i,s,n,r){const o=e.distance(i);if(this._fraction0<=n&&r<=this._fraction1)this._summedLength+=o;else{const t=dt.createXX(n,r);t.intersectRangeXXInPlace(this._fraction0,this._fraction1),t.isNull||(this._summedLength+=o*t.length()/(r-n))}}announcePointTangent(t,e,i){}}class $t extends Rt{constructor(){super(),this.geometryCategory="curvePrimitive"}fractionToPointAndUnitTangent(t,e){const i=this.fractionToPointAndDerivative(t,e);return i.trySetDirectionMagnitudeInPlace(1),i}fractionToCurvature(t){const e=this.fractionToPointAnd2Derivatives(t),i=e.vectorU.crossProduct(e.vectorV).magnitude(),s=e.vectorU.magnitude();return J.conditionalDivideFraction(i,s*s*s)}fractionToFrenetFrame(t,e){const i=this.fractionToPointAnd2Derivatives(t);if(!i)return;let s=pt.createRigidFromColumns(i.vectorU,i.vectorV,g.XYZ);if(s)return ft.createRefs(i.origin,s,e);const n=pt.createPerpendicularVectorFavorXYPlane(i.vectorU,i.vectorV);return s=pt.createRigidFromColumns(i.vectorU,n,g.XYZ),s?ft.createRefs(i.origin,s,e):void 0}fractionToSignedXYRadiusOfCurvature(t){const e=this.fractionToPointAnd2Derivatives(t);if(!e)return 0;const i=e.vectorU.crossProductXY(e.vectorV),s=e.vectorU.magnitude();if(0===s)return 0;const n=J.conditionalDivideCoordinate(s*s*s,i);return void 0!==n?n:0}fractionAndDistanceToPointOnTangent(t,e){return this.fractionToPointAndUnitTangent(t).fractionToPoint(e)}curveLength(){const t=new Qt;return this.emitStrokableParts(t),t.getSum()}curveLengthBetweenFractions(t,e){if(t===e)return 0;if(void 0!==this.getFractionToDistanceScale()){const i=this.curveLength();return Math.abs((e-t)*i)}const i=new Qt(t,e);return this.emitStrokableParts(i),Math.abs(i.getSum())}rangeBetweenFractions(t,e,i){return this.rangeBetweenFractionsByClone(t,e,i)}rangeBetweenFractionsByClone(t,e,i){if(t===e)return lt.create(this.fractionToPoint(t));const s=this.clonePartialCurve(t,e);return s?s.range(i):lt.createNull()}rangeBetweenFractionsByCount(t,e,i,s,n=0){const r=lt.createNull(),o=K.create();r.extendPoint(this.startPoint(o)),r.extendPoint(this.endPoint(o));const a=(t,e,i)=>{let n=t;for(let t=0;t<i;t++,n+=e)this.fractionToPoint(n,o),s?r.extendTransformedPoint(s,o):r.extendPoint(o)},c=i-2;if(c>0){const i=1/(c+1)*(e-t);a(t+i,i,c)}if(n>0){const i=r.clone(),s=c+1,o=.5/s*2*(e-t);a(t+.5*o,o,s),r.extendWhenLarger(i,n)}return r}curveLengthWithFixedIntervalCountQuadrature(t,e,i,s=5){if(t>e){const i=t;t=e,e=i}const n=new Qt(t,e,s);return n.announceIntervalForUniformStepStrokes(this,i,t,e),Math.abs(n.getSum())}moveSignedDistanceFromFraction(t,e,i,s){if(void 0!==this.getFractionToDistanceScale()){const n=this.curveLength(),r=J.conditionalDivideFraction(e,n);return void 0===r?yt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,I.error):yt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}return this.moveSignedDistanceFromFractionGeneric(t,e,i,s)}moveSignedDistanceFromFractionGeneric(t,i,s,n){let r;if(0===i)return yt.createCurveEvaluatedFraction(this,t,n);if(i>0){if(r=1,t>=1){const e=.9;i+=this.curveLengthBetweenFractions(e,t),t=e}}else if(r=0,t<=0){const e=.1;i-=this.curveLengthBetweenFractions(t,e),t=e}const o=this.curveLengthBetweenFractions(t,r);e(o>0);const a=Math.abs(i);if(o<a&&!s)return yt.createConditionalMoveSignedDistance(s,this,t,r,i,n);const c=J.conditionalDivideCoordinate(a,o);if(void 0===c)return(n=yt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=I.error,n;const h=i<0?-1:1;let l=J.interpolate(t,c,r),d=t,u=0;const f=1e-12*o;let g=0;const p=kt.createXAxis();for(let t=0;t<10;t++){const t=u+(l>d?h:-h)*this.curveLengthBetweenFractions(d,l),e=a-t;if(Math.abs(e)<f){if(g++,g>1)break}else g=0;if(this.fractionToPointAndDerivative(l,p),d=l,l=d+h*e/p.direction.magnitude(),d===l){g=100;break}u=t}return g>1?yt.createConditionalMoveSignedDistance(s,this,t,l,i,n):((n=yt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=I.error,n)}get isExtensibleFractionSpace(){return!1}closestPoint(t,e){const i=new Ht(t,e);return this.emitStrokableParts(i),i.claimResult()}announceClipIntervals(t,e){return!1}clonePartialCurve(t,e){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(t,e){const i=new Gt(t,e),s=e.length;return this.emitStrokableParts(i),e.length-s}static snapAndRestrictDetails(t,e=!0,i=!1,s=J.smallAngleRadians,n=J.smallMetricDistance){const r=t.length;let o=0;const a=K.create(),c=K.create();let h;for(let l=0;l<r;l++){h=void 0;const r=t[l];let d=r.fraction,u=e||J.isIn01(d);r.curve&&(r.curve.startPoint(a),r.curve.endPoint(c)),s>0&&(Math.abs(d)<s&&(d=0,u=!0,r.intervalRole=P.isolatedAtVertex,h=a),Math.abs(d-1)<s&&(d=1,u=!0,r.intervalRole=P.isolatedAtVertex,h=c,r.curve&&(h=r.curve.startPoint(c)))),n>0&&void 0!==r.curve&&(r.point.distance(a)<=n?(d=0,r.intervalRole=P.isolatedAtVertex,h=a):r.point.distance(c)<=n&&(d=1,r.intervalRole=P.isolatedAtVertex,h=c)),u&&(i&&(r.fraction=d,void 0!==h&&r.point.setFrom(h)),o<l&&(t[o]=r),o++)}o<r&&(t.length=o)}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.computeStrokeCountForOptions(t),s=this.curveLength();$t.installStrokeCountMap(this,zt.createWithCurvePrimitive(this,i,s,0,s),e)}addMappedStrokesToLineString3D(t,e){const i=e.numPoints();if(t.primitive&&t.primitive===this&&t.numStroke>0)for(let i=0;i<=t.numStroke;i++){const s=i/t.numStroke;e.appendFractionToPoint(this,s)}return e.numPoints()-i}static installStrokeCountMap(t,e,i){i&&i.addToCountAndLength(e.numStroke,e.curveLength),t.strokeData=e}collectCurvePrimitivesGo(t,e,i=!1){t.push(this)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}projectedParameterRange(t,e){}}class te extends et{constructor(t){super(),this.data=t}isValidIndex(t){return t>=0&&t<this.data.length}getPoint3dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return K.create(i.x,i.y,i.z,e)}}getPoint3dAtUncheckedPointIndex(t,e){const i=this.data[t];return K.create(i.x,i.y,i.z,e)}getVector3dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return j.create(i.x,i.y,i.z,e)}}getXAtUncheckedPointIndex(t){return this.data[t].x}getYAtUncheckedPointIndex(t){return this.data[t].y}getZAtUncheckedPointIndex(t){return this.data[t].z}vectorIndexIndex(t,e,i){if(this.isValidIndex(t)&&this.isValidIndex(e))return j.createStartEnd(this.data[t],this.data[e],i)}vectorXYAndZIndex(t,e,i){if(this.isValidIndex(e))return j.createStartEnd(t,this.data[e],i)}crossProductXYAndZIndexIndex(t,e,i,s){if(this.isValidIndex(e)&&this.isValidIndex(i))return j.createCrossProductToPoints(t,this.data[e],this.data[i],s)}crossProductIndexIndexIndex(t,e,i,s){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i))return j.createCrossProductToPoints(this.data[t],this.data[e],this.data[i],s)}accumulateCrossProductIndexIndexIndex(t,e,i,s){const n=this.data;this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i)&&s.addCrossProductToTargetsInPlace(n[t].x,n[t].y,n[t].z,n[e].x,n[e].y,n[e].z,n[i].x,n[i].y,n[i].z)}accumulateScaledXYZ(t,e,i){if(this.isValidIndex(t)){const s=this.data[t];i.x+=e*s.x,i.y+=e*s.y,i.z+=e*s.z}}get length(){return this.data.length}push(t){this.data.push(t.clone())}pushXYZ(t,e,i){this.data.push(K.create(void 0===t?0:t,void 0===e?0:e,void 0===i?0:i))}back(t){if(this.data.length>0)return this.data[this.data.length-1].clone(t)}front(t){if(this.data.length>0)return this.data[0].clone(t)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distanceSquared(this.data[e])}distanceIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distance(this.data[e])}cyclicIndex(t){return t%this.data.length}}function ee(t,e,i){if(void 0!==e){const s=e*i;if(s>=0&&s<=t)return s}return t}class ie{static preciseSum(t){const e=t.length;if(0===e)return 0;let i,s,n=t[0],r=0;for(let o=1;o<e;o++)i=t[o]-r,s=n+i,r=s-n-i,n=s;return n}static isExactEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return void 0===t&&void 0===e}static isAlmostEqual(t,e,i){if(t&&e){if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(Math.abs(t[s]-e[s])>=i)return!1;return!0}return void 0===t&&void 0===e}static sum(t){let e=0;for(const i of t)e+=i;return e}static isCoordinateInArray(t,e){if(e)for(const i of e)if(J.isSameCoordinate(t,i))return!0;return!1}static maxAbsArray(t){const e=t.length;if(0===e)return 0;let i=Math.abs(t[0]);for(let s=1;s<e;s++){const e=Math.abs(t[s]);i<e&&(i=e)}return i}static maxAbsTwo(t,e){return(t=Math.abs(t))>(e=Math.abs(e))?t:e}static maxAbsDiff(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static maxAbsDiffFloat64(t,e){let i=0;const s=Math.min(t.length,e.length);for(let n=0;n<s;n++)i=Math.max(i,Math.abs(t[n]-e[n]));return i}static createArrayWithMaxStepSize(t,e,i){if(t===e)return[t];const s=e-t,n=Math.max(1,Math.floor(Math.abs(s/i))),r=[];r.push(t);for(let e=1;e<n;e++)r.push(t+e/n*s);return r.push(e),r}static create(t){const e=[];for(const i of t)e.push(i);return e}static cloneWithStartAndEndMultiplicity(t,e,i){const s=[];if(void 0===t||0===t.length)return s;let n=1;const r=t[0],o=t[t.length-1];for(;n<t.length&&t[n]===r;)n++;let a=1;const c=t.length-1;for(;c-a>=0&&t[c-a]===o;)a++;for(let t=0;t<e;t++)s.push(r);for(let e=n;e+a<t.length;e++)s.push(t[e]);for(let t=0;t<i;t++)s.push(o);return s}static linearCombination(t,e){const i=Math.min(t.length,e.length);let s=0;for(let n=0;n<i;++n)s+=e[n]*t[n];return s}static linearCombinationOfColors(t,e){const i=Math.min(t.length,e.length),s=[0,0,0,0];for(let n=0,r=0;n<4;++n,r+=8){for(let o=0;o<i;++o){const i=J.clamp(e[o],0,1),a=t[o]>>>r&255;s[n]+=i*a}s[n]=(255&Math.floor(s[n]))<<r}return s[0]|s[1]|s[2]|s[3]}}class se{static packPointsAndWeightsToFloat64Array(t,e,i){if(Array.isArray(t)&&t[0]instanceof K){const s=t;if(s.length!==e.length)return;i=i||new Float64Array(4*s.length);let n=0,r=0;for(r=0;r<s.length;r++)i[n++]=s[r].x,i[n++]=s[r].y,i[n++]=s[r].z,i[n++]=e[r];return i}{const s=t,n=e.length;if(s.length!==3*n)return;let r,o=0;for(i=i||new Float64Array(4*n),r=0;r<n;r++){const t=3*r;i[o++]=s[t],i[o++]=s[t+1],i[o++]=s[t+2],i[o++]=e[r]}return i}}static packToFloat64Array(t,e){e=e||new Float64Array(4*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return e}static unpackToPoint4dArray(t){const e=[];for(let i=0;i+3<t.length;i+=4)e.push(bt.create(t[i],t[i+1],t[i+2],t[i+3]));return e}static unpackFloat64ArrayToPointsAndWeights(t,e,i,s=K.create){e.length=0,i.length=0;for(let n=0;n+3<t.length;n+=4)e.push(s(t[n],t[n+1],t[n+2])),i.push(t[n+3])}static multiplyInPlace(t,e){const i=e.length,s=se._workPoint4d;for(let n=0;n+3<i;n+=4)t.multiplyXYZW(e[n],e[n+1],e[n+2],e[n+3],s),e[n]=s.x,e[n+1]=s.y,e[n+2]=s.z,e[n+3]=s.w}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let i=0;i<t.length;i++)if(!J.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1;return!0}return void 0===t&&void 0===e}static isCloseToPlane(t,e,i=J.smallMetricDistance){if(Array.isArray(t)){for(const s of t)if(Math.abs(e.altitudeXYZW(s.x,s.y,s.z,s.w))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=4)if(Math.abs(e.altitudeXYZW(t[n],t[n+1],t[n+2],t[n+3]))>i)return!1}return!0}}se._workPoint4d=bt.create();class ne{static packToFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return e}static evaluateTrilinearWeights(t,e,i,s,n,r,o){t[0]=e*s*r,t[1]=i*s*r,t[2]=e*n*r,t[3]=i*n*r,t[4]=e*s*o,t[5]=i*s*o,t[6]=e*n*o,t[7]=i*n*o}static sumWeightedX(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].x;return i}static sumWeightedY(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].y;return i}static sumWeightedZ(t,e){let i=0;const s=t.length;for(let n=0;n<s;n++)i+=t[n]*e[n].z;return i}static evaluateTrilinearPoint(t,e,i,s,n){let r;n||(n=K.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s);for(let e=0;e<8;e++)r=this._weightUVW[e],n.x+=r*t[e].x,n.y+=r*t[e].y,n.z+=r*t[e].z;return n}static evaluateTrilinearDerivativeTransform(t,e,i,s,n){return this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-i,i,1-s,s),this.evaluateTrilinearWeights(this._weightDV,1-e,e,-1,1,1-s,s),this.evaluateTrilinearWeights(this._weightDW,1-e,e,1-i,i,-1,1),ft.createRowValues(this.sumWeightedX(this._weightDU,t),this.sumWeightedX(this._weightDV,t),this.sumWeightedX(this._weightDW,t),this.sumWeightedX(this._weightUVW,t),this.sumWeightedY(this._weightDU,t),this.sumWeightedY(this._weightDV,t),this.sumWeightedY(this._weightDW,t),this.sumWeightedY(this._weightUVW,t),this.sumWeightedZ(this._weightDU,t),this.sumWeightedZ(this._weightDV,t),this.sumWeightedZ(this._weightDW,t),this.sumWeightedZ(this._weightUVW,t),n)}static unpackNumbersToPoint3dArray(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(K.create(t[i],t[i+1],t[i+2]));return e}static unpackNumbersToNestedArrays(t,e){const i=[],s=t.length;let n=0,r=0;for(;n<s;){const o=[];for(r=n+e,r>s&&(r=s);n<r;n++)o.push(t[n]);i.push(o)}return i}static unpackNumbersToNestedArraysIJK(t,e,i){const s=[],n=t.length;let r,o=0,a=0;for(;o<n;){const c=[];for(r=o+e*i;o<r;){const i=[];for(a=o+e,a>n&&(a=n);o<a;o++)i.push(t[o]);c.push(i)}s.push(c)}return s}static multiplyInPlace(t,e){const i=K.create(),s=e.length;for(let n=0;n+2<s;n+=3)t.multiplyXYZ(e[n],e[n+1],e[n+2],i),e[n]=i.x,e[n+1]=i.y,e[n+2]=i.z}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;if(t instanceof Float64Array&&e instanceof Float64Array){for(let i=0;i<t.length;i++)if(!J.isSameCoordinate(t[i],e[i]))return!1}else if(Array.isArray(t)&&Array.isArray(e))for(let i=0;i<t.length;i++)if(!t[i].isAlmostEqual(e[i]))return!1;return!0}return void 0===t&&void 0===e}static centroid(t,e){if(t instanceof tt){e=K.create(0,0,0,e);const i=K.create();if(t.length>0){for(let s=0;s<t.length;s++)t.getPoint3dAtCheckedPointIndex(s,i),e.x+=i.x,e.y+=i.y,e.z+=i.z;e.scaleInPlace(1/t.length)}return e}const i=new te(t);return this.centroid(i)}static indexOfMostDistantPoint(t,e,i){if(0===t.length)return;let s,n=-1,r=-1;for(let o=0;o<t.length;o++)s=e.distance(t[o]),s>n&&(e.vectorTo(t[o],i),n=s,r=o);return r}static indexOfPointWithMaxCrossProductMagnitude(t,e,i,s){if(0===t.length)return;let n,r,o=-1,a=-1;for(let c=0;c<t.length;c++)r=e.vectorTo(t[c],r),n=r.crossProductMagnitude(i),n>o&&(s.setFrom(r),o=n,a=c);return a}static closestPointIndex(t,e){let i,s=-1,n=Number.MAX_VALUE;const r=e.x,o=e.y,a=e.z;for(let e=0;e<t.length;e++)i=J.distanceXYZXYZ(r,o,a,t[e].x,t[e].y,t[e].z),i<n&&(s=e,n=i);return s}static isCloseToPlane(t,e,i=J.smallMetricDistance){if(Array.isArray(t)){let s;for(s of t)if(Math.abs(e.altitude(s))>i)return!1}else if(t instanceof Float64Array){const s=t.length;for(let n=0;n+2<s;n+=3)if(Math.abs(e.altitudeXYZ(t[n],t[n+1],t[n+2]))>i)return!1}return!0}static sumEdgeLengths(t,e=!1,i){let s=0;if(Array.isArray(t)){const n=ee(t.length,i,1)-1;for(let e=0;e<n;e++)s+=t[e].distance(t[e+1]);e&&n>0&&(s+=t[0].distance(t[n]))}else if(t instanceof Float64Array){const n=ee(t.length,i,3);let r=0;for(;r+5<n;r+=3)s+=J.hypotenuseXYZ(t[r+3]-t[r],t[r+4]-t[r+1],t[r+5]-t[r+2]);e&&r>=3&&(s+=J.hypotenuseXYZ(t[0]-t[r],t[1]-t[r+1],t[2]-t[r+2]))}return s}static countNonDuplicates(t,e=J.smallMetricDistance){let i=t.length;for(;i>1&&t[0].isAlmostEqual(t[i-1],e);)i--;for(let s=0;s+1<i;s++)if(t[s].isAlmostEqual(t[s+1],e))return 0;return i}static clonePoint3dArray(t){const e=[];if(0===t.length)return e;if(t instanceof Float64Array){for(let i=0;i+2<t.length;i+=3)e.push(K.create(t[i],t[i+1],t[i+2]));return e}for(const i of t)Array.isArray(i)?e.push(K.create(i[0],i[1],i[2])):e.push(K.create(i.x,i.y,i.z));return e}static clonePoint2dArray(t){return t.map((t=>W.create(t.x,t.y)))}static cloneWithMaxEdgeLength(t,e){if(0===t.length)return[];const i=[t[0]];for(let s=1;s<t.length;s++){const n=t[s-1].distance(t[s]),r=J.stepCount(e,n,1);for(let e=1;e<r;e++)i.push(t[s-1].interpolate(e/r,t[s]));i.push(t[s])}return i}static xyzToArray(t,e,i){return[t,e,i]}static cloneDeepJSONNumberArrays(t){const e=new at(this.xyzToArray);return ct.streamXYZ(t,e),e.claimResult()}static cloneXYZPropsAsNumberArray(t){const e=[];for(const i of t)i instanceof K?e.push([i.x,i.y,i.z]):Array.isArray(i)&&e.push([i[0],i[1],i.length>2?i[2]:0]);return e}static cloneXYZPropsAsFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const s of t)s instanceof K?(e[i++]=s.x,e[i++]=s.y,e[i++]=s.z):Array.isArray(s)&&(e[i++]=s[0],e[i++]=s[1],e[i++]=s.length>2?s[2]:0);return e}static cloneDeepXYZPoint3dArrays(t){const e=new at(K.create);return ct.streamXYZ(t,e),e.claimResult()}static distanceIndexedPointBToSegmentAC(t,e,i,s,n){const r=j.createStartEnd(t[e],t[s]),o=j.createStartEnd(t[e],t[i]),a=r.dotProduct(r),c=r.dotProduct(o);let h=J.conditionalDivideFraction(c,a);void 0===h&&(h=0),n||(h>1&&(h=1),h<0&&(h=0));let l=o.magnitudeSquared()-h*h*a;return l<0&&(l=0),Math.sqrt(l)}static computeConvexHullXY(t,e,i,s=!1){e.length=0,i.length=0;let n=t.length;const r=t.slice(0,n);if(r.sort(J.lexicalXYLessThan),n<3){for(const t of r)e.push(t);return void(s&&r.length>0&&e.push(r[0]))}e.push(r[0]),e.push(r[1]);let o=0;for(let t=2;t<n;t++){const i=r[t];let s=e.length-1;for(;s>=1&&e[s-1].crossProductToPointsXY(e[s],i)<=0;)r[o++]=e[s],s--,e.pop();e.push(i)}const a=e.length-1;r.length=o,r.push(e[0]),r.sort(J.lexicalXYLessThan),n=r.length,e.push(r[n-1]);for(let t=n-1;t-- >0;){const s=r[t];let n=e.length-1;for(;n>a&&e[n-1].crossProductToPointsXY(e[n],s)<=0;)i.push(e[n]),n--,e.pop();t>0&&e.push(s)}s&&e.push(e[0])}static minMaxPoints(t){if(0===t.length)return;const e={minXPoint:t[0].clone(),maxXPoint:t[0].clone(),minYPoint:t[0].clone(),maxYPoint:t[0].clone()};let i;for(let s=1;s<t.length;s++)i=t[s],i.x<e.minXPoint.x&&e.minXPoint.setFromPoint3d(i),i.x>e.maxXPoint.x&&e.maxXPoint.setFromPoint3d(i),i.y<e.minYPoint.y&&e.minYPoint.setFromPoint3d(i),i.y>e.maxYPoint.y&&e.maxYPoint.setFromPoint3d(i);return e}}ne._weightUVW=new Float64Array(8),ne._weightDU=new Float64Array(8),ne._weightDV=new Float64Array(8),ne._weightDW=new Float64Array(8);class re extends $t{dispatchToGeometryHandler(t){return this._proxyCurve.dispatchToGeometryHandler(t)}constructor(t){super(),this._proxyCurve=t}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(t){return this._proxyCurve.computeStrokeCountForOptions(t)}emitStrokableParts(t,e){this._proxyCurve.emitStrokableParts(t,e)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}clonePartialCurve(t,e){return this._proxyCurve.clonePartialCurve(t,e)}emitStrokes(t,e){this._proxyCurve.emitStrokes(t,e)}extendRange(t,e){this._proxyCurve.extendRange(t,e)}range(t,e){return this._proxyCurve.range(t,e)}fractionToPoint(t,e){return this._proxyCurve.fractionToPoint(t,e)}fractionToPointAndDerivative(t,e){return this._proxyCurve.fractionToPointAndDerivative(t,e)}fractionToPointAnd2Derivatives(t,e){return this._proxyCurve.fractionToPointAnd2Derivatives(t,e)}isInPlane(t){return this._proxyCurve.isInPlane(t)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(t){return this._proxyCurve.constructOffsetXY(t)}projectedParameterRange(t,e){return this._proxyCurve.projectedParameterRange(t,e)}}class oe{static decomposeLU(t,e,i){const s=t-1,n=Math.floor(e/2);let r;for(let t=0;t<=s;t++){const o=Math.min(s,t+n);for(let s=t;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[t*e+o-t+n]*i[o*e+s-o+n];i[t*e+s-t+n]-=r}for(let s=t+1;s<=o;s++){r=0;for(let o=Math.max(0,s-n);o<t;o++)r+=i[s*e+o-s+n]*i[o*e+t-o+n];if(Math.abs(i[t*e+n])<1e-9)return!1;i[s*e+t-s+n]=(i[s*e+t-s+n]-r)/i[t*e+n]}}return!0}static arrayAddScaledBlock(t,e,i,s){const n=t.length;let r=n*i;for(let i=0;i<n;i++,r++)t[i]+=e[r]*s}static blockAssignBlockMinusArray(t,e,i,s,n){const r=n.length;let o=e*r,a=s*r;for(let e=0;e<r;e++,a++,o++)t[o]=i[a]-n[e]}static blockSumOfScaledBlockScaledArray(t,e,i,s,n,r,o){const a=r.length;let c=e*a,h=s*a;for(let e=0;e<a;e++,h++,c++)t[c]=i[h]*n+r[e]*o}static solveBandedSystemMultipleRHS(t,e,i,s,n){if(!this.decomposeLU(t,e,i))return;const r=t-1,o=Math.floor(e/2),a=new Float64Array(s),c=new Float64Array(s*t),h=new Float64Array(s*t);for(let t=0;t<=r;t++){a.fill(0);for(let s=Math.max(0,t-o);s<t;s++)this.arrayAddScaledBlock(a,c,s,i[t*e+s-t+o]);this.blockAssignBlockMinusArray(c,t,n,t,a)}for(let t=r;t>=0;t--){const s=J.conditionalDivideCoordinate(1,i[t*e+o]);if(void 0===s)return;a.fill(0);const n=Math.min(r,t+o);for(let s=t+1;s<=n;s++)this.arrayAddScaledBlock(a,h,s,i[t*e+s-t+o]);this.blockSumOfScaledBlockScaledArray(h,t,c,t,s,a,-s)}return h}static multiplyBandedTimesFull(t,e,i,s,n){const r=new Float64Array(n.length),o=Math.floor(e/2);let a,c,h,l;for(let d=0;d<t;d++){c=d-o,c<0&&(c=0),h=d+o+1,h>t&&(h=t),l=o+d*(e-1);for(let t=0;t<s;t++){a=0;for(let e=c;e<h;e++)a+=i[l+e]*n[e*s+t];r[d*s+t]=a}}return r}}!function(t){t[t.None=0]="None",t[t.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",t[t.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(w||(w={}));class ae{get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?w.None:this._wrapMode}set wrappable(t){this._wrapMode=t}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(t,e,i){this.degree=e,this._wrapMode=i,this._knot0=0,this._knot1=1,Array.isArray(t)?(this.knots=new Float64Array(t.length),this.setKnots(t),this.setupFixedValues()):t instanceof Float64Array?(this.knots=t.slice(),this.setupFixedValues()):this.knots=new Float64Array(t)}clone(){return new ae(this.knots,this.degree,this.wrappable)}setupFixedValues(){this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree]}get knotLength01(){return this._knot1-this._knot0}testClosable(t){void 0===t&&(t=this.wrappable);const e=this.leftKnotIndex,i=this.rightKnotIndex,s=this.rightKnot-this.leftKnot,n=this.degree,r=i-e;if(t===w.OpenByAddingControlPoints){for(let t=e-n+1;t<e+n-1;t++){const e=t+r;if(!J.isSameCoordinate(this.knots[t]+s,this.knots[e]))return!1}return!0}if(t===w.OpenByRemovingKnots){const t=n-1,s=this.knots[e],r=this.knots[i];for(let n=0;n<t;n++){if(!J.isSameCoordinate(s,this.knots[e-n-1]))return!1;if(!J.isSameCoordinate(r,this.knots[i+n+1]))return!1}return!0}return!1}isAlmostEqual(t){return this.degree===t.degree&&ie.isAlmostEqual(this.knots,t.knots,ae.knotTolerance)}getKnotMultiplicity(t){let e=0;for(const i of this.knots)if(Math.abs(i-t)<ae.knotTolerance)++e;else if(t<i)break;return e}getKnotMultiplicityAtIndex(t){let e=0;if(t>=0&&t<this.knots.length){const i=this.knots[t];++e;for(let s=t-1;s>=0;--s){const t=this.knots[s];if(Math.abs(t-i)<ae.knotTolerance)++e;else if(i>t)break}for(let s=t+1;s<this.knots.length;++s){const t=this.knots[s];if(Math.abs(t-i)<ae.knotTolerance)++e;else if(i<t)break}}return e}normalize(){if(this.knotLength01<ae.knotTolerance)return!1;const t=1/this.knotLength01,e=this.leftKnot;for(let i=0;i<this.knots.length;++i)this.knots[i]=(this.knots[i]-e)*t;for(let t=this.rightKnotIndex-1;t>this.leftKnotIndex&&this.knots[t]===this.knots[this.rightKnotIndex];--t)this.knots[t]=1;for(let t=this.rightKnotIndex+1;t<this.knots.length&&this.knots[t]===this.knots[this.rightKnotIndex];++t)this.knots[t]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(t,e){const i=e?t.length-2:t.length;if(i!==this.knots.length&&(this.knots=new Float64Array(i)),e)for(let e=1;e+1<t.length;e++)this.knots[e-1]=t[e];else for(let e=0;e<t.length;e++)this.knots[e]=t[e];this.setupFixedValues()}setKnotsCapture(t){this.knots=t,this.setupFixedValues()}static createUniformClamped(t,e,i,s){const n=new ae(t+e-1,e);let r=0;for(let t=0;t<e;t++)n.knots[r++]=i;const o=1/(t-e);for(let a=1;a+e<t;a++)n.knots[r++]=i+a*o*(s-i);for(let t=0;t<e;t++)n.knots[r++]=s;return n.setupFixedValues(),n}static createUniformWrapped(t,e,i,s){const n=new ae(t+2*e-1,e),r=1/t;for(let o=1-e,a=0;o<t+e;o++,a++)n.knots[a]=J.interpolate(i,o*r,s);return n.setupFixedValues(),n}static create(t,e,i){const s=i?t.length-2:t.length,n=new ae(s,e);return n.setKnots(t,i),n}grevilleKnot(t){if(t<0)return this.leftKnot;if(t>this.rightKnotIndex)return this.rightKnot;let e=0;for(let i=t;i<t+this.degree;i++)e+=this.knots[i];return e/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(t,e){const i=this.knots[t];return i+(e=J.clamp(e,0,1))*(this.knots[t+1]-i)}spanFractionToKnot(t,e){const i=this.spanIndexToLeftKnotIndex(t);return e=J.clamp(e,0,1),this.knots[i]+e*(this.knots[i+1]-this.knots[i])}spanFractionToFraction(t,e){return(this.spanFractionToKnot(t,e)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(t){return t=J.clamp(t,0,1),J.interpolate(this.knots[this.degree-1],t,this.knots[this.knots.length-this.degree])}evaluateBasisFunctions(t,e,i){if(i[0]=1,this.degree<1)return;const s=this.knots[t],n=this.knots[t+1];if(i[1]=(e-s)/(n-s),i[0]=1-i[1],!(this.degree<2))for(let s=1;s<this.degree;s++){let n=t-s,r=n+s+1,o=0;for(let t=0;t<=s;t++){const s=this.knots[n++],a=(e-s)/(this.knots[r++]-s),c=i[t]*a,h=i[t]*(1-a);i[t]=o+h,o=c}i[s+1]=o}}evaluateBasisFunctions1(t,e,i,s,n){if(i[0]=1,s[0]=0,this.degree<1)return;const r=this.knots[t];let o=1/(this.knots[t+1]-r);if(i[1]=(e-r)*o,i[0]=1-i[1],s[0]=-o,s[1]=o,n&&(n[0]=0,n[1]=0),!(this.degree<2))for(let r=1;r<this.degree;r++){let a=t-r,c=a+r+1,h=0,l=0,d=0;for(let t=0;t<=r;t++){const r=this.knots[a++];o=1/(this.knots[c++]-r);const u=(e-r)*o,f=1-u,g=i[t]*u,p=i[t]*f,m=s[t]*u+i[t]*o,x=s[t]*f-i[t]*o,y=2*s[t]*o;if(i[t]=h+p,s[t]=l+x,h=g,l=m,n){const e=n[t]*u+y,i=n[t]*f-y;n[t]=d+i,d=e}}i[r+1]=h,s[r+1]=l,n&&(n[r+1]=d)}}knotToLeftKnotIndex(t){for(let e=this.leftKnotIndex;e<this.rightKnotIndex;++e)if(t<this.knots[e+1])return e;for(let t=this.rightKnotIndex;t>this.leftKnotIndex;--t)if(this.knots[t]-this.knots[t-1]>=ae.knotTolerance)return t-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(t){const e=this.degree;return t<=0?e-1:Math.min(t+e-1,this.knots.length-e-1)}spanIndexToSpanLength(t){const e=this.spanIndexToLeftKnotIndex(t);return this.knots[e+1]-this.knots[e]}isIndexOfRealSpan(t){return t>=0&&t<this.numSpans&&!J.isSmallMetricDistance(this.spanIndexToSpanLength(t))}reflectKnots(){const t=this.leftKnot,e=this.rightKnot,i=this.knots.length;for(let s=0;s<i;s++)this.knots[s]=t+(e-this.knots[s]);this.knots.reverse()}copyKnots(t){const e=this.wrappable===w.OpenByAddingControlPoints&&this.testClosable(),i=this.leftKnotIndex,s=this.rightKnotIndex,n=this.leftKnot,r=this.rightKnot-n,o=this.degree,a=[];t&&(e?a.push(this.knots[s-o]-r):a.push(this.knots[0]));for(const t of this.knots)a.push(t);return t&&(e?a.push(this.knots[i+o]+r):a.push(a[a.length-1])),a}}ae.knotTolerance=1e-9;class ce{static createThroughPoints(t,e){const i=t.length;if(e>i||e<2)return;const s=e-1,n=1+2*s,r=new Float64Array(n*i),o=new Float64Array(e),a=new it,c=ae.createUniformClamped(i,e-1,0,1),h=K.create();for(let l=0;l<i;l++){const d=c.grevilleKnot(l),u=c.knotToLeftKnotIndex(d);c.evaluateBasisFunctions(u,d,o);let f=0;for(let t=1;t<e;t++)o[t]>o[f]&&(f=t);const g=s-f,p=l*n;for(let t=0;t<e;t++){const e=l-s+g+t;p+e>=0&&e<i&&(r[p+g+t]=o[t])}t instanceof tt?a.push(t.getPoint3dAtUncheckedPointIndex(l,h)):a.push(t[l].clone())}const l=oe.solveBandedSystemMultipleRHS(i,n,r,3,a.float64Data());return l?cr.create(l,c.knots,e):void 0}static createThroughPointsC2Cubic(t){const e=t.clone();if(!this.C2CubicFit.validateOptions(e))return;const i=this.C2CubicFit.constructPoles(e);if(void 0===i)return;const s=this.C2CubicFit.convertFitParamsToCubicKnotVector(e.knots,e.closed);if(void 0===s)return;const n=cr.create(i,s,e.order);return e.closed&&n?.setWrappable(w.OpenByAddingControlPoints),n}}!function(t){t.C2CubicFit=class{static normalizeKnots(t){if(void 0===t||t.length<2)return t=void 0,!1;const e=ae.create(t,1,!1);if(!e.normalize())return t=void 0,!1;for(let i=0;i<t.length;++i)t[i]=e.knots[i];return!0}static constructChordLengthParameters(t){if(t.length<2)return;const e=[0];for(let i=1;i<t.length;++i)e[i]=e[i-1]+t[i].distance(t[i-1]);return this.normalizeKnots(e)?e:void 0}static constructUniformParameters(t){if(t<2)return;const e=ae.createUniformClamped(t+2,3,0,1),i=[];for(let t=e.leftKnotIndex;t<=e.rightKnotIndex;++t)i.push(e.knots[t]);return i}static removeDuplicateFitPoints(t){void 0!==t.knots&&t.knots.length!==t.fitPoints.length&&(t.knots=void 0);const e=it.create(t.fitPoints),i=e.findOrderedDuplicates();e.clear();for(let s=0,n=0;s<t.fitPoints.length;++s)s===i[n]?++n:e.push(t.fitPoints[s].clone());if(t.fitPoints=e.getPoint3dArray(),void 0!==t.knots){const e=[];for(let s=0,n=0;s<t.knots.length;++s)s===i[n]?++n:e.push(t.knots[s]);t.knots=e.slice()}return!0}static constructFitParametersFromPoints(t,e,i){let s;return!e&&i||(s=this.constructChordLengthParameters(t)),void 0===s&&(s=this.constructUniformParameters(t.length)),s}static constructFitParameters(t){return void 0===t.knots&&(t.knots=this.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed)),t.knots?.length===t.fitPoints.length}static computeAlphaBetaGamma(t,e,i,s,n,r,o,a){let c=1/(a+o+r);t[s]=r*r*c,e[s]=r*(a+o)*c,c=1/(o+r+n),e[s]+=o*(r+n)*c,i[s]=o*o*c,c=1/(o+r),t[s]*=c,e[s]*=c,i[s]*=c}static setUpSystem2Points(t,e,i){return 2===t.length&&2===e.length&&2===i.length&&(t[0]=t[1]=i[0]=i[1]=0,e[0]=e[1]=1,!0)}static setUpSystem3Points(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(3!==t.length||3!==e.length||3!==i.length)return!1;if(3!==s.knots.length||3!==s.fitPoints.length)return!1;let o=0,a=0,c=0,h=0,l=0,d=0;return n?(t[0]=0,a=s.knots[1]-s.knots[0],o=s.knots[2]-s.knots[1],l=a+o,d=1/l,e[0]=(a+l)*d,i[0]=-a*d):(t[0]=i[0]=0,e[0]=1),c=s.knots[1]-s.knots[0],a=s.knots[2]-s.knots[1],d=1/(c+a),d*=d,t[1]=a*a*d,e[1]=a*c*2*d,i[1]=c*c*d,r?(c=s.knots[2]-s.knots[1],h=s.knots[1]-s.knots[0],l=h+c,d=1/l,t[2]=-c*d,e[2]=(c+l)*d,i[2]=0):(t[2]=i[2]=0,e[2]=1),!0}static setUpSystem4PointsOrMore(t,e,i,s,n,r){if(void 0===s.knots)return!1;if(t.length!==e.length||t.length!==i.length||t.length!==s.knots.length)return!1;if(s.knots.length!==s.fitPoints.length)return!1;const o=s.fitPoints.length-1,a=o-1;let c=0,h=0,l=0,d=0,u=0,f=0;s.closed?(h=s.knots[1]-s.knots[0],d=s.knots[a]-s.knots[a-1],l=s.knots[a+1]-s.knots[a],c=s.knots[2]-s.knots[1],this.computeAlphaBetaGamma(t,e,i,0,c,h,l,d),d=l,l=h,h=s.knots[2]-s.knots[1],c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,h,l,d),c=l,h=s.knots[a+1]-s.knots[a],d=s.knots[a-1]-s.knots[a-2],l=s.knots[a]-s.knots[a-1],this.computeAlphaBetaGamma(t,e,i,a,c,h,l,d)):(n?(t[0]=0,h=s.knots[1]-s.knots[0],c=s.knots[2]-s.knots[1],u=h+c,f=1/u,e[0]=(h+u)*f,i[0]=-h*f):(t[0]=i[0]=0,e[0]=1),h=s.knots[2]-s.knots[1],l=s.knots[1]-s.knots[0],d=0,c=s.knots[3]-s.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,h,l,d),h=s.knots[a+1]-s.knots[a],l=s.knots[a]-s.knots[a-1],d=s.knots[a-1]-s.knots[a-2],c=0,this.computeAlphaBetaGamma(t,e,i,a,c,h,l,d),r?(l=s.knots[o]-s.knots[o-1],d=s.knots[o-1]-s.knots[o-2],u=d+l,f=1/u,t[o]=-l*f,e[o]=(l+u)*f,i[o]=0):(t[o]=i[o]=0,e[o]=1));for(let n=2;n<a;++n)h=s.knots[n+1]-s.knots[n],d=s.knots[n-1]-s.knots[n-2],l=s.knots[n]-s.knots[n-1],c=s.knots[n+2]-s.knots[n+1],this.computeAlphaBetaGamma(t,e,i,n,c,h,l,d);return!0}static setUpSystem(t,e,i,s){let n=!1,r=!1;s.isNaturalTangents&&!s.closed&&(n=void 0===s.startTangent,r=void 0===s.endTangent);let o=!1;return 2===s.fitPoints.length?o=this.setUpSystem2Points(t,e,i):3===s.fitPoints.length?o=this.setUpSystem3Points(t,e,i,s,n,r):4<=s.fitPoints.length&&(o=this.setUpSystem4PointsOrMore(t,e,i,s,n,r)),o}static setBesselEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;if(void 0===e.knots)return!1;const s=1/3,n=e.fitPoints.length-1;if(1===n)return i?t[0].interpolate(s,t[3],t[1]):t[3].interpolate(s,t[0],t[2]),!0;if(2===n){const n=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),r=1-n,o=t[2].plus2Scaled(t[0],-n*n,t[4],-r*r);return i?K.createAdd2Scaled(o,1/(2*n),t[0],n).interpolate(s,t[0],t[1]):K.createAdd2Scaled(o,1/(2*r),t[4],r).interpolate(s,t[4],t[3]),!0}if(i){const i=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),n=1-i,r=t[2].plus2Scaled(t[0],-i*i,t[3],-n*n);K.createAdd2Scaled(r,1/(2*i),t[0],i).interpolate(s,t[0],t[1])}else{const i=(e.knots[n]-e.knots[n-1])/(e.knots[n]-e.knots[n-2]),r=1-i,o=t[n].plus2Scaled(t[n-1],-i*i,t[n+2],-r*r);K.createAdd2Scaled(o,1/(2*r),t[n+2],r).interpolate(s,t[n+2],t[n+1])}return!0}static setNaturalEndCondition(t,e,i){return t.length===e.fitPoints.length+2&&(1==e.fitPoints.length-1?this.setBesselEndCondition(t,e,i):(i?t[1]=t[0]:t[t.length-2]=t[t.length-1],!0))}static setChordLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;let n=0,r=0,o=0;const a=e.fitPoints.length-1;1===a?i?(n=0,r=1,o=3):(n=3,r=2,o=0):i?(n=0,r=1,o=2):(n=a+2,r=a+1,o=a);const c=t[o].distance(t[n]);return t[n].plusScaled(s,c/3,t[r]),!0}static setBesselLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const s=i?e.startTangent:e.endTangent;if(void 0===s)return!1;if(!this.setBesselEndCondition(t,e,i))return!1;const n=e.fitPoints.length-1,r=i?0:n+2,o=i?1:n+1;return t[r].plusScaled(s,t[r].distance(t[o]),t[o]),!0}static setPhysicallyClosedEndCondition(t,e){const i=e.fitPoints.length-1;if(!e.isColinearTangents||i<=2||void 0!==e.startTangent&&void 0!==e.endTangent||e.isNaturalTangents||!t[0].isAlmostEqual(t[i+2]))return!0;if(void 0!==e.startTangent){const e=j.createStartEnd(t[1],t[0]).normalize();if(void 0!==e){const s=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,s,t[i+1])}}else if(void 0!==e.endTangent){const e=j.createStartEnd(t[i+1],t[i+2]).normalize();if(void 0!==e){const i=t[0].distance(t[1]);t[0].plusScaled(e,i,t[1])}}else{const e=j.createStartEnd(t[i+1],t[1]).normalize();if(void 0!==e){const s=t[0].distance(t[1]);t[0].plusScaled(e,s,t[1]);const n=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,-n,t[i+1])}}return!0}static setEndConditions(t,e){if(t.length!==e.fitPoints.length)return!1;const i=K.createZero(),s=K.createZero();t.splice(1,0,i),t.splice(t.length-1,0,s);let n=!1;return n=void 0===e.startTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!0):this.setBesselEndCondition(t,e,!0):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!0):this.setBesselLengthScaledEndCondition(t,e,!0),n=void 0===e.endTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!1):this.setBesselEndCondition(t,e,!1):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!1):this.setBesselLengthScaledEndCondition(t,e,!1),n&&(n=this.setPhysicallyClosedEndCondition(t,e)),n}static solveNearTridiagonal(t,e,i,s){if(e.length!==i.length||e.length!==s.length||e.length!==t.length)return;const n=[],r=t.length-1,o=t.slice(0,-1);let a=0;for(let t=1;t<r;++t){if(void 0===(a=J.conditionalDivideFraction(-e[t],i[t-1])))return;i[t]+=a*s[t-1],e[t]=a*e[t-1],o[t].addScaledInPlace(o[t-1],a)}if(void 0!==(a=J.conditionalDivideFraction(1,i[r-1]+e[r-1]))){s[r-1]*=a,o[r-1].scaleInPlace(a);for(let t=r-2;t>=0;--t){if(void 0===(a=J.conditionalDivideFraction(1,i[t])))return;K.createScale(o[t].plus2Scaled(o[t+1],-s[t],o[r-1],-e[t]),a,o[t]),s[t]=-(s[t]*s[t+1]+e[t]*s[r-1])*a}if(void 0!==(a=J.conditionalDivideFraction(1,1+s[0]))){n.push(K.createScale(o[0],a));for(let t=1;t<r;++t)n.push(o[t].plusScaled(n[0],-s[t]));return n}}}static validateOptions(t){if(t.order=4,t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!0),!this.removeDuplicateFitPoints(t))return!1;let e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1]);if(3===t.fitPoints.length&&e&&(t.fitPoints.pop(),void 0!==t.knots&&t.knots.pop(),e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1])),t.fitPoints.length<=2){if(e)return!1;t.closed=!1}return t.closed&&(e||(t.fitPoints.push(t.fitPoints[0].clone()),void 0!==t.knots&&t.knots.push(t.knots[t.knots.length-1]+(t.knots[t.knots.length-1]-t.knots[0])/(t.knots.length-1))),t.fitPoints.length<=4&&(t.closed=!1)),!(t.fitPoints.length<2||(void 0!==t.startTangent&&(t.startTangent.isAlmostZero?t.startTangent=void 0:t.startTangent.normalizeInPlace()),void 0!==t.endTangent&&(t.endTangent.isAlmostZero?t.endTangent=void 0:t.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(t,e,i){let s=t?.slice();if(void 0!==s){const t=s.length-e;switch(t){case 0:break;case 4:case 6:for(let e=0;e<t/2;++e)s.pop(),s.shift();break;default:s=void 0}i&&!this.normalizeKnots(s)&&(s=void 0)}return s}static convertFitParamsToCubicKnotVector(t,e,i){const s=t?.slice();if(void 0!==s){const t=i?6:4;if(e){const e=s.length-2;for(let i=2;i<=t;i+=2)s.unshift(s[e]-1),s.push(1+s[i])}else for(let e=0;e<t/2;++e)s.unshift(0),s.push(1)}return s}static convertToJsonKnots(t){void 0!==t.knots?(t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!1),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0)):(t.knots=this.constructFitParametersFromPoints(ne.clonePoint3dArray(t.fitPoints),t.isChordLenKnots,t.closed),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0))}static constructPoles(t){if(!this.constructFitParameters(t)||void 0===t.knots)return;const e=t.fitPoints.length,i=Array(e),s=Array(e),n=Array(e);if(!this.setUpSystem(i,s,n,t))return;let r=[];if(t.closed){if(void 0!==(r=this.solveNearTridiagonal(t.fitPoints,i,s,n))&&r.length>2){r.unshift(r.pop());for(let e=0;e<t.order-1;++e)r.push(r[e].clone())}}else{const o=t.fitPoints.slice();if(!this.setEndConditions(o,t))return;if(o.length!==e+2)return;const a=new Float64Array(3*e),c=new Float64Array(3*e);for(let t=0,r=0,h=0;t<e;++t)a[r++]=i[t],a[r++]=s[t],a[r++]=n[t],c[h++]=o[t+1].x,c[h++]=o[t+1].y,c[h++]=o[t+1].z;const h=oe.solveBandedSystemMultipleRHS(e,3,a,3,c);if(void 0===h)return;r=new Float64Array(3+h.length+3);let l=0;r[l++]=t.fitPoints[0].x,r[l++]=t.fitPoints[0].y,r[l++]=t.fitPoints[0].z;for(let t=0;t<h.length;)r[l++]=h[t++];r[l++]=t.fitPoints[t.fitPoints.length-1].x,r[l++]=t.fitPoints[t.fitPoints.length-1].y,r[l++]=t.fitPoints[t.fitPoints.length-1].z}return r}}}(ce||(ce={}));class he{constructor(t,e){this._fitPoints=t||[],this._knots=e}get order(){return J.resolveNumber(this._order,4)}set order(t){this._order=t}get closed(){return J.resolveValue(this._closed,!1)}set closed(t){this._closed=t}get isChordLenKnots(){return J.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(t){this._isChordLenKnots=t}get isColinearTangents(){return J.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(t){this._isColinearTangents=t}get isChordLenTangents(){return J.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(t){this._isChordLenTangents=t}get isNaturalTangents(){return J.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(t){this._isNaturalTangents=t}get startTangent(){return this._startTangent}set startTangent(t){this._startTangent=t}get endTangent(){return this._endTangent}set endTangent(t){this._endTangent=t}get fitPoints(){return this._fitPoints}set fitPoints(t){this._fitPoints=t}get knots(){return this._knots}set knots(t){this._knots=t}captureOptionalProps(t,e,i,s,n,r,o,a){this._order=J.resolveToUndefined(t,0),this._closed=J.resolveToUndefined(e,!1),this._isChordLenKnots=J.resolveToUndefined(i,0),this._isColinearTangents=J.resolveToUndefined(s,0),this._isChordLenTangents=J.resolveToUndefined(n,0),this._isNaturalTangents=J.resolveToUndefined(r,0),this._startTangent=o,this._endTangent=a}cloneAsInterpolationCurve3dProps(){const t={fitPoints:ne.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(t.order=this._order),void 0!==this._closed&&(t.closed=this._closed),void 0!==this._isChordLenKnots&&(t.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(t.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(t.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(t.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(t.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(t.endTangent=this._endTangent?.toArray()),t}clone(){const t=new he(ne.clonePoint3dArray(this.fitPoints),this.knots?.slice());return t._order=this.order,t._closed=this.closed,t._isChordLenKnots=this.isChordLenKnots,t._isColinearTangents=this.isColinearTangents,t._isChordLenTangents=this.isChordLenTangents,t._isNaturalTangents=this.isNaturalTangents,t._startTangent=this._startTangent?.clone(),t._endTangent=this._endTangent?.clone(),t}static create(t){const e=new he(ne.clonePoint3dArray(t.fitPoints),t.knots?.slice());return e._order=t.order,e._closed=t.closed,e._isChordLenKnots=t.isChordLenKnots,e._isColinearTangents=t.isColinearTangents,e._isChordLenTangents=t.isChordLenTangents,e._isNaturalTangents=t.isNaturalTangents,e._startTangent=t.startTangent?j.fromJSON(t.startTangent):void 0,e._endTangent=t.endTangent?j.fromJSON(t.endTangent):void 0,e}static areAlmostEqualAllow000AsUndefined(t,e){return void 0!==t&&0===t.maxAbs()&&(t=void 0),void 0!==e&&0===e.maxAbs()&&(e=void 0),void 0!==t&&void 0!==e?t.isAlmostEqual(e):void 0===t&&void 0===e}static areAlmostEqual(t,e){if(void 0===t&&void 0===e)return!0;if(void 0!==t&&void 0!==e&&J.areEqualAllowUndefined(t.order,e.order)&&J.areEqualAllowUndefined(t.closed,e.closed)&&J.areEqualAllowUndefined(t.isChordLenKnots,e.isChordLenKnots)&&J.areEqualAllowUndefined(t.isColinearTangents,e.isColinearTangents)&&J.areEqualAllowUndefined(t.isNaturalTangents,e.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(t.startTangent,e.startTangent)&&this.areAlmostEqualAllow000AsUndefined(t.endTangent,e.endTangent)&&J.almostEqualArrays(t.fitPoints,e.fitPoints,((t,e)=>t.isAlmostEqual(e)))){if(J.almostEqualNumberArrays(t.knots,e.knots,((t,e)=>t===e)))return!0;if(void 0===t.knots&&void 0===e.knots)return!0;let i=t.knots,s=e.knots;return void 0===t.knots?i=ce.C2CubicFit.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed):void 0===e.knots&&(s=ce.C2CubicFit.constructFitParametersFromPoints(e.fitPoints,e.isChordLenKnots,e.closed)),i=ce.C2CubicFit.convertCubicKnotVectorToFitParams(i,t.fitPoints.length,!1),s=ce.C2CubicFit.convertCubicKnotVectorToFitParams(s,e.fitPoints.length,!1),J.almostEqualNumberArrays(i,s,((t,e)=>J.isAlmostEqualNumber(t,e)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const t=this._startTangent;this._startTangent=this.endTangent,this._endTangent=t}}class le extends re{constructor(t,e){super(e),this.curvePrimitiveType="interpolationCurve",this._options=t}dispatchToGeometryHandler(t){let e=t.handleInterpolationCurve3d(this);return void 0===e&&(e=this._proxyCurve.dispatchToGeometryHandler(t)),e}static create(t){let e;return e=t instanceof he?t.clone():he.create(t),le.createCapture(e)}static createCapture(t){const e=cr.createFromInterpolationCurve3dOptions(t);if(e)return new le(t,e)}copyFitPointsFloat64Array(){return ne.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(t){const e=this._proxyCurve.tryTransformInPlace(t);return e&&(t.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&t.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&t.multiplyVectorInPlace(this._options.endTangent)),e}clone(){return new le(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(t){return t instanceof le&&he.areAlmostEqual(this._options,t._options)}isSameGeometryClass(t){return t instanceof le}}class de{constructor(t,e){this._p0=K.createZero(),this._p1=K.createZero(),this._v0=j.createZero(),this._v1=j.createZero(),this._r0=kt.createZero(),this._offsetDistance=e,this._fitOptions=new he;const i=t.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),s=t.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=i,this._fitOptions.endTangent=s,(this._fitOptions.closed=t.startPoint(this._p0).isAlmostEqual(t.endPoint(this._p1))&&i.isParallelTo(s,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(t,e){J.isSmallMetricDistance(e.x)&&J.isSmallMetricDistance(e.y)||this._fitOptions.fitPoints.push(t.plusScaled(e.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){for(let n=0;n<=e;++n){const r=J.interpolate(i,n/e,s),o=t.fractionToPointAndDerivative(r,this._r0);this.pushOffsetPoint(o.origin,o.direction)}}announceSegmentInterval(t,e,i,s,n,r){if(s>0){const t=j.createStartEnd(e,i,this._v1);for(let n=0;n<=s;++n)this.pushOffsetPoint(e.interpolate(n/s,i,this._p0),t)}}announcePointTangent(t,e,i){this.pushOffsetPoint(t,i)}claimResult(){return ce.createThroughPointsC2Cubic(this._fitOptions)}}class ue{handleCurveCollection(t){}handlePath(t){return this.handleCurveCollection(t)}handleLoop(t){return this.handleCurveCollection(t)}handleParityRegion(t){return this.handleCurveCollection(t)}handleUnionRegion(t){return this.handleCurveCollection(t)}handleBagOfCurves(t){return this.handleCurveCollection(t)}}class fe extends ue{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleCurveCollection(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handlePath(t){}handleLoop(t){}handleParityRegion(t){}handleUnionRegion(t){}handleBagOfCurves(t){}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class ge extends ue{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handleChildren(t){const e=t.children;if(e)for(const t of e)t.dispatchToGeometryHandler(this)}handleCurveCollection(t){return this.handleChildren(t)}handlePath(t){return this.handleChildren(t)}handleLoop(t){return this.handleChildren(t)}handleParityRegion(t){return this.handleChildren(t)}handleUnionRegion(t){return this.handleChildren(t)}handleBagOfCurves(t){return this.handleChildren(t)}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class pe{getXAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,pe._workPoint);return void 0===pe._workPoint&&(pe._workPoint=e),e?e.x:0}getYAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,pe._workPoint);return void 0===pe._workPoint&&(pe._workPoint=e),e?e.y:0}linearCombination(t,e){const i=Math.min(this.length,t.length),s=e instanceof G?G.createZero(e):W.createZero(e);for(let e=0;e<i;++e)s.x+=t[e]*this.getXAtUncheckedPointIndex(e),s.y+=t[e]*this.getYAtUncheckedPointIndex(e);return s}}class me extends pe{constructor(t=8,e){super(),this._data=new Float64Array(2*t),this._xyInUse=0,this._xyCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let s=void 0!==i?2*i:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?2*e:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%2!=0&&(n-=n%2)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/2,offset:s/2})}get length(){return this._xyInUse}set length(t){this.resize(t,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(2*t),this.copyData(i,this._xyInUse),this._xyCapacity=t}}resize(t,e){t>=0&&t<this._xyInUse?this._xyInUse=t:t>this._xyInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,2*this._xyInUse),this._xyInUse=t)}clone(){const t=new me(this.length);return t.copyData(this._data,this.length),t._xyInUse=this.length,t}static create(t){const e=new me(t.length);return t instanceof it?e.pushAllXYAndZ(t):e.pushAll(t),e}static createArrayOfGrowableXYZArray(t){const e=new rt;return ct.streamXYZ(t,e),e.claimArrayOfGrowableXYZArray()}push(t){this.pushXY(t.x,t.y)}pushAll(t){this.ensureCapacity(this._xyInUse+t.length,!1);for(const e of t)this.push(e)}pushAllXYAndZ(t){if(this.ensureCapacity(this._xyInUse+t.length,!1),t instanceof it){const e=t.float64Data(),i=3*t.length;for(let t=0;t+2<i;t+=3)this.pushXY(e[t],e[t+1])}else for(const e of t)this.pushXY(e.x,e.y)}pushWrap(t){if(this._xyInUse>=t){this.ensureCapacity(this._xyInUse+t,!1);for(let e=0;e<t;e++){const t=2*e;this.pushXY(this._data[t],this._data[t+1])}}}pushXY(t,e){this.ensureCapacity(this._xyInUse+1);const i=2*this._xyInUse;this._data[i]=t,this._data[i+1]=e,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(t){return!(t>=this._xyInUse||t<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(t,e){const i=2*t;return W.create(this._data[i],this._data[i+1],e)}getXAtUncheckedPointIndex(t){return this._data[2*t]}getYAtUncheckedPointIndex(t){return this._data[2*t+1]}getPoint2dArray(){const t=2*this._xyInUse,e=[],i=this._data;for(let s=0;s<t;s+=2)e.push(W.create(i[s],i[s+1]));return e}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return W.create(this._data[i],this._data[i+1],e)}}getVector2dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return G.create(this._data[i],this._data[i+1],e)}}transferFromGrowableXYArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const s=2*t,n=2*i;return this._data[s]=e._data[n],this._data[s+1]=e._data[n+1],!0}return!1}pushFromGrowableXYArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyInUse+=e,e}if(t.isIndexValid(e)){const i=2*e;return this.pushXY(t._data[i],t._data[i+1]),1}return 0}pushInterpolatedFromGrowableXYArray(t,e,i,s){if(t.isIndexValid(e)&&t.isIndexValid(s)){const n=1-i,r=t._data;e*=2,s*=2,this.pushXY(n*r[e]+i*r[s],n*r[e+1]+i*r[s+1])}}static createFromGrowableXYZArray(t,e,i){const s=t.length;if(i?(i.ensureCapacity(s,!1),i.clear()):i=new me(s),e){const n=t.float64Data(),r=3*s;let o,a,c;for(let t=0;t<r;t+=3)o=n[t],a=n[t+1],c=n[t+2],i.pushXY(e.multiplyComponentXYZ(0,o,a,c),e.multiplyComponentXYZ(1,o,a,c))}else i.pushAllXYAndZ(t);return i}front(t){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;const i=2*t;return this._data[i]=e.x,this._data[i+1]=e.y,!0}setXYAtCheckedPointIndex(t,e,i){if(!this.isIndexValid(t))return!1;const s=2*t;return this._data[s]=e,this._data[s+1]=i,!0}setXYZAtCheckedPointIndex(t,e,i){return this.setXYAtCheckedPointIndex(t,e,i)}getPoint3dArray(t=0){const e=2*this._xyInUse,i=[],s=this._data;for(let n=0;n<e;n+=2)i.push(K.create(s[n],s[n+1],t));return i}reverseInPlace(){const t=this.length;let e,i,s;const n=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=2*r,i=2*o,s=n[e],n[e]=n[i],n[i]=s,e++,i++,s=n[e],n[e]=n[i],n[i]=s}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix.coffs,n=t.origin,r=n.x,o=n.y;let a=0,c=0;for(let t=0;t+1<i;t+=2)a=e[t],c=e[t+1],e[t]=s[0]*a+s[1]*c+r,e[t+1]=s[3]*a+s[4]*c+o}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,s=t.coffs;let n=0,r=0;for(let t=0;t+1<i;t+=2)n=e[t],r=e[t+1],e[t]=s[0]*n+s[1]*r,e[t+1]=s[3]*n+s[4]*r}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,s=t.matrix;s.computeCachedInverse(!0);const n=s.inverseCoffs;if(!n)return!1;const r=t.origin,o=r.x,a=r.y;let c=0,h=0;for(let t=0;t+1<i;t+=2)c=e[t]-o,h=e[t+1]-a,e[t]=n[0]*c+n[1]*h,e[t+1]=n[3]*c+n[4]*h;return!0}extendRange(t,e){const i=this.float64Length,s=this._data;if(e)for(let n=0;n+1<i;n+=2)t.extendTransformedXY(e,s[n],s[n+1]);else for(let e=0;e+1<i;e+=2)t.extendXY(s[e],s[e+1])}sumLengths(){let t=0;const e=2*(this._xyInUse-1),i=this._data;for(let s=0;s<e;s+=2)t+=J.hypotenuseXY(i[s+2]-i[s],i[s+3]-i[s+1]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}interpolate(t,e,i,s){if(this.isIndexValid(t)&&this.isIndexValid(i)){const n=1-e,r=this._data;return t*=2,i*=2,W.create(n*r[t]+e*r[i],n*r[t+1]+e*r[i+1],s)}}areaXY(){let t=0;const e=2*this._xyInUse;if(e>4){const i=this._data[e-2],s=this._data[e-1];let n=this._data[0]-i,r=this._data[1]-s,o=0,a=0;for(let c=2;c<e;c+=2,n=o,r=a)o=this._data[c]-i,a=this._data[c+1]-s,t+=J.crossProductXYXY(n,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const s=this._data;return t*=2,e*=2,G.create(s[e]-s[t],s[e+1]-s[t+1],i)}vectorXAndYIndex(t,e,i){if(this.isIndexValid(e)){const s=this._data;return e*=2,G.create(s[e]-t.x,s[e+1]-t.y,i)}}crossProductIndexIndexIndex(t,e,i){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*t,n=2*e,r=2*i,o=this._data;return J.crossProductXYXY(o[n]-o[s],o[n+1]-o[s+1],o[r]-o[s],o[r+1]-o[s+1])}}crossProductXAndYIndexIndex(t,e,i){if(this.isIndexValid(e)&&this.isIndexValid(i)){const s=2*e,n=2*i,r=this._data;return J.crossProductXYXY(r[s]-t.x,r[s+1]-t.y,r[n]-t.x,r[n+1]-t.y)}}distance(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=2*t,s=2*e;return J.hypotenuseXY(this._data[s]-this._data[i],this._data[s+1]-this._data[i+1])}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=2*t;return J.hypotenuseXY(e.x-this._data[i],e.y-this._data[i+1])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint2dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,s=0;for(let n=0;n<2;n++){if(i=this._data[2*t+n],s=this._data[2*e+n],i>s)return 1;if(i<s)return-1}return t-e}component(t,e){return this._data[2*t+e]}isAlmostEqual(t,e=J.smallMetricDistance){const i=this._xyInUse;if(t._xyInUse!==i)return!1;const s=this._data,n=t._data;for(let t=0;t<2*i;t++)if(Math.abs(s[t]-n[t])>e)return!1;return!0}}function xe(t,e,i,s,n,r,o){const a=t.length;if(s>0){for(let s=i;s+1<a;s++)if(t.vectorIndexIndex(s,s+1,o),e.crossProduct(o,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),!0}else{i+1>=a&&(i=a-2);for(let s=i;s>=0;s--)if(t.vectorIndexIndex(s,s+1,o),o.crossProduct(e,o),o.normalizeInPlace())return r.addScaledInPlace(o,n),!0}return!1}class ye extends $t{isSameGeometryClass(t){return t instanceof ye}get isExtensibleFractionSpace(){return!0}get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(t){super(),this.curvePrimitiveType="lineString",this._points=t||new it}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(...t){const e=new ye;return e.addPoints(t),e}static createCapture(t){return new ye(t)}static createXY(t,e,i=!1){const s=new ye,n=s._points;for(const i of t)n.pushXYZ(i.x,i.y,e);if(i&&t.length>1){const t=n.distanceIndexIndex(0,n.length-1);if(void 0!==t&&0!==t&&J.isSameCoordinate(0,t)){n.pop();const t=n.front();n.push(t)}}return s}addPoints(...t){this._points.pushFrom(t)}addSteppedPoints(t,e,i,s){this._points.addSteppedPoints(t,e,i,s)}addPoint(t){this._points.push(t)}addPointXYZ(t,e,i=0){this._points.pushXYZ(t,e,i)}addFraction(t){this._fractions||(this._fractions=new Pt),this._fractions.push(t)}ensureEmptyFractions(){const t=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(t),this._fractions):(this._fractions=new Pt(t),this._fractions)}ensureEmptyUVParams(){const t=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(t),this._uvParams):(this._uvParams=new me(t),this._uvParams)}ensureEmptySurfaceNormals(){const t=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(t),this._surfaceNormals):(this._surfaceNormals=new it(t),this._surfaceNormals)}ensureEmptyDerivatives(){const t=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(t),this._derivatives):(this._derivatives=new it(t),this._derivatives)}ensureEmptyNormalIndices(){const t=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(t),this._normalIndices):(this._normalIndices=new Pt(t),this._normalIndices)}ensureEmptyUVIndices(){const t=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(t),this._uvIndices):(this._uvIndices=new Pt(t),this._uvIndices)}ensureEmptyPointIndices(){const t=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(t),this._pointIndices):(this._pointIndices=new Pt(t),this._pointIndices)}addUVParam(t){this._uvParams||(this._uvParams=new me),this._uvParams.pushXY(t.x,t.y)}addUVParamAsUV(t,e){this._uvParams||(this._uvParams=new me),this._uvParams.pushXY(t,e)}addDerivative(t){this._derivatives||(this._derivatives=new it),this._derivatives.push(t)}addSurfaceNormal(t){this._surfaceNormals||(this._surfaceNormals=new it),this._surfaceNormals.push(t)}addClosurePoint(){const t=this._points.distanceIndexIndex(0,this._points.length-1);void 0===t||J.isSameCoordinate(t,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(t){this._uvParams=me.createFromGrowableXYZArray(this._points,t)}static createRectangleXY(t,e,i,s=!0){const n=ye.create(),r=t.x,o=t.x+e,a=t.y,c=t.y+i,h=t.z;return n.addPointXYZ(r,a,h),n.addPointXYZ(o,a,h),n.addPointXYZ(o,c,h),n.addPointXYZ(r,c,h),s&&n.addClosurePoint(),n}static createRegularPolygonXY(t,e,i,s=!0){e<3&&(e=3);const n=ye.create(),r=s?0:-1,o=Math.PI/e;let a,c,h;s||(i/=Math.cos(o));for(let s=0;s<e;s++)h=(r+2*s)*o,a=Z.cleanupTrigValue(Math.cos(h)),c=Z.cleanupTrigValue(Math.sin(h)),n.addPointXYZ(t.x+i*a,t.y+i*c,t.z);return n.addClosurePoint(),n}setFrom(t){this._points=t._points.clone(this._points),t._derivatives?this._derivatives=t._derivatives.clone(this._derivatives):this._derivatives=void 0,t._fractions?this._fractions=t._fractions.clone(!1):this._fractions=void 0,t._surfaceNormals?this._surfaceNormals=t._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,t._uvParams?this._uvParams=t._uvParams.clone():this._uvParams=void 0}static createPoints(t){const e=new ye;let i;for(i of t)e._points.push(i);return e}static createIndexedPoints(t,e,i=!1){const s=new ye;for(const i of e)s._points.push(t[i]);return i&&e.length>1&&s._points.push(t[e[0]]),s}static createFloat64Array(t){const e=new ye;for(let i=0;i+3<=t.length;i+=3)e._points.push(K.create(t[i],t[i+1],t[i+2]));return e}clone(){const t=new ye;return t.setFrom(this),t}setFromJSON(t){if(this._points.clear(),Array.isArray(t)){let e;for(e of t)this._points.push(K.fromJSON(e))}}toJSON(){const t=[];let e=0;for(;this._points.isIndexValid(e);)t.push(this._points.getPoint3dAtUncheckedPointIndex(e).toJSON()),e++;return t}static fromJSON(t){const e=new ye;return e.setFromJSON(t),e}fractionToPoint(t,e){const i=this._points.length;if(0===i)return K.createZero();if(1===i)return K.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),e);const s=1/(i-1);if(t<=s)return this._points.interpolate(0,t/s,1,e);if(t+s>=1)return this._points.interpolate(i-1,(1-t)/s,i-2,e);const n=Math.floor(t/s);return this._points.interpolate(n,(t-n*s)/s,n+1,e)}fractionToPointAndDerivative(t,e){e=e||kt.createZero();const i=this._points.length;if(i<=1)return e.direction.setZero(),1===i?e.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):e.origin.setZero(),e;const s=1/(i-1);if(t<=s)return e=e||kt.createZero(),this._points.interpolate(0,t/s,1,e.origin),this._points.vectorIndexIndex(0,1,e.direction),e.direction.scaleInPlace(1/s),e;if(t+s>=1)return e=e||kt.createZero(),this._points.interpolate(i-2,1-(1-t)/s,i-1,e.origin),this._points.vectorIndexIndex(i-2,i-1,e.direction),e.direction.scaleInPlace(1/s),e;e=e||kt.createZero();const n=Math.floor(t/s),r=(t-n*s)/s;return this._points.interpolate(n,r,n+1,e.origin),this._points.vectorIndexIndex(n,n+1,e.direction),e.direction.scaleInPlace(1/s),e}fractionToPointAnd2Derivatives(t,e){const i=this.fractionToPointAndDerivative(t);return Ft.createCapture(i.origin,i.direction,j.createZero(),e)}segmentIndexAndLocalFractionToGlobalFraction(t,e){const i=this._points.length-1;return i<1?0:(t+e)/i}globalFractionToSegmentIndexAndLocalFraction(t){const e=this._points.length-1;if(e<1)return{index:0,fraction:0};const i=t*e;let s;return s=t<0?0:t>1?e-1:Math.floor(i),{index:s,fraction:i-s}}fractionToFrenetFrame(t,e){const i=this._points.length;if(i<=1)return 1===i?ft.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),e):ft.createIdentity(e);if(2===i)return ft.createRefs(this._points.interpolate(0,t,1),pt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),g.XYZ));const s=i-1,n=1/s;let r=0,o=0;t<=n?(o=t/n,r=0):t+n>=1?(r=i-2,o=1-(1-t)/n):(r=Math.floor(t/n),o=t*s-r);const a=this._points.interpolate(r,o,r+1),c=this._points.vectorIndexIndex(r,r+1),h=j.create(),l=j.create();0===r?xe(this._points,c,r+1,1,1,h,l):r+2>=i?xe(this._points,c,r-1,-1,1,h,l):(xe(this._points,c,r-1,-1,1-o,h,l),xe(this._points,c,r+1,1,o,h,l));const d=pt.createRigidFromColumns(h,c,g.ZXY);return d?ft.createOriginAndMatrix(a,d,e):ft.createTranslation(a,e)}startPoint(){return 0===this._points.length?K.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(t,e){if(this._points.isIndexValid(t))return this._points.getPoint3dAtUncheckedPointIndex(t,e)}vectorBetween(t,e,i){return this._points.vectorIndexIndex(t,e,i)}derivativeAt(t,e){if(this._derivatives&&this._derivatives.isIndexValid(t))return this._derivatives.getVector3dAtCheckedVectorIndex(t,e)}surfaceNormalAt(t,e){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(t))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(t,e)}numPoints(){return this._points.length}endPoint(){return 0===this._points.length?K.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){this._points.length>=2&&(this._points.reverseInPlace(),this._uvParams&&this._uvParams.reverseInPlace())}tryTransformInPlace(t){return this._points.multiplyTransformInPlace(t),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(t.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(t,e){const i=this._points.length-1;if(e===t||i<1)return 0;if(e<t)return this.curveLengthBetweenFractions(e,t);const s=t*i,n=e*i,r=Math.max(1,Math.ceil(s)),o=Math.min(Math.floor(n),i-1),a=r-s,c=n-o;if(r>o)return Math.abs(n-s)*this._points.distanceIndexIndex(r-1,r);{let t=a*this._points.distanceIndexIndex(r-1,r)+c*this._points.distanceIndexIndex(o,o+1);for(let e=r;e<o;e++)t+=this._points.distanceIndexIndex(e,e+1);return t}}rangeBetweenFractions(t,e,i){const s=lt.create();if(this.points.length<1)return s;if(e<t)return this.rangeBetweenFractions(e,t,i);const n=this._points.length-1,r=t*n,o=Math.max(0,Math.floor(r)),a=r-o,c=K.create();if(this._points.interpolate(o,a,o+1,c),s.extendPoint(c,i),e===t)return s;const h=e*n,l=Math.min(Math.floor(h),n-1),d=h-l;this._points.interpolate(l,d,l+1,c),s.extendPoint(c,i);for(let t=o+1;t<=l;t++)this._points.getPoint3dAtUncheckedPointIndex(t,c),s.extendPoint(c,i);return s}moveSignedDistanceFromFraction(t,e,i,s){const n=this._points.length-1,r=t*n;let o=J.restrictToInterval(Math.floor(r),0,n-1);const a=r-o,c=this._points.interpolate(o,a,o+1,ye._workPointA),h=ye._workPointB,l=new _e(c,t,e);if(e>0){for(;o<=n;)if(o++,this._points.getPoint3dAtCheckedPointIndex(o,h),l.announcePoint(h,o/n))return yt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,I.success,s);return i&&l.announceExtrapolation(this._points,n-1,n,(n-1)/n,1),yt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,l.distanceStatus(),s)}for(a<=0&&o--;o>=0;o--)if(this._points.getPoint3dAtCheckedPointIndex(o,h),l.announcePoint(h,o/n))return yt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,e,I.success,s);return i&&l.announceExtrapolation(this._points,1,0,1/n,0),yt.createCurveFractionPointDistanceCurveSearchStatus(this,l.fraction0,l.point0,-l.distance0,l.distanceStatus(),s)}quickLength(){return this.curveLength()}quickUnitNormal(t){let e=Math.floor(this._points.length/3);if(e<1&&(e=1),(t=this._points.crossProductIndexIndexIndex(0,e,e+e))&&t.normalizeInPlace())return t}closestPoint(t,e,i){i=yt.create(this,i);const s=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),n=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,1),r=this._points.length;if(r>0){const e=r-1;if(i.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(e),void 0),i.setDistanceTo(t),r>1){let o=0,a=0;for(let c=1;c<r;c++)o=t.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(c-1),this._points.getPoint3dAtUncheckedPointIndex(c)),o<0?(!s||c>1)&&(o=0):o>1&&(!n||c<e)&&(o=1),this._points.getPoint3dAtUncheckedPointIndex(c-1).interpolate(o,this._points.getPoint3dAtUncheckedPointIndex(c),i.pointQ),a=i.pointQ.distance(t),a<i.a&&i.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(c-1,o),i.pointQ,void 0,a)}}return i}isInPlane(t){return this._points.isCloseToPlane(t,J.smallMetricDistance)}static pushVertexHit(t,e,i,s,n){const r=yt.createCurveFractionPoint(i,s,n);t.push(r),0===e?r.setIntervalRole(P.isolatedAtVertex):1===e?(t[t.length-2].setIntervalRole(P.intervalStart),r.setIntervalRole(P.intervalEnd)):(t[t.length-2].setIntervalRole(P.intervalInterior),r.setIntervalRole(P.intervalEnd))}appendPlaneIntersectionPoints(t,e){if(this._points.length<1)return 0;const i=e.length,s=this._points.length,n=1===s?1:s-1,r=ye._workPointA,o=ye._workPointB,a=ye._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,r);let c=0,h=0,l=0,d=0;for(let i=0;i<this._points.length;i++,r.setFrom(o),l=c)if(this._points.getPoint3dAtUncheckedPointIndex(i,o),c=J.correctSmallMetricDistance(t.altitude(o)),0===c)ye.pushVertexHit(e,h++,this,i/n,o);else if(l*c<0){d=l/(l-c),r.interpolate(d,o,a);const t=yt.createCurveFractionPoint(this,(i-1+d)/n,a);t.setIntervalRole(P.isolated),e.push(t),h=0}return e.length-i}extendRange(t,e){this._points.extendRange(t,e)}isAlmostEqual(t){return t instanceof ye&&!!it.isAlmostEqual(this._points,t._points)}appendStrokePoint(t,e){const i=this._points.length;let s=!0;const n=void 0!==e&&void 0!==this._fractions;i>0&&(n&&J.isSameCoordinate(e,this._fractions.back())&&(s=!1),t.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(i-1))&&(s=!1)),s&&(this._points.push(t),n&&this.addFraction(e))}removeDuplicatePoints(t=J.smallMetricDistance){const e=this._points.length;if(e<2)return;let i=1;for(let s=1;s<e;s++){const e=this._points.distanceIndexIndex(s,i-1);void 0!==e&&e>t&&(this._points.moveIndexToIndex(s,i),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(i,this._fractions.atUncheckedIndex(s)),this._derivatives&&this._derivatives.moveIndexToIndex(s,i),i++)}this._points.resize(i),this._fractions&&this._fractions.resize(i),this._derivatives&&this._derivatives.resize(i)}appendFractionToPoint(t,e){if(this._derivatives){const i=t.fractionToPointAndDerivative(e,ye._workRay);this._fractions&&this._fractions.push(e),this._points.push(i.origin),this._derivatives&&this._derivatives.push(i.direction)}else{const i=t.fractionToPoint(e,ye._workPointA);this._fractions&&this._fractions.push(e),this._points.push(i)}}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(t=0,e){const i=ye.create();return t>0&&i._points.ensureCapacity(t),e&&(e.needParams&&(i._fractions=new Pt(t),i._uvParams=new me(t)),e.needNormals&&(i._derivatives=new it(t),i._surfaceNormals=new it(t))),i}appendFractionalStrokePoints(t,e,i=0,s=1,n=!0){let r=1,o=e-1;if(n&&(r=0,o=e),e>=1){const n=(s-i)/e;for(let e=r;e<=o;e++)this.appendFractionToPoint(t,i+e*n)}}appendInterpolatedStrokePoints(t,e,i,s){if(s&&this.appendStrokePoint(e,0),t>1){const s=1/t;for(let n=1;n<t;n++){const t=n*s;this.appendStrokePoint(e.interpolate(t,i),t)}}s&&this.appendStrokePoint(i,1)}emitStrokes(t,e){const i=this._points.length,s=ye._workPointA,n=ye._workPointB;if(i>0)if(e&&e.hasMaxEdgeLength){t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let r=1;r<i;r++){this._points.getPoint3dAtUncheckedPointIndex(r-1,s),this._points.getPoint3dAtUncheckedPointIndex(r,n);const i=e.applyMaxEdgeLength(1,s.distance(n));i>1&&t.appendInterpolatedStrokePoints(i,s,n,!1),t.appendStrokePoint(n)}}else for(let e=0;e<i;e++)t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(e))}emitStrokableParts(t,e){const i=this._points.length;if(t.startCurvePrimitive(this),i>1){const s=1/(i-1);if(e&&e.hasMaxEdgeLength)for(let n=1;n<i;n++){const i=e.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(n-1).distance(this._points.getPoint3dAtUncheckedPointIndex(n)));t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(n-1),this._points.getPoint3dAtUncheckedPointIndex(n),i,(n-1)*s,n*s)}else for(let e=1;e<i;e++)t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(e-1),this._points.getPoint3dAtUncheckedPointIndex(e),1,(e-1)*s,e*s)}t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){const e=this._points.length;let i=e-1;if(t&&t.hasMaxEdgeLength){i=0;for(let s=1;s<e;s++)i+=t.applyMaxEdgeLength(1,this._points.distanceIndexIndex(s-1,s))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const i=this._points.length,s=void 0!==t&&t.hasMaxEdgeLength,n=zt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=1;e<i;e++){const i=this._points.distanceIndexIndex(e-1,e),r=s?t.applyMaxEdgeLength(1,i):1;n.addToCountAndLength(r,i)}$t.installStrokeCountMap(this,n,e)}dispatchToGeometryHandler(t){return t.handleLineString3d(this)}announceClipIntervals(t,e){const i=this._points.length;if(i<2)return!1;let s=0,n=1;const r=(t,i)=>{e&&e(J.interpolate(s,t,n),J.interpolate(s,i,n),this)},o=ye._workPointA,a=ye._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,o);let c=!1;for(let e=1;e<i;e++,o.setFrom(a),s=n)this._points.getPoint3dAtUncheckedPointIndex(e,a),n=e/(i-1),t.announceClippedSegmentIntervals(0,1,o,a,r)&&(c=!0);return c}addResolvedPoint(t,e,i){const s=this._points.length;if(0!==s){if(1===s)return this._points.getPoint3dAtUncheckedPointIndex(0,ye._indexPoint),void i.push(ye._indexPoint);t<0&&(t=0),t>s-2&&(t=s-2,e+=1),this._points.interpolate(t,e,t+1,ye._indexPoint),i.push(ye._indexPoint)}}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i&&i.reverseInPlace(),i}const i=this._points.length;if(i<2)return this.clone();let s,n;i>2&&this.isPhysicallyClosed&&(t<0&&(t=0),e>1&&(e=1));const r=this.globalFractionToSegmentIndexAndLocalFraction(t),o=this.globalFractionToSegmentIndexAndLocalFraction(e);s=t<0?1:0<=t&&t<=1?J.isSmallRelative(1-r.fraction)?r.index+2:r.index+1:i,n=e<0?-1:0<=e&&e<=1?J.isSmallRelative(o.fraction)?o.index-1:o.index:i-2;const a=ye.create();this.addResolvedPoint(r.index,r.fraction,a._points);for(let t=s;t<=n;t++)this._points.isIndexValid(t)&&(this._points.getPoint3dAtUncheckedPointIndex(t,ye._workPointA),a._points.push(ye._workPointA));return this.addResolvedPoint(o.index,o.fraction,a._points),a}getIndexedSegment(t){if(t>=0&&t+1<this._points.length)return tr.create(this._points.getPoint3dAtCheckedPointIndex(t),this._points.getPoint3dAtCheckedPointIndex(t+1))}get isPhysicallyClosed(){return this._points.length>0&&J.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(t,e){const i=e.numPoints(),s=void 0!==e._fractions,n=void 0!==e._derivatives,r=this._points,o=ye._workPointA,a=ye._workPointB,c=ye._workPointC,h=r.length;if(t.primitive&&t.primitive===this&&t.componentData&&t.componentData.length+1===h){r.getPoint3dAtUncheckedPointIndex(0,o);for(let i=0;i+1<h;i++,o.setFromPoint3d(a)){r.getPoint3dAtUncheckedPointIndex(i+1,a);const h=t.componentData[i],l=h.numStroke,d=o.vectorTo(a);d.scale(l);for(let t=0;t<=l;t++){const i=t/l,r=h.fractionToA(i);e.addPoint(o.interpolate(i,a,c)),s&&e._fractions.push(r),n&&e._derivatives.push(d)}}}return e.numPoints()-i}static createArrayOfLineString3d(t){const e=new rt;ct.streamXYZ(t,e);const i=e.claimArrayOfGrowableXYZArray(),s=[];if(void 0!==i)for(const t of i)s.push(ye.createCapture(t));return s}collectCurvePrimitivesGo(t,e,i=!1){if(i){let e;for(let i=0;void 0!==(e=this.getIndexedSegment(i));i++)t.push(e)}else t.push(this)}constructOffsetXY(t){const e=Kn.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const s=t.constructOffsetXY(e);void 0!==s&&(s instanceof $t?i.push(s):Array.isArray(s)&&s.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}ye._workPointA=K.create(),ye._workPointB=K.create(),ye._workPointC=K.create(),ye._workRay=kt.createXAxis(),ye._indexPoint=K.create();class _e{constructor(t,e,i){this.point0=t,this.distance0=0,this.targetDistance=Math.abs(i),this.fraction0=e}distanceStatus(){return J.isSameCoordinate(this.distance0,this.targetDistance)?I.success:I.stoppedAtBoundary}announcePoint(t,e){const i=this.point0.distance(t),s=this.distance0+i;if(s<this.targetDistance&&!J.isSameCoordinate(s,this.targetDistance))return this.point0.setFromPoint3d(t),this.distance0=s,this.fraction0=e,!1;const n=this.targetDistance-this.distance0,r=J.safeDivideFraction(n,i,0);return this.point0.interpolate(r,t,this.point0),this.fraction0=J.interpolate(this.fraction0,r,e),this.distance0=this.targetDistance,!0}announceExtrapolation(t,e,i,s,n){const r=this.targetDistance-this.distance0,o=t.distanceIndexIndex(e,i);if(!o)return!1;const a=J.conditionalDivideFraction(r,o);return void 0!==a&&(t.interpolate(i,-a,e,this.point0),this.distance0=this.targetDistance,this.fraction0=J.interpolate(n,-a,s),!0)}}class ve{constructor(){this.shouldTriangulate=!1,this.defaultCircleStrokes=16}get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(t){this._needParams=t}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(t){this._needNormals=t}get needTwoSided(){return void 0!==this._needTwoSided&&this._needTwoSided}set needTwoSided(t){this._needTwoSided=t}get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}clone(){const t=new ve;return t.chordTol=this.chordTol,t.angleTol=this.angleTol?.clone(),t.maxEdgeLength=this.maxEdgeLength,t.needConvexFacets=this.needConvexFacets,t.minStrokesPerPrimitive=this.minStrokesPerPrimitive,t.shouldTriangulate=this.shouldTriangulate,t._needNormals=this._needNormals,t._needTwoSided=this._needTwoSided,t._needParams=this._needParams,t.needColors=this.needColors,t.defaultCircleStrokes=this.defaultCircleStrokes,t}applyMaxEdgeLength(t,e){return e=Math.abs(e),this.maxEdgeLength&&this.maxEdgeLength>0&&t*this.maxEdgeLength<e&&(t=J.stepCount(this.maxEdgeLength,e,t)),t}applyAngleTol(t,e,i){return ve.applyAngleTol(this,t,e,i)}static applyAngleTol(t,e,i,s){i=Math.abs(i);let n=s||Math.PI/8;return t&&t.angleTol&&t.angleTol.radians>0&&(n=t.angleTol.radians),e*n<i&&(e=J.stepCount(n,i,e)),e}static applyMaxEdgeLength(t,e,i){return i<0&&(i=-i),e<1&&(e=1),t&&t.maxEdgeLength&&t.maxEdgeLength*e<i&&(e=J.stepCount(t.maxEdgeLength,i,e)),e}applyTolerancesToArc(t,e=2*Math.PI){let i=1;return i=this.applyAngleTol(i,e,.25*Math.PI),i=this.applyMaxEdgeLength(i,e*t),i=this.applyChordTol(i,t,e),i=this.applyMinStrokesPerPrimitive(i),i}applyChordTol(t,e,i){if(this.chordTol&&this.chordTol>0&&this.chordTol<e){const s=this.chordTol,n=2*Math.acos(1-s/e);t=J.stepCount(n,i,t)}return t}applyChordTolToLengthAndRadians(t,e,i){if(this.chordTol&&this.chordTol>0){const s=J.conditionalDivideFraction(e,i);if(void 0!==s)return this.applyChordTol(t,s,i)}return t}applyMinStrokesPerPrimitive(t){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>t&&(t=this.minStrokesPerPrimitive),t}static createForCurves(){const t=new ve;return t.angleTol=Z.createDegrees(15),t}static createForFacets(){const t=new ve;return t.angleTol=Z.createDegrees(22.5),t}}class Pe extends $t{isSameGeometryClass(t){return t instanceof Pe}get center(){return this._center.clone()}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(t){this._sweep.setFrom(t)}get isExtensibleFractionSpace(){return!0}constructor(t,e,i){super(),this.curvePrimitiveType="arc",this._center=t,this._matrix=e,this._sweep=i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}setRefs(t,e,i){this._center=t,this._matrix=e,this._sweep=i}set(t,e,i){this.setRefs(t.clone(),e.clone(),i?i.clone():vt.create360())}setFrom(t){this._center.setFrom(t._center),this._matrix.setFrom(t._matrix),this._sweep.setFrom(t._sweep)}clone(){return new Pe(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(t,e,i,s){return s?(s.setRefs(t,e,i),s):new Pe(t,e,i)}static createScaledXYColumns(t,e,i,s,n,r){const o=e.columnX(),a=e.columnY();return Pe.create(t,o.scale(i,o),a.scale(s,a),n,r)}static createCenterNormalRadius(t,e,i,s){const n=pt.createRigidHeadsUp(e);return Pe.createScaledXYColumns(t,n,i,i,void 0,s)}static create(t,e,i,s,n){const r=e.unitCrossProductWithDefault(i,0,0,0),o=pt.createColumns(e,i,r);return Pe.createRefs(void 0!==t?t.clone():K.create(0,0,0),o,s?s.clone():vt.create360(),n)}cloneAtZ(t){return void 0===t&&(t=this._center.z),Pe.createXYZXYZXYZ(this._center.x,this._center.y,this._center.z,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,h,l){return Pe.create(K.create(t,e,i),j.create(s,n,r),j.create(o,a,c),h,l)}quickEccentricity(){const t=this._matrix.columnXMagnitude(),e=this._matrix.columnYMagnitude(),i=this._matrix.columnXYCrossProductMagnitude(),s=J.maxXY(t,e);return i/(s*s)}static createCircularStartMiddleEnd(t,e,i,s){const n=j.createStartEnd(t,e),r=j.createStartEnd(t,i),o=n.magnitude(),a=r.magnitude(),c=n.sizedCrossProduct(r,Math.sqrt(o*a));if(c){const e=Ct.linearSystem3d(c.x,c.y,c.z,n.x,n.y,n.z,r.x,r.y,r.z,0,.5*o*o,.5*a*a);if(e){const n=K.create(t.x,t.y,t.z).plus(e),r=j.createStartEnd(n,t),o=j.createRotateVectorAroundVector(r,c,Z.createDegrees(90));if(o){const t=j.createStartEnd(n,i),e=r.signedAngleTo(t,c);return e.radians<0&&e.addMultipleOf2PiInPlace(1),Pe.create(n,r,o,vt.createStartEndRadians(0,e.radians),s)}}}return ye.create(t,e,i)}getFractionToDistanceScale(){const t=this.circularRadius();if(void 0!==t)return Math.abs(t*this._sweep.sweepRadians)}fractionToPoint(t,e){const i=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(i),Math.sin(i),e)}fractionAndRadialFractionToPoint(t,e,i){const s=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,e*Math.cos(s),e*Math.sin(s),i)}fractionToPointAndDerivative(t,e){return(e=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(t),e)).direction.scaleInPlace(this._sweep.sweepRadians),e}fractionToPointAnd2Derivatives(t,e){const i=this._sweep.fractionToRadians(t);e||(e=Ft.createXYPlane());const s=Math.cos(i),n=Math.sin(i);this._matrix.originPlusMatrixTimesXY(this._center,s,n,e.origin);const r=this._sweep.sweepRadians;this._matrix.multiplyXY(-r*n,r*s,e.vectorU);const o=r*r;return this._matrix.multiplyXY(-o*s,-o*n,e.vectorV),e}radiansToPointAndDerivative(t,e){e=e||kt.createZero();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}radiansToPoint(t,e){e=e||K.create();const i=Math.cos(t),s=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e),e}radiansToRotatedBasis(t,e){e=e||Ft.createXYPlane();const i=Math.cos(t),s=Math.sin(t);return e.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(i,s,e.vectorU),this._matrix.multiplyXY(-s,i,e.vectorV),e}angleToPointAndDerivative(t,e){e=e||kt.createZero();const i=t.cos(),s=t.sin();return this._matrix.originPlusMatrixTimesXY(this._center,i,s,e.origin),this._matrix.multiplyXY(-s,i,e.direction),e}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}curveLength(){return this.curveLengthBetweenFractions(0,1)}curveLengthBetweenFractions(t,e){const i=this.getFractionToDistanceScale();if(void 0!==i)return i*Math.abs(e-t);let s=t,n=e;t>e&&(s=e,n=t);const r=(n-s)*this._sweep.sweepDegrees;let o=this.quickEccentricity();o<1e-5&&(o=1e-5);let a=Math.ceil(r/(o*Pe.quadratureIntervalAngleDegrees));return a>400&&(a=400),a<1&&(a=1),super.curveLengthWithFixedIntervalCountQuadrature(s,n,a,Pe.quadratureGuassCount)}quickLength(){const t=Math.abs(this._sweep.sweepRadians);let e=Math.ceil(4*t/Math.PI);e<1&&(e=1),e<4?e+=3:e<6&&(e+=2);const i=Pe._workPointA,s=Pe._workPointB;let n=0;this.fractionToPoint(0,i);for(let t=1;t<=e;t++)this.fractionToPoint(t/e,s),n+=i.distance(s),i.setFromPoint3d(s);const r=t/e;return n*(r/(2*Math.sin(.5*r)))}moveSignedDistanceFromFraction(t,e,i,s){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(t,e,i,s);const n=this.curveLength(),r=J.conditionalDivideFraction(e,n);return void 0===r?yt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,I.error):yt.createConditionalMoveSignedDistance(i,this,t,t+r,e,s)}allPerpendicularAngles(t,e=!0,i=!1){const s=[],n=t.vectorTo(this.center),r=this._matrix.columnXMagnitudeSquared(),o=this._matrix.columnXDotColumnY(),a=this._matrix.columnYMagnitudeSquared();return wt.solveUnitCircleImplicitQuadricIntersection(o,a-r,-o,this._matrix.dotColumnY(n),-this._matrix.dotColumnX(n),0,s),i&&(s.push(this.sweep.startRadians),s.push(this.sweep.endRadians)),s}closestPoint(t,e,i){i=yt.create(this,i);const s=this.allPerpendicularAngles(t,!0,!0);let n=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),r=Jt.resolveVariantCurveExtendParameterToCurveExtendMode(e,1);this._sweep.isFullCircle&&(n=S.None,r=S.None),n!==S.None&&r!==S.None&&(s.push(this._sweep.startRadians),s.push(this._sweep.endRadians));const o=kt.createZero();if(0===s.length)i.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,o)),i.a=t.distance(i.point);else{let n=Number.MAX_VALUE,r=0;for(const a of s){const s=Jt.resolveRadiansToSweepFraction(e,a,this.sweep);void 0!==s&&(this.fractionToPointAndDerivative(s,o),r=t.distance(o.origin),r<n&&(n=r,i.setFR(s,o),i.a=r))}}return i}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(t){return this._center=t.multiplyPoint3d(this._center,this._center),this._matrix=t.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(t){const e=t.getNormalRef();return J.isSmallMetricDistance(t.altitude(this._center))&&J.isSmallMetricDistance(this._matrix.dotColumnX(e))&&J.isSmallMetricDistance(this._matrix.dotColumnY(e))}get isCircular(){const t=this._matrix.columnXMagnitudeSquared(),e=this._matrix.columnYMagnitudeSquared(),i=this._matrix.columnXDotColumnY();return Z.isPerpendicularDotSet(t,e,i)&&J.isSameCoordinateSquared(t,e)}circularRadiusXY(){const t=this._matrix.at(0,0),e=this._matrix.at(1,0),i=this._matrix.at(0,1),s=this._matrix.at(1,1),n=J.dotProductXYXY(t,e,t,e),r=J.dotProductXYXY(i,s,i,s),o=J.dotProductXYXY(t,e,i,s);if(Z.isPerpendicularDotSet(n,r,o)&&J.isSameCoordinateSquared(n,r))return J.hypotenuseXY(t,e)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._center),s=this._matrix.coffs,n=t.velocityXYZ(s[0],s[3],s[6]),r=t.velocityXYZ(s[1],s[4],s[7]),o=J.solveTrigForm(i,n,r);let a=0;if(void 0!==o){let t;for(t of(a=o.length,o)){const i=Math.atan2(t.y,t.x),s=this._sweep.radiansToPositivePeriodicFraction(i),n=yt.createCurveFractionPoint(this,s,this.fractionToPoint(s));n.intervalRole=P.isolated,(Z.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.startRadians)||Z.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.endRadians))&&(n.intervalRole=P.isolatedAtVertex),e.push(n)}}return a}extendRange(t,e){this.extendRangeInSweep(t,this._sweep,e)}extendRangeInSweep(t,e,i){const s=new Tt(0,0,0),n=this._center.clone(Pe._workPointA),r=this._matrix.columnX(Pe._workVectorU),o=this._matrix.columnY(Pe._workVectorV);i&&(i.multiplyPoint3d(n,n),i.multiplyVector(r,r),i.multiplyVector(o,o));const a=Pe._workPointB,c=Pe._workPointC,h=dt.createNull();for(let t=0;t<3;t++)s.set(n.at(t),r.at(t),o.at(t)),s.rangeInSweep(e,h),a.setAt(t,h.low),c.setAt(t,h.high);t.extend(a),t.extend(c)}rangeBetweenFractions(t,e,i){const s=vt.createStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),n=lt.create();return this.extendRangeInSweep(n,s,i),n}getPlaneAltitudeSineCosinePolynomial(t,e){return e||(e=new Tt(0,0,0)),e.set(t.altitude(this._center),t.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),t.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),e}static createUnitCircle(){return Pe.createRefs(K.create(0,0,0),pt.createIdentity(),vt.create360())}static createXY(t,e,i=vt.create360()){return new Pe(t.clone(),pt.createScale(e,e,1),i)}static createXYEllipse(t,e,i,s=vt.create360()){return new Pe(t.clone(),pt.createScale(e,i,1),s)}setVector0Vector90(t,e){this._matrix.setColumns(t,e,t.unitCrossProductWithDefault(e,0,0,0))}toScaledMatrix3d(){const t=Z.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),e=this._matrix.multiplyXY(t.c,t.s),i=this._matrix.multiplyXY(-t.s,t.c);return{axes:pt.createRigidFromColumns(e,i,g.XYZ)||pt.createIdentity(),center:this._center,r0:e.magnitude(),r90:i.magnitude(),sweep:this.sweep.cloneMinusRadians(t.radians)}}toVectors(){return{center:this.center,vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedVectors(t){return t?{center:t.multiplyPoint3d(this._center),vector0:t.multiplyVector(this._matrix.columnX()),vector90:t.multiplyVector(this._matrix.columnY()),sweep:this.sweep}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep}}toTransformedPoint4d(t){return{center:t.multiplyPoint3d(this._center,1),vector0:t.multiplyPoint3d(this._matrix.columnX(),0),vector90:t.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep}}setFromJSON(t){if(t&&t.center&&t.vector0&&t.vector90&&t.sweep){this._center.setFromJSON(t.center);const e=j.create(),i=j.create();e.setFromJSON(t.vector0),i.setFromJSON(t.vector90),this.setVector0Vector90(e,i),this._sweep.setFromJSON(t.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(pt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(t){if(t instanceof Pe){const e=t;return this._center.isAlmostEqual(e._center)&&this._matrix.isAlmostEqual(e._matrix)&&this._sweep.isAlmostEqualAllowPeriodShift(e._sweep)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1,!0)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startCurvePrimitive(this),t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=this.maxVectorLength();e=t.applyTolerancesToArc(i,this._sweep.sweepRadians)}else e=ve.applyAngleTol(void 0,1,this._sweep.sweepRadians);return e}dispatchToGeometryHandler(t){return t.handleArc3d(this)}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i.reverseInPlace(),i}const i=this.clone();return i.sweep.setStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),i}cloneInRotatedBasis(t){const e=t.cos(),i=t.sin(),s=this._matrix.multiplyXY(e,i),n=this._matrix.multiplyXY(-i,e),r=vt.createStartEndRadians(this._sweep.startRadians-t.radians,this._sweep.endRadians-t.radians);return Pe.create(this._center.clone(),s,n,r)}announceClipIntervals(t,e){return t.announceClippedArcIntervals(this,e)}otherArcAsLocalVectors(t){const e=this._matrix.multiplyInverseXYZAsPoint3d(t.center.x-this.center.x,t.center.y-this.center.y,t.center.z-this.center.z),i=this._matrix.multiplyInverse(t.vector0),s=this._matrix.multiplyInverse(t.vector90);if(e&&i&&s)return{center:e,vector0:i,vector90:s,sweep:this.sweep.clone()}}static createFilletArc(t,e,i,s){const n=j.createStartEnd(e,t),r=j.createStartEnd(e,i),o=n.magnitude(),a=r.magnitude();if(n.normalizeInPlace()&&r.normalizeInPlace()){const t=n.plus(r);if(t.normalizeInPlace()){const i=r.minus(n),c=i.magnitude(),h=.5*c;if(!J.isSmallAngleRadians(h)){const n=h/Math.sqrt(1-h*h),r=Math.acos(h),l=s/h,d=s/n,u=d/o,f=d/a,g=e.plusScaled(t,l);return t.scaleInPlace(-s),i.scaleInPlace(s/c),{arc:Pe.create(g,t,i,vt.createStartEndRadians(-r,r)),fraction10:u,fraction12:f,point:e.clone()}}}}return{fraction10:0,fraction12:0,point:e.clone()}}scaleAboutCenterInPlace(t){this._matrix.scaleColumnsInPlace(t,t,1)}areaToChordXY(t,e){let i=J.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const s=this._sweep.fractionToRadians(t),n=.5*(this._sweep.fractionToRadians(e)-s);return n<0&&(i=-i),(n-Math.cos(n)*Math.sin(n))*i}constructOffsetXY(t){const e=Kn.create(t);if(this.isCircular||e.preserveEllipticalArcs){const t=this.cloneAtZ(),i=t.sweep.sweepRadians*t.matrixRef.coffs[8]>=0?1:-1,s=t.matrixRef.columnXMagnitude(),n=s-i*e.leftOffsetDistance,r=this.isCircular?s:t.matrixRef.columnYMagnitude(),o=this.isCircular?n:r-i*e.leftOffsetDistance;if(!J.isSmallMetricDistance(n)&&s*n>0&&(this.isCircular||!J.isSmallMetricDistance(o)&&r*o>0)){const e=n/s,i=this.isCircular?e:o/r,a=t.matrixClone();return a.scaleColumnsInPlace(e,i,1),Pe.createRefs(t.center.clone(),a,t.sweep.clone())}return}const i=new de(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}Pe._workPointA=K.create(),Pe._workPointB=K.create(),Pe._workPointC=K.create(),Pe._workVectorU=j.create(),Pe._workVectorV=j.create(),Pe.quadratureGuassCount=5,Pe.quadratureIntervalAngleDegrees=10;class Ie{constructor(){}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceLoop(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceParityRegion(t,e=-1){let i=0;for(const e of t.children)this.announceLoop(e,i++)}announceUnionRegion(t,e=-1){let i=0;for(const e of t.children)e.announceToCurveProcessor(this,i++)}announceBagOfCurves(t,e=-1){for(const e of t.children)e instanceof $t?this.announceCurvePrimitive(e):e.announceToCurveProcessor(this)}}class Ae extends Ie{constructor(){super(),this._stack=[]}enter(t){this._stack.push(t)}leave(){return this._stack.pop()}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){this.enter(t),super.announcePath(t,e),this.leave()}announceLoop(t,e=-1){this.enter(t),super.announceLoop(t,e),this.leave()}announceParityRegion(t,e=-1){this.enter(t);let i=0;for(const e of t.children)this.announceLoop(e,i++);this.leave()}announceUnionRegion(t,e=-1){this.enter(t),super.announceUnionRegion(t,e),this.leave()}announceBagOfCurves(t,e=-1){this.enter(t);let i=0;for(const e of t.children)e instanceof $t?this.announceCurvePrimitive(e,i++):e.announceToCurveProcessor(this);this.leave()}}class Se extends Ae{constructor(t){super(),this._transform=t,this._result=void 0}static clone(t,e){const i=new Se(e);return t.announceToCurveProcessor(i),i._result}enter(t){t instanceof Me&&super.enter(t.cloneEmptyPeer())}leave(){const t=super.leave();return t&&(0===this._stack.length?this._result=t:this._stack[this._stack.length-1].tryAddChild(t)),t}doClone(t){return this._transform?t.cloneTransformed(this._transform):t.clone()}announceCurvePrimitive(t,e){const i=this.doClone(t);if(void 0!==i&&this._stack.length>0){const t=this._stack[this._stack.length-1];if(t instanceof be||t instanceof Ee)if(Array.isArray(i))for(const e of i)t.tryAddChild(e);else t.tryAddChild(i)}}}class we extends Se{constructor(){super(void 0)}doClone(t){if(t instanceof ye&&t.numPoints()>1){const e=t.packedPoints,i=e.length,s=[];for(let t=0;t+1<i;t++)s.push(tr.createCapture(e.getPoint3dAtUncheckedPointIndex(t),e.getPoint3dAtUncheckedPointIndex(t+1)));return s}return t.clone()}static clone(t){const e=new we;return t.announceToCurveProcessor(e),e._result}}class Ce extends Ae{constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(t){const e=new Ce;return t.announceToCurveProcessor(e),e.numOther>0}announceCurvePrimitive(t,e){t instanceof tr?this.numLineSegment++:t instanceof ye?this.numLineString++:this.numOther++}}class Te extends Ae{constructor(){super(),this.maxGap=0}static maxGap(t){const e=new Te;return t.announceToCurveProcessor(e),e.maxGap}announceCurvePrimitive(t,e){if(this._stack.length>0){const i=this._stack[this._stack.length-1];if(i instanceof be){const s=i.cyclicCurvePrimitive(e+1);void 0!==t&&void 0!==s&&(this.maxGap=Math.max(this.maxGap,t.endPoint().distance(s.startPoint())))}}}}class ke extends Ie{constructor(){super(),this._sum=0}static sumLengths(t){const e=new ke;return t.announceToCurveProcessor(e),e._sum}announceCurvePrimitive(t,e){this._sum+=t.curveLength()}}class Fe extends Ie{constructor(t){super(),this.numFail=0,this.numOK=0,this.transform=t}static tryTransformInPlace(t,e){const i=new Fe(e);return t.announceToCurveProcessor(i),0===i.numFail}announceCurvePrimitive(t,e){t.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class Me extends Rt{constructor(){super(...arguments),this.geometryCategory="curveCollection",this.isInner=!1}sumLengths(){return ke.sumLengths(this)}closestPoint(t){let e;if(void 0!==this.children)for(const i of this.children)if(i instanceof $t){const s=i.closestPoint(t,!1);e=yt.chooseSmallerA(e,s)}else if(i instanceof Me){const s=i.closestPoint(t);e=yt.chooseSmallerA(e,s)}return e}maxGap(){return Te.maxGap(this)}checkForNonLinearPrimitives(){return Ce.hasNonLinearPrimitives(this)}tryTransformInPlace(t){return Fe.tryTransformInPlace(this,t)}clone(){return Se.clone(this)}cloneTransformed(t){return Se.clone(this,t)}cloneWithExpandedLineStrings(){return we.clone(this)}collectCurvePrimitivesGo(t,e,i=!1){if(this.children)for(const s of this.children)(s instanceof $t||s instanceof Me)&&s.collectCurvePrimitivesGo(t,e,i)}collectCurvePrimitives(t,e=!1,i=!1){const s=void 0===t?[]:t;return this.collectCurvePrimitivesGo(s,e,i),s}get isAnyRegionType(){return 2===this.dgnBoundaryType()||5===this.dgnBoundaryType()||4===this.dgnBoundaryType()}get isOpenPath(){return 1===this.dgnBoundaryType()}get isClosedPath(){return 2===this.dgnBoundaryType()}extendRange(t,e){const i=this.children;if(i)for(const s of i)s.extendRange(t,e)}static createCurveLocationDetailOnAnyCurvePrimitive(t,e=.5){if(t){if(t instanceof $t)return yt.createCurveEvaluatedFraction(t,e);if(t instanceof Me&&void 0!==t.children)for(const i of t.children){const t=this.createCurveLocationDetailOnAnyCurvePrimitive(i,e);if(t)return t}}}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}class be extends Me{constructor(){super(),this._curves=[]}get children(){return void 0===this._curves&&(this._curves=[]),this._curves}cyclicCurvePrimitive(t,e=!0){const i=this.children.length;if(0!==i){if(t>=0&&t<i)return this.children[t];if(e){const e=J.modulo(t,i);return this.children[e]}}}getPackedStrokes(t){const e=this.cloneStroked(t);if(e instanceof be){const t=e.children;if(1===t.length){const e=t[0];if(e instanceof ye)return e.packedPoints}}}tryAddChild(t){return!!(t&&t instanceof $t)&&(this._curves.push(t),!0)}getChild(t){if(t<this._curves.length)return this._curves[t]}extendRange(t,e){for(const i of this._curves)i.extendRange(t,e)}reverseChildrenInPlace(){for(const t of this._curves)t.reverseInPlace();this._curves.reverse()}childIndex(t,e){for(let e=0;e<this._curves.length;e++)if(this._curves[e]===t)return e;if(e)for(let e=0;e<this._curves.length;e++){const i=this._curves[e];if(i instanceof re&&i.proxyCurve===t)return e}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(t,e,i=!1,s){const n=this.cyclicCurvePrimitive(t,i);if(n)return yt.createCurveEvaluatedFractionPointAndDerivative(n,e,s)}}class Ee extends Me{isSameGeometryClass(t){return t instanceof Ee}constructor(){super(),this.curveCollectionType="bagOfCurves",this._children=[]}get children(){return this._children}static create(...t){const e=new Ee;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 0}announceToCurveProcessor(t,e=-1){return t.announceBagOfCurves(this,e)}cloneStroked(t){const e=new Ee;let i;for(i of this.children)if(i instanceof $t){const s=ye.create();i.emitStrokes(s,t),s&&e.children.push(s)}else if(i instanceof Me){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Ee}tryAddChild(t){return t&&this._children.push(t),!0}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleBagOfCurves(this)}}class Xe{constructor(){this.consolidateLinearGeometry=!0,this.consolidateCompatibleArcs=!0,this.duplicatePointTolerance=J.smallMetricDistance,this.colinearPointTolerance=J.smallMetricDistance}}function ze(t,e,i){let s=0;return t<i.low.x?s=1:t>i.high.x&&(s=2),e<i.low.y?s|=4:e>i.high.y&&(s|=8),s}class Re extends fe{setGeometryB(t){if(this._geometryB=t,this._circularArcB=void 0,this._circularRadiusB=void 0,t instanceof Pe){const e=t.circularRadiusXY();void 0!==e&&(this._circularRadiusB=e,this._circularArcB=t)}}reinitialize(){this._results=[]}constructor(t,e){super(),this.setGeometryB(e),this._maxDistanceSquared=J.smallMetricDistanceSquared,this.reinitialize()}set maxDistanceToAccept(t){this._maxDistanceToAccept=t,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(t,e){this.setGeometryB(e)}acceptFraction(t,e=1e-12){return!(t<-e||t>1+e)}grabPairedResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}sameCurveAndFraction(t,e,i){return t===i.curve&&J.isAlmostEqualNumber(e,i.fraction)}testAndRecordPointPairApproach(t,e,i,s,n,r,o){if(i.distanceSquaredXY(r)<this._maxDistanceSquared){const a=yt.createCurveFractionPoint(t,e,i),c=yt.createCurveFractionPoint(s,n,r),h=_t.createCapture(a,c);o&&h.swapDetails(),this._results.push(h)}}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,h){let l,d,u,f;const g=void 0!==h&&h.detailA.hasFraction1&&h.detailB.hasFraction1;g?(l=J.interpolate(i,h.detailA.fraction,s),d=J.interpolate(o,h.detailB.fraction,a),u=J.interpolate(i,h.detailA.fraction1,s),f=J.interpolate(o,h.detailB.fraction1,a)):(l=u=J.interpolate(i,t,s),d=f=J.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(this.sameCurveAndFraction(e,l,i)&&this.sameCurveAndFraction(r,d,t))return}else if(this.sameCurveAndFraction(e,l,t)&&this.sameCurveAndFraction(r,d,i))return}const m=yt.createCurveFractionPoint(e,l,e.fractionToPoint(l)),x=yt.createCurveFractionPoint(r,d,r.fractionToPoint(d));g?(m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f))):(m.setIntervalRole(P.isolated),x.setIntervalRole(P.isolated)),c?this._results.push(new _t(x,m)):this._results.push(new _t(m,x))}capturePairWithLocalFractions(t,e,i,s,n,r,o,a){const c=J.interpolate(i,t.detailA.fraction,s),h=J.interpolate(r,t.detailB.fraction,o),l=this._results.length;if(l>0){const t=this._results[l-1].detailA,i=this._results[l-1].detailB;if(a){if(this.sameCurveAndFraction(e,c,i)&&this.sameCurveAndFraction(n,h,t))return}else if(this.sameCurveAndFraction(e,c,t)&&this.sameCurveAndFraction(n,h,i))return}t.detailA.setIntervalRole(P.isolated),t.detailB.setIntervalRole(P.isolated),a||t.swapDetails(),this._results.push(t)}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}captureDetailPair(t,e,i){t&&e&&(i?this._results.push(_t.createCapture(t,e)):this._results.push(_t.createCapture(e,t)))}static updatePointToSegmentDistance(t,e,i,s,n,r,o){n<0?n=0:n>1&&(n=1),this._workPointB0=i.interpolate(n,s,this._workPointB0);const a=this._workPointB0.distanceSquaredXY(e);return a<r&&(void 0===o||a<o.detailA.a)&&(void 0===o&&(o=_t.createCapture(yt.create(),yt.create())),o.detailA.setFP(t,e),o.detailA.a=a,o.detailB.setFP(n,this._workPointB0),o.detailA.a=a),o}static segmentSegmentBoundedApproach(t,e,i,s,n){const r=e.x-t.x,o=e.y-t.y,a=s.x-i.x,c=s.y-i.y,h=i.x-t.x,l=i.y-t.y,d=s.x-t.x,u=s.y-t.y,f=i.x-e.x,g=i.y-e.y,p=s.x-e.x,m=s.y-e.y,x=J.crossProductXYXY(r,o,h,l),y=J.crossProductXYXY(r,o,d,u),_=-J.crossProductXYXY(a,c,h,l),v=-J.crossProductXYXY(a,c,p,m);if(x*y<0&&_*v<0){const n=-_/(v-_),r=-x/(y-x);return _t.createCapture(yt.createCurveFractionPoint(void 0,n,t.interpolate(n,e)),yt.createCurveFractionPoint(void 0,r,i.interpolate(r,s)))}let P;const I=J.hypotenuseSquaredXY(r,o);x*x<n*I&&(P=this.updatePointToSegmentDistance(0,i,t,e,J.dotProductXYXY(r,o,h,l)/I,n,P)),y*y<n*I&&(P=this.updatePointToSegmentDistance(1,s,t,e,J.dotProductXYXY(r,o,d,u)/I,n,P));const A=J.hypotenuseSquaredXY(a,c);return _*_<n*A&&(P=this.updatePointToSegmentDistance(0,t,i,s,-J.dotProductXYXY(a,c,h,l)/A,n,P)),v*v<n*A&&(P=this.updatePointToSegmentDistance(1,e,i,s,-J.dotProductXYXY(a,c,f,g)/A,n,P)),P}testAndRecordFractionalPairApproach(t,e,i,s,n,r,o,a,c){const h=t.fractionToPoint(e),l=t.fractionToPoint(i),d=n.fractionToPoint(r),u=n.fractionToPoint(o);this.testAndRecordPointPairApproach(t,e,h,n,r,d,c),this.testAndRecordPointPairApproach(t,i,l,n,r,d,c),this.testAndRecordPointPairApproach(t,e,h,n,o,u,c),this.testAndRecordPointPairApproach(t,i,l,n,o,u,c),a&&(this.testAndRecordProjection(t,e,h,n,r,o,c),this.testAndRecordProjection(t,i,l,n,r,o,c)),s&&(this.testAndRecordProjection(n,r,d,t,e,i,!c),this.testAndRecordProjection(n,o,u,t,e,i,!c))}testAndRecordProjection(t,e,i,s,n,r,o){const a=s.closestPoint(i,!1);a&&J.restrictToInterval(a.fraction,n,r)===a.fraction&&this.testAndRecordPointPairApproach(t,e,i,s,a.fraction,a.point,o)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l){const d=Re.segmentSegmentBoundedApproach(e,s,o,c,this._maxDistanceSquared);d&&this.capturePairWithLocalFractions(d,t,i,n,r,a,h,l)}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l)}dispatchSegmentArc(t,e,i,s,n,r,o){this.testAndRecordFractionalPairApproach(t,0,1,!0,r,0,1,!1,o);const a=r.toTransformedVectors(),c=e,h=s,l=J.tripleProductXYW(c,1,h,1,a.center,1),d=J.tripleProductXYW(c,1,h,1,a.vector0,0),u=J.tripleProductXYW(c,1,h,1,a.vector90,0),f=new Pt(2),g=new Pt(2),p=new Pt(2),m=At.appendImplicitLineUnitCircleIntersections(l,d,u,f,g,p);for(let e=0;e<m;e++){const s=a.center.plus2Scaled(a.vector0,f.atUncheckedIndex(e),a.vector90,g.atUncheckedIndex(e)),l=a.sweep.radiansToSignedPeriodicFraction(p.atUncheckedIndex(e)),d=Ct.lineSegment3dXYClosestPointUnbounded(c,h,s);void 0!==d&&this.acceptFraction(d)&&this.acceptFraction(l)&&this.recordPointWithLocalFractions(d,t,i,n,l,r,0,1,o)}const x=a.vector0.crossProductStartEndXY(e,s),y=a.vector90.crossProductStartEndXY(e,s),_=Math.atan2(y,x);for(const e of[_,_+Math.PI]){const s=a.center.plus2Scaled(a.vector0,Math.cos(e),a.vector90,Math.sin(e)),l=a.sweep.radiansToSignedPeriodicFraction(e),d=Ct.lineSegment3dXYClosestPointUnbounded(c,h,s);void 0!==d&&this.acceptFraction(d)&&this.acceptFraction(l)&&this.recordPointWithLocalFractions(d,t,i,n,l,r,0,1,o)}}dispatchCircularCircularOrdered(t,e,i,s,n){const r=t.center.distance(i.center),o=void 0!==this._maxDistanceToAccept?this._maxDistanceToAccept:J.smallMetricDistance;if(!(r>e+s+o))if(this.testAndRecordFractionalPairApproach(t,0,1,!1,i,0,1,!1,n),J.isSmallMetricDistance(r));else{const a=j.createStartEnd(t.center,i.center);if(a.scaleInPlace(1/r),r-e-s>o);else for(const c of[-e,e])for(const e of[-s,s])if(r-c+e<o){const s=this.resolveDirectionToArcXYFraction(t,a,c);if(s){const t=this.resolveDirectionToArcXYFraction(i,a,e);t&&this.captureDetailPair(s,t,n)}}}}resolveDirectionToArcXYFraction(t,e,i){const s=i*t.matrixRef.columnDotXYZ(0,e.x,e.y,0),n=i*t.matrixRef.columnDotXYZ(1,e.x,e.y,0),r=Math.atan2(n,s),o=t.sweep.radiansToPositivePeriodicFraction(r,0);if(o<1)return yt.createCurveEvaluatedFraction(t,o)}dispatchArcArc(t,e,i){if(this._circularArcB){const s=this._circularRadiusB,n=t.circularRadiusXY();if(void 0!==n)return void(n>=s?this.dispatchCircularCircularOrdered(t,n,e,s,i):this.dispatchCircularCircularOrdered(e,s,t,n,!i))}}dispatchArcBsplineCurve3d(t,e,i){const s=ye.create();e.emitStrokes(s),this.computeArcLineString(t,s,i)}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=ye.create();t.emitStrokes(s);const n=ye.create();e.emitStrokes(n),this.computeLineStringLineString(s,n,i)}dispatchLineStringBSplineCurve(t,e,i){const s=ye.create();e.emitStrokes(s),this.computeLineStringLineString(t,s,i)}dispatchSegmentBsplineCurve(t,e,i){const s=ye.create();e.emitStrokes(s),this.computeSegmentLineString(t,s,i)}computeSegmentLineString(t,e,i){const s=t.point0Ref,n=t.point1Ref;let r,o,a,c,h,l,d=Re._workPointBB0,u=Re._workPointBB1,f=Re._workPointBB2;const g=Re._workVectorA;j.createStartEnd(s,n,g);const p=g.magnitudeSquared(),m=e.numPoints();e.packedPoints.getPoint3dAtUncheckedPointIndex(0,d),e.packedPoints.getPoint3dAtUncheckedPointIndex(1,d),r=g.crossProductStartEndXY(s,d),o=g.crossProductStartEndXY(s,d),c=g.dotProductStartEndXY(s,d),h=g.dotProductStartEndXY(s,u);for(let x=2;x<m;x++){if(e.packedPoints.getPoint3dAtUncheckedPointIndex(x,u),a=g.crossProductStartEndXY(s,d),l=g.dotProductStartEndXY(s,f),(r-o)*(a-o)<=0&&h>=0&&h<=p){const r=h/p,o=s.interpolate(h/p,n);if(u.distanceXY(o)<this._maxDistanceToAccept){const s=yt.createCurveFractionPoint(t,r,o),n=yt.createCurveFractionPoint(e,x/(m-1),f),a=_t.createCaptureOptionalReverse(s,n,i);this._results.push(a)}}const y=d;d=u,u=f,f=y;const _=r;r=o,o=a,a=_;const v=c;c=h,h=l,l=v}this.testAndRecordFractionalPairApproach(t,0,1,!0,e,0,1,!1,i)}computeArcLineString(t,e,i){const s=Re._workPointBB0,n=Re._workPointBB1,r=e.numPoints();if(r>1){const o=1/(r-1);let a,c;a=0,e.pointAt(0,s);for(let h=1;h<r;h++,s.setFrom(n),a=c)e.pointAt(h,n),c=h*o,this.dispatchSegmentArc(e,s,a,n,c,t,!i)}}handleLineSegment3d(t){if(this._geometryB instanceof tr){const e=this._geometryB;this.dispatchSegmentSegment(t,t.point0Ref,0,t.point1Ref,1,e,e.point0Ref,0,e.point1Ref,1,!1)}else this._geometryB instanceof ye?this.computeSegmentLineString(t,this._geometryB,!1):this._geometryB instanceof Pe?this.dispatchSegmentArc(t,t.point0Ref,0,t.point1Ref,1,this._geometryB,!1):this._geometryB instanceof cr&&this.dispatchSegmentBsplineCurve(t,this._geometryB,!1)}computeLineStringLineString(t,e,i){const s=t.range(),n=e.range();if(s.expandInPlace(this._maxDistanceToAccept),!n.intersectsRangeXY(s))return;let r,o;const a=lt.createNull(),c=Re._workPointAA0,h=Re._workPointAA1,l=Re._workPointBB0,d=Re._workPointBB1,u=t.numPoints(),f=e.numPoints();if(u>1&&f>1){t.pointAt(0,c);const s=1/(u-1),g=1/(f-1);let p,m,x,y=0;t.pointAt(0,c);for(let _=1;_<u;_++,c.setFrom(h),y=m)if(m=_*s,p=0,t.pointAt(_,h),a.setNull(),a.extendPoint(c),a.extendPoint(h),a.expandInPlace(this._maxDistanceToAccept),a.intersectsRangeXY(n)){e.pointAt(0,l),r=ze(l.x,l.y,a);for(let s=1;s<f;s++,l.setFrom(d),p=x,r=o)e.pointAt(s,d),o=ze(d.x,d.y,a),x=s*g,0==(r&o)&&this.dispatchSegmentSegment(t,c,y,h,m,e,l,p,d,x,i)}}}handleLineString3d(t){if(this._geometryB instanceof ye){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof tr?this.computeSegmentLineString(this._geometryB,t,!0):this._geometryB instanceof Pe?this.computeArcLineString(this._geometryB,t,!0):this._geometryB instanceof cr&&this.dispatchLineStringBSplineCurve(t,this._geometryB,!1)}handleArc3d(t){this._geometryB instanceof tr?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,t,!0):this._geometryB instanceof ye?this.computeArcLineString(t,this._geometryB,!1):this._geometryB instanceof Pe?this.dispatchArcArc(t,this._geometryB,!1):this._geometryB instanceof cr&&this.dispatchArcBsplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof tr?this.dispatchSegmentBsplineCurve(this._geometryB,t,!0):this._geometryB instanceof ye?this.dispatchLineStringBSplineCurve(this._geometryB,t,!0):this._geometryB instanceof Pe?this.dispatchArcBsplineCurve3d(this._geometryB,t,!0):this._geometryB instanceof ar&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}Re._workPointAA0=K.create(),Re._workPointAA1=K.create(),Re._workPointBB0=K.create(),Re._workPointBB1=K.create(),Re._workPointBB2=K.create(),Re._workVectorA=j.create(),Re._workPointB0=K.create();class De{constructor(t,e){this.x0=t,this.x1=e}set(t,e){this.x0=t,this.x1=e}shift(t){this.x0+=t,this.x1+=t}static create(t=0,e=1,i){return i?(i.set(t,e),i):new De(t,e)}setFrom(t){this.x0=t.x0,this.x1=t.x1}clone(){return new De(this.x0,this.x1)}get isIn01(){return J.isIn01(this.x0)&&J.isIn01(this.x1)}fractionToPoint(t){return J.interpolate(this.x0,t,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const t=this.x0;this.x0=this.x1,this.x1=t}reverseIfNeededForDeltaSign(t=1){t*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(t){return J.isSameCoordinate(this.x0,t.x0)&&J.isSameCoordinate(this.x1,t.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(t,e){const i=e-t,s=t+this.x0*i,n=t+this.x1*i,r=n-s;if(s>0){if(n>=0)return!0;const t=-s/r;return this.x1=this.x0+t*(this.x1-this.x0),!0}if(s<0){if(n<0)return!1;const t=-s/r;return this.x0=this.x0+t*(this.x1-this.x0),!0}return n>0}clampDirectedTo01(){let t=this.x0,e=this.x1;if(e>t){if(t<0&&(t=0),e>1&&(e=1),t>=e)return!1}else if(t>1&&(t=1),e<0&&(e=0),t<=e)return!1;return this.set(t,e),!0}}class Ne{get tolerance(){return this._tolerance}constructor(t=J.smallMetricDistance){this._tolerance=t}static create(t=J.smallMetricDistance){return new Ne(t)}static assignDetailInterpolatedFractionsAndPoints(t,e,i,s,n,r=!1){r?(t.fraction=i,t.fraction1=e):(t.fraction=e,t.fraction1=i),t.point=s.interpolate(t.fraction,n,t.point),t.point1=s.interpolate(t.fraction1,n,t.point1)}projectPointToSegmentXY(t,e,i){this._vectorU=j.createStartEnd(e,i,this._vectorU),this._vectorV=j.createStartEnd(e,t,this._vectorV);const s=this._vectorU.dotProductXY(this._vectorU),n=this._vectorU.dotProductXY(this._vectorV),r=J.safeDivideFraction(n,s,0);return yt.createCurveFractionPoint(void 0,r,e.interpolate(r,i))}coincidentSegmentRangeXY(t,e,i,s,n=!0){const r=this.projectPointToSegmentXY(t,i,s);if(t.distanceXY(r.point)>this._tolerance)return;const o=this.projectPointToSegmentXY(e,i,s);if(e.distanceXY(o.point)>this._tolerance)return;const a=this.projectPointToSegmentXY(i,t,e);if(i.distanceXY(a.point)>this._tolerance)return;const c=this.projectPointToSegmentXY(s,t,e);if(s.distanceXY(c.point)>this._tolerance)return;if(r.fraction1=o.fraction,r.point1=o.point,a.fraction1=c.fraction,a.point1=c.point,!n)return _t.createCapture(a,r);const h=De.create(a.fraction,a.fraction1);if(h.clampDirectedTo01()){const n=h.x0,o=h.x1,c=a.inverseInterpolateFraction(n),l=a.inverseInterpolateFraction(o);return Ne.assignDetailInterpolatedFractionsAndPoints(a,n,o,t,e,n>o),Ne.assignDetailInterpolatedFractionsAndPoints(r,c,l,i,s,c>l),_t.createCapture(a,r)}if(h.signedDelta()<0){if(a.point.isAlmostEqual(t,this.tolerance))return a.collapseToStart(),r.collapseToStart(),_t.createCapture(a,r);if(a.point1.isAlmostEqual(e,this.tolerance))return a.collapseToEnd(),r.collapseToEnd(),_t.createCapture(a,r)}else{if(a.point.isAlmostEqual(e,this.tolerance))return a.collapseToStart(),r.collapseToEnd(),_t.createCapture(a,r);if(a.point1.isAlmostEqual(t,this.tolerance))return a.collapseToEnd(),r.collapseToStart(),_t.createCapture(a,r)}}createDetailPair(t,e,i,s,n,r){const o=n-s,a=J.conditionalDivideFraction(i.x0-s,o),c=J.conditionalDivideFraction(i.x1-s,o);if(void 0!==a&&void 0!==c){const s=yt.createCurveEvaluatedFractionFraction(t,i.x0,i.x1),n=yt.createCurveEvaluatedFractionFraction(e,a,c);return r&&s.swapFractionsAndPoints(),_t.createCapture(s,n)}}appendDetailPair(t,e){return void 0===e?t:void 0===t?[e]:(t.push(e),t)}coincidentArcIntersectionXY(t,i,s=!0){let n;if(t.center.isAlmostEqual(i.center,this.tolerance)){const s=t.matrixRef.multiplyMatrixInverseMatrix(i.matrixRef);if(s){const r=s.at(0,0),o=s.at(1,0),a=s.at(0,1),c=s.at(1,1),h=J.hypotenuseXY(r,o),l=J.hypotenuseXY(a,c),d=J.dotProductXYXY(r,o,a,c),u=J.crossProductXYXY(r,o,a,c);if(J.isAlmostEqualNumber(h,1)&&J.isAlmostEqualNumber(l,1)&&J.isAlmostEqualNumber(0,d)){const s=Math.atan2(o,r),a=u>0?1:-1,c=s+a*i.sweep.startRadians,h=s+a*i.sweep.endRadians,l=a*t.sweep.sweepRadians*i.sweep.sweepRadians<0,d=vt.createStartEndRadians(c,h),f=t.sweep,g=f.fractionPeriod(),p=f.radiansToPositivePeriodicFraction(d.startRadians);e(p>=0);const m=p+d.sweepRadians/f.sweepRadians,x=(e,s)=>{const r=n?n.length:0,o=e.x0,a=e.x1;if(e.clampDirectedTo01()&&!J.isSmallRelative(e.absoluteDelta()))n=this.appendDetailPair(n,this.createDetailPair(t,i,e,o,a,l));else{const e=l?s:!s,r=this._point0=s?t.startPoint(this._point0):t.endPoint(this._point0),o=this._point1=e?i.startPoint(this._point1):i.endPoint(this._point1);if(r.isAlmostEqual(o,this.tolerance)){const a=yt.createCurveFractionPoint(t,s?0:1,r),c=yt.createCurveFractionPoint(i,e?0:1,o);n=this.appendDetailPair(n,_t.createCapture(a,c))}}return void 0!==n&&n.length>r};x(De.create(p,m),!1),m>=g?x(De.create(p-g,m-g),!0):0===p&&x(De.create(p+g,m+g),!0)}}}return n}}class Ye extends Zt{constructor(t,e){super(),this._curveA=t,this._curveB=e,this._rayA=kt.createZero(),this._rayB=kt.createZero()}evaluate(t,e){return this._curveA.fractionToPointAndDerivative(t,this._rayA),this._curveB.fractionToPointAndDerivative(e,this._rayB),this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x-this._rayA.origin.x,this._rayB.origin.y-this._rayA.origin.y,0,-this._rayA.direction.x,-this._rayA.direction.y,0,this._rayB.direction.x,this._rayB.direction.y,0),!0}}class Oe{constructor(){this.dataA=[],this.dataB=[]}}class Be extends fe{reinitialize(){this._results=[]}constructor(t,e,i,s,n,r=J.smallMetricDistance){super(),this._extendA=i,this._geometryB=s,this._extendB=n,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===t||t.isIdentity()||(this._worldToLocalAffine=t.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=t.clone())),this._coincidentGeometryContext=Ne.create(r),this.reinitialize()}resetGeometry(t,e,i,s){this._extendA=e,this._geometryB=i,this._extendB=s}acceptFraction(t,e,i,s=1e-12){return!(!t&&e<-s||!i&&e>1+s)}acceptFractionOnLine(t,e,i,s,n,r=J.smallMetricDistance){return!t&&e<0?J.isDistanceWithinTol(e*s.distanceXY(n),r):!(!i&&e>1)||J.isDistanceWithinTol((e-1)*s.distanceXY(n),r)}grabPairedResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}sameCurveAndFraction(t,e,i){return t===i.curve&&J.isAlmostEqualNumber(e,i.fraction)}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c,h){let l,d,u,f;const g=void 0!==h&&h.detailA.hasFraction1&&h.detailB.hasFraction1;g?(l=J.interpolate(i,h.detailA.fraction,s),d=J.interpolate(o,h.detailB.fraction,a),u=J.interpolate(i,h.detailA.fraction1,s),f=J.interpolate(o,h.detailB.fraction1,a)):(l=u=J.interpolate(i,t,s),d=f=J.interpolate(o,n,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(this.sameCurveAndFraction(e,l,i)&&this.sameCurveAndFraction(r,d,t))return}else if(this.sameCurveAndFraction(e,l,t)&&this.sameCurveAndFraction(r,d,i))return}const m=yt.createCurveFractionPoint(e,l,e.fractionToPoint(l)),x=yt.createCurveFractionPoint(r,d,r.fractionToPoint(d));g?(m.captureFraction1Point1(u,e.fractionToPoint(u)),x.captureFraction1Point1(f,r.fractionToPoint(f))):(m.setIntervalRole(P.isolated),x.setIntervalRole(P.isolated)),c?this._results.push(new _t(x,m)):this._results.push(new _t(m,x))}recordPairs(t,e,i,s){if(void 0!==i)for(const n of i)this.recordPointWithLocalFractions(n.detailA.fraction,t,0,1,n.detailB.fraction,e,0,1,s,n)}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Be._workVector2dA,m=this._coincidentGeometryContext.coincidentSegmentRangeXY(i,n,h,d);m?this.recordPointWithLocalFractions(m.detailA.fraction,t,s,r,m.detailB.fraction,a,l,u,g,m):Ct.lineSegment3dXYTransverseIntersectionUnbounded(i,n,h,d,p)&&this.acceptFractionOnLine(e,p.x,o,i,n,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(c,p.y,f,h,d,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,l,u,g)}computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Be._workPointA0H,m=Be._workPointA1H,x=Be._workPointB0H,y=Be._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(i,1,p),this._worldToLocalPerspective.multiplyPoint3d(n,1,m),this._worldToLocalPerspective.multiplyPoint3d(h,1,x),this._worldToLocalPerspective.multiplyPoint3d(d,1,y);const _=Ct.lineSegment3dHXYTransverseIntersectionUnbounded(p,m,x,y);if(void 0!==_){const i=_.x,n=_.y;this.acceptFraction(e,i,o)&&this.acceptFraction(c,n,f)&&this.recordPointWithLocalFractions(i,t,s,r,n,a,l,u,g)}}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){this._worldToLocalAffine?(Be.setTransformedWorkPoints(this._worldToLocalAffine,i,n,h,d),this.computeSegmentSegment3D(t,e,Be._workPointA0,s,Be._workPointA1,r,o,a,c,Be._workPointB0,l,Be._workPointB1,u,f,g)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g):this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,h,l){if(this._worldToLocalPerspective){const d=a.toTransformedPoint4d(this._worldToLocalPerspective),u=this._worldToLocalPerspective.multiplyPoint3d(i,1),f=this._worldToLocalPerspective.multiplyPoint3d(n,1),g=J.tripleProductPoint4dXYW(u,f,d.center),p=J.tripleProductPoint4dXYW(u,f,d.vector0),m=J.tripleProductPoint4dXYW(u,f,d.vector90),x=new Pt(2),y=new Pt(2),_=new Pt(2),v=At.appendImplicitLineUnitCircleIntersections(g,p,m,x,y,_);for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,y.atUncheckedIndex(i)),g=d.sweep.radiansToSignedPeriodicFraction(_.atUncheckedIndex(i)),p=Ct.lineSegment3dHXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,g,h)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,l)}}else{const d=a.toTransformedVectors(this._worldToLocalAffine);let u=i,f=n;this._worldToLocalAffine&&(u=this._worldToLocalAffine.multiplyPoint3d(i),f=this._worldToLocalAffine.multiplyPoint3d(n));const g=J.tripleProductXYW(u,1,f,1,d.center,1),p=J.tripleProductXYW(u,1,f,1,d.vector0,0),m=J.tripleProductXYW(u,1,f,1,d.vector90,0),x=new Pt(2),y=new Pt(2),_=new Pt(2),v=At.appendImplicitLineUnitCircleIntersections(g,p,m,x,y,_),P=1e-10,I=1e-7;for(let i=0;i<v;i++){const n=d.center.plus2Scaled(d.vector0,x.atUncheckedIndex(i),d.vector90,y.atUncheckedIndex(i)),g=d.sweep.radiansToSignedPeriodicFraction(_.atUncheckedIndex(i)),p=Ct.lineSegment3dXYClosestPointUnbounded(u,f,n);void 0!==p&&this.acceptFraction(e,p,o,P)&&this.acceptFraction(c,g,h,I)&&this.recordPointWithLocalFractions(p,t,s,r,g,a,0,1,l)}}}dispatchArcArcThisOrder(t,e,i,s,n,r,o){const a=e.inverse();if(a){const e=a.multiplyMatrixMatrix(n),c=[],h=[];wt.solveUnitCircleHomogeneousEllipseIntersection(e.coffs[2],e.coffs[5],e.coffs[8],e.coffs[0],e.coffs[3],e.coffs[6],e.coffs[1],e.coffs[4],e.coffs[7],c,h);for(let e=0;e<c.length;e++){const n=t.sweep.radiansToSignedPeriodicFraction(h[e]),a=s.sweep.radiansToSignedPeriodicFraction(c[e]);this.acceptFraction(i,n,i)&&this.acceptFraction(r,a,r)&&this.recordPointWithLocalFractions(n,t,0,1,a,s,0,1,o)}}}dispatchArcArc(t,e,i,s,n){let r,o;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective),s=i.toTransformedPoint4d(this._worldToLocalPerspective);r=pt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w),o=pt.createColumnsXYW(s.vector0,s.vector0.w,s.vector90,e.vector90.w,s.center,s.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine),s=i.toTransformedVectors(this._worldToLocalAffine);r=pt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1),o=pt.createColumnsXYW(s.vector0,0,s.vector90,0,s.center,1)}if(r.conditionNumber()>o.conditionNumber()?this.dispatchArcArcThisOrder(t,r,e,i,o,s,n):this.dispatchArcArcThisOrder(i,o,s,t,r,e,!n),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const e=this._coincidentGeometryContext.coincidentArcIntersectionXY(t,i,!0);void 0!==e&&this.recordPairs(t,i,e,n)}}dispatchArcBsplineCurve3d(t,e,i,s,n){let r;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective);r=pt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine);r=pt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1)}const o=r.inverse();if(o){const r=i.order,a=2*r-1,c=new Float64Array(r),h=new Ot(a),l=o.at(0,0),d=o.at(0,1),u=0,f=o.at(0,2),g=o.at(1,0),p=o.at(1,1),m=0,x=o.at(1,2),y=o.at(2,0),_=o.at(2,1),v=0,P=o.at(2,2);if(o){let r;for(let o=0;r=i.getSaturatedBezierSpan3dH(o,r),r;o++){this._worldToLocalPerspective?r.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&r.tryTransformInPlace(this._worldToLocalAffine),h.zero(),r.poleProductsXYZW(c,l,d,u,f),h.addSquaredSquaredBezier(c,1),r.poleProductsXYZW(c,g,p,m,x),h.addSquaredSquaredBezier(c,1),r.poleProductsXYZW(c,y,_,v,P),h.addSquaredSquaredBezier(c,-1);const o=h.roots(0,!0);if(o)for(const a of o){const o=r.fractionToParentFraction(a),c=r.fractionToPoint4d(a),h=c.dotProductXYZW(l,d,u,f),y=c.dotProductXYZW(g,p,m,x),_=t.sweep.radiansToSignedPeriodicFraction(Math.atan2(y,h));this.acceptFraction(e,_,e)&&this.acceptFraction(s,o,s)&&this.recordPointWithLocalFractions(_,t,0,1,o,i,0,1,n)}}}}}transformBeziers(t){if(this._worldToLocalAffine)for(const e of t)e.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const e of t)e.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(t){const e=[];e.length=0;for(const i of t)e.push(i.range());return e}dispatchBezierBezierStrokeFirst(t,e,i,s,n,r,o,a){this._xyzwA0||(this._xyzwA0=bt.create()),this._xyzwA1||(this._xyzwA1=bt.create()),this._xyzwPlane||(this._xyzwPlane=bt.create()),this._xyzwB||(this._xyzwB=bt.create()),t.fractionToPoint4d(0,this._xyzwA0);let c,h=0;const l=1/i;for(let r=1;r<=i;r++,h=c,this._xyzwA0.setFrom(this._xyzwA1)){c=r*l,t.fractionToPoint4d(c,this._xyzwA1),bt.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),s.poleProductsXYZW(o.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);let i=0;const d=o.roots(0,!0);if(d)for(const r of d){let o=r;s.fractionToPoint4d(o,this._xyzwB);const l=Ct.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(l&&J.isIn01WithTolerance(l,1e-5)){let r=J.interpolate(h,l,c);const d=new Ye(t,s),u=new qt(d);u.setUV(r,o),u.runIterations()&&(r=u.getU(),o=u.getV());const f=t.fractionToParentFraction(r),g=s.fractionToParentFraction(o),p=t.fractionToPoint(r),m=e.fractionToPoint(f),x=s.fractionToPoint(o),y=n.fractionToPoint(g);p.isAlmostEqualXY(m)||i++,x.isAlmostEqualXY(y)||i++,i>0&&!p.isAlmostEqual(x)&&i++,i>0&&!m.isAlmostEqual(y)&&i++,this.acceptFraction(!1,f,!1)&&this.acceptFraction(!1,g,!1)&&this.recordPointWithLocalFractions(f,e,0,1,g,n,0,1,a)}}}}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const s=t.collectBezierSpans(!0),n=e.collectBezierSpans(!0),r=s.length,o=n.length;this.transformBeziers(s),this.transformBeziers(n);const a=this.getRanges(s),c=this.getRanges(n),h=t.order,l=e.order,d=new Ot(h),u=new Ot(l);for(let h=0;h<r;h++)for(let r=0;r<o;r++)if(a[h].intersectsRangeXY(c[r])){const o=s[h].computeStrokeCountForOptions(),a=n[r].computeStrokeCountForOptions();o<a?this.dispatchBezierBezierStrokeFirst(s[h],t,o,n[r],e,a,u,i):this.dispatchBezierBezierStrokeFirst(n[r],e,a,s[h],t,o,d,!i)}}projectPoint(t,e=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(t,e):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(t.x,t.y,t.z,e):bt.createFromPointAndWeight(t,e)}mapNPCPlaneToWorld(t,e){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(t.x,t.y,t.z,t.w,e):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(t,e):t.clone(e)}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,h){const l=this.projectPoint(i),d=this.projectPoint(n),u=bt.createPlanePointPointZ(l,d);this.mapNPCPlaneToWorld(u,u);const f=[];a.appendPlaneIntersectionPoints(u,f);for(const i of f){const n=i.fraction,u=i.point,f=this.projectPoint(u),g=Ct.lineSegment3dHXYClosestPointUnbounded(l,d,f);void 0!==g&&this.acceptFraction(e,g,o)&&this.acceptFraction(c,n,c)&&this.recordPointWithLocalFractions(g,t,s,r,n,a,0,1,h)}}dispatchLineStringBSplineCurve(t,e,i,s,n){const r=t.numPoints();if(r>1){const o=1/(r-1);let a,c;a=0;const h=Be._workPointA0,l=Be._workPointA1;t.pointAt(0,h);for(let d=1;d<r;d++,h.setFrom(l),a=c)t.pointAt(d,l),c=d*o,this.dispatchSegmentBsplineCurve(t,1===d&&e,h,a,l,c,d+1===r&&e,i,s,n)}}computeSegmentLineString(t,e,i,s,n){const r=t.point0Ref,o=t.point1Ref,a=Be._workPointBB0,c=Be._workPointBB1,h=i.numPoints();if(h>1){const l=1/(h-1);let d,u;d=0,i.pointAt(0,a);for(let f=1;f<h;f++,a.setFrom(c),d=u)i.pointAt(f,c),u=f*l,this.dispatchSegmentSegment(t,e,r,0,o,1,e,i,1===f&&s,a,d,c,u,f+1===h&&s,n)}}computeArcLineString(t,e,i,s,n){const r=Be._workPointBB0,o=Be._workPointBB1,a=i.numPoints();if(a>1){const c=1/(a-1);let h,l;h=0,i.pointAt(0,r);for(let d=1;d<a;d++,r.setFrom(o),h=l)i.pointAt(d,o),l=d*c,this.dispatchSegmentArc(i,1===d&&s,r,h,o,l,d+1===a&&s,t,e,e,!n)}}static setTransformedWorkPoints(t,e,i,s,n){t.multiplyPoint3d(e,this._workPointA0),t.multiplyPoint3d(i,this._workPointA1),t.multiplyPoint3d(s,this._workPointB0),t.multiplyPoint3d(n,this._workPointB1)}handleLineSegment3d(t){if(this._geometryB instanceof tr){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof ye?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof Pe?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof cr&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof ye){const e=this._geometryB,i=Be._workPointAA0,s=Be._workPointAA1,n=Be._workPointBB0,r=Be._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,i);const c=1/(o-1),h=1/(a-1);let l,d,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,i);for(let m=1;m<o;m++,i.setFrom(s),f=d){d=m*c,l=0,t.pointAt(m,s),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(r),l=u)e.pointAt(c,r),u=c*h,this.dispatchSegmentSegment(t,1===m&&g,i,f,s,d,m+1===o&&g,e,1===c&&p,n,l,r,u,c+1===a&&p,!1)}}}else this._geometryB instanceof tr?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Pe?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof cr&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof tr?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof ye?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof Pe?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof cr&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof tr?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof ye?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Pe?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof ar&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}Be._workVector2dA=G.create(),Be._workPointA0H=bt.create(),Be._workPointA1H=bt.create(),Be._workPointB0H=bt.create(),Be._workPointB1H=bt.create(),Be._workPointAA0=K.create(),Be._workPointAA1=K.create(),Be._workPointBB0=K.create(),Be._workPointBB1=K.create(),Be._workPointA0=K.create(),Be._workPointA1=K.create(),Be._workPointB0=K.create(),Be._workPointB1=K.create();class Ve extends fe{reinitialize(){this._results=new Oe}constructor(t,e,i,s){super(),this._extendA=e,this._geometryB=i,this._extendB=s,this.reinitialize()}grabResults(t=!1){const e=this._results;return t&&this.reinitialize(),e}acceptFraction(t,e,i){return!(!t&&e<0||!i&&e>1)}recordPointWithLocalFractions(t,e,i,s,n,r,o,a,c){const h=J.interpolate(i,t,s),l=J.interpolate(o,n,a),d=this._results.dataA.length;if(d>0){const t=this._results.dataA[d-1].fraction,e=this._results.dataB[d-1].fraction;if(c){if(J.isAlmostEqualNumber(t,l)&&J.isAlmostEqualNumber(e,h))return}else if(J.isAlmostEqualNumber(t,h)&&J.isAlmostEqualNumber(e,l))return}const u=e.fractionToPoint(h),f=r.fractionToPoint(l);if(!u.isAlmostEqualMetric(f))return;const g=yt.createCurveFractionPoint(e,h,u);g.setIntervalRole(P.isolated);const p=yt.createCurveFractionPoint(r,l,f);p.setIntervalRole(P.isolated),c?(this._results.dataA.push(p),this._results.dataB.push(g)):(this._results.dataA.push(g),this._results.dataB.push(p))}computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){const p=Ve._workVector2dA;Ct.lineSegment3dClosestApproachUnbounded(i,n,h,d,p)&&this.acceptFraction(e,p.x,o)&&this.acceptFraction(c,p.y,f)&&this.recordPointWithLocalFractions(p.x,t,s,r,p.y,a,l,u,g)}dispatchSegmentSegment(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g){this.computeSegmentSegment3D(t,e,i,s,n,r,o,a,c,h,l,d,u,f,g)}createPlaneWithPreferredPerpendicular(t,e,i,s,n){i=J.restrictToInterval(Math.abs(i),0,1-J.smallFraction);const r=e.magnitudeSquared(),o=s.magnitudeSquared(),a=Math.abs(e.dotProduct(s)),c=e.unitCrossProduct(a*a<=i*i*r*o?s:n);if(c)return mt.create(t,c)}dispatchSegmentArc(t,e,i,s,n,r,o,a,c,h,l){const d=j.createStartEnd(i,n),u=this.createPlaneWithPreferredPerpendicular(i,d,.94,a.perpendicularVector,a.vector0);if(void 0!==u){const d=[];let f,g;a.appendPlaneIntersectionPoints(u,d);for(const u of d)this.acceptFraction(c,u.fraction,h)&&(f=Ct.lineSegment3dClosestPointUnbounded(i,n,u.point),void 0!==f&&(g=i.interpolate(f,n,g),g.isAlmostEqualMetric(u.point)&&this.acceptFraction(e,f,o)&&this.recordPointWithLocalFractions(f,t,s,r,u.fraction,a,0,1,l)))}}dispatchArcArcInPlane(t,e,i,s,n){const r=t.otherArcAsLocalVectors(i);if(void 0!==r){const o=[],a=[];wt.solveUnitCircleHomogeneousEllipseIntersection(r.center.x,r.center.y,1,r.vector0.x,r.vector0.y,0,r.vector90.x,r.vector90.y,0,o,a);for(let r=0;r<o.length;r++){const c=t.sweep.radiansToSignedPeriodicFraction(a[r]),h=t.sweep.radiansToSignedPeriodicFraction(o[r]);this.acceptFraction(e,c,e)&&this.acceptFraction(s,h,s)&&this.recordPointWithLocalFractions(c,t,0,1,h,i,0,1,n)}}}dispatchArcArc(t,e,i,s,n){const r=mt.create(t.center,t.perpendicularVector),o=mt.create(i.center,i.perpendicularVector);if(void 0!==r&&void 0!==o)if(r.getNormalRef().isParallelTo(o.getNormalRef()))r.isPointInPlane(o.getOriginRef())&&o.isPointInPlane(r.getOriginRef())&&this.dispatchArcArcInPlane(t,e,i,s,n);else{const a=[];i.appendPlaneIntersectionPoints(r,a);const c=[];t.appendPlaneIntersectionPoints(o,c);for(const r of a)for(const o of c)o.point.isAlmostEqual(r.point)&&this.acceptFraction(e,o.fraction,e)&&this.acceptFraction(s,r.fraction,s)&&this.recordPointWithLocalFractions(o.fraction,t,0,1,r.fraction,i,0,1,n)}}dispatchArcBsplineCurve3d(t,e,i,s,n){}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){}dispatchSegmentBsplineCurve(t,e,i,s,n,r,o,a,c,h){}dispatchLineStringBSplineCurve(t,e,i,s,n){}computeSegmentLineString(t,e,i,s,n){const r=t.point0Ref,o=t.point1Ref,a=Ve._workPointBB0,c=Ve._workPointBB1,h=i.numPoints();if(h>1){const l=1/(h-1);let d,u;d=0,i.pointAt(0,a);for(let f=1;f<h;f++,a.setFrom(c),d=u)i.pointAt(f,c),u=f*l,this.dispatchSegmentSegment(t,e,r,0,o,1,e,i,1===f&&s,a,d,c,u,f+1===h&&s,n)}}computeArcLineString(t,e,i,s,n){const r=Ve._workPointBB0,o=Ve._workPointBB1,a=i.numPoints();if(a>1){const c=1/(a-1);let h,l;h=0,i.pointAt(0,r);for(let d=1;d<a;d++,r.setFrom(o),h=l)i.pointAt(d,o),l=d*c,this.dispatchSegmentArc(i,1===d&&s,r,h,o,l,d+1===a&&s,t,e,e,!n)}}handleLineSegment3d(t){if(this._geometryB instanceof tr){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,e,this._extendB,e.point0Ref,0,e.point1Ref,1,this._extendB,!1)}else this._geometryB instanceof ye?this.computeSegmentLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof Pe?this.dispatchSegmentArc(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,this._extendB,!1):this._geometryB instanceof cr&&this.dispatchSegmentBsplineCurve(t,this._extendA,t.point0Ref,0,t.point1Ref,1,this._extendA,this._geometryB,this._extendB,!1)}handleLineString3d(t){if(this._geometryB instanceof ye){const e=this._geometryB,i=Ve._workPointAA0,s=Ve._workPointAA1,n=Ve._workPointBB0,r=Ve._workPointBB1,o=t.numPoints(),a=e.numPoints();if(o>1&&a>1){t.pointAt(0,i);const c=1/(o-1),h=1/(a-1);let l,d,u,f=0;const g=this._extendA,p=this._extendB;t.pointAt(0,i);for(let m=1;m<o;m++,i.setFrom(s),f=d){d=m*c,l=0,t.pointAt(m,s),e.pointAt(0,n);for(let c=1;c<a;c++,n.setFrom(r),l=u)e.pointAt(c,r),u=c*h,this.dispatchSegmentSegment(t,1===m&&g,i,f,s,d,m+1===o&&g,e,1===c&&p,n,l,r,u,c+1===a&&p,!1)}}}else this._geometryB instanceof tr?this.computeSegmentLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Pe?this.computeArcLineString(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof cr&&this.dispatchLineStringBSplineCurve(t,this._extendA,this._geometryB,this._extendB,!1)}handleArc3d(t){this._geometryB instanceof tr?this.dispatchSegmentArc(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,this._extendA,!0):this._geometryB instanceof ye?this.computeArcLineString(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof Pe?this.dispatchArcArc(t,this._extendA,this._geometryB,this._extendB,!1):this._geometryB instanceof cr&&this.dispatchArcBsplineCurve3d(t,this._extendA,this._geometryB,this._extendB,!1)}handleBSplineCurve3d(t){this._geometryB instanceof tr?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB,t,this._extendA,!0):this._geometryB instanceof ye?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof Pe?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB,t,this._extendA,!0):this._geometryB instanceof ar&&this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1)}handleBSplineCurve3dH(t){}}Ve._workVector2dA=G.create(),Ve._workPointAA0=K.create(),Ve._workPointAA1=K.create(),Ve._workPointBB0=K.create(),Ve._workPointBB1=K.create();class Le{static intersectionXYPairs(t,e,i,s,n=J.smallMetricDistance){const r=new Be(void 0,t,e,i,s,n);if(i instanceof $t)t.dispatchToGeometryHandler(r);else if(i instanceof Me){const e=i.collectCurvePrimitives();for(const i of e)r.resetGeometry(t,!1,i,!1),t.dispatchToGeometryHandler(r)}return r.grabPairedResults()}static intersectionProjectedXYPairs(t,e,i,s,n,r=J.smallMetricDistance){const o=new Be(t,e,i,s,n,r);return e.dispatchToGeometryHandler(o),o.grabPairedResults()}static intersectionXYZ(t,e,i,s){const n=new Ve(t,e,i,s);return t.dispatchToGeometryHandler(n),n.grabResults()}static allIntersectionsAmongPrimitivesXY(t,e=J.smallMetricDistance){const i=new Be(void 0,void 0,!1,void 0,!1,e);for(let e=0;e<t.length;e++){const s=t[e];for(let n=e+1;n<t.length;n++)i.resetGeometry(s,!1,t[n],!1),s.dispatchToGeometryHandler(i)}return i.grabPairedResults()}static closeApproachProjectedXYPairs(t,e,i){const s=new Re(t,e);return s.maxDistanceToAccept=i,t.dispatchToGeometryHandler(s),s.grabPairedResults()}}class Ue extends be{isSameGeometryClass(t){return t instanceof Ue}constructor(){super(),this.curveCollectionType="loop",this.isInner=!1}static create(...t){const e=new Ue;for(const i of t)e.children.push(i);return e}static createArray(t){const e=new Ue;for(const i of t)e.children.push(i);return e}static createPolygon(t){const e=ye.create(t);return e.addClosurePoint(),Ue.create(e)}cloneStroked(t){const e=ye.create();for(const i of this.children)i.emitStrokes(e,t);return e.removeDuplicatePoints(),e.isPhysicallyClosed&&(e.popPoint(),e.addClosurePoint()),Ue.create(e)}dgnBoundaryType(){return 2}announceToCurveProcessor(t,e=-1){return t.announceLoop(this,e)}cloneEmptyPeer(){return new Ue}dispatchToGeometryHandler(t){return t.handleLoop(this)}}class Ze{constructor(t,e,i,s){this.loopA=t,this.curveA=e,this.loopB=i,this.curveB=s}setA(t,e){this.loopA=t,this.curveA=e}setB(t,e){this.loopB=t,this.curveB=e}}class qe extends be{isSameGeometryClass(t){return t instanceof qe}announceToCurveProcessor(t,e=-1){return t.announcePath(this,e)}constructor(){super(),this.curveCollectionType="path"}static create(...t){const e=new qe;for(const i of t)i instanceof $t?e.children.push(i):Array.isArray(i)&&i.length>0&&i[0]instanceof K&&e.children.push(ye.create(i));return e}static createArray(t){const e=new qe;for(const i of t)e.children.push(i);return e}cloneStroked(t){const e=ye.create();for(const i of this.children)i.emitStrokes(e,t);return qe.create(e)}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new qe}dispatchToGeometryHandler(t){return t.handlePath(this)}}class We{constructor(t,e,i){this._toleranceSquared=i*i,this._source=t,this._dest=e}acceptPointByIndex(t){const e=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(t));e&&this._dest.push(e)}indexOfMaxCrossProduct(t,e){let i,s,n=0;for(let r=t;r<=e;r++){const t=this._source.cyclicIndex(r),e=this._source.cyclicIndex(r+1),o=this._source.cyclicIndex(r+2);this._source.crossProductIndexIndexIndex(t,e,o,We._vectorQ),i=We._vectorQ.magnitudeSquared(),i>n&&(n=i,s=r)}return s}indexOfMaxDeviation(t,e){const i=this._source.cyclicIndex(t),s=this._source.cyclicIndex(e);let n,r,o,a,c,h=this._toleranceSquared;this._source.vectorIndexIndex(i,s,We._vector01);const l=We._vector01.magnitudeSquared();for(let d=t+1;d<e;d++)c=this._source.cyclicIndex(d),this._source.vectorIndexIndex(i,c,We._vectorQ),r=We._vector01.dotProduct(We._vectorQ),r<=0?o=We._vectorQ.magnitudeSquared():r>l?(this._source.vectorIndexIndex(s,c,We._vectorQ),o=We._vectorQ.magnitudeSquared()):(a=r/l,o=We._vectorQ.magnitudeSquared()-l*a*a),o>h&&(h=o,n=d);return n}recursiveCompressByChordErrorGo(t,e){if(e===t+1)return void this.acceptPointByIndex(e);const i=this.indexOfMaxDeviation(t,e);void 0===i?this.acceptPointByIndex(e):(this.recursiveCompressByChordErrorGo(t,i),this.recursiveCompressByChordErrorGo(i,e))}static compressPoint3dArrayByChordError(t,e){const i=new te(t),s=new te([]);return this.compressCollectionByChordError(i,s,e),s.data}static compressCollectionByChordError(t,e,i){e.clear();const s=t.length;if(1===s)return void e.push(t.getPoint3dAtCheckedPointIndex(0));const n=new We(t,e,i);let r=0,o=s-1;if(s>2&&t.distanceIndexIndex(0,s-1)<=i){const t=n.indexOfMaxCrossProduct(0,s-1);void 0!==t&&(r=t+1,o=r+s)}n.acceptPointByIndex(r),n.recursiveCompressByChordErrorGo(r,o)}static compressInPlaceByShortEdgeLength(t,e){const i=t.length;if(i<2)return;let s=0,n=i-1;for(;n>0&&t.distanceIndexIndex(n-1,i-1)<e;)n--;if(0===n)return void(t.length=1);n<i-1&&t.moveIndexToIndex(i-1,n);let r=s+1;for(;r<=n;)t.distanceIndexIndex(s,r)>=e&&(t.moveIndexToIndex(r,s+1),s++),r++;t.length=s+1}static compressInPlaceBySmallTriangleArea(t,e){const i=t.length;if(i<3)return;let s=0;const n=j.create();for(let r=1;r+1<i;r++)t.crossProductIndexIndexIndex(s,r,r+1,n),.5*n.magnitude()>e&&t.moveIndexToIndex(r,++s);t.moveIndexToIndex(i-1,++s),t.length=s+1}static compressInPlaceByPerpendicularDistance(t,e,i=1.0001){const s=t.length;if(s<3)return;let n=0;const r=We._vector01,o=We._vectorQ;let a;const c=e*e;let h,l=1;for(;l+1<s;l++){t.vectorIndexIndex(n,l+1,r),t.vectorIndexIndex(n,l,o),h=r.magnitudeSquared();const e=J.conditionalDivideFraction(o.dotProduct(r),h);void 0!==e&&e>=0&&e<=i&&(a=We._vectorQ.magnitudeSquared()-h*e*e,a<=c)?(t.moveIndexToIndex(l+1,++n),l+=1):t.moveIndexToIndex(l,++n)}l<s&&t.moveIndexToIndex(l,++n),t.length=n+1}static compressColinearWrapInPlace(t,e){const i=t.length-1;if(i>=3&&t[0].distance(t[i])<e){const s=i-1,n=0,r=1,o=j.createStartEnd(t[s],t[r]),a=j.createStartEnd(t[s],t[n]),c=o.dotProduct(o),h=o.dotProduct(a),l=J.conditionalDivideFraction(h,c);if(void 0!==l&&l>0&&l<1){const i=a.magnitudeSquared()-l*l*c;Math.sqrt(Math.abs(i))<e&&(t[0]=t[s],t.pop())}}}}We._vector01=j.create(),We._vectorQ=j.create();class Ge extends Me{isSameGeometryClass(t){return t instanceof Ge}get children(){return this._children}constructor(){super(),this.curveCollectionType="parityRegion",this._children=[]}addLoops(t){if(void 0===t);else if(t instanceof Ue)this.children.push(t);else if(Array.isArray(t))for(const e of t)e instanceof Ue?this.children.push(e):Array.isArray(e)&&this.addLoops(e)}static createLoops(t){if(t instanceof Ue)return t;const e=new Ge;return e.addLoops(t),e}static create(...t){const e=new Ge;for(const i of t)e.children.push(i);return e}dgnBoundaryType(){return 4}announceToCurveProcessor(t,e=-1){return t.announceParityRegion(this,e)}clone(){const t=new Ge;let e;for(e of this.children){const i=e.clone();i instanceof Ue&&t.children.push(i)}return t}cloneStroked(t){const e=new Ge;let i;for(i of this.children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Ge}tryAddChild(t){return!!(t&&t instanceof Ue)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleParityRegion(this)}}class Je extends Me{isSameGeometryClass(t){return t instanceof Je}get children(){return this._children}constructor(){super(),this.curveCollectionType="unionRegion",this._children=[]}static create(...t){const e=new Je;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 5}announceToCurveProcessor(t,e=-1){return t.announceUnionRegion(this,e)}cloneStroked(t){const e=new Je;let i;for(i of this._children){const s=i.cloneStroked(t);s&&e.children.push(s)}return e}cloneEmptyPeer(){return new Je}tryAddChild(t){return!!(t&&t instanceof Ge||t instanceof Ue)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleUnionRegion(this)}}class He{}class Ke extends He{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t,this._signedArea=fr.areaXY(t)}classifyPointXY(t){return fr.classifyPointInPolygonXY(t.x,t.y,this.data)}getAnyInteriorPoint(){for(let t=0;t<this.data.length;t++){const e=this.constructInteriorPointNearEdge(t,.2349);if(void 0!==e)return e}}grabPolygon(){return this.data}grabLoop(){return Ue.createPolygon(this.data)}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(t,e){if(t+1<this.data.length){const i=this.data.getPoint3dAtUncheckedPointIndex(t),s=this.data.getPoint3dAtUncheckedPointIndex(t+1),n=i.vectorTo(s),r=i.interpolate(e,s);if(n.rotate90CCWXY(n),n.normalizeInPlace()){this._signedArea<0&&n.scaleInPlace(-1);const t=Math.sqrt(Math.abs(this._signedArea));for(let e=1e-5;e<3;e*=5){const i=r.plusScaled(n,e*t);if(1===this.classifyPointXY(i))return i}}}}}class je extends He{get signedArea(){return this._signedArea}constructor(t){super(),this.data=t;const e=Gn.computeXYAreaMoments(t);this._signedArea=void 0!==e?e.quantitySum:0}classifyPointXY(t){return Gn.testPointInOnOutRegionXY(this.data,t.x,t.y)}constructInteriorPointNearChild(t,e){if(t<this.data.children.length){const i=this.data.children[t].fractionToPointAndUnitTangent(e);i.direction.rotate90CCWXY(i.direction),this._signedArea<0&&i.direction.scaleInPlace(-1);const s=Math.sqrt(Math.abs(this._signedArea));for(let t=1e-5;t<3;t*=5){const e=i.fractionToPoint(t*s);if(1===this.classifyPointXY(e))return e}}}getAnyInteriorPoint(){for(let t=0;t<this.data.children.length;t++){const e=this.constructInteriorPointNearChild(t,.2349);if(void 0!==e)return e}}grabPolygon(){const t=this.data.cloneStroked();if(t instanceof be){const e=ye.create();for(const i of t.children)i instanceof $t&&i.emitStrokes(e);return e.numPoints()>0?e.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class Qe{constructor(t,e){this._loopCarrier=t instanceof et?new Ke(t):new je(t),this.range=e,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(t,e){const i=e.getRange(),s=new Qe(e,i);return s.sortKey>0&&(t.push(s),!0)}static pushLoop(t,e){const i=e.range(),s=new Qe(e,i);return s.sortKey>0&&(t.push(s),!0)}static assignParentsAndDepth(t){t.sort(((t,e)=>e.sortKey-t.sortKey));for(let e=t.length;e-- >0;){const i=t[e],s=i._loopCarrier.getAnyInteriorPoint();if(void 0!==s){t[e].parentIndex=void 0,t[e].outputSetIndex=void 0;for(let n=e;n-- >0;){const e=t[n];if(e.range.containsXY(s.x,s.y)&&1===e._loopCarrier.classifyPointXY(s)){i.parentIndex=n;break}}}}}static assemblePolygonSet(t){const e=[];for(const i of t){i.isHole=!1;const s=i.parentIndex;void 0!==s&&(i.isHole=!t[s].isHole),i.isHole?(i._loopCarrier.reverseForAreaSign(-1),e[t[s].outputSetIndex].push(i._loopCarrier.grabPolygon())):(i._loopCarrier.reverseForAreaSign(1),i.outputSetIndex=e.length,e.push([]),e[i.outputSetIndex].push(i._loopCarrier.grabPolygon()))}return e}static assembleLoopSet(t){const e=[],i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.parentIndex;if(n.isHole=void 0!==r&&!t[r].isHole,!n.isHole){n._loopCarrier.reverseForAreaSign(1);const r=n._loopCarrier.grabLoop();let o;for(let e=s+1;e<i;e++){const i=t[e];i.parentIndex===s&&(void 0===o?(o=Ge.create(),o.tryAddChild(r),i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())):(i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())))}void 0!==o?e.push(o):void 0!==r&&e.push(r)}}return e}static sortAsAnyRegion(t){this.assignParentsAndDepth(t);const e=this.assembleLoopSet(t);if(1===e.length)return e[0];{const t=Je.create();for(const i of e)t.tryAddChild(i);return t}}static sortAsArrayOfArrayOfPolygons(t){return this.assignParentsAndDepth(t),this.assemblePolygonSet(t)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(t){this._loopCarrier.reverseForAreaSign(t)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class $e{get quantitySum(){return this.sums.atIJ(3,3)}signFactor(t){return t*this.quantitySum>0?1:-1}setOriginIfNeeded(t){this.needOrigin&&(this.origin.setFromPoint3d(t),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(t){this.needOrigin&&t.length>0&&(t.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(t,e,i){this.needOrigin&&(this.origin.set(t,e,i),this.needOrigin=!1)}constructor(){this._point0=K.create(),this._point1=K.create(),this.origin=K.createZero(),this.sums=Et.createZero(),this.localToWorldMap=ft.createIdentity(),this.radiusOfGyration=j.create(),this.needOrigin=!1,this.absoluteQuantity=.1,this.absoluteQuantity=void 0}static create(t,e=!1){const i=new $e;return i.needOrigin=e,t&&(i.origin.setFromPoint3d(t),i.needOrigin=!1),i}static momentTensorFromInertiaProducts(t){const e=t.sumDiagonal(),i=pt.createScale(e,e,e);return i.addScaledInPlace(t,-1),i}static sortColumnsForIncreasingMoments(t,e){const i=[t.indexedColumnWithWeight(0,e.x),t.indexedColumnWithWeight(1,e.y),t.indexedColumnWithWeight(2,e.z)].sort(((t,e)=>t.w<e.w?-1:t.w>e.w?1:0));t.setColumnsPoint4dXYZ(i[0],i[1],i[2]),t.determinant()<0&&t.scaleColumnsInPlace(-1,-1,-1),t.at(0,0)<0&&t.scaleColumnsInPlace(-1,-1,1),t.at(2,2)<0&&t.scaleColumnsInPlace(1,-1,-1),e.set(i[0].w,i[1].w,i[2].w)}static pointsToPrincipalAxes(t){const e=new $e;return 0===t.length?e:(e.clearSums(t[0]),e.accumulatePointMomentsFromOrigin(t),this.inertiaProductsToPrincipalAxes(e.origin,e.sums))}static inertiaProductsToPrincipalAxes(t,e){const i=new $e;if(i.sums.setFrom(e),i.origin.setFrom(t),!i.shiftOriginAndSumsToCentroidOfSums())return;const s=i.sums.matrixPart(),n=i.sums.weight();n<0&&s.scaleColumnsInPlace(-1,-1,-1);const r=$e.momentTensorFromInertiaProducts(s),o=j.create(),a=pt.createZero();return r.fastSymmetricEigenvalues(a,o),o.x<0?void 0:($e.sortColumnsForIncreasingMoments(a,o),n<0&&a.scaleColumnsInPlace(1,-1,-1),i.localToWorldMap=ft.createOriginAndMatrix(i.origin,a),i.radiusOfGyration.set(Math.sqrt(Math.abs(o.x)),Math.sqrt(Math.abs(o.y)),Math.sqrt(Math.abs(o.z))),i.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(n))),i.absoluteQuantity=Math.abs(n),i)}static areEquivalentPrincipalAxes(t,e){if(t&&e&&J.isSameCoordinate(t.quantitySum,e.quantitySum)&&t.localToWorldMap.getOrigin().isAlmostEqual(e.localToWorldMap.getOrigin())&&t.radiusOfGyration.isAlmostEqual(e.radiusOfGyration)){if(J.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.y)){if(J.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.z))return!0;const i=t.localToWorldMap.matrix.columnZ(),s=e.localToWorldMap.matrix.columnZ();return!!i.isParallelTo(s,!0)}const i=j.create(),s=j.create();for(let n=0;n<3;n++)if(t.localToWorldMap.matrix.getColumn(n,i),e.localToWorldMap.matrix.getColumn(n,s),!i.isParallelTo(s,!0))return!1;return!0}return!1}clearSums(t){this.sums.setZero(),t?this.origin.setFrom(t):this.origin.setZero()}accumulatePointMomentsFromOrigin(t){for(const e of t)this.sums.addMomentsInPlace(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const t=this.sums.columnW().realPoint();return!!t&&(this.shiftOriginAndSumsByXYZ(t.x,t.y,t.z),!0)}shiftOriginAndSumsByXYZ(t,e,i){this.origin.addXYZInPlace(t,e,i),this.sums.multiplyTranslationSandwichInPlace(-t,-e,-i)}shiftOriginAndSumsToNewOrigin(t){this.shiftOriginAndSumsByXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z)}accumulateTriangleMomentsXY(t,e,i){this.setOriginXYZIfNeeded(e.x,e.y,0);const s=this.origin.x,n=this.origin.y,r=$e._vectorA=void 0!==t?bt.create(t.x-s,t.y-n,0,1,$e._vectorA):bt.create(this.origin.x,this.origin.y,0,1,$e._vectorA),o=$e._vectorB=bt.create(e.x-s,e.y-n,0,1,$e._vectorB),a=$e._vectorC=bt.create(i.x-s,i.y-n,0,1,$e._vectorC),c=J.crossProductXYXY(o.x-r.x,o.y-r.y,a.x-r.x,a.y-r.y);if(0!==c){const t=c/12,e=c/24;this.sums.addScaledOuterProductInPlace(r,r,t),this.sums.addScaledOuterProductInPlace(r,o,e),this.sums.addScaledOuterProductInPlace(r,a,e),this.sums.addScaledOuterProductInPlace(o,r,e),this.sums.addScaledOuterProductInPlace(o,o,t),this.sums.addScaledOuterProductInPlace(o,a,e),this.sums.addScaledOuterProductInPlace(a,r,e),this.sums.addScaledOuterProductInPlace(a,o,e),this.sums.addScaledOuterProductInPlace(a,a,t)}}accumulateScaledOuterProduct(t,e){this.setOriginXYZIfNeeded(t.x,t.y,0);const i=$e._vectorA=bt.create(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,1,$e._vectorA);this.sums.addScaledOuterProductInPlace(i,i,e)}accumulateLineMomentsXYZ(t,e){this.setOriginXYZIfNeeded(t.x,t.y,t.z);const i=this.origin.x,s=this.origin.y,n=this.origin.z,r=$e._vectorA=bt.create(t.x-i,t.y-s,t.z-n,1,$e._vectorA),o=$e._vectorB=bt.create(e.x-i,e.y-s,e.z-n,1,$e._vectorB),a=t.distance(e),c=a/3,h=a/6;this.sums.addScaledOuterProductInPlace(r,r,c),this.sums.addScaledOuterProductInPlace(r,o,h),this.sums.addScaledOuterProductInPlace(o,r,h),this.sums.addScaledOuterProductInPlace(o,o,c)}accumulateTriangleToLineStringMomentsXY(t,e){const i=e.length;if(i>1){e.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let s=1;s<i;s++)e.getPoint3dAtUncheckedPointIndex(s,this._point1),this.accumulateTriangleMomentsXY(t,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(t,e,i,s,n,r,o){const a=Et.createRowValues(t,e,0,0,e,i,0,0,0,0,0,0,0,0,0,s),c=J.crossProductXYXY(r.x,o.x,r.y,o.y),h=Et.createRowValues(r.x,o.x,0,n.x-this.origin.x,r.y,o.y,0,n.y-this.origin.y,0,0,0,0,0,0,0,1),l=h.multiplyMatrixMatrix(a).multiplyMatrixMatrixTranspose(h);this.sums.addScaledInPlace(l,c)}accumulateProducts(t,e){this.setOriginIfNeeded(t.origin),this.sums.addTranslationSandwichInPlace(t.sums,this.origin.x-t.origin.x,this.origin.y-t.origin.y,this.origin.z-t.origin.z,e)}accumulateProductsFromOrigin(t,e,i){this.setOriginIfNeeded(t),this.sums.addTranslationSandwichInPlace(e,this.origin.x-t.x,this.origin.y-t.y,this.origin.z-t.z,i)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class ti extends fe{constructor(t,e,i){super(),this._geometry1=i,this._fraction=e}handleLineSegment3d(t){if(this._geometry1 instanceof tr){const e=this._geometry1;return tr.create(t.startPoint().interpolate(this._fraction,e.startPoint()),t.endPoint().interpolate(this._fraction,e.endPoint()))}}handleLineString3d(t){if(this._geometry1 instanceof ye){const e=this._geometry1;if(t.numPoints()===e.numPoints()){const i=t.numPoints(),s=ye.create(),n=K.create(),r=K.create(),o=K.create(),a=this._fraction;for(let c=0;c<i;c++)t.pointAt(c,r),e.pointAt(c,o),r.interpolate(a,o,n),s.addPoint(n);if(t.fractions&&e.fractions)for(let n=0;n<i;n++)s.addFraction(J.interpolate(t.fractions.atUncheckedIndex(n),a,e.fractions.atUncheckedIndex(n)));if(t.strokeData&&e.strokeData&&(s.strokeData=t.strokeData.clone()),t.packedDerivatives&&e.packedDerivatives){const n=j.create(),r=j.create();for(let o=0;o<i;o++)t.packedDerivatives.getVector3dAtCheckedVectorIndex(o,n),e.packedDerivatives.getVector3dAtCheckedVectorIndex(o,r),s.addDerivative(n.interpolate(a,r))}return s}}}handleArc3d(t){if(this._geometry1 instanceof Pe){const e=this._geometry1;return Pe.create(t.center.interpolate(this._fraction,e.center),t.vector0.interpolate(this._fraction,e.vector0),t.vector90.interpolate(this._fraction,e.vector90),t.sweep.interpolate(this._fraction,e.sweep))}}static interpolateBetween(t,e,i){const s=new ti(t,e,i);return t.dispatchToGeometryHandler(s)}}class ei extends Rt{constructor(t){super(),this.geometryCategory="solid",this._capped=t}get capped(){return this._capped}set capped(t){this._capped=t}}class ii extends ei{constructor(t,e,i,s){super(s),this.solidPrimitiveType="cone",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new ii(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return t.multiplyTransformTransform(e._localToWorld,e._localToWorld),e}static createAxisPoints(t,e,i,s,n){const r=t.vectorTo(e),o=r.magnitude();if(J.isSmallMetricDistance(o))return;if((i=J.correctSmallMetricDistance(i))*(s=J.correctSmallMetricDistance(s))<0)return;if(i+s===0)return;const a=pt.createRigidHeadsUp(r);a.scaleColumns(1,1,o,a);const c=ft.createOriginAndMatrix(t,a);return new ii(c,i,s,n)}static createBaseAndTarget(t,e,i,s,n,r,o){n=Math.abs(J.correctSmallMetricDistance(n)),r=Math.abs(J.correctSmallMetricDistance(r));const a=t.vectorTo(e),c=ft.createOriginAndMatrixColumns(t,i,s,a);return new ii(c,n,r,o)}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(t){return J.interpolate(this._radiusA,t,this._radiusB)}isSameGeometryClass(t){return t instanceof ii}isAlmostEqual(t){return t instanceof ii&&this.capped===t.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(t._localToWorld)&&J.isSameCoordinate(this._radiusA,t._radiusA)&&J.isSameCoordinate(this._radiusB,t._radiusB)}dispatchToGeometryHandler(t){return t.handleCone(this)}strokeConstantVSection(t,e,i){let s=16;void 0!==e?s=e:void 0!==i&&(s=i.defaultCircleStrokes),s=J.clampToStartEnd(s,4,64);const n=this.vFractionToRadius(t),r=ye.createForStrokes(e,i),o=2*Math.PI,a=o/s;let c=0;const h=r.fractions,l=r.packedDerivatives,d=r.packedUVParams,u=r.packedSurfaceNormals,f=K.create(),g=j.create(),p=j.create(),m=j.create(),x=this._localToWorld;let y,_,v,P;for(let e=0;e<=s;e++)c=2*e<=s?e*a:(e-s)*a,v=Math.cos(c),P=Math.sin(c),y=n*v,_=n*P,x.multiplyXYZ(y,_,t,f),r.addPoint(f),h&&h.push(e/s),l&&(x.matrix.multiplyXYZ(-_*o,y*o,0,g),l.push(g)),u&&(x.matrix.multiplyXYZ(-P,v,0,g),x.matrix.multiplyXYZ(0,0,1,p),g.unitCrossProduct(p,m),u.push(m)),d&&d.pushXY(e/s,t);return r}constantVSection(t){const e=this.vFractionToRadius(t),i=this._localToWorld,s=i.multiplyXYZ(0,0,t),n=i.matrix.multiplyXYZ(e,0,0),r=i.matrix.multiplyXYZ(0,e,0);return Ue.create(Pe.create(s,n,r))}extendRange(t,e){const i=this.constantVSection(0),s=this.constantVSection(1);i.extendRange(t,e),s.extendRange(t,e)}uvFractionToPoint(t,e,i){const s=t*Math.PI*2,n=J.interpolate(this._radiusA,e,this._radiusB),r=Math.cos(s),o=Math.sin(s);return this._localToWorld.multiplyXYZ(n*r,n*o,e,i)}uvFractionToPointAndTangents(t,e,i){const s=t*Math.PI*2,n=J.interpolate(this._radiusA,e,this._radiusB),r=this._radiusB-this._radiusA,o=Math.cos(s),a=Math.sin(s),c=2*Math.PI;return Ft.createOriginAndVectors(this._localToWorld.multiplyXYZ(n*o,n*a,e),this._localToWorld.multiplyVectorXYZ(-n*a*c,n*o*c,0),this._localToWorld.multiplyVectorXYZ(r*o,r*a,1),i)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnX(),e=this._localToWorld.matrix.columnY(),i=this._localToWorld.matrix.columnZ(),s=t.unitCrossProduct(e),n=s.dotProduct(i),r=i.plusScaled(s,n).magnitudeXY();return G.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),J.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+r,n))}}class si extends ei{constructor(t,e,i,s,n){super(n),this.solidPrimitiveType="torusPipe",this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._sweep=s,this._isReversed=!1}clone(){const t=new si(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return t._isReversed=this._isReversed,t}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}static createInFrame(t,e,i,s,n){if((e=Math.abs(J.correctSmallMetricDistance(e)))<(i=Math.abs(J.correctSmallMetricDistance(i))))return;if(0===e)return;if(0===i)return;if(s.isAlmostZero)return;let r=1,o=1,a=!1;t.matrix.determinant()<0&&(o*=-1);const c=s.clone();s.radians<0&&(c.setRadians(-s.radians),o*=-1,r*=-1,a=!0);const h=t.clone();h.matrix.scaleColumnsInPlace(1,r,o);const l=new si(h,e,i,c,n);return l._isReversed=a,l}static createDgnTorusPipe(t,e,i,s,n,r,o){const a=e.unitCrossProductWithDefault(i,0,0,1),c=ft.createOriginAndMatrixColumns(t,e,i,a);return si.createInFrame(c,s,n,r,o)}static createAlongArc(t,e,i){Z.isAlmostEqualRadiansAllowPeriodShift(0,t.sweep.startRadians)||(t=t.cloneInRotatedBasis(t.sweep.startAngle));const s=t.sweep.sweepRadians,n=t.toScaledMatrix3d(),r=ft.createOriginAndMatrix(n.center,n.axes);return si.createInFrame(r,n.r0,e,Z.createRadians(s),i)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const t=this._localToWorld.matrix.columnX();return t.normalizeWithDefault(1,0,0,t)}cloneVectorY(){const t=this._localToWorld.matrix.columnY();return t.normalizeWithDefault(0,1,0,t)}cloneVectorZ(){const t=this._localToWorld.matrix.columnZ();return t.normalizeWithDefault(0,0,1,t)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(t){return t instanceof si}isAlmostEqual(t){return!!(t instanceof si&&(this._sweep.isFullCircle||this.capped===t.capped)&&this.cloneCenter().isAlmostEqual(t.cloneCenter())&&this.cloneVectorX().isAlmostEqual(t.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(t.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(t.cloneVectorZ())&&J.isSameCoordinate(this.getMinorRadius(),t.getMinorRadius())&&J.isSameCoordinate(this.getMajorRadius(),t.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(t.getSweepAngle()))}vFractionToRadians(t){return this._sweep.radians*t}dispatchToGeometryHandler(t){return t.handleTorusPipe(this)}constantVSection(t){const e=this.vFractionToRadians(t),i=Math.cos(e),s=Math.sin(e),n=this._radiusA,r=this._radiusB,o=this._localToWorld.multiplyXYZ(n*i,n*s,0),a=this._localToWorld.multiplyVectorXYZ(r*i,r*s,0),c=this._localToWorld.multiplyVectorXYZ(0,0,r);return Ue.create(Pe.create(o,a,c))}constantUSection(t){const e=this._sweep.radians,i=2*t*Math.PI,s=this._radiusA,n=this._radiusB,r=this._localToWorld.matrix,o=this._localToWorld.multiplyXYZ(0,0,n*Math.sin(i)),a=s+n*Math.cos(i),c=r.multiplyXYZ(a,0,0),h=r.multiplyXYZ(0,a,0);return qe.create(Pe.create(o,c,h,vt.createStartEndRadians(0,e)))}extendRange(t,e){const i=this._sweep.radians,s=this._radiusA,n=this._radiusB,r=this._localToWorld,o=Math.ceil(i/(Math.PI/16));let a=0,c=0,h=0,l=0,d=0,u=0,f=0,g=0,p=0;const m=i/o;for(let i=0;i<=o;i++)if(l=i*m,d=Math.cos(l),u=Math.sin(l),0===i||i===o?(a=-Math.PI,c=2*Math.PI/16,h=16):(a=-.5*Math.PI,c=Math.PI/16,h=31),e)for(p=0;p<=h;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformTransformedXYZ(e,r,d*f,u*f,Math.sin(g)*n);else for(p=0;p<=h;p++)g=a+p*c,f=s+n*Math.cos(g),t.extendTransformedXYZ(r,d*f,u*f,Math.sin(g)*n)}uvFractionToPoint(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=Math.cos(s),o=Math.sin(s),a=this._radiusA,c=this._radiusB,h=a+Math.cos(n)*c;return this._localToWorld.multiplyXYZ(h*r,h*o,c*Math.sin(n),i)}uvFractionToPointAndTangents(t,e,i){const s=e*this._sweep.radians,n=t*Math.PI*2,r=this._sweep.radians,o=2*Math.PI,a=Math.cos(s),c=Math.sin(s),h=Math.sin(n),l=Math.cos(n),d=this._radiusA,u=this._radiusB,f=d+Math.cos(n)*u,g=u*h,p=u*l;return Ft.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*f,c*f,g),this._localToWorld.multiplyVectorXYZ(-a*g*o,-c*g*o,p*o),this._localToWorld.multiplyVectorXYZ(-f*c*r,f*a*r,0),i)}maxIsoParametricDistance(){const t=Math.abs(this.getMajorRadius()),e=Math.abs(this.getMinorRadius());return G.create(e*Math.PI*2,(t+e)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class ni extends $t{get activeFractionInterval(){return this._activeFractionInterval}get localToWorld(){return this._localToWorld}constructor(t,e,i,s){super(),this._spiralType=t||"unknownSpiralType",this._designProperties=s,this._localToWorld=e,this._activeFractionInterval=i||De.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(t){return 0===t?0:1/t}static curvatureToRadius(t){return Math.abs(t)<J.smallAngleRadians?0:1/t}clonePartialCurve(t,e){const i=this.clone(),s=this._activeFractionInterval.fractionToPoint(t),n=this._activeFractionInterval.fractionToPoint(e);return i._activeFractionInterval.set(s,n),i.refreshComputedProperties(),i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static averageCurvature(t){return.5*(ni.radiusToCurvature(t.x0)+ni.radiusToCurvature(t.x1))}static averageCurvatureR0R1(t,e){return.5*(ni.radiusToCurvature(t)+ni.radiusToCurvature(e))}static interpolateCurvatureR0R1(t,e,i){return J.interpolate(ni.radiusToCurvature(t),e,ni.radiusToCurvature(i))}static radiusRadiusSweepRadiansToArcLength(t,e,i){return Math.abs(i/ni.averageCurvatureR0R1(t,e))}static radiusRadiusLengthToSweepRadians(t,e,i){return ni.averageCurvatureR0R1(t,e)*i}static radius0LengthSweepRadiansToRadius1(t,e,i){return ni.curvatureToRadius(2*i/e-ni.radiusToCurvature(t))}static radius1LengthSweepRadiansToRadius0(t,e,i){return ni.curvatureToRadius(2*i/e-ni.radiusToCurvature(t))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(t){const e=t.matrix.factorRigidWithSignedScale();if(void 0!==e){const i=t.multiplyTransformTransform(this.localToWorld),s=e.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=ft.createOriginAndMatrix(i.origin,s),this.designProperties&&this.designProperties.applyScaleFactor(e.scale),e}}constructOffsetXY(t){const e=Kn.create(t),i=new de(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}extendRange(t,e){const i=this.rangeBetweenFractions(0,1,e);t.extendRange(i)}rangeBetweenFractions(t,e,i){const s=this.activeStrokes;if(void 0===s)return lt.createNull();let n=Math.ceil(s.numPoints()*Math.abs(e-t));return n=J.clamp(5,n,30),this.rangeBetweenFractionsByCount(t,e,n,i,.5)}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}class ri{constructor(){}static findEvaluator(t){return"clothoid"===t?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new oi:"bloss"===t?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new ai:"biquadratic"===t?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new ci:"sine"===t?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new hi:"cosine"===t?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new li:void 0}}class oi extends ri{constructor(){super()}fractionToCurvatureFraction(t){return t}fractionToCurvatureFractionDerivative(t){return 1}fractionToArea(t){return t*t*.5}}class ai extends ri{constructor(){super()}fractionToCurvatureFraction(t){return t*t*(3-2*t)}fractionToCurvatureFractionDerivative(t){return 6*t*(1-t)}fractionToArea(t){return t*t*t*(1-.5*t)}}class ci extends ri{constructor(){super()}integratedBasis(t){return t*t*t*(2/3)}basis(t){return 2*t*t}basisDerivative(t){return 4*t}fractionToCurvatureFraction(t){return t<=.5?this.basis(t):1-this.basis(1-t)}fractionToCurvatureFractionDerivative(t){return t<.5?this.basisDerivative(t):this.basisDerivative(1-t)}fractionToArea(t){if(t<=.5)return this.integratedBasis(t);const e=1-t;return.5-e+this.integratedBasis(e)}}class hi extends ri{constructor(){super()}fractionToCurvatureFraction(t){const e=2*Math.PI;return t-Math.sin(t*e)/e}fractionToCurvatureFractionDerivative(t){const e=2*Math.PI;return 1-Math.cos(t*e)}fractionToArea(t){const e=2*Math.PI;return.5*t*t+(Math.cos(t*e)-1)/(e*e)}}class li extends ri{constructor(){super()}fractionToCurvatureFraction(t){const e=Math.PI;return.5*(1-Math.cos(t*e))}fractionToCurvatureFractionDerivative(t){const e=Math.PI;return.5*e*Math.sin(t*e)}fractionToArea(t){const e=Math.PI;return.5*t-.5*Math.sin(t*e)/e}}class di{constructor(t,e,i,s,n){this.radius0=t,this.radius1=e,this.bearing0=i,this.bearing1=s,this.curveLength=n}numDefinedProperties(){return J.defined01(this.radius0)+J.defined01(this.radius1)+J.defined01(this.bearing0)+J.defined01(this.bearing1)+J.defined01(this.curveLength)}clone(){return new di(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const t=ni.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return J.isSameCoordinate(this.curveLength,t)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const t=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=ni.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,t),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=ni.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,t),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=ni.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,t),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=Z.createRadians(this.bearing0.radians+ni.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=Z.createRadians(this.bearing1.radians-ni.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&J.isSameCoordinate(t,e)}almostEqualBearing(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqualNoPeriodShift(e)}isAlmostEqual(t){return!!(t&&this.almostEqualCoordinate(this.radius0,t.radius0)&&this.almostEqualCoordinate(this.radius1,t.radius1)&&this.almostEqualBearing(this.bearing0,t.bearing0)&&this.almostEqualBearing(this.bearing1,t.bearing1)&&this.almostEqualCoordinate(this.curveLength,t.curveLength))}applyScaleFactor(t){void 0!==this.radius0&&(this.radius0*=t),void 0!==this.radius1&&(this.radius1*=t),void 0!==this.curveLength&&(this.curveLength*=t)}static areAlmostEqual(t,e){return void 0===t?void 0===e:t.isAlmostEqual(e)}}class ui extends ni{get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}constructor(t,e,i,s,n,r,o,a){super(t,r,n,a),this.curvePrimitiveType="transitionSpiral",this._evaluator=e,this.radius01=i,this.bearing01=s,this._arcLength01=o,this._globalStrokes=ye.create(),this._curvature01=De.create(0,1),this.refreshComputedProperties()}globalFractionToBearingRadians(t){const e=this._evaluator.fractionToArea(t),i=this._arcLength01;return this.bearing01.startRadians+e*i*this._curvature01.signedDelta()+t*this._curvature01.x0*i}globalFractionToCurvature(t){const e=this._evaluator.fractionToCurvatureFraction(t);return this._curvature01.fractionToPoint(e)}fractionToBearingRadians(t){const e=this.activeFractionInterval.fractionToPoint(t);return this.bearing01.startRadians+e*this._arcLength01*(this._curvature01.x0+.5*e*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(t){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(t))}static initWorkSpace(){ui._gaussFraction=new Float64Array(5),ui._gaussWeight=new Float64Array(5),ui._gaussMapper=Kt.setupGauss5}fullSpiralIncrementalIntegral(t,e,i,s){const n=ui._gaussFraction,r=ui._gaussWeight,o=ui._gaussMapper(e,i,n,r),a=this._arcLength01;let c=0,h=0,l=0;for(let t=0;t<o;t++){const e=this.globalFractionToBearingRadians(n[t]);c=r[t]*a,h+=c*Math.cos(e),l+=c*Math.sin(e)}s?pt.xyzPlusMatrixTimesXYZ(t,this.localToWorld.matrix,{x:h,y:l,z:0},t):t.addXYZInPlace(h,l,0)}refreshComputedProperties(){this._curvature01=De.create(ni.radiusToCurvature(this.radius01.x0),ni.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const t=K.create();this._globalStrokes.appendStrokePoint(t);const e=1/16;for(let i=1;i<=16;i++){const s=(i-1)*e,n=i*e;this.fullSpiralIncrementalIntegral(t,s,n,!1),this._globalStrokes.appendStrokePoint(t)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=ye.create()),this._activeStrokes.clear();for(let t=0;t<=16;t++){const i=t*e;this._activeStrokes.addPoint(this.fractionToPoint(i))}}}static createRadiusRadiusBearingBearing(t,e,i,s,n){const r=ni.radiusRadiusSweepRadiansToArcLength(t.x0,t.x1,e.sweepRadians);void 0===n&&(n="clothoid");const o=ri.findEvaluator(n);if(o)return new ui(n,o,t.clone(),e.clone(),i.clone(),s.clone(),r,new di(t.x0,t.x1,e.startAngle.clone(),e.endAngle.clone(),void 0))}static createFrom4OutOf5(t,e,i,s,n,r,o,a){void 0===t&&(t="clothoid");const c=ri.findEvaluator(t);if(!c)return;const h=new di(e,i,s,n,r),l=h.clone();return h.tryResolveAnySingleUnknown()?(void 0===o&&(o=De.create(0,1)),new ui(t,c,De.create(h.radius0,h.radius1),vt.createStartEnd(h.bearing0,h.bearing1),o?o.clone():De.create(0,1),a,h.curveLength,l)):void 0}setFrom(t){return this.localToWorld.setFrom(t.localToWorld),this.radius01.setFrom(t.radius01),this._curvature01.setFrom(t._curvature01),this.bearing01.setFrom(t.bearing01),this.localToWorld.setFrom(t.localToWorld),this.activeFractionInterval.setFrom(t.activeFractionInterval),this._arcLength01=t._arcLength01,this}clone(){return new ui(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(t){const e=this.applyRigidPartOfTransform(t);return void 0!==e&&(this._curvature01.x0/=e.scale,this._curvature01.x1/=e.scale,this.radius01.x0*=e.scale,this.radius01.x1*=e.scale,this._arcLength01*=e.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(t){return t.isPointInPlane(this.localToWorld.origin)&&J.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(t.getNormalRef()))&&J.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(t.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(t,e){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(e-t))}isSameGeometryClass(t){return t instanceof ni}emitStrokes(t,e){this.activeStrokes.emitStrokes(t,e)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startParentCurvePrimitive(this);const s=this.activeStrokes;(void 0===t.needPrimaryGeometryForStrokes||!t.needPrimaryGeometryForStrokes())&&i<=s.numPoints()?this.activeStrokes.emitStrokableParts(t,e):t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endParentCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));e=t.applyTolerancesToArc(i,this.bearing01.sweepRadians),e=t.applyMaxEdgeLength(e,this.curveLength()),e=t.applyMinStrokesPerPrimitive(e)}else e=ve.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return e}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this._globalStrokes.packedPoints.length-1;if(t>1){e=this._globalStrokes.packedPoints.back(e);const t=1/s;let n=1,r=n+t;for(;r<i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r+=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else if(t<0){e=this._globalStrokes.packedPoints.front(e);const t=1/s;let n=0,r=n-t;for(;r>i;)this.fullSpiralIncrementalIntegral(e,n,r,!0),n=r,r-=t;this.fullSpiralIncrementalIntegral(e,n,i,!0)}else{const t=J.clampToStartEnd(i,0,1),n=Math.trunc(t*s),r=n/s;e=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(n,e),this.fullSpiralIncrementalIntegral(e,r,i,!0)}return e}fractionToPointAndDerivative(t,e){const i=this.activeFractionInterval.fractionToPoint(t);e=e||kt.createZero(),this.fractionToPoint(t,e.origin);const s=this.globalFractionToBearingRadians(i),n=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(n*Math.cos(s),n*Math.sin(s),e.direction),e}fractionToFrenetFrame(t,e){const i=this.activeFractionInterval.fractionToPoint(t);(e=e||ft.createIdentity()).origin.setFrom(this.fractionToPoint(t)),pt.createRigidFromMatrix3d(this.localToWorld.matrix,g.XYZ,e.matrix);const s=this.globalFractionToBearingRadians(i),n=Math.cos(s),r=Math.sin(s);return e.matrix.applyGivensColumnOp(0,1,n,r),e}fractionToPointAnd2Derivatives(t,e){const i=this.activeFractionInterval.fractionToPoint(t),s=this.fractionToPoint(t),n=this.globalFractionToBearingRadians(i),r=Math.cos(n),o=Math.sin(n),a=this.activeFractionInterval.signedDelta(),c=a,h=c*a,l=this.localToWorld.matrix.multiplyXY(c*r,c*o),d=this.localToWorld.matrix.multiplyXY(-h*o,h*r);return d.scaleInPlace(this.globalFractionToCurvature(i)),Ft.createCapture(s,l,d,e)}dispatchToGeometryHandler(t){return t.handleTransitionSpiral(this)}isAlmostEqual(t){return t instanceof ui&&this.radius01.isAlmostEqual(t.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(t.bearing01)&&this.localToWorld.isAlmostEqual(t.localToWorld)&&J.isSameCoordinate(this._arcLength01,t._arcLength01)&&this.activeFractionInterval.isAlmostEqual(t.activeFractionInterval)&&this._curvature01.isAlmostEqual(t._curvature01)}}ui.defaultSpiralType="clothoid",ui.initWorkSpace();class fi{static addPartialSegment(t,e,i,s,n,r){(e||r>n)&&(void 0===i||void 0===s||J.isAlmostEqualNumber(n,r)||t.tryAddChild(tr.create(i.interpolate(n,s),i.interpolate(r,s))))}static createArcPointTangentPoint(t,e,i){const s=j.createStartEnd(t,i),n=pt.createRigidFromColumns(e,s,g.XYZ);if(void 0!==n){const i=s.dotProduct(s),r=n.dotColumnY(s),o=J.conditionalDivideCoordinate(i,2*r);if(void 0!==o){const i=n.columnY();i.scaleInPlace(-o);const r=n.columnX();r.scaleInPlace(o);const a=i.plus(s);let c=i.angleTo(a).radians;e.dotProduct(a)<0&&(c=2*Math.PI-c);const h=t.plusScaled(i,-1);return Pe.create(h,i,r,vt.createStartEndRadians(0,c))}}}static createFilletsInLineString(t,e,i=!0){if(Array.isArray(t))return this.createFilletsInLineString(new te(t),e,i);if(t instanceof ye)return this.createFilletsInLineString(t.packedPoints,e,i);const s=t.length;if(s<=1)return;const n=t.getPoint3dAtCheckedPointIndex(0),r=t.getPoint3dAtCheckedPointIndex(1),o=[];o.push({fraction10:0,fraction12:0,point:n.clone()});for(let i=1;i+1<s;i++){const s=t.getPoint3dAtCheckedPointIndex(i+1);let a=0;Array.isArray(e)?i<e.length&&(a=e[i]):Number.isFinite(e)&&(a=e),0!==a?o.push(Pe.createFilletArc(n,r,s,a)):o.push({fraction10:0,fraction12:0,point:r.clone()}),n.setFromPoint3d(r),r.setFromPoint3d(s)}if(o.push({fraction10:0,fraction12:0,point:r.clone()}),!i)for(let t=1;t+1<s;t++){const e=o[t];(e.fraction10>1||e.fraction12>1||1-e.fraction10<o[t-1].fraction12||e.fraction12>1-o[t+1].fraction10)&&(e.fraction10=0,e.fraction12=0,o[t].arc=void 0)}const a=qe.create();this.addPartialSegment(a,i,o[0].point,o[1].point,o[0].fraction12,1-o[1].fraction10);for(let e=1;e+1<t.length;e++){const t=o[e],s=o[e+1];a.tryAddChild(t.arc),this.addPartialSegment(a,i,t.point,s.point,t.fraction12,1-s.fraction10)}return a}static createRectangleXY(t,e,i,s,n=0,r){let o=J.correctSmallMetricDistance(r);const a=Math.min(t,i),c=Math.max(t,i),h=Math.min(e,s),l=Math.max(e,s);if(o=Math.min(Math.abs(o),.5*(c-a),.5*(l-h)),0===o)return Ue.createPolygon([K.create(a,h,n),K.create(c,h,n),K.create(c,l,n),K.create(a,l,n),K.create(a,h,n)]);{const t=j.create(o,0,0),e=j.create(0,o,0),i=a+o,s=h+o,r=c-o,d=l-o,u=[K.create(r,d,n),K.create(i,d,n),K.create(i,s,n),K.create(r,s,n)],f=Ue.create();for(let i=0;i<4;i++){const s=u[i],n=u[(i+1)%4],r=j.createStartEnd(s,n),o=Pe.create(s,t,e,vt.createStartEndDegrees(0,90));f.tryAddChild(o);const a=o.endPoint();r.isAlmostZero||f.tryAddChild(tr.create(a,a.plus(r))),t.rotate90CCWXY(t),e.rotate90CCWXY(e)}return f}}static appendToArcInPlace(t,e,i=!1){if(t.center.isAlmostEqual(e.center)){const s=J.split3WaySign(t.sweep.sweepRadians*e.sweep.sweepRadians,-1,0,1),n=t.angleToPointAndDerivative(t.sweep.fractionToAngle(1));t.sweep.sweepRadians<0&&n.direction.scaleInPlace(-1);const r=e.angleToPointAndDerivative(e.sweep.fractionToAngle(0));if(e.sweep.sweepRadians<0&&r.direction.scaleInPlace(-1),n.isAlmostEqual(r))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians+s*e.sweep.sweepRadians),!0;if(i&&(r.direction.scaleInPlace(-1),n.isAlmostEqual(r)))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians-s*e.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(t,e,i=.5){const s=qe.create();for(let n=0;n+1<e.length;n++){const r=t.sectionArcWithIntermediateNormal(e[n].toAngles(),i,e[n+1].toAngles());s.tryAddChild(r)}return s}static appendGeometryQueryArray(t,e){if(t instanceof Rt)e.push(t);else if(Array.isArray(t))for(const i of t)this.appendGeometryQueryArray(i,e)}static createPipeSegments(t,e){if(t instanceof tr)return ii.createAxisPoints(t.startPoint(),t.endPoint(),e,e,!1);if(t instanceof Pe)return si.createAlongArc(t,e,!1);if(t instanceof $t){const i=In.create();return i.addMiteredPipes(t,e),i.claimPolyface()}if(t instanceof be){const i=[];for(const s of t.children){const t=this.createPipeSegments(s,e);this.appendGeometryQueryArray(t,i)}return i}}static createMiteredPipeSections(t,e){const i=[];if(t.length<2)return[];const s=j.create(),n=j.create(),r=j.create(),o=K.create();let a;if(t.vectorIndexIndex(0,1,r),t.getPoint3dAtUncheckedPointIndex(0,o),e instanceof Pe)a=e.clone(),a.center.setFrom(o),s.setFrom(e.vector0),n.setFrom(e.vector90);else{if("number"!=typeof e&&!K.isXAndY(e))return[];{const t="number"==typeof e?e:e.x,i="number"==typeof e?e:e.y,c=pt.createRigidHeadsUp(r,g.ZXY);c.columnX(s).scaleInPlace(t),c.columnY(n).scaleInPlace(i),a=Pe.create(o,s,n,vt.create360())}}i.push(a);const c=j.create(),h=j.create();for(let e=1;e<t.length;e++)c.setFromVector3d(r),t.getPoint3dAtUncheckedPointIndex(e,o),e+1<t.length?t.vectorIndexIndex(e,e+1,r):r.setFromVector3d(c),c.normalizeInPlace()&&r.normalizeInPlace()&&(c.interpolate(.5,r,h),gi(s,c,h,s),gi(n,c,h,n),i.push(Pe.create(o,s,n,vt.create360())));return i}static createArcPointTangentRadius(t,e,i,s,n){void 0===s&&(s=j.unitZ());const r=s.unitCrossProduct(e);if(void 0===r)return;const o=t.plusScaled(r,i);r.scaleInPlace(-i);const a=e.scaleToLength(Math.abs(i));return Pe.create(o,r,a,vt.create(n))}static createLineSpiralSpiralLine(t,e,i,s){const n=j.createStartEnd(e,i),r=j.createStartEnd(i,s),o=n.magnitude(),a=Math.atan2(n.y,n.x),c=n.angleToXY(r),h=.5*c.radians,l=a+c.radians,d=pt.createRotationAroundAxisIndex(p.Z,Z.createRadians(a)),u=ft.createRefs(e.clone(),d),f=ui.createFrom4OutOf5(t,0,void 0,Z.createRadians(0),Z.createRadians(h),o,void 0,u);if(f){const r=a+h,c=j.createPolar(1,Z.createRadians(r)),d=c.dotProductStartEnd(e,i)/c.dotProductStartEnd(e,f.endPoint()),g=ui.createFrom4OutOf5(t,0,void 0,Z.createRadians(0),Z.createRadians(h),o*d,void 0,u),m=n.magnitude(),x=j.createStartEnd(i,s);x.scaleToLength(m,x);const y=i.plus(x),_=pt.createRotationAroundAxisIndex(p.Z,Z.createRadians(l+Math.PI)),v=ft.createRefs(y,_),P=ui.createFrom4OutOf5(t,0,-g.radius01.x1,Z.zero(),void 0,g.curveLength(),De.create(1,0),v);return[g,P]}}static createLineSpiralSpiralLineWithSpiralLength(t,e,i,s,n){const r=j.createStartEnd(e,i),o=j.createStartEnd(i,s),a=Math.atan2(r.y,r.x),c=r.angleToXY(o),h=.5*c.radians,l=.5*(Math.PI-c.radians),d=Math.atan2(-o.y,-o.x),u=ui.createFrom4OutOf5(t,0,void 0,Z.zero(),Z.createRadians(h),n,void 0,ft.createIdentity());if(u){const r=u.fractionToPoint(1),o=e.distance(i),c=s.distance(i),f=r.y/Math.tan(l),g=J.conditionalDivideFraction(o-f-r.x,o),m=J.conditionalDivideFraction(c-f-r.x,c);if(void 0!==g&&void 0!==m){const r=pt.createRotationAroundAxisIndex(p.Z,Z.createRadians(a)),o=e.interpolate(g,i),c=ft.createRefs(o,r),l=ui.createFrom4OutOf5(t,0,void 0,Z.zero(),Z.createRadians(h),n,void 0,c),u=pt.createRotationAroundAxisIndex(p.Z,Z.createRadians(d)),f=s.interpolate(m,i),x=ft.createRefs(f,u);return[l,ui.createFrom4OutOf5(t,0,void 0,Z.zero(),Z.createRadians(-h),n,void 0,x)]}}}static createLineSpiralArcSpiralLine(t,e,i,s,n,r,o){const a=j.createStartEnd(e,i);a.z=0;const c=j.createStartEnd(s,i);c.z=0;const h=a.normalize(),l=c.normalize();if(void 0===h||void 0===l)return;const d=h.unitPerpendicularXY(),u=l.unitPerpendicularXY(),f=a.angleToXY(c),g=J.split3WaySign(f.radians,1,-1,-1),p=-g,m=g*Math.abs(o),x=p*Math.abs(o),y=ui.createFrom4OutOf5(t,0,m,Z.zero(),void 0,n,void 0,ft.createIdentity()),_=ui.createFrom4OutOf5(t,0,x,Z.zero(),void 0,r,void 0,ft.createIdentity()),v=y.fractionToPointAndUnitTangent(1),P=_.fractionToPointAndUnitTangent(1),I=v.origin.x-m*v.direction.y,A=v.origin.y+m*v.direction.x,S=P.origin.x-x*P.direction.y,w=P.origin.y+x*P.direction.x,C=j.createAdd2Scaled(h,I,d,A),T=j.createAdd2Scaled(l,S,u,w),k=G.create();if(Ct.linearSystem2d(h.x,-l.x,h.y,-l.y,T.x-C.x,T.y-C.y,k)){const t=i.plusScaled(h,k.x),e=i.plusScaled(l,k.y),s=ft.createOriginAndMatrixColumns(t,h,d,j.unitZ()),n=ft.createOriginAndMatrixColumns(e,l,u,j.unitZ());y.tryTransformInPlace(s),_.tryTransformInPlace(n);const r=y.fractionToPointAndUnitTangent(1),o=_.fractionToPointAndUnitTangent(1);o.direction.scaleInPlace(-1);const a=r.direction.angleToXY(o.direction);return m<0&&a.setRadians(-a.radians),[y,fi.createArcPointTangentRadius(r.origin,r.direction,m,void 0,a),_]}}static planePlaneIntersectionRay(t,e){const i=t.altitudeXYZ(0,0,0),s=e.altitudeXYZ(0,0,0),n=t.normalX(),r=t.normalY(),o=t.normalZ(),a=e.normalX(),c=e.normalY(),h=e.normalZ(),l=J.crossProductXYXY(r,o,c,h),d=J.crossProductXYXY(o,n,h,a),u=J.crossProductXYXY(n,r,a,c),f=Ct.linearSystem3d(n,r,o,a,c,h,l,d,u,-i,-s,0);if(void 0!==f)return kt.createXYZUVW(f.x,f.y,f.z,l,d,u)}}function gi(t,e,i,s){const n=t.dotProduct(i),r=e.dotProduct(i),o=J.safeDivideFraction(n,r,0);return t.plusScaled(e,-o,s)}class pi extends ge{constructor(t){super(),this._localPoint=K.create(),this._worldPoint=K.create(),this._perpVector=j.createZero(),this._maxDistance=0,this._localToWorld=t.toRigidZFrame()}announcePoint(t){this._localToWorld.multiplyInversePoint3d(t,this._localPoint);const e=this._localPoint.magnitudeXY();e>=this._maxDistance&&(this._maxDistance=e,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(t){this.announcePoint(t.startPoint(this._worldPoint)),this.announcePoint(t.endPoint(this._worldPoint))}handleLineString3d(t){for(let e=0;e<t.numPoints();e++)t.pointAt(e,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(t){const e=ve.applyAngleTol(void 0,3,t.sweep.sweepRadians,.1),i=1/e;for(let s=0;s<=e;s++)t.fractionToPoint(s*i,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(t,e){const i=new pi(t);return e.dispatchToGeometryHandler(i),i._perpVector.clone()}static buildRotationalNormalsInLineStrings(t,e,i){if(t instanceof ye){const s=t.packedPoints,n=t.packedDerivatives,r=t.ensureEmptySurfaceNormals();if(n&&r){const n=j.create(),o=j.create(),a=K.create(),c=s.length;for(let h=0;h<c;h++)s.getPoint3dAtUncheckedPointIndex(h,a),e.perpendicularPartOfVectorToTarget(a,n),n.isAlmostZero?e.direction.crossProduct(i,o):e.direction.crossProduct(n,o),t.packedDerivatives.getVector3dAtCheckedVectorIndex(h,n),n.crossProduct(o,o),o.normalizeInPlace(),r.push(o)}}else if(t.children){const s=t.children;for(const t of s)this.buildRotationalNormalsInLineStrings(t,e,i)}}}class mi{startSweeps(t,e,i){return!0}endSweeps(t,e,i){return!0}}class xi extends mi{constructor(){super(),this.myMap=zt.createWithComponentIndex()}startPass(t){return 0===t?(this.myMap.numStroke=0,!0):1===t}visit(t,e){return 0===t?(e.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=e.numStroke),!0):1===t&&(e.numStroke=this.myMap.numStroke,!0)}endPass(t){return!0}}class yi extends mi{constructor(){super(),this.maxCurveLength=0}startPass(t){return 0===t?(this.maxCurveLength=0,!0):1===t}visit(t,e){return 0===t?(this.maxCurveLength=J.maxXY(e.curveLength,this.maxCurveLength),!0):1===t&&(e.a0=0,e.a1=this.maxCurveLength,!0)}endPass(t){return!0}}class _i{constructor(t,e){this.parent=t,this.maps=[],this.options=e}static createForCurveChain(t,e){const i=new _i(t,e);i.parent=t;for(const s of t.children)s.computeAndAttachRecursiveStrokeCounts(e),s.strokeData&&i.maps.push(s.strokeData);return i}getStrokes(){const t=ye.create();this.options&&(this.options.needNormals||this.options.needParams)&&(t.ensureEmptyFractions(),t.ensureEmptyDerivatives(),t.ensureEmptyUVParams());for(const e of this.maps)e.primitive&&e.primitive.addMappedStrokesToLineString3D(e,t);return t}static applySummed01LimitsWithinArray(t,e){let i=e;for(const e of t)e.a0+=i,e.componentData?e.a1=this.applySummed01LimitsWithinArray(e.componentData,e.a0):e.a1+=i,i=e.a1;return i}applySummed01Limits(t){return _i.applySummed01LimitsWithinArray(this.maps,t)}}class vi{constructor(t){this.parent=t,this.chains=[]}static createForParityRegionOrChain(t,e){const i=new vi(t);if(t instanceof Ge)for(const s of t.children){const t=_i.createForCurveChain(s,e);i.chains.push(t)}else t instanceof be&&i.chains.push(_i.createForCurveChain(t,e));return i}static areSectionsCompatible(t,e){if(t.length<2)return!0;const i=t[0].chains.length;for(let s=1;s<t.length;s++){if(t[s].chains.length!==i)return!1;for(let i=0;i<t[0].chains.length;i++){const n=t[0].chains[i].maps.length;if(t[s].chains[i].maps.length!==n)return!1;for(let r=0;r<n;r++)if(!t[0].chains[i].maps[r].isCompatibleComponentStructure(t[s].chains[i].maps[r],e))return!1}}return!0}static remapa0a1WithinEachChain(t){for(const e of t)for(const t of e.chains)t.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(t,e,i,s,n){const r=t.length;if(!n.startSweeps(e,i,s))return!1;if(void 0===s)for(let s=0;n.startPass(s);s++){for(let o=0;o<r;o++)if(!n.visit(s,t[o].chains[e].maps[i]))return!1;if(!n.endPass(s))return!1}else for(let o=0;n.startPass(o);o++){for(let a=0;a<r;a++)if(!n.visit(o,t[a].chains[e].maps[i].componentData[s]))return!1;if(!n.endPass(o))return!1}return!!n.endSweeps(e,i,s)}static runMultiPassVisitorAtCorrespondingPrimitives(t,e){const i=t[0].chains.length;for(let s=0;s<i;s++){const i=t[0].chains[s].maps.length;for(let n=0;n<i;n++)if(t[0].chains[s].maps[n].componentData){const i=t[0].chains[s].maps[n].componentData.length;for(let r=0;r<i;r++)if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,r,e))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(t,s,n,void 0,e))return!1}return!0}static enforceStrokeCountCompatibility(t){if(t.length<2)return!0;if(!vi.areSectionsCompatible(t,!1))return!1;const e=new xi;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),!0}static enforceCompatibleDistanceSums(t){if(t.length<2)return!0;if(!vi.areSectionsCompatible(t,!1))return!1;const e=new yi;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),this.remapa0a1WithinEachChain(t),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const t=Ge.create();for(const e of this.chains){const i=e.getStrokes();i instanceof ye&&t.tryAddChild(Ue.create(i))}return t}}static extendDistanceRangeBetweenStrokes(t,e,i){if(t instanceof ye){if(e instanceof ye&&t.numPoints()===e.numPoints()){const s=t.numPoints(),n=K.create(),r=K.create(),o=t.packedPoints,a=e.packedPoints;for(let t=0;t<s;t++)o.getPoint3dAtCheckedPointIndex(t,n),a.getPoint3dAtCheckedPointIndex(t,r),i.extendX(n.distance(r));return!0}}else if(t instanceof Ge){if(e instanceof Ge){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}}else if(t instanceof be&&e instanceof be){const s=t.children,n=e.children,r=s.length;if(r===n.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(s[t],n[t],i))return!1;return!0}}return!1}}class Pi{constructor(t,e,i){this.surface=t,this.point=i||K.createZero(),this.uv=e||W.createZero(),this.a=0}static createSurfaceUVPoint(t,e,i){const s=new Pi(t);return e&&s.uv.setFrom(e),s.point.setFromPoint3d(i),s}static createSurfaceUVNumbersPoint(t,e,i,s){const n=new Pi(t);return n.uv.x=e,n.uv.y=i,n.point.setFromPoint3d(s),n}}class Ii{constructor(t,e){this.curveDetail=t,this.surfaceDetail=e}}class Ai{constructor(t,e,i,s){this.point00=t,this.point10=e,this.point01=i,this.point11=s}static create(t,e,i,s){return new Ai(t.clone(),e.clone(),i.clone(),s.clone())}static createXYZ(t,e,i,s,n,r,o,a,c,h,l,d){return new Ai(K.create(t,e,i),K.create(s,n,r),K.create(o,a,c),K.create(h,l,d))}clone(){return new Ai(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(t){return this.point00.isAlmostEqual(t.point00)&&this.point10.isAlmostEqual(t.point10)&&this.point01.isAlmostEqual(t.point01)&&this.point11.isAlmostEqual(t.point11)}tryTransformInPlace(t){return t.multiplyPoint3d(this.point00,this.point00),t.multiplyPoint3d(this.point10,this.point10),t.multiplyPoint3d(this.point01,this.point01),t.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}extendRange(t,e){e?(t.extendTransformedPoint(e,this.point00),t.extendTransformedPoint(e,this.point10),t.extendTransformedPoint(e,this.point01),t.extendTransformedPoint(e,this.point11)):(t.extendPoint(this.point00),t.extendPoint(this.point10),t.extendPoint(this.point01),t.extendPoint(this.point11))}uvFractionToPoint(t,e,i){const s=(1-t)*(1-e),n=t*(1-e),r=(1-t)*e,o=t*e;return K.create(s*this.point00.x+n*this.point10.x+r*this.point01.x+o*this.point11.x,s*this.point00.y+n*this.point10.y+r*this.point01.y+o*this.point11.y,s*this.point00.z+n*this.point10.z+r*this.point01.z+o*this.point11.z,i)}uvFractionToPointAndTangents(t,e,i){const s=1-t,n=1-e,r=s*n,o=t*n,a=s*e,c=t*e;return Ft.createOriginAndVectorsXYZ(r*this.point00.x+o*this.point10.x+a*this.point01.x+c*this.point11.x,r*this.point00.y+o*this.point10.y+a*this.point01.y+c*this.point11.y,r*this.point00.z+o*this.point10.z+a*this.point01.z+c*this.point11.z,n*(this.point10.x-this.point00.x)+e*(this.point11.x-this.point01.x),n*(this.point10.y-this.point00.y)+e*(this.point11.y-this.point01.y),n*(this.point10.z-this.point00.z)+e*(this.point11.z-this.point01.z),s*(this.point01.x-this.point00.x)+t*(this.point11.x-this.point10.x),s*(this.point01.y-this.point00.y)+t*(this.point11.y-this.point10.y),s*(this.point01.z-this.point00.z)+t*(this.point11.z-this.point10.z),i)}static conditionalPivot(t,e,i,s){if(Math.abs(e[s][t])>Math.abs(e[i][t])){const t=e[i];e[i]=e[s],e[s]=t}}intersectRay(t){const e=this.point10.minus(this.point00),i=this.point01.minus(this.point00),s=this.point11.minus(this.point10);s.subtractInPlace(i);const n=[new Float64Array([-t.direction.x,this.point00.x-t.origin.x,e.x,i.x,s.x]),new Float64Array([-t.direction.y,this.point00.y-t.origin.y,e.y,i.y,s.y]),new Float64Array([-t.direction.z,this.point00.z-t.origin.z,e.z,i.z,s.z])];Ai.conditionalPivot(0,n,0,1),Ai.conditionalPivot(0,n,0,2),Ct.eliminateFromPivot(n[0],0,n[1],-1),Ct.eliminateFromPivot(n[0],0,n[2],-1);const r=Ct.solveBilinearPair(n[1][1],n[1][2],n[1][3],n[1][4],n[2][1],n[2][2],n[2][3],n[2][4]);if(r){const e=[];for(const i of r){const s=-(n[0][1]+n[0][2]*i.x+(n[0][3]+n[0][4]*i.x)*i.y)/n[0][0],r=t.fractionToPoint(s);e.push(new Ii(yt.createRayFractionPoint(t,s,r),Pi.createSurfaceUVPoint(this,i,r)))}return e}}maxUEdgeLength(){return J.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return J.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class Si{static sampledRangeOfOffsetPatch(t,e,i,s){const n=lt.createNull(),r=1/(i=Math.ceil(J.clamp(i,2,500))),o=1/(s=Math.ceil(J.clamp(s,2,500))),a=K.create(),c=Ft.createXYPlane();let h,l;for(let d=0;d<=s;d++){l=d*o;for(let s=0;s<=i;s++)if(h=s*r,void 0!==e){t.uvFractionToPointAndTangents(h,l,c);const i=c.unitNormal();void 0!==i&&(c.origin.addScaledInPlace(i,e),n.extend(c.origin))}else t.uvFractionToPoint(h,l,a),n.extendXYZ(a.x,a.y,a.z)}return n}static sampledRangeOfOffsetEllipsoidPatch(t,e,i){const s=ve.applyAngleTol(i,2,t.latitudeSweep.sweepRadians,Z.degreesToRadians(5)),n=ve.applyAngleTol(i,2,t.longitudeSweep.sweepRadians,Z.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(t,e,s,n)}constructor(){}static createLinestringOnUVLine(t,e,i,s,n,r,o=!1,a=!1){const c=ye.create(),h=K.create();let l,d,u;const f=r+1;for(let g=0;g<f;g++)l=g/r,d=J.interpolate(e,l,s),u=J.interpolate(i,l,n),t.uvFractionToPoint(d,u,h),c.addPoint(h),o&&c.addUVParamAsUV(d,u),a&&c.addFraction(l);return c}}class wi{constructor(t,e=8,i){this._data=new Float64Array(e*t),this._inUse=0,this._blockSize=t>0?t:1,this._growthFactor=void 0!==i&&i>=1?i:1.5}copyData(t,e,i){let s=void 0!==i?i*this.numPerBlock:0;if(s<0&&(s=0),s>=this._data.length)return{count:0,offset:0};let n=void 0!==e?e*this.numPerBlock:t.length;return n>0&&(n>t.length&&(n=t.length),s+n>this._data.length&&(n=this._data.length-s),n%this.numPerBlock!=0&&(n-=n%this.numPerBlock)),n<=0?{count:0,offset:0}:(n===t.length?this._data.set(t,s):t instanceof Float64Array?this._data.set(t.subarray(0,n),s):this._data.set(t.slice(0,n),s),{count:n/this.numPerBlock,offset:s/this.numPerBlock})}clone(){const t=new wi(this.numPerBlock,this.numBlocks,this._growthFactor);return t.copyData(this._data,this.numBlocks),t._inUse=this.numBlocks,t}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(t,e){return this._data[t*this._blockSize+e]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(t,e=!0){if(t>this.blockCapacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t*this._blockSize),this.copyData(i,this._inUse)}}addBlock(t){const e=this.newBlockIndex();let i=t.length;i>this._blockSize&&(i=this._blockSize);for(let s=0;s<i;s++)this._data[e+s]=t[s]}newBlockIndex(){const t=this._blockSize*this._inUse;t+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let e=t;e<t+this._blockSize;e++)this._data[e]=0;return t}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(t){return this._blockSize*t}checkedComponent(t,e){if(!(t>=this._inUse||t<0||e<0||e>=this._blockSize))return this._data[this._blockSize*t+e]}component(t,e){return this._data[this._blockSize*t+e]}static compareLexicalBlock(t,e,i,s){let n=0,r=0;for(let o=0;o<e;o++){if(n=t[i+o],r=t[s+o],n>r)return 1;if(n<r)return-1}return i-s}sortIndicesLexical(t=wi.compareLexicalBlock){const e=this._inUse,i=new Uint32Array(e),s=this._data,n=this._blockSize;for(let t=0;t<e;t++)i[t]=t;return i.sort(((e,i)=>t(s,n,e*n,i*n))),i}distanceBetweenBlocks(t,e){let i=0,s=this.blockIndexToDoubleIndex(t),n=this.blockIndexToDoubleIndex(e),r=0;const o=this._data;for(let t=0;t<this._blockSize;t++)r=o[s++]-o[n++],i+=r*r;return Math.sqrt(i)}distanceBetweenSubBlocks(t,e,i,s){let n=0;const r=this.blockIndexToDoubleIndex(t),o=this.blockIndexToDoubleIndex(e);let a=0;const c=this._data;for(let t=i;t<s;t++)a=c[r+t]-c[o+t],n+=a*a;return Math.sqrt(n)}}class Ci extends wi{static sortVectorComponent(t){let e=1;for(let i=1;i<t;i++)e*=Ci._vectorFactor;return e}constructor(t,e,i){super(1+t+e,i),this._numExtraDataPerPoint=e,this._numCoordinatePerPoint=t}addBlock(t){const e=this.newBlockIndex()+1,i=Math.min(this.numPerBlock-1,t.length);for(let s=0;s<i;s++)this._data[e+s]=t[s]}addDirect(t,e,i,s,n){const r=this.newBlockIndex();this._data[r+1]=t,void 0!==e&&(this._data[r+2]=e),void 0!==i&&(this._data[r+3]=i),void 0!==s&&(this._data[r+4]=s),void 0!==n&&(this._data[r+5]=n)}addPoint2d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,void 0!==e&&(this._data[n+3]=e),void 0!==i&&(this._data[n+4]=i),void 0!==s&&(this._data[n+5]=s)}addPoint3d(t,e,i,s){const n=this.newBlockIndex();this._data[n+1]=t.x,this._data[n+2]=t.y,this._data[n+3]=t.z,void 0!==e&&(this._data[n+4]=e),void 0!==i&&(this._data[n+5]=i),void 0!==s&&(this._data[n+6]=s)}getPoint2d(t,e){const i=this.blockIndexToDoubleIndex(t);return W.create(this._data[i+1],this._data[i+2],e)}getPoint3d(t,e){const i=this.blockIndexToDoubleIndex(t);return K.create(this._data[i+1],this._data[i+2],this._data[i+3],e)}getExtraData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+1+this._numCoordinatePerPoint+e]}getData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+e]}setExtraData(t,e,i){const s=this.blockIndexToDoubleIndex(t);this._data[s+1+this._numCoordinatePerPoint+e]=i}static isClusterTerminator(t){return t===Ci.clusterTerminator}clusterIndicesLexical(t=J.smallMetricDistance){this.setupPrimaryClusterSort();const e=this.sortIndicesLexical(),i=new Uint32Array(2*e.length);let s=0;const n=this.numBlocks;let r=0,o=0,a=0,c=0,h=0;const l=1+this._numCoordinatePerPoint;for(c=0;c<n;c++)if(r=e[c],!Ci.isClusterTerminator(r)){for(i[s++]=r,a=this.component(r,0)+t,e[c]=Ci.clusterTerminator,h=c+1;h<n;h++)if(o=e[h],o!==Ci.clusterTerminator){if(this.component(o,0)>=a)break;this.distanceBetweenSubBlocks(r,o,1,l)<t&&(i[s++]=o,e[h]=Ci.clusterTerminator)}i[s++]=Ci.clusterTerminator}return i.slice(0,s)}setupPrimaryClusterSort(){const t=this.numBlocks,e=this._numCoordinatePerPoint,i=new Float64Array(e);i[0]=1;for(let t=1;t<e;t++)i[t]=i[t-1]*Ci._vectorFactor;let s=0,n=0;const r=this._data;for(let o=0;o<t;o++){s=this.blockIndexToDoubleIndex(o),n=0;for(let t=0;t<e;t++)n+=i[t]*r[s+1+t];r[s]=n}}toJSON(){const t=[];for(let e=0;e<this.numBlocks;e++){let i=this.blockIndexToDoubleIndex(e);const s=[e,this._data[i++]],n=[];for(let t=0;t<this._numCoordinatePerPoint;t++)n.push(this._data[i++]);s.push(n);for(let t=0;t<this._numExtraDataPerPoint;t++)s.push(this._data[i++]);t.push(s)}return t}createIndexBlockToClusterIndex(t){const e=this.numBlocks,i=new Uint32Array(e);i.fill(Ci.clusterTerminator);let s=0;for(const n of t)n>=e?s++:i[n]=s;return i}createIndexBlockToClusterStart(t){const e=t.length,i=this.numBlocks,s=new Uint32Array(i),n=Ci.clusterTerminator;s.fill(n);let r=0;for(let n=0;n<e;n++){const e=t[n];e>i?r=n+1:s[e]=r}return s}countClusters(t){let e=0;const i=Ci.clusterTerminator;for(const s of t)s===i&&e++;return e}createIndexClusterToClusterStart(t){let e=this.countClusters(t);const i=new Uint32Array(e),s=Ci.clusterTerminator;i.fill(s);const n=t.length;let r=0;for(let o=0;o<n;o++)t[o]===s?r=o+1:o===r&&(i[e++]=r);return i}sortSubsetsBySingleKey(t,e){const i=1+e;let s,n,r,o=0;const a=t.length;for(let e=0;e<a;e++)if(t[e]===Ci.clusterTerminator){for(let a=o;a+1<e;a++){n=this.getWithinBlock(t[a],i);for(let o=a+1;o<e;o++)r=this.getWithinBlock(t[o],i),r<n&&(s=t[a],t[a]=t[o],t[o]=s,n=r)}o=e+1}}static clusterPoint3dArray(t,e=J.smallMetricDistance){const i=new Ci(3,0,t.length);t.forEach((t=>{i.addDirect(t.x,t.y,t.z)}));const s=i.clusterIndicesLexical(e),n=new ki(t.length);let r=0,o=0;return s.forEach((e=>{Ci.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedPoints.push(t[e].clone()),n.oldToNew[e]=r,o++)})),n}static clusterNumberArray(t,e=J.smallMetricDistance){const i=new Ci(1,0,t.length);t.forEach((t=>{i.addDirect(t)}));const s=i.clusterIndicesLexical(e),n=new Mi(t.length);let r=0,o=0;return s.forEach((e=>{Ci.isClusterTerminator(e)?(r++,o=0):(0===o&&n.packedNumbers.push(t[e]),n.oldToNew[e]=r,o++)})),n}static clusterGrowablePoint2dArray(t,e=J.smallMetricDistance){const i=new Ci(2,0,t.length),s=W.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint2dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y);const r=i.clusterIndicesLexical(e),o=i.countClusters(r),a=new Fi(t.length,o);let c=0,h=0;return r.forEach((e=>{Ci.isClusterTerminator(e)?(c++,h=0):(0===h&&a.growablePackedPoints.pushFromGrowableXYArray(t,e),a.oldToNew[e]=c,h++)})),a}static clusterGrowablePoint3dArray(t,e=J.smallMetricDistance){const i=new Ci(3,0,t.length),s=K.create(),n=t.length;for(let e=0;e<n;e++)t.getPoint3dAtUncheckedPointIndex(e,s),i.addDirect(s.x,s.y,s.z);const r=i.clusterIndicesLexical(e),o=new ki(t.length),a=i.countClusters(r);o.growablePackedPoints=new it(a);let c=0,h=0;return r.forEach((e=>{Ci.isClusterTerminator(e)?(c++,h=0):(0===h&&o.growablePackedPoints.pushFromGrowableXYZArray(t,e),o.oldToNew[e]=c,h++)})),o}}function Ti(t,e){let i=0;return t.forEach(((t,s,n)=>{t<e.length?n[s]=e[t]:i++})),0===i}Ci._vectorFactor=.8732,Ci.clusterTerminator=4294967295;class ki{constructor(t){this.packedPoints=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=ki.invalidIndex}updateIndices(t){return Ti(t,this.oldToNew)}}ki.invalidIndex=4294967295;class Fi{constructor(t,e){this.growablePackedPoints=new me(e),this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Fi.invalidIndex}updateIndices(t){return Ti(t,this.oldToNew)}}Fi.invalidIndex=4294967295;class Mi{constructor(t){this.packedNumbers=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=ki.invalidIndex}updateIndices(t){return Ti(t,this.oldToNew)}}Mi.invalidIndex=4294967295,function(t){t[t.Scalar=0]="Scalar",t[t.Distance=1]="Distance",t[t.Vector=2]="Vector",t[t.Normal=3]="Normal"}(C||(C={}));class bi{constructor(t,e){if(this.input=t,e instanceof Float64Array){this.values=[];for(const t of e)this.values.push(t)}else this.values=e}copyValues(t,e,i,s){for(let n=0;n<s;n++)this.values[e*s+n]=t.values[i*s+n]}clone(){return new bi(this.input,this.values.slice())}isAlmostEqual(t,e){const i=e||1e-8;return Math.abs(this.input-t.input)<i&&ie.isAlmostEqual(this.values,t.values,i)}}class Ei{constructor(t,e,i,s){this.data=t,this.dataType=e,this.name=i,this.inputName=s}clone(){const t=[];for(const e of this.data)t.push(e.clone());return new Ei(t,this.dataType,this.name,this.inputName)}isAlmostEqual(t,e){if(this.dataType!==t.dataType||this.name!==t.name||this.inputName!==t.inputName||this.data.length!==t.data.length)return!1;for(let i=0;i<this.data.length;i++)if(!this.data[i].isAlmostEqual(t.data[i],e))return!1;return!0}get isScalar(){return this.dataType===C.Distance||this.dataType===C.Scalar}get entriesPerValue(){return this.isScalar?1:3}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const t=dt.createNull();for(const e of this.data)t.extendArray(e.values);return t}computeDisplacementRange(t=1,e){if(e=lt.createNull(e),C.Vector===this.dataType)for(const i of this.data){const s=i.values;for(let i=0;i<s.length;i+=3)e.extendXYZ(s[i]*t,s[i+1]*t,s[i+2]*t)}return e}}class Xi{constructor(t,e){this.channels=t,this.indices=e}clone(){const t=this.channels.map((t=>t.clone()));return new Xi(t,this.indices.slice())}isAlmostEqual(t,e){if(!ie.isExactEqual(this.indices,t.indices)||this.channels.length!==t.channels.length)return!1;for(let i=0;i<this.channels.length;i++)if(!this.channels[i].isAlmostEqual(t.channels[i],e))return!1;return!0}static isAlmostEqual(t,e,i){return t===e||!(!t||!e)&&t.isAlmostEqual(e,i)}createForVisitor(){const t=[];for(const e of this.channels){const i=[];for(const t of e.data)i.push(new bi(t.input,[]));t.push(new Ei(i,e.dataType,e.name,e.inputName))}return new Xi(t,[])}tryTransformInPlace(t){let e;const i=t.matrix,s=i.determinant(),n=Math.pow(Math.abs(s),1/3)*(s>=0?1:-1);for(const t of this.channels)for(const s of t.data)switch(t.dataType){case C.Scalar:continue;case C.Distance:for(let t=0;t<s.values.length;t++)s.values[t]*=n;break;case C.Normal:if(e=e??i.inverse(),!e)return!1;zi(s.values,(t=>e.multiplyTransposeVectorInPlace(t)));break;case C.Vector:zi(s.values,(t=>i.multiplyVectorInPlace(t)))}return!0}}function zi(t,e){const i=new K;for(let s=0;s<t.length;s+=3)i.set(t[s],t[s+1],t[s+2]),e(i),t[s]=i.x,t[s+1]=i.y,t[s+2]=i.z}!function(t){let e,i,s;!function(t){t[t.SubdivisionSurface=-1e3]="SubdivisionSurface"}(e=t.TaggedNumericTagType||(t.TaggedNumericTagType={})),function(t){t[t.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",t[t.CatmullClark=1]="CatmullClark",t[t.Loop=2]="Loop",t[t.DooSabin=3]="DooSabin"}(i=t.SubdivisionMethod||(t.SubdivisionMethod={})),function(t){t[t.FixedDepth=-100]="FixedDepth",t[t.AbsoluteTolerance=-101]="AbsoluteTolerance",t[t.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(s=t.SubdivisionControlCode||(t.SubdivisionControlCode={}))}(T||(T={}));class Ri{constructor(t=0,e=0,i,s){this.tagA=t,this.tagB=e,i&&(this.intData=i),s&&(this.doubleData=s)}pushIntPair(t,e){this.intData||(this.intData=[]),this.intData.push(t),this.intData.push(e)}pushIndexedDouble(t,e){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(t),this.intData.push(this.doubleData.length),this.doubleData.push(e)}tagToInt(t,e,i,s){if(this.intData)for(let s=0;s+1<this.intData.length;s+=2)if(this.intData[s]===t)return Math.min(Math.max(this.intData[s+1],e),i);return s}tagToIndexedDouble(t,e,i,s){if(this.intData)for(let n=0;n+1<this.intData.length;n+=2)if(this.intData[n]===t)return J.clamp(this.getDoubleData(this.intData[n+1],s),e,i);return s}getDoubleData(t,e){return this.doubleData&&0<=t&&t<this.doubleData.length?this.doubleData[t]:e}isAlmostEqual(t){return void 0!==t&&this.tagA===t.tagA&&this.tagB===t.tagB&&J.exactEqualNumberArrays(this.intData,t.intData)&&J.almostEqualArrays(this.doubleData,t.doubleData,J.isAlmostEqualNumber)}static areAlmostEqual(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqual(e)}clone(t){return t||(t=new Ri(this.tagA,this.tagB)),this.intData&&(t.intData=this.intData.slice()),this.doubleData&&(t.doubleData=this.doubleData.slice()),t}}class Di{get twoSided(){return this._twoSided}set twoSided(t){this._twoSided=t}setTaggedNumericData(t){this.taggedNumericData=t}get expectedClosure(){return this._expectedClosure}set expectedClosure(t){this._expectedClosure=t}constructor(t=!1,e=!1,i=!1,s=!1){this.face=[],this.point=new it,this.pointIndex=[],this.edgeVisible=[],t&&(this.normal=new it,this.normalIndex=[]),e&&(this.param=new me,this.paramIndex=[]),i&&(this.color=[],this.colorIndex=[]),this._twoSided=s,this._expectedClosure=0}clone(){const t=new Di;return t.point=this.point.clone(),t.pointIndex=this.pointIndex.slice(),t.edgeVisible=this.edgeVisible.slice(),t.face=this.face.slice(),t.twoSided=this.twoSided,t.expectedClosure=this.expectedClosure,this.normal&&(t.normal=this.normal.clone()),this.param&&(t.param=this.param.clone()),this.color&&(t.color=this.color.slice()),this.normalIndex&&(t.normalIndex=this.normalIndex.slice()),this.paramIndex&&(t.paramIndex=this.paramIndex.slice()),this.colorIndex&&(t.colorIndex=this.colorIndex.slice()),this.auxData&&(t.auxData=this.auxData.clone()),this.taggedNumericData&&(t.taggedNumericData=this.taggedNumericData.clone()),t}isAlmostEqual(t){return!!(it.isAlmostEqual(this.point,t.point)&&ie.isExactEqual(this.pointIndex,t.pointIndex)&&it.isAlmostEqual(this.normal,t.normal)&&ie.isExactEqual(this.normalIndex,t.normalIndex)&&me.isAlmostEqual(this.param,t.param)&&ie.isExactEqual(this.paramIndex,t.paramIndex)&&ie.isExactEqual(this.color,t.color)&&ie.isExactEqual(this.colorIndex,t.colorIndex)&&ie.isExactEqual(this.edgeVisible,t.edgeVisible)&&Xi.isAlmostEqual(this.auxData,t.auxData)&&this.twoSided===t.twoSided&&this.expectedClosure===t.expectedClosure&&Ri.areAlmostEqual(this.taggedNumericData,t.taggedNumericData))}get requireNormals(){return void 0!==this.normal}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(t,e){return this.point.getPoint3dAtCheckedPointIndex(t,e)}getNormal(t){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(t):void 0}getParam(t){return this.param?this.param.getPoint2dAtCheckedPointIndex(t):void 0}getColor(t){return this.color?this.color[t]:0}getEdgeVisible(t){return this.edgeVisible[t]}copyPointTo(t,e){this.point.getPoint3dAtUncheckedPointIndex(t,e)}copyNormalTo(t,e){this.normal&&this.normal.getVector3dAtCheckedVectorIndex(t,e)}copyParamTo(t,e){this.param&&this.param.getPoint2dAtCheckedPointIndex(t,e)}isAlmostEqualParamIndexUV(t,e,i){return void 0!==this.param&&t>=0&&t<this.param.length&&J.isSameCoordinate(e,this.param.getXAtUncheckedPointIndex(t))&&J.isSameCoordinate(i,this.param.getYAtUncheckedPointIndex(t))}gatherIndexedData(t,e,i,s){const n=i-e,r=n+s;this.resizeAllDataArrays(r);for(let i=0;i<n;i++)this.point.transferFromGrowableXYZArray(i,t.point,t.pointIndex[e+i]);for(let t=0;t<s;t++)this.point.transferFromGrowableXYZArray(n+t,this.point,t);for(let i=0;i<n;i++)this.pointIndex[i]=t.pointIndex[e+i];for(let t=0;t<s;t++)this.pointIndex[n+t]=this.pointIndex[t];for(let i=0;i<n;i++)this.edgeVisible[i]=t.edgeVisible[e+i];for(let t=0;t<s;t++)this.edgeVisible[n+t]=this.edgeVisible[t];if(this.normal&&this.normalIndex&&t.normal&&t.normalIndex){for(let i=0;i<n;i++)this.normal.transferFromGrowableXYZArray(i,t.normal,t.normalIndex[e+i]);for(let t=0;t<s;t++)this.normal.transferFromGrowableXYZArray(n+t,this.normal,t);for(let i=0;i<n;i++)this.normalIndex[i]=t.normalIndex[e+i];for(let t=0;t<s;t++)this.normalIndex[n+t]=this.normalIndex[t]}if(this.param&&this.paramIndex&&t.param&&t.paramIndex){for(let i=0;i<n;i++)this.param.transferFromGrowableXYArray(i,t.param,t.paramIndex[e+i]);for(let t=0;t<s;t++)this.param.transferFromGrowableXYArray(n+t,this.param,t);for(let i=0;i<n;i++)this.paramIndex[i]=t.paramIndex[e+i];for(let t=0;t<s;t++)this.paramIndex[n+t]=this.paramIndex[t]}if(this.color&&this.colorIndex&&t.color&&t.colorIndex){for(let i=0;i<n;i++)this.color[i]=t.color[t.colorIndex[e+i]];for(let t=0;t<s;t++)this.color[n+t]=this.color[t];for(let i=0;i<n;i++)this.colorIndex[i]=t.colorIndex[e+i];for(let t=0;t<s;t++)this.colorIndex[n+t]=this.colorIndex[t]}if(this.auxData&&t.auxData&&this.auxData.channels.length===t.auxData.channels.length){for(let i=0;i<this.auxData.channels.length;i++){const r=this.auxData.channels[i],o=t.auxData.channels[i],a=r.entriesPerValue;if(r.data.length===o.data.length)for(let i=0;i<r.data.length;i++){const c=r.data[i],h=o.data[i];for(let i=0;i<n;i++)c.copyValues(h,i,t.auxData.indices[e+i],a);for(let e=0;e<s;e++)c.copyValues(c,t.auxData.indices[n+e],e,a)}}for(let i=0;i<n;i++)this.auxData.indices[i]=t.auxData.indices[e+i];for(let t=0;t<s;t++)this.auxData.indices[n+t]=this.auxData.indices[t]}}static trimArray(t,e){t&&e<t.length&&(t.length=e)}trimAllIndexArrays(t){if(Di.trimArray(this.pointIndex,t),Di.trimArray(this.paramIndex,t),Di.trimArray(this.normalIndex,t),Di.trimArray(this.colorIndex,t),Di.trimArray(this.edgeVisible,t),this.auxData){Di.trimArray(this.auxData.indices,t);for(const e of this.auxData.channels)for(const i of e.data)Di.trimArray(i.values,e.entriesPerValue*t)}}resizeAllDataArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push(K.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<t;)this.normal.push(j.create());if(this.param)for(;this.param.length<t;)this.param.push(W.create());if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.auxData)for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0)}else if(t<this.point.length&&(this.point.resize(t),this.edgeVisible.length=t,this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.param&&this.param.resize(t),this.color&&(this.color.length=t),this.auxData))for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue}range(t,e){return(t=t||lt.createNull()).extendArray(this.point,e),t}reverseIndices(t){t&&Di.isValidFacetStartIndexArray(t)&&(Di.reverseIndices(t,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Di.reverseIndices(t,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Di.reverseIndices(t,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Di.reverseIndices(t,this.colorIndex,!0),Di.reverseIndices(t,this.edgeVisible,!1))}reverseIndicesSingleFacet(t,e){Di.reverseIndicesSingleFacet(t,e,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Di.reverseIndicesSingleFacet(t,e,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Di.reverseIndicesSingleFacet(t,e,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Di.reverseIndicesSingleFacet(t,e,this.colorIndex,!0),Di.reverseIndicesSingleFacet(t,e,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}tryTransformInPlace(t){return this.point.multiplyTransformInPlace(t),this.normal&&!t.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),void 0===this.auxData||this.auxData.tryTransformInPlace(t)}compress(){const t=Ci.clusterGrowablePoint3dArray(this.point);if(this.point=t.growablePackedPoints,t.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const t=Ci.clusterGrowablePoint3dArray(this.normal);this.normal=t.growablePackedPoints,t.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const t=Ci.clusterGrowablePoint2dArray(this.param);this.param=t.growablePackedPoints,t.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const t=Ci.clusterNumberArray(this.color);this.color=t.packedNumbers,t.updateIndices(this.colorIndex)}}static isValidFacetStartIndexArray(t){if(0===t.length)return!1;for(let e=0;e+1<t.length;e++)if(t[e]>=t[e+1])return!1;return!0}static reverseIndices(t,e,i){if(!e||0===e.length)return!0;if(e.length>0&&t[t.length-1]===e.length){for(let s=0;s+1<t.length;s++){let n=t[s],r=t[s+1];if(i)for(;r>n+2;){r--,n++;const t=e[n];e[n]=e[r],e[r]=t}else for(;r>n+1;){r--;const t=e[n];e[n]=e[r],e[r]=t,n++}}return!0}return!1}static reverseIndicesSingleFacet(t,e,i,s){if(!i||0===i.length)return!0;if(i.length>0&&e[e.length-1]===i.length&&t>=0&&t+1<e.length){let n=e[t],r=e[t+1];if(s)for(;r>n+2;){r--,n++;const t=i[n];i[n]=i[r],i[r]=t}else for(;r>n+1;){r--;const t=i[n];i[n]=i[r],i[r]=t,n++}return!0}return!1}}Di.planarityLocalRelTol=1e-13;class Ni extends Di{constructor(t,e){super(t.data.normalCount>0,t.data.paramCount>0,t.data.colorCount>0,t.twoSided),this._polyface=t,this._numWrap=e,t.data.auxData&&(this.auxData=t.data.auxData.createForVisitor()),this.reset(),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1}clientPolyface(){return this._polyface}setNumWrap(t){this._numWrap=t}get numEdgesThisFacet(){return this._numEdges}static create(t,e){return new Ni(t,e)}moveToReadIndex(t){return!!this._polyface.isValidFacetIndex(t)&&(this._currentFacetIndex=t,this._nextFacetIndex=t+1,this._numEdges=this._polyface.numEdgeInFacet(t),this.resizeAllDataArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap),!0)}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}tryGetNormalizedParameter(t,e){if(t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(t){return this.pointIndex[t]}clientParamIndex(t){return this.paramIndex?this.paramIndex[t]:-1}clientNormalIndex(t){return this.normalIndex?this.normalIndex[t]:-1}clientColorIndex(t){return this.colorIndex?this.colorIndex[t]:-1}clientAuxIndex(t){return this.auxData?this.auxData.indices[t]:-1}clearArrays(){void 0!==this.point&&(this.point.length=0),void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(t,e){this.point.pushFromGrowableXYZArray(t.point,e),this.color&&t.color&&e<t.color.length&&this.color.push(t.color[e]),this.param&&t.param&&e<t.param.length&&this.param.pushFromGrowableXYArray(t.param,e),this.normal&&t.normal&&e<t.normal.length&&this.normal.pushFromGrowableXYZArray(t.normal,e)}pushInterpolatedDataFrom(t,e,i,s){this.point.pushInterpolatedFromGrowableXYZArray(t.point,e,i,s),this.color&&t.color&&e<t.color.length&&s<t.color.length&&this.color.push(function(t,e,i){return Yi(t,e=J.clamp(e,0,1),i,0)|Yi(t,e,i,8)|Yi(t,e,i,16)|Yi(t,e,i,24)}(t.color[e],i,t.color[s])),this.param&&t.param&&e<t.param.length&&s<t.param.length&&this.param.pushInterpolatedFromGrowableXYArray(t.param,e,i,s),this.normal&&t.normal&&e<t.normal.length&&s<t.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(t.normal,e,i,s)}}function Yi(t,e,i,s){return t=t>>>s&255,i=i>>>s&255,(255&Math.floor(t+e*(i-t)))<<s}class Oi extends Ni{constructor(t,e,i){super(t,i),this._parentFacetIndices=e.slice(),this._nextActiveIndex=0}static createSubsetVisitor(t,e,i){return new Oi(t,e,i)}moveToReadIndex(t){return t>=0&&t<=this._parentFacetIndices.length&&(this._nextActiveIndex=t,super.moveToReadIndex(this._parentFacetIndices[t++]))}moveToNextFacet(){return!!(this._nextActiveIndex<this._parentFacetIndices.length&&this.moveToReadIndex(this._nextActiveIndex))&&(this._nextActiveIndex++,!0)}reset(){this._nextActiveIndex=0}parentFacetIndex(t){if(t>=0&&t<=this._nextActiveIndex)return this._parentFacetIndices[t]}}class Bi{get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(t,e){this._paramDistanceRange=t,this._paramRange=e}static createNull(){return new Bi(ut.createNull(),ut.createNull())}clone(t){return t?(this._paramDistanceRange.clone(t._paramDistanceRange),this._paramRange.clone(t._paramRange),t):new Bi(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(t,e,i){i=i||W.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:this._paramDistanceRange.low.x+(t-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/s.x,i.y=0===s.y?e:this.paramDistanceRange.low.y+(e-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/s.y,i}convertParamXYToNormalized(t,e,i){i=i||W.create();const s=this._paramRange.high.minus(this._paramRange.low);return i.x=0===s.x?t:(t-this._paramRange.low.x)/s.x,i.y=0===s.y?e:(e-this._paramRange.low.y)/s.y,i}convertParamToDistance(t,e){return this.convertParamXYToDistance(t.x,t.y,e)}convertParamToNormalized(t,e){return this.convertParamXYToNormalized(t.x,t.y,e)}scaleDistances(t){this._paramDistanceRange.low.x*=t,this._paramDistanceRange.low.y*=t,this._paramDistanceRange.high.x*=t,this._paramDistanceRange.high.y*=t}setParamDistanceRangeFromNewFaceData(t,e,i){const s=W.create(),n=W.create();this.setNull();let r=0;const o=Ni.create(t,0);if(!o.moveToReadIndex(e)||i<=e)return!1;do{const t=o.numEdgesThisFacet,e=o.point,i=[],a=o.param,c=[];if(!a)return!1;a.extendRange(this._paramRange);const h=G.create(),l=G.create();for(let o=0;o<t;o++){if(i[2]=o,c[2]=o,o>1){a.vectorIndexIndex(c[1],c[0],h),a.vectorIndexIndex(c[1],c[2],l);const t=e.getPoint3dAtUncheckedPointIndex(i[0]).minus(e.getPoint3dAtUncheckedPointIndex(i[1])),o=e.getPoint3dAtUncheckedPointIndex(i[1]).minus(e.getPoint3dAtUncheckedPointIndex(i[2])),d=Math.abs(h.x*l.y-l.x*h.y);if(d){const e=K.createFrom(t);e.scaleInPlace(l.y),e.addScaledInPlace(o,-h.y);const i=K.createFrom(o);i.scaleInPlace(h.x),i.addScaledInPlace(t,-l.x);const a=W.create(e.magnitude()/d,i.magnitude()/d);s.x+=a.x,s.y+=a.y,n.x+=a.x*a.x,n.y+=a.y*a.y,r++}}c[0]=c[1],c[1]=c[2],i[0]=i[1],i[1]=i[2]}}while(o.moveToNextFacet()&&o.currentReadIndex()<i);if(0!==r){const t=W.create(s.x/r,s.y/r),e=W.create(Math.sqrt(Math.abs(n.x/r-t.x*t.x)),Math.sqrt(Math.abs(n.y/r-t.y*t.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((t.x+e.x)*(this._paramRange.high.x-this._paramRange.low.x),(t.y+e.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class Vi extends Rt{constructor(t){super(),this.geometryCategory="polyface",this.data=t}get twoSided(){return this.data.twoSided}set twoSided(t){this.data.twoSided=t}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(t){this.data.expectedClosure=t}static areIndicesValid(t,e,i,s,n){if(void 0===t&&void 0===s)return!0;if(!t||!s)return!1;if(e<0||e>=t.length)return!1;if(i<e||i>t.length)return!1;for(let s=e;s<i;s++)if(t[s]<0||t[s]>=n)return!1;return!0}get facetCount(){}}class Li extends Vi{isSameGeometryClass(t){return t instanceof Li}isAlmostEqual(t){return t instanceof Li&&this.data.isAlmostEqual(t.data)&&ie.isExactEqual(this._facetStart,t._facetStart)&&ie.isExactEqual(this._facetToFaceData,t._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(t){return!!this.data.tryTransformInPlace(t)&&(t.matrix.determinant()<0&&(this.reverseIndices(),this.reverseNormals()),!0)}reverseSingleFacet(t){this.data.reverseIndicesSingleFacet(t,this._facetStart)}clone(){return new Li(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(t){const e=this._facetToFaceData[t];if(!(e>=this.data.face.length))return this.data.face[e]}constructor(t,e,i){super(t),e?this._facetStart=e.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=i?i.slice():[]}addIndexedPolyface(t,e,i){const s=t.facetCount,n=this.data.point.length,r=K.create();for(let e=0;e<t.data.point.length;e++)t.data.point.getPoint3dAtUncheckedPointIndex(e,r),i?(i.multiplyPoint3d(r,r),this.addPoint(r)):this.addPoint(r);for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e>s?e-1:r-1]);else for(let e=s;e<r;e++)this.addPointIndex(n+t.data.pointIndex[e],t.data.edgeVisible[e]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==t.data.param&&void 0!==t.data.paramIndex){const i=this.data.param.length;this.data.param.pushFromGrowableXYArray(t.data.param);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addParamIndex(i+t.data.paramIndex[e]);else for(let e=s;e<r;e++)this.addParamIndex(i+t.data.paramIndex[e])}}if(void 0!==this.data.normal&&void 0!==t.data.normal&&void 0!==t.data.normalIndex){const n=this.data.normal.length;for(let s=0;s<t.data.normal.length;s++){const n=t.data.normal.getVector3dAtCheckedVectorIndex(s);i&&i.multiplyVector(n,n),e&&n.scaleInPlace(-1),this.addNormal(n)}for(let i=0;i<s;i++){const s=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >s;)this.addNormalIndex(n+t.data.normalIndex[e]);else for(let e=s;e<r;e++)this.addNormalIndex(n+t.data.normalIndex[e])}}if(void 0!==this.data.color&&void 0!==t.data.color&&void 0!==t.data.colorIndex){const i=this.data.color.length;for(const e of t.data.color)this.addColor(e);for(let n=0;n<s;n++){const s=t._facetStart[n],r=t._facetStart[n+1];if(e)for(let e=r;e-- >s;)this.addColorIndex(i+t.data.colorIndex[e]);else for(let e=s;e<r;e++)this.addColorIndex(i+t.data.colorIndex[e])}}if(0!==t.data.face.length){const e=this.data.face.length;for(const e of t.data.face){const t=e.clone();this.data.face.push(t)}for(const i of t._facetToFaceData)this._facetToFaceData.push(e+i)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(t=!1,e=!1,i=!1,s=!1){return new Li(new Di(t,e,i,s))}addPoint(t,e){if(void 0!==e){const i=this.data.point.distanceIndexToPoint(e,t);if(void 0!==i&&J.isSmallMetricDistance(i))return e}return this.data.point.pushXYZ(t.x,t.y,t.z),this.data.point.length-1}addPointXYZ(t,e,i){return this.data.point.pushXYZ(t,e,i),this.data.point.length-1}addParam(t){return this.data.param||(this.data.param=new me),this.data.param.push(t),this.data.param.length-1}addParamUV(t,e,i,s){return this.data.param||(this.data.param=new me),void 0!==i&&this.data.isAlmostEqualParamIndexUV(i,t,e)?i:void 0!==s&&this.data.isAlmostEqualParamIndexUV(s,t,e)?s:(this.data.param.pushXY(t,e),this.data.param.length-1)}addNormal(t,e,i){if(void 0!==this.data.normal){let s;if(void 0!==e&&(s=this.data.normal.distanceIndexToPoint(e,t),void 0!==s&&J.isSmallMetricDistance(s)))return e;if(void 0!==i&&(s=this.data.normal.distanceIndexToPoint(i,t),void 0!==s&&J.isSmallMetricDistance(s)))return i;if(void 0!==e||void 0!==i){const e=this.data.normal.length-1;if(s=this.data.normal.distanceIndexToPoint(e,t),void 0!==s&&J.isSmallMetricDistance(s))return e}}return this.addNormalXYZ(t.x,t.y,t.z)}addNormalXYZ(t,e,i){return this.data.normal||(this.data.normal=new it),this.data.normal.pushXYZ(t,e,i),this.data.normal.length-1}addColor(t){return this.data.color||(this.data.color=[]),this.data.color.push(t),this.data.color.length-1}addPointIndex(t,e=!0){this.data.pointIndex.push(t),this.data.edgeVisible.push(e)}addNormalIndex(t){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(t)}addParamIndex(t){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(t)}addColorIndex(t){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(t)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}terminateFacet(t=!0){const e=this._facetStart.length-1,i=this._facetStart[e],s=this.data.pointIndex.length;if(t){const t=[];if(s<i+2&&t.push("Less than 3 indices in open facet"),this.data.normalIndex&&this.data.normalIndex.length!==s&&t.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==s&&t.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==s&&t.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==s&&t.push("visibleIndex count must equal pointIndex count"),Vi.areIndicesValid(this.data.normalIndex,i,s,this.data.normal,this.data.normal?this.data.normal.length:0)||t.push("invalid normal indices in open facet"),t.length>0)return this.cleanupOpenFacet(),t}this._facetStart.push(s)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}numEdgeInFacet(t){return this.isValidFacetIndex(t)?this._facetStart[t+1]-this._facetStart[t]:0}isValidFacetIndex(t){return t>=0&&t+1<this._facetStart.length}facetIndex0(t){return this._facetStart[t]}facetIndex1(t){return this._facetStart[t+1]}createVisitor(t=0){return Ni.create(this,t)}range(t,e){return this.data.range(e,t)}extendRange(t,e){this.data.range(t,e)}getFaceDataByFacetIndex(t){return this.data.face[this._facetToFaceData[t]]}setNewFaceData(t=0){const e=this._facetToFaceData.length;if(e>=this._facetStart.length)return!1;0===t&&(t=this._facetStart.length);const i=Bi.createNull(),s=Ni.create(this,0);if(!s.moveToReadIndex(e))return!1;const n=void 0!==this.data.param,r=i.paramRange.isNull&&n;do{r&&void 0!==s.param&&s.param.extendRange(i.paramRange)}while(s.moveToNextFacet()&&s.currentReadIndex()<t);n&&0!==this.data.param.length&&i.paramDistanceRange.isNull&&i.setParamDistanceRangeFromNewFaceData(this,e,t),this.data.face.push(i);const o=this.data.face.length-1;for(let e=this._facetToFaceData.length;e<t;e++)this._facetToFaceData.push(0===this._facetStart[e]?0:o);return!0}dispatchToGeometryHandler(t){return t.handleIndexedPolyface(this)}}class Ui{constructor(t=J.smallMetricDistance,e=J.smallMetricDistance){this._chains=[],this._endPointShiftTolerance=t,this._endPointHitTolerance=J.smallMetricDistance,this._planarityTolerance=e}findAnyChainToConnect(t,e,i=-1){for(let s=0;s<this._chains.length;s++){if(i===s)continue;const n=this._chains[s];if(this._xyzWork1=n[n.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!0};if(this._xyzWork1=n[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:s,atEnd:!1}}}captureCurvePrimitive(t){this.attachPrimitiveToAnyChain(t,this._endPointHitTolerance)||this.attachPrimitiveToAnyChain(t,this._endPointShiftTolerance)||this._chains.push([t])}captureCurve(t){if(t instanceof $t)this.captureCurvePrimitive(t);else if(t instanceof Me&&void 0!==t.children)for(const e of t.children)this.captureCurve(e)}attachPrimitiveToAnyChain(t,e){if(t){this._xyzWork0=t.startPoint(this._xyzWork0);let i=this.findAnyChainToConnect(this._xyzWork0,e);if(i){if(i.atEnd){const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),Zi.moveHeadOrTail(s[n],s[n+1],this._endPointShiftTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{t.reverseInPlace();const s=this._chains[i.chainIndex];return s.splice(0,0,t),Zi.moveHeadOrTail(s[0],s[1],this._endPointShiftTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}if(this._xyzWork0=t.endPoint(this._xyzWork0),i=this.findAnyChainToConnect(this._xyzWork0,e),i){if(i.atEnd){t.reverseInPlace();const s=this._chains[i.chainIndex],n=s.length-1;return this._chains[i.chainIndex].push(t),Zi.moveHeadOrTail(s[n],s[n+1],this._endPointShiftTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{const s=this._chains[i.chainIndex];return s.splice(0,0,t),Zi.moveHeadOrTail(s[0],s[1],this._endPointShiftTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}}return!1}mergeChainsForwardForward(t,e){const i=this._chains[t],s=this._chains[e];for(const t of s)i.push(t);s.length=0;const n=this._chains.length-1;e!==n?(this._chains[e]=this._chains[n],this._chains.pop()):this._chains.pop()}reverseChain(t){const e=this._chains[t];e.reverse();for(const t of e)t.reverseInPlace()}searchAndMergeChainIndex(t,e){const i=this._chains[t],s=i.length-1;this._xyzWork0=i[0].startPoint(this._xyzWork0);let n=this.findAnyChainToConnect(this._xyzWork0,e,t);return n?(n.atEnd||this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(n.chainIndex,t)):(this._xyzWork0=i[s].endPoint(this._xyzWork0),n=this.findAnyChainToConnect(this._xyzWork0,e,t),n?(n.atEnd&&this.reverseChain(n.chainIndex),void this.mergeChainsForwardForward(t,n.chainIndex)):void 0)}promoteArrayToCurves(t,e){if(0!==t.length){if(e){const e=t[0],i=t[t.length-1];if(Ui._staticPointA=e.startPoint(Ui._staticPointA),Ui._staticPointB=i.endPoint(Ui._staticPointB),Ui._staticPointA.distance(Ui._staticPointB)<this._endPointShiftTolerance&&(Zi.moveHeadOrTail(i,e,this._endPointShiftTolerance),Ui._staticPointA=e.startPoint(Ui._staticPointA),Ui._staticPointB=i.endPoint(Ui._staticPointB)),Ui._staticPointA.isAlmostEqual(Ui._staticPointB)){const e=hr.createRightHandedLocalToWorld(t);if(e){const i=e.inverse();if(i){const e=Gn.curveArrayRange(t,i);if(void 0!==this._planarityTolerance&&e.zLength()<=this._planarityTolerance)return Ue.createArray(t)}}return qe.createArray(t)}}return 1===t.length?t[0]:qe.createArray(t)}}chainToLineString3d(t){if(0===t.length)return;const e=ye.create();for(const i of t)i.emitStrokes(e),e.removeDuplicatePoints();return e}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=Ee.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}announceChainsAsLineString3d(t){const e=this._chains;if(1===e.length){const i=this.chainToLineString3d(e[0]);i&&t(i)}else if(e.length>1)for(const i of e){const e=this.chainToLineString3d(i);e&&t(e)}}}class Zi{static sumLengths(t){let e=0;if(t instanceof $t)e+=t.curveLength();else if(t instanceof Me)e+=t.sumLengths();else if(Array.isArray(t))for(const i of t)e+=this.sumLengths(i);return e}static extendRange(t,e){if(e instanceof Rt)e.extendRange(t);else if(Array.isArray(e))for(const i of e)this.extendRange(t,i);return t}static appendOffsets(t,e,i){let s=0;if(t instanceof $t){const n=$n.constructCurveXYOffset(qe.create(t),e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof Ue||t instanceof qe){const n=$n.constructCurveXYOffset(t,e);n&&(s+=this.sumLengths(n),i.push(n))}else if(t instanceof Ee)for(const n of t.children)s+=this.appendOffsets(n,e,i);else if(Array.isArray(t))for(const n of t)s+=this.appendOffsets(n,e,i);return s}static collectInsideAndOutsideOffsets(t,e,i){const s=new Ui(i);for(const e of t)s.captureCurve(e);const n=s.grabResult(!0),r=[],o=[];return Zi.appendOffsets(n,e,r)>Zi.appendOffsets(n,-e,o)?{outsideOffsets:r,insideOffsets:o,chains:n}:{insideOffsets:r,outsideOffsets:o,chains:n}}static collectChains(t,e,i=J.smallMetricDistance){const s=new Ui(e,i);for(const e of t)s.captureCurve(e);return s.grabResult(!0)}static simpleEndPointMove(t,e,i){if(t instanceof tr)return e?t.point1Ref.setFrom(i):t.point0Ref.setFrom(i),!0;if(t instanceof ye&&t.numPoints()>0){const s=e?t.numPoints()-1:0;return t.packedPoints.setAtCheckedPointIndex(s,i),!0}return!1}static moveHeadOrTail(t,e,i){const s=t.endPoint(),n=e.startPoint(),r=.001*J.smallMetricDistance;if(s.distanceXY(n)<r)return!0;if(this.simpleEndPointMove(e,!1,s)||this.simpleEndPointMove(t,!0,n))return!0;const o=Le.intersectionXYPairs(t,!0,e,!0);for(const r of o){const o=r.detailA,a=r.detailB,c=o.point.distanceXY(s),h=a.point.distanceXY(n);if(c<5*i&&h<5*i&&t instanceof Pe&&e instanceof Pe){const i=t.sweep.fractionToRadians(o.fraction);t.sweep.setStartEndRadians(t.sweep.startRadians,i);const s=e.sweep.fractionToRadians(a.fraction);return e.sweep.setStartEndRadians(s,e.sweep.endRadians),!0}}return!1}}class qi{constructor(t=0){this._parentArray=[];for(let e=0;e<t;e++)this._parentArray.push(e)}get length(){return this._parentArray.length}isValidIndex(t){return 0<=t&&t<this._parentArray.length}addLeaf(){const t=this._parentArray.length;return this._parentArray.push(t),t}findRoot(t){if(!this.isValidIndex(t))return t;let e=t,i=this._parentArray[t];for(;i!==e;)e=i,i=this._parentArray[e];const s=e;for(e=t;e!==s;)i=this._parentArray[e],this._parentArray[e]=s,e=i;return s}mergeSubsets(t,e){if(!this.isValidIndex(t)||!this.isValidIndex(e))return t;const i=this.findRoot(t),s=this.findRoot(e);return i!==s&&(this._parentArray[i]=s),this.findRoot(t)}askParent(t){return this.isValidIndex(t)?this._parentArray[t]:t}countRoots(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t++;return t}countNonTrivialPaths(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++){const e=this._parentArray[i];e!==i&&this._parentArray[e]!==e&&t++}return t}collectRootIndices(){const t=[],e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t.push(i);return t}}class Wi{constructor(t,e){this._originalFreeMasks=t,this._freeMasks=t,this._firstFreeMask=e}static create(t){let e=0,i=1;for(let s=0;s<32;s++){if(0!=(i&t)){e=i;break}i<<=1}if(0!==e)return new Wi(t,e)}grabMask(){let t=this._firstFreeMask;if(0===this._freeMasks)return 0;for(;!(t&this._freeMasks);)t<<=1;return this._freeMasks&=~t,t}dropMask(t){t&=this._originalFreeMasks,this._freeMasks|=t}}(V=k||(k={}))[V.EXTERIOR=1]="EXTERIOR",V[V.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",V[V.PRIMARY_EDGE=4]="PRIMARY_EDGE",V[V.VISITED=16]="VISITED",V[V.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",V[V.NULL_FACE=512]="NULL_FACE",V[V.NULL_MASK=0]="NULL_MASK",V[V.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",V[V.ALL_MASK=4294967295]="ALL_MASK";class Gi{get id(){return this._id}get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}faceStepY(t){let e=this;if(t>0)for(let i=0;i<t;i++)e=e.faceSuccessor;else if(t<0)for(let i=0;i>t;i--)e=e.facePredecessor;return e.y}static createHalfEdgePair(t){const e=new Gi,i=new Gi;return t&&(t.push(e),t.push(i)),Gi.setFaceLinks(e,i),Gi.setFaceLinks(i,e),Gi.setEdgeMates(e,i),e}static createHalfEdgePairWithCoordinates(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0,c){const h=Gi.createHalfEdgePair(c),l=h._edgeMate;return h.x=t,h.y=e,h.z=i,h.i=s,l.x=n,l.y=r,l.z=o,l.i=a,h}static setFaceLinks(t,e){t._faceSuccessor=e,e._facePredecessor=t}static setEdgeMates(t,e){t._edgeMate=e,e._edgeMate=t}static splitEdge(t,e=0,i=0,s=0,n=0,r){const o=new Gi(e,i,s,n),a=new Gi(e,i,s,n);if(r&&(r.push(o),r.push(a)),void 0===t)o._faceSuccessor=o._facePredecessor=o,a._faceSuccessor=a._facePredecessor=a,Gi.setEdgeMates(o,a);else{const e=t._faceSuccessor,i=t._edgeMate,s=i._faceSuccessor;Gi.setFaceLinks(o,e),Gi.setFaceLinks(t,o),Gi.setFaceLinks(i,a),Gi.setFaceLinks(a,s),Gi.setEdgeMates(o,i),Gi.setEdgeMates(a,t),this.transferEdgeProperties(t,o),this.transferEdgeProperties(i,a)}return o}static splitEdgeCreateSliverFace(t,e){const i=new Gi,s=new Gi,n=t.edgeMate;return e&&(e.push(i),e.push(s)),i._faceSuccessor=i._facePredecessor=s,s._faceSuccessor=s._facePredecessor=i,Gi.setEdgeMates(i,n),Gi.setEdgeMates(s,t),i.copyDataFrom(t,!0,!0,!1,!1),s.copyDataFrom(n,!0,!0,!1,!1),i}static transferEdgeProperties(t,e){e.edgeTag=t.edgeTag;for(const i of this._edgePropertyMasks)t.getMask(i)?e.setMask(i):e.clearMask(i)}constructor(t=0,e=0,i=0,s=0){this._id=Gi._totalNodesCreated++,this.i=s,this.maskBits=0,this.x=t,this.y=e,this.z=i,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(t){this.maskBits|=t}getMask(t){return this.maskBits&t}clearMask(t){this.maskBits&=~t}setMaskAroundVertex(t){let e=this;do{e.setMask(t),e=e.vertexSuccessor}while(e!==this)}setXYZAroundVertex(t,e,i){let s=this;do{s.x=t,s.y=e,s.z=i,s=s.vertexSuccessor}while(s!==this)}setMaskAroundFace(t){let e=this;do{e.setMask(t),e=e.faceSuccessor}while(e!==this)}setMaskAroundEdge(t){this.setMask(t),this.edgeMate.setMask(t)}clearMaskAroundEdge(t){this.clearMask(t),this.edgeMate.clearMask(t)}countEdgesAroundFace(){let t=0,e=this;do{t++,e=e.faceSuccessor}while(e!==this);return t}findAroundVertex(t){let e=this;do{if(e===t)return!0;e=e.vertexSuccessor}while(e!==this);return!1}findAroundFace(t){let e=this;do{if(e===t)return!0;e=e.faceSuccessor}while(e!==this);return!1}isMaskedAroundFace(t,e=!0){let i=this;if(e)do{if(!i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);else do{if(i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);return!0}setMaskAndEdgeTagAroundFace(t,e,i=!1){let s=this;do{if(s.setMask(t),s.edgeTag=e,i){const i=s.edgeMate;i.edgeTag=e,i.setMask(t)}s=s.faceSuccessor}while(s!==this)}countEdgesAroundVertex(){let t=0,e=this;do{t++,e=e.vertexSuccessor}while(e!==this);return t}countMaskAroundFace(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.faceSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.faceSuccessor}while(s!==this);return i}countMaskAroundVertex(t,e=!0){let i=0,s=this;if(e)do{s.isMaskSet(t)&&i++,s=s.vertexSuccessor}while(s!==this);else do{s.isMaskSet(t)||i++,s=s.vertexSuccessor}while(s!==this);return i}findMaskAroundVertex(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.vertexSuccessor}while(i!==this)}findMaskAroundFace(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.faceSuccessor}while(i!==this)}findMaskAroundEdge(t,e=!0){if(this.isMaskSet(t)===e)return this;const i=this.edgeMate;return i.isMaskSet(t)===e?i:void 0}testAndSetMask(t){const e=this.maskBits&t;return this.maskBits|=t,e}setXYZFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}setXYZ(t){this.x=t.x,this.y=t.y,this.z=t.z}isMaskSet(t){return 0!=(this.maskBits&t)}static filterIsMaskOn(t,e){return t.isMaskSet(e)}static filterIsMaskOff(t,e){return!t.isMaskSet(e)}static createEdgeXYXY(t,e,i,s,n,r){const o=new Gi(e,i),a=new Gi(n,r);return o._faceSuccessor=o._facePredecessor=o._edgeMate=a,a._faceSuccessor=a._facePredecessor=a._edgeMate=o,o._id=t,a._id=s,o}static pinch(t,e){if(t!==e){const i=t._facePredecessor,s=e._facePredecessor;e._facePredecessor=i,t._facePredecessor=s,s._faceSuccessor=t,i._faceSuccessor=e}}yankFromVertexLoop(){const t=this.edgeMate.faceSuccessor;if(t!==this)return Gi.pinch(this,t),t}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(t){return t}static nodeToId(t){return t.id}static nodeToIdString(t){return t.id.toString()}static nodeToIdMaskXY(t){return{id:t.id,mask:Gi.nodeToMaskString(t),xy:[t.x,t.y]}}static nodeToIdXYString(t){return`${t.id.toString()}+${Gi.nodeToMaskString(t)}[${t.x},${t.y}]`}static nodeToIdXYZString(t){return`[${t.id.toString()}: ${t.x},${t.y},${t.z}]`}static nodeToMaskString(t){let e="";return t.isMaskSet(k.BOUNDARY_EDGE)&&(e+="B"),t.isMaskSet(k.PRIMARY_EDGE)&&(e+="P"),t.isMaskSet(k.EXTERIOR)&&(e+="X"),t.isMaskSet(k.NULL_FACE)&&(e+="N"),e}static nodeToXY(t){return[t.x,t.y]}vectorToFaceSuccessorXY(t){return G.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,t)}vectorToFaceSuccessor(t){const e=this.faceSuccessor;return j.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}vectorToFacePredecessor(t){const e=this.facePredecessor;return j.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}static isNodeVisibleInSector(t,e){if(e.vertexSuccessor===e)return!0;const i=e.faceSuccessor,s=e.facePredecessor,n=this.crossProductXYToTargets(e,i,t),r=this.crossProductXYToTargets(s,e,t);if(n>0&&r>0)return!0;const o=this.crossProductXYToTargets(s,e,i);return r<=0&&n<=0?0===r&&0===n&&0===o&&(s===i&&e.vertexSuccessor!==e?t===i:Gi.dotProductNodeToNodeVectorsXY(s,e,e,t)>0):0===o&&0!==r&&0!==n?s!==i:o<0}static crossProductXYToTargets(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static dotProductNodeToNodeVectorsXY(t,e,i,s){return J.dotProductXYXY(e.x-t.x,e.y-t.y,s.x-i.x,s.y-i.y)}static crossProductXYAlongChain(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-e.x,i.y-e.y)}static isSectorConvex(t,e,i){const s=Gi.crossProductXYAlongChain(t,e,i);return s>0||!(s<0)&&Gi.dotProductNodeToNodeVectorsXY(t,e,e,i)>0}isSectorConvex(){return Gi.isSectorConvex(this.facePredecessor,this,this.faceSuccessor)}isFaceConvex(){let t=this;do{if(!t.isSectorConvex())return!1;t=t.faceSuccessor}while(t!==this);return!0}isolateEdge(){const t=this.edgeMate;this.yankFromVertexLoop(),t.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(t){return this.y<t.y||!(this.y>t.y)&&this.x<t.x}static testNodeMaskNotExterior(t){return!t.isMaskSet(k.EXTERIOR)}static testMateMaskExterior(t){return t.edgeMate.isMaskSet(k.EXTERIOR)}static sectorSweepRadiansXYZ(t,e){const i=t.faceSuccessor,s=t.facePredecessor;return Z.orientedRadiansBetweenVectorsXYZ(i.x-t.x,i.y-t.y,i.z-t.z,s.x-t.x,s.y-t.y,s.z-t.z,e.x,e.y,e.z,!0)}static testFacePositiveAreaXY(t){return t.countEdgesAroundFace()>2&&t.signedFaceArea()>0}isEqualXY(t){return this.x===t.x&&this.y===t.y}distanceXY(t){return J.distanceXYXY(this.x,this.y,t.x,t.y)}distanceXYZ(t){return J.distanceXYZXYZ(this.x,this.y,this.z,t.x,t.y,t.z)}collectAroundFace(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.faceSuccessor}while(i!==this);return e}collectMaskedEdgesAroundVertex(t,e=!0,i){void 0===i?i=[]:i.length=0;let s=this;do{s.isMaskSet(t)===e&&i.push(s),s=s.vertexSuccessor}while(s!==this);return i}collectAroundVertex(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.vertexSuccessor}while(i!==this);return e}sumAroundFace(t){let e=this,i=0;do{i+=t(e),e=e.faceSuccessor}while(e!==this);return i}sumAroundVertex(t){let e=this,i=0;do{i+=t(e),e=e.vertexSuccessor}while(e!==this);return i}clearMaskAroundFace(t){let e=this;do{e.clearMask(t),e=e.faceSuccessor}while(e!==this)}clearMaskAroundVertex(t){let e=this;do{e.clearMask(t),e=e.vertexSuccessor}while(e!==this)}signedFaceArea(){let t=0;const e=this.y;let i,s,n=0,r=0,o=this.x,a=this;do{s=a.faceSuccessor,i=s.x,r=s.y-e,t+=(o-i)*(n+r),o=i,n=r,a=s}while(a!==this);return.5*t}fractionToPoint2d(t,e){const i=this.faceSuccessor;return W.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,e)}fractionToPoint3d(t,e){const i=this.faceSuccessor;return K.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,this.z+(i.z-this.z)*t,e)}fractionAlongAndPerpendicularToPoint2d(t,e,i){const s=this.faceSuccessor,n=s.x-this.x,r=s.y-this.y;return W.create(this.x+n*t-r*e,this.y+r*t+n*e,i)}getPoint3d(t){return K.create(this.x,this.y,this.z,t)}getPoint2d(t){return W.create(this.x,this.y,t)}getVector3dAlongEdge(t){const e=this.faceSuccessor;return j.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}getVector2dAlongEdge(t){const e=this.faceSuccessor;return G.create(e.x-this.x,e.y-this.y,t)}fractionToX(t){const e=this.faceSuccessor;return this.x+(e.x-this.x)*t}fractionToY(t){const e=this.faceSuccessor;return this.y+(e.y-this.y)*t}fractionToZ(t){const e=this.faceSuccessor;return this.z+(e.z-this.z)*t}static transverseIntersectionFractions(t,e,i){const s=t.faceSuccessor,n=e.faceSuccessor;if(i||(i=G.create()),Ct.linearSystem2d(s.x-t.x,e.x-n.x,s.y-t.y,e.y-n.y,e.x-t.x,e.y-t.y,i))return i}static horizontalScanFraction(t,e){const i=t.faceSuccessor,s=i.y-t.y;return J.isSameCoordinate(e,t.y)&&J.isSameCoordinate(e,i.y)?t:J.isSameCoordinate(s,0)?void 0:J.conditionalDivideFraction(e-t.y,s)}static horizontalScanFraction01(t,e){const i=t.faceSuccessor,s=i.y-t.y;if(J.isSameCoordinate(e,t.y)&&J.isSameCoordinate(e,i.y))return;if(J.isSameCoordinate(s,0))return;const n=J.conditionalDivideFraction(e-t.y,s);return void 0!==n&&n>=0&&n<=1?n:void 0}copyDataFrom(t,e,i,s,n){e&&(this.x=t.x,this.y=t.y,this.z=t.z),i&&(this.i=t.i),s&&(Gi.transferEdgeProperties(t,this),this.edgeTag=t.edgeTag),n&&(this.faceTag=t.faceTag)}}Gi._edgePropertyMasks=[k.BOUNDARY_EDGE,k.EXTERIOR,k.PRIMARY_EDGE,k.NULL_FACE],Gi._totalNodesCreated=0;class Ji{constructor(){this._numNodesCreated=0,this.allHalfEdges=[],this._maskManager=Wi.create(k.ALL_GRAB_DROP_MASKS)}grabMask(t=!0){const e=this._maskManager.grabMask();return t&&this.clearMask(e),e}dropMask(t){this._maskManager.dropMask(t)}createEdgeXYZXYZ(t=0,e=0,i=0,s=0,n=0,r=0,o=0,a=0){return Gi.createHalfEdgePairWithCoordinates(t,e,i,s,n,r,o,a,this.allHalfEdges)}createEdgeIdId(t=0,e=0){return Gi.createHalfEdgePairWithCoordinates(0,0,0,t,0,0,0,e,this.allHalfEdges)}createEdgeXYZHalfEdge(t=0,e=0,i=0,s=0,n,r=0){const o=Gi.createHalfEdgePairWithCoordinates(t,e,i,s,n.x,n.y,n.z,r,this.allHalfEdges),a=o.faceSuccessor;return Gi.pinch(n,a),o}createEdgeHalfEdgeHalfEdge(t,e,i,s=0){const n=Gi.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges),r=n.faceSuccessor;return Gi.pinch(t,n),Gi.pinch(i,r),n}createEdgeXYAndZ(t,e,i,s){return Gi.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,s,this.allHalfEdges)}splitEdge(t,e=0,i=0,s=0,n=0){return Gi.splitEdge(t,e,i,s,n,this.allHalfEdges)}splitEdgeCreateSliverFace(t){return Gi.splitEdgeCreateSliverFace(t,this.allHalfEdges)}splitEdgeAtFraction(t,e){return Gi.splitEdge(t,t.fractionToX(e),t.fractionToY(e),t.fractionToZ(e),0,this.allHalfEdges)}decommission(){for(const t of this.allHalfEdges)t.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(t,e,i,s){const n=Gi.createEdgeXYXY(this._numNodesCreated,t,e,this._numNodesCreated+1,i,s);return this._numNodesCreated+=2,this.allHalfEdges.push(n),this.allHalfEdges.push(n.faceSuccessor),n}clearMask(t){for(const e of this.allHalfEdges)e.maskBits&=~t}setMask(t){for(const e of this.allHalfEdges)e.maskBits|=t}reverseMask(t){for(const e of this.allHalfEdges)e.maskBits^=t}countMask(t){let e=0;for(const i of this.allHalfEdges)i.isMaskSet(t)&&e++;return e}collectSegments(){const t=[];for(const e of this.allHalfEdges)e.id<e.edgeMate.id&&t.push(tr.create(K.create(e.x,e.y),K.create(e.faceSuccessor.x,e.faceSuccessor.y)));return t}countVertexLoops(){this.clearMask(k.VISITED);let t=0;return this.announceVertexLoops(((e,i)=>(t++,!0))),t}countFaceLoops(){this.clearMask(k.VISITED);let t=0;return this.announceFaceLoops(((e,i)=>(t++,!0))),t}countFaceLoopsWithMaskFilter(t,e){this.clearMask(k.VISITED);let i=0;return this.announceFaceLoops(((s,n)=>(t(n,e)&&i++,!0))),i}collectFaceLoops(){const t=[];return this.announceFaceLoops(((e,i)=>(t.push(i),!0))),t}collectVertexLoops(){this.clearMask(k.VISITED);const t=[];for(const e of this.allHalfEdges)e.getMask(k.VISITED)||(t.push(e),e.setMaskAroundVertex(k.VISITED));return t}announceFaceLoops(t){this.clearMask(k.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(k.VISITED)&&(e.setMaskAroundFace(k.VISITED),!t(this,e)))break}announceEdges(t){this.clearMask(k.VISITED);for(const e of this.allHalfEdges){if(e.getMask(k.VISITED))continue;const i=e.edgeMate;if(e.setMask(k.VISITED),i.setMask(k.VISITED),!t(this,e))break}}announceVertexLoops(t){this.clearMask(k.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(k.VISITED)&&(e.setMaskAroundVertex(k.VISITED),!t(this,e)))break}announceNodes(t){for(const e of this.allHalfEdges)if(!t(this,e))break}countNodes(){return this.allHalfEdges.length}transformInPlace(t){for(const e of this.allHalfEdges)t.multiplyXYAndZInPlace(e)}yankAndDeleteEdges(t){const e=this.allHalfEdges.length;let i=0;for(let s=0;s<e;s++){const e=this.allHalfEdges[s];t(e)?e.isolateEdge():this.allHalfEdges[i++]=e}const s=e-i;return this.allHalfEdges.length=i,s}deleteIsolatedEdges(){const t=this.allHalfEdges.length;let e=0;for(let i=0;i<t;i++){const t=this.allHalfEdges[i];t.isIsolatedEdge||(this.allHalfEdges[e++]=t)}const i=t-e;return this.allHalfEdges.length=e,i}}function Hi(t){return t}function Ki(t,e,i){return ji(e,(e=>i(t,e)))}function ji(t,e){let i=0,s=t.length;for(;i<s;){const n=Math.floor((i+s)/2),r=e(t[n]);if(0===r)return{index:n,equal:!0};r<0?s=n:i=n+1}return{index:i,equal:!1}}!function(t){t[t.Allow=0]="Allow",t[t.Retain=1]="Retain",t[t.Replace=2]="Replace"}(F||(F={}));class Qi{constructor(t,e=!1,i=Hi){this._array=[],this._compare=t,this._clone=i,"boolean"==typeof e&&(e?F.Allow:F.Retain),this._duplicatePolicy=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}indexOf(t){const e=this.lowerBound(t);return e.equal?e.index:-1}contains(t){return-1!==this.indexOf(t)}findEqual(t){const e=this.indexOf(t);return-1!==e?this._array[e]:void 0}findEquivalent(t){const e=this.indexOfEquivalent(t);return-1!==e?this._array[e]:void 0}indexOfEquivalent(t){const e=ji(this._array,(e=>0-t(e)));return e.equal?e.index:-1}get(t){return t<this.length?this._array[t]:void 0}forEach(t){for(let e=0;e<this.length;e++)t(this._array[e])}slice(t,e){const i=new Qi(this._compare,this._duplicatePolicy,this._clone);return i._array=this._array.slice(t,e),i}lowerBound(t){return Ki(t,this._array,this._compare)}_clear(){this._array.length=0}_extractArray(){const t=this._array;return this._array=[],t}_insert(t,e){const i=this.lowerBound(t);if(i.equal)switch(this._duplicatePolicy){case F.Retain:return i.index;case F.Replace:return this._array[i.index]=this._clone(t),e&&e(t),i.index}return this._array.splice(i.index,0,this._clone(t)),void 0!==e&&e(t),i.index}_remove(t){const e=this.lowerBound(t);return e.equal?(this._array.splice(e.index,1),e.index):-1}}class $i{constructor(t,e=Hi){this._array=[],this._compare=t,this._clone=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(t,e){const i=this._array[t];this._array[t]=this._array[e],this._array[e]=i}_heapify(t){let e=-1;for(;;){const i=2*(t+1),s=i-1;if(e=s<this.length&&this._compare(this._array[s],this._array[t])<0?s:t,i<this.length&&this._compare(this._array[i],this._array[e])<0&&(e=i),e===t)break;this._swap(e,t),t=e}}sort(){for(let t=Math.ceil(this.length/2);t>=0;t--)this._heapify(t)}push(t){const e=this._clone(t);let i=this.length;for(this._array.push(e);0!==i;){const t=Math.floor((i-1)/2);if(!(this._compare(this._array[i],this._array[t])<0))break;this._swap(i,t),i=t}return e}append(t){const e=this._clone(t);return this._array.push(e),e}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(t){if(t<0||t>=this.length)return;const e=this._array[t];return this._swap(t,this.length-1),this._array.length--,this._heapify(t),e}_peek(t){return t<0||t>=this.length?void 0:this._array[t]}}class ts{constructor(t=Es.compareNodesYXUp){this.priorityQueue=new $i(t),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const t=this.priorityQueue.pop();return this.activeEdges.push(t),t}popArrayToArrayIndex(t){if(t<this.activeEdges.length){const e=this.activeEdges.pop();this.activeEdges[t]=e}}removeArrayMembersWithY1Below(t){let e=0;const i=this.activeEdges.length;for(let s=0;s<i;s++){const i=this.activeEdges[s];i.faceSuccessor.y>=t&&(e<s&&(this.activeEdges[e]=i),e++)}this.activeEdges.length=e}}class es{constructor(t){this.graph=t,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}collectVerticalEventsAroundFace(t){let e,i,s,n,r=t;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{e=r.faceSuccessor,i=e.faceSuccessor,s=Es.compareNodesYXUp(r,e)<0,n=Es.compareNodesYXUp(e,i)<0,s?(this.upEdges.push(r),n||(Es.crossProductToTargets(e,r,i)<0?this.localMax.push(e):this.topPeaks.push(e))):(this.downEdges.push(r),n&&(Es.crossProductToTargets(e,r,i)>0?this.bottomPeaks.push(e):this.localMin.push(e))),r=e}while(r!==t)}collectVerticalEventFromEdgesInAndArray(t){let e,i,s,n,r;for(e of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,t))i=e.faceSuccessor,s=i.faceSuccessor,n=Es.compareNodesYXUp(e,i)<0,r=Es.compareNodesYXUp(i,s)<0,n?(this.upEdges.push(e),r||(Es.crossProductToTargets(i,e,s)<0?this.localMax.push(i):this.topPeaks.push(i))):(this.downEdges.push(e),r&&(Es.crossProductToTargets(i,e,s)>0?this.bottomPeaks.push(i):this.localMin.push(i)))}swapArrays(){let t=this.downEdges;this.downEdges=this.upEdges,this.upEdges=t,t=this.localMax,this.localMax=this.localMin,this.localMin=t,t=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=t}findTopVisibleEdge(t,e,i){const s=t.y,n=t.x;let r,o,a=Number.MAX_SAFE_INTEGER;for(const c of e){const e=c.faceSuccessor;if(c===t||e===t)continue;if(Es.compareNodesYXUp(t,c)*Es.compareNodesYXUp(t,e)>=0)continue;const h=Gi.horizontalScanFraction01(c,s);void 0!==h&&(r=i*(c.fractionToX(h)-n),r>0&&r<a&&(o=c,a=r))}return o}highestUpPeakConnection(t,e,i){let s;for(const n of this.topPeaks){const r=n.y,o=n.x;if(!(void 0!==s&&Es.compareNodesYXUp(n,s)<0)&&Es.compareNodesYXUp(n,t)<0){if(e){const t=Gi.horizontalScanFraction01(e,r);if(void 0===t)continue;if(o<=e.fractionToX(t))continue}if(i){const t=Gi.horizontalScanFraction01(i,r);if(void 0===t)continue;if(i.fractionToX(t)<=o)continue}s=n}}return s}updateMaxNode(t,e,i){return t?e&&i(t,e)<0?e:t:e}negateXY(){for(const t of this.graph.allHalfEdges)t.x*=-1,t.y*=-1}downwardConnectionFromBottomPeak(t){let e;const i=Es.compareNodesYXUp,s=this.findTopVisibleEdge(t,this.upEdges,1),n=this.findTopVisibleEdge(t,this.downEdges,-1);e=this.updateMaxNode(e,s,i),n&&(e=this.updateMaxNode(e,n.faceSuccessor,i));const r=this.highestUpPeakConnection(t,n,s);return void 0!==r&&(e=this.updateMaxNode(e,r,i)),e}findVisibleSector(t,e){let i=t;do{if(Gi.isNodeVisibleInSector(e,i))return i;i=i.vertexSuccessor}while(i!==t)}joinNodes(t,e,i){const s=this.graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0),n=this.findVisibleSector(t,e),r=this.findVisibleSector(e,t);if(void 0!==n&&void 0!==r)return Gi.pinch(n,s),Gi.pinch(r,s.edgeMate),es.announceEdge&&es.announceEdge(this.graph,t,e,i),s}runRegularization(t=!0,e=!0){if(t){this.bottomPeaks.sort(Es.compareNodesYXUp);for(const t of this.bottomPeaks){if(!Es.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,1)}}if(e){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(Es.compareNodesYXUp);for(const t of this.bottomPeaks){if(!Es.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(t,e=!0,i=!0){this.collectVerticalEventsAroundFace(t),this.runRegularization(e,i)}regularizeGraph(t=!0,e=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(t,e)}static isMonotoneFace(t){let e,i=0,s=0,n=t;do{const t=n.faceSuccessor,r=t.faceSuccessor,o=Es.compareNodesYXUp(n,t),a=Es.compareNodesYXUp(t,r);o*a<=0&&(o>0&&(i++,e=t),a>0&&s++)}while((n=n.faceSuccessor)!==t);return 1===i&&1===s?e:void 0}static collectMappedFaceRepresentatives(t,e,i,s,n){s&&(s.length=0),n&&(n.length=0);const r=k.VISITED;t.clearMask(r);for(const o of t.allHalfEdges)if(!o.getMask(r)&&(o.setMaskAroundFace(r),!e||o.signedFaceArea()>0)){const t=i(o);t?s&&s.push(t):n&&n.push(o)}}}class is{constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(t){t&&(this.numDrop++,this.clearForCache(t),this._cachedObjects.push(t))}grabFromCache(){let t=this._cachedObjects.pop();return void 0===t?(t=this.createForCache(),this.numCreate++):this.numReuse++,t}dropAllToCache(t){for(;t.length>0;)this.dropToCache(t.pop())}}class ss extends is{clearForCache(t){t.length=0}createForCache(){return new it(10)}constructor(){super()}grabAndFill(t){const e=this.grabFromCache();return e.pushFromGrowableXYZArray(t),e}}class ns{get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const t=[];for(const e of this._convexSets)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new ns)._convexSets.length=0,!Array.isArray(t))return e;for(const i of t)e._convexSets.push(fn.fromJSON(i));return e}static createEmpty(t){return t?(t._convexSets.length=0,t):new ns}isAlmostEqual(t){if(this._convexSets.length!==t._convexSets.length)return!1;for(let e=0;e<this._convexSets.length;e++)if(!this._convexSets[e].isAlmostEqual(t._convexSets[e]))return!1;return!0}static createConvexSets(t,e){e=e||new ns;for(const i of t)e._convexSets.push(i);return e}clone(t){(t=t||new ns)._convexSets.length=0;for(const e of this._convexSets)t._convexSets.push(e.clone());return t}addConvexSet(t){t&&this._convexSets.push(t)}hasIntersectionWithRay(t,e){if(void 0===e){for(const e of this._convexSets)if(e.hasIntersectionWithRay(t))return!0;return!1}e.setNull();const i=dt.createNull();for(const s of this._convexSets)s.hasIntersectionWithRay(t,i)&&e.extendRange(i);return!e.isNull}isPointInside(t){for(const e of this._convexSets)if(e.isPointInside(t))return!0;return!1}isPointOnOrInside(t,e=J.smallMetricDistance){for(const i of this._convexSets)if(i.isPointOnOrInside(t,e))return!0;return!1}isSphereInside(t,e){for(const i of this._convexSets)if(i.isSphereInside(t,e))return!0;return!1}isAnyPointInOrOnFromSegment(t){for(const e of this._convexSets)if(e.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref))return!0;return!1}appendIntervalsFromSegment(t,e){for(const i of this._convexSets)i.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref,((t,i)=>e.push(De.create(t,i))))}transformInPlace(t){for(const e of this._convexSets)e.transformInPlace(t)}classifyPointContainment(t,e){for(const i of this._convexSets){const s=i.classifyPointContainment(t,e);if(s!==E.StronglyOutside)return s}return E.StronglyOutside}polygonClip(t,e){e.length=0,Array.isArray(t)&&(t=it.create(t));const i=new it;for(const s of this._convexSets){const n=new it;s.polygonClip(t,n,i),0!==n.length&&e.push(n)}}announceClippedSegmentIntervals(t,e,i,s,n){let r=0;for(const o of this._convexSets)o.announceClippedSegmentIntervals(t,e,i,s,n)&&r++;return r>0}announceClippedArcIntervals(t,e){const i=ns._clipArcFractionArray;i.clear();for(const e of this._convexSets)for(const s of e.planes)s.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),ys.selectIntervals01(t,i,this,e)}computePlanePlanePlaneIntersectionsInAllConvexSets(t,e,i,s=!0){let n=0;for(const r of this._convexSets)n+=r.computePlanePlanePlaneIntersections(t,e,i,s);return n}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._convexSets)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}setInvisible(t){for(const e of this._convexSets)e.setInvisible(t)}addOutsideZClipSets(t,e,i){if(e){const i=fn.createEmpty();i.addZClipPlanes(t,e),this._convexSets.push(i)}if(i){const e=fn.createEmpty();e.addZClipPlanes(t,void 0,i),this._convexSets.push(e)}}takeConvexSets(t){let e;for(;void 0!==(e=t._convexSets.pop());)this._convexSets.push(e)}appendPolygonClip(t,e,i,s){const n=i.length,r=e.length;let o,a,c=[s.grabAndFill(t)],h=[];for(const t of this._convexSets){for(;void 0!==(a=c.pop());)t.appendPolygonClip(a,e,h,s),s.dropToCache(a);o=h,h=c,c=o}for(;void 0!==(a=c.pop());)i.push(a);i.length===n?ys.restoreSingletonInPlaceOfMultipleShards(e,r,t,s):e.length===r&&ys.restoreSingletonInPlaceOfMultipleShards(i,n,t,s)}}ns._clipArcFractionArray=new Pt;class rs{static advanceIntervalDifference(t,e,i,s){const n=e.length;let r=t.low,o=t.high;for(;i<n;){const t=e[i];if(t.high<r)i++;else{if(!(t.high<=o)){t.low<o&&(o=t.low);break}t.low>r&&s.push(dt.createXX(r,t.low)),r=t.high,i++}}return r<o&&s.push(dt.createXX(r,o)),s}static differenceSorted(t,e){const i=t.length,s=[];for(let n=0;n<i;n++)rs.advanceIntervalDifference(t[n],e,0,s);return s}static advanceIntervalIntersection(t,e,i){return e.low>t.high||(e.high>=t.high?(i.push(dt.createXX(e.low,t.high)),!0):(i.push(dt.createXX(e.low,e.high)),!1))}static intersectSorted(t,e){let i=0,s=0;const n=t.length,r=e.length,o=[];for(;i<n&&s<r;){const n=t[i],r=e[s];n.low<=r.low?rs.advanceIntervalIntersection(n,r,o)?i++:s++:rs.advanceIntervalIntersection(r,n,o)?s++:i++}return o}static advanceIntervalUnion(t,e,i){if(i>=e.length)return!1;const s=e[i];return!(s.low>t.high||(s.high>t.high&&(t.high=s.high),0))}static unionSorted(t,e){const i=t.length,s=e.length;let n=0,r=0;const o=[];for(;n<i&&r<s;){const i=t[n],s=e[r];let a;i.low<=s.low?(a=i.clone(),n++):(a=s.clone(),r++);let c=!0;do{const i=rs.advanceIntervalUnion(a,t,n),s=rs.advanceIntervalUnion(a,e,r);i&&n++,s&&r++,i||s||(c=!1)}while(c);o.push(a)}for(;n<i;)o.push(t[n++]);for(;r<s;)o.push(e[r++]);return o}static paritySorted(t,e){const i=[];for(const e of t)i.push(e.clone());for(const t of e)i.push(t.clone());return i.sort(os),rs.simplifySortParity(i,!0),i}static sort(t){t.sort(os)}static simplifySortUnion(t,e=!1){if(t.length<2)return;t.sort(os);let i=0;for(let e=1;e<t.length;e++)t[e].low<=t[i].high?t[e].high>t[i].high&&(t[i].high=t[e].high):(i++,t[i].setFrom(t[e]));if(t.length=i+1,e){i=-1;for(let e=0;e<t.length;e++)t[e].low<t[e].high&&i<e&&t[++i].setFrom(t[e])}}static simplifySortParity(t,e=!1){const i=[];for(const e of t)e.low!==e.high&&(i.push(e.low),i.push(e.high));const s=i.length;i.sort(((t,e)=>t<e?-1:t>e?1:0));let n,r,o=0;for(let a=0;a<s;a+=2)if(n=i[a],r=i[a+1],e){for(;a+2<s&&i[a+2]===r;)a+=2,r=i[a+1];r>n&&dt.createXX(n,r,t[o++])}else dt.createXX(n,r,t[o++]);t.length=o}static testUnion(t,e){return this.countContainingRanges(t,e)>0}static testParity(t,e){let i=!1;for(const s of t)s.containsX(e)&&(i=!i);return i}static countContainingRanges(t,e){let i=0;for(const s of t)s.containsX(e)&&i++;return i}static getBreaks(t,e,i=!1,s=!1,n=!0){e||(e=new Pt(2*t.length)),n&&e.clear();for(const i of t)e.push(i.low),e.push(i.high);return i&&e.sort(),s&&e.compressAdjacentDuplicates(),e}static appendFractionalPoints(t,e,i,s,n,r,o,a){const c=t.length;if(c>0){void 0!==e&&a.push(t[0].fractionToPoint(e));for(let e=0;e<c;e++)void 0===i||!s&&t[e].low===t[e].high||a.push(t[e].fractionToPoint(i)),e>1&&void 0!==n&&(r||t[e].low!==t[e].high)&&a.push(J.interpolate(t[e-1].high,n,t[e].low));void 0!==o&&a.push(t[c-1].fractionToPoint(o))}return a}static firstLowToLastHigh(t){return 0===t.length?dt.createNull():dt.createXX(t[0].low,t[t.length-1].high)}static sumLengths(t){let e=0;for(const i of t)e+=i.length();return e}static isSorted(t,e=!0){const i=t.length;if(e){for(let e=0;e+1<i;e++)if(t[e].high>=t[e+1].low)return!1}else for(let e=0;e+1<i;e++)if(t[e].high>t[e+1].low)return!1;return!0}}function os(t,e){return t.low<e.low?-1:t.low>e.low?1:t.high<e.high?-1:t.high>e.high?1:0}class as{constructor(){this.points=[],this.planes=fn.createEmpty(),this.children=[],this.startIdx=-1,this.numPoints=-1}static createWithIndices(t,e,i){return(i=i||new as).startIdx=t,i.numPoints=e,i.children.length=0,i}static createTreeForPolygon(t,e){return(e=e||new as).empty(),cs.createPointsRef(t).buildHullTree(e),e}static createHullAndInletsForPolygon(t,e){return(e=e||new as).empty(),cs.createPointsRef(t).buildHullAndInletsForPolygon(e),e}extractLoopsGo(t){t.push(ne.clonePoint3dArray(this.points));for(const e of this.children)e.extractLoopsGo(t)}extractLoops(){const t=[];return this.extractLoopsGo(t),t}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(t){t=t||new as;for(const e of this.points)t.points.push(e.clone());t.planes=fn.createEmpty();for(const e of this.planes.planes)t.planes.planes.push(e.clone());for(const e of this.children)t.children.push(e.clone());return t.startIdx=this.startIdx,t.numPoints=this.numPoints,t}addEmptyChild(t,e){const i=as.createWithIndices(t,e);this.children.push(i)}addPlane(t){this.planes.addPlaneToConvexSet(t)}isPointOnOrInside(t){if(!this.planes.isPointOnOrInside(t,0))return!1;for(const e of this.children)if(e.isPointOnOrInside(t))return!1;return!0}captureConvexClipPlaneSetAsVoid(t){this.children.push(t)}appendCurvePrimitiveClipIntervals(t,e,i){(new hs).appendSingleClipPrimitive(this,t,e,i)}appendCurveCollectionClipIntervals(t,e,i){(new hs).appendCurveCollectionClip(this,t,e,i)}appendPolygonClip(t,e,i,s){const n=i.length,r=this.planes.clipInsidePushOutside(t,i,s);if(void 0===r)ys.restoreSingletonInPlaceOfMultipleShards(i,n,t,s);else{let t,n,o=[r],a=[];for(const e of this.children){for(a.length=0;void 0!==(n=o.pop());)e.appendPolygonClip(n,i,a,s),s.dropToCache(n);t=a,a=o,o=t}for(;void 0!==(n=o.pop());)e.push(n)}}depth(){let t=0;for(const e of this.children)t=Math.max(t,e.depth());return 1+t}}class cs{constructor(){this._points=[],this._stack=[]}static createPointsRef(t,e){return(e=e||new cs)._points=t,fr.areaXY(t)<0&&e._points.reverse(),e._points[e._points.length-1].isAlmostEqualMetric(e._points[0])&&e._points.pop(),e}get period(){return this._points.length}indexAfter(t){return(t+1)%this._points.length}indexBefore(t){return(t+this._points.length-1)%this._points.length}pushIndex(t){this._stack.push(t)}static cross(t,e,i){return t.crossProductToPointsXY(e,i)}cyclicStackPoint(t){let e;const i=this._stack;return e=t>0?t:t+10*i.length,e%=i.length,this._points[i[e]]}signFromStackTip(t,e){const i=this.cyclicStackPoint(-2),s=this.cyclicStackPoint(-1),n=this._points[t];return e*cs.cross(i,s,n)>=0?1:-1}get indexOfMaxX(){let t=0;const e=this._points,i=this._points.length;for(let s=1;s<i;s++)e[s].x>e[t].x&&(t=s);return t}extendHullChain(t,e,i){for(;this._stack.length>1&&this.signFromStackTip(t,e)<0;)this._stack.pop();i&&this.pushIndex(t)}collectHullChain(t,e,i){if(this._stack.length=0,e>2){let s=t;for(let t=0;t<e;t++)this.extendHullChain(s,i,!0),s=this.indexAfter(s)}}collectHullPointsInArray(t,e,i,s){if(t.length=0,i>2){let s=e;for(let e=0;e<i;e++)t.push(this._points[s]),s=this.indexAfter(s)}}buildHullTreeGo(t,e,i=!0){this.collectHullChain(t.startIdx,t.numPoints,e?1:-1),t.points.length=0;const s=this._stack,n=this._points,r=s.length;for(let i=0;i<r;i++){const o=s[i];if(t.points.push(n[o]),i+1<r){let r=s[i+1];if(r===this.indexAfter(o)){const i=pr.createEdgeAndUpVector(n[o],n[r],j.create(0,0,1),Z.createRadians(0));void 0!==i&&(e&&i.negateInPlace(),t.addPlane(i))}else r<o&&(r+=this.period),t.addEmptyChild(o,r-o+1)}}if(i)for(const i of t.children)this.buildHullTreeGo(i,!e);else for(const i of t.children)this.collectHullPointsInArray(i.points,i.startIdx,i.numPoints,e?-1:1);return!0}buildHullAndInletsForPolygon(t){return as.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0,!1)}buildHullTree(t){return as.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0)}}class hs{constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(t){this._curve=t}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(t){const e=this._stackDepth;e>0&&(this._intervalStack[e-1]=t)}stackEntry(t){return t<=this._stackDepth?this._intervalStack[this._stackDepth-1-t]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}appendSingleClipToStack(t,e){const i=hs._fractionIntervals;if(this._curve instanceof tr){let i,s;return this._curve.announceClipIntervals(t,((t,e,n)=>{i=t,s=e}))&&e.push(dt.createXX(i,s)),!0}if(this._curve instanceof Pe){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(dt.createXX(i[t],i[t+1]));return!0}if(this._curve instanceof ye&&this._curve.points.length>1){const i=this._curve;let s,n;const r=i.points.length,o=1/(r-1);for(let a=0;a<r-1;a++)tr.create(i.points[a],i.points[a+1]).announceClipIntervals(t,((t,e,i)=>{s=t,n=e}))&&e.push(dt.createXX((a+s)*o,(a+n)*o));return!0}if(this._curve instanceof cr){const s=this._curve;i.length=0,s.announceClipIntervals(t,((t,e,s)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(dt.createXX(i[t],i[t+1]));return!0}return!1}recurse(t){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(t.planes,this._topOfStack),rs.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const e of t.children){if(this.recurse(e),this.isTopOfStackEmpty())this.popSegmentFrame();else{const t=rs.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=t}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(t,e,i,s){if(this.setCurveRef(e),this.clearSegmentStack(),this.recurse(t),1!==this._stackDepth)return;const n=this._topOfStack;for(const t of n){const s=t.low,n=t.high,r=e.fractionToPoint(s),o=e.fractionToPoint(n);i.push(_t.createCapture(yt.createCurveFractionPoint(e,s,r),yt.createCurveFractionPoint(e,n,o)))}this.popSegmentFrame()}appendCurveCollectionClip(t,e,i,s){for(const n of e.children)n instanceof $t?this.appendSingleClipPrimitive(t,n,i,s):n instanceof Me&&this.appendCurveCollectionClip(t,n,i,s)}}hs._fractionIntervals=[];class ls{static edgeLengthRange(t){const e=dt.createNull();for(let i=1;i<t.length;i++)e.extendX(t[i-1].distance(t[i]));return e}static compressByChordError(t,e){return We.compressPoint3dArrayByChordError(t,e)}static compressShortEdges(t,e){const i=it.create(t);return We.compressInPlaceByShortEdgeLength(i,e),i.getPoint3dArray()}static compressSmallTriangles(t,e){const i=it.create(t);return We.compressInPlaceBySmallTriangleArea(i,e),i.getPoint3dArray()}static compressByPerpendicularDistance(t,e,i=2){const s=it.create(t);let n=s.length;for(let t=0;t<i;t++){We.compressInPlaceByPerpendicularDistance(s,e);const t=s.length;if(t===n)break;n=t}return s.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(t,e,i,s){const n=1-i,r=t.x-(n*e.x+i*s.x),o=t.y-(n*e.y+i*s.y),a=t.z-(n*e.z+i*s.z);return r*r+o*o+a*a}static isDanglerConfiguration(t,e,i,s,n){if(e<0||e>=t.length)return!1;const r=t[e],o=r.distanceSquared(s);if(o<=n)return!0;if(i<0||i>=t.length)return!1;const a=t[i],c=r.dotVectorsToTargets(a,s);if(c<=0)return!1;const h=r.distanceSquared(a);let l;if(o>=h){const t=c/o;l=this.squaredDistanceToInterpolatedPoint(a,r,t,s)}else{const t=c/h;l=this.squaredDistanceToInterpolatedPoint(s,r,t,a)}return l<n}static compressDanglers(t,e=!1,i=J.smallMetricDistance){let s=t.length;const n=i*i;if(e)for(;s>1&&t[s-1].distanceSquared(t[0])<=n;)s--;const r=[];r.push(t[0].clone());for(let e=1;e<s;e++){const i=t[e];for(;this.isDanglerConfiguration(r,r.length-1,r.length-2,i,n);)r.pop();r.push(i.clone())}if(e){let t=0,e=r.length-1;for(;e>t+2;)if(this.isDanglerConfiguration(r,t,t+1,r[e],n))t++;else{if(!this.isDanglerConfiguration(r,e,e-1,r[t],n))break;e--}e+1<r.length&&(r.length=e+1),t>0&&r.splice(0,t)}return r}static addClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.addClosurePoint(e);return}const i=t[t.length-1];e instanceof K&&i instanceof K&&!e.isAlmostEqual(i)&&t.push(e.clone())}static removeClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.removeClosurePoint(e);return}const i=t[t.length-1];e instanceof K&&i instanceof K&&e.isAlmostEqual(i)&&t.pop()}}!function(t){t[t.None=0]="None",t[t.XLow=1]="XLow",t[t.XHigh=2]="XHigh",t[t.YLow=4]="YLow",t[t.YHigh=8]="YHigh",t[t.ZLow=16]="ZLow",t[t.ZHigh=32]="ZHigh",t[t.XAndY=15]="XAndY",t[t.All=63]="All"}(M||(M={}));class ds{fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(t,e=!1){this._clipPlanes=t,this._invisible=e}static createCapture(t,e=!1){let i;return t instanceof ns&&(i=t),t instanceof fn&&(i=ns.createConvexSets([t])),new ds(i,e)}toJSON(){const t={};return this._clipPlanes&&(t.clips=this._clipPlanes.toJSON()),this._invisible&&(t.invisible=!0),{planes:t}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const t=this._clipPlanes?this._clipPlanes.clone():void 0;return new ds(t,this._invisible)}ensurePlaneSets(){}pointInside(t,e=J.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}isPointOnOrInside(t,e=J.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}announceClippedSegmentIntervals(t,e,i,s,n){this.ensurePlaneSets();let r=!1;return this._clipPlanes&&(r=this._clipPlanes.announceClippedSegmentIntervals(t,e,i,s,n)),r}announceClippedArcIntervals(t,e){this.ensurePlaneSets();let i=!1;return this._clipPlanes&&(i=this._clipPlanes.announceClippedArcIntervals(t,e)),i}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(t),!0}transformInPlace(t){return this._clipPlanes&&this._clipPlanes.transformInPlace(t),!0}setInvisible(t){this._invisible=t}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const t of this._clipPlanes.convexSets)for(const e of t.planes)if(Math.abs(e.inwardNormalRef.z)>1e-6&&Math.abs(e.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(t,e){this.ensurePlaneSets();const i=this._clipPlanes;let s=E.StronglyInside;if(i&&(s=i.classifyPointContainment(t,!1)),this._invisible&&!e)switch(s){case E.StronglyInside:return E.StronglyOutside;case E.StronglyOutside:return E.StronglyInside;case E.Ambiguous:return E.Ambiguous}return s}static fromJSON(t){if(!t)return;return fs.fromClipShapeJSON(t)||ds.fromJSONClipPrimitive(t)}static fromJSONClipPrimitive(t){const e=t?.planes;if(!e)return;const i=e.clips?ns.fromJSON(e.clips):void 0,s=void 0!==e.invisible&&e.invisible;return new ds(i,s)}}class us{constructor(t,e,i,s){this.pointA=K.create(t.x,t.y,s),this.pointB=K.create(e.x,e.y,s),this.normal=i}static makeUnitPerpendicularToBisector(t,e,i){let s=e.normal.minus(t.normal);if(void 0!==s.normalize(s)||(s=j.createStartEnd(t.pointA,e.pointB),void 0!==s.normalize(s)))return i&&s.scale(-1,s),s}}class fs extends ds{constructor(t=[],e,i,s,n=!1,r=!1){super(void 0,r),this._isMask=!1,this._polygon=t,this.initSecondaryProps(n,e,i,s)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(t){t[0].isAlmostEqual(t[t.length-1])||t.push(t[0].clone()),this._polygon=t}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=ns.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(t,e,i,s){this._isMask=t,this._zLow=e,this._zHigh=i,void 0!==s?(this._transformFromClip=s,this._transformToClip=s.inverse()):(this._transformFromClip=ft.createIdentity(),this._transformToClip=ft.createIdentity())}toJSON(){const t={points:this._polygon.map((t=>t.toJSON()))};return this.invisible&&(t.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(t.trans=this._transformFromClip.toJSON()),this.isMask&&(t.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(t.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(t.zhigh=this.zHigh),{shape:t}}static fromClipShapeJSON(t,e){const i=t?.shape;if(!i)return;const s=i.points?i.points.map((t=>K.fromJSON(t))):[],n=i.trans?ft.fromJSON(i.trans):void 0,r="number"==typeof i.zlow?i.zlow:void 0,o="number"==typeof i.zhigh?i.zhigh:void 0,a="boolean"==typeof i.mask&&i.mask,c="boolean"==typeof i.invisible&&i.invisible;return fs.createShape(s,r,o,n,a,c,e)}static createFrom(t,e){const i=fs.createEmpty(!1,!1,void 0,e);i._invisible=t._invisible;for(const e of t._polygon)i._polygon.push(e.clone());return i._isMask=t._isMask,i._zLow=t._zLow,i._zHigh=t._zHigh,i._transformToClip=t._transformToClip?t._transformToClip.clone():void 0,i._transformFromClip=t._transformFromClip?t._transformFromClip.clone():void 0,i}static createShape(t=[],e,i,s,n=!1,r=!1,o){if(t.length<3)return;const a=t.slice(0);return a[0].isAlmostEqual(a[a.length-1])?a[0].clone(a[a.length-1]):a.push(a[0].clone()),o?(o._clipPlanes=void 0,o._invisible=r,o._polygon=a,o.initSecondaryProps(n,e,i,s),o):new fs(a,e,i,s,n,r)}static createBlock(t,e,i=!1,s=!1,n,r){const o=t.low,a=t.high,c=[];for(let t=0;t<5;t++)c.push(K.create());return c[0].x=c[3].x=c[4].x=o.x,c[1].x=c[2].x=a.x,c[0].y=c[1].y=c[4].y=o.y,c[2].y=c[3].y=a.y,fs.createShape(c,M.None!==(e&M.ZLow)?o.z:void 0,M.None!==(e&M.ZHigh)?a.z:void 0,n,i,s,r)}static createEmpty(t=!1,e=!1,i,s){return s?(s._clipPlanes=void 0,s._invisible=e,s._polygon.length=0,s.initSecondaryProps(t,void 0,void 0,i),s):new fs([],void 0,void 0,i,t,e)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(t){return fs.createFrom(this,t)}parseClipPlanes(t){const e=this._polygon;if(3===e.length&&!this._isMask&&e[0].isExactEqual(e[e.length-1]))return this.parseLinearPlanes(t,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const e=fr.testXYPolygonTurningDirections(this.polygon);if(0!==e)return this.parseConvexPolygonPlanes(t,this._polygon,e,!1),!0}return this.parsePolygonPlanes(t,this._polygon,this.isMask),!0}parseLinearPlanes(t,e,i,s){const n=e.vectorTo(i);if(0===n.magnitude())return!1;n.normalize(n);const r=fn.createEmpty();if(void 0===s){const t=G.create(-n.y,n.x);r.planes.push(pr.createNormalAndPoint(j.create(n.x,n.y),K.createFrom(e),this._invisible)),r.planes.push(pr.createNormalAndPoint(j.create(-n.x,-n.y),K.createFrom(i),this._invisible)),r.planes.push(pr.createNormalAndPoint(j.create(t.x,t.y),K.createFrom(e),this._invisible)),r.planes.push(pr.createNormalAndPoint(j.create(-t.x,-t.y),K.createFrom(e),this._invisible))}else{const t=K.create(e.x,e.y,-s),n=K.create(i.x,i.y,-s),o=j.createFrom(n),a=o.crossProduct(j.createFrom(t)).normalize();let c=j.createFrom(t).crossProduct(a).normalize();r.planes.push(pr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(pr.createNormalAndDistance(c,0,this._invisible)),a.negate(),c=o.crossProduct(a).normalize(),r.planes.push(pr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(pr.createNormalAndDistance(c,0,this._invisible))}return r.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(r),!0}parseConvexPolygonPlanes(t,e,i,s,n){const r=[],o=i<0;for(let t=0;t<e.length-1;t++){const i=void 0===n?0:-n,s=j.createStartEnd(e[t],e[t+1]),a=s.magnitude();if(s.normalize(s),a>1e-8){const n=j.create(o?s.y:-s.y,o?-s.x:s.x);r.push(new us(e[t],e[t+1],n,i))}}if(r.length<3)return!1;if(s){const e=r.length-1;for(let i=0;i<=e;i++){const s=r[i],n=r[i?i-1:e],a=r[i===e?0:i+1],c=fn.createEmpty(),h=us.makeUnitPerpendicularToBisector(n,s,!o),l=us.makeUnitPerpendicularToBisector(s,a,o);h&&c.planes.push(pr.createNormalAndPoint(h,s.pointA,this._invisible,!0)),c.planes.push(pr.createNormalAndPoint(s.normal,s.pointB,this._invisible,!1)),l&&c.planes.push(pr.createNormalAndPoint(l,a.pointA,this._invisible,!0)),t.addConvexSet(c),t.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const e=fn.createEmpty();if(void 0===n)for(const t of r)e.planes.push(pr.createNormalAndPoint(j.create(t.normal.x,t.normal.y),t.pointA));else if(o)for(const t of r)e.planes.push(pr.createNormalAndDistance(j.createFrom(t.pointA).crossProduct(j.createFrom(t.pointB)).normalize(),0));else for(const t of r)e.planes.push(pr.createNormalAndDistance(j.createFrom(t.pointB).crossProduct(j.createFrom(t.pointA)).normalize(),0));e.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(e)}return!0}parsePolygonPlanes(t,e,i,s){const n=ls.compressDanglers(e,!0),r=(e,i)=>{if(!i.isMaskSet(k.EXTERIOR)){const e=i.collectAroundFace((t=>{if(!t.isMaskSet(k.EXTERIOR))return K.create(t.x,t.y,0)}));e.push(e[0].clone());const n=fr.testXYPolygonTurningDirections(e);this.parseConvexPolygonPlanes(t,e,n,!1,s)}return!0};if(i){const e=ne.clonePoint3dArray(n),i=as.createHullAndInletsForPolygon(e).extractLoops();if(0===i.length)return!1;const o=i[0],a=fr.testXYPolygonTurningDirections(o);this.parseConvexPolygonPlanes(t,o,-a,!0,s);for(let t=1;t<i.length;t++){const e=ks.createTriangulatedGraphFromSingleLoop(i[t]);e&&(ks.flipTriangles(e),e.announceFaceLoops(r))}return!0}{const t=ks.createTriangulatedGraphFromSingleLoop(n);if(void 0===t)return!1;ks.flipTriangles(t),t.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(t,e=!0,i=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(t,e,i)}transformInPlace(t){return t.isIdentity||(super.transformInPlace(t),this._transformFromClip?t.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=t.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(t){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(t,t)}performTransformFromClip(t){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(t,t)}}class gs{constructor(t){this._keepInside=t,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const t=[];for(const e of this._clippers){const i=e;i.toJSON&&t.push(i.toJSON())}const e={};return e[this.operationName]=t,e}captureChild(t){if(Array.isArray(t))for(const e of t)this.captureChild(e);else this._clippers.push(t)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(t){const e=this._keepInside;return this._keepInside=t,e}testedAnnounceNN(t,e,i){return t<e?(i&&i(t,e),1):0}testedAnnounceNNC(t,e,i,s){return t<e?(s&&s(t,e,i),1):0}swapAB(){const t=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=t}announcePartsNN(t,e,i,s,n){let r=0;if(t)for(const t of e)r+=this.testedAnnounceNN(t.low,t.high,n);else{let t=i;for(const i of e)r+=this.testedAnnounceNN(t,i.low,n),t=i.high;r+=this.testedAnnounceNN(t,s,n)}return r>0}announcePartsNNC(t,e,i,s,n,r){let o=0;if(t)for(const t of e)o+=this.testedAnnounceNNC(t.low,t.high,n,r);else{let t=i;for(const i of e)o+=this.testedAnnounceNNC(t,i.low,n,r),t=i.high;o+=this.testedAnnounceNNC(t,s,n,r)}return o>0}isPointOnOrInside(t){const e=this.isPointOnOrInsideChildren(t);return this._keepInside?e:!e}announceClippedSegmentIntervals(t,e,i,s,n){this._intervalsA.length=0;const r=(t,e)=>{this._intervalsB.push(dt.createXX(t,e))};let o=0;for(const n of this._clippers)this._intervalsB.length=0,n.announceClippedSegmentIntervals(t,e,i,s,r),rs.simplifySortUnion(this._intervalsB),0===o?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),o++;return this.announcePartsNN(this._keepInside,this._intervalsA,t,e,n)}announceClippedArcIntervals(t,e){this._intervalsA.length=0;const i=(t,e)=>{this._intervalsB.push(dt.createXX(t,e))};let s=0;for(const e of this._clippers)this._intervalsB.length=0,e.announceClippedArcIntervals(t,i),rs.simplifySortUnion(this._intervalsB),0===s?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),s++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,t,e)}}class ps extends gs{get operationName(){return this._keepInside?"AND":"NAND"}constructor(t){super(t)}isPointOnOrInsideChildren(t){for(const e of this._clippers)if(!e.isPointOnOrInside(t))return!1;return!0}combineIntervals(t,e){return rs.intersectSorted(t,e)}appendPolygonClip(t,e,i,s){ys.doPolygonClipSequence(t,this._clippers,this._keepInside?e:i,this._keepInside?i:e,void 0,X.passToNextStep,X.acceptOut,X.acceptIn,s)}}class ms{get clips(){return this._clips}constructor(t){this.boundingRange=lt.createNull(),this._clips=t||[]}get isValid(){return this._clips.length>0}static createEmpty(t){return t?(t._clips.length=0,t):new ms}static createCapture(t,e){return e?(e._clips=t,e):new ms(t)}static create(t,e){const i=[];for(const e of t)i.push(e.clone());return ms.createCapture(i,e)}clone(t){const e=t||new ms;e._clips.length=0;for(const t of this._clips)e._clips.push(t.clone());return e.boundingRange.setFrom(this.boundingRange),e}toJSON(){return this.isValid?this.clips.map((t=>t.toJSON())):[]}static fromJSON(t,e){if((e=e||new ms).clear(),!Array.isArray(t))return e;try{for(const i of t){const t=ds.fromJSON(i);t&&e._clips.push(t)}}catch(t){e.clear()}return e}clear(){this._clips.length=0}appendClone(t){this._clips.push(t.clone())}appendReference(t){this._clips.push(t)}appendShape(t,e,i,s,n=!1,r=!1){const o=fs.createShape(t,e,i,s,n,r);return!!o&&(this._clips.push(o),!0)}pointInside(t,e=J.smallMetricDistanceSquared){return this.isPointOnOrInside(t,e)}isPointOnOrInside(t,e=J.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(t))return!1;for(const i of this._clips)if(!i.pointInside(t,e))return!1;return!0}ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new ps(!0);let t=0;for(const e of this._clips){const i=e.fetchClipPlanesRef();i&&(t++,this._clipNodeProxy.captureChild(i))}return t>0}announceClippedSegmentIntervals(t,e,i,s,n){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(t,e,i,s,n)}announceClippedArcIntervals(t,e){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(t,e)}appendPolygonClip(t,e,i,s){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(t,e,i,s)}transformInPlace(t){for(const e of this._clips)if(!1===e.transformInPlace(t))return!1;return this.boundingRange.isNull||t.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(t,e){let i=M.None,s=-Number.MAX_VALUE,n=Number.MAX_VALUE;const r=[];let o,a=0;if(0===this._clips.length)return r;const c=ft.createIdentity();for(const e of this._clips)if(e instanceof fs){if(void 0!==o&&e!==o){let t=ft.createIdentity(),i=ft.createIdentity();o.transformValid&&e.transformValid&&(t=e.transformFromClip.clone(),i=o.transformToClip.clone()),c.setFrom(i.multiplyTransformTransform(t))}if(o||(o=e),t[a]=[],void 0!==e.polygon){i=M.XAndY,e.zHighValid&&(i|=M.ZHigh,n=e.zHigh),e.zLowValid&&(i|=M.ZLow,s=e.zLow);for(const i of e.polygon)t[a].push(i.clone());c.multiplyPoint3dArray(t[a],t[a]),a++}}return r.push(i),r.push(s),r.push(n),e&&o&&e.setFrom(o.transformFromClip),r}setInvisible(t){for(const e of this._clips)e.setInvisible(t)}parseClipPlanes(){for(const t of this._clips)t.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._clips)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}classifyPointContainment(t,e=!1){let i=E.Ambiguous;for(const s of this._clips){const n=s.classifyPointContainment(t,e);if(E.Ambiguous===n)return E.Ambiguous;if(E.Ambiguous===i)i=n;else if(i!==n)return E.Ambiguous}return i}classifyRangeContainment(t,e){const i=t.corners();return this.classifyPointContainment(i,e)}isAnyLineStringPointInside(t){for(const e of this._clips){const i=e.fetchClipPlanesRef();if(void 0!==i)for(let e=0;e+1<t.length;e++){const s=tr.create(t[e],t[e+1]);if(i.isAnyPointInOrOnFromSegment(s))return!0}}return!1}sumSizes(t,e,i){let s=0;for(let n=e;n<i;n++)s+=t[n].x1-t[n].x0;return s}isLineStringCompletelyContained(t){const e=[];for(let i=0;i+1<t.length;i++){const s=tr.create(t[i],t[i+1]);let n=0,r=0;for(const t of this._clips){const i=t.fetchClipPlanesRef();if(void 0!==i){i.appendIntervalsFromSegment(s,e);const t=e.length;if(n+=this.sumSizes(e,r,t),r=t,n>=ms._TARGET_FRACTION_SUM)break}}if(n<ms._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(t){return`${t.toString()}_`}function i(i){let s=i.invisible?1:0;return s|=i.interior?2:0,`${function(t){const i=t.toString();return e(1===i.length),i}(s)}${n=i.inwardNormalRef,`${t(n.x)}${t(n.y)}${t(n.z)}`}${t(i.distance)}`;var n}function s(t){let e="";for(const s of t.planes)e=`${e}${i(s)}`;return`${e}_`}function n(t){let i=(t.invisible?1:0).toString();e(1===i.length);const n=t.fetchClipPlanesRef();if(n)for(const t of n.convexSets)i=`${i}${s(t)}`;return`${i}_`}let r="";for(const t of this.clips)r=`${r}${n(t)}`;return`${r}_`}}ms._TARGET_FRACTION_SUM=.99999999,function(t){t.fromClipVector=function(t){if(!t||!t.isValid)return;const i=t;void 0===i.clipString&&(i.clipString=t.toCompactString());const s=i;return e(void 0!==s.clipString),s}}(b||(b={}));class xs{constructor(t,e){this._positiveOffsetLeft=t,this._positiveOffsetRight=e,this._turnDegrees=60}static createUnit(t,e,i,s=!0){let n=e,r=e+1;const o=t.length-1;i?e<0?(n=o-1,r=o):e>=o&&(n=0,r=1):0===e?(n=0,r=1):r>o&&(n=o-1,r=o);const a=t.vectorIndexIndex(n,r);if(a)return s&&(a.z=0),a.normalize(a)}static createDirectedPlane(t,e,i,s,n=!1){return pr.createNormalAndPointXYZXYZ(e.x*s,e.y*s,e.z*s,t.x+i*e.x,t.y+i*e.y,t.z+i*e.z,n,n)}createChamferCut(t,e,i,s){const n=i.angleToXY(s).degrees;if(Math.abs(n)>this._turnDegrees){const r=i.interpolate(.5,s);r.rotate90CCWXY(r),r.normalizeInPlace(),n>0?t.addPlaneToConvexSet(xs.createDirectedPlane(e,r,-this._positiveOffsetRight,1,!1)):t.addPlaneToConvexSet(xs.createDirectedPlane(e,r,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(t,e,i,s,n){if(void 0===s)return;void 0===i&&(i=s),void 0===n&&(n=s);const r=i.interpolate(.5,s);r.normalizeInPlace();const o=s.rotate90CCWXY(),a=s.interpolate(.5,n);a.normalizeInPlace();const c=fn.createEmpty();return c.addPlaneToConvexSet(xs.createDirectedPlane(t,o,this._positiveOffsetLeft,-1,!1)),c.addPlaneToConvexSet(xs.createDirectedPlane(t,o,-this._positiveOffsetRight,1,!1)),c.addPlaneToConvexSet(xs.createDirectedPlane(t,r,0,1,!0)),c.addPlaneToConvexSet(xs.createDirectedPlane(e,a,0,-1,!0)),this.createChamferCut(c,t,i,s),this.createChamferCut(c,e,s,n),c}static createClipBetweenOffsets(t,e,i,s,n){const r=new xs(e,i),o=ns.createEmpty();if(t.length>1){const e=J.isSmallMetricDistance(t.distanceIndexIndex(0,t.length-1));for(let i=0;i+1<t.length;i++){const a=this.createUnit(t,i-1,e),c=this.createUnit(t,i,e),h=this.createUnit(t,i+1,e),l=r.createOffsetFromSegment(t.getPoint3dAtUncheckedPointIndex(i),t.getPoint3dAtUncheckedPointIndex(i+1),a,c,h);l?.addZClipPlanes(!1,s,n),l&&o.addConvexSet(l)}}else{const t=fn.createEmpty();t?.addZClipPlanes(!1,s,n),t.planes.length>0&&o.addConvexSet(t)}return o}}!function(t){t[t.StronglyInside=1]="StronglyInside",t[t.Ambiguous=2]="Ambiguous",t[t.StronglyOutside=3]="StronglyOutside"}(E||(E={})),(L=X||(X={}))[L.acceptIn=1]="acceptIn",L[L.acceptOut=-1]="acceptOut",L[L.passToNextStep=0]="passToNextStep",function(t){t[t.ClipRequired=0]="ClipRequired",t[t.TrivialReject=1]="TrivialReject",t[t.TrivialAccept=2]="TrivialAccept"}(z||(z={}));class ys{static selectIntervals01(t,e,i,s){e.push(0),e.push(1),e.sort();let n,r,o=e.atUncheckedIndex(0);const a=ys._selectIntervals01TestPoint,c=e.length;for(let h=1;h<c;h++)if(n=e.atUncheckedIndex(h),n>o+J.smallFraction){if(r=.5*(o+n),r>=0&&r<=1&&(t.fractionToPoint(r,a),i.isPointOnOrInside(a))){if(!s)return!0;s(o,n,t)}o=n}return!1}static announceNNC(t,e,i){if(i)for(const s of t)i(s.low,s.high,e);return t.length>0}static collectClippedCurves(t,e){const i=[];return t.announceClipIntervals(e,((t,e,s)=>{if(e!==t){const n=s.clonePartialCurve(t,e);n&&i.push(n)}})),i}static clipPolygonToClipShape(t,e){const i=this.clipPolygonToClipShapeReturnGrowableXYZArrays(t,e),s=[];for(const t of i)s.push(t.getPoint3dArray());return s}static clipPolygonToClipShapeReturnGrowableXYZArrays(t,e){const i=[],s=e.fetchClipPlanesRef();return s&&s.polygonClip(t,i),i}static pointSetSingleClipStatus(t,e,i){if(0===e.convexSets.length)return z.TrivialAccept;for(const s of e.convexSets){let e=!1,n=!1;for(const r of s.planes){let s=0,o=0;const a=r.distance-i,c=K.create(),h=j.create();for(let e=0;e<t.length;e++)t.getPoint3dAtUncheckedPointIndex(e,c),h.setFrom(c),h.dotProduct(r.inwardNormalRef)>a?s++:o++;if(n=0!==o||n,0===s){e=!0;break}}if(!n)return z.TrivialAccept;if(!e)return z.ClipRequired}return z.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,i,s=!0,n=!0,r=!1){const o=new it;if(s)if(t instanceof fn)for(const s of t.planes){if(r&&s.invisible)continue;const n=s.intersectRange(e,!0),a=new it;n&&(t.polygonClip(n,a,o,s),a.length>0&&i(a))}else if(r&&t.invisible);else{const s=t.intersectRange(e,!0);s&&i(s)}if(n){const s=e.corners();for(let e=0;e<6;e++){const n=lt.faceCornerIndices(e),r=new it,a=ye.createIndexedPoints(s,n);t instanceof fn?(t.polygonClip(a.packedPoints,r,o),r.length>0&&i(r)):(t.clipConvexPolygonInPlace(a.packedPoints,o),a.packedPoints.length>0&&i(a.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(t,e,i=!0,s=!0,n=!1){const r=[];if(t instanceof ns)for(const o of t.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(o,e,(t=>{t.length>0&&r.push(Ue.createPolygon(t))}),i,s,n);else(t instanceof fn||t instanceof pr)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&r.push(Ue.createPolygon(t))}),i,s,n);return r}static rangeOfConvexClipPlaneSetIntersectionWithRange(t,e){const i=lt.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&i.extendArray(t)}),!0,!0,!1),i}static rangeOfClipperIntersectionWithRange(t,e,i=!0){if(void 0===t)return e.clone();if(t instanceof fn)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(t,e);if(t instanceof ns){const i=lt.createNull();for(const s of t.convexSets){const t=this.rangeOfConvexClipPlaneSetIntersectionWithRange(s,e);i.extendRange(t)}return i}if(t instanceof ds)return i&&t.invisible?e.clone():this.rangeOfClipperIntersectionWithRange(t.fetchClipPlanesRef(),e);if(t instanceof ms){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return s}return e.clone()}static doesClipperIntersectRange(t,e,i=!0){if(void 0===t)return!0;if(t instanceof fn)return this.doesConvexClipPlaneSetIntersectRange(t,e);if(t instanceof ns){for(const i of t.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(i,e))return!0;return!1}if(t instanceof ds)return!(!i||!t.invisible)||this.doesClipperIntersectRange(t.fetchClipPlanesRef(),e);if(t instanceof ms){const s=e.clone();for(const n of t.clips)if(i&&n.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(n,e,i);s.intersect(t,s)}return!s.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(t,e,i=!0,s=!0,n=!1){const r=new it;if(i)for(const i of t.planes){if(n&&i.invisible)continue;const s=i.intersectRange(e,!0);if(s){const e=new it;if(t.polygonClip(s,e,r,i),e.length>0)return!0}}if(s){const i=e.corners();for(let e=0;e<6;e++){const s=lt.faceCornerIndices(e),n=new it,o=ye.createIndexedPoints(i,s);if(t.polygonClip(o.packedPoints,n,r),n.length>0)return!0}}return!1}static doLocalRangesIntersect(t,e,i,s,n){const r=ys._workTransform=s.inverse(ys._workTransform);if(!r)return!1;let o=i;n&&(o=ys._workRange=i.clone(ys._workRange),o.expandInPlace(n));const a=r.multiplyTransformTransform(e,r),c=In.create();c.addTransformedRangeMesh(a,t);const h=c.claimPolyface(),l=ys._workClipper=fn.createConvexPolyface(h,ys._workClipper).clipper;return ys.doesClipperIntersectRange(l,o)}static isClipper(t){return!!(t&&t.isPointOnOrInside&&t.announceClippedSegmentIntervals&&t.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(t,e,i,s){if(t&&t.length>e+1){for(;t.length>e;){const e=t.pop();s.dropToCache(e)}t.push(s.grabAndFill(i))}}static createXYOffsetClipFromLineString(t,e,i,s,n){return Array.isArray(t)?xs.createClipBetweenOffsets(new te(t),e,i,s,n):xs.createClipBetweenOffsets(t,e,i,s,n)}static captureOrDrop(t,e,i,s){t.length>=e?i.push(t):s.dropToCache(t)}static clipSegmentToLLeftOfLineXY(t,e,i,s,n,r=1e-14){const o=e.x-t.x,a=e.y-t.y,c=-(o*(i.y-t.y)-a*(i.x-t.x)),h=-(o*(s.y-t.y)-a*(s.x-t.x));if(!(c<r&&h<r))if(c*h>0)c>0&&n.setNull();else{if(c*h<0){const t=-c/(h-c);return c<0?n.intersectRangeXXInPlace(0,t):n.intersectRangeXXInPlace(t,1)}c>0?n.intersectRangeXXInPlace(1,1):h>0&&n.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(t,e,i,s,n,r,o=1e-14){r.isNull||(this.clipSegmentToLLeftOfLineXY(t,e,s,n,r,o),r.isNull||(this.clipSegmentToLLeftOfLineXY(e,i,s,n,r,o),r.isNull||this.clipSegmentToLLeftOfLineXY(i,t,s,n,r,o)))}static clipSegmentBelowPlaneXY(t,e,i,s,n=1e-14){const r=t.altitudeXY(e.x,e.y),o=t.altitudeXY(i.x,i.y);if(!(r<n&&o<n))if(r*o>0)r>0&&s.setNull();else{if(r*o<0){const t=-r/(o-r);return r<0?s.intersectRangeXXInPlace(0,t):s.intersectRangeXXInPlace(t,1)}r>0?s.intersectRangeXXInPlace(1,1):o>0&&s.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(t,e,i,s,n=1e-14){const r=t.length;for(let o=0;!s.isNull&&o<r;o++)this.clipSegmentBelowPlaneXY(t[o],e,i,s,n)}static announcePolylineClip(t,e,i){for(let s=0;s+1<e.length;s++)t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,n)=>{i(e[s].interpolate(t,e[s+1]),e[s].interpolate(n,e[s+1]))}))}static sumPolylineClipLength(t,e){let i=0;for(let s=0;s+1<e.length;s++){const n=e[s].distance(e[s+1]);t.announceClippedSegmentIntervals(0,1,e[s],e[s+1],((t,e)=>{i+=Math.abs(e-t)*n}))}return i}static doPolygonClipSequence(t,e,i,s,n,r,o,a,c){void 0===c&&(c=new ss);let h=[c.grabAndFill(t)],l=[];const d=[],u=[],f=i?i.length:0,g=s?s.length:0;let p;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(p=h.pop());)t.appendPolygonClip(p,d,u,c),vs(r,d,i,s,l,c),vs(o,u,i,s,l,c),c.dropToCache(p);const e=h;h=l,l=e}vs(a,h,i,s,n,c),s?.length===g&&ys.restoreSingletonInPlaceOfMultipleShards(i,f,t,c),i?.length===f&&ys.restoreSingletonInPlaceOfMultipleShards(s,g,t,c)}static doPolygonClipParitySequence(t,e,i,s,n){void 0===n&&(n=new ss);let r=[n.grabAndFill(t)],o=[],a=[],c=[];const h=[],l=[];let d;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(d=o.pop());)t.appendPolygonClip(d,h,l,n),vs(X.acceptOut,h,a,c,void 0,n),vs(X.acceptIn,l,a,c,void 0,n),n.dropToCache(d);for(;void 0!==(d=r.pop());)t.appendPolygonClip(d,h,l,n),vs(X.acceptIn,h,a,c,void 0,n),vs(X.acceptOut,l,a,c,void 0,n),n.dropToCache(d);const e=o;o=a,a=e;const i=r;r=c,c=i}0===r.length?i?.push(n.grabAndFill(t)):0===r.length?s?.push(n.grabAndFill(t)):(_s(o,i,n),_s(r,s,n))}static createComplementaryClips(t){const e=t.planes,i=dt.createNull(),s=e.length,n=[];for(const t of e){const e=fn.createEmpty();e.addPlaneToConvexSet(t.cloneNegated()),n.push(e)}for(let r=0;r<s;r++)for(let o=r+1;o<s;o++){const s=fi.planePlaneIntersectionRay(e[r],e[o]);if(s&&t.hasIntersectionWithRay(s,i)){const t=e[o].inwardNormalRef.minus(e[r].inwardNormalRef),i=pr.createNormalAndPoint(t,s.origin);if(i){const t=i.cloneNegated();n[r].addPlaneToConvexSet(i),n[o].addPlaneToConvexSet(t)}}}return ns.createConvexSets(n)}}function _s(t,e,i){if(void 0===e)i.dropAllToCache(t);else for(const i of t)e.push(i);t.length=0}function vs(t,e,i,s,n,r){let o;if(t===X.acceptIn?o=i:t===X.acceptOut?o=s:t===X.passToNextStep&&(o=n),void 0===o)r.dropAllToCache(e);else for(const t of e)o.push(t);e.length=0}ys._selectIntervals01TestPoint=K.create();class Ps{constructor(t,e){this._graph=t,this._candidates=[],this._mask=e,this._graph.clearMask(e)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let t=0;for(const e of this._candidates)e.isMaskSet(this._mask)&&t++;return t}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const t=this._candidates.length;if(0===t)return;const e=this._candidates[t-1];return this._candidates.pop(),e}getAtIndex(t){if(t>=0&&t<this._candidates.length){const e=this._candidates[t];if(e.isMaskSet(this._mask))return e}}addToSet(t){return!t.isMaskSet(this._mask)&&(this._candidates.push(t),this.setMaskInScope(t),!0)}isCandidateInSet(t){return t.isMaskSet(this._mask)}removeFromSet(t){return!!t.isMaskSet(this._mask)&&(this.clearMaskInScope(t),!0)}chooseAndRemoveAny(){for(;;){const t=this.popAndReturn();if(!t)return;if(this.removeFromSet(t))return t}}[Symbol.iterator](){return new As(this)}addAroundFace(t){let e=t;do{this.addToSet(e),e=e.faceSuccessor}while(e!==t)}addAroundVertex(t){let e=t;do{this.addToSet(e),e=e.vertexSuccessor}while(e!==t)}}class Is extends Ps{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==k.NULL_MASK)return new Is(t,e)}setMaskInScope(t){t.setMaskAroundEdge(this._mask)}clearMaskInScope(t){t.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(t){return t?2:0}}class As{constructor(t){this._markSet=t,this._nextReadIndex=0}next(){const t=this._markSet.getNumCandidates();for(;this._nextReadIndex<t;){const t=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==t)return{done:!1,value:t}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class Ss{constructor(t,e,i,s,n,r){this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t}set(t,e,i,s,n,r){return this._x=e,this._y=i,this._z=s,this._u=n,this._v=r,this._node=t,this}setFrom(t){this._x=t.x,this._y=t.y,this._z=t.z,this._u=t.u,this._v=t.v,this._node=t.node}static createNodeAndRayOrigin(t,e,i){const s=t.x,n=t.y,r=t.z,o=s-e.origin.x,a=n-e.origin.y,c=J.dotProductXYXY(o,a,e.direction.x,e.direction.y),h=J.crossProductXYXY(e.direction.x,e.direction.y,o,a);return i?i.set(t,s,n,r,c,h):new Ss(t,s,n,r,c,h)}static create(t,e=0,i=0,s=0,n=0,r=0){return new Ss(t,e,i,s,n,r)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(t){return K.create(this._x,this._y,this._z,t)}getUVAsPoint2d(t){return W.create(this._u,this._v,t)}classifyU(t,e){const i=this.u-t;return Math.abs(i)<=e?0:i>=0?1:-1}classifyV(t,e){const i=t-this._v;return Math.abs(i)<=e?0:i>=0?1:-1}}!function(t){t[t.None=0]="None",t[t.Vertex=1]="Vertex",t[t.Edge=2]="Edge",t[t.Face=3]="Face",t[t.ExteriorFace=4]="ExteriorFace"}(R||(R={}));class ws{constructor(t,e,i,s,n,r,o,a,c){this._node=t,this.x=e,this.y=i,this.z=s,this._topo=n,this._edgeFraction=r,this._iTag=o,this._dTag=a,this._isExteriorTarget=c}setFrom(t){this._node=t._node,this.x=t.x,this.y=t.y,this.z=t.z,this._topo=t._topo,this._edgeFraction=t._edgeFraction,this._iTag=t._iTag,this._dTag=t._dTag}resetAsUnknown(){this._node=void 0,this._topo=R.None}static create(){return new ws(void 0,0,0,0,R.None)}getITag(){return this._iTag}setITag(t){this._iTag=t}getDTag(){return this._dTag}setDTag(t){this._dTag=t}getTopo(){return this._topo}static createEdgeAtFraction(t,e){const i=t.faceSuccessor,s=J.interpolate(t.x,e,i.x),n=J.interpolate(t.y,e,i.y),r=J.interpolate(t.z,e,i.z);return new ws(t,s,n,r,R.Edge,e)}resetAsFace(t,e){return this._topo=R.Face,t&&(this._node=t),e&&(this.x=e.x,this.y=e.y,this.z=e.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(t){return this._topo=R.None,this._dTag=0,this._iTag=0,this._dTag=t,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(t,e){this._topo=R.Edge,this._node=t;const i=t.faceSuccessor;return this._edgeFraction=e,this.x=J.interpolate(t.x,e,i.x),this.y=J.interpolate(t.y,e,i.y),this.z=J.interpolate(t.z,e,i.z),this._isExteriorTarget=void 0,this}static createVertex(t){return new ws(t,t.x,t.y,t.z,R.Vertex)}resetAsVertex(t){return this._topo=R.Vertex,this._node=t,this._edgeFraction=0,this.setXYZFromNode(t),this._isExteriorTarget=void 0,this}setIsExteriorTarget(t){this._isExteriorTarget=t}setXYZFromNode(t){this.x=t.x,this.y=t.y,this.z=t.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===R.Face}get isEdge(){return this._topo===R.Edge}get isVertex(){return this._topo===R.Vertex}get isUnclassified(){return this._topo===R.None}get node(){return this._node}clonePoint(t){return K.create(this.x,this.y,this.z,t)}isAtXY(t,e){return this._topo!==R.None&&J.isSameCoordinate(this.x,t)&&J.isSameCoordinate(this.y,e)}}!function(t){t[t.RC_NoHits=0]="RC_NoHits",t[t.RC_TargetOnVertex=1]="RC_TargetOnVertex",t[t.RC_TargetOnEdge=2]="RC_TargetOnEdge",t[t.RC_Bracket=3]="RC_Bracket",t[t.RC_TargetBefore=4]="RC_TargetBefore",t[t.RC_TargetAfter=5]="RC_TargetAfter"}(D||(D={}));class Cs{constructor(t){this._tol=t}static create(t=J.smallMetricDistance){return new Cs(t)}panic(){return ws.create()}reAimFromEdge(t,e,i){const s=t.node,n=Ss.createNodeAndRayOrigin(s,e),r=Ss.createNodeAndRayOrigin(s.edgeMate,e),o=-n.classifyV(0,this._tol),a=-r.classifyV(0,this._tol);let c;if(o*a<0)c=o>0?t.resetAsFace(n.node):t.resetAsFace(r.node);else if(0===o||0===a){const e=n.classifyU(i,this._tol),s=r.classifyU(i,this._tol);if(0===e&&0===o)c=t.resetAsVertex(n.node),c.setITag(1);else if(0===s&&0===a)c=t.resetAsVertex(r.node),c.setITag(1);else if(e*s<0){const e=(i-n.u)/(r.u-n.u);c=t.resetAtEdgeAndFraction(n.node,e),c.setITag(1)}else e<0&&s<0?c=n.u>r.u?t.resetAsVertex(n.node):t.resetAsVertex(r.node):Math.abs(n.u)<this._tol&&Math.abs(n.v)<this._tol?c=t.resetAsVertex(n.node):Math.abs(r.u)<this._tol&&Math.abs(r.v)<this._tol?c=t.resetAsVertex(r.node):(t.resetAsUnknown(),c=this.panic())}else t.resetAsUnknown(),c=this.panic();return c}reAimFromVertex(t,e,i){const s=t.node;let n,r=s;do{const s=Ss.createNodeAndRayOrigin(r.faceSuccessor,e),o=Ss.createNodeAndRayOrigin(r.facePredecessor,e),a=s.u,c=s.v,h=o.v;if(Math.abs(c)<this._tol){if(Math.abs(a-i)<this._tol)return n=t.resetAsVertex(s.node),n.setITag(1),n;if(a>i){const e=i/a;return n=t.resetAtEdgeAndFraction(r,e),n}if(Math.abs(a)<=this._tol)return n=t.resetAsVertex(r),n.setITag(1),n;if(a>this._tol)return n=t.resetAsVertex(s.node),n;if(h>this._tol)return n=t.resetAsFace(r,r),n}else if(c<-this._tol&&h>this._tol)return n=t.resetAsFace(r,r),n;r=r.vertexSuccessor}while(r!==s);return this.panic()}reAimAroundFace(t,e,i,s,n){s.resetAsUndefinedWithTag(-Number.MAX_VALUE),n.resetAsUndefinedWithTag(Number.MAX_VALUE);const r=Ss.createNodeAndRayOrigin(t,e);let o,a=t;do{const t=a.faceSuccessor;o=Ss.createNodeAndRayOrigin(t,e,o);const c=r.u,h=o.u,l=r.v,d=o.v;if(Math.abs(d)<this._tol){const e=ws.createVertex(t);if(e.setDTag(h),Math.abs(h-i)<this._tol)return n.setFrom(e),s.setFrom(e),D.RC_TargetOnVertex;h>i&&h<n.getDTag()&&n.setFrom(e),h<i&&h>s.getDTag()&&s.setFrom(e)}else if(l*d<0){const t=-l/(d-l),e=J.interpolate(c,t,h),o=ws.createEdgeAtFraction(r.node,t);if(o.setDTag(e),Math.abs(e-i)<=this._tol)return n.setFrom(o),s.setFrom(o),D.RC_TargetOnEdge;e>i&&e<n.getDTag()&&(n.setFrom(o),n.setITag(l>0?-1:1)),e<i&&e>s.getDTag()&&(s.setFrom(o),s.setDTag(e))}r.setFrom(o),a=a.faceSuccessor}while(a!==t);const c=n.getITag();return n.setITag(0),s.setITag(0),s.isUnclassified?n.isUnclassified?D.RC_NoHits:D.RC_TargetBefore:n.isUnclassified||n.isEdge&&c&&c<0?D.RC_TargetAfter:D.RC_Bracket}setSearchRay(t,e,i){i.origin.setFromPoint3d(t),j.createStartEnd(i.origin,e,i.direction),i.direction.z=0;const s=i.direction.magnitudeXY();return i.a=i.direction.magnitude(),i.direction.scaleInPlace(1/i.a),s>=this._tol}}class Ts{constructor(t){this._graph=t,this._edgeSet=Is.create(t),this._searcher=ws.create()}static create(t){return new Ts(t)}get graph(){return this._graph}retriangulateFromBaseVertex(t){const e=t.countEdgesAroundFace();if(this._edgeSet.addAroundFace(t),e<4||t.signedFaceArea()<=0)return;const i=e-3;let s=t.faceSuccessor,n=t;for(let t=0;t<i;t++)s=s.faceSuccessor,n=this._graph.createEdgeHalfEdgeHalfEdge(n,0,s,0),s=n.faceSuccessor,this._edgeSet.addToSet(n)}reset(){this._searcher=ws.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(t){const e=ws.create();e.setDTag(Number.MAX_VALUE);const i=K.create();let s,n;for(const r of this._graph.allHalfEdges){const o=r.faceSuccessor;s=Ct.lineSegment3dXYClosestPointUnbounded(r,o,t),void 0!==s&&(s>1?(n=t.distanceXY(o),n<e.getDTag()&&(e.resetAsVertex(o),e.setDTag(n))):s<0?(n=t.distanceXY(r),n<e.getDTag()&&(e.resetAsVertex(r),e.setDTag(n))):(r.fractionToPoint3d(s,i),n=t.distanceXY(i),n<e.getDTag()&&e.resetAtEdgeAndFraction(r,s)))}return e}searchForNearestVertex(t){const e=ws.create();let i;e.setDTag(Number.MAX_VALUE);for(const s of this._graph.allHalfEdges)i=t.distanceXY(s),i<e.getDTag()&&(e.resetAsVertex(s),e.setDTag(i));return e}resetSearch(t,e){this._searcher=e>0?this.searchForNearestEdgeOrVertex(t):this.searchForNearestVertex(t)}insertAndRetriangulate(t,e){this.moveToPoint(this._searcher,t);const i=this._searcher.node;let s=!1;if(void 0===i);else if(this._searcher.isFace){if(!i.isMaskSet(k.EXTERIOR)){const e=this._graph.createEdgeXYZHalfEdge(t.x,t.y,t.z,0,i,0);this.retriangulateFromBaseVertex(e),ks.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}s=!0}else if(this._searcher.isEdge){const t=this._graph.splitEdgeAtFraction(i,this._searcher.edgeFraction),e=t.vertexPredecessor;this.retriangulateFromBaseVertex(t),this.retriangulateFromBaseVertex(e),ks.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(t),s=!0}else this._searcher.isVertex?(e&&i.setXYZAroundVertex(t.x,t.y,t.z),s=!0):s=!1;return s}moveToPoint(t,e,i){const s=Cs.create();if(t.setITag(0),t.isUnclassified&&(function(t,e,i,s){for(const i of t.allHalfEdges)if(!i.isMaskSet(0))return e.resetAtEdgeAndFraction(i,.5),!0}(this.graph,t),t.isUnclassified))return!1;let n=0;const r=kt.createXAxis();for(;0===t.getITag()&&n<2&&(void 0===i||i(t));){if(!s.setSearchRay(t,e,r))return!1;if(t.isFace){const i=ws.create(),o=ws.create();switch(s.reAimAroundFace(t.node,r,r.a,i,o)){case D.RC_NoHits:t.resetAsUnknown();break;case D.RC_TargetOnVertex:case D.RC_TargetOnEdge:t.setFrom(i),t.setITag(1);break;case D.RC_Bracket:t.resetAsFace(i.node,e),t.setITag(1);break;case D.RC_TargetBefore:t.resetAsFace(t.node,e),t.setITag(1);break;case D.RC_TargetAfter:t.node===i.node&&t.isFace&&(i.isEdge||i.isVertex)?n++:n=0,t.setFrom(i)}}else if(t.isEdge){if(s.reAimFromEdge(t,r,r.a),t.isUnclassified)break}else if(t.isVertex&&(s.reAimFromVertex(t,r,r.a),t.isUnclassified))break}return!!t.isAtXY(e.x,e.y)||n>1&&(void 0!==t.node&&t.setIsExteriorTarget(!0),!1)}}class ks{static flipEdgeBetweenTriangles(t,e,i,s,n,r){Gi.pinch(t,n),Gi.pinch(i,s),Gi.pinch(r,i),Gi.pinch(n,e),n.x=e.x,n.y=e.y,n.z=e.z,n.i=e.i,i.i=r.i,i.x=r.x,i.y=r.y,i.z=r.z}static computeInCircleDeterminantIsStrongPositive(t){const e=t.faceSuccessor,i=e.faceSuccessor;if(i.faceSuccessor!==t)return!1;const s=t.edgeMate,n=s.faceSuccessor.faceSuccessor;if(n.faceSuccessor!==s)return!1;const r=e.x-t.x,o=e.y-t.y,a=i.x-t.x,c=i.y-t.y;if(J.crossProductXYXY(r,o,a,c)<0)return!1;const h=n.x-t.x,l=n.y-t.y,d=h*h+l*l,u=a*a+c*c,f=r*r+o*o,g=J.tripleProduct(h,l,d,a,c,u,r,o,f);return!(g<0)&&g>1e-12*(Math.abs(h*c*f)+Math.abs(l*u*r)+Math.abs(d*a*o)+Math.abs(h*u*o)+Math.abs(l*a*f)+Math.abs(d*c*r))}static flipTriangles(t){const e=Is.create(t);for(const i of t.allHalfEdges)e.addToSet(i);const i=this.flipTrianglesInEdgeSet(t,e);return e.teardown(),i}static flipTrianglesInEdgeSet(t,e){const i=k.EXTERIOR|k.PRIMARY_EDGE|k.BOUNDARY_EDGE,s=10*t.allHalfEdges.length;let n,r=0,o=0;for(;void 0!==(n=e.chooseAndRemoveAny())&&(n.isMaskSet(i)||(ks.computeInCircleDeterminantIsStrongPositive(n)?(ks.flipEdgeBetweenTriangles(n.edgeMate.faceSuccessor,n.edgeMate.facePredecessor,n.edgeMate,n.faceSuccessor,n,n.facePredecessor),e.addAroundFace(n),e.addAroundFace(n.edgeMate),r++):o++,!(r+o>s))););return r}static createTriangulatedGraphFromPoints(t){if(t.length<3)return;const e=[],i=[];ne.computeConvexHullXY(t,e,i,!0);const s=new Ji,n=Ts.create(s);ks.createFaceLoopFromCoordinates(s,e,!0,!0);let r=0;for(const t of i)n.insertAndRetriangulate(t,!0),r++,r>16&&(r=0);return s}static createTriangulatedGraphFromLoops(t){if(t.length<1)return;const e=k.BOUNDARY_EDGE|k.PRIMARY_EDGE,i=new Ji,s=[];let n=-1e4,r=-1;for(let o=0;o<t.length;o++){let a=ks.directCreateFaceLoopFromCoordinates(i,t[o]);if(a){a=a.faceSuccessor;const t=a.vertexSuccessor;a.setMaskAroundFace(e),t.setMaskAroundFace(e);const i=a.signedFaceArea(),c=Math.abs(i);s.push(i>=0?a:t),(0===o||c>n)&&(n=c,r=o)}}if(0===s.length)return;const o=s[r];s[r]=s[s.length-1],s.pop(),o.vertexSuccessor.setMaskAroundFace(k.EXTERIOR);for(let t=0;t<s.length;t++){const e=s[t];e.setMaskAroundFace(k.EXTERIOR),s[t]=this.getLeftmost(e.vertexSuccessor)}const a=ks.spliceLeftMostNodesOfHoles(i,o,s);return a&&ks.triangulateSingleFace(i,a)?i:void 0}static triangulateAllPositiveAreaFaces(t){const e=t.collectFaceLoops();let i=0;for(const s of e)s.countEdgesAroundFace()>3&&s.signedFaceArea()>0&&(ks.triangulateSingleFace(t,s)||i++);return 0===i}static createTriangulatedGraphFromSingleLoop(t){const e=new Ji,i=ks.createFaceLoopFromCoordinates(e,t,!0,!0);return!i||e.countNodes()<6?e:ks.triangulateSingleFace(e,i)?(ks.flipTriangles(e),e):void 0}static interiorEdgeSplit(t,e,i){let s=0,n=0,r=0;if(Array.isArray(i))s=i[0],n=i[1],r=i.length>2?i[3]:0;else{const t=i;t.hasOwnProperty("x")&&(s=t.x),t.hasOwnProperty("y")&&(n=t.y),t.hasOwnProperty("z")&&(r=t.z)}return e&&(ks.isAlmostEqualXAndYXY(e,s,n)||ks.isAlmostEqualXAndYXY(e.faceSuccessor,s,n))?e:t.splitEdge(e,s,n,r)}static directCreateFaceLoopFromCoordinates(t,e){let i;if(e instanceof tt){const s=K.create();for(let n=0;n<e.length;n++)e.getPoint3dAtCheckedPointIndex(n,s),i=ks.interiorEdgeSplit(t,i,s)}else for(const s of e)i=ks.interiorEdgeSplit(t,i,s);return i}static directCreateChainsFromCoordinates(t,e,i=0){const s=new Fs(t,i);return ct.streamXYZ(e,s),s.claimSeeds()}static maskAndOrientNewFaceLoop(t,e,i,s,n){if(e){const t=(e=e.faceSuccessor).signedFaceArea(),r=e.edgeMate;s!==k.NULL_MASK&&(e.setMaskAroundFace(s),r.setMaskAroundFace(s));let o=e;i&&t<0&&(o=r);const a=o.vertexSuccessor;return n!==k.NULL_MASK&&a.setMaskAroundFace(n),o}}static createFaceLoopFromCoordinates(t,e,i,s){const n=ks.directCreateFaceLoopFromCoordinates(t,e);return ks.maskAndOrientNewFaceLoop(t,n,i,k.BOUNDARY_EDGE|k.PRIMARY_EDGE,s?k.EXTERIOR:k.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(t,e,i,s,n){const r=ks.directCreateFaceLoopFromCoordinates(t,e);return ks.maskAndOrientNewFaceLoop(t,r,i,s,n)}static joinNeighborsOfEar(t,e){const i=t.createEdgeXYZXYZ(e.facePredecessor.x,e.facePredecessor.y,e.facePredecessor.z,e.facePredecessor.i,e.faceSuccessor.x,e.faceSuccessor.y,e.faceSuccessor.z,e.faceSuccessor.i),s=i.edgeMate;Gi.pinch(e.faceSuccessor,s),Gi.pinch(e.facePredecessor,i),e.setMaskAroundFace(k.TRIANGULATED_FACE)}static isInteriorTriangle(t){if(!t.isMaskSet(k.TRIANGULATED_FACE)||t.isMaskSet(k.EXTERIOR))return!1;const e=t.faceSuccessor;if(!e.isMaskSet(k.TRIANGULATED_FACE)||e.isMaskSet(k.EXTERIOR))return!1;const i=e.faceSuccessor;return!(!i.isMaskSet(k.TRIANGULATED_FACE)||i.isMaskSet(k.EXTERIOR))&&i.faceSuccessor===t}static doPostCutFlips(t){let e=t,i=e.facePredecessor,s=i.edgeMate;for(;ks.isInteriorTriangle(i)&&ks.isInteriorTriangle(s)&&ks.computeInCircleDeterminantIsStrongPositive(i);){const t=s.faceSuccessor;ks.flipEdgeBetweenTriangles(t,t.faceSuccessor,t.facePredecessor,e,e.facePredecessor,e.faceSuccessor),e=i,i=e.facePredecessor,s=i.edgeMate}return e}static triangulateSingleFace(t,e){if(!e)return ks.setDebugGraph(t),!1;let i,s,n,r=e.countEdgesAroundFace(),o=0;for(e.clearMaskAroundFace(k.TRIANGULATED_FACE);!e.isMaskSet(k.TRIANGULATED_FACE);){if(n=e?.facePredecessor,i=e.faceSuccessor,s=i.faceSuccessor,i===e||s===e)return!0;if(s.faceSuccessor===e)return e.setMaskAroundFace(k.TRIANGULATED_FACE),!0;if(!J.isAlmostEqualXAndY(s,n)||s.findAroundVertex(n)){if(++o>r)return ks.setDebugGraph(t),!1;ks.isEar(e)?(r--,o=0,e.faceSuccessor.faceSuccessor!==e.facePredecessor?(ks.joinNeighborsOfEar(t,e),e=(e=ks.doPostCutFlips(e)).faceSuccessor.edgeMate.faceSuccessor):(e.setMaskAroundFace(k.TRIANGULATED_FACE),e=i.faceSuccessor)):e=i}else Gi.pinch(n,s),e.setMaskAroundFace(k.TRIANGULATED_FACE),e=s}return!0}static claimDebugGraph(){const t=ks.sDebugGraph;return ks.sDebugGraph=void 0,ks.sEnableDebugGraphCapture=!1,t}static setDebugGraph(t){ks.sEnableDebugGraphCapture&&(ks.sDebugGraph=t)}static clearAndEnableDebugGraphCapture(t){ks.sEnableDebugGraphCapture=t,ks.sDebugGraph=void 0}static isEar(t){const e=t.facePredecessor,i=t,s=t.faceSuccessor,n=ks.signedTolerancedCCWTriangleArea(e,i,s);if(n<=0)return!1;const r=this._planes;if(!mt.createOriginAndTargetXY(e,i,r[0])||!mt.createOriginAndTargetXY(i,s,r[1])||!mt.createOriginAndTargetXY(s,e,r[2]))return!1;const o=this._earRange,a=this._edgeRange,c=this._edgeInterval;ut.createXYXYXY(e.x,e.y,i.x,i.y,s.x,s.y,o),o.expandInPlace(J.smallMetricDistance);let h=s;const l=1e-10*n;for(;h!==e;){const t=h.faceSuccessor;if(ut.createXYXY(h.x,h.y,t.x,t.y,a),o.intersectsRange(a)&&(dt.createXX(-1e-8,1.00000001,c),ys.clipSegmentBelowPlanesXY(r,h,t,c,l),!c.isNull)){const n=h.edgeMate;if(n===e||n===i);else if(c.low>.99999999){if(!e.findAroundVertex(t)&&!i.findAroundVertex(t)&&!s.findAroundVertex(t))return!1}else{if(!(c.high<1e-8))return!1;if(!e.findAroundVertex(h)&&!i.findAroundVertex(h)&&!s.findAroundVertex(h))return!1}}h=h.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(t,e,i){i.sort(ks.compareX);let s=0;for(const n of i)ks.eliminateHole(t,n,e)||s++;return 0===s?e:void 0}static compareX(t,e){return t.x-e.x}static eliminateHole(t,e,i){const s=ks.findHoleBridge(e,i);return!!s&&void 0!==ks.splitFace(t,s,e)}static findHoleBridge(t,e){let i=e;if(!i)return;const s=t.x,n=t.y;let r,o=-1/0;do{if(n<=i.y&&n>=i.faceSuccessor.y&&i.faceSuccessor.y!==i.y){const t=i.x+(n-i.y)*(i.faceSuccessor.x-i.x)/(i.faceSuccessor.y-i.y);if(t<=s&&t>o){if(o=t,t===s){if(n===i.y)return i;if(n===i.faceSuccessor.y)return i.faceSuccessor}r=i.x<i.faceSuccessor.x?i:i.faceSuccessor}}i=i.faceSuccessor}while(i!==e);if(!r)return;if(s===o)return r.facePredecessor;const a=r,c=r.x,h=r.y;let l,d=1/0;for(i=r.faceSuccessor;i!==a;)s>=i.x&&i.x>=c&&s!==i.x&&ks.pointInTriangle(n<h?s:o,n,c,h,n<h?o:s,n,i.x,i.y)&&(l=Math.abs(n-i.y)/(s-i.x),(l<d||l===d&&i.x>r.x)&&ks.locallyInside(i,t)&&(r=i,d=l)),i=i.faceSuccessor;return r}static getLeftmost(t){let e=t,i=t;do{e.x<i.x&&(i=e),e=e.faceSuccessor}while(e!==t);return i}static pointInTriangle(t,e,i,s,n,r,o,a){return(n-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(s-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(n-o)*(s-a)>=0}static nodeInTriangle(t,e,i,s){return ks.signedTolerancedCCWTriangleArea(t,e,s)>0&&ks.signedTolerancedCCWTriangleArea(e,i,s)>0&&ks.signedTolerancedCCWTriangleArea(i,t,s)>0}static signedCWTriangleArea(t,e,i){return.5*((e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y))}static signedTolerancedCCWTriangleArea(t,e,i,s=1e-12){const n=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y,c=.5*(n*a-r*o);return c<0?c:c<s*(n*n+r*r+(o*o+a*a))?0:c}static isAlmostEqualXAndYXY(t,e,i){return J.isAlmostEqualNumber(t.x,e)&&J.isAlmostEqualNumber(t.y,i)}static locallyInside(t,e){return ks.signedCWTriangleArea(t.facePredecessor,t,t.faceSuccessor)<0?ks.signedCWTriangleArea(t,e,t.faceSuccessor)>=0&&ks.signedCWTriangleArea(t,t.facePredecessor,e)>=0:ks.signedCWTriangleArea(t,e,t.facePredecessor)<0||ks.signedCWTriangleArea(t,t.faceSuccessor,e)<0}static splitFace(t,e,i){if(Gi.isNodeVisibleInSector(e,i)&&Gi.isNodeVisibleInSector(i,e)){const s=t.createEdgeXYZXYZ(e.x,e.y,e.z,e.i,i.x,i.y,i.z,i.i),n=s.faceSuccessor;return Gi.pinch(e,s),Gi.pinch(i,n),s}}static triangulateSingleMonotoneFace(t,e){let i,s=e.facePredecessor,n=e.faceSuccessor;for(;s!==n&&n!==e&&n.faceSuccessor!==s;){if(Gi.crossProductXYAlongChain(s,e,n)<=0)return!1;if(!e.belowYX(s))return!1;if(!e.belowYX(n))return!1;if(s.belowYX(n)){let r=s,o=e,a=n;for(;r!==a&&r.belowYX(n);){for(;a!==n&&a!==r&&a!==o&&Gi.crossProductXYAlongChain(r,o,a)>0;){if(i=ks.splitFace(t,r,a),void 0===i)return!1;r=i,o=r.faceSuccessor,a=o.faceSuccessor}a=o,o=r,r=r.facePredecessor}for(s=o,a=n,o=a.facePredecessor,r=o.facePredecessor;a.faceSuccessor!==r&&r!==s;){if(i=ks.splitFace(t,r,a),void 0===i)return!1;o=i,r=o.facePredecessor}if(a.faceSuccessor!==r){if(i=ks.splitFace(t,r,a),void 0===i)return!1;r=i}n=(e=r).faceSuccessor,s=e.facePredecessor}else{let r=s,o=e,a=n;for(;r!==a&&a.belowYX(s);){for(;r!==s&&a!==r&&a!==o&&Gi.crossProductXYAlongChain(r,o,a)>0;){if(i=ks.splitFace(t,r,a),void 0===i)return!1;r=i.facePredecessor,o=i}r=o,o=a,a=a.faceSuccessor}for(n=o,r=s,o=r.faceSuccessor,a=o.faceSuccessor;a.faceSuccessor!==r&&a!==n;){if(i=ks.splitFace(t,r,a),void 0===i)return!1;r=i,a=a.faceSuccessor}if(a.faceSuccessor!==r&&void 0===ks.splitFace(t,r,a))return!1;n=(e=n).faceSuccessor,s=e.facePredecessor}}return!0}}ks.sEnableDebugGraphCapture=!1,ks._edgeInterval=dt.createNull(),ks._earRange=ut.createNull(),ks._edgeRange=ut.createNull(),ks._planes=[mt.createXYPlane(),mt.createXYPlane(),mt.createXYPlane()];class Fs extends nt{constructor(t,e){super(),this._graph=t,this._id=e}startChain(t,e){super.startChain(t,e),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(t,e,i,s,n,r){this._nodeC=this._graph.createEdgeXYZXYZ(t,e,i,this._id,s,n,r,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(Gi.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(t,e){super.endChain(t,e),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class Ms{constructor(){this.numUpEdge=0,this.numIntersectionTest=0,this.numSplit=0,this.numPopOut=0,this.numA0B0=0,this.numA0B1=0}}class bs{constructor(t,e,i,s){this.index=t,this.radiusOfCurvature=e,this.node=i,this.radians=s}}class Es{static compareNodesYXUp(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static isDownPeak(t){const e=t.facePredecessor,i=t.faceSuccessor;return this.compareNodesYXUp(t,e)<0&&this.compareNodesYXUp(t,i)<0&&this.crossProductToTargets(t,e,i)>0}static crossProductToTargets(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static graphRange(t){const e=lt.create();for(const i of t.allHalfEdges)e.extendXYZ(i.x,i.y,i.z);return e}static segmentArrayToGraphEdges(t,e,i){const s=[];let n=0;for(const r of t){const t=e.createEdgeXYZXYZ(r.point0Ref.x,r.point0Ref.y,r.point0Ref.z,n,r.point1Ref.x,r.point1Ref.y,r.point1Ref.z,n+1),o=t.edgeMate;n+=2,t.setMaskAroundFace(i),s.push(t),s.push(o)}return s}static isolateAllEdges(t){for(const e of t.allHalfEdges){const t=e.vertexPredecessor;Gi.pinch(e,t)}}static isSectorConvexAfterEdgeRemoval(t,e,i){let s=t;do{if(s.isMaskSet(i)||s.edgeMate.isMaskSet(i))break;s=s.vertexSuccessor}while(s!==t&&s.isMaskSet(e));if(s===t)return!1;let n=t;do{if(n.isMaskSet(i)||n.edgeMate.isMaskSet(i))break;n=n.vertexPredecessor}while(n!==t&&n.isMaskSet(e));return n!==t&&Gi.isSectorConvex(s.edgeMate,t,n.faceSuccessor)}static markRemovableEdgesToExpandConvexFaces(t,e,i=k.BOUNDARY_EDGE){if(k.NULL_MASK===e)return 0;const s=t.grabMask(!0);let n=0;for(const r of t.allHalfEdges)r.isMaskSet(s)||r.isMaskSet(i)||r.edgeMate.isMaskSet(i)||this.isSectorConvexAfterEdgeRemoval(r,e,i)&&this.isSectorConvexAfterEdgeRemoval(r.edgeMate,e,i)&&(r.setMaskAroundEdge(e),++n),r.setMaskAroundEdge(s);return n}static collectRemovableEdgesToExpandConvexFaces(t,e=k.BOUNDARY_EDGE){const i=[],s=t.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(t,s,e)){const e=t.grabMask(!0);for(const n of t.allHalfEdges)n.isMaskSet(s)&&!n.isMaskSet(e)&&(n.setMaskAroundEdge(e),i.push(n));t.dropMask(e)}return t.dropMask(s),i}static expandConvexFaces(t,e=k.BOUNDARY_EDGE){const i=t.grabMask(!0),s=this.markRemovableEdgesToExpandConvexFaces(t,i,e);return s>0&&t.yankAndDeleteEdges((t=>t.getMask(i))),t.dropMask(i),s}static isEveryFaceConvex(t,e=k.EXTERIOR){const i=t.collectFaceLoops();for(const t of i)if(!t.isMaskedAroundFace(e)&&!t.isFaceConvex())return!1;return!0}}class Xs{static getCommonThetaEndIndex(t,e,i,s){let n=i+1;const r=t.getExtraData(e[i],0);for(;n<s;){const i=t.getExtraData(e[n],0);if(!Z.isAlmostEqualRadiansAllowPeriodShift(r,i))return n;n++}return n}static set announceVertexNeighborhoodFunction(t){this._announceVertexNeighborhoodFunction=t}static doAnnounceVertexNeighborhood(t,e,i,s,n){if(this._announceVertexNeighborhoodFunction){const r=[];for(let o=s;o<n;o++){const s=t.getExtraData(e[o],1),n=t.getExtraData(e[o],0),a=i[s],c=this.curvatureSortKey(a);r.push(new bs(e[o],c,a,n))}this._announceVertexNeighborhoodFunction(r)}}static secondarySortAroundVertex(t,e,i,s,n){const r=[];for(let o=s;o<n;){const s=this.getCommonThetaEndIndex(t,e,o,n);if(o+1<s){r.length=0;for(let n=o;n<s;n++){const s=i[t.getExtraData(e[n],1)],o=this.curvatureSortKey(s);r.push(new bs(e[n],o,s))}r.sort(((t,e)=>t.radiusOfCurvature-e.radiusOfCurvature));for(let t=0;t<r.length;t++)e[o+t]=r[t].index}o=s}}static curvatureSortKey(t){const e=t.edgeTag;if(void 0!==e){const i=e.fraction,s=e.curve;if(s){let e=s.fractionToSignedXYRadiusOfCurvature(i);return void 0!==t.sortData&&t.sortData<0&&(e=-e),e}}return 0}static clusterAndMergeXYTheta(t,e){const i=t.allHalfEdges,s=i.length;t.clearMask(k.NULL_FACE);const n=new Ci(2,2,s);for(let t=0;t<s;t++){const e=i[t],s=e.x,r=e.y;Gi.pinch(e,e.vertexSuccessor),n.addDirect(s,r,0,t)}const r=J.smallMetricDistance,o=n.clusterIndicesLexical(r);let a=0;const c=o.length;for(let t=0;t<c;t++)if(o[t]===Ci.clusterTerminator){if(t>a){const e=i[n.getExtraData(o[a],1)];for(let s=a+1;s<t;s++){const t=i[n.getExtraData(o[s],1)];t.x=e.x,t.y=e.y}}a=t+1}for(const t of o)if(t!==Ci.clusterTerminator){const s=i[t],r=s.faceSuccessor;let o=e;if(o){const t=s.edgeTag;(void 0===t||void 0===t.curve||t.curve instanceof tr)&&(o=void 0)}let a=o?o(s):Math.atan2(r.y-s.y,r.x-s.x);Z.isAlmostEqualRadiansAllowPeriodShift(a,-Math.PI)&&(a=Math.PI),n.setExtraData(t,0,a)}n.sortSubsetsBySingleKey(o,2);const h=[];let l,d;a=0;for(let t=0;t<c;t++)if(o[t]===Ci.clusterTerminator){if(t>a){t>a+1&&this.secondarySortAroundVertex(n,o,i,a,t),this.doAnnounceVertexNeighborhood(n,o,i,a,t);const e=n.getExtraData(o[a],1);l=n.getExtraData(o[a],0);let s=i[e];for(let e=a+1;e<t;e++){const t=n.getExtraData(o[e],1);d=n.getExtraData(o[e],0);const a=i[t];if(s.isMaskSet(k.NULL_FACE)){const t=h.findIndex((t=>s===t));t>=0&&(h[t]=h[h.length-1],h.pop()),s=a,l=d}else if(a.isMaskSet(k.NULL_FACE)){const t=h.findIndex((t=>a===t));t>=0&&(h[t]=h[h.length-1],h.pop())}else{if(Gi.pinch(s,a),Z.isAlmostEqualRadiansAllowPeriodShift(l,d)){const t=s.faceSuccessor,e=a.edgeMate;if(t.isEqualXY(e)){const i=this.curvatureSortKey(s),n=this.curvatureSortKey(a);J.isSameCoordinate(i,n,r)&&(Gi.pinch(t,e),s.setMask(k.NULL_FACE),e.setMask(k.NULL_FACE),h.push(e))}}s=a,l=d}}}a=t+1}}static buildVerticalSweepPriorityQueue(t){const e=new ts;for(const i of t.allHalfEdges)Es.compareNodesYXUp(i,i.faceSuccessor)<0&&e.priorityQueue.push(i);return e}static snapFractionToNode(t,e,i,s){return J.isSameCoordinate(t.x,i.x)&&J.isSameCoordinate(t.y,i.y)?s:e}static computeIntersectionFractionsOnEdges(t,e,i,s,n){const r=t.faceSuccessor,o=t.x,a=t.y,c=r.x-o,h=r.y-a,l=e.faceSuccessor,d=e.x,u=e.y,f=l.x-d,g=l.y-u;return!!Ct.lineSegmentXYUVTransverseIntersectionUnbounded(o,a,c,h,d,u,f,g,i)&&(s.x=o+i.x*c,s.y=a+i.x*h,n.x=d+i.y*f,n.y=u+i.y*g,i.x=this.snapFractionToNode(s,i.x,t,0),i.x=this.snapFractionToNode(s,i.x,r,1),i.y=this.snapFractionToNode(n,i.y,e,0),i.y=this.snapFractionToNode(n,i.y,l,1),J.isIn01(i.x)&&J.isIn01(i.y))}static splitIntersectingEdges(t){const e=new Ms,i=this.buildVerticalSweepPriorityQueue(t);let s,n;const r=.99999999;let o;const a=G.create(),c=W.create(),h=W.create();let l;const d=J.smallMetricDistance;for(;void 0!==(s=i.priorityQueue.pop());){e.numUpEdge++;const u=i.activeEdges.length;for(i.removeArrayMembersWithY1Below(s.y-d),e.numPopOut+=u-i.activeEdges.length,o=0;o<i.activeEdges.length;o++)if(l=i.activeEdges[o],n=l.faceSuccessor,J.isSameCoordinateXY(s.x,s.y,l.x,l.y))e.numA0B0++;else if(J.isSameCoordinateXY(n.x,n.y,s.x,s.y))e.numA0B1++;else if(e.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(s,l,a,c,h)){if(a.x>1e-8&&a.x<r){const n=t.splitEdgeAtFraction(s,a.x);i.priorityQueue.push(n),e.numSplit++}if(a.y>1e-8&&a.y<r){const s=t.splitEdgeAtFraction(l,a.y);i.priorityQueue.push(s),e.numSplit++}}i.activeEdges.push(s)}return e}static formGraphFromSegments(t){const e=new Ji;return Es.segmentArrayToGraphEdges(t,e,k.BOUNDARY_EDGE),this.splitIntersectingEdges(e),this.clusterAndMergeXYTheta(e),e}static formGraphFromChains(t,e=!0,i=k.PRIMARY_EDGE){if(t.length<1)return;const s=new Ji,n=ks.directCreateChainsFromCoordinates(s,t);for(const t of n)t.setMaskAroundFace(i);return this.splitIntersectingEdges(s),this.clusterAndMergeXYTheta(s),e&&new es(s).regularizeGraph(!0,!0),s}}class zs{static createPrimarySortVector(t){return void 0===t&&(t=this._defaultPrimarySortDirection.clone()),t.normalizeWithDefault(zs._defaultPrimarySortDirection.x,zs._defaultPrimarySortDirection.y,zs._defaultPrimarySortDirection.z)}constructor(t,e){this.tolerance=t,this.primarySortDirection=e}static createFromUnValidated(t){const e=new zs(J.smallMetricDistance,zs.createPrimarySortVector());return void 0!==t&&(void 0!==t.tolerance&&(e.tolerance=t.tolerance),void 0!==t.primarySortDirection&&(e.primarySortDirection=zs.createPrimarySortVector())),e}clone(){return new zs(this.tolerance,this.primarySortDirection)}}zs._defaultPrimarySortDirection=j.create(.294234298,.72391399,.45234328798);class Rs{constructor(t){this._graph=new Ji,this._options=t}set plane(t){this._plane=t}get plane(){return this._plane}set convexClipper(t){this._convexClipper=t}get convexClipper(){return this._convexClipper}static create(t){const e=zs.createFromUnValidated(t);return new Rs(e)}addSegment(t,e){this._graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0)}addLineSegment3dArray(t){for(const e of t)this.addSegment(e.point0Ref,e.point1Ref)}addSegmentsOnPlane(t,e=!1){if(!this._plane)return;const i=this._plane;let s,n=e?t.length-1:0,r=t.evaluateUncheckedIndexPlaneAltitude(n,i),o=e?0:1;for(;o<t.length;n=o++,r=s)s=t.evaluateUncheckedIndexPlaneAltitude(o,i),J.isSmallMetricDistance(r)&&J.isSmallMetricDistance(s)&&this._graph.createEdgeXYZXYZ(t.getXAtUncheckedPointIndex(n),t.getYAtUncheckedPointIndex(n),t.getZAtUncheckedPointIndex(n),0,t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getZAtUncheckedPointIndex(o),0)}primarySortKey(t){return this._options.primarySortDirection.dotProductXYZ(t.x,t.y,t.z)}static nodeCompareSortData(t,e){return t.sortData-e.sortData}static isIsolatedEnd(t){return t.vertexSuccessor===t}static isChainInteriorVertex(t){const e=t.vertexSuccessor;return e!==t&&e.vertexSuccessor===t}clusterAndMergeVerticesXYZ(){Es.isolateAllEdges(this._graph);for(const t of this._graph.allHalfEdges)t.sortData=this.primarySortKey(t);const t=this._graph.allHalfEdges.slice();t.sort(Rs.nodeCompareSortData);const e=this._options.tolerance,i=t.length;for(let s=0;s<i;s++){const n=t[s],r=n.sortData+e;if(Rs.isIsolatedEnd(n))for(let o=s+1;o<i;o++){const i=t[o];if(Rs.isIsolatedEnd(i)){if(i.sortData>r)break;n.distanceXYZ(i)<=e&&(Gi.pinch(n,i),i.setXYZFrom(n))}}}}collectMaximalLineString3dFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=ye.create();for(s.addPointXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.addPointXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Rs.isChainInteriorVertex(e););t.push(s)}}collectMaximalGrowableXYXArrayFromStartNode(t,e,i){if(!e.isMaskSet(i)){const s=new it;for(s.pushXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,s.pushXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Rs.isChainInteriorVertex(e););s.length>0&&t.push(s)}}exciseAndMarkSlingEdges(t){let e=0;for(const i of this._graph.allHalfEdges)if(i.distanceXYZ(i.edgeMate)<this._options.tolerance&&!i.isMaskSet(t)){const s=i.edgeMate;Gi.pinch(i,i.vertexPredecessor),Gi.pinch(s,s.vertexPredecessor),i.setMask(t),s.setMask(t),e++}return e}collectMaximalChains(){const t=[],e=k.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Rs.isChainInteriorVertex(i)||this.collectMaximalLineString3dFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(t,i,e);return t}collectMaximalGrowableXYZArrays(){const t=[],e=k.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Rs.isChainInteriorVertex(i)||this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);return t}}class Ds{constructor(t){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,t&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(t,e){e<0?(this.numNegative++,this.negativeSum+=e,this.negativeItemArray&&this.negativeItemArray.push(t),e<this.largestNegativeValue&&(this.largestNegativeValue=e,this.largestNegativeItem=t)):e>0?(this.numPositive++,this.positiveSum+=e,this.positiveItemArray&&this.positiveItemArray.push(t),e>this.largestPositiveValue&&(this.largestPositiveValue=e,this.largestPositiveItem=t)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(t))}}class Ns{constructor(t,e=!0){this._targetMask=t,this._targetValue=e}testEdge(t){return t.isMaskSet(this._targetMask)===this._targetValue}}class Ys{static pushAndMaskAllNodesInFace(t,e,i,s){s.push(t),t.collectAroundFace((t=>{t.setMask(e),i.push(t)}))}static findMinimumAreaFace(t,e){return Ys.collectFaceAreaSummary(t,!1,e).largestNegativeItem}static signedFaceArea(t){return t.signedFaceArea()}static collectFaceAreaSummary(t,e=!1,i=Ys.signedFaceArea){const s=new Ds(e);let n;n=t instanceof Ji?t.collectFaceLoops():t;for(const t of n){const e=i(t);s.announceItem(t,e)}return s}static isTriangulatedCCW(t,e=!0,i=0){let s;s=t instanceof Ji?t.collectFaceLoops():t;let n=0,r=0;for(const t of s){const s=t.countEdgesAroundFace();if(s>=3)if(t.signedFaceArea()>0){if(s>3&&(r++,r>i))return!1}else if(n++,n>1&&!e)return!1}return!0}static parityFloodFromSeed(t,e,i,s){const n=[];if(t.isMaskSet(e))return n;const r=s|e,o=[];for(Ys.pushAndMaskAllNodesInFace(t,r,o,n);o.length>0;){const t=o.pop(),a=t.edgeMate;if(a&&!a.isMaskSet(e)){let c=t.isMaskSet(s);i&&!i.testEdge(t)||(c=!c),Ys.pushAndMaskAllNodesInFace(a,c?r:e,o,n)}}return n}static correctParityInSingleComponent(t,e,i){const s=Ys.findMinimumAreaFace(i);if(s)if(s.isMaskSet(e));else for(const t of i)t.isMaskSet(e)?t.clearMaskAroundFace(e):t.setMaskAroundFace(e)}static correctParityInComponentArrays(t,e,i){if(e!==k.NULL_MASK)for(const s of i)Ys.correctParityInSingleComponent(t,e,s)}static collectConnectedComponentsWithExteriorParityMasks(t,e,i=k.NULL_MASK){const s=[],n=k.VISITED,r=i|n;t.clearMask(r);for(const r of t.allHalfEdges)if(!r.isMaskSet(k.VISITED)){const t=Ys.parityFloodFromSeed(r,n,e,i);s.push(t)}return Ys.correctParityInComponentArrays(t,i,s),s}static pointInOrOnFaceXY(t,e,i){const s=new Xt(e,i);let n=t,r=t.faceSuccessor;for(;!s.tryStartEdge(n.x,n.y,r.x,r.y);n=r){if(r===t)return s.classifyCounts();r=n.faceSuccessor}let o=r.faceSuccessor;for(;;){if(!s.advance(o.x,o.y))return s.classifyCounts();if(o===r)break;o=o.faceSuccessor}return s.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(t,e,i,s){let n=0;for(;!t.getMask(e)&&i(t);){s(t,n++),t.setMask(e);const r=t.faceSuccessor;let o=r;for(;;){if(o.getMask(e))return;if(i(o)){t=o;break}if(o=o.vertexPredecessor,o===r)break}}}static collectExtendedBoundaryLoopsInGraph(t,e){const i=[],s=t.grabMask(!0),n=t=>0===t.getMask(e)&&0!==t.edgeMate.getMask(e),r=(t,e)=>{0===e&&i.push([]),i[i.length-1].push(t)};for(const e of t.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(e,s,n,r);return t.dropMask(s),i}}class Os extends Float64Array{get vertexIndexA(){return this[0]}get vertexIndexB(){return this[1]}get facetIndex(){return this[2]}get isLowHigh(){return this[0]<this[1]}get lowVertexIndex(){return this[0]<this[1]?this[0]:this[1]}get highVertexIndex(){return this[0]>this[1]?this[0]:this[1]}static areDirectedPartners(t,e){return t[0]===e[1]&&t[1]===e[0]}static areUndirectedPartners(t,e){return t[0]===e[0]&&t[1]===e[1]||t[0]===e[1]&&t[1]===e[0]}static relativeOrientation(t,e){return t[0]===e[0]&&t[1]===e[1]?1:t[0]===e[1]&&t[1]===e[0]?-1:0}get isNullEdge(){return this[0]===this[1]}static lessThan(t,e){const i=t.lowVertexIndex,s=e.lowVertexIndex;if(i<s)return-1;if(s<i)return 1;const n=t.highVertexIndex,r=e.highVertexIndex;return n<r?-1:r<n?1:t.vertexIndexA-e.vertexIndexA}constructor(t,e,i){super(3),this[0]=t,this[1]=e,this[2]=i}toJSON(){return[this[0],this[1],this[2]]}static clusterToJSON(t){if(t instanceof Os)return t.toJSON();const e=[];for(const i of t)e.push(i.toJSON())}static clusterArrayToJSON(t){const e=[];for(const i of t)e.push(Os.clusterToJSON(i));return e}}class Bs{constructor(){this.edges=[]}addEdge(t,e,i){const s=new Os(t,e,i);return this.edges.push(s),s}addPath(t,e,i=!0){if(0===t.length)return;const s=t.length-1;for(let i=0;i<s;i++)this.addEdge(t[i],t[i+1],e);i&&this.addEdge(t[s],t[0],e)}sort(){this.edges.sort(Os.lessThan)}collectSortableEdgeCluster(t,e,i){if(void 0!==i&&e>t)if(e===t+1)i.push(this.edges[t]);else{const s=[];for(let i=t;i<e;i++)s.push(this.edges[i]);i.push(s)}}sortAndCollectClusters(t,e,i,s){this.sort(),t&&(t.length=0),e&&(e.length=0),i&&(i.length=0),s&&(s.length=0);const n=this.edges.length;let r;for(let o=0;o<n;o+=r){const a=this.edges[o];r=1;for(let t=o+1;t<n&&Os.areUndirectedPartners(a,this.edges[t]);t++)r++;this.edges[o].isNullEdge?this.collectSortableEdgeCluster(o,o+r,i):2===r&&Os.areDirectedPartners(a,this.edges[o+1])?this.collectSortableEdgeCluster(o,o+r,t):1===r?this.collectSortableEdgeCluster(o,o+1,e):this.collectSortableEdgeCluster(o,o+r,s)}}}class Vs{constructor(t){this.numPositive=this.numNegative=0,this.firstEdgeIndex=t}recordOrientation(t){t>0?this.numPositive++:t<0&&this.numNegative++}}class Ls{constructor(t){this._workArray=[],this._visitor=t.createVisitor(1),this._edges=un.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=t}edgeIdToFacetOrientation(t){const e=this._edges.edges[t].facetIndex;return this._facetOrientation[e]}setupUnoriented(){this._edges.sort();const t=this._edges.edges;let e=-1;const i=this._edges.edges.length;for(let t=0;t<i;t++){const i=this._edges.edges[t].facetIndex;i>e&&(e=i),this._edgeToEdgeInComponent.push(t),this._edgeToPartnerEdge.push(t)}for(let t=0;t<=e;t++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let t=0;t<i;t++){const e=this._edges.edges[t].facetIndex,i=this._facetToFirstEdgeInComponent[e];-1===i?this._facetToFirstEdgeInComponent[e]=t:Ls.swapEntries(this._edgeToEdgeInComponent,t,i)}for(let e=0;e<i;e++){let s=e+1;for(;s<i&&Os.areUndirectedPartners(t[e],t[s]);)Ls.swapEntries(this._edgeToPartnerEdge,e,s),s++;if(s>e+2)return!1}return!0}recordFacetInComponent(t,e){const i=this._components[this._components.length-1];this._facetOrientation[t]=e,i.recordOrientation(e)}initializeComponent(t){const e=this._edges.edges[t].facetIndex;this._components.push(new Vs(t)),this.recordFacetInComponent(e,1)}pushFacetEdgesOnStack(t,e){Ls.extractCyclicIndices(this._edgeToEdgeInComponent,t,this._workArray);for(const t of this._workArray)e.push(t)}doFlood(){const t=[],e=this._edges.edges,i=e.length,s=[];for(let n=0;n<i;n++)if(0===this.edgeIdToFacetOrientation(n)){let i;for(t.length=0,this.initializeComponent(n),this.pushFacetEdgesOnStack(n,t);void 0!==(i=t.pop());){const n=e[i].facetIndex,r=this._facetOrientation[n];Ls.extractCyclicIndices(this._edgeToPartnerEdge,i,s);for(const n of s)if(n!==i){const s=e[n].facetIndex,o=this._facetOrientation[s];if(0===o){const o=Os.areDirectedPartners(e[i],e[n])?r:-r;this.recordFacetInComponent(s,o),this.pushFacetEdgesOnStack(n,t),Ls.swapEntries(this._edgeToEdgeInComponent,i,n)}else if(Os.relativeOrientation(e[i],e[n])*r*o>0)return!1}}}return!0}doFacetReversals(){let t=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const e=this._visitor.currentReadIndex();this._facetOrientation[e]<0&&(t++,this._mesh.reverseSingleFacet(e))}return t}static doFixup(t){const e=new Ls(t);if(!e.setupUnoriented())return!1;const i=e.doFlood();return i&&e.doFacetReversals(),i}static swapEntries(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}static extractCyclicIndices(t,e,i){i.length=0;let s=e;do{i.push(s),s=t[s]}while(s!==e)}}class Us{constructor(t,e,i){this.index=t,this.area=e,this.normal=i}addWeightedNormal(t,e){this.area+=t,this.normal.addScaledInPlace(e,t)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class Zs{constructor(t,e,i){this.facetData=t,this.sectorClusterData=void 0,this.sectorIndex=e,this.vertexIndex=i}static cbSectorSort(t,e){return t.sectorIndex-e.sectorIndex}static cbVertexSort(t,e){return t.vertexIndex-e.vertexIndex}static pushToArray(t,e,i,s){t.push(new Zs(e,i,s))}}class qs{static buildFastAverageNormals(t,e){const i=t.createVisitor(0),s=j.create(0,0,1),n=J.smallMetricDistanceSquared,r=[];let o=0,a=0;for(;i.moveToNextFacet();){const t=fr.areaNormalGo(i.point);let e=t.magnitude();e<n?(t.setFromVector3d(s),e=0):t.scaleInPlace(1/e);const c=new Us(o++,e,t);for(let t=0;t<i.pointCount;t++)Zs.pushToArray(r,c,a++,i.clientPointIndex(t))}r.sort(Zs.cbVertexSort);const c=[];let h=e.radians;h<1e-4&&(h=1e-4);let l=0;for(let t=0;t<r.length;t++){const e=r[t],i=e.vertexIndex,s=e.facetData;if(void 0===e.sectorClusterData){const n=new Us(l++,0,j.createZero());c.push(n),n.addWeightedNormal(1,e.facetData.normal.clone());for(let e=t;e<r.length;e++){const t=r[e];if(t.vertexIndex!==i)break;t.facetData.normal.angleTo(s.normal).radians>h||void 0===t.sectorClusterData&&(n.addWeightedNormal(1,t.facetData.normal),t.sectorClusterData=n)}}}r.sort(Zs.cbSectorSort),t.data.normalIndex=[],t.data.normal=new it(r.length);for(const e of c)e.divideNormalByArea(),e.index=t.data.normal.length,t.data.normal.push(e.normal);for(const e of r)t.data.normalIndex.push(e.sectorClusterData.index)}static buildPerFaceNormals(t){const e=t.createVisitor(0),i=j.create(0,0,1),s=j.create(0,0,1),n=new it(t.faceCount),r=[];for(;e.moveToNextFacet();){const t=n.length;fr.unitNormal(e.point,i)?n.push(i):n.push(s);for(let i=0;i<e.pointCount;i++)r.push(t)}t.data.normalIndex=r,t.data.normal=n}}class Ws{constructor(t){this._segmentPoint0=K.create(),this._segmentPoint1=K.create(),this._localSegmentPoint0=K.create(),this._localSegmentPoint1=K.create(),this._clipFractions=De.create(0,1),this._localFrame=ft.createIdentity(),this._polygonRange=lt.create(),this._spacePoints=t,this._spacePointsRange=new lt,t.setRange(this._spacePointsRange),this._numSpacePoints=this._spacePoints.length}static create(t){if(t.length>1)return new Ws(t.clone())}projectToPolygon(t,e,i,s){t.setRange(this._polygonRange);let n=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return n;for(let r=1;r+1<t.length;r++){n++;const o=t.fillLocalXYTriangleFrame(0,r,r+1,this._localFrame);if(o)for(let t=1;t<this._numSpacePoints;t++)if(n++,this._spacePoints.getPoint3dAtCheckedPointIndex(t-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(t,this._segmentPoint1),o.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),o.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){n++;const r=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),o=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),a=this._localFrame.multiplyPoint3d(r),c=this._localFrame.multiplyPoint3d(o),h=this._localFrame.multiplyXYZ(r.x,r.y,0),l=this._localFrame.multiplyXYZ(o.x,o.y,0),d=J.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==d&&d>this._clipFractions.x0&&d<this._clipFractions.x1){n++;const r=this._segmentPoint0.interpolate(d,this._segmentPoint1),o=r.clone();e(this._spacePoints,t-1,i,s,[a,r,h],2,1),e(this._spacePoints,t-1,i,s,[c,o,l],1,2)}else this._localSegmentPoint0.z>0?e(this._spacePoints,t-1,i,s,[a,c,l,h],3,2):e(this._spacePoints,t-1,i,s,[c,a,h,l],2,3)}}return n}}class Gs{constructor(t,e,i){this._range=t,this._numXEdge=Math.max(e,1),this._numYEdge=Math.max(i,1),this._data=[];for(let t=0;t<i;t++){const t=[];for(let i=0;i<e;i++)t.push(void 0);this._data.push(t)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x),i=Math.floor(e*this._numXEdge);return i<0?0:i>this._numXEdge-1?this._numXEdge-1:i}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y),i=Math.floor(e*this._numYEdge);return i<0?0:i>this._numYEdge-1?this._numYEdge-1:i}static createWithEstimatedCounts(t,e,i){if(t.low.x>=t.high.x||t.low.y>=t.high.y)return;const s=ut.createXYXY(t.low.x,t.low.y,t.high.x,t.high.y),n=s.xLength(),r=s.yLength();let o,a;return r>n?(a=Math.ceil(Math.sqrt(r*e/(i*n))),o=Math.ceil(e/a)):(o=Math.ceil(Math.sqrt(n*e/(i*r))),a=Math.ceil(e/(o*i))),new Gs(s,o,a)}addDataAtXY(t,e,i){const s=this.xIndex(t),n=this.yIndex(e);let r=this._data[n][s];r||(r=[],this._data[n][s]=r),r.push(i)}getDataAtXY(t,e){const i=this.xIndex(t),s=this.yIndex(e);return this._data[s][i]}getDataAtIndex(t,e){if(!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge))return this._data[e][t]}isValidIndex(t,e){return!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge)}}class Js{get indexGrid(){return this._buckets}constructor(t,e){this._points=t,this._buckets=e}static create(t,e){const i=t.length;if(t.length<1)return;const s=t.getRange();s.expandInPlace(1e3*J.smallMetricDistance);const n=Gs.createWithEstimatedCounts(s,t.length,e);if(void 0===n)return;const r=new Js(t,n),o=K.create();for(let e=0;e<i;e++)t.getPoint3dAtUncheckedPointIndex(e,o),n.addDataAtXY(o.x,o.y,e);return r}announcePointsInRange(t,e){const i=this._buckets.xIndex(t.low.x),s=this._buckets.xIndex(t.high.x),n=this._buckets.yIndex(t.low.y),r=this._buckets.yIndex(t.high.y),o=this._points.length;for(let a=i;a<=s;a++)for(let i=n;i<=r;i++){const s=this._buckets.getDataAtIndex(a,i);if(void 0!==s)for(const i of s)if(i<o){const s=this._points.getXAtUncheckedPointIndex(i),n=this._points.getYAtUncheckedPointIndex(i),r=this._points.getZAtUncheckedPointIndex(i);if(t.containsXY(s,n)&&!e(i,s,n,r))return}}}}class Hs{constructor(t=0){this._minMax=dt.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=t}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const t=this.mean,e=this._sumXX,i=this._sumX;return Math.sqrt((e-2*t*i+this._count*t*t)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(t){this._origin=t}shiftOriginAndSums(t){const e=t-this._origin;this._origin=t,this._sumXX=this._sumXX-2*e*this._sumX+this._count*e*e,this._sumX=this._sumX-this._count*e,this._minMax.cloneTranslated(-e,this._minMax)}accumulate(t){t-=this._origin,this._count+=1,this._sumX+=t,this._sumXX+=t*t,this._minMax.extendX(t)}accumulateArray(t){for(const e of t)this.accumulate(e)}clone(t){return t||(t=new Hs),this._minMax.clone(t._minMax),t._count=this._count,t._origin=this._origin,t._sumX=this._sumX,t._sumXX=this._sumXX,t}isAlmostEqual(t){return J.isAlmostEqualNumber(this._sumX,t._sumX)&&J.isAlmostEqualNumber(this._sumXX,t._sumXX)&&J.isAlmostEqualNumber(this._origin,t._origin)&&this._count===t._count&&this._minMax.isAlmostEqual(t._minMax)}}class Ks{constructor(){this.range=lt.createNull(),this.xSums=new Hs,this.ySums=new Hs,this.zSums=new Hs,this._workRange=lt.createNull()}accumulateGrowableXYZArrayRange(t){t.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class js{static spaceTriangleAspectRatio(t,e,i){const s=.5*t.crossProductToPoints(e,i).magnitude(),n=t.distanceSquared(e)+e.distanceSquared(i)+i.distanceSquared(t);return J.safeDivideFraction(s,n,0)}static spaceQuadDiagonalAspectRatio(t,e,i,s){const n=this.spaceTriangleAspectRatio(t,e,i),r=this.spaceTriangleAspectRatio(t,i,s);return Math.max(n,r)}static triangulateGreedyEarCut(t,e){const i=fr.areaNormal(t),s=[],n=t.slice();for(ls.removeClosurePoint(n);n.length>2;){let t,e=-1,r=0,o=n.length-2,a=n.length-1;for(t=0;t<n.length;o=a,a=t,t++){const s=this.spaceTriangleAspectRatio(n[o],n[a],n[t]);n[o].crossProductToPoints(n[a],n[t]).dotProduct(i)>0&&s>e&&(e=s,r=o)}if(e<=0)return!1;o=r,a=(o+1)%n.length,t=(a+1)%n.length;const c=[];c.push(n[o],n[a],n[t]),n.splice(a,1),s.push(c)}return e(t,s),!0}static triangulateSimplestSpaceLoopGo(t,e,i){const s=ne.countNonDuplicates(t);if(void 0!==i&&ne.sumEdgeLengths(t,!0,s)>i)return!1;if(s<3)return!1;if(3===s)return 0!==this.spaceTriangleAspectRatio(t[0],t[1],t[2])&&(e(t,[t.slice()]),!0);if(4===s){const i=this.spaceQuadDiagonalAspectRatio(t[0],t[1],t[2],t[3]),s=this.spaceQuadDiagonalAspectRatio(t[1],t[2],t[3],t[0]);return!(0===i&&0===s||(i>s?(e(t,[[t[0],t[1],t[2]],[t[2],t[3],t[0]]]),0):(e(t,[[t[0],t[1],t[3]],[t[3],t[1],t[2]]]),0)))}return this.triangulateGreedyEarCut(t,e)}static triangulateSimplestSpaceLoop(t,e,i){return t instanceof ye?this.triangulateSimplestSpaceLoopGo(t.points,e,i):this.triangulateSimplestSpaceLoopGo(t,e,i)}}class Qs{constructor(){this._unmatchedEdges=new Map,this._graph=new Ji,this._halfEdgesAroundCurrentLoop=[]}get graph(){return this._graph}indexPairToString(t,e){return`${t.toString()},${e.toString()}`}insertLoop(t,e){if(t.length>1){let i=t[t.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const s of t){const t=this.indexPairToString(i,s),n=this._unmatchedEdges.get(t);if(void 0===n){const t=this.indexPairToString(s,i),n=this._graph.createEdgeIdId(i,s);void 0!==e&&e(n),this._unmatchedEdges.set(t,n.edgeMate),this._halfEdgesAroundCurrentLoop.push(n),n.edgeMate.setMask(k.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(n),n.clearMask(k.EXTERIOR);i=s}let s=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const t of this._halfEdgesAroundCurrentLoop){const e=s.faceSuccessor;Gi.pinch(t,e),s=t}return this._halfEdgesAroundCurrentLoop[0]}}}function $s(t){return void 0!==t&&t}class tn{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=j.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}accumulateNormal(t,e,i){if(t.isMaskSet(i))this.numInactiveSectors++;else{const i=Gi.sectorSweepRadiansXYZ(t,e);this.averageNormal.addScaledInPlace(e,i),this.radiansSum+=i,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(t,e){if(e){const e=this.averageNormal.radiansTo(t);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),e)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function en(t){void 0!==rn.stringDebugFunction&&(rn.stringDebugFunction(`    Sector xyz    ${t.xyz.x},${t.xyz.y},${t.xyz.z} `),rn.stringDebugFunction(`           normal ${t.normal.x},${t.normal.y},${t.normal.z} `))}class sn{constructor(t,e){this.facetIndex=t,this.facetNormal=e}}class nn{constructor(t,e){this.xyz=e,this.normal=t,this.count=0}static edgeHasLargeExteriorAngleBetweenNormals(t,e,i,s,n=.5*Math.PI){const r=t.edgeTag,o=t.edgeMate.edgeTag;if(void 0!==r&&void 0!==o){t.vectorToFaceSuccessor(e);const a=r.normal.signedRadiansTo(o.normal,e);if(J.split3WaySign(s,-1,1,1)*a>=n&&(j.createAdd2Scaled(r.normal,1,o.normal,1,i),i.normalizeInPlace()))return!0}return!1}static almostEqualNormals(t,e,i=J.smallAngleRadians){return t.normal.radiansTo(e.normal)<=i}static radiansBetweenNormals(t,e){return t.normal.radiansTo(e.normal)}setOffsetPointAtDistanceAtHalfEdge(t,e){t.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,e)}static setXYZAtHalfEdge(t,e){const i=t.edgeTag;void 0!==i&&void 0!==e&&i.xyz.set(e.x,e.y,e.z)}setXYAndZ(t){this.xyz.set(t.x,t.y,t.z)}static setNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&(s.normal.set(e.x,e.y,e.z),void 0!==i&&s.setOffsetPointAtDistanceAtHalfEdge(t,i))}static sweepRadiansAroundNormal(t,e){const i=t.edgeTag,s=t.vertexSuccessor.edgeTag;if(void 0!==i&&void 0!==s)return i.normal.planarRadiansTo(s.normal,e)}static getSectorPointAtHalfEdge(t,e,i){const s=t.edgeTag;return void 0!==s&&(void 0!==e&&e.setFromPoint3d(s.xyz),void 0!==i&&i.push(s.xyz),!0)}static pushXYZ(t,e){const i=e.edgeTag;return void 0!==i&&t.push(i.xyz),i}static accumulateScaledNormalAtHalfEdge(t,e,i){const s=t.edgeTag;void 0!==s&&i.addScaledInPlace(s.normal,e)}}class rn{constructor(t,e,i){this._basePolyface=t,this._baseGraph=e,this._breakMaskA=e.grabMask(),this._breakMaskB=e.grabMask(),this._insideOfChamferFace=e.grabMask(),this._outsideOfChamferFace=e.grabMask(),this._insideChamferSling=e.grabMask(),this._outsideEndOfChamferFace=e.grabMask(),this._exteriorMask=k.EXTERIOR,this._offsetCoordinatesReassigned=e.grabMask(),this._smoothRadiansBetweenNormals=i.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=i.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=i.smoothAccumulatedAngleBetweenNormals.radians}get exteriorMask(){return this._exteriorMask}get breakMaskA(){return this._breakMaskA}get breakMaskB(){return this._breakMaskB}get insideOfChamferFace(){return this._insideOfChamferFace}get outsideOfChamferFace(){return this._outsideOfChamferFace}get insideChamferSling(){return this._insideChamferSling}get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}applyFaceNormalOffsetsToSectorData(t){this._baseGraph.announceNodes(((e,i)=>{const s=i.edgeTag;return void 0!==s&&s.setOffsetPointAtDistanceAtHalfEdge(i,t),!0}))}static buildOffsetMeshWithEdgeChamfers(t,e,i,s){const n=this.buildBaseGraph(t);if(void 0!==n){const r=new rn(t,n,s);r.applyFaceNormalOffsetsToSectorData(i),void 0!==rn.graphDebugFunction&&rn.graphDebugFunction("BaseGraph",n,r._breakMaskA,r._breakMaskB);const o=s.outputSelector?s.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};$s(o.outputOffsetsFromFacesBeforeChamfers)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),r.addChamferTopologyToAllEdges(s,i),r.computeOffsetFacetIntersections(i),void 0!==rn.graphDebugFunction&&rn.graphDebugFunction("after computeEdgeChamfers",n,r._breakMaskA,r._breakMaskB),$s(o.outputOffsetsFromFaces)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),$s(o.outputOffsetsFromEdges)&&r.announceFacetsWithSectorCoordinatesAroundEdges(e),$s(o.outputOffsetsFromVertices)&&r.announceFacetsWithSectorCoordinatesAroundVertices(e)}}announceSimpleOffsetFromFaces(t,e){const i=new it,s=K.create(),n=j.create(),r=t=>(t.getPoint3d(s),s.addInPlace(n),i.push(s),0);this._baseGraph.announceFaceLoops(((s,o)=>{if(!o.isMaskSet(k.EXTERIOR)){const s=o.faceTag;n.setFromVector3d(s.facetNormal.direction),n.scaleInPlace(e),i.length=0,o.sumAroundFace(r),t.addPolygonGrowableXYZArray(i)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(t){const e=new it,i=t=>{const i=t.edgeTag;return void 0!==i&&e.push(i.xyz),0};this._baseGraph.announceFaceLoops(((s,n)=>(n.isMaskSet(k.EXTERIOR)||(e.length=0,n.sumAroundFace(i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}countBits(t){let e=0,i=t;for(;0!==i;)1&i&&e++,i>>=1;return e}announceFacetsWithSectorCoordinatesAroundEdges(t){const e=new it,i=J.smallMetricDistance,s=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((n,r)=>{if(void 0!==r.findMaskAroundEdge(this._exteriorMask))return!0;if(r.isMaskSet(s))return!0;{const n=r.faceSuccessor,o=r.edgeMate;if(!o.isMaskSet(s)){const s=o.faceSuccessor;e.clear(),nn.getSectorPointAtHalfEdge(r,void 0,e),nn.getSectorPointAtHalfEdge(n,void 0,e),nn.getSectorPointAtHalfEdge(o,void 0,e),nn.getSectorPointAtHalfEdge(s,void 0,e),We.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)}}return!0}))}getCoordinateString(t,e=!0,i=!1){return e?i?`${Gi.nodeToIdXYZString(t)} ==> ${Gi.nodeToIdXYZString(t.faceSuccessor)}`:`${Gi.nodeToIdXYZString(t)}`:i?`==> ${Gi.nodeToIdXYZString(t.faceSuccessor)}`:""}inspectMasks(t,e=!0,i=!1){return"[".concat(t.id.toString(),t.isMaskSet(this._exteriorMask)?"X":"",t.isMaskSet(this.breakMaskA)?"A":"",t.isMaskSet(this.breakMaskB)?"B":"",t.isMaskSet(this.insideChamferSling)?"(sling)":"",t.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",t.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",t.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(t,e,i),"]")}announceFacetsWithSectorCoordinatesAroundVertices(t){const e=new it,i=J.smallMetricDistance;this._baseGraph.announceVertexLoops(((s,n)=>(n.findMaskAroundVertex(this._exteriorMask)||(e.length=0,n.sumAroundVertex((t=>(t.isMaskSet(this._insideChamferSling)||nn.getSectorPointAtHalfEdge(t,void 0,e),0))),We.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}static buildBaseGraph(t){const e=new Qs,i=t.createVisitor(),s=K.create(),n=K.create();for(i.reset();i.moveToNextFacet();){const r=fr.centroidAreaNormal(i.point);if(void 0!==r){const o=e.insertLoop(i.pointIndex,(e=>{const i=e.edgeMate;t.data.getPoint(e.i,s),e.setXYZ(s),t.data.getPoint(i.i,n),i.setXYZ(n)})),a=new sn(i.currentReadIndex(),r);void 0!==o&&o.sumAroundFace((t=>(t.faceTag=a,t.edgeTag=new nn(r.direction.clone(),t.getPoint3d()),0)))}}return e.graph}setOffsetAtDistanceAroundVertex(t,e,i=!1){t.sumAroundVertex((s=>{const n=s.edgeTag;return void 0!==n&&(i&&this.isInsideChamferOrSling(t)||n.setOffsetPointAtDistanceAtHalfEdge(s,e)),0}))}setOffsetXYAndZAroundVertex(t,e){t.sumAroundVertex((t=>{const i=t.edgeTag;return void 0!==i&&(i.setXYAndZ(e),t.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(t,e){let i=0;for(let s=t;;s=s.vertexSuccessor){const n=s.edgeTag;if(void 0!==n&&(e(s,n),i++),s.isMaskSet(this._breakMaskB))return i;if(s.isMaskSet(this._exteriorMask))return i;if(s===t&&0===i)return i}}computeAverageNormalAndMaxDeviationAroundVertex(t,e){e.clear();const i=this._exteriorMask|this._insideChamferSling;if(t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.accumulateNormal(t,s.normal,i),0})),e.finishNormalAveraging())return t.sumAroundVertex((t=>{const s=t.edgeTag;return s&&e.recordDeviation(s.normal,!t.isMaskSet(i)),0})),e.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(t,e,i,s){const n=this.computeAverageNormalAndMaxDeviationAroundVertex(t,i);return rn.stringDebugFunction&&(rn.stringDebugFunction(`XYZ ${Gi.nodeToIdXYZString(t)} Average Normal ${i.averageNormal.toJSON()}`),rn.stringDebugFunction(`           angle ratio ${i.radiansSum/(2*Math.PI)}   maxDeviation ${i.maxDeviationRadiansFromAverage}`)),void 0!==n&&n<=e&&(t.sumAroundVertex((t=>(nn.setNormalAtHalfEdge(t,i.averageNormal,s),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(t){t.clearMaskAroundVertex(this._breakMaskA),t.clearMaskAroundVertex(this._breakMaskB);const e=this._smoothRadiansBetweenNormals,i=this._smoothAccumulatedRadiansBetweenNormals;let s=0,n=t,r=0;do{const t=n.edgeMate,i=t.faceSuccessor;n.isMaskSet(this._exteriorMask)?t.isMaskSet(this._exteriorMask)||(i.setMask(this._breakMaskB),s++):n.isMaskSet(this._outsideOfChamferFace)?n.setMask(this._breakMaskA):n.isMaskSet(this._outsideEndOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB)):n.isMaskSet(this._insideChamferSling)||(n.isMaskSet(this._insideOfChamferFace)?(n.setMask(this._breakMaskA),n.setMask(this._breakMaskB),i.setMask(this._breakMaskB)):t.isMaskSet(this._exteriorMask)?(s++,n.setMask(this._breakMaskA)):nn.almostEqualNormals(n.edgeTag,i.edgeTag,e)?r++:(n.setMask(this._breakMaskA),s++,i.setMask(this._breakMaskB))),n=n.vertexSuccessor}while(n!==t);void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(`   numSkip   ${r} `),0===s&&(t.setMask(this._breakMaskA),t.vertexPredecessor.setMask(this._breakMaskB),s=1);const o=n.findMaskAroundVertex(this._breakMaskA);if(void 0!==o){n=o;do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let t=0;do{const e=n.vertexSuccessor;t+=nn.radiansBetweenNormals(n.edgeTag,e.edgeTag),t>i&&(n.setMask(this._breakMaskB),e.setMask(this._breakMaskA),s++,t=0),n=e}while(!n.isMaskSet(this._breakMaskB))}else n=n.vertexSuccessor}while(n!==o)}if(s>0&&void 0!==o){n=o;const t=j.create(),e=j.create(),i=j.create();t.setZero();do{if(n.isMaskSet(this._breakMaskA)&&!n.isMaskSet(this._breakMaskB)){let s=n;for(t.setZero();;){s.vectorToFaceSuccessor(e),s.vectorToFacePredecessor(i);let n=e.signedRadiansTo(i,s.faceTag.facetNormal.direction);if(n<0&&(n+=2*Math.PI),nn.accumulateScaledNormalAtHalfEdge(s,n,t),s.isMaskSet(this._breakMaskB))break;s=s.vertexSuccessor}if(t.normalizeInPlace())for(s=n;nn.setNormalAtHalfEdge(s,t),!s.isMaskSet(this._breakMaskB);)s=s.vertexSuccessor}n=n.vertexSuccessor}while(n!==o)}}compute3SectorIntersection(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;return Ct.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s)}compute3SectorIntersectionDebug(t,e,i,s){const n=t.edgeTag,r=e.edgeTag,o=i.edgeTag;if(void 0!==rn.stringDebugFunction){rn.stringDebugFunction(`compute3${this.inspectMasks(t)}${this.inspectMasks(e)}${this.inspectMasks(i)} `);for(const t of[n,r,o])en(t)}const a=Ct.intersect3Planes(n.xyz,n.normal,r.xyz,r.normal,o.xyz,o.normal,s);return void 0!==rn.stringDebugFunction&&(void 0===a?rn.stringDebugFunction(" NO INTERSECTION"):rn.stringDebugFunction(` ComputedVector ${a.x},${a.y},${a.z} `)),a}compute2SectorIntersection(t,e,i){const s=t.edgeTag,n=e.edgeTag,r=s.normal.crossProduct(n.normal);return Ct.intersect3Planes(s.xyz,s.normal,n.xyz,n.normal,n.xyz,r,i)}addChamferTopologyToAllEdges(t,e){const i=[],s=t.chamferAngleBetweenNormals.radians,n=K.create(),r=j.create(),o=j.create(),a=j.create();this._baseGraph.announceEdges(((t,n)=>!nn.edgeHasLargeExteriorAngleBetweenNormals(n,r,a,e,s)||(i.push(n),!0)));for(const t of i)if(nn.edgeHasLargeExteriorAngleBetweenNormals(t,r,a,s)){const i=this._baseGraph.splitEdgeCreateSliverFace(t),s=i.facePredecessor,c=i.getPoint3d();c.addScaledInPlace(a,e);const h=kt.createCapture(c,a.clone()),l=new sn(-1,h);let d=-1;for(const t of[i,s]){r.scale(d,o),t.getPoint3d(n),t.setMask(this._insideOfChamferFace),t.edgeMate.setMask(this._outsideOfChamferFace),t.faceTag=l;const e=this._baseGraph.splitEdge(void 0,n.x,n.y,n.z,t.i),i=e.edgeMate;e.setMask(this._outsideEndOfChamferFace),e.faceTag=l,i.setMask(this._insideChamferSling),Gi.pinch(t,e);const s=kt.create(n,o),h=new sn(-1,s);i.faceTag=h,t.edgeTag=new nn(a.clone(),c.clone()),e.edgeTag=new nn(a.clone(),c.clone()),i.edgeTag=new nn(o.clone(),n.clone());const u=this.compute3SectorIntersection(t,t.edgeMate,i),f=this.compute3SectorIntersection(e,e.vertexSuccessor,i);nn.setXYZAtHalfEdge(t,u),nn.setXYZAtHalfEdge(e,f),d*=-1}}}computeOffsetFacetIntersections(t){void 0!==rn.stringDebugFunction&&rn.stringDebugFunction("*****                                 recompute intersections");const e=[],i=K.create(),s=K.create(),n=2*t,r=new tn,o=Z.degreesToRadians(25);this._baseGraph.announceVertexLoops(((a,c)=>{let h=c.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===h&&(h=c.findMaskAroundVertex(this._breakMaskA)),void 0===h&&(h=c),void 0!==rn.stringDebugFunction&&(rn.stringDebugFunction(""),rn.stringDebugFunction(` VERTEX LOOP   ${h.getPoint3d().toJSON()} `),h.sumAroundVertex((t=>(rn.stringDebugFunction(this.inspectMasks(t,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(h,o,r,t))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(h),this.setOffsetAtDistanceAroundVertex(h,t,!0),h.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,e),void 0!==rn.stringDebugFunction){rn.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(h,!0,!1)}`);for(const t of e)rn.stringDebugFunction(this.inspectMasks(t,!1,!0))}if(e.length<=1);else if(2===e.length){const t=this.compute2SectorIntersection(e[0],e[1]);void 0!==t&&this.setOffsetXYAndZAroundVertex(h,t)}else if(3===e.length){void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(` Vertex Update just ${e.length} `);const t=this.compute3SectorIntersection(e[0],e[1],e[2]);void 0!==t&&this.setOffsetXYAndZAroundVertex(h,t)}else{void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(` Vertex Update breakEdges ${e.length} `),h.getPoint3d(i);for(let t=0;t<e.length;t++){const i=t,s=(i+1)%e.length,n=(s+1)%e.length;if(e[i].isMaskSet(this._outsideEndOfChamferFace)&&e[s].isMaskSet(this._outsideOfChamferFace)&&e[n].isMaskSet(this._insideOfChamferFace)){void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(e[i])} ${this.inspectMasks(e[s])} ${this.inspectMasks(e[n])} `);const r=this.compute3SectorIntersection(e[i],e[s],e[n]);if(void 0!==r){for(const t of[i,s,n])this.announceNodeAndSectorPropertiesInSmoothSector(e[t],((t,e)=>{e.setXYAndZ(r),t.setMask(this._offsetCoordinatesReassigned)}));t+=2}}}for(let t=0;t<e.length;t++){const i=t,n=(i+1)%e.length;this.isInsideSling(e[i],e[n])||(!this.isOffsetAssigned(e[i])&&e[n].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(e[n],e[i],"push left from chamfer",s):!this.isOffsetAssigned(e[n])&&e[i].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(e[i],e[n],"push right from chamfer",s))}for(let t=0;t<e.length;t++){const s=t,r=(s+1)%e.length,o=(r+1)%e.length;if(this.isInsideSling(e[s],e[r],e[o]))continue;if(this.isOffsetAssigned(e[r]))continue;void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(e[s])} ${this.inspectMasks(e[r])} ${this.inspectMasks(e[o])} `);const a=this.compute3SectorIntersection(e[s],e[r],e[o]);void 0!==a&&i.distance(a)<n&&this.announceNodeAndSectorPropertiesInSmoothSector(e[r],((t,e)=>{e.setXYAndZ(a),t.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==rn.stringDebugFunction){const t=h.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),e=`   **** Vertex offset mask counts(TRUE ${h.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${t})`;rn.stringDebugFunction(e)}return!0}))}isInsideSling(t,e,i){return t.isMaskSet(this._insideChamferSling)||void 0!==e&&e.isMaskSet(this._insideChamferSling)||void 0!==i&&i.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(t){return t.isMaskSet(this._insideChamferSling)||t.isMaskSet(this._insideOfChamferFace)||t.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(t,e,i){return t.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==e&&e.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==i&&i.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(t,e,i,s){void 0!==rn.stringDebugFunction&&rn.stringDebugFunction(`    ${i} ${this.inspectMasks(t)} to ${this.inspectMasks(e)}} `),nn.getSectorPointAtHalfEdge(t,s,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(e,((t,e)=>{e.setXYAndZ(s),t.setMask(this._offsetCoordinatesReassigned)}))}}class on{constructor(){this.world=new K,this.local=new K,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new on:t.invalidate(),t}copyContentsFrom(t){this.world.setFrom(t.world),this.local.setFrom(t.local),this.a=t.a,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return y.Unknown;if(this.isInsideOrOn){let t=0;return 0===Math.abs(this.local.x)&&++t,0===Math.abs(this.local.y)&&++t,0===Math.abs(this.local.z)&&++t,2===t?y.OnPolygonVertex:1===t?y.OnPolygonEdgeInterior:y.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?y.OutsidePolygonProjectsToVertex:y.OutsidePolygonProjectsToEdgeInterior}}class an{constructor(t,e,i){this.points=[],this.points.push(t),this.points.push(e),this.points.push(i),this.edgeLength2=[],this.edgeLength2.push(e.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(e))}set(t,e,i){this.points[0].setFromPoint3d(t),this.points[1].setFromPoint3d(e),this.points[2].setFromPoint3d(i),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(t){for(let e=0;e<3;++e)this.points[e].setFromPoint3d(t.points[e]),this.edgeLength2[e]=t.edgeLength2[e]}static createXYZXYZXYZ(t,e,i,s,n,r,o,a,c,h){return h?(h.points[0].set(t,e,i),h.points[1].set(s,n,r),h.points[2].set(o,a,c),h):new this(K.create(t,e,i),K.create(s,n,r),K.create(o,a,c))}static create(t,e,i,s){return s?(s.set(t,e,i),s):new this(t.clone(),e.clone(),i.clone())}clone(t){return an.create(this.points[0],this.points[1],this.points[2],t)}cloneTransformed(t,e){return an.create(t.multiplyPoint3d(this.points[0],e?.points[0]),t.multiplyPoint3d(this.points[1],e?.points[1]),t.multiplyPoint3d(this.points[2],e?.points[2]),e)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(t){return this.edgeLength2[J.cyclic3dAxis(t)]}edgeLength(t){return Math.sqrt(this.edgeLengthSquared(t))}get aspectRatio(){return J.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(t){const e=this.points[0].crossProductToPoints(this.points[1],this.points[2],t);if(e.tryNormalizeInPlace())return e}fractionToPoint(t,e,i,s){return K.createAdd3Scaled(this.points[0],t,this.points[1],e,this.points[2],i,s)}pointToFraction(t,e){const i=an._workVector0=this.normal(an._workVector0);if(void 0===i)return on.create(e);const s=an._workRay=kt.create(t,i,an._workRay);return this.intersectRay3d(s,e)}static edgeOppositeVertexIndexToStartVertexIndex(t){return J.cyclic3dAxis(t+1)}static edgeStartVertexIndexToOppositeVertexIndex(t){return J.cyclic3dAxis(t-1)}static isInsideTriangle(t,e,i){return t>0&&e>0&&i>0}static isInsideOrOnTriangle(t,e,i){return t>=0&&e>=0&&i>=0}static isInRegionBeyondEdge(t,e,i){return t<0&&e>=0&&i>=0?0:t>=0&&e<0&&i>=0?1:t>=0&&e>=0&&i<0?2:-1}static isInRegionBeyondVertex(t,e,i){return e<0&&i<0?0:t<0&&i<0?1:t<0&&e<0?2:-1}static isOnVertex(t,e,i){return 1===t&&0===e&&0===i?0:0===t&&1===e&&0===i?1:0===t&&0===e&&1===i?2:-1}static isOnBoundedEdge(t,e,i){return 0===t&&e>0&&i>0?0:t>0&&0===e&&i>0?1:t>0&&e>0&&0===i?2:-1}static indexOfMinimum(t){let e=0,i=t(0);const s=t(1);return i>s&&(e=1,i=s),i>t(2)&&(e=2),e}distanceSquared(t,e,i,s,n,r){return-this.edgeLengthSquared(0)*(n-e)*(r-i)-this.edgeLengthSquared(1)*(r-i)*(s-t)-this.edgeLengthSquared(2)*(s-t)*(n-e)}closestVertexIndex(t,e,i){return an.indexOfMinimum((s=>{const n=an._workPoint=K.createZero(an._workPoint);return n.setAt(s,1),this.distanceSquared(n.x,n.y,n.z,t,e,i)}))}dotProductOfEdgeVectorsAtVertex(t){const e=J.cyclic3dAxis(t),i=J.cyclic3dAxis(e+1),s=J.cyclic3dAxis(i+1);return J.dotProductXYZXYZ(this.points[i].x-this.points[e].x,this.points[i].y-this.points[e].y,this.points[i].z-this.points[e].z,this.points[s].x-this.points[e].x,this.points[s].y-this.points[e].y,this.points[s].z-this.points[e].z)}computeProjectionToEdge(t,e){t=J.cyclic3dAxis(t);const i=J.cyclic3dAxis(t+1);return e[J.cyclic3dAxis(i+1)]+e[t]*this.dotProductOfEdgeVectorsAtVertex(i)/this.edgeLengthSquared(t)}closestPoint(t,i,s){const n=[t,i,s];let r=-1,o=0;return an.isInsideTriangle(t,i,s)?(r=an.indexOfMinimum((t=>n[t]*n[t]/this.edgeLengthSquared(t))),o=this.computeProjectionToEdge(r,n)):(r=an.isInRegionBeyondVertex(t,i,s))>=0?(r=J.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(r=J.cyclic3dAxis(r+1),o=this.computeProjectionToEdge(r,n),(o<0||o>1)&&(o=0,r=an.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(t,i,s))))):(r=an.isInRegionBeyondEdge(t,i,s))>=0?(o=this.computeProjectionToEdge(r,n),o<0?o=0:o>1&&(o=0,r=J.cyclic3dAxis(r+1))):(r=an.isOnBoundedEdge(t,i,s))>=0?o=1-n[an.edgeOppositeVertexIndexToStartVertexIndex(r)]:(r=an.isOnVertex(t,i,s))>=0&&(o=0,r=an.edgeStartVertexIndexToOppositeVertexIndex(r)),e(0===r||1===r||2===r),{closestEdgeIndex:r<0?-1:an.edgeOppositeVertexIndexToStartVertexIndex(r),closestEdgeParam:o}}intersectRay3d(t,e){e=on.create(e);const i=t.origin,s=t.direction,n=an._workVector0=j.createStartEnd(this.points[0],this.points[1],an._workVector0),r=an._workVector1=j.createStartEnd(this.points[0],this.points[2],an._workVector1),o=an._workMatrix=pt.createColumns(n,r,s,an._workMatrix),a=j.createStartEnd(this.points[0],i,an._workVector0),c=an._workVector1;if(void 0===o.multiplyInverse(a,c))return e;e.a=-c.z,t.fractionToPoint(e.a,e.world),e.local.set(1-c.x-c.y,c.x,c.y);const h=this.closestPoint(e.local.x,e.local.y,e.local.z);return e.closestEdgeIndex=h.closestEdgeIndex,e.closestEdgeParam=h.closestEdgeParam,e}intersectSegment(t,e,i){return an._workRay=kt.createStartEnd(t,e,an._workRay),this.intersectRay3d(an._workRay,i)}snapLocationToEdge(t,e=J.smallMetricDistance,i=J.smallFloatingPoint){if(!t.isValid)return!1;if(i>0){let e=0,s=0;for(let n=0;n<3;n++){const r=Math.abs(t.local.at(n));r>0&&r<i&&(t.local.setAt(n,0),e++),s+=t.local.at(n)}if(e>0&&s>0)return t.local.scaleInPlace(1/s),1===e?(t.closestEdgeIndex=an.edgeOppositeVertexIndexToStartVertexIndex(an.isOnBoundedEdge(t.local.x,t.local.y,t.local.z)),t.closestEdgeParam=1-t.local.at(t.closestEdgeIndex)):(t.closestEdgeIndex=an.isOnVertex(t.local.x,t.local.y,t.local.z),t.closestEdgeParam=0),this.fractionToPoint(t.local.x,t.local.y,t.local.z,t.world),!0}if(e>0){const i=t.closestEdgeIndex,s=(i+1)%3,n=(s+1)%3,r=an._workPoint=this.points[i].interpolate(t.closestEdgeParam,this.points[s],an._workPoint),o=t.world.distance(r);if(o>0&&o<e)return t.local.setAt(i,1-t.closestEdgeParam),t.local.setAt(s,t.closestEdgeParam),t.local.setAt(n,0),t.world.setFrom(r),!0}return!1}dotProductOfCrossProductsFromOrigin(t){return an._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],an._workVector0),an._workVector1=t.points[0].crossProductToPoints(t.points[1],t.points[2],an._workVector1),an._workVector0.dotProduct(an._workVector1)}centroid(t){return K.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,t)}incenter(t){const e=this.edgeLength(0),i=this.edgeLength(1),s=this.edgeLength(2),n=J.safeDivideFraction(1,e+i+s,0);return this.fractionToPoint(n*e,n*i,n*s,t)}circumcenter(t){const e=this.edgeLengthSquared(0),i=this.edgeLengthSquared(1),s=this.edgeLengthSquared(2),n=e*(i+s-e),r=i*(s+e-i),o=s*(e+i-s),a=J.safeDivideFraction(1,n+r+o,0);return this.fractionToPoint(a*n,a*r,a*o,t)}isAlmostEqual(t,e){return this.points[0].isAlmostEqual(t.points[0],e)&&this.points[1].isAlmostEqual(t.points[1],e)&&this.points[2].isAlmostEqual(t.points[2],e)}}class cn{constructor(t=-1,e){this._facetIndex=t,this._detail=e||on.create()}invalidate(t=!0){this._facetIndex=-1,t&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(t,e,i){return void 0===i?new cn(t,e):(i.invalidate(!1),i._facetIndex=t,void 0!==e&&i._detail.copyContentsFrom(e),i)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const t=new cn;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._detail.copyContentsFrom(t._detail),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color}getNormal(t){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){this._normal=j.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._normal)}return this._normal}getParam(t){if(this._detail.isValid&&void 0===this._param&&void 0!==t){this._param=W.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._param)}return this._param}getColor(t){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=ie.linearCombinationOfColors(t,e)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class hn{constructor(t=-1,e=0,i){this._facetIndex=t,this._edgeCount=e,this._detail=i||lr.create()}invalidate(t=!0){this._facetIndex=-1,this._edgeCount=0,t&&this._detail.invalidate()}static create(t,e,i,s){return void 0===s?new hn(t,e,i):(s.invalidate(!1),s._facetIndex=t,s._edgeCount=e,void 0!==i&&s._detail!==i&&s._detail.copyContentsFrom(i),s)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const t=new hn;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._edgeCount=t._edgeCount,this._detail.copyContentsFrom(t._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class ln extends hn{constructor(t=-1,e=0,i){super(t,e,i)}invalidate(t=!0){super.invalidate(t),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(t,e,i,s){return void 0===s?new ln(t,e,i):super.create(t,e,i,s)}get isConvex(){return!0}clone(){const t=new ln;return t.copyContentsFrom(this),t}copyContentsFrom(t){super.copyContentsFrom(t),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color,this._barycentricCoordinates=t._barycentricCoordinates?.slice()}getNormal(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._normal=j.create(),t.linearCombination(s,this._normal))}return this._normal}getParam(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._param=W.create(),t.linearCombination(s,this._param))}return this._param}getColor(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const s=this.getBarycentricCoordinates(e,i);void 0!==s&&(this._color=ie.linearCombinationOfColors(t,s))}return this._color}getBarycentricCoordinates(t,e=J.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==t&&(this._barycentricCoordinates=fr.convexBarycentricCoordinates(t,this._detail.point,e)),this._barycentricCoordinates}}class dn{constructor(t=Z.createDegrees(25),e=Z.createDegrees(60),i=Z.createDegrees(90)){this.smoothSingleAngleBetweenNormals=t.clone(),this.smoothAccumulatedAngleBetweenNormals=e.clone(),this.chamferAngleBetweenNormals=i.clone()}static create(t=Z.createDegrees(25),e=Z.createDegrees(60),i=Z.createDegrees(120)){const s=t.clone(),n=e.clone(),r=i.clone();return s.degrees<1&&n.setDegrees(1),n.degrees<1&&n.setDegrees(1),n.degrees<15&&n.setDegrees(15),new dn(s,n,r)}}!function(t){t[t.SelectNone=0]="SelectNone",t[t.SelectAny=1]="SelectAny",t[t.SelectAll=2]="SelectAll",t[t.SelectOneByParity=3]="SelectOneByParity"}(N||(N={}));class un{static visitorToLoop(t){const e=ye.createPoints(t.point.getPoint3dArray());return Ue.create(e)}static indexedPolyfaceToLoops(t){const e=Ee.create(),i=t.createVisitor(1);for(;i.moveToNextFacet();){const t=un.visitorToLoop(i);e.tryAddChild(t)}return e}static sumFacetAreas(t,e){let i=0;if(void 0!==t){if(t instanceof Vi)return un.sumFacetAreas(t.createVisitor(1),e);let s;for(void 0!==e&&(s=e.normalize()),t.reset();t.moveToNextFacet();){const e=fr.areaNormal(t.point.getPoint3dArray());let n=e.magnitude();if(void 0!==s){const t=J.conditionalDivideCoordinate(1,n);void 0!==t&&(n*=e.dotProduct(s)*t)}i+=n}}return i}static sumTetrahedralVolumes(t,e){let i=0;if(t instanceof Vi)return un.sumTetrahedralVolumes(t.createVisitor(0),e);let s=e;const n=K.create(),r=K.create(),o=K.create();for(t.reset();t.moveToNextFacet();){void 0===s&&(s=t.point.getPoint3dAtUncheckedPointIndex(0)),t.point.getPoint3dAtUncheckedPointIndex(0,n);for(let e=1;e+1<t.point.length;e++)t.point.getPoint3dAtUncheckedPointIndex(e,r),t.point.getPoint3dAtUncheckedPointIndex(e+1,o),i+=s.tripleProductToPoints(n,r,o)}return i/6}static sumVolumeBetweenFacetsAndPlane(t,e){if(t instanceof Vi)return un.sumVolumeBetweenFacetsAndPlane(t.createVisitor(0),e);const i=K.create(),s=K.create(),n=K.create(),r=j.create(),o=e.getNormalRef();let a,c,h,l,d,u=0;const f=$e.create(void 0,!0),g=$e.create(void 0,!0),p=Et.createZero(),m=e.getProjectionToPlane();for(t.reset();t.moveToNextFacet();){t.point.getPoint3dAtUncheckedPointIndex(0,i),a=e.altitude(i),d=0;for(let f=1;f+1<t.point.length;f++)t.point.getPoint3dAtUncheckedPointIndex(f,s),t.point.getPoint3dAtUncheckedPointIndex(f+1,n),i.crossProductToPoints(s,n,r),c=e.altitude(s),h=e.altitude(n),l=o.dotProduct(r),d+=l,u+=l*(a+c+h);p.setZero(),t.point.multiplyTransformInPlace(m),fr.addSecondMomentAreaProducts(t.point,i,p),d>0?f.accumulateProductsFromOrigin(i,p,1):g.accumulateProductsFromOrigin(i,p,1)}return f.shiftOriginAndSumsToCentroidOfSums(),g.shiftOriginAndSumsToCentroidOfSums(),{volume:u/6,positiveProjectedFacetAreaMoments:$e.inertiaProductsToPrincipalAxes(f.origin,f.sums),negativeProjectedFacetAreaMoments:$e.inertiaProductsToPrincipalAxes(g.origin,g.sums)}}static sumFacetSecondAreaMomentProducts(t,e){if(t instanceof Vi)return un.sumFacetSecondAreaMomentProducts(t.createVisitor(0),e);const i=Et.createZero();for(t.reset();t.moveToNextFacet();)fr.addSecondMomentAreaProducts(t.point,e,i);return i}static sumFacetSecondVolumeMomentProducts(t,e){if(t instanceof Vi)return un.sumFacetSecondVolumeMomentProducts(t.createVisitor(0),e);const i=Et.createZero();for(t.reset();t.moveToNextFacet();)fr.addSecondMomentVolumeProducts(t.point,e,i);return i}static computePrincipalAreaMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=un.sumFacetSecondAreaMomentProducts(t,e);return $e.inertiaProductsToPrincipalAxes(e,i)}static computePrincipalVolumeMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=un.sumFacetSecondVolumeMomentProducts(t,e);return $e.inertiaProductsToPrincipalAxes(e,i)}static isConvexByDihedralAngleCount(t,e=!1){return this.dihedralAngleSummary(t,e)>0}static dihedralAngleSummary(t,e=!1){const i=new Bs,s=t.createVisitor(1);s.reset();const n=[];let r=0;for(;s.moveToNextFacet();){const t=s.pointCount-1,e=fr.centroidAreaNormal(s.point);if(void 0===e)return 0;n.push(e);for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),r);r++}const o=[],a=[];if(i.sortAndCollectClusters(a,e?void 0:o,void 0,o),o.length>0)return 0;let c=0,h=0,l=0;const d=j.create();for(const e of a){const i=e[0],s=e[1];if(i instanceof Os&&s instanceof Os&&t.data.point.vectorIndexIndex(i.vertexIndexA,i.vertexIndexB,d)){const t=n[i.facetIndex].direction.signedAngleTo(n[s.facetIndex].direction,d);t.isAlmostZero?h++:t.radians>0?c++:l++}}return c>0&&0===l?1:l>0&&0===c?-1:h>0&&0===c&&0===l?1:0}static isPolyfaceClosedByEdgePairing(t){return this.isPolyfaceManifold(t,!1)}static isPolyfaceManifold(t,e=!1){const i=new Bs,s=t.createVisitor(1);for(s.reset();s.moveToNextFacet();){const t=s.pointCount-1;for(let e=0;e<t;e++)i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),s.currentReadIndex())}const n=[];return i.sortAndCollectClusters(void 0,e?void 0:n,void 0,n),0===n.length}static boundaryEdges(t,e=!0,i=!0,s=!0){const n=new Ee;if(un.announceBoundaryEdges(t,((t,e,i,s,r)=>{n.tryAddChild(tr.create(t,e))}),e,i,s),0!==n.children.length)return n}static announceBoundaryEdges(t,e,i=!0,s=!0,n=!0){if(void 0===t)return;const r=new Bs,o=t instanceof Vi?t.createVisitor(1):t;for(o.setNumWrap(1),o.reset();o.moveToNextFacet();){const t=o.pointCount-1;for(let e=0;e<t;e++)r.addEdge(o.clientPointIndex(e),o.clientPointIndex(e+1),o.currentReadIndex())}const a=[],c=[],h=[];r.sortAndCollectClusters(void 0,a,h,c);const l=[];if(i&&a.length>0&&l.push(a),s&&c.length>0&&l.push(c),n&&h.length>0&&l.push(h),0===l.length)return;const d=o.clientPolyface();for(const t of l)for(const i of t){const t=i instanceof Os?i:i[0],s=t.vertexIndexA,n=t.vertexIndexB,r=d.data.getPoint(s),a=d.data.getPoint(n);r&&a&&e(r,a,s,n,o.currentReadIndex())}}static announceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=Ws.create(t);if(s){const t=e.createVisitor(0);for(t.reset();t.moveToNextFacet();)s.projectToPolygon(t.point,i,e,t.currentReadIndex())}}static async continueAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){let s=0;for(;s<this.asyncWorkLimit&&e.moveToNextFacet();)s+=t.projectToPolygon(e.point,i,e.clientPolyface(),e.currentReadIndex());return s}static setAsyncWorkLimit(t){const e=this._asyncWorkLimit;return this._asyncWorkLimit=t,e}static get asyncWorkLimit(){return this._asyncWorkLimit}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){const s=Ws.create(t);this.awaitBlockCount=0;let n=0;if(s){const t=e.createVisitor(0);let r;for(;0<(r=await Promise.resolve(un.continueAnnounceSweepLinestringToConvexPolyfaceXY(s,t,i)));)n+=r,this.awaitBlockCount++}return n}static partitionFacetIndicesByVertexConnectedComponent(t){if(t instanceof Vi)return this.partitionFacetIndicesByVertexConnectedComponent(t.createVisitor(0));const e=new qi(this.visitorClientPointCount(t));for(t.reset();t.moveToNextFacet();){const i=t.pointIndex[0];for(const s of t.pointIndex)e.mergeSubsets(i,s)}const i=e.collectRootIndices(),s=[],n=i.length;for(let t=0;t<n;t++)s.push([]);for(t.reset();t.moveToNextFacet();){const r=t.pointIndex[0],o=e.findRoot(r);for(let e=0;e<n;e++)if(i[e]===o){s[e].push(t.currentReadIndex());break}}return s}static partitionFacetIndicesByVisibilityVector(t,e,i){if(t instanceof Vi)return this.partitionFacetIndicesByVisibilityVector(t.createVisitor(0),e,i);const s=[];for(let t=0;t<3;t++)s.push([]);const n=s[0],r=s[1],o=s[2],a=Math.max(i.radians,1e-8);for(t.reset();t.moveToNextFacet();){const i=fr.areaNormalGo(t.point),s=t.currentReadIndex();if(i){const t=i.angleFromPerpendicular(e);Math.abs(t.radians)<a?o.push(s):i.dotProduct(e)<0?r.push(s):n.push(s)}}return s}static boundaryOfVisibleSubset(t,e,i,s=Z.createDegrees(.001)){const n=this.partitionFacetIndicesByVisibilityVector(t,i,s);if(0===n[e].length)return;const r=Oi.createSubsetVisitor(t,n[e],1);return this.boundaryEdges(r,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(t,e){const i=new Ui(J.smallMetricDistance,1e3);un.announceBoundaryEdges(t,((t,e,s,n)=>i.captureCurve(tr.create(t,e))),!0,!1,!1),i.announceChainsAsLineString3d(e)}static cloneWithMaximalPlanarFacets(t){if(t instanceof Vi)return this.cloneWithMaximalPlanarFacets(t.createVisitor(0));const e=un.visitorClientFacetCount(t),i=un.collectEdgesByDihedralAngle(t),s=un.partitionFacetIndicesBySortableEdgeClusters(i,e),n=In.create(),r=t,o=[];for(const t of s)1===t.length?r.moveToReadIndex(t[0])&&n.addFacetFromVisitor(r):o.push(t);const a=un.clonePartitions(t,o);for(const t of a){const e=[],i=[];un.announceBoundaryEdges(t,((t,s,n,r)=>{e.push(tr.create(t,s)),i.push([t.clone(),s.clone()])}));const s=Zi.collectChains(e,1e-4,1e-4);if(s){const t=new hr;t.announce(s);const e=t.getValidatedFrame(!1);if(void 0!==e){const t=e.inverse();if(void 0!==t){t.multiplyPoint3dArrayArrayInPlace(i);const s=Xs.formGraphFromChains(i,!0,k.BOUNDARY_EDGE);if(s){Ys.collectConnectedComponentsWithExteriorParityMasks(s,new Ns(k.BOUNDARY_EDGE),k.EXTERIOR);const t=In.graphToPolyface(s);n.addIndexedPolyface(t,!1,e)}}}}}return n.claimPolyface(!0)}static fillSimpleHoles(t,e,i){if(t instanceof Vi)return this.fillSimpleHoles(t.createVisitor(0),e,i);const s=In.create(),n=[];un.announceBoundaryChainsAsLineString3d(t,(t=>{t.reverseInPlace(),n.push(t)}));for(const t of n){const n=t.points;let r=!1;t.isPhysicallyClosed?(void 0!==e.maxEdgesAroundHole&&n.length>e.maxEdgesAroundHole||void 0!==e.maxPerimeter&&ne.sumEdgeLengths(n,!1)>e.maxPerimeter||void 0!==e.upVector&&fr.sumTriangleAreasPerpendicularToUpVector(n,e.upVector)<=0)&&(r=!0):r=!0,!r&&js.triangulateSimplestSpaceLoop(n,((t,e)=>{for(const t of e)s.addPolygon(t)}))||(r=!0),r&&void 0!==i&&i.push(t)}if(void 0!==e.includeOriginalMesh&&e.includeOriginalMesh)for(t.reset();t.moveToNextFacet();)s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static clonePartitions(t,e){if(t instanceof Vi)return this.clonePartitions(t.createVisitor(0),e);t.setNumWrap(0);const i=[],s=ve.createForFacets();s.needNormals=void 0!==t.normal,s.needParams=void 0!==t.param,s.needColors=void 0!==t.color,s.needTwoSided=t.twoSided;for(const n of e){const e=In.create(s);t.reset();for(const i of n)t.moveToReadIndex(i),e.addFacetFromVisitor(t);i.push(e.claimPolyface(!0))}return i}static cloneFiltered(t,e){if(t instanceof Vi)return this.cloneFiltered(t.createVisitor(0),e);t.setNumWrap(0);const i=ve.createForFacets();i.needNormals=void 0!==t.normal,i.needParams=void 0!==t.param,i.needColors=void 0!==t.color,i.needTwoSided=t.twoSided;const s=In.create(i);for(t.reset();t.moveToNextFacet();)e(t)&&s.addFacetFromVisitor(t);return s.claimPolyface(!0)}static visitorClientPointCount(t){const e=t.clientPolyface();if(void 0!==e)return e.data.point.length;t.reset();let i=-1;for(;t.moveToNextFacet();)for(const e of t.pointIndex)e>i&&(i=e);return i+1}static visitorClientFacetCount(t){const e=t.clientPolyface();if(void 0!==e&&void 0!==e.facetCount)return e.facetCount;let i=0;for(t.reset();t.moveToNextFacet();)++i;return i}static partitionFacetIndicesBySortableEdgeClusters(t,e){const i=new qi(e);for(const e of t)if(e instanceof Os);else{const t=e[0];for(let s=1;s<e.length;s++)i.mergeSubsets(t.facetIndex,e[s].facetIndex)}const s=i.collectRootIndices(),n=[],r=s.length;for(let t=0;t<r;t++)n.push([]);for(let t=0;t<e;t++){const e=i.findRoot(t);for(let i=0;i<r;i++)if(s[i]===e){n[i].push(t);break}}return n}static partitionFacetIndicesByEdgeConnectedComponent(t,e=!1){if(t instanceof Vi)return this.partitionFacetIndicesByEdgeConnectedComponent(t.createVisitor(0),e);t.setNumWrap(1);const i=new Bs;t.reset();let s=0;for(;t.moveToNextFacet();){const n=t.pointCount-1;s++;for(let s=0;s<n;s++)e&&t.edgeVisible[s]||i.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}const n=[];return i.sortAndCollectClusters(n,n,n,n),this.partitionFacetIndicesBySortableEdgeClusters(n,s)}static sweepLinestringToFacetsXYreturnSweptFacets(t,e){const i=In.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r)=>{4===r.length?i.addQuadFacet(r):3===r.length&&i.addTriangleFacet(r)})),i.claimPolyface(!0)}static sweepLinestringToFacetsXYReturnLines(t,e){const i=[];return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r,o,a)=>{i.push(tr.create(r[o],r[a]))})),i}static sweepLinestringToFacetsXYReturnChains(t,e){const i=Rs.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r,o,a)=>{i.addSegment(r[o],r[a])})),i.clusterAndMergeVerticesXYZ(),i.collectMaximalChains()}static async asyncSweepLinestringToFacetsXYReturnChains(t,e){const i=Rs.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,s,n,r,o,a)=>{i.addSegment(r[o],r[a])}))),i.clusterAndMergeVerticesXYZ(),i.collectMaximalChains()}static collectRangeLengthData(t){if(t instanceof Vi)return this.collectRangeLengthData(t.createVisitor(0));const e=new Ks;for(t.reset();t.moveToNextFacet();)e.accumulateGrowableXYZArrayRange(t.point);return e}static cloneWithTVertexFixup(t){const e=t.createVisitor(1),i=t.createVisitor(0),s=Js.create(t.data.point,30),n=In.create(),r=lt.createNull(),o=K.create(),a=K.create(),c=K.create(),h=tr.create(o,a);for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let n=0;n+1<e.point.length;n++){let l;if(e.point.getPoint3dAtUncheckedPointIndex(n,o),e.point.getPoint3dAtUncheckedPointIndex(n+1,a),i.pushDataFrom(e,n),r.setNull(),tr.create(o,a,h),r.extend(o),r.extend(a),s.announcePointsInRange(r,((e,i,s,n)=>{t.data.point.getPoint3dAtUncheckedPointIndex(e,c);const r=h.closestPoint(c,!1);return void 0!==r&&r.fraction>=0&&r.fraction<1&&!r.point.isAlmostEqual(o)&&!r.point.isAlmostEqual(a)&&c.isAlmostEqual(r.point)&&(void 0===l&&(l=[]),r.a=e,l.push(r)),!0})),void 0!==l){l.sort(((t,e)=>t.fraction-e.fraction));for(const t of l)i.pushInterpolatedDataFrom(e,n,t.fraction,n+1)}}n.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return n.claimPolyface()}static compareFacetIndexAndVertexIndices(t,e){if(t.length!==e.length)return t.length-e.length;for(let i=1;i<t.length;i++)if(t[i]!==e[i])return t[i]-e[i];return 0}static collectDuplicateFacetIndices(t,e=!1){const i=[];return this.announceDuplicateFacetIndices(t,(t=>{(e||t.length>1)&&i.push(t.slice())})),i}static announceDuplicateFacetIndices(t,e){const i=t.createVisitor(0),s=[];for(i.reset();i.moveToNextFacet();){const t=[i.currentReadIndex()],e=i.pointIndex,n=e.length;let r=0;for(let t=1;t<i.pointIndex.length;t++)e[t]<e[r]&&(r=t);if(e[(r+1)%n]<e[(r+n-1)%n])for(let i=0;i<n;i++)t.push(e[(r+i)%n]);else for(let i=0;i<n;i++)t.push(e[(r+n-i)%n]);s.push(t)}let n,r;s.sort(this.compareFacetIndexAndVertexIndices);const o=s.length,a=[];for(n=0;n<o;n=r){for(r=n+1,a.length=0,a.push(s[n][0]);r<o&&0===this.compareFacetIndexAndVertexIndices(s[n],s[r]);)a.push(s[r][0]),r++;e(a)}}static cloneByFacetDuplication(t,e,i){const s=In.create(),n=t.createVisitor(0);return this.announceDuplicateFacetIndices(t,(t=>{let r=0;1===t.length?e&&(r=1):t.length>1&&(i===N.SelectAny?r=1:i===N.SelectAll?r=t.length:i===N.SelectOneByParity&&(r=1==(1&t.length)?1:0));for(let e=0;e<r;e++)n.moveToReadIndex(t[e]),s.addFacetFromVisitor(n)})),s.claimPolyface()}static cloneWithColinearEdgeFixup(t){const e=t.createVisitor(2),i=t.createVisitor(0),s=In.create(),n=j.create(),r=j.create(),o=t.data.point.length,a=new Int32Array(o);for(e.reset();e.moveToNextFacet();)for(let t=0;t+2<e.point.length;t++){e.point.vectorIndexIndex(t,t+1,n),e.point.vectorIndexIndex(t+1,t+2,r);const i=e.clientPointIndex(t+1);a[i]>=0&&(n.angleTo(r).isAlmostZero?a[i]++:a[i]=-1)}for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let t=0;t+2<e.point.length;t++)a[e.clientPointIndex(t)]<0&&i.pushDataFrom(e,t);i.point.length>2&&s.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return s.claimPolyface()}static setEdgeVisibility(t,e,i){for(const s of e)if(s instanceof Os)this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,i);else if(Array.isArray(s))for(const e of s)this.setSingleEdgeVisibility(t,e.facetIndex,e.vertexIndexA,i)}static setSingleEdgeVisibility(t,e,i,s){const n=t.data,r=t.facetIndex0(e),o=t.facetIndex1(e);for(let t=r;t<o;t++)n.pointIndex[t]===i&&(n.edgeVisible[t]=s)}static getSingleEdgeVisibility(t,e,i){const s=t.data,n=t.facetIndex0(e),r=t.facetIndex1(e);for(let t=n;t<r;t++)if(s.pointIndex[t]===i)return s.edgeVisible[t]}static createIndexedEdges(t){if(t instanceof Vi)return this.createIndexedEdges(t.createVisitor(1));const e=new Bs;for(t.reset();t.moveToNextFacet();){const i=t.pointCount-1;for(let s=0;s<i;s++)e.addEdge(t.clientPointIndex(s),t.clientPointIndex(s+1),t.currentReadIndex())}return e}static collectEdgesByDihedralAngle(t,e,i=!1){if(t instanceof Vi)return this.collectEdgesByDihedralAngle(t.createVisitor(1),e,i);t.setNumWrap(1);const s=[];this.createIndexedEdges(t).sortAndCollectClusters(s),(void 0===e||e.radians<0)&&(e=Z.createRadians(J.smallAngleRadians));const n=[],r=j.create(),o=j.create();for(const a of s)if(Array.isArray(a)&&2===a.length){const s=a[0],c=a[1];if(void 0!==un.computeFacetUnitNormal(t,s.facetIndex,r)&&void 0!==un.computeFacetUnitNormal(t,c.facetIndex,o)){const t=r.smallerUnorientedAngleTo(o);i?t.radians>e.radians&&n.push(a):t.radians<=e.radians&&n.push(a)}}return n}static markPairedEdgesInvisible(t,e){const i=t.createVisitor(1),s=[],n=[];if(this.createIndexedEdges(i).sortAndCollectClusters(s,n,n,n),this.markAllEdgeVisibility(t,!1),this.setEdgeVisibility(t,n,!0),void 0!==e){const n=j.create(),r=j.create();for(const o of s)if(Array.isArray(o)&&2===o.length){const s=o[0],a=o[1];void 0!==un.computeFacetUnitNormal(i,s.facetIndex,n)&&void 0!==un.computeFacetUnitNormal(i,a.facetIndex,r)&&n.smallerUnorientedAngleTo(r).radians>e.radians&&(this.setSingleEdgeVisibility(t,s.facetIndex,s.vertexIndexA,!0),this.setSingleEdgeVisibility(t,a.facetIndex,a.vertexIndexA,!0))}}}static computeFacetUnitNormal(t,e,i){if(i||(i=j.create()),t.moveToReadIndex(e)&&fr.unitNormal(t.point,i))return i}static markAllEdgeVisibility(t,e){const i=t.data;for(let t=0;t<i.edgeVisible.length;t++)i.edgeVisible[t]=e}static convertToHalfEdgeGraph(t){const e=new Qs,i=t.createVisitor(0);for(i.reset();i.moveToNextFacet();)e.insertLoop(i.pointIndex);const s=e.graph,n=K.create();return s.announceNodes(((e,i)=>{const s=i.i;return t.data.getPoint(s,n),i.setXYZ(n),!0})),s}static reorientVertexOrderAroundFacetsForConsistentOrientation(t){return Ls.doFixup(t)}static buildPerFaceNormals(t){qs.buildPerFaceNormals(t)}static buildAverageNormals(t,e=Z.createDegrees(31)){qs.buildFastAverageNormals(t,e)}static cloneOffset(t,e,i=dn.create()){const s=ve.createForFacets(),n=In.create(s);return rn.buildOffsetMeshWithEdgeChamfers(t,n,e,i),n.claimPolyface()}static intersectRay3d(t,e,i){if(t instanceof Vi)return un.intersectRay3d(t.createVisitor(0),e,i);let s;for(t.setNumWrap(0);t.moveToNextFacet();){const n=t.pointCount,r=t.point;if(3===n){const n=this._workTriangle=an.create(r.getPoint3dAtUncheckedPointIndex(0),r.getPoint3dAtUncheckedPointIndex(1),r.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),o=this._workTriDetail=n.intersectRay3d(e,this._workTriDetail);n.snapLocationToEdge(o,i?.distanceTolerance,i?.parameterTolerance),s=this._workFacetDetail3=cn.create(t.currentReadIndex(),o,this._workFacetDetail3)}else{const o=this._workPolyDetail=fr.intersectRay3d(r,e,i?.distanceTolerance,this._workPolyDetail);s=fr.isConvex(r)?this._workFacetDetailC=ln.create(t.currentReadIndex(),n,o,this._workFacetDetailC):this._workFacetDetailNC=hn.create(t.currentReadIndex(),n,o,this._workFacetDetailNC)}if(s.isInsideOrOn){if(i?.needNormal&&t.normal&&s.getNormal(t.normal,r,i?.distanceTolerance),i?.needParam&&t.param&&s.getParam(t.param,r,i?.distanceTolerance),i?.needColor&&t.color&&s.getColor(t.color,r,i?.distanceTolerance),i?.needBarycentricCoordinates&&s.getBarycentricCoordinates(r,i?.distanceTolerance),i?.acceptIntersection&&!i.acceptIntersection(s,t))continue;return s}}}}un._asyncWorkLimit=1e6,un.awaitBlockCount=0;class fn{constructor(t){this._planes=t||[]}toJSON(){const t=[];for(const e of this._planes)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new fn)._planes.length=0,!Array.isArray(t))return e;for(const i of t){const t=pr.fromJSON(i);t&&e._planes.push(t)}return e}isAlmostEqual(t){if(this._planes.length!==t._planes.length)return!1;for(let e=0;e<this._planes.length;e++)if(!this._planes[e].isAlmostEqual(t._planes[e]))return!1;return!0}static createPlanes(t,e){e=e||new fn;for(const i of t)if(i instanceof pr)e._planes.push(i);else if(i instanceof mt){const t=pr.createPlane(i);e._planes.push(t)}return e}static createRange3dPlanes(t,e=!0,i=!0,s=!0,n=!0,r=!0,o=!0){const a=fn.createEmpty();return e&&a.planes.push(pr.createNormalAndPointXYZXYZ(1,0,0,t.low.x,0,0)),i&&a.planes.push(pr.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,0,0)),s&&a.planes.push(pr.createNormalAndPointXYZXYZ(0,1,0,0,t.low.y,0)),n&&a.planes.push(pr.createNormalAndPointXYZXYZ(0,-1,0,0,t.high.y,0)),r&&a.planes.push(pr.createNormalAndPointXYZXYZ(0,0,1,0,0,t.low.z)),o&&a.planes.push(pr.createNormalAndPointXYZXYZ(0,0,-1,0,0,t.high.z)),a}static createEmpty(t){return t?(t._planes.length=0,t):new fn}negateAllPlanes(){for(const t of this._planes)t.negateInPlace()}static createXYBox(t,e,i,s,n){(n=n||new fn)._planes.length=0;const r=pr.createNormalAndDistance(j.create(-1,0,0),-i,!1,!0),o=pr.createNormalAndDistance(j.create(1,0,0),t,!1,!0),a=pr.createNormalAndDistance(j.create(0,-1,0),-s,!1,!0),c=pr.createNormalAndDistance(j.create(0,1,0),e,!1,!0);return r&&o&&a&&c&&n._planes.push(r,o,a,c),n}static createXYPolyLine(t,e,i,s){(s=s||new fn)._planes.length=0;for(let n=0;n+1<t.length;n++){const r=j.createStartEnd(t[n],t[n+1]).unitPerpendicularXY();if(r.z=0,i||r.scaleInPlace(-1),r.normalize()){const i=void 0!==e&&e[n],o=pr.createNormalAndPoint(r,t[n],i,i);o&&s._planes.push(o)}}return s}static createXYPolyLineInsideLeft(t,e){(e=e||new fn)._planes.length=0;for(let i=0;i+1<t.length;i++){const s=j.createStartEnd(t[i],t[i+1]).unitPerpendicularXY();if(s.z=0,s.normalize()){const n=pr.createNormalAndPoint(s,t[i],!1,!1);n&&e._planes.push(n)}}return e}static setPlaneAndXYLoopCCW(t,e,i){const s=t.length-1,n=t.length;let r,o,a,c,h=t.getXAtUncheckedPointIndex(s),l=t.getYAtUncheckedPointIndex(s);i._planes.length=0;const d=t.getZAtUncheckedPointIndex(s),u=t.crossProductIndexIndexIndex(0,2,1);if(pr.createNormalAndPointXYZXYZ(u.x,u.y,u.z,h,l,d,!1,!1,e),u.normalizeInPlace())for(let e=0;e<n;e++,h=r,l=o){r=t.getXAtUncheckedPointIndex(e),o=t.getYAtUncheckedPointIndex(e),a=-(o-l),c=r-h;const s=pr.createNormalAndPointXYZXYZ(a,c,0,r,o,d);s&&i._planes.push(s)}}clone(t){(t=t||new fn)._planes.length=0;for(const e of this._planes)t._planes.push(e.clone());return t}get planes(){return this._planes}hasIntersectionWithRay(t,e,i=J.smallMetricDistance){let s=-J.largeCoordinateResult,n=J.largeCoordinateResult;e&&e.setNull();for(const e of this._planes){const r=e.velocity(t.direction),o=e.altitude(t.origin);if(Math.abs(r)<=1e-13){if(o<-i)return!1}else{const t=-o/r;r<0?t<n&&(n=t):t>s&&(s=t)}}return!(n<s||(e&&(e.extendX(s),e.extendX(n)),0))}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._planes)e.multiplyPlaneByMatrix4d(t,!1,i);return!0}isPointInside(t){for(const e of this._planes)if(!e.isPointInside(t))return!1;return!0}isPointOnOrInside(t,e=J.smallMetricDistance){const i=Math.abs(e);for(const s of this._planes)if(!s.isPointOnOrInside(t,s.interior?i:e))return!1;return!0}isSphereInside(t,e){const i=Math.abs(e)+J.smallMetricDistance;for(const e of this._planes)if(!e.isPointOnOrInside(t,i))return!1;return!0}announceClippedSegmentIntervals(t,e,i,s,n){let r;if(e<t)return!1;for(const n of this._planes){const o=-n.altitude(i),a=-n.altitude(s);if(r=J.conditionalDivideFraction(-o,a-o),void 0===r){if(o>0)return!1}else if(a>o){if(r<t)return!1;r<e&&(e=r)}else if(o>a){if(r>e)return!1;r>t&&(t=r)}else if(o>0)return!1}return e>=t&&(n&&n(t,e),!0)}announceClippedArcIntervals(t,e){const i=fn._clipArcFractionArray;i.clear();for(const e of this.planes)e.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),ys.selectIntervals01(t,i,this,e)}clipUnboundedSegment(t,e,i){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,t,e,i)}transformInPlace(t){for(const e of this._planes)e.transformInPlace(t)}clipConvexPolygonInPlace(t,e,i=J.smallMetricDistance){for(const s of this._planes)if(s.clipConvexPolygonInPlace(t,e,!0,i),t.length<3)return}clipInsidePushOutside(t,e,i){const s=dt.createNull();let n=i.grabFromCache(),r=i.grabFromCache(),o=i.grabFromCache();o.pushFrom(t);for(const t of this._planes)if(gr.splitConvexPolygonInsideOutsidePlane(t,o,n,r,s),r.length>0){if(e&&ys.captureOrDrop(r,3,e,i),r=i.grabFromCache(),0===n.length){o.length=0;break}i.dropToCache(o),o=n,n=i.grabFromCache()}if(i.dropToCache(n),i.dropToCache(r),o.length>0)return o;i.dropToCache(o)}classifyPointContainment(t,e){let i=!0;const s=e?1e-8:-1e-8;for(const e of this._planes){let n=0;for(const r of t)e.altitude(r)<(e.interior?1e-8:s)&&(n++,i=!1);if(n===t.length)return E.StronglyOutside}return i?E.StronglyInside:E.Ambiguous}static createSweptPolyline(t,e,i){const s=fn.createEmpty();let n=!1;t.length>3&&t[0].isAlmostEqual(t[t.length-1])&&fr.areaNormal(t).dotProduct(e)>0&&(n=!0);for(let r=0;r+1<t.length;r++)if(n){const n=pr.createEdgeAndUpVector(t[r+1],t[r],e,i);if(!n)return;s.addPlaneToConvexSet(n)}else{const n=pr.createEdgeAndUpVector(t[r],t[r+1],e,i);if(!n)return;s.addPlaneToConvexSet(n)}return s}addPlaneToConvexSet(t){t instanceof pr?this._planes.push(t):t instanceof mt&&this._planes.push(pr.createPlane(t))}clipPointsOnOrInside(t,e,i){e.length=0,i.length=0;for(const s of t)this.isPointOnOrInside(s,0)?e.push(s):i.push(s)}polygonClip(t,e,i,s){t instanceof it?t.clone(e):it.create(t,e);for(const t of this._planes)if(s!==t){if(0===e.length)break;t.clipConvexPolygonInPlace(e,i)}}reloadSweptPolygon(t,e,i){this._planes.length=0;const s=t.length;if(s<=2)return 0;const n=fr.areaNormal(t),r=e.dotProduct(n)>0,o=r?1:s-1;for(let i=0;i<s;i++){const n=(i+o)%s,r=t[i],a=t[n];if(r.isAlmostEqual(a))continue;const c=j.createStartEnd(r,a),h=j.createCrossProduct(e.x,e.y,e.z,c.x,c.y,c.z).normalize();let l;if(h){l=h.dotProduct(r);const t=pr.createNormalAndDistance(h,l,!1,!1);t&&this._planes.push(t)}}if(0!==i){let s=n.normalize();if(s){e.dotProduct(s)*i<0&&(s=s.negate());const n=t[0],r=s.dotProduct(n),o=pr.createNormalAndDistance(s,r,!1,!1);o&&this._planes.push(o)}}return r?1:-1}computePlanePlanePlaneIntersections(t,e,i,s=!0){const n=pt.createIdentity(),r=this._planes,o=r.length;let a=0;for(let c=0;c<o;c++)for(let h=c+1;h<o;h++)for(let l=h+1;l<o;l++)if(pt.createRowValues(r[c].inwardNormalRef.x,r[c].inwardNormalRef.y,r[c].inwardNormalRef.z,r[h].inwardNormalRef.x,r[h].inwardNormalRef.y,r[h].inwardNormalRef.z,r[l].inwardNormalRef.x,r[l].inwardNormalRef.y,r[l].inwardNormalRef.z,n),n.computeCachedInverse(!1)){const o=n.multiplyInverseXYZAsPoint3d(r[c].distance,r[h].distance,r[l].distance);s&&!this.isPointOnOrInside(o,J.smallMetricDistance)||(a++,i&&i.multiplyPoint3d(o,o),t&&t.push(o),e&&e.extendPoint(o))}return a}setInvisible(t){for(const e of this._planes)e.setInvisible(t)}addZClipPlanes(t,e,i){void 0!==e&&this._planes.push(pr.createNormalAndDistance(j.create(0,0,1),e,t)),void 0!==i&&this._planes.push(pr.createNormalAndDistance(j.create(0,0,-1),-i,t))}appendPolygonClip(t,e,i,s){const n=this.clipInsidePushOutside(t,i,s);n&&e.push(n)}static createConvexPolyface(t,e){e=this.createEmpty(e);let i,s,n=0;if(t instanceof Vi?(i=t,s=t.createVisitor(0)):(i=t.clientPolyface(),s=t),i&&s){un.isPolyfaceClosedByEdgePairing(i)&&(n=un.sumTetrahedralVolumes(s));const t=n>0?-1:1,r=j.create(),o=mt.createXYPlane();for(s.reset();s.moveToNextFacet();)void 0!==fr.areaNormalGo(s.point,r)&&(r.scaleInPlace(t),void 0!==mt.create(s.point.front(),r,o)&&e.addPlaneToConvexSet(o))}return{clipper:e,volume:n}}}fn.hugeVal=1e37,fn._clipArcFractionArray=new Pt;class gn{constructor(t,e,i){this.curves=t,this.localToWorld=e,this.axis=i}static createForLinearSweep(t,e){const i=hr.createRightHandedFrame(e,t);if(i)return new gn(t,i,void 0)}static createForPolygon(t,e){const i=hr.createRightHandedFrame(e,t);if(i){void 0!==e&&i.matrix.dotColumnZ(e)&&i.matrix.scaleColumnsInPlace(1,-1,-1);const s=ye.createArrayOfLineString3d(t),n=[];for(const t of s)t.addClosurePoint(),n.push(Ue.create(t));if(1===n.length)return new gn(n[0],i,void 0);if(n.length>1)return new gn(Ge.createLoops(n),i,void 0)}}static createForRotation(t,e){const i=hr.createRightHandedFrame(void 0,t,e);if(i)return new gn(t,i,e.clone())}getCurves(){return this.curves}tryTransformInPlace(t){if(this.curves.tryTransformInPlace(t)){this.axis&&this.axis.transformInPlace(t);const e=void 0!==this.axis?hr.createRightHandedFrame(void 0,this.curves,this.axis):hr.createRightHandedFrame(void 0,this.curves);if(e)return this.localToWorld.setFrom(e),!0}return!1}clone(){return new gn(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}isAlmostEqual(t){return t instanceof gn&&this.curves.isAlmostEqual(t.curves)&&this.localToWorld.isAlmostEqual(t.localToWorld)}get xyStrokes(){return this._xyStrokes}buildFacets(t){if(!this._facets)if(this.curves instanceof Ue){if(this._xyStrokes=this.curves.cloneStroked(t),this._xyStrokes instanceof Ue&&1===this._xyStrokes.children.length){const e=this._xyStrokes.children[0].points;this.localToWorld.multiplyInversePoint3dArrayInPlace(e),fr.sumTriangleAreasXY(e)<0&&e.reverse();const i=ks.createTriangulatedGraphFromSingleLoop(e);if(i){ks.flipTriangles(i);const e=In.graphToPolyface(i,t);this._facets=e,this._facets.tryTransformInPlace(this.localToWorld)}else{const t=Gn.polygonXYAreaUnionLoopsToPolyface(e,[],!0);t&&(this._facets=t,this._facets.tryTransformInPlace(this.localToWorld))}}}else if(this.curves instanceof Ge&&(this._xyStrokes=this.curves.cloneStroked(t),this._xyStrokes instanceof Ge)){const e=this.localToWorld.inverse();this._xyStrokes.tryTransformInPlace(e);const i=[];for(const t of this._xyStrokes.children){const e=t.children;if(1===e.length){const t=e[0];t instanceof ye&&i.push(t.packedPoints)}}const s=i.length,n=ks.createTriangulatedGraphFromLoops(i);if(n&&Ys.isTriangulatedCCW(n,!0,s-1)){ks.flipTriangles(n);const e=In.graphToPolyface(n,t);this._facets=e,this._facets.tryTransformInPlace(this.localToWorld)}else{const t=Gn.polygonXYAreaUnionLoopsToPolyface(i,[],!0);t&&(this._facets=t,this._facets.tryTransformInPlace(this.localToWorld))}}}purgeFacets(){this._facets=void 0}emitFacets(t,e,i){this.buildFacets(t.options),this._facets&&t.addIndexedPolyface(this._facets,e,i)}announceFacets(t,e){this.buildFacets(e),this._facets&&t(this._facets)}sweepToUnionOfConvexClipPlaneSets(t,e=!1,i=!1){const s=In.create();t||(e=i=!1),this.buildFacets(s.options),void 0===t&&(t=this.localToWorld.matrix.columnZ());const n=this.localToWorld.matrix.columnZ(),r=this._facets,o=K.create(),a=K.create();if(r){const s=this.localToWorld.getOrigin(),c=s.plus(t),h=n.clone(),l=n.negate(),d=ns.createEmpty(),u=r.createVisitor(1);for(u.reset();u.moveToNextFacet();){const n=u.point.length-1,r=fn.createEmpty();for(let e=0;e<n;e++){u.point.getPoint3dAtUncheckedPointIndex(e,o),u.point.getPoint3dAtUncheckedPointIndex(e+1,a);const i=pr.createEdgeAndUpVector(a,o,t),s=u.edgeVisible[e];i?.setFlags(!s,!s),r.addPlaneToConvexSet(i)}e&&r.addPlaneToConvexSet(pr.createNormalAndPoint(h,s)),i&&r.addPlaneToConvexSet(pr.createNormalAndPoint(l,c)),d.addConvexSet(r)}return d}}}class pn{static pointsClone(){const t=[];for(const e of this.points)t.push(e.clone());return t}}pn.points=[K.create(0,0,0),K.create(1,0,0),K.create(0,1,0),K.create(1,1,0),K.create(0,0,1),K.create(1,0,1),K.create(0,1,1),K.create(1,1,1)],pn.primaryCapId=-1,pn.cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]],pn.partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]],pn.faceId=[[pn.primaryCapId,0],[pn.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]],pn.faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]],pn.axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]];class mn{constructor(t,e,i){this.points=t,this.begin=e,this.end=i}static createComplete(t){return new this(t,0,t.length)}static createBeginEnd(t,e,i){return new this(t,e,i)}static createBeginLength(t,e,i){return new this(t,e,e+i)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(t){if(t>=0){const e=this.begin+t;if(e<this.points.length)return e}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(t){return this.begin=t.end-1,this.isNonEmpty}advanceToHead(t){return this.begin=t.begin,this.isNonEmpty}setFrom(t,e,i){this.points=t.points,this.begin=void 0===e?t.begin:e,this.end=void 0===i?t.end:i,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class xn extends mn{}class yn extends an{constructor(t,e,i,s,n,r){super(t,e,i),this._isValid=r,this._quality=n,this.id=s}setFrom(t){return super.setFrom(t),this._isValid=t._isValid,this._quality=t._quality,this.id=t.id,this}static createFromIndexedXYZ(t,e,i,s,n,r,o,a){a||(a=new yn(K.create(),K.create(),K.create(),o,0,!1)),a.id=o;let c=0;return void 0!==t.getPoint3dAtCheckedPointIndex(e,a.points[0])&&c++,void 0!==i.getPoint3dAtCheckedPointIndex(s,a.points[1])&&c++,void 0!==n.getPoint3dAtCheckedPointIndex(r,a.points[2])&&c++,3===c?a.updateAspectRatio():a.markInvalid(),a}get isValid(){return this._isValid}markInvalid(t){this._isValid=!1,void 0!==t&&(this._quality=t)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(t){return t?t.setFrom(this):new yn(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(t,e,i){if(i=t.clone(i),e.isValid){const s=t.dotProductOfCrossProductsFromOrigin(e);i._quality=J.minXY(t.aspectRatio,e.aspectRatio),s<0&&(i._quality-=1)}return i}static updateIfOtherHasHigherQuality(t,e){e.isValid&&e._quality>t._quality&&t.setFrom(e)}}class _n{constructor(t){this._turnRadians=t,this._xyzA=K.create(),this._xyzB=K.create(),this._forwardA=j.create(),this._forwardB=j.create(),this._vector1=j.create(),this._crossA=j.create(),this._crossB=j.create()}isForwardVector(t,e,i){if(t.dotProduct(e)<=0)return!1;const s=t.angleFromPerpendicular(i);return!(Math.abs(s.radians)>this._turnRadians)}isPlanarBase(t,e,i,s,n,r,o,a,c,h){return e+1<t.length&&s+1<i.length&&(t.getPoint3dAtUncheckedPointIndex(e,n),i.getPoint3dAtUncheckedPointIndex(s,a),t.vectorXYAndZIndex(n,e+1,o),i.vectorXYAndZIndex(a,s+1,h),j.createStartEnd(n,a,this._vector1),this._vector1.crossProduct(o,r),this._vector1.crossProduct(h,c),!n.isAlmostEqual(a)&&r.angleTo(c).radians<this._turnRadians)}advanceToPlanarLimit(t,e,i,s,n,r,o,a){for(e.setFrom(t,t.begin,i);e.end<t.end&&(e.points.vectorXYAndZIndex(s,e.end,this._vector1),this.isForwardVector(this._vector1,r,n))&&this.isForwardVector(this._vector1,a,o)&&(!(e.end>0)||(e.points.vectorIndexIndex(e.end-1,e.end,this._vector1),this.isForwardVector(this._vector1,r,n)));)e.end++}addGreedy(t,e,i,s=!1){for(t.restrictEnd(),e.restrictEnd();t.length>1&&e.length>1;)if(this._triangleA1=yn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,1,this._triangleA1),this._triangleA2=yn.createFromIndexedXYZ(t.points,t.begin+1,t.points,t.begin+2,e.points,e.begin,2,this._triangleA2),this._triangleA3=yn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin+1,3,this._triangleA3),this._triangleB1=yn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,-1,this._triangleB1),this._triangleB2=yn.createFromIndexedXYZ(e.points,e.begin+2,e.points,e.begin+1,t.points,t.begin,-2,this._triangleB2),this._triangleB3=yn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin+1,-3,this._triangleB3),this._bestTriangle=yn.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=yn.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),yn.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(t.advanceBegin(),i(this._bestTriangle),s)return}else if(e.advanceBegin(),i(this._bestTriangle),s)return;if(t.isSingleton)for(;e.length>=2;)this._workTriangle=yn.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,0,this._workTriangle),i(this._workTriangle),e.advanceBegin();if(e.isSingleton)for(;t.length>=2;)this._workTriangle=yn.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,0,this._workTriangle),i(this._workTriangle),t.advanceBegin()}emitTriangles(t,e,i){this.emitTrianglesGo(vn(t),vn(e),i)}emitTrianglesGo(t,e,i){const s=xn.createComplete(t),n=xn.createComplete(e),r=xn.createComplete(t),o=xn.createComplete(e);for(;s.length>0&&n.length>0&&(s.length>1||n.length>1);)this.isPlanarBase(t,s.begin,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(s,r,s.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(n,o,n.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin+1,e,n.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+1),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):this.isPlanarBase(t,s.begin,e,n.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(s,s.begin,s.begin+1),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):s.length>1&&n.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i,!0),s.advanceToHead(r),n.advanceToHead(o)):s.length>1?(r.setFrom(s,s.begin,s.begin+2),o.setFrom(n),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o)):n.length>1&&(r.setFrom(s),o.setFrom(n,n.begin,n.begin+2),this.addGreedy(r,o,i),s.advanceToTail(r),n.advanceToTail(o));this.addGreedy(s,n,i)}static createContext(t=this.defaultNearColinearAngle){return new _n(t.radians)}}function vn(t,e=J.smallMetricDistance){let i=!1;const s=t.length;for(let n=0;n+1<s;n++)if(t.distanceIndexIndex(n,n+1)<=e){i=!0;break}if(!i)return t;const n=new it(s);n.pushXYZ(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0));let r=0;for(let i=1;i<s;i++)t.distanceIndexIndex(r,i)>e&&(n.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i)),r=i);return t.distanceIndexIndex(0,s-1)<=e&&(n.pop(),n.pushFromGrowableXYZArray(n,0)),n}_n.defaultNearColinearAngle=Z.createDegrees(15);class Pn{constructor(t=!1,e=!1,i=!1){this.xyz=K.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,t&&(this.normal=j.create()),e&&(this.uv=W.create(),this.uvIndex=-1),i&&(this.sectionDerivative=j.create())}copyContentsFrom(t){this.xyz.setFromPoint3d(t.xyz),this.xyzIndex=t.xyzIndex,this.normal&&this.normal.setFromVector3d(t.normal),this.normalIndex=t.normalIndex,this.uv&&this.uv.setFrom(t.uv),this.uvIndex=t.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(t.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,e,i,s,n){e.getPoint3dAtCheckedPointIndex(t,this.xyz),s&&void 0!==n&&(this.uv=W.create(s.atUncheckedIndex(t),n)),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==i&&i.getVector3dAtCheckedVectorIndex(t,this.sectionDerivative)}static suppressSmallUnitVectorComponents(t){const e=J.smallFloatingPoint;Math.abs(t.x)<e&&(t.x=0),Math.abs(t.y)<e&&(t.y=0),Math.abs(t.z)<e&&(t.z=0)}static computeNormalsAlongRuleLine(t,e){if(t.sectionDerivative&&e.sectionDerivative){const i=Pn._edgeVector;j.createStartEnd(t.xyz,e.xyz,i),t.sectionDerivative.crossProduct(i,t.normal),e.sectionDerivative.crossProduct(i,e.normal),t.normal.normalizeInPlace(),e.normal.normalizeInPlace(),Pn.suppressSmallUnitVectorComponents(t.normal),Pn.suppressSmallUnitVectorComponents(e.normal)}}}Pn._edgeVector=j.create();class In extends fe{get options(){return this._options}get reversedFlag(){return this._reversed}claimPolyface(t=!0){return t&&this._polyface.data.compress(),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(t){super(),this._options=t||ve.createForFacets(),this._polyface=Li.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(t){return new In(t)}addTransformedUnitBox(t){this.addTransformedRangeMesh(t,lt.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(t,e,i){const s=this._polyface.data.pointCount,n=e.corners();for(const e of n)this._polyface.addPoint(t.multiplyPoint3d(e));let r=0;for(const t of pn.cornerIndexCCW){if(!i||r<i.length&&i[r]){const e=t.map((t=>t+s));this._reversed&&e.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(e[0],e[1],e[2],!1),this.addIndexedTrianglePointIndexes(e[0],e[2],e[3],!1)):this.addIndexedQuadPointIndexes(e[0],e[1],e[3],e[2],!1),this._polyface.terminateFacet()}r++}}addTriangleFan(t,e,i){const s=e.numPoints();if(s>2){i&&this.toggleReversedFacetFlag();const n=this.addPoint(t);let r=this.findOrAddPointInLineString(e,0),o=0;for(let t=1;t<s;t++)o=this.findOrAddPointInLineString(e,t),this.addIndexedTrianglePointIndexes(n,r,o),r=o;i&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(t,e){const i=t.numPoints();if(i>2){let s,n;e&&this.toggleReversedFacetFlag(),this._options.needNormals&&(s=t.quickUnitNormal(In._workVectorFindOrAdd),e&&s.scaleInPlace(-1),n=this._polyface.addNormal(s));const r=this._options.needParams?t.packedUVParams:void 0;let o=-1,a=-1,c=-1;r&&(o=this.addParamInGrowableXYArray(r,0),a=this.addParamInGrowableXYArray(r,1));const h=this.findOrAddPointInLineString(t,0);let l=this.findOrAddPointInLineString(t,1),d=0,u=i;t.isPhysicallyClosed&&u--;for(let e=2;e<u;e++,l=d,a=c)d=this.findOrAddPointInLineString(t,e),this.addIndexedTrianglePointIndexes(h,l,d,!1),void 0!==n&&this.addIndexedTriangleNormalIndexes(n,n,n),r&&(c=this.addParamInGrowableXYArray(r,e),this.addIndexedTriangleParamIndexes(o,a,c)),this._polyface.terminateFacet();e&&this.toggleReversedFacetFlag()}}addPoint(t){return this._polyface.addPoint(t)}findOrAddPoint(t){return this.addPoint(t)}addParamXY(t,e){return this._polyface.addParamUV(t,e)}findOrAddParamXY(t,e){return this.addParamXY(t,e)}findOrAddPointInLineString(t,e,i,s){const n=t.pointAt(e,In._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddPointInGrowableXYZArray(t,e,i,s){const n=t.getPoint3dAtCheckedPointIndex(e,In._workPointFindOrAddA);if(n)return i&&i.multiplyPoint3d(n,n),this._polyface.addPoint(n,s)}findOrAddNormalInGrowableXYZArray(t,e,i,s){const n=t.getVector3dAtCheckedVectorIndex(e,In._workVectorFindOrAdd);if(n)return i&&i.multiplyVector(n,n),this._polyface.addNormal(n,s)}addParamInGrowableXYArray(t,e){if(!t)return;const i=t.getPoint2dAtCheckedPointIndex(e,In._workUVFindOrAdd);return i?this._polyface.addParam(i):void 0}findOrAddParamInGrowableXYArray(t,e){return this.addParamInGrowableXYArray(t,e)}findOrAddParamInLineString(t,e,i,s,n){const r=t.fractions&&e<t.fractions.length?t.fractions.atUncheckedIndex(e):e/t.points.length;return this._polyface.addParamUV(r,i,s,n)}findOrAddNormalInLineString(t,e,i,s,n){const r=t.packedSurfaceNormals;if(r){const t=r.getVector3dAtCheckedVectorIndex(e,In._workVectorFindOrAdd);if(t)return i&&i.multiplyVector(t,t),this._polyface.addNormal(t,s,n)}}addPointXYZ(t,e,i){return this._polyface.addPointXYZ(t,e,i)}findOrAddPointXYZ(t,e,i){return this.addPointXYZ(t,e,i)}getUVTransformForTriangleFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i),r=pt.createRigidFromColumns(s,n,g.XYZ);return ft.createOriginAndMatrix(t,r).inverse()}getNormalForTriangularFacet(t,e,i){const s=t.vectorTo(e),n=t.vectorTo(i);let r=s.crossProduct(n).normalize();return r=r||j.create(),r}addQuadFacet(t,e,i,s){t instanceof it&&(t=t.getPoint3dArray());const n=this.options.needParams,r=this.options.needNormals,o=this.options.needColors;let a,c,h,l,d,u,f,g,p,m,x,y,_,v,P,I;if(n)if(void 0!==e&&e.length>3)a=e[0],c=e[1],h=e[2],l=e[3];else{const e=this.getUVTransformForTriangleFacet(t[0],t[1],t[2]);void 0===e?a=c=h=l=W.createZero():(a=W.createFrom(e.multiplyPoint3d(t[0])),c=W.createFrom(e.multiplyPoint3d(t[1])),h=W.createFrom(e.multiplyPoint3d(t[2])),l=W.createFrom(e.multiplyPoint3d(t[3])))}if(r&&(void 0!==i&&i.length>3?(d=i[0],u=i[1],f=i[2],g=i[3]):(d=this.getNormalForTriangularFacet(t[0],t[1],t[2]),u=this.getNormalForTriangularFacet(t[0],t[1],t[2]),f=this.getNormalForTriangularFacet(t[0],t[1],t[2]),g=this.getNormalForTriangularFacet(t[0],t[1],t[2]))),o&&void 0!==s&&s.length>3&&(p=s[0],m=s[1],x=s[2],y=s[3]),this._options.shouldTriangulate){const e=t[0].vectorTo(t[2]),i=t[1].vectorTo(t[3]);e.magnitude()>=i.magnitude()?(this.addTriangleFacet([t[0],t[1],t[2]],n?[a,c,h]:void 0,r?[d,u,f]:void 0,o?[p,m,x]:void 0),this.addTriangleFacet([t[0],t[2],t[3]],n?[a,h,l]:void 0,r?[d,f,g]:void 0,o?[p,x,y]:void 0)):(this.addTriangleFacet([t[0],t[1],t[3]],n?[a,c,l]:void 0,r?[d,u,g]:void 0,o?[p,m,y]:void 0),this.addTriangleFacet([t[1],t[2],t[3]],n?[c,h,l]:void 0,r?[u,f,g]:void 0,o?[m,x,y]:void 0))}else n&&(_=this._polyface.addParam(a),v=this._polyface.addParam(c),P=this._polyface.addParam(h),I=this._polyface.addParam(l),this.addIndexedQuadParamIndexes(_,v,I,P)),r&&(_=this._polyface.addNormal(d),v=this._polyface.addNormal(u),P=this._polyface.addNormal(f),I=this._polyface.addNormal(g),this.addIndexedQuadNormalIndexes(_,v,I,P)),o&&(_=this._polyface.addColor(p),v=this._polyface.addColor(m),P=this._polyface.addColor(x),I=this._polyface.addColor(y),this.addIndexedQuadColorIndexes(_,v,I,P)),_=this.addPoint(t[0]),v=this.addPoint(t[1]),P=this.addPoint(t[2]),I=this.addPoint(t[3]),this.addIndexedQuadPointIndexes(_,v,I,P)}addIndexedQuadPointIndexes(t,e,i,s,n=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(s),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(s),this._polyface.addPointIndex(i)),n&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(t,e,i,s){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(s),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(s),this._polyface.addParamIndex(i))}addIndexedQuadNormalIndexes(t,e,i,s){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(s),this._polyface.addNormalIndex(i))}addIndexedQuadColorIndexes(t,e,i,s){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(s),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(s),this._polyface.addColorIndex(i))}addTriangleFacet(t,e,i,s){if(t.length<3)return;let n,r,o,a,c,h;if(t instanceof it?(a=t.getPoint3dAtCheckedPointIndex(0),c=t.getPoint3dAtCheckedPointIndex(1),h=t.getPoint3dAtCheckedPointIndex(2)):(a=t[0],c=t[1],h=t[2]),this._options.needParams){if(e&&e.length>=3)n=this._polyface.addParam(e[0]),r=this._polyface.addParam(e[1]),o=this._polyface.addParam(e[2]);else{const t=this.getUVTransformForTriangleFacet(a,c,h);n=this._polyface.addParam(W.createFrom(t?t.multiplyPoint3d(a):void 0)),r=this._polyface.addParam(W.createFrom(t?t.multiplyPoint3d(c):void 0)),o=this._polyface.addParam(W.createFrom(t?t.multiplyPoint3d(c):void 0))}this.addIndexedTriangleParamIndexes(n,r,o)}if(this._options.needNormals){if(void 0!==i&&i.length>2)n=this._polyface.addNormal(i[0]),r=this._polyface.addNormal(i[1]),o=this._polyface.addNormal(i[2]);else{const t=this.getNormalForTriangularFacet(a,c,h);n=this._polyface.addNormal(t),r=this._polyface.addNormal(t),o=this._polyface.addNormal(t)}this.addIndexedTriangleNormalIndexes(n,r,o)}this._options.needColors&&void 0!==s&&s.length>2&&(n=this._polyface.addColor(s[0]),r=this._polyface.addColor(s[1]),o=this._polyface.addColor(s[2]),this.addIndexedTriangleColorIndexes(n,r,o)),n=this.addPoint(a),r=this.addPoint(c),o=this.addPoint(h),this.addIndexedTrianglePointIndexes(n,r,o)}addIndexedTrianglePointIndexes(t,e,i,s=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(i)),s&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(t,e,i){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(i))}addIndexedTriangleNormalIndexes(t,e,i){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(i))}addIndexedTriangleColorIndexes(t,e,i){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(i))}setSectorIndices(t){t.xyzIndex=this.addPoint(t.xyz),t.normal&&(t.normalIndex=this._polyface.addNormal(t.normal)),t.uv&&(t.uvIndex=this._polyface.addParam(t.uv))}addSectorTriangle(t,e,i){t.xyz.isAlmostEqual(e.xyz)||e.xyz.isAlmostEqual(i.xyz)||i.xyz.isAlmostEqual(t.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex),this.addIndexedTrianglePointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex),this._polyface.terminateFacet())}addSectorQuadA01B01(t,e,i,s){t.xyz.isAlmostEqual(e.xyz)&&i.xyz.isAlmostEqual(s.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(t,e,s),this.addSectorTriangle(s,i,t)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex,s.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex,s.uvIndex),this.addIndexedQuadPointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,s.xyzIndex),this._polyface.terminateFacet()))}addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,n=!1){const r=t.packedPoints,o=i.packedPoints,a=t.packedDerivatives,c=i.packedDerivatives,h=t.fractions,l=i.fractions,d=this._options.needNormals,u=this._options.needParams,f=new Pn(d,u,d),g=new Pn(d,u,d),p=new Pn(d,u,d),m=new Pn(d,u,d),x=new Pn(d,u,d),y=new Pn(d,u,d),_=r.length;if(!(_<2||_!==o.length)){f.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,r,a,h,e),p.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,o,c,l,s),d&&Pn.computeNormalsAlongRuleLine(f,p),this.setSectorIndices(f),this.setSectorIndices(p),x.copyContentsFrom(f),y.copyContentsFrom(p);for(let t=1;t<_;t++)g.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,r,a,h,e),m.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,o,a,l,s),Pn.computeNormalsAlongRuleLine(g,m),this.setSectorIndices(g),this.setSectorIndices(m),this.addSectorQuadA01B01(f,g,p,m),f.copyContentsFrom(g),p.copyContentsFrom(m);n&&this.addSectorQuadA01B01(f,x,p,y)}}addBetweenLineStringsWithStoredIndices(t,e){const i=t.pointIndices,s=e.pointIndices;let n=t.normalIndices,r=e.normalIndices;this._options.needNormals||(n=void 0,r=void 0);let o=t.paramIndices,a=e.paramIndices;this._options.needParams||(o=void 0,a=void 0);const c=i.length;for(let t=1;t<c;t++)this.options.shouldTriangulate?(Sn(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t)),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1))),Sn(s.atUncheckedIndex(t),s.atUncheckedIndex(t-1),i.atUncheckedIndex(t-1))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),s.atUncheckedIndex(t),s.atUncheckedIndex(t-1)),n&&r&&this.addIndexedTriangleNormalIndexes(n.atUncheckedIndex(t-1),r.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),a.atUncheckedIndex(t),a.atUncheckedIndex(t-1)))):(i.atUncheckedIndex(t-1)===i.atUncheckedIndex(t)&&s.atUncheckedIndex(t-1)===s.atUncheckedIndex(t)||(this.addIndexedQuadPointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),s.atUncheckedIndex(t-1),s.atUncheckedIndex(t)),n&&r&&this.addIndexedQuadNormalIndexes(n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),r.atUncheckedIndex(t-1),r.atUncheckedIndex(t)),o&&a&&this.addIndexedQuadParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1),a.atUncheckedIndex(t))),this._polyface.terminateFacet())}addBetweenTransformedLineStrings(t,e,i,s=!1){if(t instanceof ye){const n=t.points.length;let r=this.findOrAddPointInLineString(t,0,e),o=this.findOrAddPointInLineString(t,0,i);const a=r,c=o;let h=0,l=0;for(let s=1;s<n;s++)h=this.findOrAddPointInLineString(t,s,e),l=this.findOrAddPointInLineString(t,s,i),this.addIndexedQuadPointIndexes(r,h,o,l),r=h,o=l;s&&this.addIndexedQuadPointIndexes(r,a,o,c)}else{const s=t.children;if(s)for(const t of s)this.addBetweenTransformedLineStrings(t,e,i)}}addBetweenStrokeSetPair(t,e,i,s){if(t instanceof ye&&i instanceof ye)this.addBetweenLineStringsWithRuleEdgeNormals(t,e,i,s,!1);else if(t instanceof Ge&&i instanceof Ge){if(t.children.length===i.children.length)for(let n=0;n<t.children.length;n++)this.addBetweenStrokeSetPair(t.children[n],e,i.children[n],s)}else if(t instanceof be&&i instanceof be){const n=t.children,r=i.children;if(n.length===r.length)for(let t=0;t<n.length;t++){const i=n[t],o=r[t];i instanceof ye&&o instanceof ye&&this.addBetweenLineStringsWithRuleEdgeNormals(i,e,o,s)}}}addCone(t){let e=16;this._options&&(e=this._options.applyTolerancesToArc(t.getMaxRadius()));let i=1;const s=t.strokeConstantVSection(0,e,this._options),n=t.strokeConstantVSection(1,e,this._options);if(this._options){const t=it.distanceRangeBetweenCorrespondingPoints(s.packedPoints,n.packedPoints);i=this._options.applyMaxEdgeLength(1,t.low)}const r=t.maxIsoParametricDistance();this.addUVGridBody(t,e,i,De.create(0,r.x),De.create(0,r.y)),this.endFace(),t.capped&&(J.isSmallMetricDistance(t.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(s,!0),this.endFace()),J.isSmallMetricDistance(t.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(n,!1),this.endFace()))}addTorusPipe(t,e,i){const s=t.getThetaFraction(),n=J.clamp(J.resolveNumber(e,8),4,64),r=J.clamp(J.resolveNumber(i,Math.ceil(16*s)),2,64);this.toggleReversedFacetFlag();const o=t.maxIsoParametricDistance();if(this.addUVGridBody(t,n,r,De.create(0,o.x),De.create(0,o.y)),this.toggleReversedFacetFlag(),t.capped&&s<1){const e=t.getConstructiveFrame(),i=t.getMinorRadius(),s=t.getMajorRadius(),r=2*i,o=s-i,a=s+i,c=-i,h=ft.createRowValues(r,0,0,o,0,0,-1,0,0,r,0,c),l=e.multiplyTransformTransform(h).inverse();if(l){const e=Si.createLinestringOnUVLine(t,0,0,1,0,n,!1,!0);e.computeUVFromXYZTransform(l),this.addTrianglesInUncheckedConvexPolygon(e,!1)}const d=t.getSweepAngle().radians,u=Math.cos(d),f=Math.sin(d),g=ft.createRowValues(-u*r,0,-f,a*u,-f*r,0,u,a*f,0,r,0,c),p=e.multiplyTransformTransform(g).inverse();if(p){const e=Si.createLinestringOnUVLine(t,1,1,0,1,n,!1,!0);e.computeUVFromXYZTransform(p),this.addTrianglesInUncheckedConvexPolygon(e,!1)}}}addLinearSweepLineStringsXYZOnly(t,e){if(t instanceof ye){let i=K.create(),s=K.create(),n=0,r=0,o=0,a=0;const c=t.numPoints();for(let h=0;h<c;h++)i=t.pointAt(h,i),s=i.plus(e,s),r=this.addPoint(i),a=this.addPoint(s),h>0&&this.addIndexedQuadPointIndexes(n,r,o,a),n=r,o=a}else if(t instanceof be)for(const i of t.children)this.addLinearSweepLineStringsXYZOnly(i,e)}addRotationalSweep(t){const e=t.getCurves(),i=vi.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneAxisRay(),n=pi.computeMaxVectorFromRay(s,i),r=s.direction.crossProduct(n);this._options.needNormals&&pi.buildRotationalNormalsInLineStrings(i,s,r);const o=n.magnitude(),a=Math.abs(o*t.getSweep().radians);let c=ve.applyAngleTol(this._options,1,t.getSweep().radians,void 0);c=ve.applyMaxEdgeLength(this._options,c,a);for(let e=1;e<=c;e++){const s=t.getFractionalRotationTransform((e-1)/c),n=t.getFractionalRotationTransform(e/c);this.addBetweenRotatedStrokeSets(i,s,e-1,n,e)}if(t.capped){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,t.getFractionalRotationTransform(1))}}addTriangulatedRegion(t){if(t instanceof Je)for(const e of t.children)this.addTriangulatedRegion(e);const e=gn.createForLinearSweep(t);e&&e.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(t){const e=this._options;if(t instanceof $t)t.computeStrokeCountForOptions(e);else if(t instanceof Me){const e=t.children;if(e)for(const t of e)this.applyStrokeCountsToCurvePrimitives(t)}}addBetweenStrokeSetsWithRuledNormals(t,e,i){const s=[t],n=[0];for(let r=1;r<i;r++){const o=r/i,a=ti.interpolateBetween(t,r/i,e);s.push(a),n.push(o)}s.push(e),n.push(1);for(let t=0;t<i;t++)this.addBetweenStrokeSetPair(s[t],n[t],s[t+1],n[t+1])}createIndicesInLineString(t,e,i){const s=t.numPoints();{const e=t.ensureEmptyPointIndices(),n=this.findOrAddPointInLineString(t,0,i);if(e.push(n),s>1){let r,o=n;for(let n=1;n+1<s;n++)r=this.findOrAddPointInLineString(t,n,i,o),e.push(r),o=r;r=this.findOrAddPointInLineString(t,s-1,i,n),e.push(r)}}if(this._options.needNormals&&void 0!==t.packedSurfaceNormals){const e=t.ensureEmptyNormalIndices(),n=this.findOrAddNormalInLineString(t,0,i);e.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddNormalInLineString(t,n,i,o),e.push(r),o=r;r=this.findOrAddNormalInLineString(t,s-1,i,n,o),e.push(r)}}if(this._options.needParams&&void 0!==t.packedUVParams){const i=t.ensureEmptyUVIndices(),n=this.findOrAddParamInLineString(t,0,e);i.push(n);let r,o=n;if(s>1){for(let n=1;n+1<s;n++)r=this.findOrAddParamInLineString(t,n,e,o),i.push(r),o=r;r=this.findOrAddParamInLineString(t,s-1,e,o,n),i.push(r)}}}addBetweenRotatedStrokeSets(t,e,i,s,n){if(t instanceof ye){const r=t.cloneTransformed(e);this.createIndicesInLineString(r,i);const o=t.cloneTransformed(s);this.createIndicesInLineString(o,n),this.addBetweenLineStringsWithStoredIndices(r,o)}else if(t instanceof Ge)for(let r=0;r<t.children.length;r++)this.addBetweenRotatedStrokeSets(t.children[r],e,i,s,n);else if(t instanceof be){const r=t.children;for(let t=0;t<r.length;t++){const o=r[t];o instanceof ye&&this.addBetweenRotatedStrokeSets(o,e,i,s,n)}}}addLinearSweep(t){const e=t.getCurvesRef(),i=vi.createForParityRegionOrChain(e,this._options).getStrokes(),s=t.cloneSweepVector(),n=ft.createTranslation(s),r=i.cloneTransformed(n),o=this._options.applyMaxEdgeLength(1,s.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(i,r,o),t.capped&&e.isAnyRegionType){const e=t.getSweepContourRef();e.purgeFacets(),e.emitFacets(this,!0,void 0),e.emitFacets(this,!1,n)}}addRuledSweep(t){const e=t.sweepContoursRef();let i,s;const n=[];for(let t=0;t<e.length;t++)n.push(vi.createForParityRegionOrChain(e[t].curves,this._options));if(vi.enforceStrokeCountCompatibility(n)){vi.enforceCompatibleDistanceSums(n);for(let t=0;t<e.length;t++){if(s=n[t].getStrokes(),s||(s=e[t].curves.cloneStroked()),t>0&&i&&s){const t=dt.createNull();if(vi.extendDistanceRangeBetweenStrokes(i,s,t)&&!t.isNull){const e=this._options.applyMaxEdgeLength(1,t.high);this.addBetweenStrokeSetsWithRuledNormals(i,s,e)}}i=s}}return t.capped&&e[0].curves.isAnyRegionType&&(e[0].purgeFacets(),e[0].emitFacets(this,!0,void 0),e[e.length-1].purgeFacets(),e[e.length-1].emitFacets(this,!1,void 0)),!0}addSphere(t,e){let i=e||this.options.applyTolerancesToArc(t.maxAxisRadius());J.isOdd(i)&&(i+=1);const s=J.clampToStartEnd(Math.abs(i*t.latitudeSweepFraction),1,Math.ceil(.5*i)),n=t.strokeConstantVSection(0,i,this._options);t.capped&&!J.isSmallMetricDistance(n.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(n,!0),this.endFace());const r=t.maxIsoParametricDistance();this.addUVGridBody(t,i,s,De.create(0,r.x),De.create(0,r.y)),this.endFace();const o=t.strokeConstantVSection(1,i,this._options);t.capped&&!J.isSmallMetricDistance(o.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(o,!1),this.endFace())}addBox(t){const e=t.getCorners(),i=J.maxXY(t.getBaseX(),t.getBaseX()),s=J.maxXY(t.getBaseY(),t.getTopY());let n=0;for(let t=0;t<4;t++)n=J.maxXY(n,e[t].distance(e[t+4]));const r=this._options.applyMaxEdgeLength(1,i),o=this._options.applyMaxEdgeLength(1,s),a=this._options.applyMaxEdgeLength(1,n),c=De.create(0,i),h=De.create(0,n);this.addUVGridBody(Ai.create(e[0],e[1],e[4],e[5]),r,a,c,h),c.shift(i),this.addUVGridBody(Ai.create(e[1],e[3],e[5],e[7]),o,a,c,h),c.shift(s),this.addUVGridBody(Ai.create(e[3],e[2],e[7],e[6]),r,a,c,h),c.shift(i),this.addUVGridBody(Ai.create(e[2],e[0],e[6],e[4]),o,a,c,h),this.endFace(),t.capped&&(c.set(0,i),h.set(0,s),this.addUVGridBody(Ai.create(e[4],e[5],e[6],e[7]),r,o,c,h),this.endFace(),c.set(0,i),h.set(0,s),this.addUVGridBody(Ai.create(e[2],e[3],e[0],e[1]),r,o,c,h),this.endFace())}addPolygon(t,e){for(void 0===e&&(e=t.length);e>1&&t[e-1].isAlmostEqual(t[0]);)e--;let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.addPoint(t[s]),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(t){let e=t.length;for(;e>2&&J.isSmallMetricDistance(t.distanceIndexIndex(0,e-1));)e--;for(;e>2&&J.isSmallMetricDistance(t.distanceIndexIndex(e-2,e-1));)e--;if(3===e){const i=t.crossProductIndexIndexIndex(0,1,2).magnitude(),s=t.distanceIndexIndex(0,1)+t.distanceIndexIndex(0,2)+t.distanceIndexIndex(1,2);i<J.smallMetricDistance*s&&(e=0)}if(e>2){let i=0;if(this._reversed)for(let s=e;--s>=0;)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);else for(let s=0;s<e;s++)i=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(t,e,i,s,n){let r=t.length;for(;r>1&&J.isSmallMetricDistance(t.distanceIndexIndex(0,r-1));)r--;let o=0;if(e&&e.length<r&&(e=void 0),i&&i.length<r&&(i=void 0),s&&s.length<r&&(s=void 0),n&&n.length<r&&(n=void 0),this._reversed)for(let n=r;--n>=0;)o=this.findOrAddPointInGrowableXYZArray(t,n),this._polyface.addPointIndex(o),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,n),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,n),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[n]),this._polyface.addColorIndex(o));else for(let a=0;a<r;a++)o=this.findOrAddPointInGrowableXYZArray(t,a),this._polyface.addPointIndex(o,!n||n[a]),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,a),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,a),this._polyface.addParamIndex(o)),s&&(o=this._polyface.addColor(s[a]),this._polyface.addColorIndex(o));this._polyface.terminateFacet()}addFacetFromVisitor(t){this.addFacetFromGrowableArrays(t.point,t.normal,t.param,t.color,t.edgeVisible)}addIndexedPolyface(t,e,i){this._polyface.addIndexedPolyface(t,e,i)}endFace(){return this._polyface.setNewFaceData()}handleCone(t){return this.addCone(t)}handleTorusPipe(t){return this.addTorusPipe(t)}handleSphere(t){return this.addSphere(t)}handleBox(t){return this.addBox(t)}handleLinearSweep(t){return this.addLinearSweep(t)}handleRotationalSweep(t){return this.addRotationalSweep(t)}handleRuledSweep(t){return this.addRuledSweep(t)}handleLoop(t){return this.addTriangulatedRegion(t)}handleParityRegion(t){return this.addTriangulatedRegion(t)}handleUnionRegion(t){return this.addTriangulatedRegion(t)}addGeometryQuery(t){t.dispatchToGeometryHandler(this)}addGraph(t,e,i=Gi.testNodeMaskNotExterior,s=Gi.testMateMaskExterior){let n=0;const r=this._options.needNormals;let o=0;r&&(o=this._polyface.addNormalXYZ(0,0,1)),t.announceFaceLoops(((t,a)=>{if(i(a)&&a.countEdgesAroundFace()>2){let t=a;do{n=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(n,void 0===s||s(t)),e&&(n=this.addParamXY(t.x,t.y),this._polyface.addParamIndex(n)),r&&this._polyface.addNormalIndex(o),t=t.faceSuccessor}while(t!==a);this._polyface.terminateFacet()}return!0}))}addGraphFaces(t,e){let i=0;for(const t of e){let e=t;do{i=this.addPointXYZ(e.x,e.y,e.z),this._polyface.addPointIndex(i),e=e.faceSuccessor}while(e!==t);this._polyface.terminateFacet()}}static graphToPolyface(t,e,i=Gi.testNodeMaskNotExterior){const s=In.create(e);return s.addGraph(t,s.options.needParams,i),s.endFace(),s.claimPolyface()}static graphFacesToPolyface(t,e){const i=In.create();return i.addGraphFaces(t,e),i.endFace(),i.claimPolyface()}static polygonToTriangulatedPolyface(t,e){if(e||(e=hr.createFrameWithCCWPolygon(t)),e){const i=e.multiplyInversePoint3dArray(t);fr.areaXY(i)<0&&i.reverse();const s=ks.createTriangulatedGraphFromSingleLoop(i);if(s){const t=this.graphToPolyface(s);return t.tryTransformInPlace(e),t}}}addCoordinateFacets(t,e,i,s=!1){for(let s=0;s<t.length;s++){const n=e?e[s]:void 0,r=i?i[s]:void 0;3===t[s].length?this.addTriangleFacet(t[s],n,r):4===t[s].length&&this.addQuadFacet(t[s],n,r)}s&&this.endFace()}addUVGridBody(t,e,i,s,n){let r,o,a,c,h=new Pt(e),l=new Pt(e);const d=this._reversed,u=this.options.needNormals;u&&(a=new Pt(e),c=new Pt(e));const f=this.options.needParams;let g;f&&(r=new Pt(e),o=new Pt(e)),h.ensureCapacity(e),l.ensureCapacity(e);const p=W.create(),m=j.create(),x=1/e,y=1/i,_=Ft.createXYPlane();for(let v=0;v<=i;v++){l.clear(),u&&c.clear(),f&&o.clear();for(let i=0;i<=e;i++){const e=i*x,r=v*y;t.uvFractionToPointAndTangents(e,r,_),l.push(this._polyface.addPoint(_.origin)),u&&(_.vectorU.crossProduct(_.vectorV,m),m.normalizeInPlace(),d&&m.scaleInPlace(-1),c.push(this._polyface.addNormal(m))),f&&o.push(this._polyface.addParam(W.create(s?s.fractionToPoint(e):e,n?n.fractionToPoint(r):r,p)))}if(v>0)for(let t=0;t<e;t++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t),!1),u&&this.addIndexedTriangleNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t)),f&&this.addIndexedTriangleParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(l.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t+1),!1),u&&this.addIndexedTriangleNormalIndexes(c.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t+1)),f&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),!1),u&&this.addIndexedQuadNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t),c.atUncheckedIndex(t+1)),f&&this.addIndexedQuadParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet());g=l,l=h,h=g,f&&(g=o,o=r,r=g),u&&(g=c,c=a,a=g)}h.clear(),l.clear()}static pointsToTriangulatedPolyface(t){const e=ks.createTriangulatedGraphFromPoints(t);if(e)return In.graphToPolyface(e)}addGreedyTriangulationBetweenLineStrings(t,e){_n.createContext().emitTriangles(An(t),An(e),(t=>{this.addTriangleFacet(t.points)}))}addMiteredPipesFromPoints(t,e,i=12){const s=fi.createMiteredPipeSections(t,e),n=K.create(),r=K.create(),o=K.create(),a=K.create();i<3&&(i=3);const c=1/i;for(let t=1;t<s.length;t++){const e=s[t-1],h=s[t];e.fractionToPoint(0,n),h.fractionToPoint(0,o);for(let t=1;t<=i;t++,n.setFromPoint3d(r),o.setFromPoint3d(a)){const i=t*c;e.fractionToPoint(i,r),h.fractionToPoint(i,a),this.addQuadFacet([n,o,a,r])}}}addMiteredPipes(t,e,i=12){if(Array.isArray(t))this.addMiteredPipesFromPoints(new te(t),e,i);else if(t instanceof it)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof tt)this.addMiteredPipesFromPoints(t,e,i);else if(t instanceof ye)this.addMiteredPipesFromPoints(t.packedPoints,e,i);else if(t instanceof Rt){const s=ye.create();t.emitStrokes(s,this._options),this.addMiteredPipesFromPoints(s.packedPoints,e,i)}}getEdgeIndices(t){let e=-1,i=-1;for(let s=this._polyface.facetIndex0(t.facetIndex);s<this._polyface.facetIndex1(t.facetIndex);++s)t.vertexIndexA===this._polyface.data.pointIndex[s]?e=s:t.vertexIndexB===this._polyface.data.pointIndex[s]&&(i=s);return e<0||i<0?void 0:{edgeIndexA:e,edgeIndexB:i}}addSweptFace(t,e){const i=this.getEdgeIndices(t);if(void 0===i)return!1;const s=e+t.facetIndex;if(!this._polyface.isValidFacetIndex(s))return!1;const n=this._polyface.numEdgeInFacet(t.facetIndex);if(n!==this._polyface.numEdgeInFacet(s))return!1;const r=this._polyface.facetIndex0(t.facetIndex),o=this._polyface.facetIndex0(s),a=n-1-(i.edgeIndexA-r),c=n-1-(i.edgeIndexB-r),h=[i.edgeIndexB,i.edgeIndexA,o+a,o+c],l=[];let d;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(d=[]);for(let t=0;t<4;++t){const e=this._polyface.data.getPoint(this._polyface.data.pointIndex[h[t]]);if(void 0===e)return!1;if(l.push(e),void 0!==d){const e=this._polyface.data.getColor(this._polyface.data.colorIndex[h[t]]);if(void 0===e)return!1;d.push(e)}}return this.addQuadFacet(l,void 0,void 0,d),!0}addSweptIndexedPolyface(t,e,i=!1){let s=!0;const n=un.sumFacetAreas(t,e);J.isAlmostEqualNumber(0,n)&&(s=!1);const r=un.partitionFacetIndicesByVisibilityVector(t,e,Z.createDegrees(.001)),o=r[0].length,a=r[1].length;r[2].length>0&&(s=!1),o>0&&a>0&&(s=!1);const c=o>0,h=this._polyface.facetCount;this.addIndexedPolyface(t,c);const l=this._polyface.facetCount;this.addIndexedPolyface(t,!c,ft.createTranslation(e));const d=l-h,u=Array.from({length:d},((t,e)=>h+e)),f=Oi.createSubsetVisitor(this._polyface,u,1),g=[];un.createIndexedEdges(f).sortAndCollectClusters(void 0,g,void 0,void 0);const p=this._options.shouldTriangulate;this._options.shouldTriangulate=i;for(const t of g)if(t instanceof Os)this.addSweptFace(t,d);else if(Array.isArray(t))for(const e of t)this.addSweptFace(e,d);return this._options.shouldTriangulate=p,s}}function An(t){return Array.isArray(t)?new te(t):t instanceof ye?t.packedPoints:t}function Sn(t,e,i){return t!==e&&e!==i&&i!==t}In._workPointFindOrAddA=K.create(),In._workVectorFindOrAdd=j.create(),In._workUVFindOrAdd=W.create();class wn{pushNewChain(t){const e=[];t&&e.push(t),this._chains.push(e)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}findAnyChainToConnect(t){for(let e=0;e<this._chains.length;e++){const i=this._chains[e];if(this._xyzWork1=i[i.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!0};if(this._xyzWork1=i[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!1}}}constructor(t){this._chains=[],this._makeClones=t}announceCurvePrimitive(t,e=!1){if(t){if(this._makeClones){const e=t.clone();if(!(e&&e instanceof $t))return;this.transferMarkup(t,e),t=e}if(e){this._xyzWork0=t.startPoint(this._xyzWork0);let e=this.findAnyChainToConnect(this._xyzWork0);e?e.atEnd?this._chains[e.chainIndex].push(t):(t.reverseInPlace(),this._chains[e.chainIndex].splice(0,0,t)):(this._xyzWork0=t.endPoint(this._xyzWork0),e=this.findAnyChainToConnect(this._xyzWork0),e?e.atEnd?(t.reverseInPlace(),this._chains[e.chainIndex].push(t)):this._chains[e.chainIndex].splice(0,0,t):this._chains.push([t]))}else{const e=this.findOrCreateTailChain();0!==e.length&&wn.needBreakBetweenPrimitives(e[e.length-1],t)?this.pushNewChain(t):e.push(t)}}}transferMarkup(t,e){t&&e&&(e.startCut=t.startCut,e.endCut=t.endCut)}promoteArrayToCurves(t,e){if(0!==t.length)return e&&(wn._staticPointA=t[0].startPoint(wn._staticPointA),wn._staticPointB=t[t.length-1].endPoint(wn._staticPointB),wn._staticPointA.isAlmostEqual(wn._staticPointB))?Ue.createArray(t):1===t.length?t[0]:qe.createArray(t)}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=Ee.create();for(const s of e){const e=this.promoteArrayToCurves(s,t);i.tryAddChild(e)}return i}static needBreakBetweenPrimitives(t,e,i=!1){return void 0===t||void 0===e||void 0!==t.endCut||void 0!==e.startCut||(wn._staticPointA=t.endPoint(wn._staticPointA),wn._staticPointB=e.startPoint(wn._staticPointB),i?!wn._staticPointA.isAlmostEqualXY(wn._staticPointB):!wn._staticPointA.isAlmostEqual(wn._staticPointB))}}class Cn{constructor(t=5){this._activeMomentData=$e.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new jt(t)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,s){this.startCurvePrimitive(t),e<1&&(e=1);const n=1/e;let r,o;for(let a=1;a<=e;a++){const c=J.interpolate(i,(a-1)*n,s),h=a===e?s:J.interpolate(i,a*n,s),l=this._gaussMapper.mapXAndW(c,h);for(let e=0;e<l;e++){o=this._gaussMapper.gaussX[e];const i=t.fractionToPointAndDerivative(o);r=this._gaussMapper.gaussW[e]*i.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(i.origin,r)}}}announceSegmentInterval(t,e,i,s,n,r){this._activeMomentData.accumulateLineMomentsXYZ(e,i)}announcePointTangent(t,e,i){}visitLeaves(t){if(t instanceof $t)t.emitStrokableParts(this);else if(t instanceof Me&&void 0!==t.children)for(const e of t.children)this.visitLeaves(e)}}class Tn extends fe{constructor(t){super(),this._options=t||new Xe}handleCurveChain(t){const e=t.children.length,i=[];let s=0;for(let n=0;n<e;){const r=t.children[n];if(this._options.consolidateLinearGeometry&&(r instanceof tr||r instanceof ye)){i.length=0;let o=n;for(;o<t.children.length;o++){const e=t.children[o];if(e instanceof tr)i.push(e.startPoint()),i.push(e.endPoint());else{if(!(e instanceof ye))break;{const t=e.packedPoints;for(let e=0;e<t.length;e++)i.push(t.getPoint3dAtUncheckedPointIndex(e))}}}if(i.length>1){const r=this._options.colinearPointTolerance,a=ls.compressShortEdges(i,r),c=ls.compressByPerpendicularDistance(a,r);0===n&&o===e&&We.compressColinearWrapInPlace(c,r),c.length<2?t.children[s++]=ye.create(c[0]):2===c.length?t.children[s++]=tr.create(c[0],c[1]):t.children[s++]=ye.createPoints(c)}else t.children[s++]=r;n=o}else if(this._options.consolidateCompatibleArcs&&r instanceof Pe){for(;++n<t.children.length;){const e=t.children[n];if(!(e instanceof Pe))break;if(!fi.appendToArcInPlace(r,e))break}t.children[s++]=r}else t.children[s++]=r,n++}t.children.length=s}handlePath(t){return this.handleCurveChain(t)}handleLoop(t){return this.handleCurveChain(t)}handleParityRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}handleUnionRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}}class kn{constructor(t,e){this.fraction=t,this.otherCurveDetail=e}setFrom(t,e){e&&this.isSameFraction(t)&&(this.otherCurveDetail=t.otherCurveDetail?t.otherCurveDetail:this.otherCurveDetail),this.fraction=t.fraction}isSameFraction(t){return J.isSmallAngleRadians(this.fraction-t.fraction)}set(t,e){this.fraction=t,this.otherCurveDetail=e}}class Fn{static hasInteriorDetailAIntersections(t,e=J.smallAngleRadians){if(0===t.length)return!1;for(const i of t)if(i.detailA.fraction>e||i.detailA.fraction<1-e)return!0;return!1}collectFragmentAndAdvanceCut(t,e,i,s){if(!e.isSameFraction(i)){const n=t.clonePartialCurve(e.fraction,i.fraction);void 0!==n&&(n.startCut=e.otherCurveDetail,n.endCut=i.otherCurveDetail,s.push(n))}e.setFrom(i,!0)}collectSinglePrimitiveFragments(t,e,i){if(void 0===e||!Fn.hasInteriorDetailAIntersections(e))return void i.push(t.clone());e.sort(((t,e)=>t.detailA.fraction-e.detailA.fraction));const s=new kn(0,void 0),n=new kn(1,void 0);for(const r of e)n.set(r.detailA.fraction,r.detailB),this.collectFragmentAndAdvanceCut(t,s,n,i);n.set(1,void 0),this.collectFragmentAndAdvanceCut(t,s,n,i)}static cloneCurvesWithXYSplits(t,e){const i=new Fn;if(t instanceof $t){const s=[],n=Le.intersectionXYPairs(t,!1,e,!1);return i.collectSinglePrimitiveFragments(t,n,s),1===s.length?s[0]:qe.createArray(s)}if(t instanceof be){const s=[];for(const n of t.children){const t=Le.intersectionXYPairs(n,!1,e,!1);i.collectSinglePrimitiveFragments(n,t,s)}return qe.createArray(s)}}}class Mn{static testPointInOnOutLoopXY(t,e,i){let s;const n=K.create(e,i);for(let r=0;Math.abs(r)<6;r=-1.2313*(r+.3212897)){s=mt.createXYAngle(e,i,Z.createRadians(r));const o=s.getNormalRef(),a=[];for(const e of t.children)e instanceof $t&&e.appendPlaneIntersectionPoints(s,a);$t.snapAndRestrictDetails(a,!1,!0);let c,h,l=0,d=0,u=0;for(const t of a){if(t.intervalRole!==P.isolated&&void 0!==t.intervalRole&&u++,c=t.point.x-e,h=t.point.y-i,J.isSameCoordinateXY(c,h,0,0))return 0;const s=J.crossProductXYXY(o.x,o.y,c,h);if(n.isAlmostEqualXY(t.point))return 0;s<0?l++:s>0&&d++}if(0!==u)continue;const f=1&l;if(f===(1&d))return 1===f?1:-1}return-1}static testPointInOnOutParityRegionXY(t,e,i){let s=-1;for(const n of t.children)if(n instanceof Ue){const t=this.testPointInOnOutLoopXY(n,e,i);if(0===t)return 0;t>0&&(s=-s)}return s}static testPointInOnOutUnionRegionXY(t,e,i){for(const s of t.children){const t=this.testPointInOnOutRegionXY(s,e,i);if(t>=0)return t}return-1}static testPointInOnOutRegionXY(t,e,i){return t instanceof Ue?this.testPointInOnOutLoopXY(t,e,i):t instanceof Ge?this.testPointInOnOutParityRegionXY(t,e,i):t instanceof Je?this.testPointInOnOutUnionRegionXY(t,e,i):-1}}class bn{constructor(){this.primitiveToPair=new Map,this.primitiveToIndex=new Map,this._numIndexedPrimitives=0}assignPrimitiveIndex(t){void 0!==t&&void 0===this.primitiveToIndex.get(t)&&this.primitiveToIndex.set(t,this._numIndexedPrimitives++)}insertPrimitiveToPair(t,e){if(t){const i=this.primitiveToPair.get(t);this.assignPrimitiveIndex(t),i?i.push(e):this.primitiveToPair.set(t,[e])}}insertPair(t){const e=t.detailA.curve;e&&this.insertPrimitiveToPair(e,t);const i=t.detailB.curve;i&&this.insertPrimitiveToPair(i,t)}splitAndAppendMissingClosedPrimitives(t,e=J.smallMetricDistance){for(const i of t){let t=!1;if(i instanceof Pe?t=i.sweep.isFullCircle:i instanceof tr||i instanceof ye||(t=i.startPoint().isAlmostEqualXY(i.endPoint(),e)),t&&!this.primitiveToPair.has(i)){const t=i.clonePartialCurve(0,.5),e=i.clonePartialCurve(.5,1);t&&e&&(this.insertPair(_t.createCapture(yt.createCurveEvaluatedFraction(t,0),yt.createCurveEvaluatedFraction(e,1))),this.insertPair(_t.createCapture(yt.createCurveEvaluatedFraction(t,1),yt.createCurveEvaluatedFraction(e,0))))}}}}class En{static assembleHalfEdgeGraph(t,e,i=J.smallMetricDistance){const s=new bn;for(const t of e)s.insertPair(t);t.length>s.primitiveToPair.size&&s.splitAndAppendMissingClosedPrimitives(t,i);const n=new Ji;for(const t of s.primitiveToPair.entries()){const e=t[0],s=t[1].reduce(((t,i)=>{if(!i.detailA.hasFraction1)return[...t,i];const s=Rn(i,e),n=yt.createCurveFractionPoint(e,s.fraction,s.point),r=yt.createCurveFractionPoint(e,s.fraction1,s.point1);return[...t,_t.createCapture(n,n),_t.createCapture(r,r)]}),[]);s.sort(((t,i)=>zn(t,e)-zn(i,e)));let r={point:e.startPoint(),fraction:0};for(const t of s){const s=Rn(t,e),o=J.restrictToInterval(s.fraction,0,1);r=this.addHalfEdge(n,e,r.point,r.fraction,s.point,o,i)}this.addHalfEdge(n,e,r.point,r.fraction,e.endPoint(),1,i)}return Xs.clusterAndMergeXYTheta(n,(t=>t.sortAngle)),n}static addHalfEdge(t,e,i,s,n,r,o=J.smallMetricDistance){if(i.isAlmostEqualXY(n,o))return{point:i,fraction:s};const a=t.createEdgeXYAndZ(i,0,n,0),c=yt.createCurveEvaluatedFractionFraction(e,s,r),h=a.edgeMate;return a.edgeTag=c,a.sortData=1,h.edgeTag=c,h.sortData=-1,a.sortAngle=Xn(e,s,!1),h.sortAngle=Xn(e,r,!0),{point:n,fraction:r}}static collectSignedLoop(t,e,i=1e-10,s){let n=s?0:Gn.computeXYArea(t);return void 0===n&&(n=0),Math.abs(n)<i&&(n=0),t.computedAreaInPlanarSubdivision=n,n>0?e.positiveAreaLoops.push(t):n<0?e.negativeAreaLoops.push(t):e.slivers.push(t),n}static createLoopInFace(t,e){let i=t;const s=Ue.create();do{const t=i.edgeTag;if(t){let n;n=i.sortData>0?t.curve.clonePartialCurve(t.fraction,t.fraction1):t.curve.clonePartialCurve(t.fraction1,t.fraction),n&&(void 0!==e&&e(i,n,s),s.tryAddChild(n))}i=i.faceSuccessor}while(i!==t);return s}static isNullFace(t){const e=t.faceSuccessor.faceSuccessor===t;let i=!1;if(e){const e=Xs.curvatureSortKey(t),s=Xs.curvatureSortKey(t.faceSuccessor.edgeMate);J.isSameCoordinate(e,s)||(i=!0)}return e&&!i}static nonNullEdgeMate(t,e){if(this.isNullFace(e))return;let i=e.edgeMate;for(;this.isNullFace(i);)if(i=i.faceSuccessor.edgeMate,i===e)return;return i}static collectSignedLoopSetsInHalfEdgeGraph(t,e=1e-10){const i=Ys.collectConnectedComponentsWithExteriorParityMasks(t,void 0),s=[],n=new Map;for(const r of i){const i={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},o=[];for(const s of r){const r=this.isNullFace(s),a=this.createLoopInFace(s,((e,i,s)=>{if(!r){const r=this.nonNullEdgeMate(t,e);if(void 0!==r){const t=n.get(r);if(void 0===t){const t=new Ze(s,i,void 0,void 0);n.set(e,t)}else t instanceof Ze&&(t.setB(s,i),o.push(t),n.delete(r))}}}));this.collectSignedLoop(a,i,e,r)}i.edges=o,s.push(i),n.clear()}return s}}function Xn(t,e,i){const s=t.fractionToPointAndDerivative(e),n=i?-1:1;return Math.atan2(n*s.direction.y,n*s.direction.x)}function zn(t,e){return t.detailA.curve===e?t.detailA.fraction:t.detailB.curve===e?t.detailB.fraction:void 0}function Rn(t,e){return t.detailA.curve===e?t.detailA:t.detailB.curve===e?t.detailB:void 0}class Dn extends fe{constructor(){super(...arguments),this._point0=K.create(),this._point1=K.create()}handleArc3d(t){const e=this._activeMomentData,i=t.sweep.sweepRadians,s=.5*i;let n=Math.sin(s),r=Math.cos(s),o=Math.sin(i);Z.isFullCircleRadians(i)&&(n=0,r=-1,o=0);const a=2*n*n*n*r/(s-n*r),c=n*n*n,h=.5*(i-o),l=.25*h*(1+a)-c*c*4/(9*h),d=.25*h*(1-a/3),u=4*n*n*n/(3*(i-o)),f=t.sweep.fractionToRadians(.5),g=t.radiansToRotatedBasis(f),p=g.origin.plusScaled(g.vectorU,u);e.accumulateXYProductsInCentroidalFrame(l,0,d,h,p,g.vectorU,g.vectorV);const m=t.fractionToPoint(0),x=t.fractionToPoint(1);e.accumulateTriangleMomentsXY(void 0,m,x)}handleLineString3d(t){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,t.packedPoints)}handleLineSegment3d(t){const e=this._activeMomentData;t.startPoint(this._point0),t.endPoint(this._point1),e.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(t){const e=this._activeMomentData=$e.create();e.needOrigin=!1;for(const e of t.children)e.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,e}handleParityRegion(t){const e=[];let i,s=0;for(const n of t.children)if(n instanceof Ue){const t=this.handleLoop(n);if(t){e.push(t);const n=Math.abs(t.quantitySum);n>s&&(s=n,i=t)}}if(i){const t=$e.create(),s=i.signFactor(1);t.accumulateProducts(i,s);for(const s of e)if(s!==i){const e=s.signFactor(-1);t.accumulateProducts(s,e)}return t}}handleUnionRegion(t){const e=$e.create();for(const i of t.children){const t=i.dispatchToGeometryHandler(this);if(t){const i=t.signFactor(1);e.accumulateProducts(t,i)}}return e}getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const t=ve.createForCurves();return t.angleTol=Z.createDegrees(5),this._strokeOptions=t,t}handleCurvePrimitive(t){const e=ye.create(),i=this.getStrokeOptions();t.emitStrokes(e,i),this.handleLineString3d(e)}handleBSplineCurve3d(t){return this.handleCurvePrimitive(t)}handleBSplineCurve3dH(t){return this.handleCurvePrimitive(t)}handleTransitionSpiral(t){return this.handleCurvePrimitive(t)}}class Nn{startComponent(t){return!0}finishComponent(t){return!0}enterFace(t,e){return!0}leaveFace(t,e){return!0}}class Yn extends Nn{constructor(t,e){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=e,this._faceSelectFunction=t}startComponent(t){return t.setMaskAroundFace(this._exteriorMask),!0}enterFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||e.setMaskAroundFace(this._exteriorMask),!0}leaveFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),!0}}class On{static faceToFaceSearchFromOuterLoop(t,e,i,s,n){if(e.isMaskSet(i))return;if(!n.startComponent(e))return;const r=[];e.setMaskAroundFace(i);let o=e;do{let t=o,e=o.edgeMate;if(!e.isMaskSet(i)){r.push(o),r.push(e);let a=e.faceSuccessor;if(e.setMaskAroundFace(i),t=e,n.enterFace(r,e))for(;;){if(e=a.edgeMate,!e.isMaskSet(i)){if(e.setMaskAroundFace(i),!n.enterFace(r,e))return;r.push(a),r.push(e),a=e,t=e}if(a.setMask(s),a=a.faceSuccessor,a===t){if(n.leaveFace(r,a),r.length<=2)break;r.pop(),a=r[r.length-1],r.pop(),t=r[r.length-1]}if(a.isMaskSet(s))return}}o=o.faceSuccessor}while(o!==e);n.finishComponent(e)}static doPolygonBoolean(t,e,i,s){const n=new Ji,r=k.BOUNDARY_EDGE|k.PRIMARY_EDGE,o=Gn.addLoopsWithEdgeTagToGraph(n,t,r,1),a=Gn.addLoopsWithEdgeTagToGraph(n,e,r,2);if(s&&s("unmerged loops",n,"U"),o||a){Xs.splitIntersectingEdges(n),s&&s("After splitIntersectingEdges",n,"S"),Xs.clusterAndMergeXYTheta(n),s&&s("After clusterAndMergeXYTheta",n,"M"),new es(n).regularizeGraph(!0,!0),s&&s("After regularize",n,"MR");const t=Ys.findMinimumAreaFace(n);if(void 0===t)return;const e=k.EXTERIOR,r=n.grabMask(),o=n.grabMask(),a=e|r|o;n.clearMask(a);const c=new Yn(i,e);return this.faceToFaceSearchFromOuterLoop(n,t,r,o,c),s&&s("After faceToFaceSearchFromOuterLoop",n,"MRX"),n.dropMask(r),n.dropMask(o),n}}static doBinaryBooleanBetweenMultiLoopInputs(t,e,i,s,n,r){const o=new Ji,a=k.BOUNDARY_EDGE|k.PRIMARY_EDGE,c=Ln.create(e,n);c.graph=o,c.faceAreaFunction=Ys.signedFaceArea;for(const e of t)if(e.length>2){const t=new Bn(e,c.groupA);Gn.addLoopsWithEdgeTagToGraph(o,e,a,t)}for(const t of s)if(t.length>2){const e=new Bn(t,c.groupB);Gn.addLoopsWithEdgeTagToGraph(o,t,a,e)}return Xs.splitIntersectingEdges(o),Xs.clusterAndMergeXYTheta(o),new es(o).regularizeGraph(!0,!0),c.runClassificationSweep(i),r&&c.unmaskMaskedNullFaces(k.EXTERIOR),o}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.NonBounding=-1]="NonBounding"}(Y||(Y={}));class Bn{constructor(t,e){this.region=t,this.parentGroup=e,this.sweepState=0}clearState(){this.sweepState=0}}class Vn{constructor(t,e){this.members=[],this.parent=t,this.groupOpType=e,this._numIn=0}clearState(){for(const t of this.members)t.clearState();this._numIn=0}range(){const t=lt.createNull();for(const e of this.members)if(e.region instanceof Rt)e.region.extendRange(t);else{const i=lt.createFromVariantData(e.region);t.extendRange(i)}return t}getInOut(){return this.groupOpType===Y.Union?this._numIn>0:this.groupOpType===Y.Parity?J.isOdd(this._numIn):this.groupOpType===Y.Intersection&&this._numIn===this.members.length}addMember(t,e=!1){if(t instanceof Ue||t instanceof Ge){const e=t.clone();Gn.consolidateAdjacentPrimitives(e),this.members.push(new Bn(e,this))}else if(t instanceof Je)for(const e of t.children)this.addMember(e);else if(Array.isArray(t))for(const e of t)this.addMember(e);else e&&t instanceof tr&&this.members.push(new Bn(t,this))}recordMemberStateChange(t,e){const i=J.isOdd(t),s=J.isOdd(e);!i&&s?this._numIn++:i&&!s&&this._numIn--}}class Ln{constructor(t,e){this.groupA=new Vn(this,t),this.groupB=new Vn(this,e),this.extraGeometry=new Vn(this,Y.NonBounding),this.binaryOp=O.Union}static create(t,e){return new Ln(t,e)}addMembers(t,e){this.groupA.addMember(t),this.groupB.addMember(e),this.addConnectives()}addConnectives(){const t=this.groupA.range(),e=this.groupB.range(),i=t.union(e),s=Gn.computeXYAreaTolerance(i);let n=.1;this._workSegment=er.findExtremePointsInDirection(i.corners(),Ln._bridgeDirection,this._workSegment),this._workSegment&&(n*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const r=[],o=t=>{const e=Gn.computeXYArea(t);void 0===e||Math.abs(e)<s||(this._workSegment=er.findExtremePointsInDirection(t,Ln._bridgeDirection,this._workSegment),this._workSegment&&r.push(this._workSegment.point1Ref))};for(const t of[this.groupA.members,this.groupB.members])for(const e of t)if(e.region instanceof Ue)o(e.region);else if(e.region instanceof Ge)for(const t of e.region.children)o(t);const a=kt.createZero();for(const t of r){const e=n+kt.create(t,Ln._bridgeDirection,a).intersectionWithRange3d(i).high,s=K.createAdd2Scaled(t,1,Ln._bridgeDirection,e),r=tr.createXYXY(t.x,t.y,s.x,s.y);this.extraGeometry.addMember(r,!0)}}annotateAndMergeCurvesInGraph(t=J.smallMetricDistance){const e=[];for(const t of[this.groupA,this.groupB,this.extraGeometry])for(const i of t.members){let t=e.length;if(i.region instanceof Rt)for(Gn.collectCurvePrimitives(i.region,e,!0,!0);t<e.length;t++)e[t].parent=i}const i=Le.allIntersectionsAmongPrimitivesXY(e,t),s=En.assembleHalfEdgeGraph(e,i,t);this.graph=s,this.faceAreaFunction=Zn}runClassificationSweep(t,e){this._announceFaceFunction=e,this.binaryOp=t,this.graph.clearMask(k.EXTERIOR);for(const t of[this.groupA,this.groupB])t.clearState();const i=this.graph.grabMask(),s=this.graph.grabMask(),n=Wn.create(this.graph);for(const t of n.components){const e=Ys.findMinimumAreaFace(t.faces,this.faceAreaFunction);if(e){const t=k.EXTERIOR|i|s;this.graph.clearMask(t),On.faceToFaceSearchFromOuterLoop(this.graph,e,i,s,this)}}this.graph.dropMask(i),this.graph.dropMask(s)}unmaskMaskedNullFaces(t){for(const e of this.graph.allHalfEdges){const i=e.faceSuccessor;i.faceSuccessor===e&&e.getMask(t)&&i.getMask(t)&&(e.edgeMate.getMask(t)&&i.edgeMate.getMask(t)||(e.clearMask(t),i.clearMask(t)))}}getInOut(){return this.binaryOp===O.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===O.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===O.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===O.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===O.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(t,e){const i=t=>{if(t.parentGroup.groupOpType===Y.NonBounding)return t;if(0!==e){const i=t.sweepState;t.sweepState+=e,t.parentGroup.recordMemberStateChange(i,t.sweepState)}return t},s=t.edgeTag;if(s instanceof Bn)return i(s);if(s instanceof yt){const t=s.curve.parent;if(t instanceof Bn)return i(t)}}startComponent(t){return t.setMaskAroundFace(k.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,t,-1,Zn(t)),!0}finishComponent(t){return!0}enterFace(t,e){this.recordTransitionAcrossEdge(e,1);const i=this.getInOut();return i||e.setMaskAroundFace(k.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,e,i?1:0,Zn(e)),!0}leaveFace(t,e){return this.recordTransitionAcrossEdge(e,-1),!0}}function Un(t,e,i,s){let n;n=t&&t.point1?-(t.point1.x-t.point.x)*(.5*(t.point.y+t.point1.y)-s.y):-(i.x-e.x)*(.5*(e.y+i.y)-s.y);let r=0;return t&&t.curve&&t.hasFraction1&&(t.curve instanceof tr||t.curve instanceof Pe&&(r=t.curve.areaToChordXY(t.fraction,t.fraction1))),n+r}function Zn(t){let e=0,i=t;do{e+=i.sortData*Un(i.edgeTag,i,i.faceSuccessor,t)}while((i=i.faceSuccessor)!==t);return e}Ln._bridgeDirection=j.createNormalized(1,-.12328974132467);class qn{constructor(t){this.faces=t,this.range=ut.createNull(),this.faceAreas=[]}buildFaceData(t,e){const i=e=>(t?t(e,this.range):this.range.extendXY(e.x,e.y),0);this.range.setNull();for(const t of this.faces)t.sumAroundFace(i);this.faceAreas.length=0,e||(e=Ys.signedFaceArea);for(const t of this.faces)this.faceAreas.push(e(t))}}class Wn{constructor(t){this.graph=t,this.components=[]}static create(t,e){const i=new Wn(t),s=Ys.collectConnectedComponentsWithExteriorParityMasks(t,void 0);for(const t of s){const s=new qn(t);s.buildFaceData(e,Zn),i.components.push(s)}return i}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.AMinusB=3]="AMinusB",t[t.BMinusA=4]="BMinusA"}(O||(O={}));class Gn{static computeXYAreaMoments(t){const e=new Dn,i=t.dispatchToGeometryHandler(e);if(i instanceof $e)return i.shiftOriginAndSumsToCentroidOfSums(),i}static computeXYAreaTolerance(t,e=J.smallMetricDistance){const i=.5*e;return i*(t.xLength()+t.yLength()+i)}static computeXYArea(t){const e=new Dn,i=t.dispatchToGeometryHandler(e);if(i instanceof $e)return i.quantitySum}static computeXYZWireMomentSums(t){const e=new Cn;e.visitLeaves(t);const i=e.momentData;return i.shiftOriginAndSumsToCentroidOfSums(),i}static addLoopsToGraph(t,e,i){if(e instanceof Ue){const s=e.getPackedStrokes();s&&this.addLoopsToGraph(t,s,i)}else if(e instanceof Ge)for(const s of e.children){const e=s.getPackedStrokes();e&&this.addLoopsToGraph(t,e,i)}else if(e instanceof tt){const s=ks.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(Array.isArray(e)&&e.length>0)if(K.isAnyImmediatePointType(e[0])){const s=ks.directCreateFaceLoopFromCoordinates(t,e);void 0!==s&&i(t,s)}else if(e[0]instanceof tt)for(const s of e){const e=ks.directCreateFaceLoopFromCoordinates(t,s);void 0!==e&&i(t,e)}else for(const s of e)Array.isArray(s)&&this.addLoopsToGraph(t,s,i)}static addLoopsWithEdgeTagToGraph(t,e,i,s){const n=[];if(this.addLoopsToGraph(t,e,((t,e)=>{e&&(n.push(e),e.setMaskAndEdgeTagAroundFace(i,s,!0))})),n.length>0)return n}static finishGraphToPolyface(t,e){if(t)return e&&(ks.triangulateAllPositiveAreaFaces(t),ks.flipTriangles(t)),In.graphToPolyface(t)}static polygonXYAreaIntersectLoopsToPolyface(t,e,i=!1){const s=On.doPolygonBoolean(t,e,((t,e)=>t&&e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaUnionLoopsToPolyface(t,e,i=!1){const s=On.doPolygonBoolean(t,e,((t,e)=>t||e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static polygonXYAreaDifferenceLoopsToPolyface(t,e,i=!1){const s=On.doPolygonBoolean(t,e,((t,e)=>t&&!e),this._graphCheckPointFunction);return this.finishGraphToPolyface(s,i)}static regionBooleanXY(t,e,i,s=J.smallMetricDistance){const n=Je.create(),r=Ln.create(Y.Union,Y.Union);r.addMembers(t,e),r.annotateAndMergeCurvesInGraph(s);const o=r.groupA.range().union(r.groupB.range()),a=this.computeXYAreaTolerance(o,s);return r.runClassificationSweep(i,((t,e,i,s)=>{if(!(e.countEdgesAroundFace()<2||Math.abs(s)<a||1!==i)){const t=En.createLoopInFace(e);t&&n.tryAddChild(t)}})),n}static polygonBooleanXYToPolyface(t,e,i,s=!1){const n=On.doBinaryBooleanBetweenMultiLoopInputs(t,Y.Union,e,i,Y.Union,!0);return this.finishGraphToPolyface(n,s)}static polygonBooleanXYToLoops(t,e,i){const s=On.doBinaryBooleanBetweenMultiLoopInputs(t,Y.Union,e,i,Y.Union,!0);if(!s)return;const n=Ys.collectExtendedBoundaryLoopsInGraph(s,k.EXTERIOR),r=[];for(const t of n){const e=new it;for(const i of t)e.pushXYZ(i.x,i.y,i.z);e.pushWrap(1);const i=Ue.create();i.tryAddChild(ye.createCapture(e)),r.push(i)}return Gn.sortOuterAndHoleLoopsXY(r)}static constructPolygonWireXYOffset(t,e,i){return(new Qn).constructPolygonWireXYOffset(t,e,i)}static constructCurveXYOffset(t,e){return $n.constructCurveXYOffset(t,e)}static testPointInOnOutRegionXY(t,e,i){return Mn.testPointInOnOutRegionXY(t,e,i)}static createLoopPathOrBagOfCurves(t,e=!0,i=!1){const s=t.length;if(0===s)return;let n,r=0,o=!1;e&&(r=J.maxXY(r,t[0].startPoint().distance(t[s-1].endPoint())));for(let e=0;e+1<s;e++)r=J.maxXY(r,t[e].endPoint().distance(t[e+1].startPoint()));J.isSmallMetricDistance(r)?(n=e?Ue.create():qe.create(),o=!0):n=Ee.create();for(const e of t)n.tryAddChild(e);return o&&i&&Gn.consolidateAdjacentPrimitives(n),n}static setCheckPointFunction(t){this._graphCheckPointFunction=t}static cloneCurvesWithXYSplits(t,e){return Fn.cloneCurvesWithXYSplits(t,e)}static splitToPathsBetweenBreaks(t,e){if(void 0===t)return;if(t instanceof $t)return t;const i=t.collectCurvePrimitives(),s=new wn(e);for(const t of i)s.announceCurvePrimitive(t);return s.grabResult()}static collectInsideAndOutsideOffsets(t,e,i){return Zi.collectInsideAndOutsideOffsets(t,e,i)}static collectChains(t,e=J.smallMetricDistance){return Zi.collectChains(t,e)}static splitPathsByRegionInOnOutXY(t,e){const i={insideParts:[],outsideParts:[],coincidentParts:[]},s=Gn.cloneCurvesWithXYSplits(t,e),n=Gn.splitToPathsBetweenBreaks(s,!0);if(n instanceof Me)for(const t of n.children){const s=Me.createCurveLocationDetailOnAnyCurvePrimitive(t);s&&Jn(t,Gn.testPointInOnOutRegionXY(e,s.point.x,s.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}else if(n instanceof $t){const t=Me.createCurveLocationDetailOnAnyCurvePrimitive(n);t&&Jn(n,Gn.testPointInOnOutRegionXY(e,t.point.x,t.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}return i}static rectangleEdgeTransform(t,e=!0){if(t instanceof ye)return this.rectangleEdgeTransform(t.packedPoints);if(t instanceof tt){let i;if(e&&5===t.length){if(!J.isSmallMetricDistance(t.distanceIndexIndex(0,4)))return;i=t}else if(e||4!==t.length){if(t.length<(e?5:4))return;if(i=it.create(t),We.compressInPlaceByShortEdgeLength(i,J.smallMetricDistance),i.length<(e?5:4))return}else i=t;const s=i.vectorIndexIndex(0,1),n=i.vectorIndexIndex(0,3),r=i.vectorIndexIndex(1,2),o=s.crossProduct(n);if(o.normalizeInPlace()&&r.isAlmostEqual(n)&&s.isPerpendicularTo(n))return ft.createOriginAndMatrixColumns(i.getPoint3dAtUncheckedPointIndex(0),s,n,o)}else{if(Array.isArray(t))return this.rectangleEdgeTransform(new te(t),e);if(t instanceof Ue&&1===t.children.length&&t.children[0]instanceof ye)return this.rectangleEdgeTransform(t.children[0].packedPoints,!0);if(t instanceof qe&&1===t.children.length&&t.children[0]instanceof ye)return this.rectangleEdgeTransform(t.children[0].packedPoints,e);if(t instanceof be&&!t.checkForNonLinearPrimitives()){const e=t.getPackedStrokes();if(e)return this.rectangleEdgeTransform(e)}}}static consolidateAdjacentPrimitives(t,e){const i=new Tn(e);t.dispatchToGeometryHandler(i)}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)if(i instanceof Ue)Qe.pushLoop(e,i);else if(i instanceof tt){const t=Ue.createPolygon(i);Qe.pushLoop(e,t)}return Qe.sortAsAnyRegion(e)}static constructAllXYRegionLoops(t,e=J.smallMetricDistance){const i=Gn.collectCurvePrimitives(t,void 0,!0,!0),s=this.curveArrayRange(i),n=this.computeXYAreaTolerance(s,e),r=Le.allIntersectionsAmongPrimitivesXY(i,e),o=En.assembleHalfEdgeGraph(i,r,e);return En.collectSignedLoopSetsInHalfEdgeGraph(o,n)}static collectCurvePrimitives(t,e,i=!1,s=!1){const n=void 0===e?[]:e;if(t instanceof $t)t.collectCurvePrimitives(n,i,s);else if(t instanceof Me)t.collectCurvePrimitives(n,i,s);else if(Array.isArray(t))for(const e of t)this.collectCurvePrimitives(e,n,i,s);return n}static expandLineStrings(t){const e=[];for(const i of t)if(i instanceof ye)for(let t=0;t+1<i.packedPoints.length;t++){const s=i.getIndexedSegment(t);void 0!==s&&e.push(s)}else e.push(i);return e}static curveArrayRange(t,e){const i=lt.create();if(t instanceof Rt)t.extendRange(i,e);else if(Array.isArray(t))for(const s of t)s instanceof Rt?s.extendRange(i,e):s instanceof K?i.extendPoint(s,e):s instanceof it?i.extendRange(s.getRange(e)):Array.isArray(s)&&i.extendRange(this.curveArrayRange(s,e));return i}}function Jn(t,e,i,s,n){e>0?n.push(t):e<0?i.push(t):s.push(t)}!function(t){t[t.Unknown=0]="Unknown",t[t.Cap=1]="Cap",t[t.Extend=2]="Extend",t[t.Trim=-1]="Trim",t[t.JustGeometry=3]="JustGeometry",t[t.Gap=4]="Gap"}(B||(B={}));class Hn{constructor(t,e=180,i=90,s=!1){this.minArcDegrees=180,this.maxChamferTurnDegrees=90,this.leftOffsetDistance=0,this.preserveEllipticalArcs=!1,this.leftOffsetDistance=t,this.minArcDegrees=e,this.maxChamferTurnDegrees=i,this.preserveEllipticalArcs=s}clone(){return new Hn(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs)}setFrom(t){this.leftOffsetDistance=t.leftOffsetDistance,this.minArcDegrees=t.minArcDegrees,this.maxChamferTurnDegrees=t.maxChamferTurnDegrees,this.preserveEllipticalArcs=t.preserveEllipticalArcs}static create(t){return t instanceof Hn?t:new Hn(t)}needArc(t){return Math.abs(t.degrees)>=this.minArcDegrees}numChamferPoints(t){const e=Math.abs(t.degrees),i=J.clamp(this.maxChamferTurnDegrees,10,120);return e<=i?1:Math.ceil(e/i)}}class Kn{constructor(t,e){this.jointOptions=Hn.create(t),this.strokeOptions=void 0!==e?e:ve.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(t){this.jointOptions.minArcDegrees=t}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(t){this.jointOptions.maxChamferTurnDegrees=t}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(t){this.jointOptions.leftOffsetDistance=t}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(t){this.jointOptions.preserveEllipticalArcs=t}static create(t){return t instanceof Kn?t:new Kn(t)}static getOffsetDistance(t){return"number"==typeof t?t:t.leftOffsetDistance}clone(){return new Kn(this.jointOptions.clone(),this.strokeOptions.clone())}}class jn{constructor(t,e,i){this.curve0=t,this.curve1=e,this.swingPoint=i,this.flexure=B.Unknown}static constructArc(t,e,i){if(void 0!==e&&J.isSameCoordinate(t.origin.distance(e),i.origin.distance(e))){const s=t.direction.angleToXY(i.direction),n=j.createStartEnd(e,t.origin),r=n.rotate90CCWXY();return Pe.create(e,n,r,vt.createStartEndRadians(0,s.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(t,e){t.nextJoint=e,e&&(e.previousJoint=t),t.curve1&&e&&!e.curve0?e.curve0=t.curve1:!t.curve1&&e&&e.curve0&&(t.curve1=e.curve0)}nextJointFraction0(t){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:t}static addStrokes(t,e){e&&e.emitStrokes(t)}static addPoint(t,e){t.packedPoints.length>0&&(t.endPoint().isAlmostEqual(e)||t.packedPoints.push(e))}static collectStrokesFromChain(t,e,i=100){let s=-2*i;jn.visitJointsOnChain(t,(t=>{if(this.addStrokes(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),n&&(t.jointCurve||this.addPoint(e,n.startPoint())),this.addStrokes(e,n)}return s++<i}),i)}static collectPrimitive(t,e){if(e){if(t.length>0){const i=t[t.length-1].endPoint(),s=e.startPoint();i.isAlmostEqual(s)||t.push(tr.create(i,s))}t.push(e)}}static adjustJointToPrimitives(t){const e=t.jointCurve;if(e instanceof ye){if(t.curve0){const i=t.curve0.endPoint(),s=e.startPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(0,i)}if(t.curve1){const i=t.curve1.startPoint(),s=e.endPoint();i.isAlmostEqual(s)||e.packedPoints.setAtCheckedPointIndex(e.packedPoints.length-1,i)}}}static collectCurvesFromChain(t,e,i=100){if(void 0===t)return;let s=-2*i;jn.visitJointsOnChain(t,(t=>{if(this.adjustJointToPrimitives(t),this.collectPrimitive(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,s=t.nextJointFraction0(1);let n;0===i&&1===s?n=t.curve1.clone():i<s&&(n=t.curve1.clonePartialCurve(i,s)),this.collectPrimitive(e,n)}return s++<i}),i)}static annotateChain(t,e,i=100){t&&jn.visitJointsOnChain(t,(t=>(t.annotateJointMode(e),!0)),i)}static visitJointsOnChain(t,e,i=100){let s=t;if(s){let n=0;for(;void 0!==s;){if(n++>=i+5)return!0;if(!e(s))return!1;if(s=s.nextJoint,s===t)break}}return!0}annotateExtension(t){if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(1),i=this.curve1.fractionToPointAndDerivative(0),s=kt.closestApproachRay3dRay3d(e,i);if(s.approachType===A.Intersection&&s.detailA.fraction>=0&&s.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=B.Extend;const n=e.getDirectionRef().angleToXY(i.getDirectionRef());if(t.needArc(n)){const t=jn.constructArc(e,this.curve0.baseCurveEnd,i);if(t)return void(this.jointCurve=t)}const r=t.numChamferPoints(n);if(r<=1)return void(this.jointCurve=ye.create(e.origin,s.detailA.point,i.origin));if(r>1){const t=2*r,s=n.radians/t,o=jn.constructArc(e,this.curve0.baseCurveEnd,i);if(void 0!==o){const n=1/Math.cos(s),a=ye.create();this.jointCurve=a,a.addPoint(e.origin);for(let e=0;e<r;e++){const i=(1+2*e)/t;a.addPoint(o.fractionAndRadialFractionToPoint(i,n))}return void a.addPoint(i.origin)}}}this.flexure=B.Gap,this.jointCurve=tr.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(t,e,i){let s=-1,n=Number.MAX_VALUE;for(let r=0;r<i.length;r++){const o=Math.abs(i[r].detailA.fraction-t)+Math.abs(i[r].detailB.fraction-e);o<n&&(n=o,s=r)}return s}annotateJointMode(t){if(this.curve0&&!this.curve1)this.flexure=B.Cap,this.fraction0=1;else if(this.curve1&&!this.curve0)this.flexure=B.Cap,this.fraction1=0;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=B.Trim;else if(this.curve0 instanceof tr&&this.curve1 instanceof tr){const e=this.curve0.fractionToPointAndDerivative(0),i=this.curve1.fractionToPointAndDerivative(0),s=kt.closestApproachRay3dRay3d(e,i);s.approachType===A.Intersection&&(this.fraction0=s.detailA.fraction,this.fraction1=s.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(t):this.fraction0<1&&this.fraction1>0?this.flexure=B.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=B.Gap,this.jointCurve=tr.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const e=Le.intersectionXYPairs(this.curve0,!1,this.curve1,!1),i=this.selectIntersectionIndexByFraction(1,0,e);i>=0?(this.flexure=B.Trim,this.fraction0=e[i].detailA.fraction,this.fraction1=e[i].detailB.fraction):this.annotateExtension(t)}}static removeDegeneratePrimitives(t,e,i){let s=t,n=0,r=0;if(s)for(;void 0!==s&&r++<i;){const i=s.nextJoint;if(s&&i&&s.previousJoint&&i.nextJoint&&void 0!==s.fraction1&&void 0!==i.fraction0){const r=s.fraction1,o=i.fraction0,a=i.fraction1,c=i.nextJoint.fraction0,h=r>=o||r>1;if(h&&(void 0!==a&&a>1||void 0!==a&&void 0!==c&&a>=c)){const t=i.nextJoint,n=new jn(s.curve0,t.curve1,void 0);jn.link(s.previousJoint,n),jn.link(n,t.nextJoint),n.annotateJointMode(e),n.previousJoint.annotateJointMode(e),n.nextJoint&&n.nextJoint.annotateJointMode(e)}else if(h){const r=new jn(s.curve0,i.curve1,void 0);if(jn.link(s.previousJoint,r),jn.link(r,i.nextJoint),r.annotateJointMode(e),r.previousJoint.annotateJointMode(e),r.nextJoint.annotateJointMode(e),n++,s===t&&(t=r),s=r,n>=1)return{newStart:t,numJointRemoved:n}}}if(s=s.nextJoint,s===t)break}return{newStart:t,numJointRemoved:n}}}class Qn{constructor(){}static createOffsetSegment(t,e,i){if(j.createStartEnd(t,e,this._unitAlong),this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const s=tr.create(t.plusScaled(this._unitPerp,i,this._offsetA),e.plusScaled(this._unitPerp,i,this._offsetB));return $n.applyBasePoints(s,t.clone(),e.clone()),s}}constructPolygonWireXYOffset(t,e,i){const s=Hn.create(i),n=t.length;let r,o=Qn.createOffsetSegment(t[0],t[1],s.leftOffsetDistance),a=new jn(void 0,o,t[0]),c=a;for(let e=1;e+1<n;e++){const i=Qn.createOffsetSegment(t[e],t[e+1],s.leftOffsetDistance);r=new jn(o,i,t[e]),jn.link(c,r),c=r,o=i}e?jn.link(c,a):(r=new jn(o,void 0,t[n-1]),jn.link(c,r)),jn.annotateChain(a,s,n);for(let t=0;t++<5;){const t=jn.removeDegeneratePrimitives(a,s,n);if(a=t.newStart,0===t.numJointRemoved)break}const h=ye.create();if(jn.collectStrokesFromChain(a,h,n),h.packedPoints.length>1)return h.packedPoints.front().isAlmostEqual(h.packedPoints.back())?Ue.create(h):qe.create(h)}}Qn._unitAlong=j.create(),Qn._unitPerp=j.create(),Qn._offsetA=K.create(),Qn._offsetB=K.create();class $n{constructor(){}static applyBasePoints(t,e,i){return void 0!==t&&(void 0!==e&&(t.baseCurveStart=e),void 0!==i&&(t.baseCurveEnd=i)),t}static createSingleOffsetPrimitiveXY(t,e){const i=t.constructOffsetXY(e);if(void 0!==i){if(Array.isArray(i)){const e=t.collectCurvePrimitives(void 0,!0,!0);if(e.length!==i.length)return;for(let t=0;t<e.length;++t)this.applyBasePoints(i[t],e[t].startPoint(),e[t].endPoint());return i}return this.applyBasePoints(i,t.startPoint(),t.endPoint())}}static constructCurveXYOffset(t,e){const i=t instanceof Ue,s=Kn.create(e),n=[];for(const e of t.children){const t=$n.createSingleOffsetPrimitiveXY(e,s);if(void 0===t);else if(t instanceof $t)n.push(t);else if(Array.isArray(t))for(const e of t)e instanceof $t&&n.push(e)}let r,o,a,c;for(const t of n)t&&(o=new jn(r,t,t.fractionToPoint(0)),void 0!==o&&void 0===c&&(c=o),a&&jn.link(a,o),a=o,r=t);c&&a&&t instanceof Ue&&jn.link(a,c);const h=n.length;jn.annotateChain(c,s.jointOptions,h);const l=[];return jn.collectCurvesFromChain(c,l,h),Gn.createLoopPathOrBagOfCurves(l,i,!0)}}class tr extends $t{isSameGeometryClass(t){return t instanceof tr}get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(t,e){super(),this.curvePrimitiveType="lineSegment",this._point0=t,this._point1=e}setRefs(t,e){this._point0=t,this._point1=e}set(t,e){this._point0=t.clone(),this._point1=e.clone()}setFrom(t){this._point0.setFrom(t._point0),this._point1.setFrom(t._point1)}startPoint(t){return t?(t.setFrom(this._point0),t):this._point0.clone()}endPoint(t){return t?(t.setFrom(this._point1),t):this._point1.clone()}fractionToPointAndDerivative(t,e){return(e=e||kt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(t,this._point1,e.origin),e}fractionToPointAnd2Derivatives(t,e){return(e=e||Ft.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),e.vectorV.set(0,0,0),this._point0.interpolate(t,this._point1,e.origin),e}clone(){return tr.create(this._point0,this._point1)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(t,e,i){return i?(i.set(t,e),i):new tr(t.clone(),e.clone())}static createCapture(t,e){return new tr(t,e)}static createXYXY(t,e,i,s,n=0,r){return r?(r._point0.set(t,e,n),r._point1.set(i,s,n),r):new tr(K.create(t,e,n),K.create(i,s,n))}static createXYZXYZ(t,e,i,s,n,r,o){return o?(o._point0.set(t,e,i),o._point1.set(s,n,r),o):new tr(K.create(t,e,i),K.create(s,n,r))}fractionToPoint(t,e){return this._point0.interpolate(t,this._point1,e)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(t,e,i){let s=t.fractionOfProjectionToLine(this._point0,this._point1,0);return s=Jt.correctFraction(e,s),(i=yt.create(this,i)).fraction=s,this._point0.interpolate(s,this._point1,i.point),i.vectorInCurveLocationDetail=void 0,i.a=i.point.distance(t),i}reverseInPlace(){const t=this._point0;this._point0=this._point1,this._point1=t}tryTransformInPlace(t){return this._point0=t.multiplyPoint3d(this._point0,this._point0),this._point1=t.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(t){return J.isSmallMetricDistance(t.altitude(this._point0))&&J.isSmallMetricDistance(t.altitude(this._point1))}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._point0),s=t.altitude(this._point1),n=Bt.solveCoffs(i,s);let r=0;if(void 0!==n){r++;const t=yt.createCurveFractionPoint(this,n,this.fractionToPoint(n));t.intervalRole=P.isolated,e.push(t)}return r}extendRange(t,e){e?(t.extendTransformedPoint(e,this._point0),t.extendTransformedPoint(e,this._point1)):(t.extendPoint(this._point0),t.extendPoint(this._point1))}setFromJSON(t){if(!t)return this._point0.set(0,0,0),void this._point1.set(1,0,0);t.startPoint&&t.endPoint?(this._point0.setFromJSON(t.startPoint),this._point1.setFromJSON(t.endPoint)):Array.isArray(t)&&t.length>1&&(this._point0.setFromJSON(t[0]),this._point1.setFromJSON(t[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(t){const e=new tr(K.createZero(),K.create());return e.setFromJSON(t),e}isAlmostEqual(t){if(t instanceof tr){const e=t;return this._point0.isAlmostEqual(e._point0)&&this._point1.isAlmostEqual(e._point1)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1)}emitStrokableParts(t,e){t.startCurvePrimitive(this);const i=this.computeStrokeCountForOptions(e);t.announceSegmentInterval(this,this._point0,this._point1,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;return t&&(t.maxEdgeLength&&(e=t.applyMaxEdgeLength(e,this.curveLength())),e=t.applyMinStrokesPerPrimitive(e)),e}dispatchToGeometryHandler(t){return t.handleLineSegment3d(this)}announceClipIntervals(t,e){return t.announceClippedSegmentIntervals(0,1,this._point0,this._point1,e?(t,i)=>e(t,i,this):void 0)}clonePartialCurve(t,e){return tr.create(this.fractionToPoint(t),this.fractionToPoint(e))}rangeBetweenFractions(t,e,i){if(!i){const i=lt.create();return i.extendInterpolated(this._point0,t,this._point1),i.extendInterpolated(this._point0,e,this._point1),i}const s=this.fractionToPoint(t),n=this.fractionToPoint(e);return i&&(i.multiplyPoint3d(s,s),i.multiplyPoint3d(n,n)),lt.create(s,n)}constructOffsetXY(t){const e=j.createStartEnd(this._point0,this._point1);if(e.normalizeInPlace()){e.rotate90CCWXY(e);const i=Kn.getOffsetDistance(t);return tr.create(this._point0.plusScaled(e,i),this._point1.plusScaled(e,i))}}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}class er extends ge{constructor(t){super(),this.plane=t,this.range=dt.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(t){const e=this.plane.altitude(t);this.range.extendLow(e)&&(this.lowPoint=t.clone(this.lowPoint)),this.range.extendHigh(e)&&(this.highPoint=t.clone(this.highPoint))}announcePoints(t){for(let e=0;e<t.length;e++){const i=t.evaluateUncheckedIndexPlaneAltitude(e,this.plane);this.range.extendLow(i)&&(this.lowPoint=t.getPoint3dAtUncheckedPointIndex(e,this.lowPoint)),this.range.extendHigh(i)&&(this.highPoint=t.getPoint3dAtUncheckedPointIndex(e,this.highPoint))}}static createCapture(t){return new er(t)}handleLineSegment3d(t){this.announcePoint(t.point0Ref),this.announcePoint(t.point1Ref)}handleLineString3d(t){this.announcePoints(t.packedPoints)}initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new ve,this._strokeOptions.angleTol=Z.createDegrees(1))}handleBSplineCurve3d(t){this.initStrokeOptions();const e=ye.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleBSplineCurve3dH(t){this.initStrokeOptions();const e=ye.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleArc3d(t){this._sineCosinePolynomial=t.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let e=this._sineCosinePolynomial.referenceMinMaxRadians();t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),e+=Math.PI,t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),this.announcePoint(this._workPoint=t.startPoint(this._workPoint)),this.announcePoint(this._workPoint=t.endPoint(this._workPoint))}static findExtremesInDirection(t,e){const i=e instanceof kt?e.origin:K.createZero(),s=e instanceof kt?e.direction:e,n=mt.create(i,s);if(n){const e=new er(n);if(t instanceof Rt)t.dispatchToGeometryHandler(e);else if(t instanceof it)e.announcePoints(t);else for(const i of t)e.announcePoint(i);return e}}static findExtremePointsInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&s.highPoint&&s.lowPoint)return tr.create(s.lowPoint,s.highPoint,i)}static findExtremeAltitudesInDirection(t,e,i){const s=this.findExtremesInDirection(t,e);if(s&&!s.range.isNull)return dt.createFrom(s.range,i)}static findExtremeFractionsAlongDirection(t,e,i){const s=this.findExtremeAltitudesInDirection(t,e,i);if(void 0!==s){const t=e instanceof j?e.magnitude():e.direction.magnitude(),i=J.conditionalDivideCoordinate(1,t);if(void 0!==i)return s.low*=i,s.high*=i,s}}}class ir{constructor(t,e){this._blockSize=t,this._order=Math.floor(e.length/t),this._packedData=e,this._basis=new Ot(this._order)}clonePolygon(t){const e=this._packedData.length;if(!t||t.length!==e)return this._packedData.slice();for(let i=0;i<e;i++)t[i]=this._packedData[i];return t}get order(){return this._order}get packedData(){return this._packedData}static create(t){if(!(t.length<1)){if(t[0]instanceof K){const e=new Float64Array(3*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new ir(3,e)}if(t[0]instanceof bt){const e=new Float64Array(4*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new ir(4,e)}if(t[0]instanceof W){const e=new Float64Array(2*t.length);let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y;return new ir(2,e)}}}evaluate(t,e){return this._basis.sumBasisFunctions(t,this._packedData,this._blockSize,e)}evaluateDerivative(t,e){return this._basis.sumBasisFunctionDerivatives(t,this._packedData,this._blockSize,e)}getPolygonPoint(t,e){if(e||(e=new Float64Array(this._blockSize)),t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)e[t]=this._packedData[i+t];return e}}setPolygonPoint(t,e){if(t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)this._packedData[i+t]=e[t]}}loadSpanPoles(t,e){let i=e*this._blockSize;for(let e=0;e<this._packedData.length;e++)this._packedData[e]=t[i++]}loadSpanPolesWithWeight(t,e,i,s){let n=0;const r=this._order;let o=i*e;for(let i=0;i<r;i++){for(let i=0;i<e;i++)this._packedData[n++]=t[o++];this._packedData[n++]=s}}unpackToJsonArrays(){return ne.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(t){if(t instanceof ir){if(this._blockSize!==t._blockSize)return!1;if(this._order!==t._order)return!1;if(this._packedData.length!==t._packedData.length)return!1;for(let e=0;e<this._packedData.length;e++)if(!J.isSameCoordinate(this._packedData[e],t._packedData[e]))return!1;return!0}return!1}reverseInPlace(){const t=this._blockSize;let e,i,s;for(e=0,i=(this._order-1)*t;e<i;e+=t,i-=t)for(let n=0;n<t;n++)s=this._packedData[e+n],this._packedData[e+n]=this._packedData[i+n],this._packedData[i+n]=s}interpolatePoleInPlace(t,e,i){let s=t*this._blockSize,n=i*this._blockSize;const r=this._packedData;for(let t=0;t<this._blockSize;t++,s++,n++)r[s]+=e*(r[n]-r[s])}saturateInPlace(t,e){const i=t.degree,s=e+i-1,n=s+1;if(e<0||e>=t.numSpans)return!1;const r=t.knots,o=r[s],a=r[n];if(this.setInterval(o,a),a<=o+ae.knotTolerance)return!1;for(let t=i-1;t>0;t--){let e=s-t;if(r[e]<o){let i=n;for(let s=0;s<t;s++,e++,i++){const t=r[e],n=(o-t)/(r[i]-t);this.interpolatePoleInPlace(s,n,s+1)}}}for(let t=i-1;t>0;t--){let e=n+t;if(r[e]>a)for(let s=0;s<t;s++,e--){const t=r[e],n=(a-t)/(o-t);this.interpolatePoleInPlace(i-s,n,i-s-1)}}return!0}static saturate1dInPlace(t,e,i){const s=e.degree,n=i+s-1,r=n+1;if(i<0||i>=e.numSpans)return!1;const o=e.knots,a=o[n],c=o[r];if(c<=a+ae.knotTolerance)return!1;for(let e=s-1;e>0;e--){let i=n-e;if(o[i]<a){let s=r;for(let n=0;n<e;n++,i++,s++){const e=o[i],r=(a-e)/(o[s]-e);t[n]=t[n]+r*(t[n+1]-t[n])}}}for(let e=s-1;e>0;e--){let i,n=r+e;if(o[n]>c)for(let r=0;r<e;r++,n--){const e=o[n],h=(c-e)/(a-e);i=s-r,t[i]+=h*(t[i-1]-t[i])}}return!0}subdivideInPlaceKeepLeft(t){if(J.isAlmostEqualNumber(t,1))return!0;if(J.isAlmostEqualNumber(t,0))return!1;const e=1-t,i=this.order;for(let t=1;t<i;t++)for(let s=i-1;s>=t;s--)this.interpolatePoleInPlace(s,e,s-1);return!0}subdivideInPlaceKeepRight(t){if(J.isAlmostEqualNumber(t,0))return!0;if(J.isAlmostEqualNumber(t,1))return!1;const e=this.order;for(let i=1;i<e;i++)for(let s=0;s+i<e;s++)this.interpolatePoleInPlace(s,t,s+1);return!0}subdivideToIntervalInPlace(t,e){return!J.isAlmostEqualNumber(t,e)&&(e<t?(this.subdivideToIntervalInPlace(e,t),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(e),this.subdivideInPlaceKeepRight(t/e),!0))}setInterval(t,e){this.interval=De.create(t,e,this.interval)}fractionToParentFraction(t){return this.interval?this.interval.fractionToPoint(t):t}}class sr extends $t{constructor(t,e){super(),this.curvePrimitiveType="bezierCurve",this._polygon=new ir(t,e),this._workPoint0=K.create(),this._workPoint1=K.create(),this._workData0=new Float64Array(t),this._workData1=new Float64Array(t)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(t,e){const i=this._polygon.saturateInPlace(t,e);return i&&this.setInterval(t.spanFractionToFraction(e,0),t.spanFractionToFraction(e,1)),i}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(t,e){this._polygon.setInterval(t,e)}fractionToParentFraction(t){return this._polygon.fractionToParentFraction(t)}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e),s=1/i;for(let e=0;e<=i;e++){const i=e*s;this.fractionToPoint(i,this._workPoint0),t.appendStrokePoint(this._workPoint0)}}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.announceIntervalForUniformStepStrokes(this,i,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(t){let e=this._workPoint0;for(let i=0;;i++){if(e=this.getPolePoint3d(i,e),!e)return!0;if(!t.isPointInPlane(e))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let t=0,e=0;for(;this.getPolePoint3d(++t,this._workPoint1);)e+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return e}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}allocateAndZeroBezierWorkData(t,e,i){t>0&&(void 0!==this._workBezier&&this._workBezier.order===t?this._workBezier.zero():this._workBezier=new Ot(t)),e>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===e?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(e)),i>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===i?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(i))}computeStrokeCountForOptions(t){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let e=1;if(this._workPoint0&&this._workPoint1){let i,s,n,r=this._workPoint1.x-this._workPoint0.x,o=this._workPoint1.y-this._workPoint0.y,a=this._workPoint1.z-this._workPoint0.z,c=0,h=J.hypotenuseXYZ(r,o,a);this._workPoint1.setFromPoint3d(this._workPoint0);let l,d=h,u=h,f=0;for(let t=2;this.getPolePoint3d(t,this._workPoint1);t++)i=this._workPoint1.x-this._workPoint0.x,s=this._workPoint1.y-this._workPoint0.y,n=this._workPoint1.z-this._workPoint0.z,l=Z.radiansBetweenVectorsXYZ(r,o,a,i,s,n),c+=l,f=J.maxAbsXY(l,f),h=J.hypotenuseXYZ(i,s,n),d+=h,u=J.maxXY(u,h),r=i,o=s,a=n,this._workPoint0.setFrom(this._workPoint1);const g=u*this.degree,p=Math.sqrt(g*d);let m=f*(this.degree-1);this.degree<3&&(m*=3);const x=Math.sqrt(m*c),y=this.degree;e=ve.applyAngleTol(t,ve.applyMaxEdgeLength(t,y,p),x,.1),t&&(e=t.applyChordTolToLengthAndRadians(e,d,m))}return e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}constructOffsetXY(t){const e=Kn.create(t),i=new de(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}clonePartialCurve(t,e){const i=this.clone();return i._polygon.subdivideToIntervalInPlace(t,e),i}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}class nr extends sr{isSameGeometryClass(t){return t instanceof nr}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZToFloat64Array(e[0],e[1],e[2],e),this._polygon.setPolygonPoint(i,e);return!0}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return K.create(i[0],i[1],i[2],e)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return bt.create(i[0],i[1],i[2],1,e)}constructor(t){super(3,t),this._workRay0=kt.createXAxis(),this._workRay1=kt.createXAxis()}copyPointsAsLineString(){const t=ye.create();for(let e=0;e<this._polygon.order;e++)t.addPoint(this.getPolePoint3d(e));return t}static create(t){if(t.length<1)return;const e=new Float64Array(3*t.length);if(t[0]instanceof K){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z;return new nr(e)}if(t[0]instanceof W){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0;return new nr(e)}}static createOrder(t){const e=new Float64Array(3*t);return new nr(e)}loadSpanPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new nr(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),K.create(this._workData0[0],this._workData0[1],this._workData0[2],e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),kt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],e)}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Ft.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return j.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof nr&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3d(this)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(i-1,i,0);const s=this._workBezier,n=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const r=this._polygon.packedData;for(let o=0;o<3;o++){for(let t=0,s=0;t<i;t++,s+=3)n[t]=e.multiplyComponentXYZ(o,r[s],r[s+1],r[s+2]);Yt.univariateDifference(n,s.coffs);const a=s.roots(0,!0);if(a&&a.length>0)for(const i of a)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(i-1,0,0);const e=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let s=0;s<3;s++){Yt.componentDifference(e.coffs,this._polygon.packedData,3,i,s);const n=e.roots(0,!0);if(n)for(const e of n)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class rr extends sr{isSameGeometryClass(t){return t instanceof rr}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZWToFloat64Array(e[0],e[1],e[2],e[3],e),this._polygon.setPolygonPoint(i,e);return!0}tryMultiplyMatrix4dInPlace(t){t.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return bt.create(i[0],i[1],i[2],i[3],e)}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return K.createFromPackedXYZW(i,0,e)}isUnitWeight(t){void 0===t&&(t=J.smallAngleRadians);const e=1-t,i=1+t,s=this._polygon.packedData,n=s.length;let r;for(let t=3;t<n;t+=4)if(r=s[t],r<e||r>i)return!1;return!0}constructor(t){super(4,t),this._workRay0=kt.createXAxis(),this._workRay1=kt.createXAxis()}static create(t){if(t.length<1)return;const e=new Float64Array(4*t.length);if(t[0]instanceof K){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=1;return new rr(e)}if(t[0]instanceof bt){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=s.z,e[i++]=s.w;return new rr(e)}if(t[0]instanceof W){let i=0;for(const s of t)e[i++]=s.x,e[i++]=s.y,e[i++]=0,e[i++]=1;return new rr(e)}}static createOrder(t){const e=new Float64Array(4*t);return new rr(e)}loadSpan3dPolesWithWeight(t,e,i){this._polygon.loadSpanPolesWithWeight(t,3,e,i)}loadSpan4dPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new rr(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),(e=K.createFromPackedXYZW(this._workData0,0,e))||K.createZero()}fractionToPoint4d(t,e){return this._polygon.evaluate(t,this._workData0),bt.createFromPackedXYZW(this._workData0,0,e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),(e=kt.createWeightedDerivative(this._workData0,this._workData1,e))||kt.createXAxis()}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Ft.createXYPlane());const s=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(s.origin),e.vectorU.setFrom(s.direction);const n=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return j.createAdd2Scaled(n.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof rr&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3dH(this)}poleProductsXYZW(t,e,i,s,n){const r=this.numPoles,o=this._polygon.packedData;for(let a=0,c=0;a<r;a++,c+=4)t[a]=e*o[c]+i*o[c+1]+s*o[c+2]+n*o[c+3]}updateClosestPointByTruePerpendicular(t,e,i=!1,s=!1){let n,r=0;if(this.isUnitWeight()){const e=2*this.order-2;this.allocateAndZeroBezierWorkData(e,0,0);const i=this._workBezier;Yt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,0,-t.x,0),Yt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,1,-t.y,1),Yt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,2,-t.z,2),n=i.roots(0,!0)}else{const e=this.order,i=2*this.order-2,s=e+i-1;this.allocateAndZeroBezierWorkData(s,e,i);const r=this._workBezier,o=this._workCoffsA,a=this._workCoffsB,c=this._polygon.packedData;for(let i=0;i<3;i++){for(let t=0;t<o.length;t++)o[t]=0;for(let t=0;t<a.length;t++)a[t]=0;Yt.scaledComponentSum(o,c,4,e,3,t.at(i),i,-1),Yt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,1,3,0,i),Yt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,-1,i,0,3),Yt.accumulateProduct(r.coffs,o,a)}n=r.roots(0,!0)}if(n)for(const i of n){const s=this.fractionToPoint(i),n=s.distance(t);r+=e.updateIfCloserCurveFractionPointDistance(this,i,s,n)?1:0}return i&&(r+=this.updateDetailAtFraction(e,0,t)?1:0),s&&(r+=this.updateDetailAtFraction(e,1,t)?1:0),r>0}updateDetailAtFraction(t,e,i){const s=this.fractionToPoint(e),n=s.distance(i);return t.updateIfCloserCurveFractionPointDistance(this,e,s,n)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(2*i-2,i,i);const s=this._workCoffsA,n=this._workCoffsB,r=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const o=this._polygon.packedData;let a;for(let c=0;c<3;c++){r.zero();for(let t=0,r=0;t<i;t++,r+=4)a=o[r+3],s[t]=e.multiplyComponentXYZW(c,o[r],o[r+1],o[r+2],a),n[t]=a;Yt.accumulateProductWithDifferences(r.coffs,s,n,1),Yt.accumulateProductWithDifferences(r.coffs,n,s,-1);const h=r.roots(0,!0);if(h&&h.length>0)for(const i of h)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*i-2,0,0);const e=this._workBezier,s=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let n=0;n<3;n++){e.zero(),Yt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,1,n,0,3),Yt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,s,4,i,-1,3,0,n);const r=e.roots(0,!0);if(r)for(const e of r)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class or{get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(t,e){return K.createFromPacked(this.packedData,t,e)}constructor(t,e,i,s){this.knots=s,this.packedData=new Float64Array(t*e),this.poleLength=e,this.basisBuffer=new Float64Array(i),this.poleBuffer=new Float64Array(e),this.basisBuffer1=new Float64Array(i),this.basisBuffer2=new Float64Array(i),this.poleBuffer1=new Float64Array(e),this.poleBuffer2=new Float64Array(e)}static create(t,e,i,s){return new or(t,e,i,s)}spanFractionToKnot(t,e){return this.knots.spanFractionToKnot(t,e)}evaluateBasisFunctionsInSpan(t,e,i,s,n){t<0&&(t=0),t>=this.numSpan&&(t=this.numSpan-1);const r=t+this.degree-1,o=this.knots.baseKnotFractionToKnot(r,e);return s?this.knots.evaluateBasisFunctions1(r,o,i,s,n):this.knots.evaluateBasisFunctions(r,o,i)}evaluateBuffersInSpan(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer),this.sumPoleBufferForSpan(t)}evaluateBuffersInSpan1(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(t),this.sumPoleBuffer1ForSpan(t)}sumPoleBufferForSpan(t){this.poleBuffer.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer)for(let i=0;i<this.poleLength;i++)this.poleBuffer[i]+=t*this.packedData[e++]}sumPoleBuffer1ForSpan(t){this.poleBuffer1.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer1)for(let i=0;i<this.poleLength;i++)this.poleBuffer1[i]+=t*this.packedData[e++]}sumPoleBuffer2ForSpan(t){this.poleBuffer2.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer2)for(let i=0;i<this.poleLength;i++)this.poleBuffer2[i]+=t*this.packedData[e++]}evaluateBuffersAtKnot(t,e=0){const i=this.knots.knotToLeftKnotIndex(t);e<1?(this.knots.evaluateBasisFunctions(i,t,this.basisBuffer),this.sumPoleBufferForSpan(i-this.degree+1)):1===e?(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1)):(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1),this.sumPoleBuffer2ForSpan(i-this.degree+1))}reverseInPlace(){const t=this.poleLength,e=this.packedData;for(let i=0,s=t*(this.numPoles-1);i<s;i+=t,s-=t){let n=0;for(let r=0;r<t;r++)n=e[i+r],e[i+r]=e[s+r],e[s+r]=n}this.knots.reflectKnots()}testCloseablePolygon(t){void 0===t&&(t=this.knots.wrappable);const e=this.degree,i=this.poleLength,s=(this.numPoles-this.degree)*i,n=this.packedData;if(t===w.OpenByAddingControlPoints){const t=e*i;for(let e=0;e<t;e++)if(!J.isSameCoordinate(n[e],n[e+s]))return!1;return!0}return t===w.OpenByRemovingKnots}addKnot(t,e){if(t<this.knots.leftKnot||t>this.knots.rightKnot)return!1;let i=this.knots.knotToLeftKnotIndex(t);if(Math.abs(t-this.knots.knots[i])<ae.knotTolerance)t=this.knots.knots[i];else if(Math.abs(t-this.knots.knots[i+1])<ae.knotTolerance){if(i+=this.knots.getKnotMultiplicityAtIndex(i+1),i>this.knots.rightKnotIndex)return!0;t=this.knots.knots[i]}const s=Math.min(e,this.degree)-this.knots.getKnotMultiplicity(t);if(s<=0)return!0;let n=this.knots.knots.length;const r=new Float64Array(n+s);for(let t=0;t<n;++t)r[t]=this.knots.knots[t];let o=this.numPoles;const a=new Float64Array(this.packedData.length+s*this.poleLength);for(let t=0;t<this.packedData.length;++t)a[t]=this.packedData[t];const c=new Float64Array(this.degree*this.poleLength);for(let e=0;e<s;++e){let e=0;const s=i-this.degree+2;for(let i=s;i<s+this.degree;++i){const s=(t-r[i-1])/(r[i+this.degree-1]-r[i-1]);for(let t=i*this.poleLength;t<(i+1)*this.poleLength;++t)c[e++]=J.interpolate(a[t-this.poleLength],s,a[t])}a.copyWithin((s+this.degree)*this.poleLength,(s+this.degree-1)*this.poleLength,o*this.poleLength);let h=s*this.poleLength;for(const t of c)a[h++]=t;r.copyWithin(i+2,i+1,n),r[i+1]=t,++i,++n,++o}return this.knots.setKnotsCapture(r),this.packedData=a,!0}}class ar extends $t{set definitionData(t){this._definitionData=t}get definitionData(){return this._definitionData}constructor(t,e,i,s){super(),this.curvePrimitiveType="bsplineCurve",this._bcurve=or.create(e,t,i,s)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}copyKnots(t){return this._bcurve.knots.copyKnots(t)}setWrappable(t){this._bcurve.knots.wrappable=t}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const i=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(i,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const i=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(i,e);const s=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(s),e.vectorV.scaleInPlace(s*s),e}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(t){const e=[],i=this.numSpan;for(let s=0;s<i;s++)if(this._bcurve.knots.isIndexOfRealSpan(s)){const i=this.getSaturatedBezierSpan3dOr3dH(s,t);i&&e.push(i)}return e}poleIndexToDataIndex(t){if(t>=0&&t<this.numPoles)return t*this._bcurve.poleLength}closestPoint(t,e){const i=this.fractionToPoint(0),s=yt.createCurveFractionPointDistance(this,0,i,i.distance(t));let n;const r=this.numSpan;for(let e=0;e<r;e++)this._bcurve.knots.isIndexOfRealSpan(e)&&(n=this.getSaturatedBezierSpan3dOr3dH(e,!0,n),n&&n.updateClosestPointByTruePerpendicular(t,s,!1,!0)&&(s.curve=this,s.fraction=n.fractionToParentFraction(s.fraction)));return s}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}clonePartialCurve(t,e){const i=this.clone(),s=i._bcurve.knots.knots.length;let n=i._bcurve.knots.fractionToKnot(t),r=i._bcurve.knots.fractionToKnot(e);if(i._bcurve.addKnot(n,i.degree),i._bcurve.addKnot(r,i.degree),s===i._bcurve.knots.knots.length)return i;if(n>r){const t=n;n=r,r=t}const o=i._bcurve.knots.knotToLeftKnotIndex(n)-i.degree+1,a=o*i._bcurve.poleLength,c=i._bcurve.knots.knotToLeftKnotIndex(r);let h=c-i._bcurve.knots.getKnotMultiplicityAtIndex(c)+1;i._bcurve.knots.knots[c]<r&&(h=c+1);const l=(h+1)*i._bcurve.poleLength,d=h+i.degree;return i._bcurve.knots.setKnotsCapture(i._bcurve.knots.knots.slice(o,d)),i._bcurve.packedData=i._bcurve.packedData.slice(a,l),i.setWrappable(w.None),i}appendPlaneIntersectionPoints(t,e){const i=this.numPoles,s=this.order,n=new Float64Array(i),r=this.numSpan,o=bt.create(),a=dt.createNull();for(let e=0;e<i;e++)n[e]=t.weightedAltitude(this.getPolePoint4d(e,o)),a.extendX(n[e]);let c,h=0,l=-1e3;if(a.containsX(0))for(let t=0;t<r;t++)if(this._bcurve.knots.isIndexOfRealSpan(t)&&(a.setNull(),a.extendArraySubset(n,t,s),a.containsX(0))){c=Ot.createArraySubset(n,t,s,c),ir.saturate1dInPlace(c.coffs,this._bcurve.knots,t);const i=c.roots(0,!0);if(i)for(const s of i){h++;const i=this._bcurve.knots.spanFractionToFraction(t,s);if(!J.isAlmostEqualNumber(i,l)){const t=yt.createCurveEvaluatedFraction(this,i);t.intervalRole=P.isolated,e.push(t),l=i}}}return h}constructOffsetXY(t){const e=Kn.create(t),i=new de(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return er.findExtremeFractionsAlongDirection(this,t,e)}}class cr extends ar{initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=nr.createOrder(this.order)),this._workBezier}isSameGeometryClass(t){return t instanceof cr}tryTransformInPlace(t){return ne.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return K.create(t[i],t[i+1],t[i+2],e)}}getPolePoint4d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return bt.create(t[i],t[i+1],t[i+2],1,e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}constructor(t,e,i){super(3,t,e,i)}copyPoints(){return ne.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(t){return this._bcurve.knots.copyKnots(t)}static createUniformKnots(t,e){const i=t instanceof Float64Array?t.length/3:t.length;if(e<2||i<e)return;const s=ae.createUniformClamped(i,e-1,0,1),n=new cr(i,e,s);if(t instanceof Float64Array)for(let e=0;e<3*i;e++)n._bcurve.packedData[e]=t[e];else if(t instanceof it)n._bcurve.packedData=t.float64Data().slice(0,3*i);else{let e=0;for(const i of t)n._bcurve.packedData[e++]=i.x,n._bcurve.packedData[e++]=i.y,n._bcurve.packedData[e++]=i.z}return n}static createPeriodicUniformKnots(t,e){if(e<2)return;let i=t instanceof Float64Array?t.length/3:t.length;const s=K.createZero(),n=K.createZero();let r=!1;do{t instanceof Float64Array?(s.set(t[0],t[1],t[2]),n.set(t[3*i-3],t[3*i-2],t[3*i-1])):t instanceof it?(s.set(t.float64Data()[0],t.float64Data()[1],t.float64Data()[2]),n.set(t.float64Data()[3*i-3],t.float64Data()[3*i-2],t.float64Data()[3*i-1])):(s.setFromPoint3d(t[0]),n.setFromPoint3d(t[i-1])),(r=s.isAlmostEqual(n))&&--i}while(r&&i>1);if(i<e)return;const o=e-1,a=i,c=ae.createUniformWrapped(a,o,0,1);c.wrappable=w.OpenByAddingControlPoints;const h=new cr(i+o,e,c);if(t instanceof Float64Array){for(let e=0;e<3*i;e++)h._bcurve.packedData[e]=t[e];for(let e=0;e<3*o;e++)h._bcurve.packedData[3*i+e]=t[e]}else if(t instanceof it){h._bcurve.packedData=t.float64Data().slice(0,3*i);for(let e=0;e<3*o;e++)h._bcurve.packedData[3*i+e]=t.float64Data()[e]}else{let e=0;for(let s=0;s<i;s++)h._bcurve.packedData[e++]=t[s].x,h._bcurve.packedData[e++]=t[s].y,h._bcurve.packedData[e++]=t[s].z;for(let i=0;i<o;i++)h._bcurve.packedData[e++]=t[i].x,h._bcurve.packedData[e++]=t[i].y,h._bcurve.packedData[e++]=t[i].z}return h}static createFromInterpolationCurve3dOptions(t){return ce.createThroughPointsC2Cubic(t)}static createFromAkimaCurve3dOptions(t){return ce.createThroughPoints(t.fitPoints,4)}static create(t,e,i){if(i<2)return;let s=t.length;if(t instanceof Float64Array&&(s/=3),s<i)return;const n=e.length;let r;if(s+i===n)r=!0;else{if(s+i!==n+2)return;r=!1}const o=ae.create(e,i-1,r),a=new cr(s,i,o);let c=0;if(t instanceof Float64Array)for(const e of t)a._bcurve.packedData[c++]=e;else for(const e of t)a._bcurve.packedData[c++]=e.x,a._bcurve.packedData[c++]=e.y,a._bcurve.packedData[c++]=e.z;return a}clone(){const t=this._bcurve.knots.clone(),e=new cr(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}evaluatePointInSpan(t,e){return this._bcurve.evaluateBuffersInSpan(t,e),K.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(t,e){return this._bcurve.evaluateBuffersInSpan1(t,e),kt.createCapture(K.createFrom(this._bcurve.poleBuffer),j.createFrom(this._bcurve.poleBuffer1))}knotToPoint(t,e){return this._bcurve.evaluateBuffersAtKnot(t),K.createFrom(this._bcurve.poleBuffer,e)}knotToPointAndDerivative(t,e){return this._bcurve.evaluateBuffersAtKnot(t,1),e?(e.origin.setFrom(this._bcurve.poleBuffer),e.direction.setFrom(this._bcurve.poleBuffer1),e):kt.createCapture(K.createFrom(this._bcurve.poleBuffer),j.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(t,e){return this._bcurve.evaluateBuffersAtKnot(t,2),Ft.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],e)}isAlmostEqual(t){return t instanceof cr&&this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&ne.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData)}isInPlane(t){return ne.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return ne.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const i=void 0!==t.announceBezierCurve,s=this.initializeWorkBezier(),n=this.numSpan;let r;for(let o=0;o<n;o++){const n=this.getSaturatedBezierSpan3dOr3dH(o,!1,s);n&&(r=n.computeStrokeCountForOptions(e),i?t.announceBezierCurve(n,r,this,o,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)):t.announceIntervalForUniformStepStrokes(this,r,this._bcurve.knots.spanFractionToFraction(o,0),this._bcurve.knots.spanFractionToFraction(o,1)))}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),i=this.numSpan;let s=0;for(let n=0;n<i;n++){const i=this.getSaturatedBezierSpan3d(n,e);i&&(s+=i.computeStrokeCountForOptions(t))}return s}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.initializeWorkBezier(),s=this.numSpan,n=zt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=0;e<s;e++)if(this.getSaturatedBezierSpan3d(e,i)){const e=i.curveLength(),s=i.computeStrokeCountForOptions(t);n.addToCountAndLength(s,e)}$t.installStrokeCountMap(this,n,e)}emitStrokes(t,e){const i=this.initializeWorkBezier(),s=this.numSpan;for(let n=0;n<s;n++){const s=this.getSaturatedBezierSpan3d(n,i);s&&s.emitStrokes(t,e)}}get isClosable(){const t=this._bcurve.knots.wrappable;return t===w.None?w.None:this._bcurve.knots.testClosable(t)&&this._bcurve.testCloseablePolygon(t)?t:w.None}getSaturatedBezierSpan3dOr3dH(t,e,i){return e?this.getSaturatedBezierSpan3dH(t,i):this.getSaturatedBezierSpan3d(t,i)}getSaturatedBezierSpan3d(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof nr&&e.order===i||(e=nr.createOrder(i));const s=e;return s.loadSpanPoles(this._bcurve.packedData,t),s.saturateInPlace(this._bcurve.knots,t)?e:void 0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof rr&&e.order===i||(e=rr.createOrder(i));const s=e;return s.loadSpan3dPolesWithWeight(this._bcurve.packedData,t,1),s.saturateInPlace(this._bcurve.knots,t)?s:void 0}setWrappable(t){this._bcurve.knots.wrappable=t}dispatchToGeometryHandler(t){return t.handleBSplineCurve3d(this)}extendRange(t,e){const i=this._bcurve.packedData,s=i.length-2;if(e)for(let n=0;n<s;n+=3)t.extendTransformedXYZ(e,i[n],i[n+1],i[n+2]);else for(let e=0;e<s;e+=3)t.extendXYZ(i[e],i[e+1],i[e+2])}}class hr{areStronglyIndependentVectors(t,e,i=J.smallAngleRadians){return void 0!==t&&void 0!==e&&t.smallerUnorientedRadiansTo(e)>i}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(t=!1){if(this._origin&&this._vector0&&this._vector1)if(t){if(this._vector2){const t=pt.createRigidFromColumns(this._vector0,this._vector1,g.XYZ);if(t)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&t.scaleColumns(1,1,-1),ft.createOriginAndMatrix(this._origin,t);const e=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(e)}}else{const t=pt.createRigidFromColumns(this._vector0,this._vector1,g.XYZ);if(t)return ft.createOriginAndMatrix(this._origin,t);this._vector1=this._vector2=void 0}}applyDefaultUpVector(t){t&&this._vector0&&!this._vector1&&!t.isParallelTo(this._vector0)&&(this._vector1=t.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(t){return this._origin?this._origin.isAlmostEqual(t)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(t)):(this._origin=t.clone(),this.savedVectorCount())}announceVector(t){if(t.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=t.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(t,this._vector0,1e-5)?(this._vector1=t.clone(this._vector1),2):1;if(!this._vector2){const e=this._vector0.unitCrossProduct(this._vector1);return e&&!J.isSameCoordinate(0,e.dotProduct(t))?(this._vector2=t.clone(this._vector2),3):2}return 3}announce(t){if(!(this.savedVectorCount()>1))if(t instanceof K)this.announcePoint(t);else if(t instanceof j)this.announceVector(t);else if(Array.isArray(t))for(const e of t){if(this.savedVectorCount()>1)break;this.announce(e)}else if(t instanceof $t)if(t instanceof tr)this.announcePoint(t.startPoint()),this.announcePoint(t.endPoint());else if(t instanceof Pe){const e=t.fractionToPointAndDerivative(0);this.announcePoint(e.origin),this.announceVector(e.direction),this.announceVector(t.matrixRef.columnZCrossVector(e.direction))}else if(t instanceof ye){for(const e of t.points)if(this.announcePoint(e),this.savedVectorCount()>1)break}else if(t instanceof cr){const e=K.create();for(let i=0;this.savedVectorCount()<2&&t.getPolePoint3d(i,e)instanceof K;i++)this.announcePoint(e)}else if(t instanceof le){const e=K.create();for(let i=0;this.savedVectorCount()<2&&i<t.options.fitPoints.length;i++)e.setFrom(t.options.fitPoints[i]),this.announcePoint(e)}else{const e=t.fractionToFrenetFrame(0);void 0!==e&&(this.announcePoint(e.getOrigin()),this.announceVector(e.matrix.getColumn(0)),this.announceVector(e.matrix.getColumn(1)))}else if(t instanceof Me){if(t.children)for(const e of t.children)if(this.announce(e),this.savedVectorCount()>1)break}else if(t instanceof it){const e=K.create();for(let i=0;this.savedVectorCount()<2&&t.getPoint3dAtCheckedPointIndex(i,e)instanceof K;i++)this.announcePoint(e)}}static createRightHandedFrame(t,...e){const i=new hr;for(const s of e){i.announce(s),i.applyDefaultUpVector(t);const e=i.getValidatedFrame(!1);if(void 0!==e)return t&&e.matrix.dotColumnZ(t)<0&&e.matrix.scaleColumnsInPlace(1,-1,-1),e}for(const t of e)if(t instanceof Me){const e=t.children;if(e)for(const t of e)if(t instanceof $t){const e=t.fractionToFrenetFrame(0);if(e)return e}}}static createRightHandedLocalToWorld(...t){const e=new hr;for(const i of t){e.announce(i);const t=e.getValidatedFrame(!1);if(void 0!==t)return t}}static createFrameToDistantPoints(t){if(t.length>2){const e=t[0].clone(),i=j.create();ne.indexOfMostDistantPoint(t,t[0],i);const s=j.create();ne.indexOfPointWithMaxCrossProductMagnitude(t,e,i,s);const n=pt.createRigidFromColumns(i,s,g.XYZ);if(n)return ft.createRefs(e,n)}}static createFrameWithCCWPolygon(t){if(t.length>2){const e=fr.centroidAreaNormal(t);if(e)return e.toRigidZFrame()}}static createLocalToWorldTransformInRange(t,e=x.NonUniformRangeContainment,i=0,s=0,n=0,r=1){if(t.isNull)return ft.createIdentity();let o=1,a=1,c=1;return e===x.LongestRangeDirection?o=a=c=J.correctSmallMetricDistance(t.maxLength(),r):e===x.NonUniformRangeContainment&&(o=J.correctSmallMetricDistance(t.xLength(),r)*J.maxAbsDiff(i,0,1),a=J.correctSmallMetricDistance(t.yLength(),r)*J.maxAbsDiff(s,0,1),c=J.correctSmallMetricDistance(t.zLength(),r)*J.maxAbsDiff(n,0,1)),ft.createRefs(t.fractionToPoint(i,s,n),pt.createScale(o,a,c))}}class lr{constructor(){this.point=new K,this.a=0,this.v=new j,this.code=y.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=y.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new lr:t.invalidate(),t}copyContentsFrom(t){this.point.setFrom(t.point),this.a=t.a,this.v.setFrom(t.v),this.code=t.code,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return this.code!==y.Unknown}get isInsideOrOn(){return this.code===y.InsidePolygon||this.code===y.OnPolygonVertex||this.code===y.OnPolygonEdgeInterior||this.code===y.InsidePolygonProjectsToVertex||this.code===y.InsidePolygonProjectsToEdgeInterior}}class dr{constructor(t){this.xyz=t,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(t){const e=new dr(t);return t.length>=2&&(e.edge=kt.createStartEnd(t.front(),t.back())),e}setSortCoordinates(t){this.sortDelta=this.edge.direction.dotProduct(t.direction);const e=t.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=e,this.sortCoordinate1=e+this.sortDelta):(this.sortCoordinate0=e+this.sortDelta,this.sortCoordinate1=e)}containsSortLimits(t){return t.sortCoordinate0>=this.sortCoordinate1||t.sortCoordinate0<=this.sortCoordinate0||t.sortCoordinate1<=this.sortCoordinate0||t.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*t.sortDelta>0?1:-1}absorb(t){this.xyz.pushFromGrowableXYZArray(t.xyz),this.sortCoordinate0=t.sortCoordinate1}static sortFunction(t,e){return t.sortCoordinate0-e.sortCoordinate0>0?1:-1}front(t){return this.xyz.front(t)}back(t){return this.xyz.back(t)}}class ur{constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(t,e,i){let s,n=-1;i.setZero();for(const r of this.inputLoops)r.front(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e)),r.back(e),s=e.distanceSquared(t),s>n&&(n=s,i.setFromPoint3d(e))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const t=this.inputLoops[0].xyz.front(),e=K.create(),i=K.create();this.mostDistantPoint(t,e,i),this.mostDistantPoint(i,e,t);const s=kt.createStartEnd(t,i);s.direction.normalizeInPlace();for(const t of this.inputLoops)t.setSortCoordinates(s);this.inputLoops.sort(dr.sortFunction)}}sortAndMergeLoops(){this.sortInputs();const t=this.inputLoops,e=this.outputLoops,i=[];e.length=0;for(const s of t){for(s.isNotch=!1;i.length>0;){const t=i[i.length-1],n=t.containsSortLimits(s);if(0!==n){if(1===n){s.isNotch=!1;break}t.absorb(s),s.isNotch=!0;break}t.isNotch||e.push(t),i.pop()}i.push(s)}for(const t of i)t.isNotch||e.push(t)}}class fr{static sumTriangleAreas(t){let e=0;const i=t.length;if(Array.isArray(t)){if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=j.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductMagnitude(r),n.setFrom(r)}return.5*e}const s=j.create();for(let n=2;n<i;n++)t.crossProductIndexIndexIndex(0,n-1,n,s),e+=s.magnitude();return.5*e}static sumTriangleAreasPerpendicularToUpVector(t,e){let i=e.magnitude();i<J.smallMetricDistance&&(e=j.create(0,0,1),i=1);let s=0;const n=t.length;if(Array.isArray(t)){if(n>=3){const i=t[0],r=i.vectorTo(t[1]);let o=j.create();for(let a=2;a<n;a++)o=i.vectorTo(t[a],o),s+=r.tripleProduct(o,e),r.setFrom(o)}return.5*s/i}const r=j.create();for(let i=2;i<n;i++)t.crossProductIndexIndexIndex(0,i-1,i,r),s+=r.dotProduct(e);return.5*s/i}static sumTriangleAreasXY(t){let e=0;const i=t.length;if(i>=3){const s=t[0],n=s.vectorTo(t[1]);let r=j.create();for(let o=2;o<i;o++)r=s.vectorTo(t[o],r),e+=n.crossProductXY(r),n.setFrom(r)}return e*=.5,e}static areaNormalGo(t,e){e?e.setZero():e=new j;const i=t.length;if(3===i)t.crossProductIndexIndexIndex(0,1,2,e);else if(i>3)for(let s=2;s<i;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,e);return e.scaleInPlace(.5),e.isZero?void 0:e}static areaNormal(t,e){return e||(e=j.create()),fr.areaNormalGo(new te(t),e),e}static area(t){return fr.areaNormal(t).magnitude()}static areaXY(t){let e=0;if(t instanceof tt){if(t.length>2){const i=t.getXAtUncheckedPointIndex(0),s=t.getYAtUncheckedPointIndex(0);let n,r,o=t.getXAtUncheckedPointIndex(1)-i,a=t.getYAtUncheckedPointIndex(1)-s;for(let c=1;c+1<t.length;c++,o=n,a=r)n=t.getXAtUncheckedPointIndex(c)-i,r=t.getYAtUncheckedPointIndex(c)-s,e+=J.crossProductXYXY(o,a,n,r)}}else for(let i=1;i+1<t.length;i++)e+=t[0].crossProductToPointsXY(t[i],t[i+1]);return.5*e}static sumAreaXY(t){let e=0;for(const i of t)e+=this.areaXY(i);return e}static centroidAreaNormal(t){if(Array.isArray(t)){const e=new te(t);return this.centroidAreaNormal(e)}const e=t.length;if(3===e){const e=t.crossProductIndexIndexIndex(0,1,2),i=.5*e.magnitude(),s=t.getPoint3dAtCheckedPointIndex(0);t.accumulateScaledXYZ(1,1,s),t.accumulateScaledXYZ(2,1,s),s.scaleInPlace(1/3);const n=kt.createCapture(s,e);return n.tryNormalizeInPlaceWithAreaWeight(i)?n:void 0}if(e>=3){const i=j.createZero();for(let s=2;s<e;s++)t.accumulateCrossProductIndexIndexIndex(0,s-1,s,i);i.normalizeInPlace();const s=t.getPoint3dAtCheckedPointIndex(0),n=j.create(),r=j.create();t.vectorXYAndZIndex(s,1,n);let o=j.create();const a=j.createZero(),c=j.createZero();let h;for(let l=2;l<e;l++){t.vectorXYAndZIndex(s,l,r),o=n.crossProduct(r,o),h=i.dotProduct(o),c.addInPlace(o);const e=h/6;a.plus2Scaled(n,e,r,e,a),n.setFrom(r)}const l=.5*c.magnitude(),d=J.conditionalDivideFraction(1,l);if(void 0!==d){const t=kt.createCapture(s.plusScaled(a,d),c);return t.tryNormalizeInPlaceWithAreaWeight(l),t}}}static centroidAndAreaXY(t,e){let i=0;if(e.set(0,0),t.length<3)return;const s=t[0];let n=G.create(0,0),r=0;for(let e=1;e+1<t.length;e++){const i=s.vectorTo(t[e]),o=s.vectorTo(t[e+1]),a=i.crossProduct(o);n=n.plus(i.plus(o).scale(a)),r+=a}i=.5*r;const o=J.conditionalDivideFraction(1,6*i);if(void 0!==o)return e.setFrom(s.plusScaled(n,o)),i;e.setFrom(s)}static unitNormal(t,e){e.setZero();let i=t.length;return i>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(i-1))&&--i,3===i?(t.crossProductIndexIndexIndex(0,1,2,e),e.normalizeInPlace()):4===i?(t.vectorIndexIndex(0,2,fr._vector0),t.vectorIndexIndex(1,3,fr._vector1),fr._vector0.crossProduct(fr._vector1,e),e.normalizeInPlace()):(fr.areaNormalGo(t,e),e.normalizeInPlace())}static addSecondMomentAreaProducts(t,e,i){this.addSecondMomentTransformedProducts(fr._triangleMomentWeights,t,e,2,i)}static addSecondMomentVolumeProducts(t,e,i){this.addSecondMomentTransformedProducts(fr._tetrahedralMomentWeights,t,e,3,i)}static addSecondMomentTransformedProducts(t,e,i,s,n){const r=fr._normal;if(fr.unitNormal(e,r)){const o=fr._vector0,a=fr._vector1,c=fr._vector2,h=fr._matrixA,l=fr._matrixB,d=fr._matrixC,u=e.vectorXYAndZIndex(i,0,fr._vectorOrigin),f=e.length;let g=0;for(let p=2;p<f;p++)2===s?(e.vectorIndexIndex(0,p-1,o),e.vectorIndexIndex(0,p,a),g=r.tripleProduct(o,a),h.setOriginAndVectors(u,o,a,r),h.multiplyMatrixMatrix(t,l),l.multiplyMatrixMatrixTranspose(h,d),n.addScaledInPlace(d,g)):3===s&&(e.vectorXYAndZIndex(i,0,o),e.vectorXYAndZIndex(i,p-1,a),e.vectorXYAndZIndex(i,p,c),g=o.tripleProduct(a,c),h.setOriginAndVectors(i,o,a,c),h.multiplyMatrixMatrix(t,l),l.multiplyMatrixMatrixTranspose(h,d),n.addScaledInPlace(d,g))}}static testXYPolygonTurningDirections(t){let e=t.length,i=e-1;for(;i>1&&t[i].x===t[0].x&&t[i].y===t[0].y;)e=i--;if(e>2){let s=W.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y);const n=W.create(t[0].x-t[i].x,t[0].y-t[i].y),r=s.x*n.y-s.y*n.x;for(let i=1;i<e;i++)if(s=n.clone(),W.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y,n),(s.x*n.y-s.y*n.x)*r<=0)return 0;return r>0?1:-1}return 0}static isConvex(t){if(!(t instanceof tt))return this.isConvex(new te(t));let e=t.length;e>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(e-1))&&--e;const i=j.create();if(!this.unitNormal(t,i))return!1;let s=0,n=0;const r=this._vector0;let o=j.createStartEnd(t.getPoint3dAtUncheckedPointIndex(e-1),t.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let a=1;a<=e;a++){r.setFromVector3d(o),o=j.createStartEnd(t.getPoint3dAtUncheckedPointIndex(a-1),t.getPoint3dAtUncheckedPointIndex(a%e),o);const c=i.tripleProduct(r,o);c>=0?s+=c:n+=c}return Math.abs(n)<J.smallMetricDistanceSquared*s}static classifyPointInPolygon(t,e,i){const s=new Xt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i[n].x,i[n].y,i[o].x,i[o].y)){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i[o].x,i[o].y))return s.classifyCounts();return s.classifyCounts()}}static classifyPointInPolygonXY(t,e,i){const s=new Xt(t,e);let n=0;const r=i.length;let o,a=-1;for(n=0;n<r;n++)if(o=n+1,o>=r&&(o=0),s.tryStartEdge(i.getXAtUncheckedPointIndex(n),i.getYAtUncheckedPointIndex(n),i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o))){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!s.advance(i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o)))return s.classifyCounts();return s.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(t,e){if(t instanceof tt)return this.orientLoopsCCWForOutwardNormalInPlace([t],e);const i=[],s=j.create();let n=0;for(const r of t)if(this.unitNormal(r,s)){const t=s.dotProduct(e);i.push(t),t<=0&&r.reverseInPlace(),n++}else i.push(0);return n}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)Qe.pushPolygon(e,i);return Qe.sortAsArrayOfArrayOfPolygons(e)}static sortOuterAndHoleLoops(t,e){const i=hr.createRightHandedFrame(e,t),s=i?.inverse(),n=[];if(void 0!==s)for(const e of t){const t=new it(e.length);for(const i of e.points)t.push(s.multiplyPoint3d(i));n.push(t)}const r=fr.sortOuterAndHoleLoopsXY(n),o=[];if(void 0!==i)for(const t of r){const e=[];for(const s of t){const t=new it(s.length);for(const e of s.points)t.push(i.multiplyPoint3d(e));e.push(t)}o.push(e)}return o}static closestPointOnBoundary(t,e,i=J.smallMetricDistance,s){if(!(t instanceof tt))return this.closestPointOnBoundary(new te(t),e,i,s);const n=i*i;let r=t.length;for(;r>1&&!(t.distanceSquaredIndexIndex(0,r-1)>n);)--r;if(s=lr.create(s),0===r)return s;if(1===r)return t.getPoint3dAtUncheckedPointIndex(0,s.point),s.a=s.point.distance(e),s.v.setZero(),s.code=y.OnPolygonVertex,s.closestEdgeIndex=0,s.closestEdgeParam=0,s;let o=r-1,a=J.largeCoordinateResult;for(let i=0;i<r;++i){let c=i+1;c===r&&(c=0);const h=t.distanceSquaredIndexIndex(i,c);if(h<=n)continue;const l=t.distanceSquaredIndexXYAndZ(i,e),d=t.dotProductIndexIndexXYAndZ(i,c,e)/h;if(d<=0){const r=l;if(r<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=y.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;r<a&&t.dotProductIndexIndexXYAndZ(i,o,e)<=0&&(t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexIndex(i,o,c,s.v),s.code=y.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,a=r)}else if(d<=1){const r=l-d*d*h;if(r<=n){const e=l;if(d<=.5&&e<=n)return t.getPoint3dAtUncheckedPointIndex(i,s.point),s.a=Math.sqrt(e),s.v.setZero(),s.code=y.OnPolygonVertex,s.closestEdgeIndex=i,s.closestEdgeParam=0,s;const o=r+(1-d)*(1-d)*h;return d>.5&&o<=n?(t.getPoint3dAtUncheckedPointIndex(c,s.point),s.a=Math.sqrt(o),s.v.setZero(),s.code=y.OnPolygonVertex,s.closestEdgeIndex=c,s.closestEdgeParam=0,s):(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),s.v.setZero(),s.code=y.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,s)}r<a&&(t.interpolateIndexIndex(i,d,c,s.point),s.a=Math.sqrt(r),t.crossProductIndexIndexXYAndZ(i,c,e,s.v),s.code=y.OnPolygonEdgeInterior,s.closestEdgeIndex=i,s.closestEdgeParam=d,a=r)}o=i}return s}static intersectRay3d(t,e,i=J.smallMetricDistance,s){if(!(t instanceof tt))return this.intersectRay3d(new te(t),e,i,s);if(!this.unitNormal(t,this._normal))return lr.create(s);this._workPlane=mt.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const n=K.createZero(this._workXYZ),r=e.intersectionWithPlane(this._workPlane,n);if(void 0===r)return lr.create(s);if((s=this.closestPointOnBoundary(t,n,i,s)).isValid){s.point.setFrom(n),s.a=r;const t=s.v.dotProduct(this._normal);0===t||(y.OnPolygonVertex===s.code?s.code=t>0?y.InsidePolygonProjectsToVertex:y.OutsidePolygonProjectsToVertex:y.OnPolygonEdgeInterior===s.code&&(s.code=t>0?y.InsidePolygonProjectsToEdgeInterior:y.OutsidePolygonProjectsToEdgeInterior))}return s}static intersectSegment(t,e,i,s=J.smallMetricDistance,n){return this._workRay=kt.createStartEnd(e,i,this._workRay),this.intersectRay3d(t,this._workRay,s,n)}static computeEdgeDataXY(t,e,i,s,n=J.smallMetricDistance,r){const o=e%t.length,a=(o+1)%t.length;t.vectorIndexIndex(o,a,s).unitPerpendicularXY(s).negate(s);const c=t.getXAtUncheckedPointIndex(o)-i.x,h=t.getYAtUncheckedPointIndex(o)-i.y;let l=J.dotProductXYXY(c,h,s.x,s.y);const d=J.crossProductXYXY(c,h,s.x,s.y),u=J.distanceXYXY(t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getXAtUncheckedPointIndex(a),t.getYAtUncheckedPointIndex(a));let f=J.safeDivideFraction(d,u,0);return J.isSameCoordinate(0,l,n)&&(l=0),J.isSameCoordinate(0,f,n)?f=0:J.isSameCoordinate(1,f,n)&&(f=1),W.create(l,f,r)}static convexBarycentricCoordinatesOnEdge(t,e,i,s,n,r,o,a){const c=!i.isZero&&0===s.x&&J.isIn01(s.y),h=!r.isZero&&0===o.x&&J.isIn01(o.y);if(c&&h)return a.fill(0),a[n]=1,a;const l=t.length;if(c){a.fill(0);const t=e,i=n,r=s.y;return a[t]=1-r,a[i]=r,a}if(h){a.fill(0);const t=n,e=(n+1)%l,i=o.y;return a[t]=1-i,a[e]=i,a}}static convexBarycentricCoordinates(t,i,s=J.smallMetricDistance){if(Array.isArray(t))return this.convexBarycentricCoordinates(new te(t),i);let n=t.length;for(;n>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(n-1));)--n;if(n<3||!fr.unitNormal(t,this._normal))return;const r=this._workMatrix3d=pt.createRigidHeadsUp(this._normal,g.ZXY,this._workMatrix3d),o=new it(n);for(let e=0;e<n;++e)o.push(r.multiplyInverseXYZAsPoint3d(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e),this._workXYZ));const a=this._workXYZ=r.multiplyInverseXYZAsPoint3d(i.x,i.y,i.z,this._workXYZ);let c=n-1;const h=this._vector0,l=this._workXY0=this.computeEdgeDataXY(o,c,a,h,s,this._workXY0);if(l.x<0)return;const d=j.createFrom(h,this._vector1),u=this._workXY1=W.createFrom(l,this._workXY1),f=Array(t.length).fill(0),p=s>0?1/(s*s):J.largeCoordinateResult;let m=0;for(let t=0;t<n;++t){const i=j.createFrom(h,this._vector2),r=this._workXY2=t<n-1?this.computeEdgeDataXY(o,t,a,i,s,this._workXY2):W.createFrom(l,this._workXY2);if(r.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(o,c,d,u,t,i,r,f))return f;if(0===i.x&&0===i.y)continue;if(0===u.x||0===r.x)continue;const g=Math.abs(d.crossProductXY(i)),x=J.conditionalDivideCoordinate(g,u.x*r.x,p);if(void 0===x)return void e(!1);f[t]=x,m+=x,d.setFrom(i),u.setFrom(r),c=t}const x=J.conditionalDivideCoordinate(1,m);if(void 0!==x){for(let t=0;t<n;++t)f[t]*=x;return f}e(!1)}}fr._triangleMomentWeights=Et.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5),fr._tetrahedralMomentWeights=Et.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6),fr._vector0=j.create(),fr._vector1=j.create(),fr._vector2=j.create(),fr._vectorOrigin=j.create(),fr._normal=j.create(),fr._matrixA=Et.createIdentity(),fr._matrixB=Et.createIdentity(),fr._matrixC=Et.createIdentity();class gr{static splitConvexPolygonInsideOutsidePlane(t,e,i,s,n){const r=gr._xyz0Work,o=gr._xyz1Work,a=gr._xyz2Work,c=e.length;if(i.clear(),s.clear(),c>2){e.back(r),n.setNull();let h=t.altitude(r);n.extendX(h);for(let l=0;l<c;l++){e.getPoint3dAtUncheckedPointIndex(l,o);const c=t.altitude(o);n.extendX(c);let d=!1;if(h*c<0){const t=-h/(c-h);t>1-1e-8&&c>=0?d=!0:(r.interpolate(t,o,a),i.push(a),s.push(a))}(c>=0||d)&&i.push(o),(c<=0||d)&&s.push(o),r.setFromPoint3d(o),h=c}}}static clipConvexPolygonInPlace(t,e,i,s=!0,n=J.smallMetricDistance){i.clear();const r=s?1:-1,o=e.length;let a=0;const c=-n;let h=0;if(e.length>1){let s,l=e.length-1,d=r*e.evaluateUncheckedIndexPlaneAltitude(l,t);Math.abs(d)<n&&(d=0);for(let u=0;u<o;d=s,l=u++){if(s=r*e.evaluateUncheckedIndexPlaneAltitude(u,t),Math.abs(s)<n&&(s=0),s<0&&a++,d*s<0){const t=-d/(s-d);t>1-1e-8&&s>=0||(i.pushInterpolatedFromGrowableXYZArray(e,l,t,u),s>0&&h++)}s>=c&&(i.pushFromGrowableXYZArray(e,u),d<-c&&h++),l=u,d=s}}return i.length<=2?e.clear():a>0&&(e.clear(),e.pushFromGrowableXYZArray(i)),i.clear(),h}static gatherCutLoopsFromPlaneClip(t,e,i=3,s=J.smallMetricDistance){const n=new ur;let r=0;const o=e.length;for(;r<o;r++){const i=e.evaluateUncheckedIndexPlaneAltitude(r,t);if(Math.abs(i)<=s)break}if(r===o)return n;let a=r;for(;a<o;){const c=new it;c.pushFromGrowableXYZArray(e,a);let h=a+1;for(;h<o;){c.pushFromGrowableXYZArray(e,h);const i=e.evaluateUncheckedIndexPlaneAltitude(h,t);if(Math.abs(i)<=s)break;h++}if(h===o)for(let t=0;t<=r;t++)c.pushFromGrowableXYZArray(e,t);c.length>=i&&n.inputLoops.push(dr.createCaptureWithReturnEdge(c)),a=h}return n}static reorderCutLoops(t){if(1!==t.inputLoops.length){if(2===t.inputLoops.length){if(t.inputLoops[0].edge.direction.dotProduct(t.inputLoops[1].edge.direction)>0)return t.outputLoops.push(t.inputLoops[0]),void t.outputLoops.push(t.inputLoops[1]);const e=t.inputLoops[1].xyz;return t.inputLoops[0].xyz.pushFromGrowableXYZArray(e),void t.outputLoops.push(t.inputLoops[0])}t.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const i=new it,s=bt.create();return s.set(0,0,-1,t.high.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,0,1,-t.low.z),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,-1,0,t.high.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(0,1,0,-t.low.y),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(-1,0,0,t.high.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length&&(s.set(1,0,0,-t.low.x),this.clipConvexPolygonInPlace(s,e,i,!0),0!==e.length)))))?e:void 0}}gr._xyz0Work=K.create(),gr._xyz1Work=K.create(),gr._xyz2Work=K.create(),K.create();class pr extends Q{constructor(t,e,i,s){super(),this._invisible=i,this._interior=s,this._inwardNormal=t,this._distanceFromOrigin=e}isAlmostEqual(t){return J.isSameCoordinate(this._distanceFromOrigin,t._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(t._inwardNormal)&&this._interior===t._interior&&this._invisible===t._invisible}clone(){return new pr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const t=new pr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return t.negateInPlace(),t}static createPlane(t,e=!1,i=!1,s){const n=t.getNormalRef().dotProduct(t.getOriginRef());return s?(s._invisible=e,s._interior=i,s._inwardNormal=t.getNormalRef().clone(),s._distanceFromOrigin=n,s):new pr(t.getNormalRef().clone(),n,e,i)}static createNormalAndDistance(t,e,i=!1,s=!1,n){const r=t.normalize();if(r)return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=e),new pr(r,e,i,s)}static createNormalAndPoint(t,e,i=!1,s=!1,n){const r=t.normalize();if(r){const t=r.dotProduct(e);return n&&(n._invisible=i,n._interior=s,n._inwardNormal=r,n._distanceFromOrigin=t),new pr(r,t,i,s)}}static createOriginAndVectors(t,e,i,s=!1,n=!1,r){const o=i.crossProduct(e);return this.createNormalAndPoint(o,t,s,n,r)}static createNormalAndPointXYZXYZ(t,e,i,s,n,r,o=!1,a=!1,c){const h=J.hypotenuseXYZ(t,e,i),l=J.conditionalDivideFraction(1,h);if(void 0!==l){if(c)return c._inwardNormal.set(t*l,e*l,i*l),c._distanceFromOrigin=c._inwardNormal.dotProductXYZ(s,n,r),c._invisible=o,c._interior=a,c;const h=j.create(t*l,e*l,i*l);return new pr(h,h.dotProductXYZ(s,n,r),o,a)}}toJSON(){const t={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(t.interior=!0),this.invisible&&(t.invisible=!0),t}static fromJSON(t,e){return t&&t.normal&&void 0!==t.dist&&Number.isFinite(t.dist)?pr.createNormalAndDistance(j.fromJSON(t.normal),t.dist,!!t.invisible,!!t.interior):pr.createNormalAndDistance(j.unitZ(),0,!1,!1,e)}setFlags(t,e){this._invisible=t,this._interior=e}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(t,e,i,s,n){const r=j.createFrom(e.minus(t));let o=i.crossProduct(r).normalize();if(o){if(void 0!==s&&!s.isAlmostZero){const t=j.createRotateVectorAroundVector(o,r,s);t&&(o=t.clone())}return o.negate(o),pr.createNormalAndPoint(o,t,!1,!1,n)}}static createEdgeXY(t,e,i){const s=j.create(t.y-e.y,e.x-t.x);if(s.normalizeInPlace())return pr.createNormalAndPoint(s,t,!1,!1,i)}getPlane3d(){const t=this._distanceFromOrigin;return mt.create(K.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),this._inwardNormal)}getPlane4d(){return bt.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(t){const e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i=0===e?1:1/e;this._inwardNormal.x=i*t.x,this._inwardNormal.y=i*t.y,this._inwardNormal.z=i*t.z,this._distanceFromOrigin=-i*t.w}weightedAltitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-t.w*this._distanceFromOrigin}altitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocityXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z}dotProductPlaneNormalPoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}isPointOnOrInside(t,e=J.smallMetricDistance){let i=this.altitude(t);return e&&(i+=e),i>=0}isPointInside(t,e=J.smallMetricDistance){let i=this.altitude(t);return e&&(i-=e),i>0}isPointOn(t,e=J.smallMetricDistance){return Math.abs(this.altitude(t))<=e}appendIntersectionRadians(t,e){const i=t.toVectors(),s=this.altitude(t.center),n=this.velocity(i.vector0),r=this.velocity(i.vector90);At.appendImplicitLineUnitCircleIntersections(s,n,r,void 0,void 0,e)}announceClippedArcIntervals(t,e){const i=pr._clipArcFractionArray;return i.clear(),this.appendIntersectionRadians(t,i),t.sweep.radiansArrayToPositivePeriodicFractions(i),ys.selectIntervals01(t,i,this,e)}getBoundedSegmentSimpleIntersection(t,e){const i=this.altitude(t),s=this.altitude(e);if(!(i*s>0||0===i&&0===s))return-i/(s-i)}transformInPlace(t){const e=this.getPlane3d(),i=t.matrix,s=t.multiplyPoint3d(e.getOriginRef()),n=i.multiplyInverseTranspose(e.getNormalRef());if(!n)return!1;e.set(s,n);const r=e.getNormalRef().normalize();return!!r&&(this._inwardNormal=r,this._distanceFromOrigin=this._inwardNormal.dotProduct(e.getOriginRef()),!0)}setInvisible(t){this._invisible=t}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(t){this._distanceFromOrigin+=t}clipConvexPolygonInPlace(t,e,i=!0,s=J.smallMetricDistance){return gr.clipConvexPolygonInPlace(this,t,e,i,s)}multiplyPlaneByMatrix4d(t,e=!0,i=!0){const s=this.getPlane4d();if(e){const e=t.createInverse();return!!e&&this.multiplyPlaneByMatrix4d(e,!1,i)}return i?t.multiplyTransposePoint4d(s,s):t.multiplyPoint4d(s,s),this.setPlane4d(s),!0}announceClippedSegmentIntervals(t,e,i,s,n){if(e<t)return!1;const r=-this.altitude(i),o=-this.altitude(s)-r,a=J.conditionalDivideFraction(-r,o);return void 0===a?r<=0&&(n&&n(t,e),!0):(o>0?a<e&&(e=a):a>t&&(t=a),!(e<t||(n&&n(t,e),0)))}getFrame(){const t=this._distanceFromOrigin,e=K.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),i=pt.createRigidHeadsUp(this._inwardNormal,g.ZXY);return ft.createOriginAndMatrix(e,i)}intersectRange(t,e=!1){if(t.isNull)return;const i=t.corners(),s=this.getFrame();s.multiplyInversePoint3dArrayInPlace(i);const n=lt.createArray(i);if(n.low.z*n.high.z>0)return;const r=new it;return r.pushXYZ(n.low.x,n.low.y,0),r.pushXYZ(n.high.x,n.low.y,0),r.pushXYZ(n.high.x,n.high.y,0),r.pushXYZ(n.low.x,n.high.y,0),r.multiplyTransformInPlace(s),gr.intersectRangeConvexPolygonInPlace(t,r),0!==r.length?(e&&r.pushWrap(1),r):void 0}appendPolygonClip(t,e,i,s){const n=dt.createNull(),r=s.grabFromCache(),o=s.grabFromCache();gr.splitConvexPolygonInsideOutsidePlane(this,t,r,o,n),ys.captureOrDrop(r,3,e,s),ys.captureOrDrop(o,3,i,s)}projectPointToPlane(t,e){const i=-this.altitude(t);return t.plusXYZ(i*this._inwardNormal.x,i*this._inwardNormal.y,i*this._inwardNormal.z,e)}}pr._clipArcFractionArray=new Pt;const mr={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class xr{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.l=i}clone(t,e,i){return new xr(t??this.h,e??this.s,i??this.l)}toColorDef(t=0){return Ir.fromHSL(this.h,this.s,this.l,t)}static fromColorDef(t){return t.toHSL()}}var yr;!function(t){t[t.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",t[t.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",t[t.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(yr||(yr={}));class _r{constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.v=i}clone(t,e,i){return new _r(t??this.h,e??this.s,i??this.v)}toColorDef(t=0){return Ir.fromHSV(this,t)}static fromColorDef(t){return t.toHSV()}adjusted(t,e){let i;if(t){if(i=e*yr.HSV_VALUE_WEIGHT,this.v>=i)return new _r(this.h,this.s,this.v-i);i-=this.v;const t=Math.min(this.s+i,100);return new _r(this.h,t,0)}if(i=e*yr.HSV_SATURATION_WEIGHT,this.s>=i)return new _r(this.h,this.s-i,this.v);i-=this.s;const s=Math.min(this.v+i,100);return new _r(this.h,0,s)}}const vr=new Uint8Array(4),Pr=new Uint32Array(vr.buffer);class Ir{constructor(t){Pr[0]=t,this._tbgr=Pr[0]}static create(t){return this.fromTbgr(this.computeTbgr(t))}static computeTbgr(t){switch(typeof t){case"number":return t;case"string":return this.computeTbgrFromString(t);default:return 0}}toJSON(){return this._tbgr}static fromJSON(t){return this.create(t)}static from(t,e,i,s){return this.fromTbgr(this.computeTbgrFromComponents(t,e,i,s))}static computeTbgrFromComponents(t,e,i,s){return vr[0]=t,vr[1]=e,vr[2]=i,vr[3]=s||0,Pr[0]}static fromTbgr(t){switch(t){case mr.black:return this.black;case mr.white:return this.white;case mr.red:return this.red;case mr.green:return this.green;case mr.blue:return this.blue;default:return new Ir(t)}}static fromAbgr(t){return this.fromTbgr(this.getAbgr(t))}static fromString(t){return this.fromTbgr(this.computeTbgrFromString(t))}static isValidColor(t){return"number"==typeof t?t>=0&&t<=4294967295&&Math.floor(t)===t:void 0!==this.tryComputeTbgrFromString(t)}static computeTbgrFromString(t){return this.tryComputeTbgrFromString(t)??0}static tryComputeTbgrFromString(t){if("string"!=typeof t)return;t=t.toLowerCase();let e=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t);if(e){let t;const i=e[1],s=e[2],n=t=>"%"===t[t.length-1],r=t=>{const e=parseFloat(t);return 255*J.clamp(n(t)?e/100:e,0,1)},o=t=>{const e=n(t)?parseFloat(t)/100*255:parseInt(t,10);return J.clamp(e,0,255)};switch(i){case"rgb":case"rgba":if(t=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(s),t)return this.computeTbgrFromComponents(o(t[1]),o(t[2]),o(t[3]),"string"==typeof t[5]?255-r(t[5]):0);break;case"hsl":case"hsla":if(t=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s),t){const e=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,s=parseInt(t[3],10)/100,n="string"==typeof t[5]?255-r(t[5]):0;return this.computeTbgrFromHSL(e,i,s,n)}}}else if(e=/^\#([a-f0-9]+)$/.exec(t)){const t=e[1],i=t.length;if(3===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(0),16),parseInt(t.charAt(1)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(2),16),0);if(6===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(3),16),parseInt(t.charAt(4)+t.charAt(5),16),0)}if(t&&t.length>0)for(const[e,i]of Object.entries(mr))if(e.toLowerCase()===t)return i}get colors(){return Ir.getColors(this._tbgr)}static getColors(t){return Pr[0]=t,{b:vr[2],g:vr[1],r:vr[0],t:vr[3]}}get tbgr(){return this._tbgr}getAbgr(){return Ir.getAbgr(this._tbgr)}static getAbgr(t){return Pr[0]=t,vr[3]=255-vr[3],Pr[0]}getRgb(){return Ir.getRgb(this._tbgr)}static getRgb(t){return Pr[0]=t,(vr[0]<<16)+(vr[1]<<8)+vr[2]}withAlpha(t){const e=Ir.withAlpha(this._tbgr,t);return e===this._tbgr?this:Ir.fromTbgr(e)}static withAlpha(t,e){return Pr[0]=t,vr[3]=255-(0|e),Pr[0]}getAlpha(){return Ir.getAlpha(this._tbgr)}static getAlpha(t){return Pr[0]=t,255-vr[3]}get isOpaque(){return Ir.isOpaque(this._tbgr)}static isOpaque(t){return 255===this.getAlpha(t)}getTransparency(){return Ir.getTransparency(this._tbgr)}static getTransparency(t){return Pr[0]=t,vr[3]}withTransparency(t){const e=Ir.withTransparency(this._tbgr,t);return e===this._tbgr?this:Ir.fromTbgr(e)}static withTransparency(t,e){return this.withAlpha(t,255-e)}get name(){return Ir.getName(this.tbgr)}static getName(t){for(const[e,i]of Object.entries(mr))if(i===t)return e}toHexString(){return Ir.toHexString(this.tbgr)}static toHexString(t){return`#${`000000${this.getRgb(t).toString(16)}`.slice(-6)}`}static getColorsString(t){const e=this.getColors(t);return`${e.r},${e.g},${e.b}`}toRgbString(){return Ir.toRgbString(this.tbgr)}static toRgbString(t){return`rgb(${this.getColorsString(t)})`}toRgbaString(){return Ir.toRgbaString(this.tbgr)}static toRgbaString(t){return`rgba(${this.getColorsString(t)},${this.getAlpha(t)/255})`}lerp(t,e){return Ir.fromTbgr(Ir.lerp(this.tbgr,t.tbgr,e))}static lerp(t,e,i){const s=this.getColors(t),n=this.getColors(e);return s.r+=(n.r-s.r)*i,s.g+=(n.g-s.g)*i,s.b+=(n.b-s.b)*i,this.computeTbgrFromComponents(s.r,s.g,s.b,s.t)}inverse(){return Ir.fromTbgr(Ir.inverse(this.tbgr))}static inverse(t){const e=this.getColors(t);return this.computeTbgrFromComponents(255-e.r,255-e.g,255-e.b)}static fromHSL(t,e,i,s=0){return this.fromTbgr(this.computeTbgrFromHSL(t,e,i,s))}static computeTbgrFromHSL(t,e,i,s=0){const n=(t,e,i)=>Math.round(255*((t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t))(t,e,i));if(t=(t%1+1)%1,e=J.clamp(e,0,1),i=J.clamp(i,0,1),0===e)return i*=255,this.computeTbgrFromComponents(i,i,i,s);const r=i<=.5?i*(1+e):i+e-i*e,o=2*i-r;return this.computeTbgrFromComponents(n(o,r,t+1/3),n(o,r,t),n(o,r,t-1/3),s)}toHSL(){const t=this.colors;t.r/=255,t.g/=255,t.b/=255;const e=Math.max(t.r,t.g,t.b),i=Math.min(t.r,t.g,t.b);let s,n=0;const r=(i+e)/2;if(i===e)s=0;else{const o=e-i;switch(s=r<=.5?o/(e+i):o/(2-e-i),e){case t.r:n=(t.g-t.b)/o+(t.g<t.b?6:0);break;case t.g:n=(t.b-t.r)/o+2;break;case t.b:n=(t.r-t.g)/o+4}n/=6}return new xr(n,s,r)}toHSV(){const{r:t,g:e,b:i}=this.colors;let s=t<e?t:e;i<s&&(s=i);let n=t>e?t:e;i>n&&(n=i);const r=Math.floor(n/255*100+.5),o=n-s,a=0!==n?Math.floor(o/n*100+.5):0;let c=0;if(a){const s=(n-t)/o,r=(n-e)/o,a=(n-i)/o;let h;h=t===n?a-r:e===n?2+s-a:4+r-s,h*=60,h<0&&(h+=360),c=Math.floor(h+.5),c>=360&&(c=0)}else c=0;return new _r(c,a,r)}static fromHSV(t,e=0){if(!t.s||-1===t.h){const e=255&Math.floor(255*t.v/100+.5+3e-14);return Ir.from(e,e,e,0)}let i=t.h,s=t.s,n=t.v;360===i&&(i=0),i/=60;const r=Math.floor(i),o=i-r;n/=100,s/=100;const a=255&Math.floor(n*(1-s)*255+.5),c=255&Math.floor(n*(1-s*o)*255+.5),h=255&Math.floor(n*(1-s*(1-o))*255+.5),l=255&Math.floor(255*n+.5);let d=0,u=0,f=0;switch(r){case 0:d=l,f=h,u=a;break;case 1:d=c,f=l,u=a;break;case 2:d=a,f=l,u=h;break;case 3:d=a,f=c,u=l;break;case 4:d=h,f=a,u=l;break;case 5:d=l,f=a,u=c}return Ir.from(d,f,u,e)}visibilityCheck(t){const e=this.colors,i=t.colors;return.3*Math.abs(e.r-i.r)+.59*Math.abs(e.g-i.g)+.11*Math.abs(e.b-i.b)}adjustedForContrast(t,e){const i=this.visibilityCheck(t);if(yr.VISIBILITY_GOAL<=i)return void 0!==e?this.withAlpha(e):this;const s=Math.floor((yr.VISIBILITY_GOAL-i)/255*100);let n=this.toHSV(),r=n.clone();n=n.adjusted(!0,s),r=r.adjusted(!1,s),void 0===e&&(e=this.getAlpha());const o=Ir.fromHSV(n).withAlpha(e),a=Ir.fromHSV(r).withAlpha(e);return a.getRgb()===t.getRgb()?o:o.getRgb()===t.getRgb()||a.visibilityCheck(t)>=o.visibilityCheck(t)?a:o}equals(t){return this._tbgr===t._tbgr}}Ir.black=new Ir(mr.black),Ir.white=new Ir(mr.white),Ir.red=new Ir(mr.red),Ir.green=new Ir(mr.green),Ir.blue=new Ir(mr.blue);class Ar{constructor(t,e,i){this.r=t,this.g=e,this.b=i,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(t){const e=t.colors;return new Ar(e.r,e.g,e.b)}toColorDef(t=0){return Ir.from(this.r,this.g,this.b,t)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(t){let e=255,i=255,s=255;return void 0!==t&&("number"==typeof t.r&&(e=t.r),"number"==typeof t.g&&(i=t.g),"number"==typeof t.b&&(s=t.b)),new Ar(e,i,s)}equals(t){return this.r===t.r&&this.g===t.g&&this.b===t.b}compareTo(t){return i(this.r,t.r)||i(this.g,t.g)||i(this.b,t.b)}toHexString(){return this.toColorDef().toHexString()}}class Sr{constructor(t,e){this.value=t,this.index=e}}class wr{constructor(t,e=Number.MAX_SAFE_INTEGER,i=Hi){this._array=[],this._compareValues=t,this._clone=i,this._maximumSize=e}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(t,e){const i=this.lowerBound(t);if(i.equal)return this._array[i.index].index;if(this.isFull)return-1;const s=new Sr(this._clone(t),this._array.length);return void 0!==e&&e(s.value),this._array.splice(i.index,0,s),s.index}indexOf(t){const e=this.lowerBound(t);return e.equal?this._array[e.index].index:-1}lowerBound(t){return Ki(t,this._array,((t,e)=>this._compareValues(t,e.value)))}toArray(){const t=[];for(const e of this._array)t[e.index]=e.value;return t}}var Cr,Tr,kr,Fr,Mr,br;!function(t){t[t.Never=0]="Never",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Blanking=3]="Blanking"}(Cr||(Cr={})),function(t){t[t.None=0]="None",t[t.Solid=1]="Solid",t[t.Outline=2]="Outline"}(Tr||(Tr={})),function(t){t[t.Primary=0]="Primary",t[t.Construction=1]="Construction",t[t.Dimension=2]="Dimension",t[t.Pattern=3]="Pattern"}(kr||(kr={}));class Er{constructor(t=l.invalid,e=l.invalid,i=kr.Primary){this.elementId=t,this.subCategoryId=e,this.geometryClass=i}get isDefined(){return!l.isInvalid(this.elementId)||!l.isInvalid(this.subCategoryId)||this.geometryClass!==kr.Primary}get isUndefined(){return!this.isDefined}equals(t){return 0===this.compare(t)}compare(t){if(this===t)return 0;let e=i(this.geometryClass,t.geometryClass);return 0===e&&(e=n(this.elementId,t.elementId),0===e&&(e=n(this.subCategoryId,t.subCategoryId))),e}}!function(t){t.create=function(){return{modelId:l.invalid,elementId:l.invalid,subCategoryId:l.invalid,geometryClass:kr.Primary}},t.isDefined=function(t){return!l.isInvalid(t.modelId)||!l.isInvalid(t.elementId)||!l.isInvalid(t.subCategoryId)||t.geometryClass!==kr.Primary},t.unpack=function(t,e,i){return e.modelId=i??l.fromUint32PairObject(t.modelId),e.elementId=l.fromUint32PairObject(t.elementId),e.subCategoryId=l.fromUint32PairObject(t.subCategoryId),e.geometryClass=t.geometryClass,e}}(Fr||(Fr={})),function(t){function e(){const t={upper:0,lower:0};return{modelId:{...t},elementId:{...t},subCategoryId:{...t},geometryClass:kr.Primary,animationNodeId:0}}t.create=e,t.createWithIndex=function(){const t=e();return t.index=0,t}}(Mr||(Mr={})),function(t){t[t.Primary=0]="Primary",t[t.VolumeClassifier=1]="VolumeClassifier",t[t.PlanarClassifier=2]="PlanarClassifier"}(br||(br={}));class Xr extends wr{constructor(t,e=l.invalid,i=br.Primary){super(((t,e)=>t.compare(e)),t),this.modelId=e,this.type=i}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return br.VolumeClassifier===this.type}get isPlanarClassifier(){return br.PlanarClassifier===this.type}findFeature(t){for(const e of this._array)if(e.index===t)return e.value}insertWithIndex(t,i){const s=this.lowerBound(t);e(!s.equal),e(!this.isFull);const n=new Sr(t,i);this._array.splice(s.index,0,n)}getArray(){return this._array}}const zr=Mr.create();function Rr(t,i,s){let n;e(s>0);const r=Mr.createWithIndex();for(const o of t.iterable(r)){const r=i(o);if(e(r<=s),0!==r){if(!n){const e=t.numFeatures;n=s<256?new Uint8Array(e):s<65536?new Uint16Array(e):new Uint32Array(e)}n[o.index]=r}}return n}class Dr{get byteLength(){return this._data.byteLength}constructor(t,i,s,n,r){switch(this._data=t,this.batchModelId=i,this.batchModelIdPair=l.getUint32Pair(i),this.numFeatures=s,this.type=n,this.animationNodeIds=r,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=Fr.isDefined(this.getFeature(0,Fr.create()));break;default:this.anyDefined=!0}e(this._data.length>=this._subCategoriesOffset),e(void 0===this.animationNodeIds||this.animationNodeIds.length===this.numFeatures)}static pack(t){const i=new Map;for(const e of t.getArray())void 0===i.get(e.value.subCategoryId.toString())&&i.set(e.value.subCategoryId,i.size);const s=3*t.length,n=s+2*i.size,r=new Uint32Array(n);for(const s of t.getArray()){const t=s.value,n=3*s.index;let o=i.get(t.subCategoryId);e(void 0!==o),o|=t.geometryClass<<24,r[n+0]=l.getLowerUint32(t.elementId),r[n+1]=l.getUpperUint32(t.elementId),r[n+2]=o}return i.forEach(((t,e,i)=>{const n=s+2*t;r[n+0]=l.getLowerUint32(e),r[n+1]=l.getUpperUint32(e)})),new Dr(r,t.modelId,t.length,t.type)}getFeature(t,e){const i=this.getPackedFeature(t,zr);return Fr.unpack(i,e,this.batchModelId)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,i){i=i??{lower:0,upper:0},e(t<this.numFeatures);const s=3*t;return i.lower=this._data[s],i.upper=this._data[s+1],i}getSubCategoryIdPair(t){const e=3*t;let i=this._data[e+2];return i=(16777215&i)>>>0,i=2*i+this._subCategoriesOffset,{lower:this._data[i],upper:this._data[i+1]}}getAnimationNodeId(t){return void 0!==this.animationNodeIds&&t<this.numFeatures?this.animationNodeIds[t]:0}getPackedFeature(t,i){e(t<this.numFeatures);const s=3*t;i.elementId.lower=this._data[s],i.elementId.upper=this._data[s+1];const n=this._data[s+2];i.geometryClass=n>>>24&255;let r=(16777215&n)>>>0;return r=2*r+this._subCategoriesOffset,i.subCategoryId.lower=this._data[r],i.subCategoryId.upper=this._data[r+1],i.animationNodeId=this.getAnimationNodeId(t),i.modelId.lower=this.batchModelIdPair.lower,i.modelId.upper=this.batchModelIdPair.upper,i}findElementId(t){return t>=this.numFeatures?void 0:this.readId(3*t)}get isUniform(){return 1===this.numFeatures}getUniform(t){return this.isUniform?this.getFeature(0,t):void 0}get isVolumeClassifier(){return br.VolumeClassifier===this.type}get isPlanarClassifier(){return br.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const t=new Xr(this.numFeatures,this.batchModelId),e=Fr.create();for(let i=0;i<this.numFeatures;i++)this.getFeature(i,e),t.insertWithIndex(new Er(e.elementId,e.subCategoryId,e.geometryClass),i);return t}populateAnimationNodeIds(t,i){e(void 0===this.animationNodeIds),this.animationNodeIds=Rr(this,t,i)}*iterator(t){for(let e=0;e<this.numFeatures;e++)this.getPackedFeature(e,t),t.index=e,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(t){return l.fromUint32Pair(this._data[t],this._data[t+1])}}const Nr={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class Yr{constructor(t){this._data=t,e(this._data.length%3==0)}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(t){return this._data[3*t]}getEntry(t,e){if(t>=this.length)return e.idLower=e.idUpper=0,e.lastFeatureIndex=Number.MAX_SAFE_INTEGER,e;const i=3*t;return e.lastFeatureIndex=this._data[i+0],e.idLower=this._data[i+1],e.idUpper=this._data[i+2],e}getModelIdPair(t,e){e?e.lower=e.upper=0:e={lower:0,upper:0};let i=0;const s=this.length;let n=s;for(;n>0;){const e=Math.floor(n/2),s=i+e;t>this.getLastFeatureIndex(s)?(i=s+1,n-=e+1):n=e}return i<s&&(e.lower=this._data[3*i+1],e.upper=this._data[3*i+2]),e}}class Or{constructor(t,e){this._features=t,this._models=e}static create(t,e,i,s,n){const r=3*i+2*n,o=t.subarray(0,r),a=new Dr(o,e,i,s),c=t.subarray(r),h=new Yr(c);return new Or(a,h)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(t){this._features.animationNodeIds=t}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(t,e){return this._features.getPackedFeature(t,e),this._models.getModelIdPair(t,e.modelId),e}getFeature(t,e){const i=this.getPackedFeature(t,zr);return Fr.unpack(i,e)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,e){return this._features.getElementIdPair(t,e)}findElementId(t){return this._features.findElementId(t)}*iterator(t){let e=0;const i=this._models.getEntry(e,Nr);for(let s=0;s<this.numFeatures;s++)s>i.lastFeatureIndex&&this._models.getEntry(++e,i),this._features.getPackedFeature(s,t),t.modelId.lower=i.idLower,t.modelId.upper=i.idUpper,t.index=s,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}getAnimationNodeId(t){return this._features.getAnimationNodeId(t)}populateAnimationNodeIds(t,e){this._features.animationNodeIds=Rr(this,t,e)}}function Br(t,e){if(t.clear(),"string"==typeof e)t.addId(e);else for(const i of e)t.addId(i)}class Vr{static fromJSON(t){return void 0!==t&&(void 0!==t.rgb||void 0!==t.weight||void 0!==t.transparency||void 0!==t.linePixels||t.ignoresMaterial||t.nonLocatable||t.emphasized)?new Vr(t):this.defaults}static fromRgb(t){return this.fromJSON({rgb:Ar.fromColorDef(t)})}static fromRgba(t,e=!1){return this.fromJSON({rgb:Ar.fromColorDef(t),transparency:t.colors.t/255,viewDependentTransparency:!!e||void 0})}static fromTransparency(t,e=!1){return this.fromJSON({transparency:t,viewDependentTransparency:!!e||void 0})}static fromSubCategoryOverride(t){const e=void 0!==t.color?Ar.fromColorDef(t.color):void 0,i=t.transparency,s=t.weight,n=!(void 0===t.material||!l.isValid(t.material))||void 0;return this.fromJSON({rgb:e,transparency:i,weight:s,ignoresMaterial:n,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(Vr.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){return void 0!==this.transparency&&this.transparency>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(t){return this===t||this.rgbIsEqual(t.rgb)&&this.weight===t.weight&&this.transparencyIsEqual(t.transparency)&&this.linePixels===t.linePixels&&this.ignoresMaterial===t.ignoresMaterial&&this.nonLocatable===t.nonLocatable&&this.emphasized===t.emphasized&&this.viewDependentTransparency===t.viewDependentTransparency}toJSON(){const t={};return this.rgb&&(t.rgb=this.rgb.toJSON()),void 0!==this.weight&&(t.weight=this.weight),void 0!==this.transparency&&(t.transparency=this.transparency,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),void 0!==this.linePixels&&(t.linePixels=this.linePixels),!0===this.ignoresMaterial&&(t.ignoresMaterial=!0),!0===this.nonLocatable&&(t.nonLocatable=!0),!0===this.emphasized&&(t.emphasized=!0),t}cloneProps(t){return{...this.toJSON(),...t}}clone(t){return Vr.fromJSON(this.cloneProps(t))}extendAppearance(t){if(!this.overridesSymbology)return t;const e=t.toJSON();return void 0===e.rgb&&(e.rgb=this.rgb),void 0===e.transparency&&(e.transparency=this.transparency),void 0===e.linePixels&&(e.linePixels=this.linePixels),void 0===e.weight&&(e.weight=this.weight),void 0===e.ignoresMaterial&&this.ignoresMaterial&&(e.ignoresMaterial=!0),void 0===e.nonLocatable&&this.nonLocatable&&(e.nonLocatable=!0),void 0===e.emphasized&&this.emphasized&&(e.emphasized=!0),void 0!==e.transparency&&this.viewDependentTransparency&&(e.viewDependentTransparency=!0),Vr.fromJSON(e)}constructor(t){if(this.rgb=void 0!==t.rgb?Ar.fromJSON(t.rgb):void 0,this.weight=t.weight,this.transparency=t.transparency,this.linePixels=t.linePixels,this.ignoresMaterial=t.ignoresMaterial,this.nonLocatable=t.nonLocatable,this.emphasized=t.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),void 0!==this.transparency){t.viewDependentTransparency&&(this.viewDependentTransparency=!0),this.transparency=Math.max(0,Math.min(this.transparency,1));const e=1e-4;1-this.transparency<e?this.transparency=1:this.transparency<e&&(this.transparency=0)}}rgbIsEqual(t){return void 0===this.rgb?void 0===t:void 0!==t&&this.rgb.equals(t)}transparencyIsEqual(t){return void 0===this.transparency?void 0===t:void 0!==t&&Math.floor(255*this.transparency)===Math.floor(255*t)}}Vr.defaults=new Vr({});const Lr={elementId:{lower:0,upper:0},animationNodeId:0};class Ur{ignoreAnimationOverrides(t){this._ignoreAnimationOverrides.push(t)}get defaultOverrides(){return this._defaultOverrides}get lineWeights(){return this._lineWeights}get neverDrawn(){return this._neverDrawn}get alwaysDrawn(){return this._alwaysDrawn}isNeverDrawn(t,e,i){return!!this._neverDrawn.has(t,e)||this.neverDrawnAnimationNodes.has(i)}isAlwaysDrawn(t,e){return this._alwaysDrawn.has(t,e)}isSubCategoryVisible(t,e){return this._visibleSubCategories.has(t,e)}isSubCategoryVisibleInModel(t,e,i,s){if(this.ignoreSubCategory)return!0;let n=this.isSubCategoryVisible(t,e);const r=this._modelSubCategoryOverrides.get(i,s);return void 0!==r&&r.has(t,e)&&(n=!n),n}getModelOverrides(t,e){return this._modelOverrides.get(t,e)}getElementAnimationOverrides(t,e,i){if(0===this.animationNodeOverrides.size)return;const s=this.animationNodeOverrides.get(i);if(!s||0===i||0===this._ignoreAnimationOverrides.length)return s;const n=Lr;return n.elementId.lower=t,n.elementId.upper=e,n.animationNodeId=i,this._ignoreAnimationOverrides.some((t=>t(n)))?void 0:s}getElementOverrides(t,e,i){const s=this._elementOverrides.get(t,e),n=this.getElementAnimationOverrides(t,e,i);return s?n?n.extendAppearance(s):s:n}getSubCategoryOverrides(t,e){return this._subCategoryOverrides.get(t,e)}setVisibleSubCategory(t){this._visibleSubCategories.addId(t)}setNeverDrawn(t){this._neverDrawn.addId(t)}setAlwaysDrawn(t){this._alwaysDrawn.addId(t)}setAnimationNodeNeverDrawn(t){this.neverDrawnAnimationNodes.add(t)}setNeverDrawnSet(t){Br(this._neverDrawn,t)}setAlwaysDrawnSet(t,e,i=!0){Br(this._alwaysDrawn,t),this.isAlwaysDrawnExclusive=e,this.alwaysDrawnIgnoresSubCategory=i}getFeatureAppearance(t,e,i=br.Primary,s=0){return this.getAppearance(l.getLowerUint32(t.elementId),l.getUpperUint32(t.elementId),l.getLowerUint32(t.subCategoryId),l.getUpperUint32(t.subCategoryId),t.geometryClass,l.getLowerUint32(e),l.getUpperUint32(e),i,s)}getAppearance(t,e,i,s,n,r,o,a,c){if(br.VolumeClassifier===a||br.PlanarClassifier===a)return this.getClassifierAppearance(t,e,i,s,r,o,c);let h=this._lineWeights?Vr.defaults:Ur._weight1Appearance;const d=this.getModelOverrides(r,o);void 0!==d&&(h=d.extendAppearance(h));let u,f,g=!1;if(l.isValidUint32Pair(t,e)){if(this.isNeverDrawn(t,e,c))return;if(g=this.isAlwaysDrawn(t,e),!g&&this.isAlwaysDrawnExclusive)return;u=this.getElementOverrides(t,e,c),void 0!==u&&(h=void 0!==d?u.extendAppearance(h):u)}if(!this.ignoreSubCategory&&l.isValidUint32Pair(i,s)){if(!(g&&this.alwaysDrawnIgnoresSubCategory||this.isSubCategoryVisibleInModel(i,s,r,o)))return;f=this.getSubCategoryOverrides(i,s),void 0!==f&&(h=f.extendAppearance(h))}void 0===u&&void 0===d&&void 0===f&&(h=this._defaultOverrides.extendAppearance(h));let p=g||this.isClassVisible(n);return p&&h.isFullyTransparent&&(p=!1),p?h:void 0}getClassifierAppearance(t,e,i,s,n,r,o){let a=Vr.defaults;const c=this.getModelOverrides(n,r);void 0!==c&&(a=c.extendAppearance(a));const h=this.getElementOverrides(t,e,o);if(void 0!==h&&(a=void 0!==c?h.extendAppearance(a):h),!this.ignoreSubCategory&&l.isValidUint32Pair(i,s)){const t=this.getSubCategoryOverrides(i,s);void 0!==t&&(a=t.extendAppearance(a))}return void 0===h&&void 0===c&&(a=this._defaultOverrides.extendAppearance(a)),a}isClassVisible(t){switch(t){case kr.Construction:return this._constructions;case kr.Dimension:return this._dimensions;case kr.Pattern:return this._patterns;default:return!0}}override(t){let i,s;void 0!==t.elementId?(i=t.elementId,s=this._elementOverrides):void 0!==t.modelId?(i=t.modelId,s=this._modelOverrides):(i=t.subCategoryId,s=this._subCategoryOverrides);let n=t.appearance;const r=l.getLowerUint32(i),o=l.getUpperUint32(i);if(void 0!==t.elementId&&this.isNeverDrawn(r,o,0))return;const a="replace"===t.onConflict?void 0:s.get(r,o);if(a)switch(e("replace"!==t.onConflict),t.onConflict){case"skip":return;case"extend":n=n.extendAppearance(a);break;default:n=a.extendAppearance(n)}s.set(r,o,n)}overrideModel(t,e,i=!0){this.override({modelId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideSubCategory(t,e,i=!0){this.override({subCategoryId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideElement(t,e,i=!0){this.override({elementId:t,appearance:e,onConflict:i?"replace":"skip"})}overrideAnimationNode(t,e){this.animationNodeOverrides.set(t,e)}setDefaultOverrides(t,e=!0){!e&&t.overridesSymbology||(this._defaultOverrides=t)}getSubCategoryPriority(t,e){return this._subCategoryPriorities.get(t,e)??0}constructor(){this._ignoreAnimationOverrides=[],this._neverDrawn=new l.Uint32Set,this._alwaysDrawn=new l.Uint32Set,this.isAlwaysDrawnExclusive=!1,this.alwaysDrawnIgnoresSubCategory=!0,this.ignoreSubCategory=!1,this._defaultOverrides=Vr.defaults,this._constructions=!1,this._dimensions=!1,this._patterns=!1,this._lineWeights=!0,this._modelOverrides=new l.Uint32Map,this._elementOverrides=new l.Uint32Map,this._subCategoryOverrides=new l.Uint32Map,this._visibleSubCategories=new l.Uint32Set,this._subCategoryPriorities=new l.Uint32Map,this._modelSubCategoryOverrides=new l.Uint32Map,this.neverDrawnAnimationNodes=new Set,this.animationNodeOverrides=new Map}isSubCategoryIdVisible(t){return this.isSubCategoryVisible(l.getLowerUint32(t),l.getUpperUint32(t))}getModelOverridesById(t){return this.getModelOverrides(l.getLowerUint32(t),l.getUpperUint32(t))}getElementOverridesById(t){return this.getElementOverrides(l.getLowerUint32(t),l.getUpperUint32(t),0)}getSubCategoryOverridesById(t){return this.getSubCategoryOverrides(l.getLowerUint32(t),l.getUpperUint32(t))}isFeatureVisible(t){const{elementId:e,subCategoryId:i,geometryClass:s}=t,n=l.isInvalid(e)?void 0:l.getUint32Pair(e);if(void 0!==n&&this.isNeverDrawn(n.lower,n.upper,0))return!1;const r=void 0!==n&&this.isAlwaysDrawn(n.lower,n.upper);return r||this.isAlwaysDrawnExclusive?r:!!this.isSubCategoryIdVisible(i)&&this.isClassVisible(s)}}var Zr;function qr(t,e,i){return t+i*(e-t)}function Wr(t,e){return i(t.x,e.x)||i(t.y,e.y)||i(t.z,e.z)}Ur._weight1Appearance=Vr.fromJSON({weight:1}),function(t){t.supplement=function(t){return{getFeatureAppearance:(e,i,s,n,r,o,a,c,h,l)=>{const d=e.getAppearance(i,s,n,r,o,a,c,h,l);return d?t(d):d}}},t.chain=function(t,e){return t===e?t:{getFeatureAppearance:(i,s,n,r,o,a,c,h,l,d)=>e.getFeatureAppearance(function(t,e){return{getAppearance:(i,s,n,r,o,a,c,h,l)=>e.getFeatureAppearance(t,i,s,n,r,o,a,c,h,l)}}(i,t),s,n,r,o,a,c,h,l,d)}}}(Zr||(Zr={}));const Gr=new j,Jr=new j;function Hr(t,e){return i(t.low,e.low)||i(t.high,e.high)}var Kr,jr,Qr;function $r(t){const e=new Set,i=t=>{t&&e.add(t.buffer)};i(t.binaryData),i(t.featureTable.data),i(t.featureTable.animationNodeIds);const s=t=>{if("pattern"!==t.type)switch(i(t.params.vertices.data),"instances"===t.modifier?.type&&(i(t.modifier.transforms),i(t.modifier.featureIds),i(t.modifier.symbologyOverrides)),t.type){case"point":i(t.params.indices);break;case"polyline":i(t.params.polyline.indices),i(t.params.polyline.prevIndices),i(t.params.polyline.nextIndicesAndParams);break;case"mesh":i(t.params.surface.indices);const e=t.params.edges;e&&(i(e.segments?.indices),i(e.segments?.endPointAndQuadIndices),i(e.silhouettes?.indices),i(e.silhouettes?.endPointAndQuadIndices),i(e.silhouettes?.normalPairs),i(e.polylines?.indices),i(e.polylines?.prevIndices),i(e.polylines?.nextIndicesAndParams),i(e.indexed?.indices),i(e.indexed?.edges.data))}else i(t.params.xyOffsets)};for(const e of t.nodes)for(const t of e.primitives)s(t);for(const e of t.patterns.values())for(const t of e)s(t);return Array.from(e)}!function(t){let a;!function(t){t[t.Step=1]="Step",t[t.Linear=2]="Linear"}(a=t.Interpolation||(t.Interpolation={}));class c{constructor(t){this.time=t.time,this.interpolation=t.interpolation===a.Linear?t.interpolation:a.Step}toJSON(){const t={time:this.time};return this.interpolation===a.Linear&&(t.interpolation=this.interpolation),t}compareTo(t){return i(this.interpolation,t.interpolation)||i(this.time,t.time)}equals(t){return 0===this.compareTo(t)}}t.TimelineEntry=c;class h extends c{constructor(t){super(t),"number"!=typeof t.value?this.value=100:this.value=Math.max(0,Math.min(100,t.value))}toJSON(){const t=super.toJSON();return 100!==this.value&&(t.value=this.value),t}compareTo(t){return e(t instanceof h),super.compareTo(t)||i(this.value,t.value)}}t.VisibilityEntry=h;class d extends c{constructor(t){super(t),t.value&&(this.value=new Ar(t.value.red,t.value.green,t.value.blue))}toJSON(){const t=super.toJSON();return this.value&&(t.value={red:this.value.r,green:this.value.g,blue:this.value.b}),t}compareTo(t){return e(t instanceof d),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.ColorEntry=d;class g{constructor(t,e,i){this.position=t,this.pivot=e,this.orientation=i}static fromJSON(t){return t.pivot&&t.position&&t.orientation?new g(j.fromJSON(t.position),j.fromJSON(t.pivot),bt.fromJSON(t.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(t){return Wr(this.pivot,t.pivot)||Wr(this.position,t.position)||(e=this.orientation,s=t.orientation,i(e.x,s.x)||i(e.y,s.y)||i(e.z,s.z)||i(e.w,s.w));var e,s}equals(t){return this.pivot.isAlmostEqual(t.pivot)&&this.position.isAlmostEqual(t.position)&&this.orientation.isAlmostEqual(t.orientation)}}t.TransformComponents=g;class p extends c{constructor(t){super(t),this.value=t.value?ft.fromJSON(t.value.transform):ft.identity,t.value&&(this.components=g.fromJSON(t.value))}toJSON(){const t=super.toJSON();return this.components?(t.value=this.components.toJSON(),t.value.transform=this.value.toRows()):t.value={transform:this.value.toRows()},t}compareTo(t){e(t instanceof p);const i=super.compareTo(t);return 0!==i?i:this.components||t.components?this.components&&t.components?this.components.compareTo(t.components):this.components?1:-1:Wr(this.value.origin,t.value.origin)||(s=this.value.matrix,n=t.value.matrix,Wr(s.columnX(Gr),n.columnX(Jr))||Wr(s.columnY(Gr),n.columnY(Jr))||Wr(s.columnZ(Gr),n.columnZ(Jr)));var s,n}}t.TransformEntry=p;class m{constructor(t){this.position=K.fromJSON(t.position),this.direction=K.fromJSON(t.direction),this.hidden=!0===t.hidden,this.visible=!0===t.visible}toJSON(){const t={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(t.visible=!0),this.hidden&&(t.hidden=!0),t}compareTo(t){return Wr(this.position,t.position)||Wr(this.direction,t.direction)||s(this.visible,t.visible)||s(this.hidden,t.hidden)}equals(t){return 0===this.compareTo(t)}}t.CuttingPlane=m;class x extends c{constructor(t){super(t),t.value&&(this.value=new m(t.value))}toJSON(){const t=super.toJSON();return this.value&&(t.value=this.value.toJSON()),t}compareTo(t){return e(t instanceof x),super.compareTo(t)||r(((t,e)=>t.compareTo(e)),this.value,t.value)}}t.CuttingPlaneEntry=x;class y{constructor(t=0,e=0,i=0){this.init(t,e,i)}init(t=0,e=0,i=0){this.lowerIndex=t,this.upperIndex=e,this.fraction=i}}t.Interval=y;class _{constructor(t,e){this.duration=dt.createNull(),this._entries=t.map((t=>{const i=new e(t);return this.duration.extendX(i.time),i}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(t){return this._entries[t]}getValue(t){return this.getEntry(t)?.value}toJSON(){return this._entries.map((t=>t.toJSON()))}compareTo(t){let e=i(this._entries.length,t._entries.length)||Hr(this.duration,t.duration);if(0===e)for(let i=0;i<this.length&&0===(e=this._entries[i].compareTo(t._entries[i]));i++);return e}equals(t){return 0===this.compareTo(t)}findInterval(t,e){if(0===this.length)return;if(e=e??new y,t<this._entries[0].time)return e.init(0,0,0),e;const i=this.length-1;if(t>=this._entries[i].time)return e.init(i,i,0),e;for(let s=0;s<i;s++){const i=this._entries[s].time,n=this._entries[s+1].time;if(i<=t&&n>=t){let r;return r=a.Linear===this._entries[s].interpolation?(t-i)/(n-i):0,e.init(s,s+1,r),e}}}}t.TimelineEntryList=_;const v=new y;class P extends _{getValue(t){return super.getValue(t)??100}}t.VisibilityTimelineEntries=P;class I extends _{getValue(t){return super.getValue(t)??ft.identity}}t.TransformTimelineEntries=I;class A{constructor(t){this.duration=dt.createNull(),t.visibilityTimeline&&(this.visibility=new P(t.visibilityTimeline,h),this.duration.extendRange(this.visibility.duration)),t.colorTimeline&&(this.color=new _(t.colorTimeline,d),this.duration.extendRange(this.color.duration)),t.transformTimeline&&(this.transform=new I(t.transformTimeline,p),this.duration.extendRange(this.transform.duration)),t.cuttingPlaneTimeline&&(this.cuttingPlane=new _(t.cuttingPlaneTimeline,x),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(t){const e=Hr(this.duration,t.duration);return 0!==e?e:!!this.visibility!=!!t.visibility?this.visibility?1:-1:!!this.color!=!!t.color?this.color?1:-1:!!this.transform!=!!t.transform?this.transform?1:-1:!!this.cuttingPlane!=!!t.cuttingPlane?this.cuttingPlane?1:-1:r(((t,e)=>t.compareTo(e)),this.visibility,t.visibility)||r(((t,e)=>t.compareTo(e)),this.color,t.color)||r(((t,e)=>t.compareTo(e)),this.transform,t.transform)||r(((t,e)=>t.compareTo(e)),this.cuttingPlane,t.cuttingPlane)}equals(t){return 0===this.compareTo(t)}getVisibility(t){let e;if(!this.visibility||!(e=this.visibility.findInterval(t,v)))return 100;let i=this.visibility.getValue(e.lowerIndex)??100;return e.fraction>0&&(i=qr(i,this.visibility.getValue(e.upperIndex)??100,e.fraction)),i}getColor(t){let e;if(!this.color||!(e=this.color.findInterval(t,v)))return;const i=this.color.getValue(e.lowerIndex);if(i&&e.fraction>0){const t=this.color.getValue(e.upperIndex);if(t)return function(t,e,i){return new Ar(qr(t.r,e.r,i),qr(t.g,e.g,i),qr(t.b,e.b,i))}(i,t,e.fraction)}return i}getAnimationTransform(t){let e;if(!this.transform||!(e=this.transform.findInterval(t,v)))return ft.identity;let i=this.transform.getValue(e.lowerIndex);if(e.fraction>0){const t=this.transform.getEntry(e.lowerIndex)?.components,s=this.transform.getEntry(e.upperIndex)?.components;if(t&&s){const n=bt.interpolateQuaternions(t.orientation,e.fraction,s.orientation),r=pt.createFromQuaternion(n),o=ft.createTranslation(t.pivot),a=ft.createTranslation(t.position.interpolate(e.fraction,s.position)).multiplyTransformMatrix3d(r);a.multiplyTransformTransform(o,a),i=a}else{const t=this.transform.getValue(e.upperIndex),s=i.matrix.inverse()?.toQuaternion(),n=t.matrix.inverse()?.toQuaternion();if(s&&n){const r=bt.interpolateQuaternions(s,e.fraction,n),o=pt.createFromQuaternion(r),a=j.createFrom(i.origin),c=j.createFrom(t.origin);i=ft.createRefs(a.interpolate(e.fraction,c),o)}}}return i}getCuttingPlane(t){let e;if(!this.cuttingPlane||!(e=this.cuttingPlane.findInterval(t,v)))return;const i=this.cuttingPlane.getValue(e.lowerIndex);if(!i)return;const s=K.createFrom(i.position),n=j.createFrom(i.direction),r=e.fraction>0?this.cuttingPlane.getValue(e.upperIndex):void 0;if(r)s.interpolate(e.fraction,r.position,s),n.interpolate(e.fraction,r.direction,n);else if(i.hidden||i.visible)return;return n.negate(n),n.normalizeInPlace(),mt.create(s,n)}getClipVector(t){const e=this.getCuttingPlane(t);if(!e)return;const i=pr.createPlane(e),s=ns.createConvexSets([fn.createPlanes([i])]),n=ds.createCapture(s);return ms.createCapture([n])}getFeatureAppearance(t,e){const i=t<100?1-t/100:void 0,s=this.getColor(e);return void 0!==s||void 0!==i?Vr.fromJSON({rgb:s,transparency:i}):void 0}}t.Timeline=A;class S extends A{constructor(t){super(t),this.batchId=t.batchId,this._elementIds=t.elementIds}static fromJSON(t){return new S(t??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(t){if(typeof this._elementIds==typeof t._elementIds){const s=i(this._elementIds.length,t._elementIds.length);if(0!==s)return s;if("string"==typeof this._elementIds)return e("string"==typeof t._elementIds),n(this._elementIds,t._elementIds)}const r=this.elementIds[Symbol.iterator](),o=t.elementIds[Symbol.iterator]();for(;;){const t=r.next(),e=o.next();if(t.done!==e.done)return s(!!t.done,!!e.done);if(t.done)return 0;const i=n(t.value,e.value);if(0!==i)return i}}compareTo(t){return e(t instanceof S),i(this.batchId,t.batchId)||this.compareElementIds(t)||super.compareTo(t)}static getElementIds(t){return"string"==typeof t?f.iterable(t):Array.isArray(t)?t:[]}get elementIds(){return S.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(t,i){e(0!==this.batchId);const s=this.getVisibility(i);if(s<=0)return void t.setAnimationNodeNeverDrawn(this.batchId);const n=this.getFeatureAppearance(s,i);n&&t.overrideAnimationNode(this.batchId,n)}}t.ElementTimeline=S;class w extends A{constructor(t){super(t),this._cachedComparisons=new WeakMap,this.modelId=t.modelId,this.realityModelUrl=t.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let e=void 0!==this.visibility||void 0!==this.color,i=!1,s=!1;const n=[],r=[];let o=!1;for(const a of t.elementTimelines){const t=S.fromJSON(a);r.push(t),this.duration.extendRange(t.duration),t.containsTransform&&(s=!0,t.batchId&&n.push(t.batchId)),e||=t.containsFeatureOverrides,i||=t.requiresBatching,o=o||t.containsElementIds}this.elementTimelines=r,this.transformBatchIds=n,this.omitsElementIds=r.length>0&&!o,this.containsFeatureOverrides=e,this.requiresBatching=i,this.containsTransform=s}static fromJSON(t){return new w(t??{elementTimelines:[],modelId:l.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((t=>t.toJSON()))}}compareTo(t){if(this===t)return 0;const r=this._cachedComparisons.get(t);if(void 0!==r)return r;e(t instanceof w);let a=n(this.modelId,t.modelId)||o(this.realityModelUrl,t.realityModelUrl)||i(this.elementTimelines.length,t.elementTimelines.length)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||s(this.containsModelClipping,t.containsModelClipping)||s(this.containsTransform,t.containsTransform)||super.compareTo(t);if(0===a)for(let e=0;e<this.elementTimelines.length&&0===(a=this.elementTimelines[e].compareTo(t.elementTimelines[e]));e++);return this._cachedComparisons.set(t,a),t._cachedComparisons.set(this,-a),a}findByBatchId(t){return this.elementTimelines.find((e=>e.batchId===t))}addSymbologyOverrides(t,e){const i=this.getFeatureAppearance(this.getVisibility(e),e);i&&t.override({modelId:this.modelId,appearance:i});for(const i of this.elementTimelines)i.addSymbologyOverrides(t,e)}getTransform(t,e){return this.findByBatchId(t)?.getAnimationTransform(e)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const t of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,t.batchId)}return this._maxBatchId}getTimelineForElement(t,e){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new l.Uint32Map;for(const t of this.elementTimelines)for(const e of t.elementIds)this._idPairToElementTimeline.setById(e,t)}return this._idPairToElementTimeline.get(t,e)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const t of this.elementTimelines)t.containsTransform||void 0===t.cuttingPlane||this._discreteBatchIds.add(t.batchId)}return this._discreteBatchIds}getBatchIdForFeature(t){e(l.fromUint32PairObject(t.modelId)===this.modelId);const i=this.getTimelineForElement(t.elementId.lower,t.elementId.upper);return i?.batchId??0}}t.ModelTimeline=w;class C{compareTo(t){if(this===t)return 0;const e=this._cachedComparisons.get(t);if(void 0!==e)return e;let n=i(this.modelTimelines.length,t.modelTimelines.length)||s(this.containsModelClipping,t.containsModelClipping)||s(this.requiresBatching,t.requiresBatching)||s(this.containsTransform,t.containsTransform)||s(this.containsFeatureOverrides,t.containsFeatureOverrides)||Hr(this.duration,t.duration);if(0===n)for(let e=0;e<this.modelTimelines.length&&0===(n=this.modelTimelines[e].compareTo(t.modelTimelines[e]));e++);return this._cachedComparisons.set(t,n),t._cachedComparisons.set(this,-n),n}equals(t){return 0===this.compareTo(t)}constructor(t){this._cachedComparisons=new WeakMap,this.duration=dt.createNull();const e=new Set,i=[];let s=!1,n=!1,r=!1,o=!1;for(const a of t){const t=w.fromJSON(a);i.push(t),this.duration.extendRange(t.duration),s||=t.containsModelClipping,n||=t.requiresBatching,r||=t.containsTransform,o||=t.containsFeatureOverrides;for(const i of t.transformBatchIds)e.add(i)}this.modelTimelines=i,this.containsModelClipping=s,this.containsTransform=r,this.requiresBatching=n||this.containsTransform,this.containsFeatureOverrides=o,this.transformBatchIds=e}static fromJSON(t){if(Array.isArray(t)&&0!==t.length)return new C(t)}toJSON(){return this.modelTimelines.map((t=>t.toJSON()))}find(t){return this.modelTimelines.find((e=>e.modelId===t))}getTransformBatchIds(t){return this.find(t)?.transformBatchIds}getTransform(t,e,i){return this.find(t)?.getTransform(e,i)}addSymbologyOverrides(t,e){for(const i of this.modelTimelines)i.addSymbologyOverrides(t,e)}discloseIds(t){for(const e of this.modelTimelines){t.addModel(e.modelId);for(const i of e.elementTimelines)for(const e of i.elementIds)t.addElement(e)}}modelRequiresBatching(t){return this.requiresBatching&&this.modelTimelines.some((e=>e.modelId===t&&e.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const t of this.modelTimelines)for(const e of t.discreteBatchIds)this._discreteBatchIds.add(e);return this._discreteBatchIds}getBatchIdForFeature(t){let e;const i=this._lastFeatureModelTimeline;if(i&&i.idLower===t.modelId.lower&&i.idUpper===t.modelId.upper)e=i.timeline;else{const i=l.fromUint32PairObject(t.modelId);e=this.find(i),this._lastFeatureModelTimeline={timeline:e,idLower:t.modelId.lower,idUpper:t.modelId.upper}}return e?.getBatchIdForFeature(t)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((t,e)=>Math.max(t,e.maxBatchId)),0))}}t.Script=C,t.ScriptReference=class{constructor(t,i){"string"==typeof t?(e(i instanceof C),this.sourceId=t,this.script=i):(e(void 0===i),this.script=t,this.sourceId=l.invalid)}};class T{addVisibility(t,e,i=a.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:t,value:e,interpolation:i})}addColor(t,e,i=a.Linear){this.color||(this.color=[]);const s=e instanceof Ar?{red:e.r,green:e.g,blue:e.b}:e;this.color.push({time:t,value:s,interpolation:i})}addCuttingPlane(t,e,i=a.Linear){let s;this.cuttingPlane||(this.cuttingPlane=[]),e&&(s={position:[e.position.x,e.position.y,e.position.z],direction:[e.direction.x,e.direction.y,e.direction.z]},e.visible&&(s.visible=!0),e.hidden&&(s.hidden=!0)),this.cuttingPlane.push({time:t,value:s,interpolation:i})}addTransform(t,e,i,s=a.Linear){this.transform||(this.transform=[]);const n={transform:e?.toRows()};i&&(n.pivot=[i.pivot.x,i.pivot.y,i.pivot.z],n.orientation=i.orientation.toJSON(),n.position=[i.position.x,i.position.y,i.position.z]),this.transform.push({time:t,value:n,interpolation:s})}finish(){const t={};return this.visibility?.length&&(t.visibilityTimeline=this.visibility),this.color?.length&&(t.colorTimeline=this.color),this.transform?.length&&(t.transformTimeline=this.transform),this.cuttingPlane?.length&&(t.cuttingPlaneTimeline=this.cuttingPlane),t}}t.TimelineBuilder=T;class k extends T{constructor(t,e){super(),this.batchId=t,this.elementIds=e}finish(){const t=super.finish();return t.batchId=this.batchId,t.elementIds=this.elementIds,t}}t.ElementTimelineBuilder=k;class F extends T{constructor(t,e){super(),this._elements=[],this.modelId=t,this._obtainNextBatchId=e}addElementTimeline(t){const e=this._obtainNextBatchId();let i;if("string"==typeof t&&l.isValidId64(t)&&(t=[t]),"string"==typeof t)i=t;else{const e=Array.from(t);u.sortArray(e),i=f.compressIds(e)}const s=new k(e,i);return this._elements.push(s),s}finish(){const t=super.finish();return t.modelId=this.modelId,void 0!==this.realityModelUrl&&(t.realityModelUrl=this.realityModelUrl),t.elementTimelines=this._elements.map((t=>t.finish())),t}}t.ModelTimelineBuilder=F,t.ScriptBuilder=class{constructor(){this._nextBatchId=1,this._models=[]}addModelTimeline(t){const e=new F(t,(()=>this._nextBatchId++));return this._models.push(e),e}finish(){return this._models.map((t=>t.finish()))}}}(Kr||(Kr={})),function(t){function e(t){return"object"==typeof t&&0===Object.keys(t).length}function i(t){return void 0===t||e(t)}function s(t){return null==t}t.asBool=function(t,e=!1){return s(t)?e:!!t},t.asInt=function(t,e=0){return"number"==typeof t?Math.trunc(t):e},t.asDouble=function(t,e=0){return"number"==typeof t?t:e},t.asString=function(t,e=""){return s(t)?e:t.toString()},t.asArray=function(t){return Array.isArray(t)?t:void 0},t.asObject=function(t){return"object"==typeof t?t:void 0},t.setOrRemoveNumber=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.setOrRemoveBoolean=function(t,e,i,s){i===s?delete t[e]:t[e]=i},t.isEmptyObject=e,t.isEmptyObjectOrUndefined=i,t.isNonEmptyObject=function(t){return!i(t)},t.toObject=function t(e){if("boolean"==typeof e||"number"==typeof e||"string"==typeof e)return e;if("object"!=typeof e)return;if(void 0!==e.toJSON)return t(e.toJSON());if(Array.isArray(e)){const i=new Array(e.length);return e.forEach(((e,s)=>i[s]=t(e))),i}const i={};return Object.getOwnPropertyNames(e).forEach((s=>{const n=t(e[s]);void 0!==n&&(i[s]=n)})),i}}(jr||(jr={}));class to{constructor(t,e){this._curPos=0,void 0!==e?(this._view=new DataView(t,e.byteOffset,e.byteLength),this._byteOffset=e.byteOffset):(this._view=new DataView(t),this._byteOffset=0)}static fromUint8Array(t){const{byteOffset:e,byteLength:i}=t;return new to(t.buffer,{byteOffset:e,byteLength:i})}static fromArrayBuffer(t,e){return new to(t,e)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(t){this._curPos=t,e(!this.isPastTheEnd)}advance(t){return this.curPos=this.curPos+t,!this.isPastTheEnd}rewind(t){return!(this.curPos-t<0||(this.curPos=this.curPos-t,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(t=>t.getUint8(this.curPos)))}readUint16(){return this.read(2,(t=>t.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(t=>t.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(t=>t.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(t=>t.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(t=>t.getFloat64(this.curPos,!0)))}readId64(){return l.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}get nextUint8(){return this.readUint8()}get nextUint16(){return this.readUint16()}get nextUint32(){return this.readUint32()}get nextInt32(){return this.readInt32()}get nextFloat32(){return this.readFloat32()}get nextFloat64(){return this.readFloat64()}get nextId64(){return this.readId64()}get nextUint24(){return this.readUint24()}nextBytes(t){const e=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(t),e}readBytes(t,e){return new Uint8Array(this.arrayBuffer,t+this._byteOffset,e)}nextUint32s(t){const e=4*t,i=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(e),i}get arrayBuffer(){return this._view.buffer}read(t,e){const i=e(this._view);return this.advance(t),i}}!function(t){function e(t,e,i){return e<=t&&t<=i}t.decodeWithFromCharCode=function(t){let i="";const s=function(t){let i=0,s=0,n=0,r=128,o=191;const a=[],c=t.length;for(let h=0;h<c;h++){const c=t[h];if(0===n){if(e(c,0,127)){a.push(c);continue}if(e(c,194,223)){n=1,i=31&c;continue}if(e(c,224,239)){224===c?r=160:237===c&&(o=159),n=2,i=15&c;continue}if(e(c,240,244)){240===c?r=144:244===c&&(o=143),n=3,i=7&c;continue}return}e(c,r,o)?(r=128,o=191,i=i<<6|63&c,++s,s===n&&(a.push(i),i=n=s=0)):(i=n=s=0,r=128,o=191,--h)}return a}(t);if(void 0!==s){for(let t of s)t<=65535?i+=String.fromCharCode(t):(t-=65536,i+=String.fromCharCode(55296+(t>>10),56320+(1023&t)));return i}}}(Qr||(Qr={}));let eo=!0;var io,so,no,ro,oo,ao,co,ho,lo,uo,fo,go,po,mo,xo,yo,_o,vo,Po,Io,Ao,So;(no=io||(io={}))[no.Unknown=0]="Unknown",no[no.B3dm=1835283298]="B3dm",no[no.Gltf=1179937895]="Gltf",no[no.Pnts=1937010288]="Pnts",no[no.IModel=1818512745]="IModel",no[no.Cmpt=1953525091]="Cmpt",no[no.I3dm=1835283305]="I3dm",no[no.A3x=5780289]="A3x",function(t){t[t.Success=0]="Success",t[t.InvalidTileData=1]="InvalidTileData",t[t.InvalidHeader=2]="InvalidHeader",t[t.InvalidBatchTable=3]="InvalidBatchTable",t[t.InvalidScene=4]="InvalidScene",t[t.InvalidFeatureTable=5]="InvalidFeatureTable",t[t.NewerMajorVersion=6]="NewerMajorVersion",t[t.Canceled=7]="Canceled"}(so||(so={}));class wo{constructor(t){this._format=function(t){const e=t;return function(t){switch(t){case io.Unknown:case io.B3dm:case io.Gltf:case io.IModel:case io.Pnts:case io.Cmpt:case io.I3dm:case io.A3x:return!0;default:return!1}}(e)?e:io.Unknown}(t.readUint32()),this.version=t.readUint32()}get format(){return this._format}invalidate(){this._format=io.Unknown}}function Co(t,e){const i=t.readFloat64(),s=t.readFloat64(),n=t.readFloat64();return void 0===e?new K(i,s,n):(e.set(i,s,n),e)}!function(t){t[t.Version1=1]="Version1",t[t.Version2=2]="Version2",t[t.CurrentVersion=1]="CurrentVersion",t[t.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(ro||(ro={})),function(t){t[t.JSON=1313821514]="JSON",t[t.Binary=5130562]="Binary"}(oo||(oo={}));class To{get isTileSection(){return To.Type.TileSection===this.type}get isGlyph(){return To.Type.Glyph===this.type}get isSkyBox(){return To.Type.SkyBox===this.type}constructor(t){this.type=t}}!function(t){let e;!function(t){t[t.Normal=0]="Normal",t[t.Glyph=1]="Glyph",t[t.TileSection=2]="TileSection",t[t.SkyBox=3]="SkyBox",t[t.FilteredTileSection=4]="FilteredTileSection",t[t.ThematicGradient=5]="ThematicGradient"}(e=t.Type||(t.Type={})),t.Params=class{constructor(e,i=t.Type.Normal,s=!1){this.key=e,this.type=i,this.isOwned=s}get isTileSection(){return t.Type.TileSection===this.type}get isGlyph(){return t.Type.Glyph===this.type}get isSkyBox(){return t.Type.SkyBox===this.type}}}(To||(To={}));class ko{constructor(t){this.key=t.key,this.textureMapping=t.textureMapping}get hasTexture(){return void 0!==this.textureMapping?.texture}}!function(t){class e{constructor(t){this.diffuse=.6,this.specular=.4,this.specularExponent=13.5,this.reflect=0,this.refract=1,this.ambient=.3,this.shadows=!0,this.key=t}get alpha(){return this._alpha}set alpha(t){var e;this._alpha=void 0!==t?(e=t,Math.max(0,Math.min(1,e))):void 0}static fromColors(t,i,s,n,r,o){const a=new e;return a.key=t,a.diffuseColor=i,a.specularColor=s,a.emissiveColor=n,a.reflectColor=r,a.textureMapping=o,a}}e.defaults=new e,t.Params=e}(ko||(ko={})),Object.freeze(ko.Params.defaults),function(t){function e(e,i=t.rangeScale16){return e>=0&&e<i+1}function i(e,i,s,n=t.rangeScale16){return Math.floor(Math.max(0,Math.min(n,.5+(e-i)*s)))}t.rangeScale16=65535,t.rangeScale8=255,t.computeScale=function(e,i=t.rangeScale16){return 0===e?e:i/e},t.isInRange=e,t.quantize=i,t.isQuantizable=function(s,n,r,o=t.rangeScale16){return e(i(s,n,r,o))},t.unquantize=function(t,e,i){return 0===i?e:e+t/i},t.isQuantized=function(t){return e(t)&&t===Math.floor(t)}}(ao||(ao={}));class Fo{constructor(t=0,e=0,i=0,s=0){this.origin=new W,this.scale=new W,this.setFrom(t,e,i,s)}setFrom(t,e,i,s){this.origin.x=t,this.origin.y=e,this.scale.x=i,this.scale.y=s}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}clone(t){const e=void 0!==t?t:new Fo;return e.copyFrom(this),e}setFromRange(t,e=ao.rangeScale16){t.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(t.low.x,t.low.y,ao.computeScale(t.high.x-t.low.x,e),ao.computeScale(t.high.y-t.low.y,e))}static fromRange(t,e,i=ao.rangeScale16){const s=void 0!==e?e:new Fo;return s.setFromRange(t,i),s}unquantize(t,e,i){return(i=i??new W).x=ao.unquantize(t,this.origin.x,this.scale.x),i.y=ao.unquantize(e,this.origin.y,this.scale.y),i}static fromNormalizedRange(t=ao.rangeScale16){return Fo.fromRange(ut.createArray([W.create(-1,-1),W.create(1,1)]),void 0,t)}static fromZeroToOne(t=ao.rangeScale16){return Fo.fromRange(ut.createArray([W.create(0,0),W.create(1,1)]),void 0,t)}static fromOriginAndScale(t,e,i,s){return new Fo(t,e,i,s)}get rangeDiagonal(){return G.createFrom({x:0===this.scale.x?0:ao.rangeScale16/this.scale.x,y:0===this.scale.y?0:ao.rangeScale16/this.scale.y})}isQuantizable(t){return ao.isQuantizable(t.x,this.origin.x,this.scale.x)&&ao.isQuantizable(t.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(t){return this.fromOriginAndScale(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}}class Mo{get x(){return this._x}set x(t){e(ao.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(ao.isQuantized(t)),this._y=t}constructor(){this._x=0,this._y=0}init(t,e){this.x=ao.quantize(t.x,e.origin.x,e.scale.x),this.y=ao.quantize(t.y,e.origin.y,e.scale.y)}static create(t,e){const i=new Mo;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y}clone(t){const e=void 0!==t?t:new Mo;return e.copyFrom(this),e}setFromScalars(t,e){this.x=t,this.y=e}static fromScalars(t,e){const i=new Mo;return i.setFromScalars(t,e),i}unquantize(t,e){const i=void 0!==e?e:new W;return i.x=ao.unquantize(this.x,t.origin.x,t.scale.x),i.y=ao.unquantize(this.y,t.origin.y,t.scale.y),i}}!function(t){const e=new Mo;function i(t,e,i){const s=2*e,n=t[s+0],r=t[s+1];if(void 0===n||void 0===r)throw new Error("Index out of range");return(i=i??new Mo).setFromScalars(n,r),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(co||(co={}));class bo{constructor(t=0,e=0,i=0,s=0,n=0,r=0){this.origin=new K,this.scale=new K,this.setFrom(t,e,i,s,n,r)}setFrom(t,e,i,s,n,r){this.origin.x=t,this.origin.y=e,this.origin.z=i,this.scale.x=s,this.scale.y=n,this.scale.z=r}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.origin.z,t.scale.x,t.scale.y,t.scale.z)}clone(t){const e=void 0!==t?t:new bo;return e.copyFrom(this),e}setFromOriginAndScale(t,e){this.setFrom(t.x,t.y,t.z,e.x,e.y,e.z)}setFromRange(t,e=ao.rangeScale16){t.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(t.low.x,t.low.y,t.low.z,ao.computeScale(t.high.x-t.low.x,e),ao.computeScale(t.high.y-t.low.y,e),ao.computeScale(t.high.z-t.low.z,e))}unquantize(t,e,i,s){const n=void 0!==s?s:new K;return n.x=ao.unquantize(t,this.origin.x,this.scale.x),n.y=ao.unquantize(e,this.origin.y,this.scale.y),n.z=ao.unquantize(i,this.origin.z,this.scale.z),n}static fromRange(t,e,i=ao.rangeScale16){const s=void 0!==e?e:new bo;return s.setFromRange(t,i),s}static fromOriginAndScale(t,e,i){const s=void 0!==i?i:new bo;return s.setFromOriginAndScale(t,e),s}static fromNormalizedRange(t=ao.rangeScale16){return bo.fromRange(lt.createArray([K.create(-1,-1,-1),K.create(1,1,1)]),void 0,t)}static fromZeroToOne(t=ao.rangeScale16){return bo.fromRange(lt.createArray([K.create(0,0,0),K.create(1,1,1)]),void 0,t)}get rangeDiagonal(){return j.createFrom({x:0===this.scale.x?0:ao.rangeScale16/this.scale.x,y:0===this.scale.y?0:ao.rangeScale16/this.scale.y,z:0===this.scale.z?0:ao.rangeScale16/this.scale.z})}isQuantizable(t){return ao.isQuantizable(t.x,this.origin.x,this.scale.x)&&ao.isQuantizable(t.y,this.origin.y,this.scale.y)&&ao.isQuantizable(t.z,this.origin.z,this.scale.z)}computeRange(t){const e=lt.createNull(t);return e.extendPoint(this.origin),e.extendPoint(this.origin.plus(this.rangeDiagonal)),e}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(t,e){return this.fromOriginAndScale(K.fromJSON(t.origin),K.fromJSON(t.scale),e)}}class Eo{get x(){return this._x}set x(t){e(ao.isQuantized(t)),this._x=t}get y(){return this._y}set y(t){e(ao.isQuantized(t)),this._y=t}get z(){return this._z}set z(t){e(ao.isQuantized(t)),this._z=t}constructor(){this._x=0,this._y=0,this._z=0}init(t,e){this.x=ao.quantize(t.x,e.origin.x,e.scale.x),this.y=ao.quantize(t.y,e.origin.y,e.scale.y),this.z=ao.quantize(t.z,e.origin.z,e.scale.z)}static create(t,e){const i=new Eo;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(t){const e=void 0!==t?t:new Eo;return e.copyFrom(this),e}setFromScalars(t,e,i){this.x=t,this.y=e,this.z=i}static fromScalars(t,e,i,s){const n=void 0===s?new Eo:s;return n.setFromScalars(t,e,i),n}unquantize(t,e){const i=void 0!==e?e:new K;return i.x=ao.unquantize(this.x,t.origin.x,t.scale.x),i.y=ao.unquantize(this.y,t.origin.y,t.scale.y),i.z=ao.unquantize(this.z,t.origin.z,t.scale.z),i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}compare(t){let e=this.x-t.x;return 0===e&&(e=this.y-t.y,0===e&&(e=this.z-t.z)),e}}!function(t){const e=new Eo;function i(t,e,i){const s=3*e,n=t[s+0],r=t[s+1],o=t[s+2];if(void 0===n||void 0===r||void 0===o)throw new Error("Index out of range");return(i=i??new Eo).setFromScalars(n,r,o),i}t.getQPoint=i,t.unquantizePoint=function(t,s,n){return i(t.points,s,e).unquantize(t.params,n)}}(ho||(ho={}));class Xo{get list(){return this._list}constructor(t){this._list=[],this.params=t?t.clone():bo.fromRange(Range3d.createNull())}static fromPoints(t,e){let i;const s=bo.fromRange(Range3d.createArray(t));e?i.reset(s):new Xo(s);for(const e of t)i.add(e);return i}clear(){this._list.length=0}reset(t){this.clear(),this.params.copyFrom(t)}add(t){this._list.push(Eo.create(t,this.params))}push(t){this._list.push(t.clone())}get length(){return this._list.length}unquantize(t,e){return assert(t<this.length),t<this.length?this._list[t].unquantize(this.params,e):void 0!==e?e:new Point3d}requantize(t){for(let e=0;e<this.length;e++){const i=this.unquantize(e);this._list[e].init(i,t)}this.params.copyFrom(t)}toTypedArray(){const t=new Uint16Array(3*this.length),e=this._list;for(let i=0;i<this.length;i++){const s=e[i];t[3*i+0]=s.x,t[3*i+1]=s.y,t[3*i+2]=s.z}return t}fromTypedArray(t,e){this.params.setFromRange(t),this._list.length=e.length/3;for(let t=0,i=0;t<this.list.length;t++)this._list[t]=Eo.fromScalars(e[i++],e[i++],e[i++])}static createFrom(t,e){const i=new Xo(e);for(const e of t)i.add(e);return i}[Symbol.iterator](){return this.list[Symbol.iterator]()}}!function(t){t[t.None=0]="None",t[t.ContainsCurves=1]="ContainsCurves",t[t.Incomplete=4]="Incomplete",t[t.DisallowMagnification=8]="DisallowMagnification",t[t.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(lo||(lo={})),function(t){t[t.Major=31]="Major",t[t.Minor=0]="Minor",t[t.Combined=2031616]="Combined"}(uo||(uo={}));class zo extends wo{get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return io.IModel===this.format}get isReadableVersion(){return this.versionMajor<=uo.Major}constructor(t){super(t),this.headerLength=t.readUint32(),this.flags=t.readUint32(),this.contentRange=new lt,Co(t,this.contentRange.low),Co(t,this.contentRange.high),this.tolerance=t.readFloat64(),this.numElementsIncluded=t.readUint32(),this.numElementsExcluded=t.readUint32(),this.tileLength=t.readUint32(),this.emptySubRanges=this.versionMajor>=2?t.readUint32():0;const i=this.headerLength-t.curPos;e(i>=0),t.advance(i),t.isPastTheEnd&&this.invalidate()}}class Ro{static readFrom(t){const e=t.readUint32(),i=t.readUint32(),s=t.readUint32();return t.isPastTheEnd?void 0:new Ro(e,i,s)}constructor(t,e,i){this.length=t,this.numSubCategories=e,this.count=i}}Ro.sizeInBytes=12,function(t){t[t.Normal=0]="Normal",t[t.Edge=1]="Edge",t[t.Outline=2]="Outline"}(fo||(fo={}));class Do{constructor(t,e){this.texture=t,this.params=e}computeUVParams(t,e){return this.params.computeUVParams(t,e)}}!function(t){let e;!function(t){t[t.None=-1]="None",t[t.Parametric=0]="Parametric",t[t.ElevationDrape=1]="ElevationDrape",t[t.Planar=2]="Planar",t[t.DirectionalDrape=3]="DirectionalDrape",t[t.Cubic=4]="Cubic",t[t.Spherical=5]="Spherical",t[t.Cylindrical=6]="Cylindrical",t[t.Solid=7]="Solid",t[t.FrontProject=8]="FrontProject"}(e=t.Mode||(t.Mode={}));class i{constructor(t=1,e=0,i=0,s=0,n=1,r=0){const o=new K(i,r,0),a=pt.createRowValues(t,e,0,s,n,0,0,0,1);this.transform=ft.createRefs(o,a)}}i.identity=new i,t.Trans2x3=i,t.Params=class{constructor(t){this.textureMatrix=t?.textureMat2x3??i.identity,this.weight=t?.textureWeight??1,this.mode=t?.mapMode??e.Parametric,this.worldMapping=t?.worldMapping??!1,this.useConstantLod=t?.useConstantLod??!1,this.constantLodParams={repetitions:t?.constantLodProps?.repetitions??1,offset:t?.constantLodProps?.offset??{x:0,y:0},minDistClamp:t?.constantLodProps?.minDistClamp??1,maxDistClamp:t?.constantLodProps?.maxDistClamp??4294967296}}computeUVParams(e,i){switch(this.mode){default:case t.Mode.Parametric:return this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping);case t.Mode.Planar:{const t=e.normalIndex;if(!t)return;return this.worldMapping&&(void 0===e.normalIndex||t[0]===t[1]&&t[0]===t[2])?this.computePlanarUVParams(e,this.textureMatrix.transform):this.computeParametricUVParams(e,this.textureMatrix.transform,!this.worldMapping)}case t.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(e,this.textureMatrix.transform,i)}}computeParametricUVParams(t,e,i){const s=[];for(let n=0;n<t.numEdgesThisFacet;n++){let r=W.create();!i&&t.tryGetDistanceParameter(n,r)||t.tryGetNormalizedParameter(n,r)||(r=t.getParam(n)),s.push(e.multiplyPoint2d(r))}return s}computePlanarUVParams(t,e){const i=[],s=t.point;let n;if(n=void 0===t.normal?s.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(s.getPoint3dAtUncheckedPointIndex(1),s.getPoint3dAtUncheckedPointIndex(2)):t.normal.getVector3dAtCheckedVectorIndex(0),!n.normalize(n))return;n.scale(-1,n);const r=j.create(n.y,-n.x,0),o=r.magnitude();r.normalize(r),o<.001&&(n.set(0,0,-1),r.set(1,0,0));const a=r.crossProduct(n).normalize();if(!a)return;const c=t.numEdgesThisFacet;for(let t=0;t<c;t++){const n=j.createFrom(s.getPoint3dAtUncheckedPointIndex(t));i.push(W.create(n.dotProduct(r),n.dotProduct(a))),e.multiplyPoint2d(i[t],i[t])}return i}computeElevationDrapeUVParams(t,e,i){const s=[],n=t.numEdgesThisFacet;for(let r=0;r<n;r++){const n=t.point.getPoint3dAtUncheckedPointIndex(r);void 0!==i&&i.multiplyPoint3d(n,n),s.push(W.createFrom(n)),e.multiplyPoint2d(s[r],s[r])}return s}}}(Do||(Do={})),Object.freeze(Do.Trans2x3.identity),(So=go||(go={}))[So.Solid=0]="Solid",So[So.Code0=0]="Code0",So[So.Code1=2155905152]="Code1",So[So.Code2=4177066232]="Code2",So[So.Code3=4292935648]="Code3",So[So.Code4=4262526480]="Code4",So[So.Code5=3772834016]="Code5",So[So.Code6=4169726088]="Code6",So[So.Code7=4279828248]="Code7",So[So.HiddenLine=3435973836]="HiddenLine",So[So.Invisible=1]="Invisible",So[So.Invalid=-1]="Invalid",function(t){t[t.None=0]="None",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Behind=4]="Behind",t[t.Blanking=6]="Blanking",t[t.Background=8]="Background"}(po||(po={})),function(t){t[t.Rgba=0]="Rgba",t[t.Rgb=2]="Rgb",t[t.Alpha=5]="Alpha"}(mo||(mo={}));class No{get numBytesPerPixel(){return No.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(t){switch(t){case mo.Alpha:return 1;case mo.Rgb:return 3;default:return 4}}get height(){return No.computeHeight(this.data,this.format,this.width)}static create(t,e,i){if(!this.isValidData(t,e,i))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new No(t,e,i)}static isValidData(t,e,i){const s=this.computeHeight(t,e,i);return i>0&&s>0&&Math.floor(i)===i&&Math.floor(s)===s}static computeHeight(t,e,i){return t.length/(i*this.getNumBytesPerPixel(e))}constructor(t,e,i){this.data=t,this.format=e,this.width=i}}!function(t){t[t.Jpeg=0]="Jpeg",t[t.Png=2]="Png",t[t.Svg=3]="Svg"}(xo||(xo={})),function(t){t[t.Smooth=0]="Smooth",t[t.Stepped=1]="Stepped",t[t.SteppedWithDelimiter=2]="SteppedWithDelimiter",t[t.IsoLines=3]="IsoLines"}(yo||(yo={})),function(t){t[t.BlueRed=0]="BlueRed",t[t.RedBlue=1]="RedBlue",t[t.Monochrome=2]="Monochrome",t[t.Topographic=3]="Topographic",t[t.SeaMountain=4]="SeaMountain",t[t.Custom=5]="Custom"}(_o||(_o={}));class Yo{static get margin(){return.001}static get contentRange(){return 1-2*Yo.margin}static get contentMax(){return 1-Yo.margin}equals(t){if(this.mode!==t.mode)return!1;if(this.stepCount!==t.stepCount)return!1;if(!this.marginColor.equals(t.marginColor))return!1;if(this.colorScheme!==t.colorScheme)return!1;if(this.customKeys.length!==t.customKeys.length)return!1;if(this.colorMix!==t.colorMix)return!1;for(let e=0;e<this.customKeys.length;e++)if(!Po.keyColorEquals(this.customKeys[e],t.customKeys[e]))return!1;return!0}static compare(t,e){let s=0;if(0!==(s=i(t.mode,e.mode)))return s;if(0!==(s=i(t.stepCount,e.stepCount)))return s;if(0!==(s=i(t.marginColor.tbgr,e.marginColor.tbgr)))return s;if(0!==(s=i(t.colorScheme,e.colorScheme)))return s;if(0!==(s=i(t.colorMix,e.colorMix)))return s;if(0!==(s=i(t.customKeys.length,e.customKeys.length)))return s;for(let n=0;n<t.customKeys.length;n++)if(0!==(s=i(t.customKeys[n].color.tbgr,e.customKeys[n].color.tbgr)))return s;return s}constructor(t){if(this.customKeys=[],void 0===t)this.mode=yo.Smooth,this.stepCount=10,this.marginColor=Ir.fromJSON(),this.colorScheme=_o.BlueRed,this.colorMix=0;else{if(this.mode=void 0!==t.mode&&null!==t.mode?t.mode:yo.Smooth,(this.mode<yo.Smooth||this.mode>yo.IsoLines)&&(this.mode=yo.Smooth),this.stepCount="number"==typeof t.stepCount?t.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=Ir.fromJSON(t.marginColor),this.colorScheme=void 0!==t.colorScheme&&null!==t.colorScheme?t.colorScheme:_o.BlueRed,(this.colorScheme<_o.BlueRed||this.colorScheme>_o.Custom)&&(this.colorScheme=_o.BlueRed),void 0!==t.customKeys&&null!==t.customKeys&&t.customKeys.forEach((t=>this.customKeys.push(new Po.KeyColor(t)))),this.colorScheme===_o.Custom&&this.customKeys.length<2){this.customKeys=[];for(const t of Yo._defaultCustomKeys)this.customKeys.push(new Po.KeyColor({value:t[0],color:Ir.computeTbgrFromComponents(t[1],t[3],t[2])}))}this.colorMix=t.colorMix??0}}static fromJSON(t){return t?new Yo(t):this.defaults}toJSON(){const t={};yo.Smooth!==this.mode&&(t.mode=this.mode),10!==this.stepCount&&(t.stepCount=this.stepCount);const e=this.marginColor.toJSON();return 0!==e&&(t.marginColor=e),_o.BlueRed!==this.colorScheme&&(t.colorScheme=this.colorScheme),0!==this.colorMix&&(t.colorMix=this.colorMix),this.customKeys.length>0&&(t.customKeys=this.customKeys.map((t=>({value:t.value,color:t.color.toJSON()})))),t}clone(t){if(void 0===t)return Yo.fromJSON(this.toJSON());const e={mode:void 0!==t.mode?t.mode:this.mode,stepCount:void 0!==t.stepCount?t.stepCount:this.stepCount,marginColor:void 0!==t.marginColor?t.marginColor:this.marginColor.tbgr,colorScheme:void 0!==t.colorScheme?t.colorScheme:this.colorScheme,customKeys:void 0!==t.customKeys?t.customKeys:this.customKeys.map((t=>({value:t.value,color:t.color.tbgr}))),colorMix:void 0!==t.colorMix?t.colorMix:this.colorMix};return Yo.fromJSON(e)}}Yo.defaults=new Yo({}),Yo._defaultCustomKeys=[[0,255,255,255],[1,0,0,0]],function(t){t[t.Height=0]="Height",t[t.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",t[t.Slope=2]="Slope",t[t.HillShade=3]="HillShade"}(vo||(vo={})),function(t){let i,s;!function(t){t[t.None=0]="None",t[t.Invert=1]="Invert",t[t.Outline=2]="Outline"}(i=t.Flags||(t.Flags={})),function(t){t[t.None=0]="None",t[t.Linear=1]="Linear",t[t.Curved=2]="Curved",t[t.Cylindrical=3]="Cylindrical",t[t.Spherical=4]="Spherical",t[t.Hemispherical=5]="Hemispherical",t[t.Thematic=6]="Thematic"}(s=t.Mode||(t.Mode={}));class n{constructor(t){this.value=t.value,this.color=Ir.fromJSON(t.color)}}t.KeyColor=n,t.keyColorEquals=function(t,e){return t.value===e.value&&t.color.equals(e.color)};class r{constructor(){this.mode=s.None,this.flags=i.None,this.shift=0,this.keys=[]}static fromJSON(t){const e=new r;return t?(e.mode=t.mode,e.flags=void 0===t.flags?i.None:t.flags,e.angle=t.angle?Z.fromJSON(t.angle):void 0,e.tint=t.tint,e.shift=t.shift?t.shift:0,t.keys.forEach((t=>e.keys.push(new n(t)))),e.thematicSettings=void 0===t.thematicSettings?void 0:Yo.fromJSON(t.thematicSettings),e):e}static createThematic(i){const o=new r;if(o.mode=s.Thematic,o.thematicSettings=i,i.colorScheme<_o.Custom)for(const e of t.Symb._fixedSchemeKeys[i.colorScheme])o.keys.push(new n({value:e[0],color:Ir.computeTbgrFromComponents(e[1],e[3],e[2])}));else if(e(i.customKeys.length>1,"Custom thematic mode requires at least two keys to be defined"),i.customKeys.length>1)i.customKeys.forEach((t=>o.keys.push(t)));else for(const e of t.Symb._fixedCustomKeys)o.keys.push(new n({value:e[0],color:Ir.from(e[1],e[3],e[2]).toJSON()}));return o}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((t=>({value:t.value,color:t.color.toJSON()})))}}clone(){return r.fromJSON(this.toJSON())}equals(t){return 0===r.compareSymb(this,t)}static compareSymb(t,e){if(t===e)return 0;if(t.mode!==e.mode)return t.mode-e.mode;if(t.flags!==e.flags)return void 0===t.flags?-1:void 0===e.flags?1:t.flags-e.flags;if(t.tint!==e.tint)return void 0===t.tint?-1:void 0===e.tint?1:t.tint-e.tint;if(t.shift!==e.shift)return void 0===t.shift?-1:void 0===e.shift?1:t.shift-e.shift;if(void 0===t.angle!=(void 0===e.angle))return void 0===t.angle?-1:1;if(t.angle&&!t.angle.isAlmostEqualNoPeriodShift(e.angle))return t.angle.radians-e.angle.radians;if(t.keys.length!==e.keys.length)return t.keys.length-e.keys.length;for(let i=0;i<t.keys.length;i++){if(t.keys[i].value!==e.keys[i].value)return t.keys[i].value-e.keys[i].value;if(!t.keys[i].color.equals(e.keys[i].color))return t.keys[i].color.tbgr-e.keys[i].color.tbgr}if(t.thematicSettings!==e.thematicSettings){if(void 0===t.thematicSettings)return-1;if(void 0===e.thematicSettings)return 1;{const i=Yo.compare(t.thematicSettings,e.thematicSettings);if(0!==i)return i}}return 0}compare(e){return t.Symb.compareSymb(this,e)}roundToByte(t){return 255&Math.min(t+.5,255)}mapColor(t){t<0?t=0:t>1&&(t=1),0!=(this.flags&i.Invert)&&(t=1-t);let e,s,n,r=0;if(this.keys.length<=2)s=1-t,n=t;else{for(;r<this.keys.length-2&&t>this.keys[r+1].value;)r++;e=this.keys[r+1].value-this.keys[r].value,n=e<1e-4?0:(t-this.keys[r].value)/e,s=1-n}const o=this.keys[r].color,a=this.keys[r+1].color,c=o.colors,h=a.colors,l=s*c.r+n*h.r,d=s*c.g+n*h.g,u=s*c.b+n*h.b,f=s*c.t+n*h.t;return Ir.from(this.roundToByte(l),this.roundToByte(d),this.roundToByte(u),this.roundToByte(f))}get hasTranslucency(){for(const t of this.keys)if(!t.color.isOpaque)return!0;return!1}get isOutlined(){return 0!=(this.flags&i.Outline)}getThematicImageForRenderer(t){e(s.Thematic===this.mode,"getThematicImageForRenderer only is used for thematic display.");let i=this.thematicSettings;void 0===i&&(i=Yo.defaults);const n=Math.min(i.stepCount,t),r=yo.Smooth===i.mode?t:n,o=new Uint8Array(1*r*4);let a=o.length-1;function c(t){o[a--]=t.getAlpha(),o[a--]=t.colors.b,o[a--]=t.colors.g,o[a--]=t.colors.r}switch(i.mode){case yo.Smooth:for(let t=0;t<r;t++){const e=1-t/r;c(this.mapColor(e))}break;case yo.SteppedWithDelimiter:case yo.IsoLines:case yo.Stepped:e(i.stepCount>1,"Step count must be at least two to generate renderer gradient for thematic display");for(let t=0;t<r;t++){const e=1-t/(r-1);c(this.mapColor(e))}}e(-1===a);const h=No.create(o,mo.Rgba,1);return e(void 0!==h),h}getImage(t,e){return this.mode===s.Thematic&&(t=1),this.produceImage({width:t,height:e,includeThematicMargin:!0})}produceImage(t){const{width:i,height:n,includeThematicMargin:r}={...t},o=void 0===this.angle?0:this.angle.radians,a=Math.cos(o),c=Math.sin(o),h=new Uint8Array(i*n*4);let l=h.length-1;const d=Math.min(1,Math.abs(this.shift));switch(this.mode){case s.Linear:case s.Cylindrical:{const t=.5-.25*d*a,e=.5-.25*d*c;let r,o,u=r=0;for(let i=0;i<2;i++)for(let s=0;s<2;s++)o=(s-t)*a+(i-e)*c,o<u&&(u=o),o>r&&(r=o);for(let d=0;d<n;d++){const f=d/n-e;for(let e=0;e<i;e++){let n;o=(e/i-t)*a+f*c,n=this.mode===s.Linear?o>0?.5+.5*o/r:.5-.5*o/u:o>0?Math.sin(Math.PI/2*(1-o/r)):Math.sin(Math.PI/2*(1-o/u));const d=this.mapColor(n);h[l--]=d.getAlpha(),h[l--]=d.colors.b,h[l--]=d.colors.g,h[l--]=d.colors.r}}break}case s.Curved:{const t=.5+.5*c-.25*d*a,e=.5-.5*a-.25*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=.8*(s*a+r*c),o=r*a-s*c,d=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o))),u=this.mapColor(d);h[l--]=u.getAlpha(),h[l--]=u.colors.b,h[l--]=u.colors.g,h[l--]=u.colors.r}}break}case s.Spherical:{const t=.5+.125*Math.sin(2*o),e=.5*d*(a+c)*t,s=.5*d*(c-a)*t;for(let r=0;r<n;r++){const o=s+r/n-.5;for(let s=0;s<i;s++){const n=e+s/i-.5,r=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+o*o)/t)),a=this.mapColor(r);h[l--]=a.getAlpha(),h[l--]=a.colors.b,h[l--]=a.colors.g,h[l--]=a.colors.r}}break}case s.Hemispherical:{const t=.5+.5*c-.5*d*a,e=.5-.5*a-.5*d*c;for(let s=0;s<n;s++){const r=s/n-e;for(let e=0;e<i;e++){const s=e/i-t,n=Math.sin(Math.PI/2*(1-Math.sqrt(s*s+r*r))),o=this.mapColor(n);h[l--]=o.getAlpha(),h[l--]=o.colors.b,h[l--]=o.colors.g,h[l--]=o.colors.r}}break}case s.Thematic:{const t=this.thematicSettings??Yo.defaults;for(let e=0;e<n;e++){let s,o=1-e/n;if(r&&(o<Yo.margin||o>Yo.contentMax))s=t.marginColor;else switch(o=(o-Yo.margin)/Yo.contentRange,t.mode){case yo.SteppedWithDelimiter:case yo.IsoLines:case yo.Stepped:if(t.stepCount>1){const e=Math.floor(o*t.stepCount-1e-5)/(t.stepCount-1);s=this.mapColor(e)}break;case yo.Smooth:s=this.mapColor(o)}for(let t=0;t<i;t++)h[l--]=s.getAlpha(),h[l--]=s.colors.b,h[l--]=s.colors.g,h[l--]=s.colors.r}}}e(-1===l);const u=No.create(h,mo.Rgba,i);return e(void 0!==u),u}}r._fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]],r._fixedCustomKeys=[[0,255,0,0],[1,0,255,0]],t.Symb=r}(Po||(Po={})),function(t){t[t.Mesh=0]="Mesh",t[t.Polyline=1]="Polyline",t[t.Point=2]="Point"}(Io||(Io={})),function(t){t[t.Unlit=0]="Unlit",t[t.Lit=1]="Lit",t[t.Textured=2]="Textured",t[t.TexturedLit=3]="TexturedLit",t[t.VolumeClassifier=4]="VolumeClassifier"}(Ao||(Ao={}));class Oo{constructor(t,i,s,n=0,r=go.Solid,o=po.None,a,c,h=!1,l){this.type=Oo.Type.Mesh,this.type=t,this.material=a,this.gradient=c,this.lineColor=Oo.adjustTransparency(i),this.fillColor=Oo.adjustTransparency(s),this.width=n,this.linePixels=r,this.fillFlags=o,this.ignoreLighting=h,this._textureMapping=l,e(void 0===a||void 0===l)}static createForType(t,e,i,s=!1){const n=Oo.adjustTransparency(e.lineColor);switch(t){case Oo.Type.Mesh:{let r;if(void 0!==e.gradient&&void 0!==i){const t=i(e.gradient);void 0!==t&&(r=new Do(t,new Do.Params))}return new Oo(t,n,Oo.adjustTransparency(e.fillColor),e.rasterWidth,e.linePixels,e.fillFlags,e.material,e.gradient,s,r)}case Oo.Type.Linear:return new Oo(t,n,n,e.rasterWidth,e.linePixels);default:return new Oo(t,n,n,0,go.Solid,po.Always,void 0,void 0,!0)}}static createForMesh(t,e,i){return Oo.createForType(Oo.Type.Mesh,t,i,e)}static createForLinear(t){return Oo.createForType(Oo.Type.Linear,t)}static createForText(t){return Oo.createForType(Oo.Type.Text,t)}get regionEdgeType(){return this.hasBlankingFill?Oo.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?0!=(this.gradient.flags&Po.Flags.Outline)||po.None===(this.fillFlags&po.Always)?Oo.RegionEdgeType.Outline:Oo.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?Oo.RegionEdgeType.Default:Oo.RegionEdgeType.Outline}get wantRegionOutline(){return Oo.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return po.Blanking===(this.fillFlags&po.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(t,e=Oo.ComparePurpose.Strict){return Oo.ComparePurpose.Merge===e?0===this.compareForMerge(t):t===this||this.type===t.type&&this.ignoreLighting===t.ignoreLighting&&this.width===t.width&&this.linePixels===t.linePixels&&this.fillFlags===t.fillFlags&&this.wantRegionOutline===t.wantRegionOutline&&this.material===t.material&&this.textureMapping===t.textureMapping&&!!this.fillColor.equals(t.fillColor)&&!!this.lineColor.equals(t.lineColor)}compareForMerge(t){if(t===this)return 0;let e=i(this.type,t.type);return 0===e&&(e=s(this.ignoreLighting,t.ignoreLighting),0===e&&(e=i(this.width,t.width),0===e&&(e=i(this.linePixels,t.linePixels),0===e&&(e=i(this.fillFlags,t.fillFlags),0===e&&(e=s(this.wantRegionOutline,t.wantRegionOutline),0===e&&(e=s(this.hasFillTransparency,t.hasFillTransparency),0===e&&(e=s(this.hasLineTransparency,t.hasLineTransparency),0===e&&(e=function(t,e){return r(((t,e)=>t===e?0:o(t.key,e.key)),t,e)}(this.material,t.material),0===e&&void 0===this.material&&this.isTextured&&(this.textureMapping,t.textureMapping,e=0))))))))),e}static adjustTransparency(t){return t.colors.t<Oo.minTransparency?t.withTransparency(0):t}}Oo.minTransparency=15,function(t){let e,i,s;!function(t){t[t.Mesh=0]="Mesh",t[t.Linear=1]="Linear",t[t.Text=2]="Text"}(e=t.Type||(t.Type={})),function(t){t[t.None=0]="None",t[t.Default=1]="Default",t[t.Outline=2]="Outline"}(i=t.RegionEdgeType||(t.RegionEdgeType={})),function(t){t[t.Merge=0]="Merge",t[t.Strict=1]="Strict"}(s=t.ComparePurpose||(t.ComparePurpose={}))}(Oo||(Oo={}));const Bo=new Uint16Array(1);function Vo(t){return Lo(.5+255*(.5*function(t,e,i){return t<-1?-1:t>1?1:t}(t)+.5))}function Lo(t){return Bo[0]=t,Bo[0]}function Uo(t){return t<0?-1:1}class Zo{constructor(t){this.value=Lo(t)}static encode(t){return this.encodeXYZ(t.x,t.y,t.z)}static encodeXYZ(t,e,i){const s=Math.abs(t)+Math.abs(e)+Math.abs(i);let n=t/s,r=e/s;if(i<0){const t=n,e=r;n=(1-Math.abs(e))*Uo(t),r=(1-Math.abs(t))*Uo(e)}return Vo(r)<<8|Vo(n)}static fromVector(t){return new Zo(this.encode(t))}decode(){return Zo.decodeValue(this.value)}static decodeValue(t,e){let i=255&t,s=t>>8;i=i/255*2-1,s=s/255*2-1;const n=1-(Math.abs(i)+Math.abs(s));let r;if(void 0===e?r=new j(i,s,n):(r=e,r.x=i,r.y=s,r.z=n),r.z<0){const t=r.x,e=r.y;r.x=(1-Math.abs(e))*Uo(t),r.y=(1-Math.abs(t))*Uo(e)}return r.normalizeInPlace(),r}}function qo(t,i,s,n){const r=t*i+s;if(r<n)return{width:r,height:1};let o=Math.ceil(Math.sqrt(r));const a=o%i;0!==a&&(o+=i-a);let c=Math.ceil(r/o);return o*c<r&&++c,e(c<=n),e(o<=n),e(o*c>=r),e(Math.floor(c)===c),e(Math.floor(o)===o),e(0==o%i),{width:o,height:c}}class Wo{constructor(t){this.name=t.name,this.inputs=t.inputs,this.indices=t.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class Go extends Wo{constructor(t){super(t),this.qOrigin=Float32Array.from(t.qOrigin),this.qScale=Float32Array.from(t.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class Jo extends Wo{constructor(t){super(t),this.qOrigin=t.qOrigin[0],this.qScale=t.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class Ho{constructor(t,e,i,s){this.data=t.data,this.width=t.width,this.height=t.height,this.numVertices=t.count,this.numBytesPerVertex=t.numBytesPerVertex,this.displacements=e,this.normals=i,this.params=s}static fromJSON(t){let e,i,s;if(void 0!==t.displacements&&0<t.displacements.length){e=[];for(const i of t.displacements)e.push(new Go(i))}if(void 0!==t.normals&&0<t.normals.length){i=[];for(const e of t.normals)i.push(new Wo(e))}if(void 0!==t.params&&0<t.params.length){s=[];for(const e of t.params)s.push(new Jo(e))}return void 0!==e||void 0!==i||void 0!==s?new Ho(t,e,i,s):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((t=>t.toJSON())),normals:this.normals?.map((t=>t.toJSON())),params:this.params?.map((t=>t.toJSON()))}}static fromChannels(t,e,i){return jo.buildAuxChannelTable(t,e,i)}}function Ko(t){return 0!==t&&(t=1/t),t}class jo{constructor(t,e){this._props=t,this._numBytesPerVertex=e,this._view=new DataView(t.data.buffer)}static buildAuxChannelTable(t,i,s){const n=t.reduce(((t,e)=>t+Qo(e)),0);if(!n)return;const r=Math.floor((n+3)/4),o=4*r-n;let a;e(0===o||2===o),a=0!==o?qo(Math.floor((i+1)/2),n/2,0,s):qo(i,r,0,s);const c={data:new Uint8Array(a.width*a.height*4),width:a.width,height:a.height,count:i,numBytesPerVertex:n};return new jo(c,n).build(t),Ho.fromJSON(c)}build(t){let e=0;for(const i of t)C.Normal===i.dataType?this.addNormals(i,e):C.Vector===i.dataType?this.addDisplacements(i,e):this.addParams(i,e),e+=Qo(i)}addNormals(t,e){const i=[],s=[],n=new j;for(let r=0;r<t.data.length;r++){let o=e+2*r;s.push(o/2);const a=t.data[r];i.push(a.input);for(let t=0;t<a.values.length;t+=3){n.x=a.values[t],n.y=a.values[t+1],n.z=a.values[t+2],n.normalizeInPlace();const e=Zo.encode(n);this._view.setUint16(o,e,!0),o+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:t.name??"",inputs:i,indices:s})}addParams(t,e){const i=[],s=[],n=dt.createNull();for(const e of t.data)i.push(e.input),n.extendArray(e.values);const r=ao.computeScale(n.high-n.low);for(let i=0;i<t.data.length;i++){let o=e+2*i;s.push(o/2);for(const e of t.data[i].values){const t=ao.quantize(e,n.low,r);this._view.setUint16(o,t,!0),o+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:[n.low],qScale:[Ko(r)]})}addDisplacements(t,e){const i=[],s=[],n=new K,r=lt.createNull();for(const e of t.data){i.push(e.input);for(let t=0;t<e.values.length;t+=3)n.set(e.values[t],e.values[t+1],e.values[t+2]),r.extend(n)}const o=bo.fromRange(r),a=new Eo;for(let i=0;i<t.data.length;i++){let r=e+6*i;s.push(r/2);const c=t.data[i];for(let t=0;t<c.values.length;t+=3)n.set(c.values[t],c.values[t+1],c.values[t+2]),a.init(n,o),this._view.setUint16(r+0,a.x,!0),this._view.setUint16(r+2,a.y,!0),this._view.setUint16(r+4,a.z,!0),r+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:i,indices:s,name:t.name??"",qOrigin:o.origin.toArray(),qScale:o.scale.toArray().map((t=>Ko(t)))})}}function Qo(t){const e=t.data.length;switch(t.dataType){case C.Vector:return 6*e;case C.Normal:case C.Distance:case C.Scalar:return 2*e}}class $o{constructor(t,e){this._constructor=t,this._data=new t(e?.initialCapacity??0),this.growthFactor=Math.max(1,e?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(t){t<0&&(t=this.length-t);const i=this._data[t];return e(void 0!==i,"index out of bounds"),i}ensureCapacity(t){if(this.capacity>=t)return this.capacity;e(this.growthFactor>=1),t=Math.ceil(t*this.growthFactor);const i=this._data;return this._data=new this._constructor(t),this._data.set(i,0),e(this.capacity===t),this.capacity}push(t){this.ensureCapacity(this.length+1),this._data[this.length]=t,++this._length}append(t){const e=this.length+t.length;this.ensureCapacity(e),this._data.set(t,this.length),this._length=e}toTypedArray(t=!1){if(t)return this._data;const i=this._data.subarray(0,this.length);return e(i instanceof this._constructor),e(i.buffer===this._data.buffer),i}}class ta extends $o{constructor(t){super(Uint8Array,t)}}class ea extends $o{constructor(t){super(Uint32Array,t)}toUint8Array(t=!1){return t?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function ia(t,e,i){let s=Math.ceil(1.5*t+2.5*e);const n=6*t;let r=0,o=s,a=1;if(s>=i){o=Math.ceil(Math.sqrt(s));const i=o%15;0!==i&&(o+=15-i),e>0&&t>0&&(r=(60-n%60)%10,s+=Math.ceil(r/4)),a=Math.ceil(s/o),o*a<s&&a++}return{width:o,height:a,silhouettePadding:r,silhouetteStartByteIndex:n}}class sa{constructor(t){this.data=t,e(0==this.data.length%3)}get length(){return this.data.length/3}static fromArray(t){const e=new Uint8Array(3*t.length);for(let i=0;i<t.length;i++)this.encodeIndex(t[i],e,3*i);return new sa(e)}static encodeIndex(t,i,s){e(s+2<i.length),i[s+0]=255&t,i[s+1]=(65280&t)>>8,i[s+2]=(16711680&t)>>16}setNthIndex(t,e){sa.encodeIndex(e,this.data,3*t)}decodeIndex(t){e(t<this.length);const i=3*t;return this.data[i]|this.data[i+1]<<8|this.data[i+2]<<16}decodeIndices(){const t=[];for(let e=0;e<this.length;e++)t.push(this.decodeIndex(e));return t}[Symbol.iterator](){return function*(t){for(let e=0;e<t.length;e++)yield t.decodeIndex(e)}(this)}}class na{constructor(t=3){this._index32=new Uint32Array(1),this._index8=new Uint8Array(this._index32.buffer,0,3),this._builder=new ta({initialCapacity:3*t})}get numIndices(){return e(this._builder.length%3==0),this._builder.length/3}push(t){this._index32[0]=t,this._builder.append(this._index8)}toVertexIndices(){return new sa(this._builder.toTypedArray())}}class ra{constructor(t){this._source=t,this._builder=new ea({initialCapacity:3*t.numRgbaPerVertex})}get length(){return e(this._builder.length%this.vertexSize==0),this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(t){e(t.length===this.vertexSize),this._builder.append(t)}buildVertexTable(t,i,s){const n=this._source;e(void 0!==(i=i??n.uniformColor));const r=i instanceof Uint32Array?i.length:0,o=s instanceof Uint32Array?s.length:0,a=qo(this.length,this.vertexSize,r+o,t);let c=this._builder.toTypedArray();if(a.width*a.height>c.length){const t=c;c=new Uint32Array(a.width*a.height),c.set(t,0)}let h=this.vertexSize*this.length;return i instanceof Uint32Array&&(c.set(i,h),h+=i.length),s instanceof Uint32Array&&c.set(s,h),{data:new Uint8Array(c.buffer,c.byteOffset,c.byteLength),usesUnquantizedPositions:n.usesUnquantizedPositions,qparams:n.qparams,width:a.width,height:a.height,hasTranslucency:n.hasTranslucency,uniformColor:i instanceof Ir?i:void 0,featureIndexType:n.featureIndexType,uniformFeatureID:n.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:n.numRgbaPerVertex,uvParams:n.uvParams}}}class oa{constructor(t){this._remappedIndices=new Map,this.colors=[],this._32=new Uint32Array(1),this._16=new Uint16Array(this._32.buffer),this._colorTable=t}remap(t,e){const i=e?4:1,s=e?0:1;this._32[0]=t[i];const n=this._16[s];let r=this._remappedIndices.get(n);if(void 0===r){r=this.colors.length,this._remappedIndices.set(n,r);const t=this._colorTable[n];this.colors.push(t)}this._16[s]=r,t[i]=this._32[0]}buildColorTable(){return e(this.colors.length>0),this.colors.length>1?new Uint32Array(this.colors):Ir.fromAbgr(this.colors[0])}}class aa{constructor(t,e){this._remappedIndices=new Map,this.materials=[],this._32=new Uint32Array(1),this._8=new Uint8Array(this._32.buffer),this._atlasTable=t,this._createMaterial=e}remap(t,e){const i=e?3:2;this._32[0]=t[i];const s=this._8[3];let n=this._remappedIndices.get(s);if(void 0===n){n=this.materials.length/4,this._remappedIndices.set(s,n);let t=4*s;this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t])}this._8[3]=n,t[i]=this._32[0]}unpackFloat(t){this._32[0]=t;const e=this._32[0],i=(e>>>24)/2;let s=Math.floor(i),n=2*(i-s);return n=-(2*n-1),s-=38,n*(16777215&e)/16777216*Math.pow(10,s)}materialFromAtlasEntry(t){const e=0!=(16777216&t[1]),i={alpha:0!=(33554432&t[1])?(t[0]>>>24)/255:void 0,diffuse:{color:e?Ir.fromTbgr(16777215&t[0]):void 0,weight:(t[1]>>>8)/255},specular:{color:Ir.fromTbgr(t[2]),weight:(t[1]>>>16&255)/255,exponent:this.unpackFloat(t[3])}};return void 0===(s=this._createMaterial(i))?void 0:{isAtlas:!1,material:s};var s}buildAtlasTable(){e(this.materials.length>0);const t=new Uint32Array(this.materials);return this.materials.length>4?t:this.materialFromAtlasEntry(t)}}class ca{constructor(t,e){if(this.remappedIndices=new Map,this.indices=new na,this.vertices=new ra(t),void 0===t.uniformColor&&(this.colors=new oa(new Uint32Array(t.data.buffer,t.data.byteOffset+4*t.numVertices*t.numRgbaPerVertex))),e){const i=4*(t.numVertices*t.numRgbaPerVertex+e.offset);this.atlas=new aa(new Uint32Array(t.data.buffer,t.data.byteOffset+i),e.createMaterial)}this.usesUnquantizedPositions=t.usesUnquantizedPositions}addVertex(t,e){let i=this.remappedIndices.get(t);void 0===i&&(i=this.vertices.length,this.remappedIndices.set(t,i),this.colors?.remap(e,this.usesUnquantizedPositions),this.atlas?.remap(e,this.usesUnquantizedPositions),this.vertices.push(e)),this.indices.push(i)}buildOutput(t){const e=this.atlas?.buildAtlasTable(),i=e instanceof Uint32Array?void 0:e;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(t,this.colors?.buildColorTable(),e),material:i}}}class ha{constructor(t,e){this._nodes=new Map,this._input=t,this._computeNodeId=e}static split(t,e){const i=new ha(t,e);return i.split(),i._nodes}split(){const t={featureIndex:-1,node:void 0},e=this._input.vertices.numRgbaPerVertex,i=new Uint32Array(e),s=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*e);for(const n of this._input.indices){const r=n*e;for(let t=0;t<i.length;t++)i[t]=s[r+t];const o=16777215&i[2];if(t.featureIndex!==o){t.featureIndex=o;const e=this._computeNodeId(o);let i=this._nodes.get(e);void 0===i&&this._nodes.set(e,i=new ca(this._input.vertices,this._input.atlasInfo)),t.node=i}t.node.addVertex(n,i)}}}function la(t){const e=ha.split({indices:t.params.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),i=new Map;for(const[s,n]of e){const{vertices:e,indices:r}=n.buildOutput(t.maxDimension);i.set(s,{vertices:e,indices:r,weight:t.params.weight})}return i}class da{constructor(){this.indices=new na,this.prevIndices=new na,this.nextIndicesAndParams=new ea}}function ua(t,i,s){for(const[e,n]of s){const s=n.remappedIndices.get(i);if(void 0!==s)return t.index=s,t.node=n,t.id=e,!0}return e(!1),!1}function fa(t,i,s,n){const r=i[t];if(!r)return;const o=new Uint32Array(r.endPointAndQuadIndices.buffer,r.endPointAndQuadIndices.byteOffset,r.endPointAndQuadIndices.length/4);let a;"silhouettes"===t&&(e(void 0!==i.silhouettes),a=new Uint32Array(i.silhouettes.normalPairs.buffer,i.silhouettes.normalPairs.byteOffset,i.silhouettes.normalPairs.length/4));let c=0;const h={};for(const i of r.indices){if(ua(h,i,s)){let i=o[c];const s=(16777215&i)>>>0,r=h.node.remappedIndices.get(s);e(void 0!==r),i=4278190080&i|r;let l=n.get(h.id);l||n.set(h.id,l={}),a?(l.silhouettes||(l.silhouettes={indices:new na,endPointAndQuadIndices:new ea,normalPairs:new ea}),l.silhouettes.normalPairs.push(a[c])):l.segments||(l.segments={indices:new na,endPointAndQuadIndices:new ea});const d=l[t];e(void 0!==d),d.indices.push(h.index),d.endPointAndQuadIndices.push(i)}++c}}function ga(t){const i=new Map,s=t.params.surface.material,n=void 0!==s&&s.isAtlas?s.vertexTableOffset:void 0,r=n?{offset:n,createMaterial:t.createMaterial}:void 0,o=ha.split({indices:t.params.surface.indices,vertices:t.params.vertices,featureTable:t.featureTable,atlasInfo:r},t.computeNodeId),a=t.params.edges?function(t,i,s){const n=new Map;fa("segments",t,i,n),fa("silhouettes",t,i,n),t.polylines&&function(t,i,s){const n=new Uint32Array(t.nextIndicesAndParams.buffer,t.nextIndicesAndParams.byteOffset,t.nextIndicesAndParams.length/4),r=t.prevIndices[Symbol.iterator]();let o=0;const a={};for(const c of t.indices){if(ua(a,c,i)){const t=r.next().value;e(void 0!==t);const i=a.node.remappedIndices.get(t);e(void 0!==i);let c=n[o];const h=(16777215&c)>>>0,l=a.node.remappedIndices.get(h);e(void 0!==l),c=4278190080&c|l;let d=s.get(a.id);d||s.set(a.id,d={}),d.polylines||(d.polylines=new da),d.polylines.indices.push(a.index),d.polylines.prevIndices.push(i),d.polylines.nextIndicesAndParams.push(c)}++o}}(t.polylines,i,n),t.indexed&&function(t,i,s){const n=t.edges.data,r=t.edges.numSegments,o=6*r+t.edges.silhouettePadding;function a(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16]}function c(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16,n[t+6]|n[t+7]<<8,n[t+8]|n[t+9]<<8]}function h(t,e,i,s,n){t.silhouettes.push(255&e),t.silhouettes.push((65280&e)>>>8),t.silhouettes.push((16711680&e)>>>16),t.silhouettes.push(255&i),t.silhouettes.push((65280&i)>>>8),t.silhouettes.push((16711680&i)>>>16),t.silhouettes.push(255&s),t.silhouettes.push((65280&s)>>>8),t.silhouettes.push(255&n),t.silhouettes.push((65280&n)>>>8)}let l=0;for(const e of t.indices)l=Math.max(e,l);const d={};let u=0,f=0,g=0,p=0;for(let t=0,n=0;t<=l;++t)if(t<r?([u,f]=a(n),n+=6):(n=o+10*(t-r),[u,f,g,p]=c(n)),ua(d,u,i)){let i=s.get(d.id);if(i||s.set(d.id,i={}),i.indexed||(i.indexed={edges:new ta,silhouettes:new ta}),t<r){const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),x=t,y=s,(m=i.indexed).edges.push(255&x),m.edges.push((65280&x)>>>8),m.edges.push((16711680&x)>>>16),m.edges.push(255&y),m.edges.push((65280&y)>>>8),m.edges.push((16711680&y)>>>16)}else{const t=d.node.remappedIndices.get(u);e(void 0!==t);const s=d.node.remappedIndices.get(f);e(void 0!==s),h(i.indexed,t,s,g,p)}}var m,x,y}(t.indexed,i,n);const r=new Map;for(const[e,i]of n){if(!i.segments&&!i.silhouettes&&!i.indexed)continue;let n={},o={};if(i.indexed){const t=i.indexed.edges.length/6,e=i.indexed.silhouettes.length/10,{width:r,height:a,silhouettePadding:c,silhouetteStartByteIndex:h}=ia(t,e,s),l=new Uint8Array(r*a*4);l.set(i.indexed.edges.toTypedArray(),0),e>0&&l.set(i.indexed.silhouettes.toTypedArray(),h+c);const d=t+e;o=new sa(new Uint8Array(6*d*3));for(let t=0;t<d;t++)for(let e=0;e<6;e++)o.setNthIndex(6*t+e,t);n={data:l,width:r,height:a,numSegments:t,silhouettePadding:c}}r.set(e,{weight:t.weight,linePixels:t.linePixels,segments:i.segments?{indices:i.segments.indices.toVertexIndices(),endPointAndQuadIndices:i.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:i.silhouettes?{indices:i.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:i.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:i.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:i.polylines?{indices:i.polylines.indices.toVertexIndices(),prevIndices:i.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:i.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:i.indexed?{indices:o,edges:n}:void 0})}return r}(t.params.edges,o,t.maxDimension):void 0;for(const[e,s]of o){const{vertices:n,indices:r,material:o}=s.buildOutput(t.maxDimension),c={vertices:n,surface:{type:t.params.surface.type,indices:r,fillFlags:t.params.surface.fillFlags,hasBakedLighting:t.params.surface.hasBakedLighting,textureMapping:t.params.surface.textureMapping,material:void 0!==o?o:t.params.surface.material},edges:a?.get(e),isPlanar:t.params.isPlanar,auxChannels:t.params.auxChannels};i.set(e,c)}return i}function pa(t){const i=ha.split({indices:t.params.polyline.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),s=t.params.polyline,n=new Uint32Array(s.nextIndicesAndParams.buffer,s.nextIndicesAndParams.byteOffset,s.nextIndicesAndParams.length/4);let r=0;const o={};for(const t of s.prevIndices){if(ua(o,t,i)){const t=o.node;t.prevIndices?e(void 0!==t.nextIndicesAndParams):(e(void 0===t.nextIndicesAndParams),t.prevIndices=new na(t.indices.numIndices),t.nextIndicesAndParams=new ea({initialCapacity:t.indices.numIndices})),t.prevIndices.push(o.index);let i=n[r];const s=(16777215&i)>>>0,a=o.node.remappedIndices.get(s);e(void 0!==a),i=4278190080&i|a,t.nextIndicesAndParams.push(i)}++r}const a=new Map;for(const[s,n]of i){e(void 0!==n.prevIndices&&void 0!==n.nextIndicesAndParams);const{vertices:i,indices:r}=n.buildOutput(t.maxDimension),o={...t.params,vertices:i,polyline:{indices:r,prevIndices:n.prevIndices.toVertexIndices(),nextIndicesAndParams:n.nextIndicesAndParams.toUint8Array()}};a.set(s,o)}return a}var ma;!function(t){t[t.Untransformed=4294967295]="Untransformed"}(ma||(ma={}));class xa extends wo{get isValid(){return io.Gltf===this.format}constructor(t){super(t),this.scenePosition=0,this.sceneStrLength=0,this.binaryPosition=0,this.gltfLength=t.readUint32(),this.sceneStrLength=t.readUint32();const e=t.readUint32();if(this.version===ro.Version2&&e===ro.Gltf1SceneFormat&&(this.version=ro.Version1),this.version===ro.Version1){const i=e;if(ro.Gltf1SceneFormat!==i)return void this.invalidate();this.scenePosition=t.curPos,this.binaryPosition=t.curPos+this.sceneStrLength}else if(this.version===ro.Version2){const i=e;this.scenePosition=t.curPos,t.curPos=t.curPos+this.sceneStrLength;const s=t.readUint32(),n=t.readUint32();if(oo.JSON!==i||oo.Binary!==n||0===s)return void this.invalidate();this.binaryPosition=t.curPos}else this.invalidate()}}const ya=/Node_(.*)/;function _a(t){const i=t.match(ya);if(e(!!i&&2===i.length),!i||2!==i.length)return 0;const s=Number.parseInt(i[1],10);return e(!Number.isNaN(s)),Number.isNaN(s)?0:s}class va extends To{constructor(t){super(t)}dispose(){}get bytesUsed(){return 0}}class Pa extends va{constructor(t,e){super(e),this._name=t}toImdl(){return this._name}}class Ia extends va{constructor(t){super(To.Type.Normal),this._gradient=t}toImdl(){return this._gradient}}class Aa extends ko{toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(t,e){super(t),this.materialParams=e??{alpha:t.alpha,diffuse:{color:t.diffuseColor?.toJSON(),weight:t.diffuse},specular:{color:t.specularColor?.toJSON(),weight:t.specular,exponent:t.specularExponent}}}static create(t){const e=new ko.Params;return e.alpha=t.alpha,t.diffuse&&(void 0!==t.diffuse.weight&&(e.diffuse=t.diffuse?.weight),t.diffuse?.color&&(e.diffuseColor=t.diffuse.color instanceof Ir?t.diffuse.color:Ar.fromJSON(t.diffuse.color).toColorDef())),t.specular&&(void 0!==t.specular.weight&&(e.specular=t.specular.weight),void 0!==t.specular.exponent&&(e.specularExponent=t.specular.exponent),t.specular.color&&(e.specularColor=t.specular.color instanceof Ir?t.specular.color:Ar.fromJSON(t.specular.color).toColorDef())),new Aa(e)}}function Sa(t){return{...t,uniformColor:void 0!==t.uniformColor?Ir.fromJSON(t.uniformColor):void 0,qparams:bo.fromJSON(t.qparams),uvParams:t.uvParams?Fo.fromJSON(t.uvParams):void 0}}function wa(t){return{...t,uniformColor:t.uniformColor?.toJSON(),qparams:t.qparams.toJSON(),uvParams:t.uvParams?.toJSON()}}function Ca(t){return{...t,segments:t.segments?{...t.segments,indices:t.segments.indices.data}:void 0,silhouettes:t.silhouettes?{...t.silhouettes,indices:t.silhouettes.indices.data}:void 0,polylines:t.polylines?{...t.polylines,indices:t.polylines.indices.data,prevIndices:t.polylines.prevIndices.data}:void 0,indexed:t.indexed?{indices:t.indexed.indices.data,edges:t.indexed.edges}:void 0}}class Ta{constructor(t,e,i,s,n){this._patterns=new Map,this._document=t,this._binaryData=e,this._options=i,this._featureTableInfo=s,this._stream=n,this._timeline=i.timeline}parse(){const t=this.parseFeatureTable();if(!t)return so.InvalidFeatureTable;const e=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0;return{featureTable:t,nodes:this.parseNodes(t),rtcCenter:e,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const t=Ro.readFrom(this._stream);if(!t||0!=t.length%4)return;const e=(t.length-Ro.sizeInBytes)/4,i=new Uint32Array(this._stream.nextUint32s(e));if(this._stream.isPastTheEnd)return;let s;if(this._featureTableInfo.multiModel)s={multiModel:!0,data:i,numFeatures:t.count,numSubCategories:t.numSubCategories};else{let e;const n=this._document.animationNodes;if(void 0!==n){const t=jr.asInt(n.bytesPerId),i=jr.asString(n.bufferView),s=this._document.bufferViews[i];if(void 0!==s){const i=jr.asInt(s.byteOffset),n=jr.asInt(s.byteLength),r=this._binaryData.subarray(i,i+n);switch(t){case 1:e=new Uint8Array(r);break;case 2:e=Uint16Array.from(new Uint16Array(r.buffer,r.byteOffset,r.byteLength/2));break;case 4:e=Uint32Array.from(new Uint32Array(r.buffer,r.byteOffset,r.byteLength/4))}}}s={multiModel:!1,data:i,numFeatures:t.count,animationNodeIds:e}}return this._stream.curPos=this._featureTableInfo.startPos+t.length,s}parseNodes(t){const i=[],s=this._document.nodes,n=this._document.meshes;if(void 0===s.Node_Root)return i;for(const r of Object.keys(s)){const s=this._document.nodes[r];e(void 0!==s);const o=n[s],a=o?.primitives;if(!a)continue;const c=o.layer;"Node_Root"===r?this._timeline?this.parseAnimationBranches(i,o,t,this._timeline):this._options.createUntransformedRootNode?i.push({animationNodeId:ma.Untransformed,primitives:this.parseNodePrimitives(a)}):i.push({primitives:this.parseNodePrimitives(a)}):void 0===c?i.push({animationNodeId:_a(r),animationId:`${this._options.batchModelId}_${r}`,primitives:this.parseNodePrimitives(a)}):i.push({layerId:c,primitives:this.parseNodePrimitives(a)})}return i}parseAnimationBranches(t,i,s,n){const r=i.primitives;if(!r)return;const o=new Map,a=e=>{let i=o.get(e);return i||(i={animationNodeId:e,animationId:`${this._options.batchModelId}_Node_${e}`,primitives:[]},o.set(e,i),t.push(i)),i};e(void 0===s.animationNodeIds);const c=function(t,e){const i=t.multiModel?Or.create(t.data,e,t.numFeatures,br.Primary,t.numSubCategories):new Dr(t.data,e,t.numFeatures,br.Primary);return i.animationNodeIds=t.animationNodeIds,i}(s,this._options.batchModelId);c.populateAnimationNodeIds((t=>n.getBatchIdForFeature(t)),n.maxBatchId),s.animationNodeIds=c.animationNodeIds;const h=n.discreteBatchIds,l={maxDimension:this._options.maxVertexTableSize,computeNodeId:t=>{const e=c.getAnimationNodeId(t);return 0!==e&&h.has(e)?e:0},featureTable:c},d=t=>{if(!t)return;if(t.isAtlas)return t;const e="string"==typeof t.material?this.materialFromJson(t.material):Aa.create(function(t){const e={alpha:t.alpha};return t.diffuse&&(e.diffuse={weight:t.diffuse.weight,color:void 0!==t.diffuse.color?Ir.fromJSON(t.diffuse.color):void 0}),t.specular&&(e.specular={weight:t.specular.weight,exponent:t.specular.exponent,color:void 0!==t.specular.color?Ir.fromJSON(t.specular.color):void 0}),e}(t.material));return e?{isAtlas:!1,material:e}:void 0};for(const t of r){const i=this.parseNodePrimitive(t);if(i)switch(i.type){case"pattern":a(ma.Untransformed).primitives.push(i);break;case"mesh":{const t=i.params,s=t.surface.textureMapping,n={vertices:Sa(i.params.vertices),surface:{...i.params.surface,indices:new sa(i.params.surface.indices),material:d(t.surface.material),textureMapping:s?{alwaysDisplayed:s.alwaysDisplayed,texture:"string"==typeof s.texture?new Pa(s.texture,To.Type.Normal):new Ia(s.texture)}:void 0},edges:i.params.edges?(u=i.params.edges,{...u,segments:u.segments?{...u.segments,indices:new sa(u.segments.indices)}:void 0,silhouettes:u.silhouettes?{...u.silhouettes,indices:new sa(u.silhouettes.indices)}:void 0,polylines:u.polylines?{...u.polylines,indices:new sa(u.polylines.indices),prevIndices:new sa(u.polylines.prevIndices)}:void 0,indexed:u.indexed?{indices:new sa(u.indexed.indices),edges:u.indexed.edges}:void 0}):void 0,isPlanar:i.params.isPlanar,auxChannels:i.params.auxChannels?Ho.fromJSON(i.params.auxChannels):void 0},r=ga({...l,params:n,createMaterial:t=>Aa.create(t)});for(const[t,i]of r){let s;i.surface.material&&(i.surface.material.isAtlas?s=i.surface.material:(e(i.surface.material.material instanceof Aa),s=i.surface.material.material.toImdl())),e(void 0===i.surface.textureMapping||i.surface.textureMapping.texture instanceof va),a(t).primitives.push({type:"mesh",params:{vertices:wa(i.vertices),surface:{...i.surface,indices:i.surface.indices.data,material:s,textureMapping:i.surface.textureMapping?.texture instanceof va?{texture:i.surface.textureMapping.texture.toImdl(),alwaysDisplayed:i.surface.textureMapping.alwaysDisplayed}:void 0},edges:i.edges?Ca(i.edges):void 0,isPlanar:i.isPlanar,auxChannels:i.auxChannels?.toJSON()}})}break}case"point":{const t={vertices:Sa(i.params.vertices),indices:new sa(i.params.indices),weight:i.params.weight},e=la({...l,params:t});for(const[t,i]of e)a(t).primitives.push({type:"point",params:{vertices:wa(i.vertices),indices:i.indices.data,weight:i.weight}});break}case"polyline":{const t={...i.params,vertices:Sa(i.params.vertices),polyline:{indices:new sa(i.params.polyline.indices),prevIndices:new sa(i.params.polyline.prevIndices),nextIndicesAndParams:i.params.polyline.nextIndicesAndParams}},e=pa({...l,params:t});for(const[t,i]of e)a(t).primitives.push({type:"polyline",params:{...i,vertices:wa(i.vertices),polyline:{indices:i.polyline.indices.data,prevIndices:i.polyline.prevIndices.data,nextIndicesAndParams:i.polyline.nextIndicesAndParams}}});break}}}var u}parseTesselatedPolyline(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.prevIndices),s=this.findBuffer(t.nextIndicesAndParams);return e&&i&&s?{indices:e,prevIndices:i,nextIndicesAndParams:s}:void 0}parseSegmentEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.endPointAndQuadIndices);return e&&i?{indices:e,endPointAndQuadIndices:i}:void 0}parseSilhouetteEdges(t){const e=this.parseSegmentEdges(t),i=this.findBuffer(t.normalPairs);return e&&i?{...e,normalPairs:i}:void 0}parseIndexedEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.edges);if(e&&i)return{indices:e,edges:{data:i,width:t.width,height:t.height,silhouettePadding:t.silhouettePadding,numSegments:t.numSegments}}}parseEdges(t,e){if(!t)return;const i=t.segments?this.parseSegmentEdges(t.segments):void 0,s=t.silhouettes?this.parseSilhouetteEdges(t.silhouettes):void 0,n=t.indexed?this.parseIndexedEdges(t.indexed):void 0,r=t.polylines?this.parseTesselatedPolyline(t.polylines):void 0;return i||s||n||r?{segments:i,silhouettes:s,polylines:r,indexed:n,weight:e.width,linePixels:e.linePixels}:void 0}getPattern(t){let e=this._patterns.get(t);if(!e){const i=this._document.patternSymbols[t];e=i?this.parsePrimitives(i.primitives):[],this._patterns.set(t,e)}return e.length>0?e:void 0}parseAreaPattern(t){const e=this.getPattern(t.symbolName);if(!e||0===e.length)return;const i=this.findBuffer(t.xyOffsets);return i?{type:"pattern",params:{...t,xyOffsets:new Float32Array(i.buffer,i.byteOffset,i.byteLength/4)}}:void 0}parseNodePrimitives(t){const e=[];for(const i of t){const t=this.parseNodePrimitive(i);t&&e.push(t)}return e}parseNodePrimitive(t){return"areaPattern"===t.type?this.parseAreaPattern(t):this.parsePrimitive(t)}parsePrimitives(t){const e=[];for(const i of t){const t=this.parsePrimitive(i);t&&e.push(t)}return e}parsePrimitive(t){let e=this.parseInstances(t);if(!e&&t.viewIndependentOrigin){const i=K.fromJSON(t.viewIndependentOrigin);e={type:"viewIndependentOrigin",origin:{x:i.x,y:i.y,z:i.z}}}const i=t.material??"",s=i.length?jr.asObject(this._document.materials[i]):void 0,n=s?this.parseDisplayParams(s):void 0;if(!n)return;const r=this.parseVertexTable(t);if(!r)return;let o;const a=!this._options.is3d||jr.asBool(t.isPlanar);switch(t.type){case Io.Mesh:{const e=this.parseSurface(t,n);e&&(o={type:"mesh",params:{vertices:r,surface:e,isPlanar:a,auxChannels:this.parseAuxChannelTable(t),edges:this.parseEdges(t.edges,n)}});break}case Io.Polyline:{const e=this.parseTesselatedPolyline(t);if(e){let t=fo.Normal;Oo.RegionEdgeType.Outline===n.regionEdgeType&&(t=!n.gradient||n.gradient.isOutlined?fo.Edge:fo.Outline),o={type:"polyline",params:{vertices:r,polyline:e,isPlanar:a,type:t,weight:n.width,linePixels:n.linePixels}}}break}case Io.Point:{const e=this.findBuffer(t.indices),i=n.width;e&&(o={type:"point",params:{vertices:r,indices:e,weight:i}});break}}return o&&(o.modifier=e),o}parseSurface(t,i){const s=t.surface;if(!s)return;const n=this.findBuffer(s.indices);if(!n)return;const r=s.type;if(!function(t){switch(t){case Ao.Unlit:case Ao.Lit:case Ao.Textured:case Ao.TexturedLit:case Ao.VolumeClassifier:return!0;default:return!1}}(r))return;const o=i.textureMapping?.texture;let a;const c=t.vertices.materialAtlas,h=t.vertices.numColors;let l;return c&&void 0!==h?a={isAtlas:!0,hasTranslucency:jr.asBool(c.hasTranslucency),overridesAlpha:jr.asBool(c.overridesAlpha,!1),vertexTableOffset:jr.asInt(h),numMaterials:jr.asInt(c.numMaterials)}:i.material&&(e(i.material instanceof Aa),a=i.material.toImdl()),o&&(e(o instanceof va),l={texture:o.toImdl(),alwaysDisplayed:jr.asBool(s.alwaysDisplayTexture)}),{type:r,indices:n,fillFlags:i.fillFlags,hasBakedLighting:!1,material:a,textureMapping:l}}parseAuxChannelTable(t){const e=t.auxChannels;if(void 0===e)return;const i=this.findBuffer(jr.asString(e.bufferView));return void 0!==i?{data:i,width:e.width,height:e.height,count:e.count,numBytesPerVertex:e.numBytesPerVertex,displacements:e.displacements,normals:e.normals,params:e.params}:void 0}parseVertexTable(t){const e=t.vertices;if(!e)return;const i=this.findBuffer(jr.asString(e.bufferView));if(!i)return;const s=void 0!==e.featureID?jr.asInt(e.featureID):void 0,n=jr.asArray(e.params.decodedMin),r=jr.asArray(e.params.decodedMax);if(void 0===n||void 0===r)return;const o=bo.fromRange(lt.create(K.create(n[0],n[1],n[2]),K.create(r[0],r[1],r[2]))),a=void 0!==e.uniformColor?Ir.fromJSON(e.uniformColor):void 0;let c;if(Io.Mesh===t.type&&t.surface&&t.surface.uvParams){const e=t.surface.uvParams.decodedMin,i=t.surface.uvParams.decodedMax,s=new ut(e[0],e[1],i[0],i[1]);c=Fo.fromRange(s)}return{data:i,usesUnquantizedPositions:!0===e.usesUnquantizedPositions,qparams:o.toJSON(),width:e.width,height:e.height,hasTranslucency:e.hasTranslucency,uniformColor:a?.toJSON(),featureIndexType:e.featureIndexType,uniformFeatureID:s,numVertices:e.count,numRgbaPerVertex:e.numRgbaPerVertex,uvParams:c?.toJSON()}}parseInstances(t){const i=t.instances;if(!i)return;const s=jr.asInt(i.count,0);if(s<=0)return;const n=jr.asArray(i.transformCenter);if(void 0===n||3!==n.length)return;const r=K.create(n[0],n[1],n[2]),o=this.findBuffer(jr.asString(i.featureIds));if(void 0===o)return;const a=this.findBuffer(jr.asString(i.transforms));if(void 0===a)return;const c=a.byteLength/4;e(Math.floor(c)===c),e(0==c%12);const h=new Float32Array(a.buffer,a.byteOffset,c);let l;return void 0!==i.symbologyOverrides&&(l=this.findBuffer(jr.asString(i.symbologyOverrides))),{type:"instances",count:s,transforms:h,transformCenter:r,featureIds:o,symbologyOverrides:l}}findBuffer(t){if("string"!=typeof t||0===t.length)return;const e=this._document.bufferViews[t];if(void 0===e)return;const i=jr.asInt(e.byteOffset),s=jr.asInt(e.byteLength);return 0!==s?this._binaryData.subarray(i,i+s):void 0}colorDefFromMaterialJson(t){return void 0!==t?Ir.from(255*t[0]+.5,255*t[1]+.5,255*t[2]+.5):void 0}materialFromJson(t){const e=this._document.renderMaterials[t];if(!e)return;const i=new ko.Params(t);return i.diffuseColor=this.colorDefFromMaterialJson(e.diffuseColor),void 0!==e.diffuse&&(i.diffuse=jr.asDouble(e.diffuse)),i.specularColor=this.colorDefFromMaterialJson(e.specularColor),void 0!==e.specular&&(i.specular=jr.asDouble(e.specular)),i.reflectColor=this.colorDefFromMaterialJson(e.reflectColor),void 0!==e.reflect&&(i.reflect=jr.asDouble(e.reflect)),void 0!==e.specularExponent&&(i.specularExponent=e.specularExponent),void 0!==e.transparency&&(i.alpha=1-e.transparency),i.refract=jr.asDouble(e.refract),i.shadows=jr.asBool(e.shadows),i.ambient=jr.asDouble(e.ambient),void 0!==e.textureMapping&&(i.textureMapping=this.textureMappingFromJson(e.textureMapping.texture)),new Aa(i)}parseNamedTexture(t,e){const i=jr.asBool(t.isGlyph)?To.Type.Glyph:jr.asBool(t.isTileSection)?To.Type.TileSection:To.Type.Normal;return new Pa(e,i)}parseConstantLodProps(t){if(void 0!==t)return{repetitions:jr.asDouble(t.repetitions,1),offset:{x:t.offset?jr.asDouble(t.offset[0]):0,y:t.offset?jr.asDouble(t.offset[1]):0},minDistClamp:jr.asDouble(t.minDistClamp,1),maxDistClamp:jr.asDouble(t.maxDistClamp,4294967296)}}textureMappingFromJson(t){if(!t)return;const e=jr.asString(t.name),i=0!==e.length?this._document.namedTextures[e]:void 0,s=i?this.parseNamedTexture(i,e):void 0;if(!s)return;const n=t.params,r=n.transform,o={textureMat2x3:new Do.Trans2x3(r[0][0],r[0][1],r[0][2],r[1][0],r[1][1],r[1][2]),textureWeight:jr.asDouble(n.weight,1),mapMode:jr.asInt(n.mode),worldMapping:jr.asBool(n.worldMapping),useConstantLod:jr.asBool(n.useConstantLod),constantLodProps:this.parseConstantLodProps(n.constantLodParams)},a=new Do(s,new Do.Params(o)),c=t.normalMapParams;if(c){const t=jr.asString(c.textureName),e=t.length>0?this._document.namedTextures[t]:void 0,i=e?this.parseNamedTexture(e,t):void 0;i&&(a.normalMapParams={normalMap:i,greenUp:jr.asBool(c.greenUp),scale:jr.asDouble(c.scale,1),useConstantLod:jr.asBool(c.useConstantLod)})}return a}parseDisplayParams(t){const i=jr.asInt(t.type,Oo.Type.Mesh),s=Ir.create(jr.asInt(t.lineColor)),n=Ir.create(jr.asInt(t.fillColor)),r=jr.asInt(t.lineWidth),o=jr.asInt(t.linePixels,go.Solid),a=jr.asInt(t.fillFlags,po.None),c=jr.asBool(t.ignoreLighting),h=t.materialId,l=void 0!==h?this.materialFromJson(h):void 0;let d,u;if(!l){const i=t.texture;if(d=void 0!==i?this.textureMappingFromJson(i):void 0,void 0===d){const i=t.gradient;if(u=void 0!==i?Po.Symb.fromJSON(i):void 0,u){e(void 0!==i);const t=new Ia(i);d=new Do(t,new Do.Params({textureMat2x3:new Do.Trans2x3(0,1,0,1,0,0)}))}}}return new Oo(i,s,n,r,o,a,l,u,c,d)}}let ka;var Fa;Fa={parse:t=>{const e=function(t){const e=to.fromUint8Array(t.data),i=new zo(e);if(!i.isValid)return so.InvalidHeader;if(!i.isReadableVersion)return so.NewerMajorVersion;const s=e.curPos,n=Ro.readFrom(e);if(!n)return so.InvalidFeatureTable;e.curPos=s+n.length;const r=new xa(e);if(!r.isValid)return so.InvalidTileData;e.curPos=r.scenePosition;const o=function(t){let e;if(eo)try{e=new TextDecoder("utf-8")}catch(t){eo=!1}return void 0!==e?e.decode(t):function(t){return Qr.decodeWithFromCharCode(t)}(t)}(e.nextBytes(r.sceneStrLength));if(!o)return so.InvalidScene;try{const n=JSON.parse(o),a={scene:jr.asString(n.scene),scenes:jr.asArray(n.scenes),animationNodes:jr.asObject(n.animationNodes),bufferViews:jr.asObject(n.bufferViews)??{},meshes:jr.asObject(n.meshes),nodes:jr.asObject(n.nodes)??{},materials:jr.asObject(n.materials)??{},renderMaterials:jr.asObject(n.renderMaterials)??{},namedTextures:jr.asObject(n.namedTextures)??{},patternSymbols:jr.asObject(n.patternSymbols)??{},rtcCenter:jr.asArray(n.rtcCenter)};if(!a.meshes)return so.InvalidTileData;const c=new Uint8Array(e.arrayBuffer,r.binaryPosition),h={startPos:s,multiModel:0!=(i.flags&lo.MultiModelFeatureTable)};return new Ta(a,c,t,h,e).parse()}catch(t){return so.InvalidTileData}}({...t,data:t.data,timeline:ka});return"number"==typeof e?e:{result:e,transfer:$r(e)}},setTimeline:t=>{e(void 0===ka,"setTimeline must be called only once"),ka=Array.isArray(t)?Kr.Script.fromJSON(t):Kr.ModelTimeline.fromJSON(t)}},onmessage=t=>{const i=t.data,s=i.msgId;try{e("object"==typeof i&&"operation"in i&&"payload"in i&&"msgId"in i);const t=Fa[i.operation];e("function"==typeof t);const n=t(i.payload);"object"==typeof n&&"transfer"in n?postMessage({result:n.result,msgId:s},{transfer:n.transfer}):postMessage({result:n,msgId:s})}catch(t){const e=t instanceof Error?t:new Error("Unknown worker error");postMessage({error:e,msgId:s})}}})();