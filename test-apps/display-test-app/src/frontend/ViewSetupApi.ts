// Copyright (c) Bentley Systems
import {
  ClipStyle,
  ColorDef,
  DisplayStyle3dSettings,
  HiddenLine,
  QueryRowFormat,
  RenderMode,
} from "@itwin/core-common";
import {
  FitViewTool,
  IModelApp,
  IModelConnection,
  SpatialViewState,
  ViewCreator2d,
  ViewCreator3d,
  Viewport,
  ViewState,
} from "@itwin/core-frontend";
import { XY } from "@itwin/core-geometry";
import { SectionDrawingApi } from "./SectionDrawingApi";

export interface ViewState2dModels {
  model: string;
}
export interface ViewState3dModels {
  models: string[] | undefined;
}

export interface ViewStateSettings {
  renderMode: RenderMode;
  showCut: boolean;
  cutColor?: ColorDef;
  visibleEdges: boolean;
  visibleEdgeColor: ColorDef;
  backgroundColor: ColorDef;
}

export type ViewStateModels = ViewState2dModels | ViewState3dModels;

/** A list of functions related to initializing the view or ensuring a good state after changing it. */
export class ViewSetupApi {
  /** Queries the view of a model from the backend and ensures it's loaded the same.
     * @note ⭐ HACKATHON: There's a lot this method doesn't do to align the views. There needs to be further consideration of the best way to do this.
     */

  public static async createViewState(iModel: IModelConnection, viewStateModels: ViewStateModels): Promise<ViewState> {
    let view: ViewState;
    const vpAspect = ViewSetupApi.getAspectRatio();

    if ((viewStateModels as ViewState2dModels).model) {
      const viewCreator = new ViewCreator2d(iModel);
      view = await viewCreator.createViewForModel((viewStateModels as ViewState2dModels).model, { vpAspect });
    } else {
      const viewCreator = new ViewCreator3d(iModel);
      view = await viewCreator.createDefaultView({ vpAspect }, (viewStateModels as ViewState3dModels).models);
    }

    return view;
  }

  public static setViewState(viewport: Viewport, settings: Partial<ViewStateSettings>) {
    const props = viewport.displayStyle.settings.clipStyle.toJSON() ?? {};
    props.produceCutGeometry = settings.showCut;
    if (settings.showCut) {
      props.cutStyle = {
        hiddenLine: {
          visible: {
            ovrColor: settings.cutColor !== undefined,
            color: settings.cutColor?.toJSON(),
          },
        },
      };
    } else {
      props.cutStyle = undefined;
    }

    viewport.displayStyle.settings.clipStyle = ClipStyle.fromJSON(props);

    // TODO: what happens if 2d view?
    if (settings.visibleEdgeColor && (viewport.displayStyle.settings as DisplayStyle3dSettings))
      (viewport.displayStyle.settings as DisplayStyle3dSettings).hiddenLineSettings = HiddenLine.Settings.fromJSON({
        visible: { color: settings.renderMode === RenderMode.HiddenLine ? undefined : settings.visibleEdgeColor.tbgr },
      });
    else
      (viewport.displayStyle.settings as DisplayStyle3dSettings).hiddenLineSettings = HiddenLine.Settings.defaults;

    if (settings.backgroundColor)
      viewport.view.displayStyle.backgroundColor = settings.backgroundColor;

    (viewport.displayStyle.settings as DisplayStyle3dSettings)?.toggleSkyBox(false);

    viewport.view.viewFlags = viewport.view.viewFlags.copy({
      renderMode: settings.renderMode,
      visibleEdges: settings.visibleEdges,
    });
  }

  public static async refresh2dViewFromIModel(viewport: Viewport): Promise<void> {
    const iModel = viewport.iModel;
    if (!viewport.view.is2d()) {
      throw new Error("This only supports 2d Views");
    }
    const modelProps = await iModel.models.getProps(viewport.view.baseModelId);
    let newView = await ViewSetupApi.createDefaultViewFor2dModel(iModel, modelProps[0].id!);
    const currentView = viewport.view;
    const pose = currentView.savePose();
    newView = newView.applyPose(pose);
    viewport.applyViewState(newView);
  }

  /** When a model is selected in above list, get its view and switch to it.  */
  public static async changeViewportView2d(iModel: IModelConnection, newModelId: string, fitView?: boolean) {
    // Check if the model is a section drawing and handle it accordingly
    /**
       * SectionDrawings require special handling. They can have an empty model, but still have a spatial view that should be viewed.
       * We are creating section drawings in a "new" way, so we need to differentiate between section drawings generated by a connector
       * vs generated by us. My quick hackathon solution is to add a prefix to the name of all section drawings we generate.
       * This will not fly in production. Maybe workspaces/channels would help here?
       */
    const query = `SELECT ECInstanceId FROM Bis:SectionDrawing WHERE ECInstanceId = ${newModelId} AND instr(CodeValue, 'SectionDrawingDemo') > 0`;
    const sectionDrawings: string[] = await iModel
      .createQueryReader(query, undefined, {
        rowFormat: QueryRowFormat.UseJsPropertyNames,
      })
      .toArray();
    if (sectionDrawings.length > 0) {
      const viewDefQuery = `SELECT ECInstanceId FROM Bis:DrawingViewDefinition WHERE BaseModel.Id = ${newModelId}`;
      // Get drawing view that was created and saved during section drawing creation
      const drawingViewDefinitionIds: any[] = await iModel
        .createQueryReader(viewDefQuery, undefined, {
          rowFormat: QueryRowFormat.UseJsPropertyNames,
        })
        .toArray();
      if (drawingViewDefinitionIds.length > 0) {
        await SectionDrawingApi.viewSectionDrawing(drawingViewDefinitionIds[0].id, newModelId);
      }
    } else {
      const vp = IModelApp.viewManager.selectedView!;
      const targetView = await ViewSetupApi.createDefaultViewFor2dModel(iModel, newModelId);
      if (vp && targetView) {
        vp.changeView(targetView);
        if (fitView)
          void IModelApp.tools.run(FitViewTool.toolId, vp, true, false);
      } else {
        alert("Invalid View Detected!");
      }
    }
  }

  /** When a model is selected in above list, get its view and switch to it.  */
  public static async changeViewportView(
    iModel: IModelConnection,
    viewStateModels: ViewStateModels,
    fitView?: boolean,
  ) {
    const vp = IModelApp.viewManager.selectedView;
    const targetView = await ViewSetupApi.createViewState(iModel, viewStateModels);
    if (vp && targetView) {
      if (targetView instanceof SpatialViewState) {
        targetView.turnCameraOff();
      }

      vp.changeView(targetView);
      if (fitView)
        void IModelApp.tools.run(FitViewTool.toolId, vp, true, false);
    } else {
      alert("Invalid View Detected!");
    }
  }

  private static async createDefaultViewFor2dModel(iModel: IModelConnection, newModelId: string) {
    const viewCreator = new ViewCreator2d(iModel);
    const vpAspect = ViewSetupApi.getAspectRatio();
    const view = await viewCreator.createViewForModel(newModelId, {
      vpAspect,
    });
    if (view.is2d() && view.computeFitRange().isNull) {
      // ⭐ HACKATHON: Update ViewCreator2d to create a reasonable view if the current range is null
      view.setExtents({ x: 20, y: 20 });
      view.setOrigin({ x: 0, y: 0 });
    }

    return view;
  }

  // ⭐ HACKATHON: create immediate tool for this
  public static async changeViewportView2dWithZoom(
    iModel: IModelConnection,
    newModelId: string,
    bBoxLow: XY,
    bBoxHigh: XY,
    origin: XY,
  ) {
    const vp = IModelApp.viewManager.selectedView!;
    const viewCreator = new ViewCreator2d(iModel);
    const vpAspect = ViewSetupApi.getAspectRatio();
    const view = await viewCreator.createViewForModel(newModelId, {
      vpAspect,
    });

    const margin = bBoxLow.x + bBoxHigh.x * 0.2;

    if (view.is2d()) {
      view.setExtents({ x: bBoxLow.x + bBoxHigh.x + margin, y: bBoxHigh.y + bBoxLow.y + margin });
      view.setOrigin({ x: origin.x - margin / 2, y: origin.y - margin / 2 });
    }

    if (vp && view) {
      vp.changeView(view);
    } else {
      alert("Invalid View Detected!");
    }
  }

  /** Returns the aspect ratio of the container the view will be created in. */
  public static getAspectRatio(): number | undefined {
    const viewDiv = document.getElementById("sample-container");

    if (null === viewDiv)
      return undefined;

    return viewDiv.clientWidth / viewDiv.clientHeight;
  }
}
