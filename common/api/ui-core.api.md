## API Report File for "@bentley/ui-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionMeta } from 'react-select/src/types';
import { BadgeType } from '@bentley/ui-abstract';
import { BeUiEvent } from '@bentley/bentleyjs-core';
import Component from 'react-select';
import { ConditionalBooleanValue } from '@bentley/ui-abstract';
import { ConditionalStringValue } from '@bentley/ui-abstract';
import * as CSS from 'csstype';
import { FocusEventHandler } from 'react-select/src/types';
import { formatGroupLabel } from 'react-select/src/builtins';
import { getOptionLabel } from 'react-select/src/builtins';
import { getOptionValue } from 'react-select/src/builtins';
import { I18N } from '@bentley/imodeljs-i18n';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IMatch } from '@bentley/ui-abstract';
import { InputActionMeta } from 'react-select/src/types';
import { KeyboardEventHandler } from 'react-select/src/types';
import { Matrix3d } from '@bentley/geometry-core';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import * as ReactAutosuggest from 'react-autosuggest';
import { RelativePosition } from '@bentley/ui-abstract';
import { SelectComponentsConfig } from 'react-select/src/components/index';
import { SliderModeFunction } from 'react-compound-slider';
import { ValueType } from 'react-select/src/types';

// @beta
export class ActivateSettingsTabEvent extends BeUiEvent<ActivateSettingsTabEventArgs> {
}

// @beta
export interface ActivateSettingsTabEventArgs {
    // (undocumented)
    readonly settingsTabId: string;
}

// @internal
export class AnnularSector {
    constructor(parent: Annulus, startAngle: number, endAngle: number);
    // (undocumented)
    end: Line;
    // (undocumented)
    endAngle: number;
    // (undocumented)
    innerEnd: Point;
    // (undocumented)
    innerStart: Point;
    // (undocumented)
    outerEnd: Point;
    // (undocumented)
    outerStart: Point;
    // (undocumented)
    parent: Annulus;
    // (undocumented)
    path: string;
    // (undocumented)
    start: Line;
    // (undocumented)
    startAngle: number;
}

// @internal
export class Annulus {
    constructor(center?: Point, innerRadius?: number, outerRadius?: number);
    // (undocumented)
    center: Point;
    // (undocumented)
    inner: Circle;
    // (undocumented)
    outer: Circle;
}

// @beta
export type AsyncGetAutoSuggestDataFunc = (value: string) => Promise<AutoSuggestData[]>;

// @beta
export class AutoSuggest extends React.PureComponent<AutoSuggestProps, AutoSuggestState> {
    constructor(props: AutoSuggestProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: AutoSuggestProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @beta
export interface AutoSuggestData {
    label: string;
    value: string;
}

// @beta
export interface AutoSuggestProps extends React.InputHTMLAttributes<HTMLInputElement>, CommonProps {
    // @internal (undocumented)
    alwaysRenderSuggestions?: boolean;
    getLabel?: (value: string | undefined) => string;
    getSuggestions?: AsyncGetAutoSuggestDataFunc;
    onInputFocus?: (e: React.FocusEvent<HTMLInputElement>) => void;
    onPressEnter?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
    onPressEscape?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
    onPressTab?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
    onSuggestionsClearRequested?: () => void;
    onSuggestionSelected: (selected: AutoSuggestData) => void;
    options?: AutoSuggestData[] | GetAutoSuggestDataFunc;
    // @internal
    renderInputComponent?: any;
    // @internal
    renderSuggestionsContainer?: ReactAutosuggest.RenderSuggestionsContainer;
    setFocus?: boolean;
    value?: string;
}

// @internal
export class Badge extends React.PureComponent<BadgeProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface BadgeProps extends CommonProps {
    // (undocumented)
    svg: any;
}

// @internal
export class BadgeUtilities {
    static getComponentForBadgeType(badgeType?: BadgeType): React.ReactNode;
}

// @internal
export function BetaBadge(props: CommonProps): JSX.Element;

// @public
export function BlockText(props: TextProps): JSX.Element;

// @public
export function BodyText(props: TextProps): JSX.Element;

// @beta @deprecated
export type BoundsFunctionProp = number | (() => number | undefined);

// @public
export class Button extends React.PureComponent<ButtonProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    buttonType?: ButtonType;
    id?: string;
    onClick?: ((event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void);
    size?: ButtonSize;
}

// @public
export enum ButtonSize {
    // (undocumented)
    Default = "",
    // (undocumented)
    Large = "large"
}

// @public
export enum ButtonType {
    // (undocumented)
    Blue = "blue",
    // (undocumented)
    Disabled = "disabled",
    // (undocumented)
    Hollow = "hollow",
    // (undocumented)
    Primary = "primary"
}

// @internal
export const calculateBackdropFilterBlur: (proximityScale: number) => number;

// @internal
export const calculateBoxShadowOpacity: (proximityScale: number) => number;

// @internal
export const calculateProximityScale: (proximity: number, snap?: boolean, threshold?: number) => number;

// @internal
export const calculateToolbarOpacity: (proximityScale: number) => number;

// @public
export function Centered(props: CommonDivProps): JSX.Element;

// @public
export class Checkbox extends React.PureComponent<CheckboxProps> {
    // @internal
    constructor(props: CheckboxProps);
    // (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(_prevProps: CheckboxProps): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export interface CheckBoxInfo {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    isVisible?: boolean;
    // (undocumented)
    state?: CheckBoxState;
    // (undocumented)
    tooltip?: string;
}

// @public
export interface CheckboxProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "type" | "onClick" | "onBlur">, CommonProps {
    indeterminate?: boolean;
    inputClassName?: string;
    inputRef?: React.Ref<HTMLInputElement>;
    inputStyle?: React.CSSProperties;
    label?: string;
    labelClassName?: string;
    labelStyle?: React.CSSProperties;
    onBlur?: (e: React.FocusEvent) => void;
    onClick?: (e: React.MouseEvent) => void;
    setFocus?: boolean;
    status?: InputStatus;
}

// @public
export enum CheckBoxState {
    // (undocumented)
    Off = 0,
    // (undocumented)
    On = 1,
    // (undocumented)
    Partial = 2
}

// @public
export class CheckListBox extends React.PureComponent<CommonProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export class CheckListBoxItem extends React.PureComponent<CheckListBoxItemProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface CheckListBoxItemProps extends CommonProps {
    checked?: boolean;
    disabled?: boolean;
    label: string;
    onClick?: () => any;
}

// @public
export function CheckListBoxSeparator(): JSX.Element;

// @internal
export class Circle {
    constructor(center?: Point, radius?: number);
    // (undocumented)
    center: Point;
    // (undocumented)
    radius: number;
}

// @public
export interface ClassNameProps {
    className?: string;
}

// @internal
export class CloseSettingsContainerEvent extends BeUiEvent<ProcessSettingsContainerCloseEventArgs> {
}

// @public
export interface CommonDivProps extends React.AllHTMLAttributes<HTMLDivElement>, CommonProps {
}

// @public
export interface CommonProps extends ClassNameProps {
    style?: React.CSSProperties;
}

// @public
export class ContextMenu extends React.PureComponent<ContextMenuProps, ContextMenuState> {
    constructor(props: ContextMenuProps);
    // @internal (undocumented)
    static autoFlip: (dir: ContextMenuDirection, rect: ClientRect, windowWidth: number, windowHeight: number) => ContextMenuDirection;
    // (undocumented)
    blur: () => void;
    // @internal (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: ContextMenuProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<ContextMenuProps>;
    // (undocumented)
    focus: () => void;
    // @internal (undocumented)
    static getCSSClassNameFromDirection: (direction?: ContextMenuDirection | undefined) => string;
    // (undocumented)
    getRect: () => ClientRect;
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ContextMenuState>;
}

// @public
export enum ContextMenuDirection {
    // (undocumented)
    Bottom = "bottom",
    // (undocumented)
    BottomLeft = "bottom left",
    // (undocumented)
    BottomRight = "bottom right",
    // (undocumented)
    Center = "center",
    // (undocumented)
    Left = "left",
    // (undocumented)
    None = "",
    // (undocumented)
    Right = "right",
    // (undocumented)
    Top = "top",
    // (undocumented)
    TopLeft = "top left",
    // (undocumented)
    TopRight = "top right"
}

// @public
export class ContextMenuDivider extends React.PureComponent<CommonProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export class ContextMenuItem extends React.PureComponent<ContextMenuItemProps, ContextMenuItemState> {
    constructor(props: ContextMenuItemProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: ContextMenuItemProps): void;
    // @internal (undocumented)
    static defaultProps: Partial<ContextMenuItemProps>;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    select: () => void;
    // @internal (undocumented)
    readonly state: Readonly<ContextMenuItemState>;
    }

// @public
export interface ContextMenuItemProps extends Omit<React.AllHTMLAttributes<HTMLDivElement>, "disabled" | "hidden">, CommonProps {
    badgeType?: BadgeType;
    disabled?: boolean | ConditionalBooleanValue;
    hidden?: boolean | ConditionalBooleanValue;
    hideIconContainer?: boolean;
    icon?: IconSpec;
    iconRight?: IconSpec;
    // (undocumented)
    isSelected?: boolean;
    // @internal (undocumented)
    onHotKeyParsed?: (hotKey: string) => void;
    // @internal (undocumented)
    onHover?: () => any;
    // (undocumented)
    onSelect?: (event: any) => any;
    // @internal (undocumented)
    parentMenu?: ContextMenu;
}

// @public
export interface ContextMenuProps extends CommonProps {
    autoflip?: boolean;
    direction?: ContextMenuDirection;
    edgeLimit?: boolean;
    floating?: boolean;
    hotkeySelect?: boolean;
    // @internal (undocumented)
    ignoreNextKeyUp?: boolean;
    onEsc?: (data: any) => any;
    onOutsideClick?: (event: MouseEvent) => any;
    onSelect?: (event: any) => any;
    opened: boolean;
    // @internal (undocumented)
    parentMenu?: ContextMenu;
    // @internal (undocumented)
    parentSubmenu?: ContextSubMenu;
    selectedIndex?: number;
}

// @public
export class ContextSubMenu extends React.Component<ContextSubMenuProps, ContextSubMenuState> {
    constructor(props: ContextSubMenuProps);
    // (undocumented)
    close: (propagate?: boolean | undefined) => void;
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: ContextSubMenuProps, prevState: ContextSubMenuState): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<ContextSubMenuProps>;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    select: () => void;
    // @internal (undocumented)
    readonly state: Readonly<ContextSubMenuState>;
    }

// @public
export interface ContextSubMenuProps extends Omit<ContextMenuItemProps, "label">, Omit<ContextMenuProps, "label">, CommonProps {
    label: string | JSX.Element;
    // @internal (undocumented)
    onHotKeyParsed?: (hotKey: string) => void;
}

// @internal
export enum Corner {
    // (undocumented)
    BottomLeft = 3,
    // (undocumented)
    BottomRight = 2,
    // (undocumented)
    TopLeft = 0,
    // (undocumented)
    TopRight = 1
}

// @internal
export type CrossAxisArrowKeyFunc = (forward: boolean) => void;

// @public
export class Cube extends React.PureComponent<CubeProps> {
    // (undocumented)
    render(): React.ReactNode;
}

// @internal (undocumented)
export class CubeFace extends React.Component<CubeFaceProps> {
    // (undocumented)
    render(): React.ReactNode;
}

// @internal (undocumented)
export interface CubeFaceProps extends React.AllHTMLAttributes<HTMLDivElement> {
    // (undocumented)
    face: Face;
    // (undocumented)
    rotMatrix: Matrix3d;
}

// @public
export interface CubeProps extends React.AllHTMLAttributes<HTMLDivElement>, CommonProps {
    // (undocumented)
    faces?: {
        [key: string]: React.ReactNode;
    };
    // (undocumented)
    rotMatrix: Matrix3d;
}

// @public
export class Dialog extends React.Component<DialogProps, DialogState> {
    constructor(props: DialogProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<DialogProps>;
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<DialogState>;
}

// @public
export enum DialogAlignment {
    // (undocumented)
    Bottom = "bottom",
    // (undocumented)
    BottomLeft = "bottom-left",
    // (undocumented)
    BottomRight = "bottom-right",
    // (undocumented)
    Center = "center",
    // (undocumented)
    Left = "left",
    // (undocumented)
    Right = "right",
    // (undocumented)
    Top = "top",
    // (undocumented)
    TopLeft = "top-left",
    // (undocumented)
    TopRight = "top-right"
}

// @public
export interface DialogButtonDef {
    buttonStyle?: DialogButtonStyle;
    className?: string;
    disabled?: boolean;
    label?: string;
    onClick: () => void;
    type: DialogButtonType;
}

// @public
export enum DialogButtonStyle {
    // (undocumented)
    Blue = "uicore-buttons-blue",
    // (undocumented)
    Hollow = "uicore-buttons-hollow",
    // (undocumented)
    None = "",
    // (undocumented)
    Primary = "uicore-buttons-primary"
}

// @public
export enum DialogButtonType {
    // (undocumented)
    Cancel = "cancel",
    // (undocumented)
    Close = "close",
    // (undocumented)
    Next = "next",
    // (undocumented)
    No = "no",
    // (undocumented)
    None = "",
    // (undocumented)
    OK = "ok",
    // (undocumented)
    Previous = "previous",
    // (undocumented)
    Retry = "retry",
    // (undocumented)
    Yes = "yes"
}

// @public
export interface DialogProps extends Omit<React.AllHTMLAttributes<HTMLDivElement>, "title">, CommonProps {
    alignment?: DialogAlignment;
    backgroundStyle?: React.CSSProperties;
    buttonCluster?: DialogButtonDef[];
    contentClassName?: string;
    contentStyle?: React.CSSProperties;
    footer?: string | JSX.Element;
    footerStyle?: React.CSSProperties;
    header?: React.ReactNode;
    height?: string | number;
    hideHeader?: boolean;
    inset?: boolean;
    maxHeight?: string | number;
    maxWidth?: string | number;
    minHeight?: string | number;
    minWidth?: string | number;
    modal?: boolean;
    modelessId?: string;
    movable?: boolean;
    onClose?: () => void;
    onEscape?: () => void;
    onModelessPointerDown?: (event: React.PointerEvent, id: string) => void;
    onOutsideClick?: (event: MouseEvent) => any;
    opened: boolean;
    resizable?: boolean;
    title?: string | JSX.Element;
    titleStyle?: React.CSSProperties;
    trapFocus?: boolean;
    width?: string | number;
    x?: number;
    y?: number;
}

// @public
export function DisabledText(props: TextProps): JSX.Element;

// @public
export function Div(props: DivProps): JSX.Element;

// @public
export interface DivProps extends CommonDivProps {
    mainClassName: string;
}

// @public
export const DivWithOutsideClick: {
    new (props: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>): {
        ref: React.RefObject<HTMLDivElement>;
        isDownOutside: boolean;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isInCorePopup(element: HTMLElement): boolean;
        onOutsideClick(e: MouseEvent): any;
        handleDocumentClick: (e: MouseEvent) => any;
        handleDocumentPointerDown: (e: PointerEvent) => void;
        handleDocumentPointerUp: (e: PointerEvent) => any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps, context?: any): {
        ref: React.RefObject<HTMLDivElement>;
        isDownOutside: boolean;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isInCorePopup(element: HTMLElement): boolean;
        onOutsideClick(e: MouseEvent): any;
        handleDocumentClick: (e: MouseEvent) => any;
        handleDocumentPointerDown: (e: PointerEvent) => void;
        handleDocumentPointerUp: (e: PointerEvent) => any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<CommonDivProps & import("../hocs/withOnOutsideClick").WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};

// @public
export const ElementSeparator: (props: ElementSeparatorProps) => JSX.Element;

// @public
export interface ElementSeparatorProps extends CommonProps {
    isResizeHandleBeingDragged?: boolean;
    isResizeHandleHovered?: boolean;
    movableArea?: number;
    onRatioChanged?: (ratio: number) => void | RatioChangeResult;
    onResizeHandleDragChanged?: (isDragStarted: boolean) => void;
    onResizeHandleHoverChanged?: (isHovered: boolean) => void;
    orientation: Orientation;
    ratio: number;
    separatorSize?: number;
}

// @public
export type ExecuteHandler = (this: void) => void;

// @public
export class ExpandableBlock extends React.PureComponent<ExpandableBlockProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface ExpandableBlockProps extends CommonProps {
    caption?: string;
    isExpanded: boolean;
    onClick: React.MouseEventHandler<HTMLDivElement>;
    onKeyDown?: React.KeyboardEventHandler<HTMLDivElement>;
    onKeyPress?: React.KeyboardEventHandler<HTMLDivElement>;
    title: string | JSX.Element;
    // @beta
    tooltip?: string;
}

// @public
export class ExpandableList extends React.PureComponent<ExpandableListProps, ExpandableListState> {
    constructor(props: ExpandableListProps);
    // @internal (undocumented)
    componentDidUpdate(prevProps: ExpandableListProps): void;
    // (undocumented)
    static defaultProps: Partial<ExpandableListProps>;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export interface ExpandableListProps extends CommonProps {
    defaultActiveBlock?: number;
    singleExpandOnly?: boolean;
    singleIsCollapsible?: boolean;
}

// @public
export class ExpansionToggle extends React.PureComponent<ExpansionToggleProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface ExpansionToggleProps extends CommonProps {
    // (undocumented)
    ["data-testid"]?: string;
    // (undocumented)
    isExpanded?: boolean;
    // (undocumented)
    onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
}

// @public
export enum Face {
    // (undocumented)
    Back = "back",
    // (undocumented)
    Bottom = "bottom",
    // (undocumented)
    Front = "front",
    // (undocumented)
    Left = "left",
    // (undocumented)
    None = "",
    // (undocumented)
    Right = "right",
    // (undocumented)
    Top = "top"
}

// @beta
export function FeaturedTile(props: TileProps): JSX.Element;

// @beta
export class Field extends React.Component<FieldProps> {
    constructor(props: FieldProps);
    // (undocumented)
    render(): JSX.Element;
}

// @beta
export interface FieldDef {
    // (undocumented)
    editor?: FieldEditor;
    // (undocumented)
    label?: string;
    // (undocumented)
    options?: string[] | {
        [key: string]: string;
    };
    // (undocumented)
    value?: any;
}

// @beta
export interface FieldDefinitions {
    // (undocumented)
    [key: string]: FieldDef;
}

// @beta
export type FieldEditor = "textbox" | "multilinetextbox" | "dropdown" | "checkbox";

// @beta
export interface FieldProps extends FieldDef {
    // (undocumented)
    id: string;
}

// @beta
export interface FieldValues {
    // (undocumented)
    [key: string]: any;
}

// @public
export function FillCentered(props: CommonDivProps): JSX.Element;

// @alpha
export function FilteredText(props: FilteredTextProps): JSX.Element;

// @alpha
export interface FilteredTextProps extends CommonProps {
    matchClassName?: string;
    matches?: IMatch[];
    matchStyle?: React.CSSProperties;
    value: string;
}

// @internal
export const flattenChildren: (children: React.ReactNode) => React.ReactNode;

// @public
export function FlexWrapContainer(props: CommonDivProps): JSX.Element;

// @internal
export function FocusTrap(props: FocusTrapProps): JSX.Element | null;

// @internal
export interface FocusTrapProps extends React.AllHTMLAttributes<any> {
    active?: boolean;
    children: React.ReactNode;
    initialFocusElement?: React.RefObject<HTMLElement> | string;
    returnFocusOnDeactivate: boolean;
}

// @beta
export class Form extends React.Component<FormProps, FormState> {
    constructor(props: FormProps);
    // (undocumented)
    render(): JSX.Element;
    }

// @beta
export const FormContext: React.Context<FormContextState | undefined>;

// @beta
export interface FormContextState extends FormState {
    // (undocumented)
    setValues: (values: FieldValues) => void;
}

// @beta
export interface FormProps {
    fields: FieldDefinitions;
    handleFormSubmit: (values: FieldValues) => Promise<void>;
    submitButtonLabel?: string;
}

// @beta
export type GetAutoSuggestDataFunc = (value: string) => AutoSuggestData[];

// @internal
export function getBestBWContrastColor(hexColor: string): "black" | "white";

// @internal (undocumented)
export function getButtonTypeClassName(buttonType?: ButtonType): string;

// @internal
export function getCssVariable(variableName: string, htmlElement?: HTMLElement): string;

// @internal
export function getCssVariableAsNumber(variableName: string, htmlElement?: HTMLElement): number;

// @internal
export const getDisplayName: (component: React.ComponentType<any>) => string;

// @internal
export const getToolbarBackdropFilter: (filterBlur: number) => string;

// @internal
export const getToolbarBackgroundColor: (opacity: number) => string;

// @internal
export const getToolbarBoxShadow: (opacity: number) => string;

// @internal
export function getUserColor(email: string): string;

// @public
export class GlobalContextMenu extends React.PureComponent<GlobalContextMenuProps> {
    constructor(props: GlobalContextMenuProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React.ReactNode;
}

// @public
export interface GlobalContextMenuProps extends ContextMenuProps {
    contextMenuComponent?: React.ComponentType<ContextMenuProps>;
    identifier?: string;
    x: number | string;
    y: number | string;
}

// @public
export class GlobalDialog extends React.Component<GlobalDialogProps> {
    constructor(props: GlobalDialogProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React.ReactNode;
}

// @public
export interface GlobalDialogProps extends DialogProps {
    // (undocumented)
    identifier?: string;
}

// @internal
export function hasPointerEventsSupport(): boolean;

// @public
export function Headline(props: TextProps): JSX.Element;

// @public
export enum HorizontalAlignment {
    // (undocumented)
    Center = "center",
    // (undocumented)
    Justify = "justify",
    // (undocumented)
    Left = "left",
    // (undocumented)
    Right = "right"
}

// @public
export function HorizontalTabs(props: TabsProps): JSX.Element;

// @public
export function Icon(props: IconProps): JSX.Element | null;

// @public
export class IconHelper {
    static getIconData(iconSpec: string | ConditionalStringValue | React.ReactNode, internalData?: Map<string, any>): string | ConditionalStringValue;
    static getIconReactNode(icon: string | ConditionalStringValue | React.ReactNode, internalData?: Map<string, any>): React.ReactNode;
    // (undocumented)
    static get reactIconKey(): string;
}

// @public
export const IconInput: (props: IconInputProps) => JSX.Element | null;

// @public
export interface IconInputProps extends InputProps {
    containerClassName?: string;
    icon: React.ReactNode;
    ref?: React.Ref<HTMLInputElement>;
}

// @public
export interface IconProps extends CommonProps {
    iconSpec?: IconSpec;
}

// @public
export type IconSpec = string | ConditionalStringValue | React.ReactNode;

// @public
export class ImageCheckBox extends React.PureComponent<ImageCheckBoxProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface ImageCheckBoxProps extends CommonProps {
    border?: boolean;
    checked?: boolean;
    disabled?: boolean;
    imageOff: string | React.ReactNode;
    imageOn: string | React.ReactNode;
    inputClassName?: string;
    inputRef?: React.Ref<HTMLInputElement>;
    inputStyle?: React.CSSProperties;
    onClick?: (checked: boolean) => any;
    tooltip?: string;
}

// @public
export const Input: (props: InputProps) => JSX.Element | null;

// @public
export class InputLabel extends React.PureComponent<InputLabelProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface InputLabelProps extends LabeledComponentProps, MessagedComponentProps, CommonProps {
    // (undocumented)
    disabled?: boolean;
}

// @public
export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement>, CommonProps {
    // (undocumented)
    nativeKeyHandler?: (e: KeyboardEvent) => void;
    ref?: React.Ref<HTMLInputElement>;
    setFocus?: boolean;
}

// @public
export enum InputStatus {
    // (undocumented)
    Error = "error",
    // (undocumented)
    Success = "success",
    // (undocumented)
    Warning = "warning"
}

// @internal
export const isHTMLElement: (message: MessageType) => message is HTMLElement;

// @internal
export function isNavigationKey(key: string): boolean;

// @internal
export function isPromiseLike(obj: unknown): obj is PromiseLike<unknown>;

// @internal
export const isReactMessage: (message: MessageType) => message is ReactMessage;

// @internal
export class ItemKeyboardNavigator {
    constructor(onFocusItem: (index: number) => void, onActivateItem: (index: number) => void);
    get allowWrap(): boolean;
    set allowWrap(v: boolean);
    get crossAxisArrowKeyHandler(): CrossAxisArrowKeyFunc | undefined;
    set crossAxisArrowKeyHandler(v: CrossAxisArrowKeyFunc | undefined);
    handleKeyDownEvent(event: React_2.KeyboardEvent, index: number): void;
    handleKeyUpEvent(event: React_2.KeyboardEvent, index: number): void;
    get itemCount(): number;
    set itemCount(count: number);
    // (undocumented)
    onActivateItem: (index: number) => void;
    // (undocumented)
    onFocusItem: (index: number) => void;
    get orientation(): Orientation;
    set orientation(orientation: Orientation);
    }

// @public
export interface LabeledComponentProps {
    inputClassName?: string;
    inputStyle?: React.CSSProperties;
    label?: string;
    labelClassName?: string;
    labelStyle?: React.CSSProperties;
    status?: InputStatus;
}

// @public
export function LabeledInput(props: LabeledInputProps): JSX.Element;

// @public
export interface LabeledInputProps extends InputProps, LabeledComponentProps, MessagedComponentProps {
}

// @public
export class LabeledSelect extends React.PureComponent<LabeledSelectProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LabeledSelectProps extends SelectProps, LabeledComponentProps, MessagedComponentProps {
}

// @public
export function LabeledTextarea(props: LabeledTextareaProps): JSX.Element;

// @public
export interface LabeledTextareaProps extends TextareaProps, LabeledComponentProps, MessagedComponentProps {
}

// @beta
export function LabeledThemedSelect(props: LabeledThemedSelectProps): JSX.Element;

// @beta
export interface LabeledThemedSelectProps extends ThemedSelectProps, LabeledComponentProps, MessagedComponentProps {
}

// @public
export class LabeledToggle extends React.PureComponent<LabeledToggleProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LabeledToggleProps extends ToggleProps {
    label?: string;
    labelClassName?: string;
    labelStyle?: React.CSSProperties;
}

// @public
export function LeadingText(props: TextProps): JSX.Element;

// @public
export function LeadingText2(props: TextProps): JSX.Element;

// @internal
export class Line {
    constructor(p1?: Point, p2?: Point);
    equals: (line: Line) => boolean;
    // (undocumented)
    p1: Point;
    // (undocumented)
    p2: Point;
}

// @alpha
export function Listbox(props: ListboxProps): JSX.Element;

// @alpha
export const ListboxContext: React.Context<ListboxContextProps>;

// @alpha
export interface ListboxContextProps {
    // (undocumented)
    focusValue?: ListboxValue;
    // (undocumented)
    listboxId?: string;
    // (undocumented)
    listboxRef?: React.RefObject<HTMLUListElement>;
    // (undocumented)
    listboxValue?: ListboxValue;
    // (undocumented)
    onListboxValueChange: ((newValue: ListboxValue, isControlOrCommandPressed?: boolean) => void);
}

// @alpha
export function ListboxItem(props: ListboxItemProps): JSX.Element;

// @alpha
export interface ListboxItemProps extends React.DetailedHTMLProps<React.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement> {
    disabled?: boolean;
    value: ListboxValue;
}

// @alpha
export interface ListboxProps extends React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement> {
    // (undocumented)
    ariaLabel?: any;
    // (undocumented)
    ariaLabelledBy?: any;
    // (undocumented)
    id?: string;
    // (undocumented)
    onListboxValueChange?: ((newValue: ListboxValue, isControlOrCommandPressed?: boolean) => void);
    // (undocumented)
    selectedValue?: ListboxValue;
}

// @alpha
export type ListboxValue = string;

// @public
export class LoadingBar extends React.PureComponent<LoadingBarProps> {
    // (undocumented)
    static defaultProps: Partial<LoadingBarProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LoadingBarProps extends CommonProps {
    barHeight: number;
    percent: number;
    showPercentage?: boolean;
}

// @public
export class LoadingPrompt extends React.PureComponent<LoadingPromptProps> {
    // (undocumented)
    static defaultProps: Partial<LoadingPromptProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LoadingPromptProps extends CommonProps {
    isDeterminate: boolean;
    // @deprecated
    isDeterministic: boolean;
    message?: string;
    onCancel?: () => void;
    percent: number;
    showCancel: boolean;
    showIndeterminateBar: boolean;
    showPercentage: boolean;
    showStatus: boolean;
    status: string;
    title: string;
}

// @public
export class LoadingSpinner extends React.PureComponent<LoadingSpinnerProps> {
    // (undocumented)
    static defaultProps: Partial<LoadingSpinnerProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LoadingSpinnerProps extends SpinnerProps {
    message?: string;
    messageOnTop?: boolean;
}

// @public
export class LoadingStatus extends React.PureComponent<LoadingStatusProps> {
    // (undocumented)
    static defaultProps: Partial<LoadingStatusProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface LoadingStatusProps extends CommonProps {
    message: string;
    percent: number;
}

// @beta
export class LocalUiSettings implements UiSettings {
    constructor(w?: Window);
    // (undocumented)
    deleteSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    getSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    saveSetting(settingNamespace: string, settingName: string, setting: any): Promise<UiSettingsResult>;
    // (undocumented)
    w: Window;
}

// @public
export interface MainTabsProps extends TabsProps {
    mainClassName: string;
    orientation: Orientation;
}

// @internal
export function mergeRefs<T>(...refs: ReadonlyArray<React.Ref<T>>): (instance: T | null) => void;

// @public
export class MessageBox extends React.PureComponent<MessageBoxProps> {
    // (undocumented)
    static defaultProps: Partial<MessageBoxProps>;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface MessageBoxProps extends CommonProps {
    buttonCluster: DialogButtonDef[];
    contentClassName?: string;
    contentStyle?: React.CSSProperties;
    height?: string | number;
    minHeight?: number;
    minWidth?: number;
    modal?: boolean;
    onClose?: () => void;
    onEscape?: () => void;
    opened: boolean;
    severity: MessageSeverity;
    title?: string | JSX.Element;
    width?: string | number;
}

// @public
export class MessageContainer extends React.PureComponent<MessageContainerProps> {
    // (undocumented)
    static getIconClassName(severity: MessageSeverity, hollow?: boolean): string;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface MessageContainerProps extends CommonProps {
    // (undocumented)
    severity: MessageSeverity;
}

// @public
export interface MessagedComponentProps {
    message?: string;
    messageClassName?: string;
    messageStyle?: React.CSSProperties;
}

// @beta
export function MessageRenderer(props: MessageRendererProps): JSX.Element | null;

// @beta
export interface MessageRendererProps extends ClassNameProps {
    message: MessageType;
    useSpan?: boolean;
}

// @public
export enum MessageSeverity {
    // (undocumented)
    Error = 4,
    // (undocumented)
    Fatal = 5,
    // (undocumented)
    Information = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Question = 2,
    // (undocumented)
    Warning = 3
}

// @public
export type MessageType = string | HTMLElement | ReactMessage;

// @beta
export function MinimalFeaturedTile(props: TileProps): JSX.Element;

// @beta
export function MinimalTile(props: TileProps): JSX.Element;

// @public
export function MutedText(props: TextProps): JSX.Element;

// @internal
export function NewBadge(props: CommonProps): JSX.Element;

// @public
export interface NoChildrenProps {
    // (undocumented)
    children?: undefined;
}

// @beta
export interface NodeCheckboxProps {
    isDisabled?: boolean;
    onClick?: (newState: CheckBoxState) => void;
    state?: CheckBoxState;
    tooltip?: string;
}

// @beta
export type NodeCheckboxRenderer = (props: NodeCheckboxRenderProps) => React.ReactNode;

// @beta
export type NodeCheckboxRenderProps = Omit<CheckboxProps, "onChange" | "onClick"> & {
    onChange: (checked: boolean) => void;
    onClick: (e: React.MouseEvent) => void;
};

// @beta
export const NumberInput: (props: NumberInputProps) => JSX.Element | null;

// @beta
export interface NumberInputProps extends Omit<InputProps, "min" | "max" | "step" | "onChange"> {
    containerClassName?: string;
    format?: (num: number | null | undefined, formattedValue: string) => string;
    max?: number;
    min?: number;
    onChange?: (value: number | undefined, stringValue: string) => void;
    parse?: ((value: string) => number | null | undefined);
    precision?: number;
    ref?: React.Ref<HTMLInputElement>;
    showTouchButtons?: boolean;
    snap?: boolean;
    step?: StepFunctionProp;
    value?: number;
}

// @beta @deprecated
export class NumericInput extends React.Component<NumericInputProps> {
    // @internal (undocumented)
    static readonly defaultProps: NumericInputDefaultProps;
    // (undocumented)
    render(): JSX.Element;
    }

// @internal @deprecated
export type NumericInputDefaultProps = Pick<NumericInputProps, "strict">;

// @beta @deprecated
export interface NumericInputProps extends Omit<ReactNumericInputProps, "step">, CommonProps {
    // (undocumented)
    step?: StepFunctionProp;
}

// @public
export type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;

// @public
export type OmitChildrenProp<T extends {
    children?: React.ReactNode;
}> = Omit<T, "children">;

// @beta
export type OptionsType = Array<OptionType>;

// @beta
export interface OptionType {
    // (undocumented)
    label: string;
    // (undocumented)
    value: any;
}

// @public
export enum Orientation {
    // (undocumented)
    Horizontal = 0,
    // (undocumented)
    Vertical = 1
}

// @internal (undocumented)
export type OutsideClickEvent = PointerEvent | MouseEvent | TouchEvent;

// @internal
export function percentInRange(percent: number): number;

// @internal (undocumented)
export function placementToPosition(placement: TooltipPlacement | undefined): RelativePosition;

// @internal
export class Point implements PointProps {
    constructor(x?: number, y?: number);
    static create(pointProps: PointProps): Point;
    // (undocumented)
    equals(other: PointProps): boolean;
    getDistanceTo(other: PointProps): number;
    getManhattanDistanceTo(other: PointProps): number;
    getOffsetTo(other: PointProps): Point;
    // (undocumented)
    multiply(factor: number): Point;
    // (undocumented)
    offset(offset: PointProps): Point;
    // (undocumented)
    offsetX(offset: number): Point;
    // (undocumented)
    offsetY(offset: number): Point;
    // (undocumented)
    setX(x: number): Point;
    // (undocumented)
    setY(y: number): Point;
    // (undocumented)
    toProps(): PointProps;
    // (undocumented)
    readonly x: number;
    // (undocumented)
    readonly y: number;
}

// @public
export interface PointProps {
    // (undocumented)
    readonly x: number;
    // (undocumented)
    readonly y: number;
}

// @public
export class Popup extends React.Component<PopupProps, PopupState> {
    constructor(props: PopupProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(previousProps: PopupProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<PopupProps>;
    // (undocumented)
    render(): React.ReactPortal | null;
    }

// @beta
export function PopupContextMenu(props: PopupContextMenuProps): JSX.Element;

// @beta
export interface PopupContextMenuProps extends CommonProps {
    animate?: boolean;
    ariaLabel?: string;
    autoflip?: boolean;
    children?: React.ReactNode;
    edgeLimit?: boolean;
    hotkeySelect?: boolean;
    isOpen: boolean;
    left?: number;
    offset?: number;
    onClose?: () => void;
    onEnter?: () => void;
    onEsc?: (event: React.KeyboardEvent) => void;
    onOpen?: () => void;
    onOutsideClick?: (e: MouseEvent) => void;
    onSelect?: (event: React.MouseEvent | undefined) => void;
    position?: RelativePosition;
    selectedIndex?: number;
    target?: HTMLElement | null;
    top?: number;
}

// @public
export interface PopupProps extends CommonProps {
    animate?: boolean;
    ariaLabel?: string;
    closeOnContextMenu?: boolean;
    closeOnEnter?: boolean;
    closeOnNestedPopupOutsideClick?: boolean;
    closeOnWheel?: boolean;
    focusTarget?: React.RefObject<HTMLElement> | string;
    isOpen: boolean;
    isPinned?: boolean;
    left: number;
    moveFocus?: boolean;
    offset: number;
    onClose?: () => void;
    onContextMenu?: (e: MouseEvent) => void;
    onEnter?: () => void;
    onOpen?: () => void;
    onOutsideClick?: (e: MouseEvent) => void;
    onWheel?: (e: WheelEvent) => void;
    position: RelativePosition;
    role?: "dialog" | "alert" | "alertdialog";
    showArrow: boolean;
    showShadow: boolean;
    target?: HTMLElement | null;
    top: number;
}

// @beta
export class ProcessSettingsContainerCloseEvent extends BeUiEvent<ProcessSettingsContainerCloseEventArgs> {
}

// @beta
export interface ProcessSettingsContainerCloseEventArgs {
    // (undocumented)
    readonly closeFunc: (args: any) => void;
    // (undocumented)
    readonly closeFuncArgs?: any;
}

// @beta
export class ProcessSettingsTabActivationEvent extends BeUiEvent<ProcessSettingsTabActivationEventArgs> {
}

// @beta
export interface ProcessSettingsTabActivationEventArgs {
    // (undocumented)
    readonly requestedSettingsTabId: string;
    // (undocumented)
    readonly tabSelectionFunc: (tabId: string) => void;
}

// @beta
export function ProgressBar(props: ProgressBarProps): JSX.Element;

// @beta
export interface ProgressBarProps extends CommonProps {
    barHeight?: number;
    indeterminate?: boolean;
    labelLeft?: string;
    labelRight?: string;
    percent?: number;
}

// @beta
export function ProgressSpinner(props: ProgressSpinnerProps): JSX.Element;

// @beta
export interface ProgressSpinnerProps extends CommonProps {
    children?: React.ReactNode;
    error?: boolean;
    indeterminate?: boolean;
    size?: SpinnerSize;
    success?: boolean;
    value?: number;
}

// @internal
export const PROXIMITY_THRESHOLD_DEFAULT = 100;

// @beta
export class RadialButton extends React.Component<RadialButtonProps, RadialButtonState> {
    constructor(props: RadialButtonProps);
    // (undocumented)
    render(): JSX.Element;
    select: () => void;
    // @internal (undocumented)
    readonly state: Readonly<RadialButtonState>;
}

// @beta
export interface RadialButtonProps extends CommonProps {
    // @internal (undocumented)
    annularSector?: AnnularSector;
    icon?: IconSpec;
    labelRotate?: boolean;
    onSelect?: (e: any) => any;
    selected?: boolean;
}

// @beta
export class RadialMenu extends React.Component<RadialMenuProps, RadialMenuState> {
    constructor(props: RadialMenuProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: RadialMenuProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: Partial<RadialMenuProps>;
    // (undocumented)
    render(): JSX.Element;
    select: () => void;
    // @internal (undocumented)
    readonly state: Readonly<RadialMenuState>;
}

// @beta
export interface RadialMenuProps extends CommonProps {
    innerRadius: number;
    labelRotate?: boolean;
    left?: number | string;
    onBlur?: (event: any) => any;
    onEsc?: (event: any) => any;
    opened: boolean;
    outerRadius: number;
    selected?: number;
    top?: number | string;
}

// @public
export class Radio extends React.PureComponent<RadioProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface RadioProps extends React.InputHTMLAttributes<HTMLInputElement>, CommonProps, LabeledComponentProps {
}

// @public
export interface RatioChangeResult {
    // (undocumented)
    ratio: number;
}

// @public
export interface ReactMessage {
    // (undocumented)
    reactNode: React.ReactNode;
}

// @internal @deprecated (undocumented)
export class ReactNumericInput extends React.Component<ReactNumericInputProps, ReactNumericInputState> {
    constructor(props: ReactNumericInputProps);
    componentDidMount(): void;
    componentDidUpdate(prevProps: ReactNumericInputProps, prevState: ReactNumericInputState): void;
    componentWillUnmount(): void;
    static defaultProps: {
        step: number;
        min: number;
        max: number;
        precision: null;
        parse: null;
        format: null;
        mobile: string;
        strict: boolean;
        componentClass: string;
        style: {};
    };
    static DELAY: number;
    static DIRECTION_DOWN: string;
    static DIRECTION_UP: string;
    // (undocumented)
    refsInput: HTMLInputElement | undefined;
    render(): JSX.Element;
    static SPEED: number;
    }

// @beta @deprecated
export interface ReactNumericInputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "min" | "max" | "step" | "onChange" | "defaultValue" | "onInvalid">, CommonProps {
    // (undocumented)
    componentClass?: string;
    // (undocumented)
    defaultValue?: number | string;
    // (undocumented)
    format?: ((value: number | null, strValue: string) => string);
    // (undocumented)
    max?: BoundsFunctionProp;
    // (undocumented)
    maxLength?: number;
    // (undocumented)
    min?: BoundsFunctionProp;
    // (undocumented)
    mobile?: boolean | "auto" | (() => boolean);
    // (undocumented)
    noStyle?: boolean;
    // (undocumented)
    noValidate?: boolean | string;
    // (undocumented)
    onBlur?: React.FocusEventHandler<HTMLDivElement | HTMLInputElement>;
    // (undocumented)
    onChange?: ((value: number | null, stringValue: string, input: HTMLInputElement) => void);
    // (undocumented)
    onFocus?: React.FocusEventHandler<HTMLDivElement | HTMLInputElement>;
    // (undocumented)
    onInput?: React.FormEventHandler<HTMLInputElement>;
    // (undocumented)
    onInvalid?: ((error: string, value: number | null, stringValue: string) => void);
    // (undocumented)
    onKeyDown?: React.KeyboardEventHandler<HTMLDivElement | HTMLInputElement>;
    // (undocumented)
    onSelect?: React.ReactEventHandler<HTMLInputElement>;
    // (undocumented)
    onValid?: ((value: number | null, stringValue: string) => void);
    // (undocumented)
    parse?: ((value: string) => number | null);
    // (undocumented)
    precision?: number | (() => number | null | undefined);
    setFocus?: boolean;
    // (undocumented)
    snap?: boolean;
    // @internal (undocumented)
    step?: ReactStepFunctionProp;
    // (undocumented)
    strict: boolean;
    // (undocumented)
    value?: number | string;
}

// @internal @deprecated (undocumented)
export type ReactStepFunctionProp = number | ((component: ReactNumericInput, direction: string) => number | undefined);

// @internal
export class Rectangle implements RectangleProps {
    constructor(left?: number, top?: number, right?: number, bottom?: number);
    // (undocumented)
    readonly bottom: number;
    // (undocumented)
    center(): Point;
    // (undocumented)
    containHorizontallyIn(other: RectangleProps): Rectangle;
    // (undocumented)
    containIn(other: RectangleProps): Rectangle;
    // (undocumented)
    contains(other: RectangleProps): boolean;
    containsPoint(point: PointProps): boolean;
    // (undocumented)
    containVerticallyIn(other: RectangleProps): Rectangle;
    static create(props: RectangleProps): Rectangle;
    static createFromSize(size: SizeProps): Rectangle;
    equals(other: RectangleProps): boolean;
    // (undocumented)
    getCorner(corner: Corner): Point;
    // (undocumented)
    getHeight(): number;
    getHorizontalSegmentBounds(segmentId: number, numberOfSegments: number): Rectangle;
    getShortestDistanceToPoint(point: PointProps): number;
    // (undocumented)
    getSize(): Size;
    getVerticalSegmentBounds(segmentId: number, numberOfSegments: number): Rectangle;
    // (undocumented)
    getWidth(): number;
    inset(left: number, top: number, right: number, bottom: number): Rectangle;
    // (undocumented)
    intersects(other: RectangleProps): boolean;
    // (undocumented)
    readonly left: number;
    offset(offset: PointProps): Rectangle;
    offsetX(offset: number): Rectangle;
    offsetY(offset: number): Rectangle;
    outerMergeWith(other: RectangleProps): Rectangle;
    // (undocumented)
    readonly right: number;
    setHeight(height: number): Rectangle;
    setPosition(position: PointProps): Rectangle;
    setSize(size: SizeProps): Rectangle;
    setWidth(width: number): Rectangle;
    // (undocumented)
    readonly top: number;
    // (undocumented)
    topLeft(): Point;
    // (undocumented)
    toProps(): RectangleProps;
}

// @public
export interface RectangleProps {
    // (undocumented)
    readonly bottom: number;
    // (undocumented)
    readonly left: number;
    // (undocumented)
    readonly right: number;
    // (undocumented)
    readonly top: number;
}

// @internal (undocumented)
export const ResizeObserver: ResizeObserverType;

// @internal (undocumented)
export type ResizeObserverType = typeof import("resize-observer-polyfill").default;

// @beta
export class ScrollPositionMaintainer implements IDisposable {
    constructor(el: Element);
    // (undocumented)
    dispose(): void;
    }

// @public
export function ScrollView(props: CommonDivProps): JSX.Element;

// @public
export class SearchBox extends React.Component<SearchBoxProps, SearchBoxState> {
    constructor(props: SearchBoxProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    focus(): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<SearchBoxState>;
    }

// @public
export interface SearchBoxProps extends CommonProps {
    initialValue?: string;
    onClear?: () => void;
    onEnterPressed?: () => void;
    onEscPressed?: () => void;
    onValueChanged: (value: string) => void;
    placeholder?: string;
    valueChangedDelay?: number;
}

// @public
export const Select: (props: SelectProps) => JSX.Element | null;

// @public
export interface SelectOption {
    disabled?: boolean;
    label: string;
    value?: string | number | readonly string[];
}

// @public
export interface SelectProps extends React.SelectHTMLAttributes<HTMLSelectElement>, CommonProps {
    options: (string | SelectOption)[] | {
        [key: string]: (string | SelectOption);
    };
    ref?: React.Ref<HTMLSelectElement>;
    setFocus?: boolean;
}

// @beta
export class SessionUiSettings implements UiSettings {
    constructor(w?: Window);
    // (undocumented)
    deleteSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    getSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    saveSetting(settingNamespace: string, settingName: string, setting: any): Promise<UiSettingsResult>;
    // (undocumented)
    w: Window;
}

// @beta
export const SettingsContainer: ({ tabs, onSettingsTabSelected, currentSettingsTab, settingsManager }: SettingsContainerProps) => JSX.Element;

// @beta (undocumented)
export interface SettingsContainerProps {
    // (undocumented)
    currentSettingsTab?: SettingsTabEntry;
    // (undocumented)
    onSettingsTabSelected?: (tab: SettingsTabEntry) => void;
    // (undocumented)
    settingsManager: SettingsManager;
    // (undocumented)
    tabs: SettingsTabEntry[];
}

// @beta
export class SettingsManager {
    activateSettingsTab(settingsTabId: string): void;
    // (undocumented)
    addSettingsProvider(settingsProvider: SettingsProvider): void;
    closeSettingsContainer(closeFunc: (args: any) => void, closeFuncArgs?: any): void;
    getSettingEntries(stageId: string, stageUsage: string): Array<SettingsTabEntry>;
    // @internal
    readonly onActivateSettingsTab: ActivateSettingsTabEvent;
    // @internal
    readonly onCloseSettingsContainer: CloseSettingsContainerEvent;
    readonly onProcessSettingsContainerClose: ProcessSettingsContainerCloseEvent;
    readonly onProcessSettingsTabActivation: ProcessSettingsTabActivationEvent;
    readonly onSettingsProvidersChanged: SettingsProvidersChangedEvent;
    // (undocumented)
    get providers(): ReadonlyArray<SettingsProvider>;
    set providers(p: ReadonlyArray<SettingsProvider>);
    // (undocumented)
    removeSettingsProvider(providerId: string): boolean;
}

// @beta
export interface SettingsProvider {
    // (undocumented)
    getSettingEntries(stageId: string, stageUsage: string): ReadonlyArray<SettingsTabEntry> | undefined;
    readonly id: string;
}

// @beta
export class SettingsProvidersChangedEvent extends BeUiEvent<SettingsProvidersChangedEventArgs> {
}

// @beta
export interface SettingsProvidersChangedEventArgs {
    // (undocumented)
    readonly providers: ReadonlyArray<SettingsProvider>;
}

// @beta
export interface SettingsTabEntry {
    readonly icon?: string | JSX.Element;
    readonly isDisabled?: boolean | ConditionalBooleanValue;
    readonly itemPriority: number;
    readonly label: string;
    readonly page: JSX.Element;
    readonly pageWillHandleCloseRequest?: boolean;
    readonly subLabel?: string;
    readonly tabId: string;
    readonly tooltip?: string | JSX.Element;
}

// @internal
export const shallowDiffers: (a: {
    [key: string]: any;
} | undefined, b: {
    [key: string]: any;
} | undefined) => boolean;

// @internal
export class Size implements SizeProps {
    constructor(width?: number, height?: number);
    static create(size: SizeProps): Size;
    equals(other: SizeProps): boolean;
    // (undocumented)
    readonly height: number;
    // (undocumented)
    readonly width: number;
}

// @public
export interface SizeProps {
    // (undocumented)
    readonly height: number;
    // (undocumented)
    readonly width: number;
}

// @public
export function Slider(props: SliderProps): JSX.Element;

// @public
export interface SliderProps extends CommonProps {
    disabled?: boolean;
    formatMax?: (value: number) => string;
    formatMin?: (value: number) => string;
    formatTick?: (tick: number) => string;
    formatTooltip?: (value: number) => string;
    getTickCount?: () => number;
    getTickValues?: () => number[];
    includeTicksInWidth?: boolean;
    max: number;
    maxImage?: React.ReactNode;
    min: number;
    minImage?: React.ReactNode;
    mode?: number | SliderModeFunction;
    onChange?: (values: ReadonlyArray<number>) => void;
    onSlideEnd?: (values: ReadonlyArray<number>) => void;
    onSlideStart?: (values: ReadonlyArray<number>) => void;
    onUpdate?: (values: ReadonlyArray<number>) => void;
    reversed?: boolean;
    showMinMax?: boolean;
    showTickLabels?: boolean;
    showTicks?: boolean;
    showTooltip?: boolean;
    step?: number;
    tooltipBelow?: boolean;
    values: number[];
}

// @public
export function SmallText(props: TextProps): JSX.Element;

// @public
export enum SortDirection {
    // (undocumented)
    Ascending = 1,
    // (undocumented)
    Descending = 2,
    // (undocumented)
    NoSort = 0
}

// @public
export class Spinner extends React.PureComponent<SpinnerProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface SpinnerProps {
    size?: SpinnerSize;
    sizeClass?: string;
}

// @public
export enum SpinnerSize {
    Large = 2,
    Medium = 1,
    Small = 0,
    XLarge = 3
}

// @public
export class SplitButton extends React.Component<SplitButtonProps, SplitButtonState> {
    constructor(props: SplitButtonProps);
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<SplitButtonState>;
}

// @internal (undocumented)
export enum SplitButtonActionType {
    // (undocumented)
    ContextMenu = 0,
    // (undocumented)
    List = 1
}

// @public
export interface SplitButtonProps extends CommonProps {
    buttonType?: ButtonType;
    drawBorder?: boolean;
    icon?: IconSpec;
    // @internal (undocumented)
    initialExpanded?: boolean;
    label: string | React.ReactNode;
    onClick?: (event: any) => any;
    onExecute?: () => any;
    popupPosition?: RelativePosition;
    toolTip?: string;
}

// @beta
export type StepFunctionProp = number | ((direction: string) => number | undefined);

// @public
export function StyledText(props: StyledTextProps): JSX.Element;

// @public
export interface StyledTextProps extends TextProps {
    mainClassName: string;
}

// @public
export function Subheading(props: TextProps): JSX.Element;

// @public
export function Subheading2(props: TextProps): JSX.Element;

// @public
export class SvgPath extends React.PureComponent<SvgPathProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface SvgPathProps extends CommonProps {
    paths: string[];
    viewBoxHeight: number;
    viewBoxWidth: number;
}

// @public
export class SvgSprite extends React.PureComponent<SvgSpriteProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface SvgSpriteProps extends CommonProps {
    src: string;
}

// @beta
export interface TabLabel {
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    icon?: string | JSX.Element;
    // (undocumented)
    label: string;
    // (undocumented)
    subLabel?: string;
    // (undocumented)
    tabId: string;
    tooltip?: string | JSX.Element;
}

// @public
export class Tabs extends React.PureComponent<MainTabsProps, TabsState> {
    constructor(props: MainTabsProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: MainTabsProps): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @public
export interface TabsProps extends React.AllHTMLAttributes<HTMLUListElement>, CommonProps {
    activeIndex?: number;
    green?: boolean;
    // @beta
    labels: Array<string | TabLabel>;
    onActivateTab?: (index: number) => any;
    // @deprecated
    onClickLabel?: (index: number) => any;
}

// @public
export const Textarea: (props: TextareaProps) => JSX.Element | null;

// @public
export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement>, CommonProps {
    ref?: React.Ref<HTMLTextAreaElement>;
    rows?: number;
    setFocus?: boolean;
}

// @public
export interface TextProps extends React.AllHTMLAttributes<HTMLSpanElement>, CommonProps {
}

// @beta
export function ThemedSelect(props: ThemedSelectProps): JSX.Element;

// @beta
export type ThemedSelectProps = {
    "aria-label"?: string;
    "aria-labelledby"?: string;
    autoFocus?: boolean;
    backspaceRemovesValue?: boolean;
    blurInputOnSelect?: boolean;
    captureMenuScroll?: boolean;
    className?: string;
    closeMenuOnSelect?: boolean;
    closeMenuOnScroll?: boolean | EventListener;
    components?: SelectComponentsConfig<OptionType>;
    controlShouldRenderValue?: boolean;
    defaultMenuIsOpen?: boolean;
    defaultValue?: ValueType<OptionType>;
    divRef?: React.Ref<HTMLDivElement>;
    escapeClearsValue?: boolean;
    filterOption?: ((option: OptionType, rawInput: string) => boolean) | null;
    formatGroupLabel?: typeof formatGroupLabel;
    formatOptionLabel?: (optionType: OptionType, formatLabelMeta: FormatOptionLabelMeta) => React.ReactNode;
    getOptionLabel?: typeof getOptionLabel;
    getOptionValue?: typeof getOptionValue;
    hideSelectedOptions?: boolean;
    id?: string;
    inputValue?: string;
    inputId?: string;
    instanceId?: number | string;
    isClearable?: boolean;
    isDisabled?: boolean;
    isLoading?: boolean;
    isOptionDisabled?: (option: OptionType, options: OptionsType) => boolean | false;
    isMulti?: boolean;
    isMenuFixed?: boolean;
    isRtl?: boolean;
    isSearchable?: boolean;
    minMenuHeight?: number;
    maxMenuHeight?: number;
    menuIsOpen?: boolean;
    menuShouldBlockScroll?: boolean;
    menuShouldScrollIntoView?: boolean;
    name?: string;
    noOptionsMessage?: (obj: {
        inputValue: string;
    }) => string | null;
    onBlur?: FocusEventHandler;
    onChange?: (value: ValueType<OptionType>, action: ActionMeta<OptionType>) => void;
    onFocus?: FocusEventHandler;
    onInputChange?: (newValue: string, actionMeta?: InputActionMeta) => void;
    onKeyDown?: KeyboardEventHandler;
    onMenuOpen?: () => void;
    onMenuClose?: () => void;
    onMenuScrollToTop?: (e: React.SyntheticEvent<HTMLElement>) => void;
    onMenuScrollToBottom?: (e: React.SyntheticEvent<HTMLElement>) => void;
    openMenuOnFocus?: boolean;
    openMenuOnClick?: boolean;
    options: OptionsType;
    pageSize?: number;
    placeholder?: string;
    ref?: React.Ref<Component>;
    styles?: React.CSSProperties;
    tabIndex?: string;
    tabSelectsValue?: boolean;
    value?: ValueType<OptionType>;
};

// @beta
export class Tile extends React.Component<TileProps> {
    // @internal (undocumented)
    static readonly defaultProps: TileDefaultProps;
    // @internal (undocumented)
    render(): JSX.Element;
}

// @internal (undocumented)
export type TileDefaultProps = Pick<TileProps, "stepNum">;

// @beta
export interface TileProps extends CommonDivProps {
    // (undocumented)
    featured?: boolean;
    // (undocumented)
    href?: string;
    // (undocumented)
    icon?: string | React.ReactNode;
    // (undocumented)
    minimal?: boolean;
    // (undocumented)
    onClick?: (e: any) => any;
    // (undocumented)
    stepCount?: number;
    // (undocumented)
    stepNum?: number;
    // (undocumented)
    title: string;
}

// @public
export enum TimeFormat {
    Long = 2,
    None = 0,
    Short = 1
}

// @public
export class Timer {
    constructor(msDelay: number);
    get delay(): number;
    set delay(ms: number);
    get isRunning(): boolean;
    setOnExecute(onExecute: ExecuteHandler | undefined): void;
    start(): void;
    stop(): void;
    }

// @public
export function Title(props: TextProps): JSX.Element;

// @public
export function Title2(props: TextProps): JSX.Element;

// @public
export const Toggle: (props: ToggleProps) => JSX.Element | null;

// @public
export enum ToggleButtonType {
    Blue = 1,
    Primary = 0
}

// @public
export interface ToggleProps extends CommonProps {
    buttonType?: ToggleButtonType;
    disabled?: boolean;
    isOn?: boolean;
    large?: boolean;
    onBlur?: (event: React.FocusEvent) => any;
    onChange?: (checked: boolean) => any;
    ref?: React.Ref<HTMLInputElement>;
    rounded?: boolean;
    setFocus?: boolean;
    showCheckmark?: boolean;
    title?: string;
}

// @internal
export const TOOLBAR_BACKDROP_FILTER_BLUR_DEFAULT = 10;

// @internal
export const TOOLBAR_BOX_SHADOW_OPACITY_DEFAULT = 0.35;

// @internal
export const TOOLBAR_OPACITY_DEFAULT = 0.5;

// @beta
export function Tooltip(props: TooltipProps): JSX.Element;

// @beta
export type TooltipPlacement = "bottom" | "left" | "right" | "top";

// @beta
export interface TooltipProps extends CommonProps {
    children?: React.ReactNode;
    placement?: TooltipPlacement;
    target?: HTMLElement;
    visible?: boolean;
}

// @public
export class Tree extends React.PureComponent<TreeProps> {
    // (undocumented)
    getElementsByClassName(className: string): Element[];
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    scrollToElement(element: Element): void;
    // (undocumented)
    setFocusByClassName(selector: string): boolean;
    }

// @public
export class TreeBranch extends React.PureComponent<TreeBranchProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface TreeBranchProps extends CommonProps {
    children?: React.ReactNode;
}

// @public
export class TreeNode extends React.Component<TreeNodeProps> {
    constructor(props: TreeNodeProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public
export class TreeNodePlaceholder extends React.PureComponent<TreeNodePlaceholderProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface TreeNodePlaceholderProps extends CommonProps {
    // (undocumented)
    ["data-testid"]?: string;
    // (undocumented)
    level: number;
    // (undocumented)
    maxWidth?: number;
    // (undocumented)
    minWidth?: number;
}

// @public
export interface TreeNodeProps extends CommonProps {
    // (undocumented)
    ["data-testid"]?: string;
    // @beta
    checkboxProps?: NodeCheckboxProps;
    // (undocumented)
    children?: React.ReactNode;
    // (undocumented)
    icon?: React.ReactChild;
    // (undocumented)
    isExpanded?: boolean;
    // (undocumented)
    isFocused?: boolean;
    // (undocumented)
    isHoverDisabled?: boolean;
    // (undocumented)
    isLeaf?: boolean;
    // (undocumented)
    isLoading?: boolean;
    // (undocumented)
    isSelected?: boolean;
    // (undocumented)
    label: React.ReactNode;
    // (undocumented)
    level: number;
    // (undocumented)
    onClick?: (e: React.MouseEvent) => void;
    // (undocumented)
    onClickExpansionToggle?: () => void;
    // (undocumented)
    onContextMenu?: (e: React.MouseEvent) => void;
    // (undocumented)
    onMouseDown?: (e: React.MouseEvent) => void;
    // (undocumented)
    onMouseMove?: (e: React.MouseEvent) => void;
    // (undocumented)
    onMouseUp?: (e: React.MouseEvent) => void;
    renderOverrides?: {
        renderCheckbox?: NodeCheckboxRenderer;
    };
}

// @public
export interface TreeProps extends CommonProps {
    // (undocumented)
    children?: React.ReactNode;
    // (undocumented)
    onKeyDown?: React.KeyboardEventHandler<HTMLDivElement>;
    // (undocumented)
    onKeyUp?: React.KeyboardEventHandler<HTMLDivElement>;
    // (undocumented)
    onMouseDown?: React.MouseEventHandler<HTMLDivElement>;
    // (undocumented)
    onMouseMove?: React.MouseEventHandler<HTMLDivElement>;
    // (undocumented)
    onMouseUp?: React.MouseEventHandler<HTMLDivElement>;
}

// @public
export class UiCore {
    static get i18n(): I18N;
    static get i18nNamespace(): string;
    static initialize(i18n: I18N): Promise<void>;
    static get initialized(): boolean;
    // @internal (undocumented)
    static loggerCategory(obj: any): string;
    // @internal (undocumented)
    static get packageName(): string;
    static terminate(): void;
    // @internal
    static translate(key: string | string[]): string;
}

// @public
export class UiEvent<TEventArgs> extends BeUiEvent<TEventArgs> {
}

// @beta
export class UiSetting<T> {
    constructor(settingNamespace: string, settingName: string, getValue: () => T, applyValue?: ((v: T) => void) | undefined);
    // (undocumented)
    applyValue?: ((v: T) => void) | undefined;
    deleteSetting(uiSettings: UiSettings): Promise<UiSettingsResult>;
    getSetting(uiSettings: UiSettings): Promise<UiSettingsResult>;
    getSettingAndApplyValue(uiSettings: UiSettings): Promise<UiSettingsResult>;
    // (undocumented)
    getValue: () => T;
    saveSetting(uiSettings: UiSettings): Promise<UiSettingsResult>;
    // (undocumented)
    settingName: string;
    // (undocumented)
    settingNamespace: string;
}

// @public
export interface UiSettings {
    // (undocumented)
    deleteSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    getSetting(settingNamespace: string, settingName: string): Promise<UiSettingsResult>;
    // (undocumented)
    saveSetting(settingNamespace: string, settingName: string, setting: any): Promise<UiSettingsResult>;
}

// @public
export interface UiSettingsResult {
    // (undocumented)
    setting?: any;
    // (undocumented)
    status: UiSettingsStatus;
}

// @public
export enum UiSettingsStatus {
    // (undocumented)
    AuthorizationError = 4,
    // (undocumented)
    NotFound = 1,
    // (undocumented)
    Success = 0,
    // (undocumented)
    Uninitialized = 3,
    // (undocumented)
    UnknownError = 2
}

// @public
export function UnderlinedButton(props: UnderlinedButtonProps): JSX.Element;

// @public
export interface UnderlinedButtonProps {
    children: string | React.ReactNode;
    className?: string;
    onActivate?: () => void;
    onClick?: (e: React.MouseEvent) => void;
    title?: string;
}

// @public
export function useDisposable<TDisposable extends IDisposable>(createDisposable: () => TDisposable): TDisposable;

// @public
export function useEffectSkipFirst(callback: () => (void | (() => void | undefined)) | void, deps?: any[]): void;

// @internal
export function useOnOutsideClick<T extends Element>(onOutsideClick?: () => void,
outsideEventPredicate?: (e: OutsideClickEvent) => boolean): React.RefObject<T>;

// @public
export function useOptionalDisposable<TDisposable extends IDisposable>(createDisposable: () => TDisposable | undefined): TDisposable | undefined;

// @internal
export const useProximityToMouse: (elementSet: WidgetElementSet, snap?: boolean, threshold?: number) => number;

// @internal
export function useRefEffect<T>(callback: (instance: T | null) => (void | (() => void)), deps: ReadonlyArray<any>): (instance: T | null) => void;

// @internal
export function useRefs<T>(...refs: ReadonlyArray<React.Ref<T>>): (instance: T | null) => void;

// @internal
export function useRefState<T>(): [React.Ref<T>, T | undefined];

// @internal
export function useResizeObserver<T extends Element>(onResize?: (width: number, height: number) => void): (instance: T | null) => void;

// @beta
export function useSaveBeforeActivatingNewSettingsTab(settingsManager: SettingsManager, saveFunction: (tabSelectionFunc: (args: any) => void, requestedSettingsTabId?: string) => void): void;

// @beta
export function useSaveBeforeClosingSettingsContainer(settingsManager: SettingsManager, saveFunction: (closeFunc: (args: any) => void, closeFuncArgs?: any) => void): void;

// @internal
export const useTargeted: (ref: React.RefObject<Element>) => boolean;

// @internal
export function useWidgetOpacityContext(): WidgetOpacityContextProps;

// @public
export enum VerticalAlignment {
    // (undocumented)
    Bottom = 3,
    // (undocumented)
    Middle = 2,
    // (undocumented)
    Top = 1
}

// @public
export function VerticalTabs(props: TabsProps): JSX.Element;

// @public
export function WebFontIcon(props: WebFontIconProps): JSX.Element;

// @public
export interface WebFontIconProps extends CommonProps {
    iconClassName?: string;
    iconName: string;
    iconSize?: "x-small" | "small" | "medium" | "large" | "x-large";
    onClick?: React.MouseEventHandler<HTMLSpanElement>;
    title?: string;
}

// @internal (undocumented)
export class WidgetElementSet extends Set<React.RefObject<Element>> {
}

// @internal
export const WidgetOpacityContext: React.Context<WidgetOpacityContextProps>;

// @internal
export interface WidgetOpacityContextProps {
    // (undocumented)
    readonly onElementRef: (elementRef: React.RefObject<Element>) => void;
    // (undocumented)
    readonly proximityScale: number;
}

// @public
export const withIsPressed: <ComponentProps extends {}>(Component: React.ComponentType<ComponentProps>) => {
    new (props: Readonly<ComponentProps & WithIsPressedProps>): {
        handleOnPointerDown: () => void;
        handleOnPointerUp: () => void;
        handleOnMouseLeave: () => void;
        changeIsPressed: (isPressed: boolean) => void;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithIsPressedProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithIsPressedProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithIsPressedProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<ComponentProps & WithIsPressedProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: ComponentProps & WithIsPressedProps, context?: any): {
        handleOnPointerDown: () => void;
        handleOnPointerUp: () => void;
        handleOnMouseLeave: () => void;
        changeIsPressed: (isPressed: boolean) => void;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithIsPressedProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithIsPressedProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithIsPressedProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<ComponentProps & WithIsPressedProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithIsPressedProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};

// @public
export interface WithIsPressedProps {
    isPressed?: boolean;
    onIsPressedChange?: (isPressed: boolean) => void;
}

// @public
export const withOnOutsideClick: <ComponentProps extends {}>(Component: React.ComponentType<ComponentProps>, defaultOnOutsideClick?: ((event: MouseEvent) => any) | undefined, useCapture?: boolean, usePointerEvents?: boolean) => {
    new (props: Readonly<ComponentProps & WithOnOutsideClickProps>): {
        ref: React.RefObject<HTMLDivElement>;
        isDownOutside: boolean;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isInCorePopup(element: HTMLElement): boolean;
        onOutsideClick(e: MouseEvent): any;
        handleDocumentClick: (e: MouseEvent) => any;
        handleDocumentPointerDown: (e: PointerEvent) => void;
        handleDocumentPointerUp: (e: PointerEvent) => any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithOnOutsideClickProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithOnOutsideClickProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithOnOutsideClickProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<ComponentProps & WithOnOutsideClickProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: ComponentProps & WithOnOutsideClickProps, context?: any): {
        ref: React.RefObject<HTMLDivElement>;
        isDownOutside: boolean;
        componentDidMount(): void;
        componentWillUnmount(): void;
        isInCorePopup(element: HTMLElement): boolean;
        onOutsideClick(e: MouseEvent): any;
        handleDocumentClick: (e: MouseEvent) => any;
        handleDocumentPointerDown: (e: PointerEvent) => void;
        handleDocumentPointerUp: (e: PointerEvent) => any;
        render(): JSX.Element;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithOnOutsideClickProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithOnOutsideClickProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithOnOutsideClickProps>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<ComponentProps & WithOnOutsideClickProps>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithOnOutsideClickProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};

// @public
export interface WithOnOutsideClickProps {
    closeOnNestedPopupOutsideClick?: boolean;
    onOutsideClick?: (event: MouseEvent) => any;
}

// @public
export const withTimeout: <ComponentProps extends {}>(Component: React.ComponentType<ComponentProps>) => {
    new (props: Readonly<ComponentProps & WithTimeoutProps>): {
        timer: Timer;
        componentDidMount(): void;
        componentDidUpdate(_prevProps: Readonly<ComponentProps & WithTimeoutProps>): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
        startTimer(timeout: number): void;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithTimeoutProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithTimeoutProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithTimeoutProps>, prevState: Readonly<{}>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: ComponentProps & WithTimeoutProps, context?: any): {
        timer: Timer;
        componentDidMount(): void;
        componentDidUpdate(_prevProps: Readonly<ComponentProps & WithTimeoutProps>): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
        startTimer(timeout: number): void;
        context: any;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<ComponentProps & WithTimeoutProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps & WithTimeoutProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps & WithTimeoutProps>, prevState: Readonly<{}>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps & WithTimeoutProps>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};

// @public
export interface WithTimeoutProps {
    onTimeout?: () => void;
    timeout: number;
}


// (No @packageDocumentation comment for this package)

```
