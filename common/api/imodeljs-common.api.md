## API Report File for "@bentley/imodeljs-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Angle } from '@bentley/geometry-core';
import { AngleProps } from '@bentley/geometry-core';
import { AnyGeometryQuery } from '@bentley/geometry-core';
import { AuthorizedClientRequestContext } from '@bentley/itwin-client';
import { AuthStatus } from '@bentley/bentleyjs-core';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyError } from '@bentley/bentleyjs-core';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { BriefcaseStatus } from '@bentley/bentleyjs-core';
import { ByteStream } from '@bentley/bentleyjs-core';
import { ChangeSetStatus } from '@bentley/bentleyjs-core';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClipPlane } from '@bentley/geometry-core';
import { ClipPlaneContainment } from '@bentley/geometry-core';
import { ClipVector } from '@bentley/geometry-core';
import { CompressedId64Set } from '@bentley/bentleyjs-core';
import { ConvexClipPlaneSet } from '@bentley/geometry-core';
import { DbOpcode } from '@bentley/bentleyjs-core';
import { DbResult } from '@bentley/bentleyjs-core';
import { GeometryQuery } from '@bentley/geometry-core';
import { GeoServiceStatus } from '@bentley/bentleyjs-core';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GuidString } from '@bentley/bentleyjs-core';
import { Id64 } from '@bentley/bentleyjs-core';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64Set } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelClient } from '@bentley/imodelhub-client';
import { IModelJson } from '@bentley/geometry-core';
import { IModelStatus } from '@bentley/bentleyjs-core';
import { IndexedPolyfaceVisitor } from '@bentley/geometry-core';
import { IndexedValue } from '@bentley/bentleyjs-core';
import { IndexMap } from '@bentley/bentleyjs-core';
import { LockLevel } from '@bentley/imodelhub-client';
import { LogFunction } from '@bentley/bentleyjs-core';
import { LogLevel } from '@bentley/bentleyjs-core';
import { LowAndHighXY } from '@bentley/geometry-core';
import { LowAndHighXYZ } from '@bentley/geometry-core';
import { Map4d } from '@bentley/geometry-core';
import { Matrix3d } from '@bentley/geometry-core';
import { Matrix4dProps } from '@bentley/geometry-core';
import { OpenMode } from '@bentley/bentleyjs-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { PolyfaceVisitor } from '@bentley/geometry-core';
import { Range1d } from '@bentley/geometry-core';
import { Range1dProps } from '@bentley/geometry-core';
import { Range2d } from '@bentley/geometry-core';
import { Range3d } from '@bentley/geometry-core';
import { Range3dProps } from '@bentley/geometry-core';
import { Readable } from 'stream';
import { RepositoryStatus } from '@bentley/bentleyjs-core';
import { RpcInterfaceStatus } from '@bentley/bentleyjs-core';
import { SerializedClientRequestContext } from '@bentley/bentleyjs-core';
import { Transform } from '@bentley/geometry-core';
import { TransformProps } from '@bentley/geometry-core';
import { Vector2d } from '@bentley/geometry-core';
import { Vector3d } from '@bentley/geometry-core';
import { Writable } from 'stream';
import { XAndY } from '@bentley/geometry-core';
import { XYAndZ } from '@bentley/geometry-core';
import { XYProps } from '@bentley/geometry-core';
import { XYZProps } from '@bentley/geometry-core';
import { YawPitchRollAngles } from '@bentley/geometry-core';
import { YawPitchRollProps } from '@bentley/geometry-core';

// @public
export class AmbientLight {
    constructor(json?: AmbientLightProps);
    clone(changed?: AmbientLightProps): AmbientLight;
    // (undocumented)
    readonly color: RgbColor;
    // (undocumented)
    equals(rhs: AmbientLight): boolean;
    // (undocumented)
    readonly intensity: number;
    // (undocumented)
    toJSON(): AmbientLightProps | undefined;
}

// @public
export interface AmbientLightProps {
    color?: RgbColorProps;
    intensity?: number;
}

// @public
export namespace AmbientOcclusion {
    export interface Props {
        readonly bias?: number;
        readonly blurDelta?: number;
        readonly blurSigma?: number;
        // (undocumented)
        readonly blurTexelStepSize?: number;
        readonly intensity?: number;
        readonly maxDistance?: number;
        readonly texelStepSize?: number;
        readonly zLengthCap?: number;
    }
    export class Settings implements Props {
        // (undocumented)
        readonly bias: number;
        // (undocumented)
        readonly blurDelta: number;
        // (undocumented)
        readonly blurSigma: number;
        // (undocumented)
        readonly blurTexelStepSize: number;
        // (undocumented)
        static defaults: Settings;
        // (undocumented)
        static fromJSON(json?: Props): Settings;
        // (undocumented)
        readonly intensity: number;
        // (undocumented)
        readonly maxDistance: number;
        // (undocumented)
        readonly texelStepSize: number;
        // (undocumented)
        toJSON(): Props;
        // (undocumented)
        readonly zLengthCap: number;
    }
}

// @alpha (undocumented)
export class AnalysisStyle {
    // (undocumented)
    clone(out?: AnalysisStyle): AnalysisStyle;
    // (undocumented)
    copyFrom(source: AnalysisStyle): void;
    // (undocumented)
    displacementChannelName?: string;
    // (undocumented)
    displacementScale?: number;
    // (undocumented)
    static fromJSON(json?: AnalysisStyleProps): AnalysisStyle;
    // (undocumented)
    inputName?: string;
    // (undocumented)
    inputRange?: Range1d;
    // (undocumented)
    normalChannelName?: string;
    // (undocumented)
    scalarChannelName?: string;
    // (undocumented)
    scalarRange?: Range1d;
    // (undocumented)
    scalarThematicSettings?: ThematicGradientSettings;
    // (undocumented)
    toJSON(): AnalysisStyleProps;
}

// @alpha
export interface AnalysisStyleProps {
    // (undocumented)
    displacementChannelName?: string;
    // (undocumented)
    displacementScale?: number;
    // (undocumented)
    inputName?: string;
    // (undocumented)
    inputRange?: Range1dProps;
    // (undocumented)
    normalChannelName?: string;
    // (undocumented)
    scalarChannelName?: string;
    // (undocumented)
    scalarRange?: Range1dProps;
    // (undocumented)
    scalarThematicSettings?: ThematicGradientSettingsProps;
}

// @internal (undocumented)
export enum AntiAliasPref {
    // (undocumented)
    Detect = 0,
    // (undocumented)
    Off = 2,
    // (undocumented)
    On = 1
}

// @public
export interface AreaFillProps {
    backgroundFill?: BackgroundFill;
    color?: ColorDefProps;
    display: FillDisplay;
    gradient?: Gradient.SymbProps;
    transparency?: number;
}

// @public (undocumented)
export namespace AreaPattern {
    // (undocumented)
    export class HatchDefLine implements HatchDefLineProps {
        constructor(json: HatchDefLineProps);
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        dashes?: number[];
        // (undocumented)
        offset?: Point2d;
        // (undocumented)
        through?: Point2d;
    }
    export interface HatchDefLineProps {
        angle?: AngleProps;
        dashes?: number[];
        offset?: XYProps;
        through?: XYProps;
    }
    export class Params {
        // (undocumented)
        angle1?: Angle;
        // (undocumented)
        angle2?: Angle;
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        clone(): Params;
        // (undocumented)
        color?: ColorDef;
        // (undocumented)
        defLines?: HatchDefLine[];
        // (undocumented)
        equals(other: Params): boolean;
        static fromJSON(json?: ParamsProps): Params;
        // (undocumented)
        static getTransformPatternScale(transform: Transform): number;
        // (undocumented)
        invisibleBoundary?: boolean;
        // (undocumented)
        origin?: Point3d;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        snappable?: boolean;
        // (undocumented)
        space1?: number;
        // (undocumented)
        space2?: number;
        // (undocumented)
        symbolId?: Id64String;
        // (undocumented)
        toJSON(): ParamsProps;
        // (undocumented)
        static transformPatternSpace(transform: Transform, oldSpace: number, patRot: Matrix3d, angle?: Angle): number;
        // (undocumented)
        weight?: number;
    }
    export interface ParamsProps {
        angle1?: AngleProps;
        angle2?: AngleProps;
        color?: ColorDefProps;
        defLines?: HatchDefLineProps[];
        invisibleBoundary?: boolean;
        origin?: XYZProps;
        rotation?: YawPitchRollProps;
        scale?: number;
        snappable?: boolean;
        space1?: number;
        space2?: number;
        symbolId?: Id64String;
        weight?: number;
    }
}

export { AuthStatus }

// @public
export interface AuxCoordSystem2dProps extends AuxCoordSystemProps {
    angle?: AngleProps;
    origin?: XYProps;
}

// @public
export interface AuxCoordSystem3dProps extends AuxCoordSystemProps {
    origin?: XYZProps;
    pitch?: AngleProps;
    roll?: AngleProps;
    yaw?: AngleProps;
}

// @public (undocumented)
export interface AuxCoordSystemProps extends ElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    type?: number;
}

// @public
export type AxisAlignedBox3d = Range3d;

// @public
export type AxisAlignedBox3dProps = Range3dProps;

// @internal
export class B3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJson: any;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public (undocumented)
export class BackendError extends IModelError {
    constructor(errorNumber: number, name: string, message: string, log?: LogFunction, category?: string, getMetaData?: GetMetaDataFunction);
}

// @public
export enum BackgroundFill {
    None = 0,
    Outline = 2,
    Solid = 1
}

// @public
export interface BackgroundMapProps {
    applyTerrain?: boolean;
    globeMode?: GlobeMode;
    groundBias?: number;
    nonLocatable?: boolean;
    providerData?: {
        mapType?: BackgroundMapType;
    };
    providerName?: string;
    terrainSettings?: TerrainProps;
    transparency?: number | false;
    useDepthBuffer?: boolean;
}

// @public
export type BackgroundMapProviderName = "BingProvider" | "MapBoxProvider";

// @public
export class BackgroundMapSettings {
    readonly applyTerrain: boolean;
    clone(changedProps?: BackgroundMapProps): BackgroundMapSettings;
    // (undocumented)
    equals(other: BackgroundMapSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    static fromJSON(json?: BackgroundMapProps): BackgroundMapSettings;
    readonly globeMode: GlobeMode;
    readonly groundBias: number;
    get locatable(): boolean;
    readonly mapType: BackgroundMapType;
    readonly providerName: BackgroundMapProviderName;
    readonly terrainSettings: TerrainSettings;
    // (undocumented)
    toJSON(): BackgroundMapProps;
    readonly transparency: number | false;
    get transparencyOverride(): number | undefined;
    readonly useDepthBuffer: boolean;
}

// @public
export enum BackgroundMapType {
    // (undocumented)
    Aerial = 2,
    // (undocumented)
    Hybrid = 3,
    // (undocumented)
    Street = 1
}

// @alpha
export type BaseLayerProps = MapLayerProps | ColorDefProps;

// @alpha
export type BaseLayerSettings = MapLayerSettings | ColorDef;

// @public
export enum BatchType {
    PlanarClassifier = 2,
    Primary = 0,
    VolumeClassifier = 1
}

// @public
export abstract class BentleyCloudRpcConfiguration extends RpcConfiguration {
    static readonly accessControl: {
        allowOrigin: string;
        allowMethods: string;
        allowHeaders: string;
    };
    abstract readonly protocol: BentleyCloudRpcProtocol;
}

// @public
export class BentleyCloudRpcManager extends RpcManager {
    static initializeClient(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[], routing?: RpcRoutingToken): BentleyCloudRpcConfiguration;
    static initializeImpl(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[]): BentleyCloudRpcConfiguration;
    }

// @public
export interface BentleyCloudRpcParams {
    info: OpenAPIInfo;
    pendingRequestListener?: RpcRequestEventHandler;
    protocol?: typeof BentleyCloudRpcProtocol;
    uriPrefix?: string;
}

// @public
export abstract class BentleyCloudRpcProtocol extends WebAppRpcProtocol {
    // (undocumented)
    checkToken: boolean;
    getOperationFromPath(path: string): SerializedRpcOperation;
    inflateToken(tokenFromBody: IModelRpcProps, request: SerializedRpcRequest): IModelRpcProps;
    protocolVersionHeaderName: string;
    serializedClientRequestContextHeaderNames: SerializedClientRequestContext;
    supplyPathForOperation(operation: RpcOperation, request: RpcRequest | undefined): string;
    // @internal
    supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
}

export { BentleyError }

export { BentleyStatus }

// @public
export enum BisCodeSpec {
    // (undocumented)
    annotationFrameStyle = "bis:AnnotationFrameStyle",
    // (undocumented)
    annotationLeaderStyle = "bis:AnnotationLeaderStyle",
    // (undocumented)
    annotationTextStyle = "bis:AnnotationTextStyle",
    // (undocumented)
    auxCoordSystem2d = "bis:AuxCoordSystem2d",
    // (undocumented)
    auxCoordSystem3d = "bis:AuxCoordSystem3d",
    // (undocumented)
    auxCoordSystemSpatial = "bis:AuxCoordSystemSpatial",
    // (undocumented)
    categorySelector = "bis:CategorySelector",
    // (undocumented)
    colorBook = "bis:ColorBook",
    // (undocumented)
    displayStyle = "bis:DisplayStyle",
    // (undocumented)
    drawing = "bis:Drawing",
    // (undocumented)
    drawingCategory = "bis:DrawingCategory",
    // (undocumented)
    geometryPart = "bis:GeometryPart",
    // (undocumented)
    graphicalType2d = "bis:GraphicalType2d",
    // (undocumented)
    informationPartitionElement = "bis:InformationPartitionElement",
    // (undocumented)
    lineStyle = "bis:LineStyle",
    // (undocumented)
    linkElement = "bis:LinkElement",
    // (undocumented)
    modelSelector = "bis:ModelSelector",
    // (undocumented)
    nullCodeSpec = "bis:NullCodeSpec",
    // (undocumented)
    physicalMaterial = "bis:PhysicalMaterial",
    // (undocumented)
    physicalType = "bis:PhysicalType",
    // (undocumented)
    renderMaterial = "bis:RenderMaterial",
    // (undocumented)
    sheet = "bis:Sheet",
    // (undocumented)
    spatialCategory = "bis:SpatialCategory",
    // (undocumented)
    spatialLocationType = "bis:SpatialLocationType",
    // (undocumented)
    subCategory = "bis:SubCategory",
    // (undocumented)
    subject = "bis:Subject",
    // (undocumented)
    templateRecipe2d = "bis:TemplateRecipe2d",
    // (undocumented)
    templateRecipe3d = "bis:TemplateRecipe3d",
    // (undocumented)
    textAnnotationSeed = "bis:TextAnnotationSeed",
    // (undocumented)
    texture = "bis:Texture",
    // (undocumented)
    viewDefinition = "bis:ViewDefinition"
}

// @internal (undocumented)
export function bisectTileRange2d(range: Range3d, takeUpper: boolean): void;

// @internal (undocumented)
export function bisectTileRange3d(range: Range3d, takeUpper: boolean): void;

// @internal
export class BoundingSphere {
    constructor(center?: Point3d, radius?: number);
    // (undocumented)
    center: Point3d;
    // (undocumented)
    init(center: Point3d, radius: number): void;
    // (undocumented)
    radius: number;
    // (undocumented)
    transformBy(transform: Transform, result: BoundingSphere): BoundingSphere;
}

// @beta (undocumented)
export namespace BRepEntity {
    export interface DataProps {
        data?: string;
        faceSymbology?: FaceSymbologyProps[];
        transform?: TransformProps;
        type?: Type;
    }
    export interface FaceSymbologyProps {
        color?: ColorDefProps;
        materialId?: Id64String;
        transparency?: number;
    }
    export enum Type {
        Sheet = 1,
        Solid = 0,
        Wire = 2
    }
}

// @public
export interface BRepPrimitive {
    // @beta (undocumented)
    readonly brep: BRepEntity.DataProps;
    // (undocumented)
    type: "brep";
}

// @internal
export interface BriefcaseDownloader {
    briefcaseProps: BriefcaseProps;
    downloadPromise: Promise<void>;
    requestCancel: () => Promise<boolean>;
}

// @internal
export type BriefcaseKey = string;

// @internal
export interface BriefcaseProps extends RequestBriefcaseProps, DownloadBriefcaseOptions {
    downloadStatus: DownloadBriefcaseStatus;
    fileSize?: number;
    readonly key: BriefcaseKey;
    openMode: OpenMode;
}

export { BriefcaseStatus }

// @beta
export function calculateSolarAngles(date: Date, location: Cartographic): {
    azimuth: number;
    elevation: number;
};

// @beta
export function calculateSolarDirection(date: Date, location: Cartographic): Vector3d;

// @beta
export function calculateSolarDirectionFromAngles(azimuthElevation: {
    azimuth: number;
    elevation: number;
}): Vector3d;

// @beta
export function calculateSunriseOrSunset(date: Date, location: Cartographic, sunrise: boolean): Date;

// @public (undocumented)
export interface CalloutProps extends GeometricElement2dProps {
    // (undocumented)
    drawingModel?: RelatedElementProps;
}

// @public
export class Camera implements CameraProps {
    constructor(props?: CameraProps);
    // (undocumented)
    clone(): Camera;
    // (undocumented)
    equals(other: Camera): boolean;
    // (undocumented)
    readonly eye: Point3d;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    getEyePoint(): Point3d;
    // (undocumented)
    getFocusDistance(): number;
    // (undocumented)
    getLensAngle(): Angle;
    // (undocumented)
    invalidateFocus(): void;
    // (undocumented)
    get isFocusValid(): boolean;
    // (undocumented)
    get isLensValid(): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    static isValidLensAngle(val: Angle): boolean;
    // (undocumented)
    readonly lens: Angle;
    // (undocumented)
    setEyePoint(pt: XYAndZ): void;
    // (undocumented)
    setFocusDistance(dist: number): void;
    // (undocumented)
    setFrom(rhs: Camera): void;
    // (undocumented)
    setLensAngle(angle: Angle): void;
    // (undocumented)
    validateLens(): void;
    // (undocumented)
    static validateLensAngle(val: Angle): void;
}

// @public
export interface CameraProps {
    // (undocumented)
    eye: XYZProps;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    lens: AngleProps;
}

// @public
export class Cartographic implements LatLongAndHeight {
    constructor(longitude?: number, latitude?: number, height?: number);
    clone(result?: Cartographic): Cartographic;
    equals(right: LatLongAndHeight): boolean;
    equalsEpsilon(right: LatLongAndHeight, epsilon: number): boolean;
    freeze(): Readonly<this>;
    static fromAngles(longitude: Angle, latitude: Angle, height: number, result?: Cartographic): Cartographic;
    static fromDegrees(longitude: number, latitude: number, height: number, result?: Cartographic): Cartographic;
    static fromEcef(cartesian: Point3d, result?: Cartographic): Cartographic | undefined;
    static fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
    static geocentricLatitudeFromGeodeticLatitude(geodeticLatitude: number): number;
    // (undocumented)
    height: number;
    // (undocumented)
    latitude: number;
    get latitudeDegrees(): number;
    // (undocumented)
    longitude: number;
    get longitudeDegrees(): number;
    static parametricLatitudeFromGeodeticLatitude(geodeticLatitude: number): number;
    static scalePointToGeodeticSurface(point: Point3d, result?: Point3d): Point3d | undefined;
    toEcef(result?: Point3d): Point3d;
    toString(): string;
    }

// @public
export class CartographicRange {
    constructor(spatialRange: Range3d, spatialToEcef: Transform);
    getLongitudeLatitudeBoundingBox(): Range2d;
    // (undocumented)
    intersectsRange(other: CartographicRange): boolean;
    }

// @public
export interface CategoryProps extends DefinitionElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    rank?: Rank;
}

// @public
export interface CategorySelectorProps extends DefinitionElementProps {
    // (undocumented)
    categories: Id64Array;
}

// @internal (undocumented)
export interface ChangeData {
    // (undocumented)
    changedElements: ChangedElements;
    // (undocumented)
    changedModels: ChangedModels;
}

// @internal (undocumented)
export interface ChangedElements {
    // (undocumented)
    classIds: Id64String[];
    // (undocumented)
    elements: Id64String[];
    // (undocumented)
    modelIds?: Id64String[];
    // (undocumented)
    opcodes: number[];
    // (undocumented)
    parentClassIds?: Id64String[];
    // (undocumented)
    parentIds?: Id64String[];
    // (undocumented)
    properties?: Id64String[][];
    // (undocumented)
    type: number[];
}

// @internal (undocumented)
export interface ChangedModels {
    // (undocumented)
    bboxes: AxisAlignedBox3dProps[];
    // (undocumented)
    modelIds: Id64String[];
}

// @public
export enum ChangedValueState {
    // (undocumented)
    AfterInsert = 1,
    // (undocumented)
    AfterUpdate = 3,
    // (undocumented)
    BeforeDelete = 4,
    // (undocumented)
    BeforeUpdate = 2
}

// @public
export enum ChangeOpCode {
    // (undocumented)
    Delete = 4,
    // (undocumented)
    Insert = 1,
    // (undocumented)
    Update = 2
}

export { ChangeSetStatus }

// @alpha
export class ChannelConstraintError extends IModelError {
    constructor(message: string, log?: LogFunction, category?: string, getMetaData?: GetMetaDataFunction);
}

// @public
export interface ChannelRootAspectProps extends ElementAspectProps {
    owner: string;
}

// @internal
export interface ClassifierTileTreeId {
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    animationTransformNodeId?: number;
    // (undocumented)
    expansion: number;
    // (undocumented)
    type: BatchType.VolumeClassifier | BatchType.PlanarClassifier;
}

// @beta (undocumented)
export abstract class CloudStorageCache<TContentId, TContentType> {
    constructor();
    // (undocumented)
    protected formContainerKey(id: TContentId): string;
    // (undocumented)
    abstract formContainerName(id: TContentId): string;
    // (undocumented)
    abstract formResourceName(id: TContentId): string;
    // (undocumented)
    protected getContainer(id: TContentId): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    protected abstract instantiateResource(response: Response): Promise<TContentType | undefined>;
    // (undocumented)
    protected abstract obtainContainerUrl(id: TContentId, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    provider: CloudStorageProvider;
    // (undocumented)
    protected requestResource(container: CloudStorageContainerUrl, id: TContentId): Promise<Response>;
    // (undocumented)
    retrieve(id: TContentId): Promise<TContentType | undefined>;
    // (undocumented)
    protected supplyUrlBase(_container: CloudStorageContainerUrl, _id: TContentId): string | undefined;
}

// @beta (undocumented)
export interface CloudStorageContainerDescriptor {
    // (undocumented)
    name: string;
    // (undocumented)
    provider?: CloudStorageProvider;
    // (undocumented)
    resource?: string;
}

// @beta (undocumented)
export interface CloudStorageContainerUrl {
    // (undocumented)
    bound?: boolean;
    // (undocumented)
    descriptor: CloudStorageContainerDescriptor;
    // (undocumented)
    expires: number;
    // (undocumented)
    headers?: Record<string, string>;
    // (undocumented)
    method?: string;
    // (undocumented)
    url: string;
    // (undocumented)
    valid: number;
}

// @beta (undocumented)
export namespace CloudStorageContainerUrl {
    // (undocumented)
    export function empty(): CloudStorageContainerUrl;
}

// @beta (undocumented)
export enum CloudStorageProvider {
    // (undocumented)
    AliCloud = 2,
    // (undocumented)
    Amazon = 1,
    // (undocumented)
    Azure = 0,
    // (undocumented)
    External = 3,
    // (undocumented)
    Unknown = 4
}

// @beta (undocumented)
export class CloudStorageTileCache extends CloudStorageCache<TileContentIdentifier, Uint8Array> {
    protected constructor();
    // (undocumented)
    protected formContainerKey(id: TileContentIdentifier): string;
    // (undocumented)
    formContainerName(id: TileContentIdentifier): string;
    // (undocumented)
    formResourceName(id: TileContentIdentifier): string;
    // (undocumented)
    static getCache(): CloudStorageTileCache;
    // (undocumented)
    protected instantiateResource(response: Response): Promise<Uint8Array | undefined>;
    // (undocumented)
    protected obtainContainerUrl(id: TileContentIdentifier, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    supplyExpiryForContainerUrl(_id: CloudStorageContainerDescriptor): Date;
}

// @public
export class Code implements CodeProps {
    constructor(val: CodeProps);
    static createEmpty(): Code;
    // @internal (undocumented)
    static equalCodes(c1: CodeProps, c2: CodeProps): boolean;
    // (undocumented)
    equals(other: Code): boolean;
    // (undocumented)
    static fromJSON(json?: any): Code;
    // (undocumented)
    getValue(): string;
    static isEmpty(c: CodeProps): boolean;
    static isValid(c: CodeProps): boolean;
    scope: string;
    spec: Id64String;
    value?: string;
}

// @public
export interface CodeProps {
    // (undocumented)
    scope: CodeScopeProps;
    // (undocumented)
    spec: Id64String;
    // (undocumented)
    value?: string;
}

// @public
export type CodeScopeProps = Id64String | GuidString;

// @public
export namespace CodeScopeSpec {
    export enum ScopeRequirement {
        ElementId = 1,
        FederationGuid = 2
    }
    export enum Type {
        Model = 2,
        ParentElement = 3,
        RelatedElement = 4,
        Repository = 1
    }
}

// @public
export class CodeSpec {
    // @internal @deprecated
    constructor(iModel: IModel, id: Id64String, name: string, scopeType?: CodeScopeSpec.Type, scopeReq?: CodeScopeSpec.ScopeRequirement, properties?: any);
    static create(iModel: IModel, name: string, scopeType: CodeScopeSpec.Type, scopeReq?: CodeScopeSpec.ScopeRequirement): CodeSpec;
    // @internal
    static createFromJson(iModel: IModel, id: Id64String, name: string, properties: any): CodeSpec;
    id: Id64String;
    iModel: IModel;
    // @beta
    get isManagedWithIModel(): boolean;
    set isManagedWithIModel(value: boolean);
    get isValid(): boolean;
    name: string;
    // @internal
    properties: any;
    get scopeReq(): CodeScopeSpec.ScopeRequirement;
    set scopeReq(req: CodeScopeSpec.ScopeRequirement);
    get scopeType(): CodeScopeSpec.Type;
    set scopeType(scopeType: CodeScopeSpec.Type);
    // @deprecated
    get specScopeType(): CodeScopeSpec.Type;
    set specScopeType(scopeType: CodeScopeSpec.Type);
}

// @public
export enum ColorByName {
    // (undocumented)
    aliceBlue = 16775408,
    // (undocumented)
    amber = 49151,
    // (undocumented)
    antiqueWhite = 14150650,
    // (undocumented)
    aqua = 16776960,
    // (undocumented)
    aquamarine = 13959039,
    // (undocumented)
    azure = 16777200,
    // (undocumented)
    beige = 14480885,
    // (undocumented)
    bisque = 12903679,
    // (undocumented)
    black = 0,
    // (undocumented)
    blanchedAlmond = 13495295,
    // (undocumented)
    blue = 16711680,
    // (undocumented)
    blueViolet = 14822282,
    // (undocumented)
    brown = 2763429,
    // (undocumented)
    burlyWood = 8894686,
    // (undocumented)
    cadetBlue = 10526303,
    // (undocumented)
    chartreuse = 65407,
    // (undocumented)
    chocolate = 1993170,
    // (undocumented)
    coral = 5275647,
    // (undocumented)
    cornflowerBlue = 15570276,
    // (undocumented)
    cornSilk = 14481663,
    // (undocumented)
    crimson = 3937500,
    // (undocumented)
    cyan = 16776960,
    // (undocumented)
    darkBlue = 9109504,
    // (undocumented)
    darkBrown = 2179941,
    // (undocumented)
    darkCyan = 9145088,
    // (undocumented)
    darkGoldenrod = 755384,
    // (undocumented)
    darkGray = 11119017,
    // (undocumented)
    darkGreen = 25600,
    // (undocumented)
    darkGrey = 11119017,
    // (undocumented)
    darkKhaki = 7059389,
    // (undocumented)
    darkMagenta = 9109643,
    // (undocumented)
    darkOliveGreen = 3107669,
    // (undocumented)
    darkOrange = 36095,
    // (undocumented)
    darkOrchid = 13382297,
    // (undocumented)
    darkRed = 139,
    // (undocumented)
    darkSalmon = 8034025,
    // (undocumented)
    darkSeagreen = 9419919,
    // (undocumented)
    darkSlateBlue = 9125192,
    // (undocumented)
    darkSlateGray = 5197615,
    // (undocumented)
    darkSlateGrey = 5197615,
    // (undocumented)
    darkTurquoise = 13749760,
    // (undocumented)
    darkViolet = 13828244,
    // (undocumented)
    deepPink = 9639167,
    // (undocumented)
    deepSkyBlue = 16760576,
    // (undocumented)
    dimGray = 6908265,
    // (undocumented)
    dimGrey = 6908265,
    // (undocumented)
    dodgerBlue = 16748574,
    // (undocumented)
    fireBrick = 2237106,
    // (undocumented)
    floralWhite = 15792895,
    // (undocumented)
    forestGreen = 2263842,
    // (undocumented)
    fuchsia = 16711935,
    // (undocumented)
    gainsboro = 14474460,
    // (undocumented)
    ghostWhite = 16775416,
    // (undocumented)
    gold = 55295,
    // (undocumented)
    goldenrod = 2139610,
    // (undocumented)
    gray = 8421504,
    // (undocumented)
    green = 32768,
    // (undocumented)
    greenYellow = 3145645,
    // (undocumented)
    grey = 8421504,
    // (undocumented)
    honeydew = 15794160,
    // (undocumented)
    hotPink = 11823615,
    // (undocumented)
    indianRed = 6053069,
    // (undocumented)
    indigo = 8519755,
    // (undocumented)
    ivory = 15794175,
    // (undocumented)
    khaki = 9234160,
    // (undocumented)
    lavender = 16443110,
    // (undocumented)
    lavenderBlush = 16118015,
    // (undocumented)
    lawnGreen = 64636,
    // (undocumented)
    lemonChiffon = 13499135,
    // (undocumented)
    lightBlue = 15128749,
    // (undocumented)
    lightCoral = 8421616,
    // (undocumented)
    lightCyan = 16777184,
    // (undocumented)
    lightGoldenrodYellow = 13826810,
    // (undocumented)
    lightGray = 13882323,
    // (undocumented)
    lightGreen = 9498256,
    // (undocumented)
    lightGrey = 13882323,
    // (undocumented)
    lightPink = 12695295,
    // (undocumented)
    lightSalmon = 8036607,
    // (undocumented)
    lightSeagreen = 11186720,
    // (undocumented)
    lightSkyBlue = 16436871,
    // (undocumented)
    lightSlateGray = 10061943,
    // (undocumented)
    lightSlateGrey = 10061943,
    // (undocumented)
    lightSteelBlue = 14599344,
    // (undocumented)
    lightyellow = 14745599,
    // (undocumented)
    lime = 65280,
    // (undocumented)
    limeGreen = 3329330,
    // (undocumented)
    linen = 15134970,
    // (undocumented)
    magenta = 16711935,
    // (undocumented)
    maroon = 128,
    // (undocumented)
    mediumAquamarine = 11193702,
    // (undocumented)
    mediumBlue = 13434880,
    // (undocumented)
    mediumOrchid = 13850042,
    // (undocumented)
    mediumPurple = 14381203,
    // (undocumented)
    mediumSeaGreen = 7451452,
    // (undocumented)
    mediumSlateBlue = 15624315,
    // (undocumented)
    mediumSpringGreen = 10156544,
    // (undocumented)
    mediumTurquoise = 13422920,
    // (undocumented)
    mediumVioletRed = 8721863,
    // (undocumented)
    midnightBlue = 7346457,
    // (undocumented)
    mintCream = 16449525,
    // (undocumented)
    mistyRose = 14804223,
    // (undocumented)
    moccasin = 11920639,
    // (undocumented)
    navajoWhite = 11394815,
    // (undocumented)
    navy = 8388608,
    // (undocumented)
    oldLace = 15136253,
    // (undocumented)
    olive = 32896,
    // (undocumented)
    oliveDrab = 2330219,
    // (undocumented)
    orange = 42495,
    // (undocumented)
    orangeRed = 17919,
    // (undocumented)
    orchid = 14053594,
    // (undocumented)
    paleGoldenrod = 11200750,
    // (undocumented)
    paleGreen = 10025880,
    // (undocumented)
    paleTurquoise = 15658671,
    // (undocumented)
    paleVioletRed = 9662683,
    // (undocumented)
    papayaWhip = 14020607,
    // (undocumented)
    peachPuff = 12180223,
    // (undocumented)
    peru = 4163021,
    // (undocumented)
    pink = 13353215,
    // (undocumented)
    plum = 14524637,
    // (undocumented)
    powderBlue = 15130800,
    // (undocumented)
    purple = 8388736,
    // (undocumented)
    rebeccaPurple = 10040166,
    // (undocumented)
    red = 255,
    // (undocumented)
    rosyBrown = 9408444,
    // (undocumented)
    royalBlue = 14772545,
    // (undocumented)
    saddleBrown = 1262987,
    // (undocumented)
    salmon = 7504122,
    // (undocumented)
    sandyBrown = 6333684,
    // (undocumented)
    seaGreen = 5737262,
    // (undocumented)
    seaShell = 15660543,
    // (undocumented)
    sienna = 2970272,
    // (undocumented)
    silver = 12632256,
    // (undocumented)
    skyBlue = 15453831,
    // (undocumented)
    slateBlue = 13458026,
    // (undocumented)
    slateGray = 9470064,
    // (undocumented)
    slateGrey = 9470064,
    // (undocumented)
    snow = 16448255,
    // (undocumented)
    springGreen = 8388352,
    // (undocumented)
    steelBlue = 11829830,
    // (undocumented)
    tan = 9221330,
    // (undocumented)
    teal = 8421376,
    // (undocumented)
    thistle = 14204888,
    // (undocumented)
    tomato = 4678655,
    // (undocumented)
    turquoise = 13688896,
    // (undocumented)
    violet = 15631086,
    // (undocumented)
    wheat = 11788021,
    // (undocumented)
    white = 16777215,
    // (undocumented)
    whiteSmoke = 16119285,
    // (undocumented)
    yellow = 65535,
    // (undocumented)
    yellowGreen = 3329434
}

// @public
export class ColorDef {
    adjustedForContrast(other: ColorDef, alpha?: number): ColorDef;
    static readonly black: ColorDef;
    static readonly blue: ColorDef;
    get colors(): {
        r: number;
        g: number;
        b: number;
        t: number;
    };
    // @internal (undocumented)
    static computeTbgr(val?: string | ColorDefProps): number;
    static computeTbgrFromComponents(red: number, green: number, blue: number, transparency?: number): number;
    static computeTbgrFromHSL(h: number, s: number, l: number, transparency?: number): number;
    static computeTbgrFromString(val: string): number;
    static create(val?: string | ColorDefProps): ColorDef;
    equals(other: ColorDef): boolean;
    static from(red: number, green: number, blue: number, transparency?: number): ColorDef;
    static fromHSL(h: number, s: number, l: number, transparency?: number): ColorDef;
    static fromHSV(hsv: HSVColor, transparency?: number): ColorDef;
    static fromJSON(json?: ColorDefProps): ColorDef;
    static fromString(val: string): ColorDef;
    static fromTbgr(tbgr: number): ColorDef;
    getAbgr(): number;
    static getAbgr(tbgr: number): number;
    getAlpha(): number;
    static getAlpha(tbgr: number): number;
    static getColors(tbgr: number): {
        b: number;
        g: number;
        r: number;
        t: number;
    };
    static getName(tbgr: number): string | undefined;
    getRgb(): number;
    static getRgb(tbgr: number): number;
    getTransparency(): number;
    static getTransparency(tbgr: number): number;
    static readonly green: ColorDef;
    inverse(): ColorDef;
    static inverse(tbgr: number): number;
    get isOpaque(): boolean;
    static isOpaque(tbgr: number): boolean;
    lerp(color2: ColorDef, weight: number): ColorDef;
    static lerp(tbgr1: number, tbgr2: number, weight: number): number;
    get name(): string | undefined;
    static readonly red: ColorDef;
    get tbgr(): number;
    toHexString(): string;
    static toHexString(tbgr: number): string;
    toHSL(): HSLColor;
    toHSV(): HSVColor;
    toJSON(): ColorDefProps;
    toRgbaString(): string;
    static toRgbaString(tbgr: number): string;
    toRgbString(): string;
    static toRgbString(tbgr: number): string;
    static readonly white: ColorDef;
    withAlpha(alpha: number): ColorDef;
    static withAlpha(tbgr: number, alpha: number): number;
    withTransparency(transparency: number): ColorDef;
    static withTransparency(tbgr: number, transparency: number): number;
}

// @public
export type ColorDefProps = number;

// @internal (undocumented)
export class ColorIndex {
    constructor();
    // (undocumented)
    get hasAlpha(): boolean;
    // (undocumented)
    initNonUniform(colors: Uint32Array, indices: number[], hasAlpha: boolean): void;
    // (undocumented)
    initUniform(color: ColorDef | number): void;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    get nonUniform(): NonUniformColor | undefined;
    // (undocumented)
    get numColors(): number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get uniform(): ColorDef | undefined;
}

// @public
export enum CommonLoggerCategory {
    ElementProps = "imodeljs-common.ElementProps",
    Geometry = "imodeljs-common.Geometry",
    RpcInterfaceBackend = "imodeljs-backend.RpcInterface",
    RpcInterfaceFrontend = "imodeljs-frontend.RpcInterface"
}

// @internal
export function compareIModelTileTreeIds(lhs: IModelTileTreeId, rhs: IModelTileTreeId): number;

// @internal
export class CompositeTileHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly tileCount: number;
    // (undocumented)
    readonly tilePosition: number;
}

// @internal
export function computeChildTileProps(parent: TileMetadata, idProvider: ContentIdProvider, root: TileTreeMetadata): {
    children: TileProps[];
    numEmpty: number;
};

// @internal
export function computeChildTileRanges(tile: TileMetadata, root: TileTreeMetadata): Array<{
    range: Range3d;
    isEmpty: boolean;
}>;

// @internal
export function computeTileChordTolerance(tile: TileMetadata, is3d: boolean): number;

// @internal
export enum ContentFlags {
    // (undocumented)
    AllowInstancing = 1,
    // (undocumented)
    IgnoreAreaPatterns = 4,
    // (undocumented)
    ImprovedElision = 2,
    // (undocumented)
    None = 0
}

// @internal
export abstract class ContentIdProvider {
    protected constructor(formatVersion: number, contentFlags: ContentFlags);
    // (undocumented)
    protected abstract computeId(depth: number, i: number, j: number, k: number, mult: number): string;
    // (undocumented)
    readonly contentFlags: ContentFlags;
    static create(allowInstancing: boolean, options: TileOptions, formatVersion?: number): ContentIdProvider;
    // (undocumented)
    idFromParentAndMultiplier(parentId: string, multiplier: number): string;
    // (undocumented)
    idFromSpec(spec: ContentIdSpec): string;
    // (undocumented)
    protected join(depth: number, i: number, j: number, k: number, mult: number): string;
    // (undocumented)
    readonly majorFormatVersion: number;
    // (undocumented)
    get rootContentId(): string;
    // (undocumented)
    protected abstract get _separator(): string;
    // (undocumented)
    specFromId(id: string): ContentIdSpec;
}

// @public
export interface ContextRealityModelProps {
    // @beta
    appearanceOverrides?: FeatureAppearanceProps;
    // @beta (undocumented)
    classifiers?: SpatialClassificationProps.Properties[];
    // (undocumented)
    description?: string;
    // (undocumented)
    name?: string;
    // @alpha (undocumented)
    orbitGtBlob?: OrbitGtBlobProps;
    realityDataId?: string;
    // (undocumented)
    tilesetUrl: string;
}

// @public
export type CreateEmptySnapshotIModelProps = CreateIModelProps & CreateSnapshotIModelProps;

// @internal
export type CreateEmptyStandaloneIModelProps = CreateIModelProps & CreateStandaloneIModelProps;

// @public
export interface CreateIModelProps extends IModelProps {
    client?: string;
    guid?: GuidString;
    // @alpha
    thumbnail?: ThumbnailProps;
}

// @public
export interface CreateSnapshotIModelProps extends IModelEncryptionProps {
    createClassViews?: boolean;
}

// @internal
export interface CreateStandaloneIModelProps extends IModelEncryptionProps {
    allowEdit?: string;
}

// @internal (undocumented)
export const CURRENT_INVOCATION: unique symbol;

// @internal (undocumented)
export const CURRENT_REQUEST: unique symbol;

// @internal
export enum CurrentImdlVersion {
    Combined = 1114112,
    Major = 17,
    Minor = 0
}

// @beta
export interface CustomAttribute {
    ecclass: string;
    properties: {
        [propName: string]: any;
    };
}

export { DbResult }

// @beta
export interface DecorationGeometryProps {
    // (undocumented)
    readonly geometryStream: GeometryStreamProps;
    // (undocumented)
    readonly id: Id64String;
}

// @alpha
export const defaultDesktopAuthorizationClientExpiryBuffer: number;

// @alpha
export const defaultMobileAuthorizationClientExpiryBuffer: number;

// @internal (undocumented)
export const defaultTileOptions: TileOptions;

// @public
export interface DefinitionElementProps extends ElementProps {
    // (undocumented)
    isPrivate?: boolean;
}

// @alpha
export interface DeletedElementGeometryChange {
    readonly id: Id64String;
    readonly type: DbOpcode.Delete;
}

// @alpha
export interface DesktopAuthorizationClientConfiguration {
    clientId: string;
    expiryBuffer?: number;
    redirectUri: string;
    scope: string;
}

// @internal
export class DesktopAuthorizationClientMessages {
    // (undocumented)
    static readonly getAccessToken: string;
    // (undocumented)
    static readonly getAccessTokenComplete: string;
    // (undocumented)
    static readonly initialize: string;
    // (undocumented)
    static readonly initializeComplete: string;
    // (undocumented)
    static readonly onUserStateChanged: string;
    // (undocumented)
    static readonly onUserStateChangedComplete: string;
    // (undocumented)
    static readonly signIn: string;
    // (undocumented)
    static readonly signInComplete: string;
    // (undocumented)
    static readonly signOut: string;
    // (undocumented)
    static readonly signOutComplete: string;
}

// @internal
export abstract class DevToolsRpcInterface extends RpcInterface {
    static getClient(): DevToolsRpcInterface;
    static readonly interfaceName = "DevToolsRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    ping(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    setLogLevel(_iModelToken: IModelRpcProps, _loggerCategory: string, _logLevel: LogLevel): Promise<LogLevel | undefined>;
    // (undocumented)
    stats(_iModelToken: IModelRpcProps, _options: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(_iModelToken: IModelRpcProps): Promise<any>;
}

// @internal
export enum DevToolsStatsOptions {
    FormatUnits = 1,
    // (undocumented)
    None = 0
}

// @public
export interface DisplayStyle3dProps extends DisplayStyleProps {
    jsonProperties?: {
        styles?: DisplayStyle3dSettingsProps;
    };
}

// @public
export class DisplayStyle3dSettings extends DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyle3dSettingsProps;
    });
    get ambientOcclusionSettings(): AmbientOcclusion.Settings;
    set ambientOcclusionSettings(ao: AmbientOcclusion.Settings);
    // @beta
    applyOverrides(overrides: DisplayStyle3dSettingsProps): void;
    // @internal (undocumented)
    get environment(): EnvironmentProps;
    set environment(environment: EnvironmentProps);
    // @beta
    getPlanProjectionSettings(modelId: Id64String): PlanProjectionSettings | undefined;
    get hiddenLineSettings(): HiddenLine.Settings;
    set hiddenLineSettings(hline: HiddenLine.Settings);
    // (undocumented)
    get lights(): LightSettings;
    set lights(lights: LightSettings);
    // @beta
    get planProjectionSettings(): Iterable<[Id64String, PlanProjectionSettings]> | undefined;
    // @beta
    setPlanProjectionSettings(modelId: Id64String, settings: PlanProjectionSettings | undefined): void;
    get solarShadows(): SolarShadowSettings;
    set solarShadows(solarShadows: SolarShadowSettings);
    // @beta
    get thematic(): ThematicDisplay;
    set thematic(thematic: ThematicDisplay);
    // @internal (undocumented)
    toJSON(): DisplayStyle3dSettingsProps;
    // @beta
    toOverrides(options?: DisplayStyleOverridesOptions): DisplayStyle3dSettingsProps;
}

// @public
export interface DisplayStyle3dSettingsProps extends DisplayStyleSettingsProps {
    ao?: AmbientOcclusion.Props;
    environment?: EnvironmentProps;
    hline?: HiddenLine.SettingsProps;
    lights?: LightSettingsProps;
    // @beta
    planProjections?: {
        [modelId: string]: PlanProjectionSettingsProps;
    };
    // @internal @deprecated
    sceneLights?: {
        sunDir?: XYZProps;
    };
    solarShadows?: SolarShadowSettingsProps;
    // @beta
    thematic?: ThematicDisplayProps;
}

// @beta
export interface DisplayStyleModelAppearanceProps extends FeatureAppearanceProps {
    modelId?: Id64String;
}

// @beta
export interface DisplayStyleOverridesOptions {
    includeAll?: true;
    includeBackgroundMap?: true;
    includeDrawingAids?: true;
    includeIModelSpecific?: true;
    includeProjectSpecific?: true;
}

// @public
export interface DisplayStyleProps extends DefinitionElementProps {
    jsonProperties?: {
        styles?: DisplayStyleSettingsProps;
    };
}

// @public
export class DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyleSettingsProps;
    });
    addExcludedElements(id: Id64String): void;
    // @alpha (undocumented)
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    // @alpha
    get analysisStyle(): AnalysisStyle | undefined;
    set analysisStyle(style: AnalysisStyle | undefined);
    // @beta
    applyOverrides(overrides: DisplayStyleSettingsProps): void;
    // @internal (undocumented)
    protected _applyOverrides(overrides: DisplayStyleSettingsProps): void;
    get backgroundColor(): ColorDef;
    set backgroundColor(color: ColorDef);
    get backgroundMap(): BackgroundMapSettings;
    set backgroundMap(map: BackgroundMapSettings);
    dropExcludedElement(id: Id64String): void;
    dropModelAppearanceOverride(id: Id64String): void;
    dropSubCategoryOverride(id: Id64String): void;
    // @internal (undocumented)
    equalModelAppearanceOverrides(other: DisplayStyleSettings): boolean;
    // @internal (undocumented)
    equalSubCategoryOverrides(other: DisplayStyleSettings): boolean;
    get excludedElements(): Set<Id64String>;
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    get hasModelAppearanceOverride(): boolean;
    get hasSubCategoryOverride(): boolean;
    // (undocumented)
    protected readonly _json: DisplayStyleSettingsProps;
    // @alpha
    get mapImagery(): MapImagerySettings;
    set mapImagery(mapImagery: MapImagerySettings);
    get modelAppearanceOverrides(): Map<Id64String, FeatureAppearance>;
    get monochromeColor(): ColorDef;
    set monochromeColor(color: ColorDef);
    get monochromeMode(): MonochromeMode;
    set monochromeMode(mode: MonochromeMode);
    // @internal (undocumented)
    readonly onOverridesApplied: BeEvent<(settings: DisplayStyleSettings, overrides: DisplayStyleSettingsProps) => void>;
    overrideModelAppearance(modelId: Id64String, ovr: FeatureAppearance): void;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @internal (undocumented)
    get scheduleScriptProps(): RenderSchedule.ModelTimelineProps[] | undefined;
    set scheduleScriptProps(props: RenderSchedule.ModelTimelineProps[] | undefined);
    get subCategoryOverrides(): Map<Id64String, SubCategoryOverride>;
    // @internal
    synchMapImagery(): void;
    // @beta
    get timePoint(): number | undefined;
    set timePoint(timePoint: number | undefined);
    // @internal (undocumented)
    toJSON(): DisplayStyleSettingsProps;
    // @beta
    toOverrides(options?: DisplayStyleOverridesOptions): DisplayStyleSettingsProps;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    }

// @public
export interface DisplayStyleSettingsProps {
    // @alpha
    analysisFraction?: number;
    // @alpha
    analysisStyle?: AnalysisStyleProps;
    backgroundColor?: ColorDefProps;
    backgroundMap?: BackgroundMapProps;
    contextRealityModels?: ContextRealityModelProps[];
    excludedElements?: Id64String[];
    // @alpha
    mapImagery?: MapImageryProps;
    // @beta
    modelOvr?: DisplayStyleModelAppearanceProps[];
    monochromeColor?: ColorDefProps;
    monochromeMode?: MonochromeMode;
    // @beta
    scheduleScript?: RenderSchedule.ModelTimelineProps[];
    subCategoryOvr?: DisplayStyleSubCategoryProps[];
    // @beta
    timePoint?: number;
    // (undocumented)
    viewflags?: ViewFlagProps;
}

// @public
export interface DisplayStyleSubCategoryProps extends SubCategoryAppearance.Props {
    subCategory?: Id64String;
}

// @beta
export enum DomainOptions {
    CheckRecommendedUpgrades = 1,
    CheckRequiredUpgrades = 0,
    SkipCheck = 3,
    Upgrade = 2
}

// @beta
export interface DownloadBriefcaseOptions {
    syncMode: SyncMode;
}

// @internal
export enum DownloadBriefcaseStatus {
    // (undocumented)
    ApplyingChangeSets = 4,
    // (undocumented)
    Complete = 5,
    // (undocumented)
    DownloadingChangeSets = 3,
    // (undocumented)
    DownloadingCheckpoint = 2,
    // (undocumented)
    Error = 6,
    // (undocumented)
    Initializing = 1,
    // (undocumented)
    NotStarted = 0
}

// @beta
export type DPoint2dProps = number[];

// @beta
export const Easing: {
    Linear: {
        None: (k: number) => number;
    };
    Quadratic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Cubic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quartic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quintic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Sinusoidal: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Exponential: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Circular: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Elastic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Back: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Bounce: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
};

// @beta (undocumented)
export type EasingFunction = (k: number) => number;

// @public
export class EcefLocation implements EcefLocationProps {
    constructor(props: EcefLocationProps);
    readonly cartographicOrigin?: Cartographic;
    static createFromCartographicOrigin(origin: Cartographic, point?: Point3d, angle?: Angle): EcefLocation;
    get earthCenter(): Point3d;
    getTransform(): Transform;
    readonly orientation: YawPitchRollAngles;
    readonly origin: Point3d;
}

// @public
export interface EcefLocationProps {
    cartographicOrigin?: LatLongAndHeight;
    orientation: YawPitchRollProps;
    origin: XYZProps;
}

// @public
export class ECJsNames {
    static systemPropertyToJsName(systemPropertyType: ECSqlSystemProperty): string;
    static toJsName(propName: string, isSystemProperty?: boolean): string;
}

// @public
export enum ECSqlSystemProperty {
    // (undocumented)
    ECClassId = 1,
    // (undocumented)
    ECInstanceId = 0,
    // (undocumented)
    NavigationId = 6,
    // (undocumented)
    NavigationRelClassId = 7,
    // (undocumented)
    PointX = 8,
    // (undocumented)
    PointY = 9,
    // (undocumented)
    PointZ = 10,
    // (undocumented)
    SourceECClassId = 3,
    // (undocumented)
    SourceECInstanceId = 2,
    // (undocumented)
    TargetECClassId = 5,
    // (undocumented)
    TargetECInstanceId = 4
}

// @public
export enum ECSqlValueType {
    // (undocumented)
    Blob = 1,
    // (undocumented)
    Boolean = 2,
    // (undocumented)
    DateTime = 3,
    // (undocumented)
    Double = 4,
    // (undocumented)
    Geometry = 5,
    // (undocumented)
    Guid = 16,
    // (undocumented)
    Id = 6,
    // (undocumented)
    Int = 7,
    // (undocumented)
    Int64 = 8,
    // (undocumented)
    Navigation = 12,
    // (undocumented)
    Point2d = 9,
    // (undocumented)
    Point3d = 10,
    // (undocumented)
    PrimitiveArray = 14,
    // (undocumented)
    String = 11,
    // (undocumented)
    Struct = 13,
    // (undocumented)
    StructArray = 15
}

// @internal (undocumented)
export class EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    edges?: MeshEdge[];
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get numEdges(): number;
}

// @alpha
export abstract class Editor3dRpcInterface extends RpcInterface {
    // (undocumented)
    applyTransform(_tokenProps: IModelRpcProps, _editorId: GuidString, _tprops: TransformProps): Promise<any>;
    // (undocumented)
    createElement(_tokenProps: IModelRpcProps, _editorId: GuidString, _props: GeometricElement3dProps, _origin?: Point3d, _angles?: YawPitchRollAngles, _geometry?: any): Promise<void>;
    // (undocumented)
    end(_tokenProps: IModelRpcProps, _editorId: GuidString): Promise<void>;
    static getClient(): Editor3dRpcInterface;
    static readonly interfaceName = "Editor3dRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    popState(_tokenProps: IModelRpcProps, _editorId: GuidString): Promise<void>;
    // (undocumented)
    pushState(_tokenProps: IModelRpcProps, _editorId: GuidString): Promise<void>;
    // (undocumented)
    start(_tokenProps: IModelRpcProps, _editorId: GuidString): Promise<void>;
    // (undocumented)
    startModifyingElements(_tokenProps: IModelRpcProps, _editorId: GuidString, _elementIds: Id64Array): Promise<void>;
    // (undocumented)
    writeAllChangesToBriefcase(_tokenProps: IModelRpcProps, _editorId: GuidString, _opts: Editor3dRpcInterfaceWriteOptions): Promise<GeometricElement3dProps[] | Id64Array | void>;
}

// @alpha (undocumented)
export interface Editor3dRpcInterfaceWriteOptions {
    returnPropsOptions?: Editor3dRpcInterfaceWriteReturnPropsOptions;
    returnType?: Editor3dRpcInterfaceWriteReturnType;
}

// @alpha (undocumented)
export interface Editor3dRpcInterfaceWriteReturnPropsOptions {
    geometry?: boolean;
}

// @alpha (undocumented)
export enum Editor3dRpcInterfaceWriteReturnType {
    Ids = 1,
    None = 0,
    Props = 2
}

// @beta
export abstract class ElectronRpcConfiguration extends RpcConfiguration {
    // (undocumented)
    static readonly isElectron: boolean;
    abstract protocol: ElectronRpcProtocol;
    // (undocumented)
    static targetWindowId?: number;
}

// @beta
export class ElectronRpcManager extends RpcManager {
    static initializeClient(params: ElectronRpcParams, interfaces: RpcInterfaceDefinition[]): ElectronRpcConfiguration;
    static initializeImpl(params: ElectronRpcParams, interfaces: RpcInterfaceDefinition[]): ElectronRpcConfiguration;
    }

// @beta
export interface ElectronRpcParams {
    // (undocumented)
    protocol?: typeof ElectronRpcProtocol;
}

// @beta
export class ElectronRpcProtocol extends RpcProtocol {
    constructor(configuration: ElectronRpcConfiguration);
    // (undocumented)
    static instances: Map<string, ElectronRpcProtocol>;
    // @internal (undocumented)
    onRpcClientInitialized(definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    requests: Map<string, ElectronRpcRequest>;
    readonly requestType: typeof ElectronRpcRequest;
    transferChunkThreshold: number;
    // @internal (undocumented)
    readonly transport: ElectronIpcTransport<IpcTransportMessage, IpcTransportMessage>;
}

// @beta (undocumented)
export class ElectronRpcRequest extends RpcRequest {
    // @internal (undocumented)
    dispose(): void;
    protected load(): Promise<import("../core/RpcMarshaling").RpcSerializedValue>;
    // @internal (undocumented)
    notifyResponse(fulfillment: RpcRequestFulfillment): void;
    readonly protocol: ElectronRpcProtocol;
    protected send(): Promise<number>;
    protected setHeader(_name: string, _value: string): void;
}

// @public
export type ElementAlignedBox2d = Range2d;

// @public
export type ElementAlignedBox3d = Range3d;

// @public
export interface ElementAspectProps extends EntityProps {
    // (undocumented)
    element: RelatedElementProps;
}

// @alpha
export namespace ElementGeometry {
    // (undocumented)
    export function appendGeometryParams(geomParams: GeometryParams, entries: ElementGeometryDataEntry[]): boolean;
    export class Builder {
        appendBRepData(brep: BRepEntity.DataProps): boolean;
        appendGeometryParamsChange(geomParams: GeometryParams): boolean;
        appendGeometryPart(partId: Id64String, partToElement?: Transform): boolean;
        appendGeometryPart2d(partId: Id64String, instanceOrigin?: Point2d, instanceRotation?: Angle, instanceScale?: number): boolean;
        appendGeometryPart3d(partId: Id64String, instanceOrigin?: Point3d, instanceRotation?: YawPitchRollAngles, instanceScale?: number): boolean;
        appendGeometryQuery(geometry: GeometryQuery): boolean;
        appendGeometryRanges(): boolean;
        appendImageGraphic(image: ImageGraphic): boolean;
        appendTextString(text: TextString): boolean;
        // (undocumented)
        readonly entries: ElementGeometryDataEntry[];
    }
    // (undocumented)
    export function fromBRep(brep: BRepEntity.DataProps): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function fromGeometryPart(partId: Id64String, partToElement?: Transform): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function fromGeometryQuery(geom: GeometryQuery): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function fromImageGraphic(image: ImageGraphicProps): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function fromSubGraphicRange(bbox: ElementAlignedBox3d): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function fromTextString(text: TextStringProps): ElementGeometryDataEntry | undefined;
    // (undocumented)
    export function isAppearanceEntry(entry: ElementGeometryDataEntry): boolean;
    // (undocumented)
    export function isGeometricEntry(entry: ElementGeometryDataEntry): boolean;
    // (undocumented)
    export function isGeometryQueryEntry(entry: ElementGeometryDataEntry): boolean;
    export class Iterator implements IterableIterator<IteratorEntry> {
        // (undocumented)
        [Symbol.iterator](): IterableIterator<IteratorEntry>;
        constructor(info: ElementGeometryInfo, categoryOrGeometryParams?: Id64String | GeometryParams, localToWorld?: Transform);
        readonly brepsPresent?: boolean;
        readonly entryArray: ElementGeometryDataEntry[];
        next(): IteratorResult<IteratorEntry>;
        readonly placement: Placement3d;
        readonly viewIndependent?: boolean;
    }
    export interface IteratorData {
        readonly geomParams: GeometryParams;
        readonly localRange?: Range3d;
        readonly localToWorld?: Transform;
        readonly value: ElementGeometryDataEntry;
    }
    // (undocumented)
    export class IteratorEntry implements IteratorData {
        constructor(geomParams: GeometryParams, localToWorld: Transform);
        // (undocumented)
        readonly geomParams: GeometryParams;
        // (undocumented)
        localRange?: Range3d;
        // (undocumented)
        readonly localToWorld?: Transform;
        toBRepData(wantBRepData?: boolean): BRepEntity.DataProps | undefined;
        toGeometryPart(partToLocal?: Transform, partToWorld?: Transform): Id64String | undefined;
        toGeometryQuery(): GeometryQuery | undefined;
        toImageGraphic(): ImageGraphic | undefined;
        toTextString(): TextString | undefined;
        // (undocumented)
        get value(): ElementGeometryDataEntry;
        set value(value: ElementGeometryDataEntry);
        }
    // (undocumented)
    export function toBRep(entry: ElementGeometryDataEntry, wantBRepData?: boolean): BRepEntity.DataProps | undefined;
    export function toElementAlignedBox3d(bbox: Float64Array): ElementAlignedBox3d | undefined;
    // (undocumented)
    export function toGeometryPart(entry: ElementGeometryDataEntry, partToElement?: Transform): Id64String | undefined;
    // (undocumented)
    export function toGeometryQuery(entry: ElementGeometryDataEntry): GeometryQuery | undefined;
    // (undocumented)
    export function toImageGraphic(entry: ElementGeometryDataEntry): ImageGraphicProps | undefined;
    // (undocumented)
    export function toSubGraphicRange(entry: ElementGeometryDataEntry): ElementAlignedBox3d | undefined;
    // (undocumented)
    export function toTextString(entry: ElementGeometryDataEntry): TextStringProps | undefined;
    export function toTransform(sourceToWorld: Float64Array): Transform | undefined;
    // (undocumented)
    export function updateGeometryParams(entry: ElementGeometryDataEntry, geomParams: GeometryParams): boolean;
}

// @alpha
export type ElementGeometryChange = ExtantElementGeometryChange | DeletedElementGeometryChange;

// @alpha
export namespace ElementGeometryChange {
    export function iterable(modelChanges: ModelGeometryChangesProps): Iterable<ElementGeometryChange>;
    export function iterator(modelChanges: ModelGeometryChangesProps): Iterator<ElementGeometryChange>;
}

// @alpha
export interface ElementGeometryDataEntry {
    data: Uint8Array;
    opcode: number;
}

// @alpha
export type ElementGeometryFunction = (info: ElementGeometryInfo) => void;

// @alpha
export interface ElementGeometryInfo {
    bbox?: Float64Array;
    brepsPresent?: boolean;
    categoryId?: Id64String;
    entryArray: ElementGeometryDataEntry[];
    sourceToWorld?: Float64Array;
    viewIndependent?: boolean;
}

// @alpha
export enum ElementGeometryOpcode {
    ArcPrimitive = 7,
    BasicSymbology = 4,
    BRep = 25,
    BsplineSurface = 12,
    CurveCollection = 8,
    CurvePrimitive = 10,
    Fill = 19,
    Image = 28,
    LineStyleModifiers = 23,
    Material = 21,
    PartReference = 3,
    Pattern = 20,
    PointPrimitive = 5,
    PointPrimitive2d = 6,
    Polyface = 9,
    SolidPrimitive = 11,
    SubGraphicRange = 2,
    TextString = 22
}

// @alpha
export interface ElementGeometryRequest {
    angleTol?: number;
    chordTol?: number;
    elementId: Id64String;
    maxEdgeLength?: number;
    minBRepFeatureSize?: number;
    onGeometry: ElementGeometryFunction;
    replaceBReps?: boolean;
    skipBReps?: boolean;
}

// @alpha
export interface ElementGeometryUpdate {
    elementId: Id64String;
    entryArray: ElementGeometryDataEntry[];
    is2dPart?: boolean;
    isWorld?: boolean;
    viewIndependent?: boolean;
}

// @internal
export interface ElementGraphicsRequestProps {
    readonly clipToProjectExtents?: boolean;
    readonly contentFlags?: ContentFlags;
    readonly elementId: Id64String;
    readonly formatVersion: number;
    readonly id: string;
    readonly location?: TransformProps;
    readonly omitEdges?: boolean;
    readonly toleranceLog10: number;
    readonly treeFlags?: TreeFlags;
}

// @alpha
export interface ElementIdsAndRangesProps {
    readonly ids: CompressedId64Set;
    readonly ranges: Range3dProps[];
}

// @public
export interface ElementLoadProps {
    // (undocumented)
    code?: CodeProps;
    // @internal
    displayStyle?: {
        omitScheduleScriptElementIds?: boolean;
    };
    // (undocumented)
    federationGuid?: GuidString;
    // (undocumented)
    id?: Id64String;
    wantBRepData?: boolean;
    wantGeometry?: boolean;
}

// @public
export interface ElementProps extends EntityProps {
    code: CodeProps;
    federationGuid?: GuidString;
    jsonProperties?: any;
    model: Id64String;
    parent?: RelatedElementProps;
    userLabel?: string;
}

// @beta
export class EntityMetaData implements EntityMetaDataProps {
    constructor(jsonObj: EntityMetaDataProps);
    readonly baseClasses: string[];
    readonly customAttributes?: CustomAttribute[];
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly displayLabel?: string;
    readonly ecclass: string;
    // (undocumented)
    readonly modifier?: string;
    readonly properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @beta (undocumented)
export interface EntityMetaDataProps {
    baseClasses: string[];
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    ecclass: string;
    // (undocumented)
    modifier?: string;
    properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @public
export interface EntityProps {
    classFullName: string;
    id?: Id64String;
    jsonProperties?: {
        [key: string]: any;
    };
}

// @public
export interface EntityQueryParams {
    from?: string;
    limit?: number;
    offset?: number;
    only?: boolean;
    orderBy?: string;
    where?: string;
}

// @public
export interface EnvironmentProps {
    // (undocumented)
    ground?: GroundPlaneProps;
    // (undocumented)
    sky?: SkyBoxProps;
}

// @internal
export namespace Events {
    // (undocumented)
    export namespace NativeApp {
        const // (undocumented)
        namespace = "NativeApp";
        const // (undocumented)
        onMemoryWarning = "onMemoryWarning";
        const // (undocumented)
        onBriefcaseDownloadProgress = "download-progress";
        const // (undocumented)
        onInternetConnectivityChanged = "onInternetConnectivityChanged";
        const // (undocumented)
        onUserStateChanged = "onUserStateChanged";
        const modelGeometryChanges = "modelGeometryChanges";
    }
}

// @alpha
export interface ExtantElementGeometryChange {
    readonly id: Id64String;
    readonly range: Range3d;
    readonly type: DbOpcode.Insert | DbOpcode.Update;
}

// @public
export interface ExternalSourceAspectProps extends ElementAspectProps {
    checksum?: string;
    identifier: string;
    jsonProperties?: any;
    kind: string;
    scope: RelatedElementProps;
    version?: string;
}

// @public
export class Feature {
    constructor(elementId?: Id64String, subCategoryId?: Id64String, geometryClass?: GeometryClass);
    compare(rhs: Feature): number;
    // (undocumented)
    readonly elementId: string;
    equals(other: Feature): boolean;
    // (undocumented)
    readonly geometryClass: GeometryClass;
    // (undocumented)
    get isDefined(): boolean;
    // (undocumented)
    get isUndefined(): boolean;
    // (undocumented)
    readonly subCategoryId: string;
}

// @public
export class FeatureAppearance implements FeatureAppearanceProps {
    protected constructor(props: FeatureAppearanceProps);
    get anyOverridden(): boolean;
    clone(changedProps: FeatureAppearanceProps): FeatureAppearance;
    cloneProps(changedProps: FeatureAppearanceProps): FeatureAppearanceProps;
    static readonly defaults: FeatureAppearance;
    // (undocumented)
    readonly emphasized?: true | undefined;
    // (undocumented)
    equals(other: FeatureAppearance): boolean;
    extendAppearance(base: FeatureAppearance): FeatureAppearance;
    // (undocumented)
    static fromJSON(props?: FeatureAppearanceProps): FeatureAppearance;
    static fromRgb(color: ColorDef): FeatureAppearance;
    static fromRgba(color: ColorDef): FeatureAppearance;
    static fromSubCategoryOverride(ovr: SubCategoryOverride): FeatureAppearance;
    static fromTransparency(transparencyValue: number): FeatureAppearance;
    // (undocumented)
    readonly ignoresMaterial?: true | undefined;
    // (undocumented)
    get isFullyTransparent(): boolean;
    // (undocumented)
    readonly linePixels?: LinePixels;
    // (undocumented)
    readonly nonLocatable?: true | undefined;
    // (undocumented)
    get overridesLinePixels(): boolean;
    // (undocumented)
    get overridesNonLocatable(): boolean;
    // (undocumented)
    get overridesRgb(): boolean;
    // (undocumented)
    get overridesSymbology(): boolean;
    // (undocumented)
    get overridesTransparency(): boolean;
    // (undocumented)
    get overridesWeight(): boolean;
    // (undocumented)
    readonly rgb?: RgbColor;
    // (undocumented)
    toJSON(): FeatureAppearanceProps;
    // (undocumented)
    readonly transparency?: number;
    // (undocumented)
    readonly weight?: number;
}

// @public
export interface FeatureAppearanceProps {
    emphasized?: true | undefined;
    ignoresMaterial?: true | undefined;
    linePixels?: LinePixels;
    nonLocatable?: true | undefined;
    rgb?: RgbColorProps;
    transparency?: number;
    weight?: number;
}

// @beta
export interface FeatureAppearanceProvider {
    getFeatureAppearance(overrides: FeatureOverrides, elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): FeatureAppearance | undefined;
}

// @internal
export class FeatureGates {
    addMonitor(feature: string, monitor: (val: GateValue) => void): () => void;
    check(feature: string, defaultVal?: GateValue): GateValue;
    readonly gates: Map<string, GateValue>;
    onChanged: BeEvent<(feature: string, val: GateValue) => void>;
    setGate(feature: string, val: GateValue): void;
}

// @internal (undocumented)
export class FeatureIndex {
    constructor();
    // (undocumented)
    featureID: number;
    // (undocumented)
    featureIDs?: Uint32Array;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    reset(): void;
    // (undocumented)
    type: FeatureIndexType;
}

// @internal (undocumented)
export enum FeatureIndexType {
    // (undocumented)
    Empty = 0,
    // (undocumented)
    NonUniform = 2,
    // (undocumented)
    Uniform = 1
}

// @public
export class FeatureOverrides {
    constructor();
    // @internal (undocumented)
    get alwaysDrawn(): Id64.Uint32Set;
    // @internal
    protected readonly _alwaysDrawn: Id64.Uint32Set;
    // @beta
    alwaysDrawnIgnoresSubCategory: boolean;
    // @internal
    readonly animationNodeOverrides: Map<number, FeatureAppearance>;
    // @internal
    protected _constructions: boolean;
    get defaultOverrides(): FeatureAppearance;
    // @internal
    protected _defaultOverrides: FeatureAppearance;
    // @internal
    protected _dimensions: boolean;
    // @internal
    protected readonly _elementOverrides: Id64.Uint32Map<FeatureAppearance>;
    // @alpha
    getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): FeatureAppearance | undefined;
    // @internal
    protected getClassifierAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, modelLo: number, modelHi: number, animationNodeId: number): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getElementOverrides(idLo: number, idHi: number, animationNodeId: number): FeatureAppearance | undefined;
    getElementOverridesById(id: Id64String): FeatureAppearance | undefined;
    getFeatureAppearance(feature: Feature, modelId: Id64String, type?: BatchType): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getModelOverrides(idLo: number, idHi: number): FeatureAppearance | undefined;
    getModelOverridesById(id: Id64String): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getSubCategoryOverrides(idLo: number, idHi: number): FeatureAppearance | undefined;
    getSubCategoryOverridesById(id: Id64String): FeatureAppearance | undefined;
    // @internal
    getSubCategoryPriority(idLo: number, idHi: number): number;
    // @internal
    ignoreSubCategory: boolean;
    // @internal (undocumented)
    protected isAlwaysDrawn(idLo: number, idHi: number): boolean;
    isAlwaysDrawnExclusive: boolean;
    // @internal (undocumented)
    isClassVisible(geomClass: GeometryClass): boolean;
    isFeatureVisible(feature: Feature): boolean;
    // @internal (undocumented)
    protected isNeverDrawn(elemIdLo: number, elemIdHi: number, animationNodeId: number): boolean;
    isSubCategoryIdVisible(id: Id64String): boolean;
    // @internal
    isSubCategoryVisible(idLo: number, idHi: number): boolean;
    // @internal (undocumented)
    isSubCategoryVisibleInModel(subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): boolean;
    get lineWeights(): boolean;
    // @internal
    protected _lineWeights: boolean;
    // @internal
    protected readonly _modelOverrides: Id64.Uint32Map<FeatureAppearance>;
    // @internal
    protected readonly _modelSubCategoryOverrides: Id64.Uint32Map<Id64.Uint32Set>;
    // @internal (undocumented)
    get neverDrawn(): Id64.Uint32Set;
    // @internal
    protected readonly _neverDrawn: Id64.Uint32Set;
    // @internal
    readonly neverDrawnAnimationNodes: Set<number>;
    overrideAnimationNode(id: number, app: FeatureAppearance): void;
    overrideElement(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    overrideModel(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    overrideSubCategory(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    // @internal
    protected _patterns: boolean;
    setAlwaysDrawn(id: Id64String): void;
    setAlwaysDrawnSet(ids: Id64Set, exclusive: boolean, ignoreSubCategory?: boolean): void;
    setAnimationNodeNeverDrawn(id: number): void;
    setDefaultOverrides(appearance: FeatureAppearance, replaceExisting?: boolean): void;
    setNeverDrawn(id: Id64String): void;
    setNeverDrawnSet(ids: Id64Set): void;
    setVisibleSubCategory(id: Id64String): void;
    // @internal
    protected readonly _subCategoryOverrides: Id64.Uint32Map<FeatureAppearance>;
    // @internal
    protected readonly _subCategoryPriorities: Id64.Uint32Map<number>;
    // @internal
    protected readonly _visibleSubCategories: Id64.Uint32Set;
    }

// @beta
export class FeatureTable extends IndexMap<Feature> {
    constructor(maxFeatures: number, modelId?: Id64String, type?: BatchType);
    // @internal (undocumented)
    get anyDefined(): boolean;
    findFeature(index: number): Feature | undefined;
    // @internal (undocumented)
    getArray(): Array<IndexedValue<Feature>>;
    // @internal (undocumented)
    insertWithIndex(feature: Feature, index: number): void;
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    get isVolumeClassifier(): boolean;
    get maxFeatures(): number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
}

// @internal
export class FeatureTableHeader {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    static readFrom(stream: ByteStream): FeatureTableHeader | undefined;
    // (undocumented)
    static sizeInBytes: number;
}

// @public (undocumented)
export interface FilePropertyProps {
    // (undocumented)
    id?: number | string;
    // (undocumented)
    name: string;
    // (undocumented)
    namespace: string;
    // (undocumented)
    subId?: number | string;
}

// @public
export enum FillDisplay {
    Always = 2,
    Blanking = 3,
    ByView = 1,
    Never = 0
}

// @public
export enum FillFlags {
    Always = 2,
    Background = 8,
    Behind = 4,
    Blanking = 6,
    ByView = 1,
    None = 0
}

// @public
export class FontMap {
    constructor(props?: FontMapProps);
    // (undocumented)
    addFonts(fonts: FontProps[]): void;
    // (undocumented)
    readonly fonts: Map<number, FontProps>;
    getFont(arg: string | number): FontProps | undefined;
    // (undocumented)
    toJSON(): FontMapProps;
}

// @public
export interface FontMapProps {
    // (undocumented)
    fonts: FontProps[];
}

// @public
export interface FontProps {
    // (undocumented)
    id: number;
    // (undocumented)
    name: string;
    // (undocumented)
    type: FontType;
}

// @public
export enum FontType {
    // (undocumented)
    Rsc = 2,
    // (undocumented)
    Shx = 3,
    // (undocumented)
    TrueType = 1
}

// @internal (undocumented)
export interface FormDataCommon {
    // (undocumented)
    append(name: string, value: string | Blob | Buffer, fileName?: string): void;
}

// @public
export class Frustum {
    constructor();
    clone(result?: Frustum): Frustum;
    distance(corner1: number, corner2: number): number;
    equals(rhs: Frustum): boolean;
    fixPointOrder(): void;
    static fromRange(range: LowAndHighXYZ | LowAndHighXY, out?: Frustum): Frustum;
    get frontCenter(): Point3d;
    getCenter(): Point3d;
    getCorner(i: number): Point3d;
    getEyePoint(result?: Point3d): Point3d | undefined;
    getFraction(): number;
    getRangePlanes(clipFront: boolean, clipBack: boolean, expandPlaneDistance: number): ConvexClipPlaneSet;
    getRotation(result?: Matrix3d): Matrix3d | undefined;
    get hasMirror(): boolean;
    initFromRange(range: LowAndHighXYZ | LowAndHighXY): void;
    initNpc(): this;
    invalidate(): void;
    isSame(other: Frustum): boolean;
    multiply(trans: Transform): void;
    readonly points: Point3d[];
    get rearCenter(): Point3d;
    scaleAboutCenter(scale: number): void;
    scaleXYAboutCenter(scale: number): void;
    setFrom(other: Frustum): void;
    toMap4d(): Map4d | undefined;
    toRange(range?: Range3d): Range3d;
    transformBy(trans: Transform, result?: Frustum): Frustum;
    translate(offset: XYAndZ): void;
}

// @internal
export class FrustumPlanes {
    constructor(frustum?: Frustum);
    // (undocumented)
    computeContainment(points: Point3d[], sphere?: BoundingSphere, tolerance?: number): FrustumPlanes.Containment;
    // (undocumented)
    computeFrustumContainment(box: Frustum, sphere?: BoundingSphere): FrustumPlanes.Containment;
    // (undocumented)
    containsPoint(point: Point3d, tolerance?: number): boolean;
    // (undocumented)
    init(frustum: Frustum): void;
    // (undocumented)
    intersectsFrustum(box: Frustum): boolean;
    // (undocumented)
    intersectsRay(origin: Point3d, direction: Vector3d): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get planes(): ClipPlane[] | undefined;
    }

// @internal (undocumented)
export namespace FrustumPlanes {
    // (undocumented)
    export function addPlaneFromPoints(planes: ClipPlane[], points: Point3d[], i0: number, i1: number, i2: number, expandPlaneDistance?: number): void;
    // (undocumented)
    export enum Containment {
        // (undocumented)
        Inside = 2,
        // (undocumented)
        Outside = 0,
        // (undocumented)
        Partial = 1
    }
}

// @public (undocumented)
export interface FunctionalElementProps extends ElementProps {
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @internal (undocumented)
export type GateValue = number | boolean | string | undefined;

// @beta
export interface GeoCoordinatesRequestProps {
    // (undocumented)
    iModelCoords: XYZProps[];
    // (undocumented)
    targetDatum: string;
}

// @beta
export interface GeoCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    geoCoords: PointWithStatus[];
}

// @public (undocumented)
export enum GeoCoordStatus {
    // (undocumented)
    CSMapError = 4096,
    // (undocumented)
    NoDatumConverter = 25,
    // (undocumented)
    NoGCSDefined = 100,
    // (undocumented)
    OutOfMathematicalDomain = 2,
    // (undocumented)
    OutOfUsefulRange = 1,
    // (undocumented)
    Pending = -41556,
    // (undocumented)
    Success = 0,
    // (undocumented)
    VerticalDatumConvertError = 26
}

// @public
export interface GeometricElement2dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement2dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElement3dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement3dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElementProps extends ElementProps {
    category: Id64String;
    // (undocumented)
    geom?: GeometryStreamProps;
}

// @public
export interface GeometricModel2dProps extends GeometricModelProps {
    globalOrigin?: XYProps;
}

// @public
export interface GeometricModel3dProps extends GeometricModelProps {
    isNotSpatiallyLocated?: boolean;
    isPlanProjection?: boolean;
}

// @public
export interface GeometricModelProps extends ModelProps {
    geometryGuid?: GuidString;
}

// @public
export interface GeometryAppearanceProps {
    color?: ColorDefProps;
    displayPriority?: number;
    geometryClass?: GeometryClass;
    style?: Id64String;
    subCategory?: Id64String;
    transparency?: number;
    weight?: number;
}

// @public
export enum GeometryClass {
    Construction = 1,
    Dimension = 2,
    Pattern = 3,
    Primary = 0
}

// @beta
export interface GeometryContainmentRequestProps {
    // (undocumented)
    allowOverlaps?: boolean;
    // (undocumented)
    candidates: Id64Array;
    // (undocumented)
    clip: any;
    // (undocumented)
    offSubCategories?: Id64Array;
    // (undocumented)
    viewFlags?: ViewFlagProps;
}

// @beta
export interface GeometryContainmentResponseProps {
    // (undocumented)
    candidatesContainment?: ClipPlaneContainment[];
    // (undocumented)
    numInside?: number;
    // (undocumented)
    numOutside?: number;
    // (undocumented)
    numOverlap?: number;
    // (undocumented)
    status: BentleyStatus;
}

// @public
export class GeometryParams {
    constructor(categoryId: Id64String, subCategoryId?: string);
    backgroundFill?: BackgroundFill;
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    clone(): GeometryParams;
    elmPriority?: number;
    elmTransparency?: number;
    fillColor?: ColorDef;
    fillDisplay?: FillDisplay;
    fillTransparency?: number;
    geometryClass?: GeometryClass;
    gradient?: Gradient.Symb;
    isEquivalent(other: GeometryParams): boolean;
    lineColor?: ColorDef;
    materialId?: Id64String;
    pattern?: AreaPattern.Params;
    resetAppearance(): void;
    setCategoryId(categoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    setSubCategoryId(subCategoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    styleInfo?: LineStyle.Info;
    // (undocumented)
    subCategoryId: string;
    weight?: number;
}

// @public
export interface GeometryPartInstanceProps {
    origin?: XYZProps;
    part: Id64String;
    rotation?: YawPitchRollProps;
    scale?: number;
}

// @public
export interface GeometryPartProps extends ElementProps {
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // (undocumented)
    geom?: GeometryStreamProps;
}

// @public
export interface GeometryPrimitive {
    // (undocumented)
    readonly geometry: AnyGeometryQuery;
    // (undocumented)
    type: "geometryQuery";
}

// @public
export class GeometryStreamBuilder {
    // @beta
    appendBRepData(brep: BRepEntity.DataProps): boolean;
    appendGeometry(geometry: GeometryQuery): boolean;
    appendGeometryParamsChange(geomParams: GeometryParams): boolean;
    appendGeometryPart2d(partId: Id64String, instanceOrigin?: Point2d, instanceRotation?: Angle, instanceScale?: number): boolean;
    appendGeometryPart3d(partId: Id64String, instanceOrigin?: Point3d, instanceRotation?: YawPitchRollAngles, instanceScale?: number): boolean;
    appendGeometryRanges(): void;
    // @beta
    appendImage(image: ImageGraphic): boolean;
    appendSubCategoryChange(subCategoryId: Id64String): boolean;
    appendTextString(textString: TextString): boolean;
    readonly geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    getHeader(): GeometryStreamHeaderProps | undefined;
    get isViewIndependent(): boolean;
    set isViewIndependent(viewIndependent: boolean);
    // @internal (undocumented)
    obtainHeader(): GeometryStreamHeaderProps;
    setLocalToWorld(localToWorld?: Transform): void;
    setLocalToWorld2d(origin: Point2d, angle?: Angle): void;
    setLocalToWorld3d(origin: Point3d, angles?: YawPitchRollAngles): void;
    }

// @public
export interface GeometryStreamEntryProps extends IModelJson.GeometryProps {
    // (undocumented)
    appearance?: GeometryAppearanceProps;
    // @beta (undocumented)
    brep?: BRepEntity.DataProps;
    // (undocumented)
    fill?: AreaFillProps;
    // (undocumented)
    geomPart?: GeometryPartInstanceProps;
    // (undocumented)
    header?: GeometryStreamHeaderProps;
    // @beta (undocumented)
    image?: ImageGraphicProps;
    // (undocumented)
    material?: MaterialProps;
    // (undocumented)
    pattern?: AreaPattern.ParamsProps;
    // (undocumented)
    styleMod?: LineStyle.ModifierProps;
    // (undocumented)
    subRange?: LowAndHighXYZ;
    // (undocumented)
    textString?: TextStringProps;
}

// @public
export enum GeometryStreamFlags {
    None = 0,
    ViewIndependent = 1
}

// @public
export interface GeometryStreamHeaderProps {
    flags: GeometryStreamFlags;
}

// @public
export class GeometryStreamIterator implements IterableIterator<GeometryStreamIteratorEntry> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<GeometryStreamIteratorEntry>;
    constructor(geometryStream: GeometryStreamProps, categoryOrGeometryParams?: Id64String | GeometryParams, localToWorld?: Transform);
    readonly flags: GeometryStreamFlags;
    static fromGeometricElement2d(element: GeometricElement2dProps): GeometryStreamIterator;
    static fromGeometricElement3d(element: GeometricElement3dProps): GeometryStreamIterator;
    static fromGeometryPart(geomPart: GeometryPartProps, geomParams?: GeometryParams, partTransform?: Transform): GeometryStreamIterator;
    geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    get isViewIndependent(): boolean;
    next(): IteratorResult<GeometryStreamIteratorEntry>;
    partToWorld(): Transform | undefined;
}

// @public
export interface GeometryStreamIteratorEntry {
    readonly geomParams: GeometryParams;
    readonly localRange?: Range3d;
    readonly localToWorld?: Transform;
    readonly primitive: GeometryStreamPrimitive;
}

// @public
export type GeometryStreamPrimitive = TextStringPrimitive | PartReference | BRepPrimitive | GeometryPrimitive | ImagePrimitive;

// @public
export type GeometryStreamProps = GeometryStreamEntryProps[];

// @beta
export interface GeometrySummaryOptions {
    geometryVerbosity?: GeometrySummaryVerbosity;
    includePartReferences?: "2d" | "3d";
    includePlacement?: boolean;
    verboseSymbology?: boolean;
}

// @beta
export interface GeometrySummaryRequestProps {
    elementIds: Id64Array;
    options?: GeometrySummaryOptions;
}

// @beta
export enum GeometrySummaryVerbosity {
    Basic = 10,
    Detailed = 20,
    Full = 30
}

// @internal
export const getIModelElectronApi: () => IModelElectronApi | undefined;

// @internal (undocumented)
export function getMaximumMajorTileFormatVersion(maxMajorVersion: number, formatVersion?: number): number;

export { GetMetaDataFunction }

// @public
export enum GlobeMode {
    Ellipsoid = 0,
    Plane = 1
}

// @internal
export class GltfBufferData {
    constructor(buffer: GltfDataBuffer, count: number);
    // (undocumented)
    readonly buffer: GltfDataBuffer;
    // (undocumented)
    readonly count: number;
    static create(bytes: Uint8Array, actualType: GltfDataType, expectedType: GltfDataType, count: number): GltfBufferData | undefined;
    }

// @internal
export class GltfBufferView {
    constructor(data: Uint8Array, count: number, type: GltfDataType, accessor: any, stride: number);
    // (undocumented)
    readonly accessor: any;
    // (undocumented)
    get byteLength(): number;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly data: Uint8Array;
    // (undocumented)
    readonly stride: number;
    // (undocumented)
    toBufferData(desiredType: GltfDataType): GltfBufferData | undefined;
    // (undocumented)
    readonly type: GltfDataType;
}

// @internal (undocumented)
export enum GltfConstants {
    // (undocumented)
    ArrayBuffer = 34962,
    // (undocumented)
    ClampToEdge = 33071,
    // (undocumented)
    CullFace = 2884,
    // (undocumented)
    DepthTest = 2929,
    // (undocumented)
    ElementArrayBuffer = 34963,
    // (undocumented)
    FragmentShader = 35632,
    // (undocumented)
    Linear = 9729,
    // (undocumented)
    LinearMipmapLinear = 9987,
    // (undocumented)
    Nearest = 9728,
    // (undocumented)
    VertexShader = 35633
}

// @internal (undocumented)
export type GltfDataBuffer = Uint8Array | Uint16Array | Uint32Array | Float32Array;

// @internal (undocumented)
export enum GltfDataType {
    // (undocumented)
    Float = 5126,
    // (undocumented)
    FloatMat3 = 35675,
    // (undocumented)
    FloatMat4 = 35676,
    // (undocumented)
    FloatVec2 = 35664,
    // (undocumented)
    FloatVec3 = 35665,
    // (undocumented)
    FloatVec4 = 35666,
    // (undocumented)
    IntVec2 = 35667,
    // (undocumented)
    IntVec3 = 35668,
    // (undocumented)
    Rgb = 6407,
    // (undocumented)
    Rgba = 6408,
    // (undocumented)
    Sampler2d = 35678,
    // (undocumented)
    SignedByte = 5120,
    // (undocumented)
    SignedShort = 5122,
    // (undocumented)
    UInt32 = 5125,
    // (undocumented)
    UnsignedByte = 5121,
    // (undocumented)
    UnsignedShort = 5123
}

// @internal
export class GltfHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly binaryPosition: number;
    // (undocumented)
    readonly gltfLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly scenePosition: number;
    // (undocumented)
    readonly sceneStrLength: number;
}

// @internal (undocumented)
export enum GltfMeshMode {
    // (undocumented)
    Lines = 1,
    // (undocumented)
    LineStrip = 3,
    // (undocumented)
    Points = 0,
    // (undocumented)
    Triangles = 4
}

// @internal (undocumented)
export enum GltfV2ChunkTypes {
    // (undocumented)
    Binary = 5130562,
    // (undocumented)
    JSON = 1313821514
}

// @internal
export enum GltfVersions {
    // (undocumented)
    CurrentVersion = 1,
    // (undocumented)
    Gltf1SceneFormat = 0,
    // (undocumented)
    Version1 = 1,
    // (undocumented)
    Version2 = 2
}

// @public
export namespace Gradient {
    export enum Flags {
        Invert = 1,
        None = 0,
        Outline = 2
    }
    export class KeyColor {
        constructor(json: KeyColorProps);
        // (undocumented)
        color: ColorDef;
        // (undocumented)
        value: number;
    }
    export function keyColorEquals(a: KeyColor, b: KeyColor): boolean;
    export interface KeyColorProps {
        color: ColorDefProps;
        value: number;
    }
    export enum Mode {
        // (undocumented)
        Curved = 2,
        // (undocumented)
        Cylindrical = 3,
        // (undocumented)
        Hemispherical = 5,
        // (undocumented)
        Linear = 1,
        // (undocumented)
        None = 0,
        // (undocumented)
        Spherical = 4,
        // @beta (undocumented)
        Thematic = 6
    }
    export class Symb {
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        clone(): Symb;
        compare(other: Symb): number;
        static compareSymb(lhs: Gradient.Symb, rhs: Gradient.Symb): number;
        // @beta (undocumented)
        static createThematic(settings: ThematicGradientSettings): Symb;
        equals(other: Symb): boolean;
        // (undocumented)
        flags: Flags;
        static fromJSON(json?: SymbProps): Symb;
        // @beta
        getImage(width: number, height: number): ImageBuffer;
        // @internal
        getThematicImageForRenderer(maxDimension: number): ImageBuffer;
        // (undocumented)
        get hasTranslucency(): boolean;
        get isOutlined(): boolean;
        // (undocumented)
        keys: KeyColor[];
        mapColor(value: number): ColorDef;
        // (undocumented)
        mode: Mode;
        // (undocumented)
        shift: number;
        // @beta (undocumented)
        thematicSettings?: ThematicGradientSettings;
        // (undocumented)
        tint?: number;
        // (undocumented)
        toJSON(): SymbProps;
    }
    export interface SymbProps {
        angle?: AngleProps;
        flags?: Flags;
        keys: KeyColorProps[];
        mode: Mode;
        shift?: number;
        // @beta
        thematicSettings?: ThematicGradientSettingsProps;
        tint?: number;
    }
}

// @public
export class GraphicParams {
    fillColor: ColorDef;
    fillFlags: FillFlags;
    static fromBlankingFill(fillColor: ColorDef): GraphicParams;
    static fromSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): GraphicParams;
    gradient?: Gradient.Symb;
    lineColor: ColorDef;
    linePixels: LinePixels;
    // @beta
    material?: RenderMaterial;
    rasterWidth: number;
    setFillTransparency(transparency: number): void;
    setLineTransparency(transparency: number): void;
    // @alpha (undocumented)
    trueWidthEnd: number;
    // @alpha (undocumented)
    trueWidthStart: number;
}

// @public
export enum GridOrientationType {
    AuxCoord = 4,
    View = 0,
    WorldXY = 1,
    WorldXZ = 3,
    WorldYZ = 2
}

// @public
export class GroundPlane {
    constructor(ground?: GroundPlaneProps);
    aboveColor: ColorDef;
    belowColor: ColorDef;
    display: boolean;
    elevation: number;
    // @internal
    getGroundPlaneGradient(aboveGround: boolean): Gradient.Symb;
    // (undocumented)
    toJSON(): GroundPlaneProps;
}

// @public
export interface GroundPlaneProps {
    aboveColor?: ColorDefProps;
    belowColor?: ColorDefProps;
    display?: boolean;
    elevation?: number;
}

// @public
export class HemisphereLights {
    constructor(json?: HemisphereLightsProps);
    clone(changed?: HemisphereLightsProps): HemisphereLights;
    // (undocumented)
    equals(rhs: HemisphereLights): boolean;
    // (undocumented)
    readonly intensity: number;
    // (undocumented)
    readonly lowerColor: RgbColor;
    // (undocumented)
    toJSON(): HemisphereLightsProps | undefined;
    // (undocumented)
    readonly upperColor: RgbColor;
}

// @public
export interface HemisphereLightsProps {
    intensity?: number;
    lowerColor?: RgbColorProps;
    upperColor?: RgbColorProps;
}

// @public
export namespace HiddenLine {
    export class Settings {
        static defaults: Settings;
        static fromJSON(json?: SettingsProps): Settings;
        readonly hidden: Style;
        override(props: SettingsProps): Settings;
        // (undocumented)
        toJSON(): SettingsProps;
        readonly transparencyThreshold: number;
        // (undocumented)
        get transThreshold(): number;
        readonly visible: Style;
    }
    export interface SettingsProps {
        readonly hidden?: StyleProps;
        readonly transThreshold?: number;
        readonly visible?: StyleProps;
    }
    export class Style {
        readonly color?: ColorDef;
        // (undocumented)
        static readonly defaultHidden: Style;
        // (undocumented)
        static readonly defaultVisible: Style;
        equals(other: Style): boolean;
        // (undocumented)
        static fromJSON(json?: StyleProps, hidden?: true): Style;
        overrideColor(color: ColorDef | undefined): Style;
        overridePattern(pattern: LinePixels | undefined): Style;
        overrideWidth(width: number | undefined): Style;
        // @internal (undocumented)
        get ovrColor(): boolean;
        readonly pattern?: LinePixels;
        // (undocumented)
        toJSON(): StyleProps;
        readonly width?: number;
    }
    export interface StyleProps {
        readonly color?: ColorDefProps;
        // @internal
        readonly ovrColor?: boolean;
        readonly pattern?: LinePixels;
        readonly width?: number;
    }
}

// @public
export namespace Hilite {
    export function cloneSettings(settings: Settings): Settings;
    export function equalSettings(lhs: Settings, rhs: Settings): boolean;
    export class Settings {
        constructor(color?: ColorDef, visibleRatio?: number, hiddenRatio?: number, silhouette?: Silhouette);
        readonly color: ColorDef;
        readonly hiddenRatio: number;
        silhouette: Silhouette;
        readonly visibleRatio: number;
    }
    export enum Silhouette {
        None = 0,
        Thick = 2,
        Thin = 1
    }
}

// @public
export class HSLColor {
    constructor(hue?: number, saturation?: number, lightness?: number);
    // (undocumented)
    clone(hue?: number, saturation?: number, lightness?: number): HSLColor;
    // (undocumented)
    static fromColorDef(val: ColorDef): HSLColor;
    readonly h: number;
    readonly l: number;
    readonly s: number;
    // (undocumented)
    toColorDef(transparency?: number): ColorDef;
}

// @public
export class HSVColor {
    constructor(hue?: number, saturation?: number, value?: number);
    // (undocumented)
    adjusted(darkenColor: boolean, delta: number): HSVColor;
    // (undocumented)
    clone(hue?: number, saturation?: number, value?: number): HSVColor;
    // (undocumented)
    static fromColorDef(val: ColorDef): HSVColor;
    readonly h: number;
    readonly s: number;
    // (undocumented)
    toColorDef(transparency?: number): ColorDef;
    readonly v: number;
}

// @public (undocumented)
export enum HSVConstants {
    // (undocumented)
    HSV_SATURATION_WEIGHT = 4,
    // (undocumented)
    HSV_VALUE_WEIGHT = 2,
    // (undocumented)
    VISIBILITY_GOAL = 40
}

// @public (undocumented)
export type HttpMethod_T = "get" | "put" | "post" | "delete" | "options" | "head" | "patch" | "trace";

// @public
export interface HttpServerRequest extends Readable {
    // (undocumented)
    body: string | Buffer;
    // (undocumented)
    connection: any;
    // (undocumented)
    destroy(error?: Error): void;
    // (undocumented)
    header: (field: string) => string | undefined;
    // (undocumented)
    headers: {
        [header: string]: string | string[] | undefined;
    };
    // (undocumented)
    httpVersion: string;
    // (undocumented)
    httpVersionMajor: number;
    // (undocumented)
    httpVersionMinor: number;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    path: string;
    // (undocumented)
    rawHeaders: string[];
    // (undocumented)
    rawTrailers: string[];
    // (undocumented)
    setTimeout(msecs: number, callback: () => void): this;
    // (undocumented)
    socket: any;
    // (undocumented)
    statusCode?: number;
    // (undocumented)
    statusMessage?: string;
    // (undocumented)
    trailers: {
        [key: string]: string | undefined;
    };
    // (undocumented)
    url?: string;
}

// @public
export interface HttpServerResponse extends Writable {
    // (undocumented)
    send(body?: any): HttpServerResponse;
    // (undocumented)
    set(field: string, value: string): void;
    // (undocumented)
    status(code: number): HttpServerResponse;
}

// @internal
export class I3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    readonly featureTableJsonPosition: number;
    // (undocumented)
    readonly gltfVersion: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public
export class ImageBuffer {
    // @internal
    protected constructor(data: Uint8Array, format: ImageBufferFormat, width: number);
    // @internal (undocumented)
    protected static computeHeight(data: Uint8Array, format: ImageBufferFormat, width: number): number;
    static create(data: Uint8Array, format: ImageBufferFormat, width: number): ImageBuffer | undefined;
    readonly data: Uint8Array;
    readonly format: ImageBufferFormat;
    static getNumBytesPerPixel(format: ImageBufferFormat): number;
    get height(): number;
    // @internal (undocumented)
    protected static isValidData(data: Uint8Array, format: ImageBufferFormat, width: number): boolean;
    get numBytesPerPixel(): number;
    readonly width: number;
}

// @public
export enum ImageBufferFormat {
    Alpha = 5,
    Rgb = 2,
    Rgba = 0
}

// @beta
export class ImageGraphic {
    constructor(corners: ImageGraphicCorners, textureId: Id64String, hasBorder?: boolean);
    // (undocumented)
    clone(): ImageGraphic;
    // (undocumented)
    cloneTransformed(transform: Transform): ImageGraphic;
    computeRange(result?: Range3d): Range3d;
    readonly corners: ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicProps): ImageGraphic;
    readonly hasBorder: boolean;
    readonly textureId: Id64String;
    // (undocumented)
    toJSON(): ImageGraphicProps;
    transformInPlace(transform: Transform): void;
}

// @beta
export class ImageGraphicCorners {
    // (undocumented)
    readonly 0: Point3d;
    // (undocumented)
    readonly 1: Point3d;
    // (undocumented)
    readonly 2: Point3d;
    // (undocumented)
    readonly 3: Point3d;
    constructor(p0: Point3d, p1: Point3d, p2: Point3d, p3: Point3d);
    // (undocumented)
    clone(): ImageGraphicCorners;
    // (undocumented)
    static from4Points(points: [Point3d, Point3d, Point3d, Point3d]): ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicCornersProps): ImageGraphicCorners;
    // (undocumented)
    toJSON(): ImageGraphicCornersProps;
}

// @beta
export type ImageGraphicCornersProps = [XYZProps, XYZProps, XYZProps, XYZProps];

// @beta
export interface ImageGraphicProps {
    corners: ImageGraphicCornersProps;
    hasBorder: boolean;
    textureId: Id64String;
}

// @public
export interface ImagePrimitive {
    // @beta (undocumented)
    readonly image: ImageGraphic;
    // (undocumented)
    type: "image";
}

// @public
export class ImageSource {
    constructor(data: Uint8Array | string, format: ImageSourceFormat);
    readonly data: Uint8Array | string;
    readonly format: ImageSourceFormat;
}

// @public
export enum ImageSourceFormat {
    Jpeg = 0,
    Png = 2,
    Svg = 3
}

// @internal
export enum ImdlFlags {
    ContainsCurves = 1,
    DisallowMagnification = 8,
    Incomplete = 4,
    None = 0
}

// @internal
export class ImdlHeader extends TileHeader {
    constructor(stream: ByteStream);
    readonly contentRange: ElementAlignedBox3d;
    readonly emptySubRanges: number;
    readonly flags: ImdlFlags;
    readonly headerLength: number;
    // (undocumented)
    get isReadableVersion(): boolean;
    // (undocumented)
    get isValid(): boolean;
    readonly numElementsExcluded: number;
    readonly numElementsIncluded: number;
    readonly tileLength: number;
    readonly tolerance: number;
    // (undocumented)
    get versionMajor(): number;
    // (undocumented)
    get versionMinor(): number;
}

// @public
export abstract class IModel implements IModelProps {
    // @internal
    protected constructor(tokenProps: IModelRpcProps | undefined, openMode: OpenMode);
    cartographicToSpatialFromEcef(cartographic: Cartographic, result?: Point3d): Point3d;
    get changeSetId(): string | undefined;
    // @internal (undocumented)
    protected _changeSetId: string | undefined;
    get contextId(): GuidString | undefined;
    // @internal (undocumented)
    protected _contextId?: GuidString;
    static readonly dictionaryId: Id64String;
    get ecefLocation(): EcefLocation | undefined;
    ecefToSpatial(ecef: XYAndZ, result?: Point3d): Point3d;
    // @internal
    protected _fileKey: string;
    // @internal (undocumented)
    getConnectionProps(): IModelConnectionProps;
    static getDefaultSubCategoryId(categoryId: Id64String): Id64String;
    getEcefTransform(): Transform;
    // @internal (undocumented)
    protected abstract getEventSourceProps(): IModelEventSourceProps;
    getRpcProps(): IModelRpcProps;
    get globalOrigin(): Point3d;
    set globalOrigin(org: Point3d);
    get iModelId(): GuidString | undefined;
    // @internal (undocumented)
    protected initialize(name: string, props: IModelProps): void;
    abstract get isBriefcase(): boolean;
    get isGeoLocated(): boolean;
    // (undocumented)
    abstract get isOpen(): boolean;
    abstract get isSnapshot(): boolean;
    name: string;
    readonly openMode: OpenMode;
    get projectExtents(): AxisAlignedBox3d;
    set projectExtents(extents: AxisAlignedBox3d);
    static readonly repositoryModelId: Id64String;
    rootSubject: RootSubjectProps;
    static readonly rootSubjectId: Id64String;
    setEcefLocation(ecef: EcefLocationProps): void;
    spatialToCartographicFromEcef(spatial: XYAndZ, result?: Cartographic): Cartographic;
    spatialToEcef(spatial: XYAndZ, result?: Point3d): Point3d;
    // @internal (undocumented)
    toJSON(): IModelConnectionProps;
}

// @internal (undocumented)
export type IModelConnectionProps = IModelProps & IModelRpcProps & IModelEventSourceProps;

// @beta
export interface IModelCoordinatesRequestProps {
    // (undocumented)
    geoCoords: XYZProps[];
    // (undocumented)
    sourceDatum: string;
}

// @beta (undocumented)
export interface IModelCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    iModelCoords: PointWithStatus[];
}

// @internal (undocumented)
export interface IModelElectronApi extends IModelElectronIpc {
    // (undocumented)
    invoke(channel: string, ...args: any[]): Promise<any>;
    // (undocumented)
    sendSync(channel: string, ...args: any[]): any;
}

// @internal (undocumented)
export interface IModelElectronIpc {
    // (undocumented)
    on: (channel: string, listener: (event: any, ...args: any[]) => void) => void;
    // (undocumented)
    once: (channel: string, listener: (event: any, ...args: any[]) => void) => void;
    // (undocumented)
    removeListener: (channel: string, listener: (event: any, ...args: any[]) => void) => void;
    // (undocumented)
    send: (channel: string, ...data: any[]) => void;
}

// @public
export interface IModelEncryptionProps {
    password?: string;
}

// @public
export class IModelError extends BentleyError {
    constructor(errorNumber: number | IModelStatus | DbResult | BentleyStatus | BriefcaseStatus | RepositoryStatus | ChangeSetStatus | RpcInterfaceStatus | AuthStatus, message: string, log?: LogFunction, category?: string, getMetaData?: GetMetaDataFunction);
}

// @internal
export interface IModelEventSourceProps {
    // (undocumented)
    eventSourceName: string;
}

// @public
export class IModelNotFoundResponse extends RpcNotFoundResponse {
    // (undocumented)
    isIModelNotFoundResponse: boolean;
}

// @public
export interface IModelProps {
    ecefLocation?: EcefLocationProps;
    globalOrigin?: XYZProps;
    name?: string;
    projectExtents?: Range3dProps;
    rootSubject: RootSubjectProps;
}

// @internal
export abstract class IModelReadRpcInterface extends RpcInterface {
    // @beta (undocumented)
    cancelSnap(_iModelToken: IModelRpcProps, _sessionId: string): Promise<void>;
    // (undocumented)
    close(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    getAllCodeSpecs(_iModelToken: IModelRpcProps): Promise<any[]>;
    // (undocumented)
    getClassHierarchy(_iModelToken: IModelRpcProps, _startClassName: string): Promise<string[]>;
    static getClient(): IModelReadRpcInterface;
    static getClientForRouting(token: RpcRoutingToken): IModelReadRpcInterface;
    // (undocumented)
    getDefaultViewId(_iModelToken: IModelRpcProps): Promise<Id64String>;
    // (undocumented)
    getElementProps(_iModelToken: IModelRpcProps, _elementIds: Id64String[]): Promise<ElementProps[]>;
    // @beta (undocumented)
    getGeoCoordinatesFromIModelCoordinates(_iModelToken: IModelRpcProps, _props: string): Promise<GeoCoordinatesResponseProps>;
    // @beta (undocumented)
    getGeometryContainment(_iModelToken: IModelRpcProps, _props: GeometryContainmentRequestProps): Promise<GeometryContainmentResponseProps>;
    // @beta (undocumented)
    getGeometrySummary(_iModelToken: IModelRpcProps, _props: GeometrySummaryRequestProps): Promise<string>;
    // @beta (undocumented)
    getIModelCoordinatesFromGeoCoordinates(_iModelToken: IModelRpcProps, _props: string): Promise<IModelCoordinatesResponseProps>;
    // @beta (undocumented)
    getMassProperties(_iModelToken: IModelRpcProps, _props: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    // (undocumented)
    getModelProps(_iModelToken: IModelRpcProps, _modelIds: Id64String[]): Promise<ModelProps[]>;
    // (undocumented)
    getToolTipMessage(_iModelToken: IModelRpcProps, _elementId: string): Promise<string[]>;
    // (undocumented)
    getViewStateData(_iModelToken: IModelRpcProps, _viewDefinitionId: string): Promise<ViewStateProps>;
    // (undocumented)
    getViewThumbnail(_iModelToken: IModelRpcProps, _viewId: string): Promise<Uint8Array>;
    static readonly interfaceName = "IModelReadRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openForRead(_iModelToken: IModelRpcProps): Promise<IModelConnectionProps>;
    // (undocumented)
    queryElementProps(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<ElementProps[]>;
    // (undocumented)
    queryEntityIds(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<Id64String[]>;
    // (undocumented)
    queryModelProps(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<ModelProps[]>;
    // (undocumented)
    queryModelRanges(_iModelToken: IModelRpcProps, _modelIds: Id64String[]): Promise<Range3dProps[]>;
    // (undocumented)
    queryRows(_iModelToken: IModelRpcProps, _ecsql: string, _bindings?: any[] | object, _limit?: QueryLimit, _quota?: QueryQuota, _priority?: QueryPriority, _restartToken?: string): Promise<QueryResponse>;
    // (undocumented)
    readFontJson(_iModelToken: IModelRpcProps): Promise<any>;
    // @beta (undocumented)
    requestSnap(_iModelToken: IModelRpcProps, _sessionId: string, _props: SnapRequestProps): Promise<SnapResponseProps>;
}

// @public
export interface IModelRpcProps {
    changeSetId?: GuidString;
    readonly contextId?: GuidString;
    readonly iModelId?: GuidString;
    readonly key: string;
    openMode?: OpenMode;
}

export { IModelStatus }

// @public (undocumented)
export abstract class IModelTileRpcInterface extends RpcInterface {
    // (undocumented)
    static getClient(): IModelTileRpcInterface;
    // @beta (undocumented)
    getTileCacheContainerUrl(_tokenProps: IModelRpcProps, _id: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    static readonly interfaceName = "IModelTileRpcInterface";
    static interfaceVersion: string;
    // @internal
    purgeTileTrees(_tokenProps: IModelRpcProps, _modelIds: Id64Array | undefined): Promise<void>;
    // @internal (undocumented)
    queryVersionInfo(): Promise<TileVersionInfo>;
    // @internal
    requestElementGraphics(_rpcProps: IModelRpcProps, _request: ElementGraphicsRequestProps): Promise<Uint8Array | undefined>;
    // @internal (undocumented)
    requestTileContent(iModelToken: IModelRpcProps, treeId: string, contentId: string, isCanceled?: () => boolean, guid?: string): Promise<Uint8Array>;
    // @internal (undocumented)
    requestTileTreeProps(_tokenProps: IModelRpcProps, _id: string): Promise<IModelTileTreeProps>;
}

// @internal
export type IModelTileTreeId = PrimaryTileTreeId | ClassifierTileTreeId;

// @internal
export function iModelTileTreeIdToString(modelId: Id64String, treeId: IModelTileTreeId, options: TileOptions): string;

// @internal
export interface IModelTileTreeProps extends TileTreeProps {
    contentIdQualifier?: string;
    formatVersion?: number;
    geometryGuid?: GuidString;
    maxInitialTilesToSkip?: number;
}

// @public
export class IModelVersion {
    static asOfChangeSet(changeSetId: GuidString): IModelVersion;
    evaluateChangeSet(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, imodelClient: IModelClient): Promise<GuidString>;
    static first(): IModelVersion;
    static fromJson(jsonObj: any): IModelVersion;
    getAsOfChangeSet(): GuidString | undefined;
    getName(): string | undefined;
    get isFirst(): boolean;
    get isLatest(): boolean;
    static latest(): IModelVersion;
    static named(versionName: string): IModelVersion;
    }

// @internal
export abstract class IModelWriteRpcInterface extends RpcInterface {
    // (undocumented)
    createAndInsertPhysicalModel(_tokenProps: IModelRpcProps, _newModelCode: CodeProps, _privateModel: boolean): Promise<Id64String>;
    // (undocumented)
    createAndInsertSpatialCategory(_tokenProps: IModelRpcProps, _scopeModelId: Id64String, _categoryName: string, _appearance: SubCategoryAppearance.Props): Promise<Id64String>;
    // (undocumented)
    deleteElements(_tokenProps: IModelRpcProps, _ids: Id64Array): Promise<void>;
    // (undocumented)
    doConcurrencyControlRequest(_tokenProps: IModelRpcProps): Promise<void>;
    static getClient(): IModelWriteRpcInterface;
    static getClientForRouting(token: RpcRoutingToken): IModelWriteRpcInterface;
    // (undocumented)
    getModelsAffectedByWrites(_tokenProps: IModelRpcProps): Promise<Id64String[]>;
    // @deprecated (undocumented)
    getParentChangeset(_iModelToken: IModelRpcProps): Promise<string>;
    // (undocumented)
    hasPendingTxns(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    hasUnsavedChanges(_iModelToken: IModelRpcProps): Promise<boolean>;
    static readonly interfaceName = "IModelWriteRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    lockModel(_tokenProps: IModelRpcProps, _modelId: Id64String, _level: LockLevel): Promise<void>;
    // (undocumented)
    openForWrite(_iModelToken: IModelRpcProps): Promise<IModelConnectionProps>;
    // (undocumented)
    pullAndMergeChanges(_tokenProps: IModelRpcProps): Promise<IModelConnectionProps>;
    // @deprecated (undocumented)
    pullMergePush(_tokenProps: IModelRpcProps, _comment: string, _doPush: boolean): Promise<GuidString>;
    // (undocumented)
    pushChanges(_tokenProps: IModelRpcProps, _description: string): Promise<IModelConnectionProps>;
    // (undocumented)
    requestResources(_tokenProps: IModelRpcProps, _elementIds: Id64Array, _modelIds: Id64Array, _opcode: DbOpcode): Promise<void>;
    // (undocumented)
    saveChanges(_iModelToken: IModelRpcProps, _description?: string): Promise<void>;
    // (undocumented)
    saveThumbnail(_iModelToken: IModelRpcProps, _val: Uint8Array): Promise<void>;
    // (undocumented)
    synchConcurrencyControlResourcesCache(_tokenProps: IModelRpcProps): Promise<void>;
    // (undocumented)
    undoRedo(_rpc: IModelRpcProps, _undo: boolean): Promise<IModelStatus>;
    // (undocumented)
    updateProjectExtents(_iModelToken: IModelRpcProps, _newExtents: AxisAlignedBox3dProps): Promise<void>;
}

// @public
export interface InformationPartitionElementProps extends DefinitionElementProps {
    // (undocumented)
    description?: string;
}

// @internal (undocumented)
export const initializeRpcRequest: () => void;

// @internal (undocumented)
export const INSTANCE: unique symbol;

// @internal
export enum InternetConnectivityStatus {
    // (undocumented)
    Offline = 1,
    // (undocumented)
    Online = 0
}

// @beta
export const Interpolation: {
    Linear: (v: any, k: number) => number;
    Bezier: (v: any, k: number) => number;
    CatmullRom: (v: any, k: number) => number;
    Utils: {
        Linear: (p0: number, p1: number, t: number) => number;
        Bernstein: (n: number, i: number) => number;
        Factorial: (n: number) => number;
        CatmullRom: (p0: number, p1: number, p2: number, p3: number, t: number) => number;
    };
};

// @beta (undocumented)
export type InterpolationFunction = (v: any, k: number) => number;

// @internal
export function isKnownTileFormat(format: number): boolean;

// @public
export function isPowerOfTwo(num: number): boolean;

// @internal (undocumented)
export function isValidImageSourceFormat(format: ImageSourceFormat): boolean;

// @public (undocumented)
export interface LatAndLong {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public (undocumented)
export interface LatLongAndHeight extends LatAndLong {
    // (undocumented)
    height: number;
}

// @internal
export interface LightLocationProps extends GeometricElement3dProps {
    // (undocumented)
    enabled?: boolean;
}

// @public
export class LightSettings {
    // (undocumented)
    readonly ambient: AmbientLight;
    clone(changed?: LightSettingsProps): LightSettings;
    // (undocumented)
    equals(rhs: LightSettings): boolean;
    // (undocumented)
    static fromJSON(props?: LightSettingsProps): LightSettings;
    // (undocumented)
    readonly hemisphere: HemisphereLights;
    // (undocumented)
    readonly numCels: number;
    // (undocumented)
    readonly portraitIntensity: number;
    // (undocumented)
    readonly solar: SolarLight;
    // (undocumented)
    readonly specularIntensity: number;
    // (undocumented)
    toJSON(): LightSettingsProps | undefined;
}

// @public
export interface LightSettingsProps {
    ambient?: AmbientLightProps;
    hemisphere?: HemisphereLightsProps;
    numCels?: number;
    portrait?: {
        intensity?: number;
    };
    solar?: SolarLightProps;
    specularIntensity?: number;
}

// @public
export enum LinePixels {
    Code0 = 0,
    Code1 = 2155905152,
    Code2 = 4177066232,
    Code3 = 4292935648,
    Code4 = 4262526480,
    Code5 = 3772834016,
    Code6 = 4169726088,
    Code7 = 4279828248,
    HiddenLine = 3435973836,
    Invalid = -1,
    Invisible = 1,
    Solid = 0
}

// @public (undocumented)
export namespace LineStyle {
    export class Info {
        constructor(styleId: Id64String, styleMod?: Modifier);
        clone(): Info;
        // (undocumented)
        equals(other: Info): boolean;
        // (undocumented)
        styleId: Id64String;
        // (undocumented)
        styleMod?: Modifier;
    }
    export class Modifier implements ModifierProps {
        constructor(props: ModifierProps);
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        centerPhase?: boolean;
        clone(): Modifier;
        // (undocumented)
        dashScale?: number;
        // (undocumented)
        distPhase?: number;
        // (undocumented)
        endWidth?: number;
        equals(other: Modifier): boolean;
        // (undocumented)
        fractPhase?: number;
        // (undocumented)
        gapScale?: number;
        // (undocumented)
        normal?: Vector3d;
        // (undocumented)
        physicalWidth?: boolean;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        segmentMode?: boolean;
        // (undocumented)
        startWidth?: number;
    }
    export interface ModifierProps {
        centerPhase?: boolean;
        dashScale?: number;
        distPhase?: number;
        endWidth?: number;
        fractPhase?: number;
        gapScale?: number;
        normal?: XYZProps;
        physicalWidth?: boolean;
        rotation?: YawPitchRollProps;
        scale?: number;
        segmentMode?: boolean;
        startWidth?: number;
    }
}

// @beta
export interface LineStyleProps extends DefinitionElementProps {
    // (undocumented)
    data: string;
    // (undocumented)
    description?: string;
}

// @public
export type LocalAlignedBox3d = Range3d;

export { LogFunction }

// @alpha
export interface MapImageryProps {
    // (undocumented)
    backgroundBase?: BaseLayerProps;
    // (undocumented)
    backgroundLayers?: MapLayerProps[];
    // (undocumented)
    overlayLayers?: MapLayerProps[];
}

// @alpha
export class MapImagerySettings {
    // (undocumented)
    get backgroundBase(): BaseLayerSettings;
    set backgroundBase(base: BaseLayerSettings);
    // (undocumented)
    get backgroundLayers(): MapLayerSettings[];
    // @internal
    get baseTransparency(): number;
    static fromJSON(imageryJson?: MapImageryProps, mapProps?: BackgroundMapProps): MapImagerySettings;
    // (undocumented)
    get overlayLayers(): MapLayerSettings[];
    // (undocumented)
    toJSON(): MapImageryProps;
}

// @beta
export interface MapLayerKey {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @alpha
export interface MapLayerProps {
    accessKey?: MapLayerKey;
    formatId?: string;
    isBase?: boolean;
    maxZoom?: number;
    name?: string;
    password?: string;
    subLayers?: MapSubLayerProps[];
    transparency?: number;
    transparentBackground?: boolean;
    url?: string;
    userName?: string;
    visible?: boolean;
}

// @alpha
export class MapLayerSettings {
    // (undocumented)
    readonly accessKey?: MapLayerKey;
    get allSubLayersInvisible(): boolean;
    clone(changedProps: MapLayerProps): MapLayerSettings;
    // @internal (undocumented)
    displayMatches(other: MapLayerSettings): boolean;
    // (undocumented)
    readonly formatId: string;
    static fromJSON(json?: MapLayerProps): MapLayerSettings | undefined;
    static fromMapSettings(mapSettings: BackgroundMapSettings): MapLayerSettings;
    getSubLayerChildren(subLayer: MapSubLayerSettings): MapSubLayerSettings[] | undefined;
    // (undocumented)
    readonly isBase: boolean;
    isSubLayerVisible(subLayer: MapSubLayerSettings): boolean;
    // @internal (undocumented)
    matchesNameAndUrl(name: string, url: string): boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly password?: string;
    subLayerById(id?: SubLayerId): MapSubLayerSettings | undefined;
    // (undocumented)
    readonly subLayers: MapSubLayerSettings[];
    toJSON(): MapLayerProps;
    // (undocumented)
    readonly transparency: number;
    // (undocumented)
    readonly transparentBackground: boolean;
    // (undocumented)
    readonly url: string;
    // (undocumented)
    readonly userName?: string;
    // (undocumented)
    readonly visible: boolean;
}

// @alpha
export interface MapSubLayerProps {
    // (undocumented)
    children?: SubLayerId[];
    // (undocumented)
    id?: SubLayerId;
    // (undocumented)
    name?: string;
    // (undocumented)
    parent?: SubLayerId;
    // (undocumented)
    title?: string;
    // (undocumented)
    visible?: boolean;
}

// @alpha
export class MapSubLayerSettings {
    constructor(name: string, title?: string, visible?: boolean, id?: SubLayerId, parent?: SubLayerId, children?: SubLayerId[]);
    readonly children?: SubLayerId[];
    clone(changedProps: MapSubLayerProps): MapSubLayerSettings;
    // @internal (undocumented)
    displayMatches(other: MapSubLayerSettings): boolean;
    static fromJSON(json: MapSubLayerProps): MapSubLayerSettings | undefined;
    readonly id: SubLayerId;
    get idString(): string;
    get isLeaf(): boolean;
    get isNamed(): boolean;
    get isUnnamedGroup(): boolean;
    readonly name: string;
    readonly parent?: SubLayerId;
    readonly title?: string;
    // (undocumented)
    toJSON(): MapSubLayerProps;
    readonly visible: boolean;
}

// @public
export function mapToGeoServiceStatus(s: GeoCoordStatus): GeoServiceStatus;

// @internal (undocumented)
export interface MarshalingBinaryMarker {
    // (undocumented)
    chunks: number;
    // (undocumented)
    index: number;
    // (undocumented)
    isBinary: true;
    // (undocumented)
    size: number;
}

// @internal (undocumented)
export namespace MarshalingBinaryMarker {
    // (undocumented)
    export function createDefault(): MarshalingBinaryMarker;
}

// @beta
export enum MassPropertiesOperation {
    AccumulateAreas = 1,
    AccumulateLengths = 0,
    AccumulateVolumes = 2
}

// @beta
export interface MassPropertiesRequestProps {
    // (undocumented)
    candidates?: Id64Array;
    // (undocumented)
    operation: MassPropertiesOperation;
}

// @beta
export interface MassPropertiesResponseProps {
    // (undocumented)
    area?: number;
    // (undocumented)
    centroid?: XYZProps;
    // (undocumented)
    ixy?: number;
    // (undocumented)
    ixz?: number;
    // (undocumented)
    iyz?: number;
    // (undocumented)
    length?: number;
    // (undocumented)
    moments?: XYZProps;
    // (undocumented)
    perimeter?: number;
    // (undocumented)
    status: BentleyStatus;
    // (undocumented)
    volume?: number;
}

// @public
export interface MaterialProps {
    materialId?: Id64String;
    // @internal (undocumented)
    origin?: XYZProps;
    // @internal (undocumented)
    rotation?: YawPitchRollProps;
    // @internal (undocumented)
    size?: XYZProps;
}

// @internal (undocumented)
export class MeshEdge {
    constructor(index0?: number, index1?: number);
    // (undocumented)
    indices: number[];
}

// @internal (undocumented)
export class MeshEdges {
    constructor();
    // (undocumented)
    polylines: MeshPolylineList;
    // (undocumented)
    silhouette: MeshEdge[];
    // (undocumented)
    silhouetteNormals: OctEncodedNormalPair[];
    // (undocumented)
    visible: MeshEdge[];
}

// @internal (undocumented)
export class MeshPolyline {
    constructor(indices?: number[]);
    // (undocumented)
    addIndex(index: number): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly indices: number[];
}

// @internal (undocumented)
export class MeshPolylineList extends Array<MeshPolyline> {
    constructor(...args: MeshPolyline[]);
}

// @alpha
export interface MobileAuthorizationClientConfiguration {
    clientId: string;
    expiryBuffer?: number;
    redirectUri: string;
    scope: string;
}

// @beta (undocumented)
export type MobileRpcChunks = Array<string | Uint8Array>;

// @beta
export abstract class MobileRpcConfiguration extends RpcConfiguration {
    static get args(): any;
    static get isIOSFrontend(): any;
    static get isMobileBackend(): boolean;
    static get isMobileFrontend(): boolean;
    static get platform(): RpcMobilePlatform;
    // (undocumented)
    abstract protocol: MobileRpcProtocol;
    // @internal (undocumented)
    static setup: {
        obtainPort: () => number;
        checkPlatform: () => boolean;
    };
}

// @beta (undocumented)
export interface MobileRpcGateway {
    // (undocumented)
    connectionId: number;
    // (undocumented)
    handler: (payload: ArrayBuffer | string, connectionId: number) => void;
    // (undocumented)
    port: number;
    // (undocumented)
    sendBinary: (message: Uint8Array, connectionId: number) => void;
    // (undocumented)
    sendString: (message: string, connectionId: number) => void;
}

// @beta
export class MobileRpcManager {
    static initializeClient(interfaces: RpcInterfaceDefinition[]): MobileRpcConfiguration;
    static initializeImpl(interfaces: RpcInterfaceDefinition[]): MobileRpcConfiguration;
    // @internal (undocumented)
    static ready(): Promise<void>;
}

// @beta
export class MobileRpcProtocol extends RpcProtocol {
    constructor(configuration: MobileRpcConfiguration, endPoint: RpcEndpoint);
    // (undocumented)
    static encodeRequest(request: MobileRpcRequest): Promise<MobileRpcChunks>;
    // (undocumented)
    static encodeResponse(fulfillment: RpcRequestFulfillment): MobileRpcChunks;
    // (undocumented)
    static obtainInterop(): MobileRpcGateway;
    // (undocumented)
    requests: Map<string, MobileRpcRequest>;
    // (undocumented)
    readonly requestType: typeof MobileRpcRequest;
    // (undocumented)
    sendToBackend(message: MobileRpcChunks): void;
    // (undocumented)
    sendToFrontend(message: MobileRpcChunks, connection?: number): void;
    // (undocumented)
    socket: WebSocket;
    }

// @beta (undocumented)
export class MobileRpcRequest extends RpcRequest {
    protected load(): Promise<RpcSerializedValue>;
    // @internal (undocumented)
    notifyResponse(fulfillment: RpcRequestFulfillment): void;
    readonly protocol: MobileRpcProtocol;
    protected send(): Promise<number>;
    protected setHeader(_name: string, _value: string): void;
}

// @alpha
export class ModelClipGroup {
    clip?: ClipVector;
    clone(): ModelClipGroup;
    static create(clip: ClipVector | undefined, models?: Id64Array): ModelClipGroup;
    // @internal (undocumented)
    static fromJSON(props: ModelClipGroupProps): ModelClipGroup;
    includesModel(modelId: Id64String): boolean;
    models?: Id64Array;
    // @internal (undocumented)
    toJSON(): ModelClipGroupProps;
}

// @internal (undocumented)
export interface ModelClipGroupProps {
    // (undocumented)
    clip?: any;
    // (undocumented)
    models?: Id64Array;
}

// @alpha
export class ModelClipGroups {
    constructor(groups?: ModelClipGroup[]);
    clone(): ModelClipGroups;
    findGroup(modelId: Id64String): ModelClipGroup | undefined;
    findGroupIndex(modelId: Id64String): number;
    // @internal (undocumented)
    static fromJSON(props: ModelClipGroupProps[] | undefined): ModelClipGroups;
    getClipForModel(modelId: Id64String): ClipVector | undefined;
    readonly groups: ModelClipGroup[];
    // @internal (undocumented)
    toJSON(): ModelClipGroupProps[];
}

// @alpha
export interface ModelGeometryChanges {
    readonly elements: Iterable<ElementGeometryChange>;
    readonly geometryGuid: GuidString;
    readonly id: Id64String;
    readonly range: Range3d;
}

// @alpha
export namespace ModelGeometryChanges {
    export function findByModelId(changes: Iterable<ModelGeometryChanges>, modelId: Id64String): ModelGeometryChanges | undefined;
    export function fromJSON(props: ModelGeometryChangesProps): ModelGeometryChanges;
    export function iterable(modelChanges: ModelGeometryChangesProps[]): Iterable<ModelGeometryChanges>;
    export function iterator(modelChanges: ModelGeometryChangesProps[]): Iterator<ModelGeometryChanges>;
}

// @alpha
export interface ModelGeometryChangesProps {
    readonly deleted?: CompressedId64Set;
    readonly guid: GuidString;
    readonly id: Id64String;
    readonly inserted?: ElementIdsAndRangesProps;
    readonly range: Range3dProps;
    readonly updated?: ElementIdsAndRangesProps;
}

// @public
export interface ModelLoadProps {
    // (undocumented)
    code?: CodeProps;
    // (undocumented)
    id?: Id64String;
}

// @public
export interface ModelProps extends EntityProps {
    // (undocumented)
    isPrivate?: boolean;
    // (undocumented)
    isTemplate?: boolean;
    // (undocumented)
    jsonProperties?: any;
    // (undocumented)
    modeledElement: RelatedElementProps;
    // (undocumented)
    name?: string;
    // (undocumented)
    parentModel?: Id64String;
}

// @public
export interface ModelQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
    // (undocumented)
    wantTemplate?: boolean;
}

// @public
export interface ModelSelectorProps extends DefinitionElementProps {
    // (undocumented)
    models: Id64Array;
}

// @public
export enum MonochromeMode {
    Flat = 0,
    Scaled = 1
}

// @internal
export abstract class NativeAppRpcInterface extends RpcInterface {
    authGetAccessToken(): Promise<string>;
    authInitialize(_issuer: string, _config: any): Promise<void>;
    authSignIn(): Promise<void>;
    authSignOut(): Promise<void>;
    cancelElementGraphicsRequests(_rpcProps: IModelRpcProps, _requestIds: string[]): Promise<void>;
    cancelTileContentRequests(_iModelToken: IModelRpcProps, _contentIds: TileTreeContentIds[]): Promise<void>;
    checkInternetConnectivity(): Promise<InternetConnectivityStatus>;
    closeBriefcase(_key: BriefcaseKey): Promise<void>;
    deleteBriefcase(_key: BriefcaseKey): Promise<void>;
    downloadRequestCompleted(_key: BriefcaseKey): Promise<void>;
    getBriefcases(): Promise<BriefcaseProps[]>;
    static getClient(): NativeAppRpcInterface;
    getConfig(): Promise<any>;
    static readonly interfaceName = "NativeAppRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    isInteractiveEditingSupported(_tokenProps: IModelRpcProps): Promise<boolean>;
    log(_timestamp: number, _level: LogLevel, _category: string, _message: string, _metaData?: any): Promise<void>;
    openBriefcase(_key: BriefcaseKey, _openOptions?: OpenBriefcaseOptions): Promise<IModelConnectionProps>;
    overrideInternetConnectivity(_overriddenBy: OverriddenBy, _status?: InternetConnectivityStatus): Promise<void>;
    requestCancelDownloadBriefcase(_key: BriefcaseKey): Promise<boolean>;
    requestDownloadBriefcase(_requestProps: RequestBriefcaseProps, _downloadOptions: DownloadBriefcaseOptions, _reportProgress: boolean): Promise<BriefcaseProps>;
    storageGet(_storageId: string, _key: string): Promise<StorageValue | undefined>;
    storageKeys(_storageId: string): Promise<string[]>;
    storageMgrClose(_storageId: string, _deleteIt: boolean): Promise<void>;
    storageMgrNames(): Promise<string[]>;
    storageMgrOpen(_storageId: string): Promise<string>;
    storageRemove(_storageId: string, _key: string): Promise<void>;
    storageRemoveAll(_storageId: string): Promise<void>;
    storageSet(_storageId: string, _key: string, _value: StorageValue): Promise<void>;
    // (undocumented)
    toggleInteractiveEditingSession(_tokenProps: IModelRpcProps, _startSession: boolean): Promise<boolean>;
}

// @public
export interface NavigationBindingValue {
    id: Id64String;
    relClassName?: string;
    relClassTableSpace?: string;
}

// @public
export interface NavigationValue {
    id: Id64String;
    relClassName?: string;
}

// @public
export function nextHighestPowerOfTwo(num: number): number;

// @internal
export function nextPoint3d64FromByteStream(stream: ByteStream, result?: Point3d): Point3d;

// @public
export class NoContentError extends IModelError {
    constructor();
}

// @internal (undocumented)
export class NonUniformColor {
    constructor(colors: Uint32Array, indices: number[], hasAlpha: boolean);
    // (undocumented)
    readonly colors: Uint32Array;
    // (undocumented)
    readonly indices: Uint16Array;
    // (undocumented)
    readonly isOpaque: boolean;
}

// @public
export enum Npc {
    _000 = 0,
    _001 = 4,
    _010 = 2,
    _011 = 6,
    _100 = 1,
    _101 = 5,
    _110 = 3,
    _111 = 7,
    CORNER_COUNT = 8,
    // (undocumented)
    LeftBottomFront = 4,
    // (undocumented)
    LeftBottomRear = 0,
    // (undocumented)
    LeftTopFront = 6,
    // (undocumented)
    LeftTopRear = 2,
    // (undocumented)
    RightBottomFront = 5,
    // (undocumented)
    RightBottomRear = 1,
    // (undocumented)
    RightTopFront = 7,
    // (undocumented)
    RightTopRear = 3
}

// @public
export const NpcCenter: Point3d;

// @public
export const NpcCorners: Point3d[];

// @internal (undocumented)
export class OctEncodedNormal {
    constructor(val: number);
    // (undocumented)
    decode(): Vector3d | undefined;
    // (undocumented)
    static decodeValue(val: number, result?: Vector3d): Vector3d;
    // (undocumented)
    static encode(vec: XYAndZ): number;
    // (undocumented)
    static fromVector(val: XYAndZ): OctEncodedNormal;
    // (undocumented)
    readonly value: number;
}

// @internal (undocumented)
export class OctEncodedNormalPair {
    constructor(first: OctEncodedNormal, second: OctEncodedNormal);
    // (undocumented)
    first: OctEncodedNormal;
    // (undocumented)
    second: OctEncodedNormal;
}

// @internal
export interface OpenAPIContentMap {
    // (undocumented)
    [index: string]: OpenAPIMediaType;
}

// @internal
export interface OpenAPIDocument {
    // (undocumented)
    info: OpenAPIInfo;
    // (undocumented)
    openapi: "3.0.0";
    // (undocumented)
    paths: OpenAPIPaths;
}

// @internal
export interface OpenAPIEncoding {
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    style?: string;
}

// @public
export interface OpenAPIInfo {
    // (undocumented)
    title: string;
    // (undocumented)
    version: string;
}

// @internal
export interface OpenAPIMediaType {
    // (undocumented)
    schema?: OpenAPISchema;
}

// @internal
export interface OpenAPIOperation {
    // (undocumented)
    operationId?: string;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    requestBody?: OpenAPIRequestBody;
    // (undocumented)
    responses: OpenAPIResponses;
    // (undocumented)
    summary?: string;
}

// @internal
export interface OpenAPIParameter {
    // (undocumented)
    allowEmptyValue?: boolean;
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    content?: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    in: "query" | "header" | "path" | "cookie";
    // (undocumented)
    name: string;
    // (undocumented)
    required?: boolean;
    // (undocumented)
    schema?: OpenAPISchema;
    // (undocumented)
    style?: "matrix" | "label" | "form" | "simple" | "spaceDelimited" | "pipeDelimited" | "deepObject";
}

// @internal
export interface OpenAPIPathItem {
    // (undocumented)
    delete?: OpenAPIOperation;
    // (undocumented)
    get?: OpenAPIOperation;
    // (undocumented)
    head?: OpenAPIOperation;
    // (undocumented)
    options?: OpenAPIOperation;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    patch?: OpenAPIOperation;
    // (undocumented)
    post?: OpenAPIOperation;
    // (undocumented)
    put?: OpenAPIOperation;
    // (undocumented)
    summary?: string;
    // (undocumented)
    trace?: OpenAPIOperation;
}

// @internal
export interface OpenAPIPaths {
    // (undocumented)
    [index: string]: OpenAPIPathItem;
}

// @internal
export interface OpenAPIRequestBody {
    // (undocumented)
    content: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    required?: boolean;
}

// @internal
export interface OpenAPIResponse {
    // (undocumented)
    content?: {
        [index: string]: OpenAPIMediaType;
    };
    // (undocumented)
    description: string;
}

// @internal
export interface OpenAPIResponses {
    // (undocumented)
    "200"?: OpenAPIResponse;
    // (undocumented)
    "301"?: OpenAPIResponse;
    // (undocumented)
    "302"?: OpenAPIResponse;
    // (undocumented)
    "400"?: OpenAPIResponse;
    // (undocumented)
    "404"?: OpenAPIResponse;
    // (undocumented)
    "500"?: OpenAPIResponse;
    // (undocumented)
    default?: OpenAPIResponse;
}

// @internal
export interface OpenAPISchema {
    // (undocumented)
    description?: string;
    // (undocumented)
    nullable?: boolean;
    // (undocumented)
    type?: "boolean" | "object" | "array" | "number" | "string";
}

// @beta
export interface OpenBriefcaseOptions {
    openAsReadOnly?: boolean;
}

// @internal (undocumented)
export const OPERATION: unique symbol;

// @alpha
export interface OrbitGtBlobProps {
    // (undocumented)
    accountName: string;
    // (undocumented)
    blobFileName: string;
    // (undocumented)
    containerName: string;
    // (undocumented)
    sasToken: string;
}

// @internal
export enum OverriddenBy {
    // (undocumented)
    Browser = 0,
    // (undocumented)
    User = 1
}

// @internal (undocumented)
export interface PackedFeature {
    // (undocumented)
    animationNodeId: number;
    // (undocumented)
    elementId: Id64.Uint32Pair;
    // (undocumented)
    geometryClass: GeometryClass;
    // (undocumented)
    subCategoryId: Id64.Uint32Pair;
}

// @internal
export class PackedFeatureTable {
    constructor(data: Uint32Array, modelId: Id64String, numFeatures: number, maxFeatures: number, type: BatchType, animationNodeIds?: Uint8Array | Uint16Array | Uint32Array);
    // (undocumented)
    readonly anyDefined: boolean;
    // (undocumented)
    get byteLength(): number;
    findElementId(featureIndex: number): Id64String | undefined;
    findFeature(featureIndex: number): Feature | undefined;
    // (undocumented)
    getAnimationNodeId(featureIndex: number): number;
    // (undocumented)
    getElementIdPair(featureIndex: number): Id64.Uint32Pair;
    getFeature(featureIndex: number): Feature;
    // (undocumented)
    getPackedFeature(featureIndex: number): PackedFeature;
    // (undocumented)
    getSubCategoryIdPair(featureIndex: number): Id64.Uint32Pair;
    // (undocumented)
    get isClassifier(): boolean;
    // (undocumented)
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    // (undocumented)
    get isVolumeClassifier(): boolean;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly numFeatures: number;
    static pack(featureTable: FeatureTable): PackedFeatureTable;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
    unpack(): FeatureTable;
}

// @public
export interface PartReference {
    // (undocumented)
    part: {
        id: Id64String;
        readonly toLocal?: Transform;
    };
    // (undocumented)
    type: "partReference";
}

// @public
export interface PhysicalElementProps extends GeometricElement3dProps {
    // (undocumented)
    physicalMaterial?: RelatedElementProps;
}

// @public
export interface PhysicalTypeProps extends TypeDefinitionElementProps {
    physicalMaterial?: RelatedElementProps;
}

// @public
export class Placement2d implements Placement2dProps {
    constructor(origin: Point2d, angle: Angle, bbox: ElementAlignedBox2d);
    // (undocumented)
    angle: Angle;
    // (undocumented)
    bbox: ElementAlignedBox2d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement2dProps): Placement2d;
    getWorldCorners(out?: Frustum): Frustum;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point2d;
    get rotation(): Matrix3d;
    setFrom(other: Placement2d): void;
    get transform(): Transform;
}

// @public
export interface Placement2dProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    bbox?: LowAndHighXY;
    // (undocumented)
    origin: XYProps;
}

// @public
export class Placement3d implements Placement3dProps {
    constructor(origin: Point3d, angles: YawPitchRollAngles, bbox: ElementAlignedBox3d);
    // (undocumented)
    angles: YawPitchRollAngles;
    // (undocumented)
    bbox: ElementAlignedBox3d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement3dProps): Placement3d;
    getWorldCorners(out?: Frustum): Frustum;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point3d;
    get rotation(): Matrix3d;
    setFrom(other: Placement3d): void;
    get transform(): Transform;
}

// @public
export interface Placement3dProps {
    // (undocumented)
    angles: YawPitchRollProps;
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // (undocumented)
    origin: XYZProps;
}

// @public (undocumented)
export type PlacementProps = Placement2dProps | Placement3dProps;

// @beta
export class PlanProjectionSettings {
    constructor(props: PlanProjectionSettingsProps);
    clone(changedProps?: PlanProjectionSettingsProps): PlanProjectionSettings;
    readonly elevation?: number;
    readonly enforceDisplayPriority?: boolean;
    // (undocumented)
    static fromJSON(props: PlanProjectionSettingsProps | undefined): PlanProjectionSettings | undefined;
    readonly overlay: boolean;
    // (undocumented)
    toJSON(): PlanProjectionSettingsProps;
    readonly transparency?: number;
}

// @beta
export interface PlanProjectionSettingsProps {
    elevation?: number;
    enforceDisplayPriority?: boolean;
    overlay?: boolean;
    transparency?: number;
}

// @internal
export class PntsHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @beta
export interface PointWithStatus {
    // (undocumented)
    p: XYZProps;
    // (undocumented)
    s: GeoCoordStatus;
}

// @internal (undocumented)
export const POLICY: unique symbol;

// @internal (undocumented)
export class PolylineData {
    constructor(vertIndices?: number[], numIndices?: number);
    // (undocumented)
    init(polyline: MeshPolyline): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    numIndices: number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    vertIndices: number[];
}

// @internal (undocumented)
export class PolylineEdgeArgs {
    constructor(lines?: PolylineData[]);
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(lines?: PolylineData[]): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    lines?: PolylineData[];
    // (undocumented)
    get numLines(): number;
}

// @internal
export class PolylineFlags {
    constructor(is2d?: boolean, isPlanar?: boolean, isDisjoint?: boolean, type?: PolylineTypeFlags);
    // (undocumented)
    clone(): PolylineFlags;
    // (undocumented)
    equals(other: PolylineFlags): boolean;
    // (undocumented)
    initDefaults(): void;
    // (undocumented)
    is2d: boolean;
    // (undocumented)
    get isAnyEdge(): boolean;
    // (undocumented)
    isDisjoint: boolean;
    // (undocumented)
    get isNormalEdge(): boolean;
    // (undocumented)
    get isOutlineEdge(): boolean;
    // (undocumented)
    isPlanar: boolean;
    pack(): number;
    // (undocumented)
    setIsNormalEdge(): void;
    // (undocumented)
    setIsOutlineEdge(): void;
    // (undocumented)
    type: PolylineTypeFlags;
    static unpack(value: number): PolylineFlags;
}

// @internal (undocumented)
export enum PolylineTypeFlags {
    // (undocumented)
    Edge = 1,
    // (undocumented)
    Normal = 0,
    // (undocumented)
    Outline = 2
}

// @internal
export interface PrimaryTileTreeId {
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    animationTransformNodeId?: number;
    // (undocumented)
    edgesRequired: boolean;
    // (undocumented)
    enforceDisplayPriority?: boolean;
    // (undocumented)
    type: BatchType.Primary;
}

// @beta
export enum PrimitiveTypeCode {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta
export enum ProfileOptions {
    None = 0,
    Upgrade = 1
}

// @beta
export type PropertyCallback = (name: string, meta: PropertyMetaData) => void;

// @beta
export class PropertyMetaData implements PropertyMetaDataProps {
    constructor(jsonObj: PropertyMetaDataProps);
    createProperty(jsonObj: any): any;
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    get isNavigation(): boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: PrimitiveTypeCode;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @beta (undocumented)
export interface PropertyMetaDataProps {
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: number;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @internal
export class QParams2d {
    // (undocumented)
    clone(out?: QParams2d): QParams2d;
    // (undocumented)
    copyFrom(src: QParams2d): void;
    static fromNormalizedRange(rangeScale?: number): QParams2d;
    static fromRange(range: Range2d, out?: QParams2d, rangeScale?: number): QParams2d;
    static fromZeroToOne(rangeScale?: number): QParams2d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    get rangeDiagonal(): Vector2d;
    // (undocumented)
    readonly scale: Point2d;
    setFromRange(range: Range2d, rangeScale?: number): void;
}

// @internal
export class QParams3d {
    // (undocumented)
    clone(out?: QParams3d): QParams3d;
    // (undocumented)
    copyFrom(src: QParams3d): void;
    static fromNormalizedRange(rangeScale?: number): QParams3d;
    static fromOriginAndScale(origin: Point3d, scale: Point3d, out?: QParams3d): QParams3d;
    static fromRange(range: Range3d, out?: QParams3d, rangeScale?: number): QParams3d;
    static fromZeroToOne(rangeScale?: number): QParams3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    get rangeDiagonal(): Vector3d;
    // (undocumented)
    readonly scale: Point3d;
    setFromOriginAndScale(origin: Point3d, scale: Point3d): void;
    setFromRange(range: Range3d, rangeScale?: number): void;
}

// @internal
export class QPoint2d {
    constructor();
    // (undocumented)
    clone(out?: QPoint2d): QPoint2d;
    // (undocumented)
    copyFrom(src: QPoint2d): void;
    static create(pos: Point2d, params: QParams2d): QPoint2d;
    static fromScalars(x: number, y: number): QPoint2d;
    init(pos: Point2d, params: QParams2d): void;
    setFromScalars(x: number, y: number): void;
    unquantize(params: QParams2d, out?: Point2d): Point2d;
    // (undocumented)
    get x(): number;
    set x(x: number);
    // (undocumented)
    get y(): number;
    set y(y: number);
    }

// @internal
export class QPoint2dList {
    constructor(params: QParams2d);
    add(pt: Point2d): void;
    clear(): void;
    static fromPoints(points: Point2d[], out?: QPoint2dList): QPoint2dList;
    fromTypedArray(range: Range2d, array: Uint16Array): void;
    get length(): number;
    // (undocumented)
    get list(): QPoint2d[];
    // (undocumented)
    readonly params: QParams2d;
    push(qpt: QPoint2d): void;
    requantize(params: QParams2d): void;
    reset(params: QParams2d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point2d): Point2d;
}

// @internal
export class QPoint3d {
    // (undocumented)
    clone(out?: QPoint3d): QPoint3d;
    // (undocumented)
    compare(rhs: QPoint3d): number;
    // (undocumented)
    copyFrom(src: QPoint3d): void;
    static create(pos: Point3d, params: QParams3d): QPoint3d;
    // (undocumented)
    equals(other: QPoint3d): boolean;
    static fromScalars(x: number, y: number, z: number, out?: QPoint3d): QPoint3d;
    init(pos: Point3d, params: QParams3d): void;
    setFromScalars(x: number, y: number, z: number): void;
    unquantize(params: QParams3d, out?: Point3d): Point3d;
    // (undocumented)
    get x(): number;
    set x(x: number);
    // (undocumented)
    get y(): number;
    set y(y: number);
    // (undocumented)
    get z(): number;
    set z(z: number);
    }

// @internal
export class QPoint3dList {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<QPoint3d>;
    constructor(paramsIn?: QParams3d);
    add(pt: Point3d): void;
    clear(): void;
    // (undocumented)
    static createFrom(points: Point3d[], params: QParams3d): QPoint3dList;
    static fromPoints(points: Point3d[], out?: QPoint3dList): QPoint3dList;
    // (undocumented)
    fromTypedArray(range: Range3d, array: Uint16Array): void;
    get length(): number;
    // (undocumented)
    get list(): QPoint3d[];
    // (undocumented)
    readonly params: QParams3d;
    push(qpt: QPoint3d): void;
    requantize(params: QParams3d): void;
    reset(params: QParams3d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point3d): Point3d;
}

// @internal
export namespace Quantization {
    const // (undocumented)
    rangeScale16 = 65535;
    const // (undocumented)
    rangeScale8 = 255;
    // (undocumented)
    export function computeScale(extent: number, rangeScale?: number): number;
    // (undocumented)
    export function isInRange(qpos: number, rangeScale?: number): boolean;
    // (undocumented)
    export function isQuantizable(pos: number, origin: number, scale: number, rangeScale?: number): boolean;
    // (undocumented)
    export function isQuantized(qpos: number): boolean;
    // (undocumented)
    export function quantize(pos: number, origin: number, scale: number, rangeScale?: number): number;
    // (undocumented)
    export function unquantize(qpos: number, origin: number, scale: number): number;
}

// @public
export interface QueryLimit {
    maxRowAllowed?: number;
    startRowOffset?: number;
}

// @public
export enum QueryPriority {
    // (undocumented)
    High = 2,
    // (undocumented)
    Low = 0,
    // (undocumented)
    Normal = 1
}

// @public
export interface QueryQuota {
    maxMemoryAllowed?: number;
    maxTimeAllowed?: number;
}

// @public
export interface QueryResponse {
    // (undocumented)
    rows: any[];
    // (undocumented)
    status: QueryResponseStatus;
}

// @public
export enum QueryResponseStatus {
    // (undocumented)
    Cancelled = 7,
    // (undocumented)
    Done = 2,
    // (undocumented)
    Error = 5,
    // (undocumented)
    Partial = 3,
    // (undocumented)
    PostError = 6,
    // (undocumented)
    Timeout = 4
}

// @internal
export interface QueuedEvent {
    data: any;
    eventId: number;
    eventName: string;
    namespace: string;
}

// @public
export enum Rank {
    Application = 2,
    Domain = 1,
    System = 0,
    User = 3
}

// @internal (undocumented)
export interface ReadableFormData extends Readable {
    // (undocumented)
    getHeaders(): {
        [key: string]: any;
    };
}

// @internal
export function readTileContentDescription(stream: ByteStream, sizeMultiplier: number | undefined, is2d: boolean, options: TileOptions, isVolumeClassifier: boolean): TileContentDescription;

// @internal (undocumented)
export const REGISTRY: unique symbol;

// @public
export class RelatedElement implements RelatedElementProps {
    constructor(props: RelatedElementProps);
    // (undocumented)
    static fromJSON(json?: RelatedElementProps): RelatedElement | undefined;
    readonly id: Id64String;
    static idFromJson(json: any): Id64String;
    static readonly none: RelatedElement;
    readonly relClassName?: string;
    // (undocumented)
    toJSON(): RelatedElementProps;
}

// @public
export interface RelatedElementProps {
    id: Id64String;
    relClassName?: string;
}

// @public
export interface RelationshipProps extends EntityProps, SourceAndTarget {
}

// @beta
export abstract class RenderMaterial {
    protected constructor(params: RenderMaterial.Params);
    // (undocumented)
    get hasTexture(): boolean;
    readonly key?: string;
    readonly textureMapping?: TextureMapping;
}

// @beta
export namespace RenderMaterial {
    export class Params {
        constructor(key?: string);
        get alpha(): number | undefined;
        set alpha(alpha: number | undefined);
        ambient: number;
        static readonly defaults: Params;
        diffuse: number;
        diffuseColor?: ColorDef;
        emissiveColor?: ColorDef;
        static fromColors(key?: string, diffuseColor?: ColorDef, specularColor?: ColorDef, emissiveColor?: ColorDef, reflectColor?: ColorDef, textureMap?: TextureMapping): Params;
        key?: string;
        reflect: number;
        reflectColor?: ColorDef;
        refract: number;
        shadows: boolean;
        specular: number;
        specularColor?: ColorDef;
        // (undocumented)
        specularExponent: number;
        textureMapping?: TextureMapping;
    }
}

// @beta
export interface RenderMaterialProps extends DefinitionElementProps {
    description?: string;
    // (undocumented)
    jsonProperties?: {
        materialAssets?: {
            renderMaterial?: {
                HasBaseColor?: boolean;
                color?: RgbFactorProps;
                HasSpecularColor?: boolean;
                specular_color?: RgbFactorProps;
                HasFinish?: boolean;
                finish?: number;
                HasTransmit?: boolean;
                transmit?: number;
                HasDiffuse?: boolean;
                diffuse?: number;
                HasSpecular?: boolean;
                specular?: number;
                HasReflect?: boolean;
                reflect?: number;
                HasReflectColor?: boolean;
                reflect_color?: RgbFactorProps;
                Map?: {
                    Pattern?: TextureMapProps;
                };
            };
        };
    };
    paletteName: string;
}

// @public
export enum RenderMode {
    HiddenLine = 3,
    SmoothShade = 6,
    SolidFill = 4,
    Wireframe = 0
}

// @beta
export namespace RenderSchedule {
    export interface ColorEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: {
            red: number;
            green: number;
            blue: number;
        };
    }
    export interface CuttingPlaneEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: CuttingPlaneProps;
    }
    export interface CuttingPlaneProps {
        direction: number[];
        hidden?: boolean;
        position: number[];
        visible?: boolean;
    }
    export interface ElementTimelineProps extends TimelineProps {
        // (undocumented)
        batchId: number;
        elementIds: Id64String[] | CompressedId64Set;
    }
    export interface ModelTimelineProps extends TimelineProps {
        // (undocumented)
        elementTimelines: ElementTimelineProps[];
        // (undocumented)
        modelId: Id64String;
        // (undocumented)
        realityModelUrl?: string;
    }
    export interface TimelineEntryProps {
        interpolation: number;
        time: number;
    }
    export interface TimelineProps {
        // (undocumented)
        colorTimeline?: ColorEntryProps[];
        // (undocumented)
        cuttingPlaneTimeline?: CuttingPlaneEntryProps[];
        // (undocumented)
        transformTimeline?: TransformEntryProps[];
        // (undocumented)
        visibilityTimeline?: VisibilityEntryProps[];
    }
    export interface TransformEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: TransformProps;
    }
    export interface TransformProps {
        orientation: number[];
        pivot: number[];
        position: number[];
        transform: number[][];
    }
    export interface VisibilityEntryProps extends TimelineEntryProps {
        // (undocumented)
        value: number;
    }
}

// @beta
export abstract class RenderTexture implements IDisposable {
    protected constructor(params: RenderTexture.Params);
    // (undocumented)
    abstract get bytesUsed(): number;
    abstract dispose(): void;
    // (undocumented)
    get isGlyph(): boolean;
    readonly isOwned: boolean;
    // (undocumented)
    get isSkyBox(): boolean;
    // (undocumented)
    get isTileSection(): boolean;
    readonly key: string | undefined;
    readonly type: RenderTexture.Type;
}

// @beta
export namespace RenderTexture {
    export class Params {
        constructor(key?: string, type?: Type, isOwned?: boolean);
        static readonly defaults: Params;
        // (undocumented)
        get isGlyph(): boolean;
        readonly isOwned: boolean;
        // (undocumented)
        get isSkyBox(): boolean;
        // (undocumented)
        get isTileSection(): boolean;
        readonly key?: string;
        readonly type: Type;
    }
    export enum Type {
        FilteredTileSection = 4,
        Glyph = 1,
        Normal = 0,
        SkyBox = 3,
        ThematicGradient = 5,
        TileSection = 2
    }
}

// @public
export interface RepositoryLinkProps extends UrlLinkProps {
    // (undocumented)
    repositoryGuid?: GuidString;
}

export { RepositoryStatus }

// @internal
export interface RequestBriefcaseProps {
    readonly changeSetId: GuidString;
    readonly contextId: GuidString;
    readonly iModelId: GuidString;
}

// @public (undocumented)
export class ResponseLike implements Response {
    constructor(data: any);
    // (undocumented)
    arrayBuffer(): Promise<ArrayBuffer>;
    // (undocumented)
    blob(): Promise<Blob>;
    // (undocumented)
    get body(): null;
    // (undocumented)
    get bodyUsed(): boolean;
    // (undocumented)
    clone(): this;
    // (undocumented)
    formData(): Promise<FormData>;
    // (undocumented)
    get headers(): Headers;
    // (undocumented)
    json(): Promise<any>;
    // (undocumented)
    get ok(): boolean;
    // (undocumented)
    get redirected(): boolean;
    // (undocumented)
    get status(): number;
    // (undocumented)
    get statusText(): string;
    // (undocumented)
    text(): Promise<string>;
    // (undocumented)
    get trailer(): Promise<Headers>;
    // (undocumented)
    get type(): ResponseType;
    // (undocumented)
    get url(): string;
}

// @public
export class RgbColor {
    constructor(r: number, g: number, b: number);
    // (undocumented)
    readonly b: number;
    // (undocumented)
    equals(rhs: RgbColor): boolean;
    static fromColorDef(colorDef: ColorDef): RgbColor;
    // (undocumented)
    static fromJSON(json: RgbColorProps | undefined): RgbColor;
    // (undocumented)
    readonly g: number;
    // (undocumented)
    readonly r: number;
    toColorDef(transparency?: number): ColorDef;
    // (undocumented)
    toJSON(): RgbColorProps;
}

// @public
export interface RgbColorProps {
    // (undocumented)
    b: number;
    // (undocumented)
    g: number;
    // (undocumented)
    r: number;
}

// @beta
export type RgbFactorProps = number[];

// @public
export interface RootSubjectProps {
    description?: string;
    name: string;
}

// @public
export abstract class RpcConfiguration {
    // @alpha (undocumented)
    allowAttachedInterfaces: boolean;
    static assign<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, supplier: RpcConfigurationSupplier): void;
    static assignWithRouting<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing: RpcRoutingToken, configuration: new () => RpcConfiguration): void;
    // @alpha (undocumented)
    attach<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // @internal (undocumented)
    attached: RpcInterfaceDefinition[];
    // @alpha (undocumented)
    get attachedInterfaces(): ReadonlyArray<RpcInterfaceDefinition>;
    // @internal
    readonly controlChannel: RpcControlChannel;
    static developmentMode: boolean;
    static disableRoutingValidation: boolean;
    static initializeInterfaces(configuration: RpcConfiguration): void;
    abstract readonly interfaces: () => RpcInterfaceDefinition[];
    static obtain<T extends RpcConfiguration>(configurationConstructor: new () => T): T;
    // @internal (undocumented)
    onRpcClientInitialized(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    pendingOperationRetryInterval: number;
    abstract readonly protocol: RpcProtocol;
    static requestContext: RpcRequestContext;
    // @alpha (undocumented)
    readonly routing: RpcRoutingToken;
    static strictMode: boolean;
    // @internal (undocumented)
    static supply(definition: RpcInterface): RpcConfiguration;
    static throwOnTokenMismatch: boolean;
}

// @public (undocumented)
export type RpcConfigurationSupplier = (routing?: RpcRoutingToken) => {
    new (): RpcConfiguration;
};

// @public
export enum RpcContentType {
    // (undocumented)
    Binary = 2,
    // (undocumented)
    Multipart = 3,
    // (undocumented)
    Stream = 4,
    // (undocumented)
    Text = 1,
    // (undocumented)
    Unknown = 0
}

// @internal
export class RpcControlChannel {
    // (undocumented)
    static channels: RpcControlChannel[];
    // (undocumented)
    describeEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    handleUnknownOperation(invocation: RpcInvocation, _error: any): boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    static obtain(configuration: RpcConfiguration): RpcControlChannel;
    }

// @public
export abstract class RpcControlResponse {
}

// @internal
export class RpcDefaultConfiguration extends RpcConfiguration {
    // (undocumented)
    interfaces: () => never[];
    // (undocumented)
    protocol: RpcProtocol;
}

// @internal
export class RpcDirectProtocol extends RpcProtocol {
    // (undocumented)
    readonly requestType: typeof RpcDirectRequest;
}

// @internal
export class RpcDirectRequest extends RpcRequest {
    // (undocumented)
    fulfillment: RpcRequestFulfillment | undefined;
    // (undocumented)
    headers: Map<string, string>;
    // (undocumented)
    protected load(): Promise<import("./RpcMarshaling").RpcSerializedValue>;
    // (undocumented)
    protected send(): Promise<number>;
    // (undocumented)
    protected setHeader(name: string, value: string): void;
}

// @public
export enum RpcEndpoint {
    // (undocumented)
    Backend = 1,
    // (undocumented)
    Frontend = 0
}

// @public
export abstract class RpcInterface {
    // @alpha
    constructor(routing?: RpcRoutingToken);
    readonly configuration: RpcConfiguration;
    // @internal (undocumented)
    configurationSupplier: RpcConfigurationSupplier | undefined;
    forward<T = any>(parameters: IArguments): Promise<T>;
    static isVersionCompatible(backend: string, frontend: string): boolean;
    // @alpha (undocumented)
    readonly routing: RpcRoutingToken;
}

// @public (undocumented)
export interface RpcInterfaceDefinition<T extends RpcInterface = RpcInterface> {
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    prototype: T;
}

// @public
export interface RpcInterfaceEndpoints {
    // (undocumented)
    compatible: boolean;
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationNames: string[];
}

// @public (undocumented)
export type RpcInterfaceImplementation<T extends RpcInterface = RpcInterface> = new () => T;

export { RpcInterfaceStatus }

// @public
export class RpcInvocation {
    constructor(protocol: RpcProtocol, request: SerializedRpcRequest);
    static current(rpcImpl: RpcInterface): RpcInvocation;
    get elapsed(): number;
    readonly fulfillment: Promise<RpcRequestFulfillment>;
    readonly operation: RpcOperation;
    readonly protocol: RpcProtocol;
    readonly request: SerializedRpcRequest;
    readonly result: Promise<any>;
    get status(): RpcRequestStatus;
    }

// @public
export type RpcInvocationCallback_T = (invocation: RpcInvocation) => void;

// @public
export class RpcManager {
    static describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    static getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing?: RpcRoutingToken): T;
    static initializeInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    static setIModel(props: IModelRpcProps): void;
    static supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    static terminateInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @internal (undocumented)
export class RpcMarshaling {
    static deserialize(protocol: RpcProtocol | undefined, value: RpcSerializedValue): any;
    static serialize(protocol: RpcProtocol | undefined, value: any): Promise<RpcSerializedValue>;
}

// @beta
export enum RpcMobilePlatform {
    // (undocumented)
    Android = 1,
    // (undocumented)
    iOS = 2,
    // (undocumented)
    Unknown = 0
}

// @internal
export class RpcMultipart {
    static createForm(value: RpcSerializedValue): FormData;
    static createStream(_value: RpcSerializedValue): ReadableFormData;
    static parseRequest(_req: HttpServerRequest): Promise<RpcSerializedValue>;
    // (undocumented)
    static writeValueToForm(form: FormDataCommon, value: RpcSerializedValue): void;
}

// @public
export class RpcNotFoundResponse extends RpcControlResponse {
}

// @internal
export class RpcOpenAPIDescription {
    constructor(protocol: WebAppRpcProtocol);
    get document(): OpenAPIDocument;
    get paths(): OpenAPIPaths;
    readonly protocol: WebAppRpcProtocol;
    toJSON(): OpenAPIDocument;
}

// @public
export class RpcOperation {
    // @internal
    constructor(definition: RpcInterfaceDefinition, operation: string, policy: RpcOperationPolicy);
    // @internal (undocumented)
    static computeOperationName(identifier: string): string;
    static fallbackToken: IModelRpcProps | undefined;
    static forEach(definition: RpcInterfaceDefinition, callback: (operation: RpcOperation) => void): void;
    readonly interfaceDefinition: RpcInterfaceDefinition;
    get interfaceVersion(): string;
    static lookup(target: string | RpcInterfaceDefinition, operationName: string): RpcOperation;
    readonly operationName: string;
    policy: RpcOperationPolicy;
}

// @public (undocumented)
export namespace RpcOperation {
    export function allowResponseCaching(control?: RpcResponseCacheControl): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
    export function setDefaultPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(definition: RpcInterfaceDefinition<T>) => void;
    export function setPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
    export function setRoutingProps(handler: RpcRequestTokenSupplier_T): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
}

// @public
export class RpcOperationPolicy {
    allowResponseCaching: RpcResponseCachingCallback_T;
    allowTokenMismatch: boolean;
    forceStrictMode: boolean;
    invocationCallback: RpcInvocationCallback_T;
    requestCallback: RpcRequestCallback_T;
    retryInterval: RpcRequestInitialRetryIntervalSupplier_T;
    sentCallback: RpcRequestCallback_T;
    token: RpcRequestTokenSupplier_T;
}

// @public (undocumented)
export type RpcOperationPolicyProps = Partial<RpcOperationPolicy>;

// @public
export interface RpcOperationsProfile {
    // (undocumented)
    readonly lastRequest: number;
    // (undocumented)
    readonly lastResponse: number;
}

// @internal
export class RpcPendingQueue {
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static instance: RpcPendingQueue;
    }

// @public
export class RpcPendingResponse extends RpcControlResponse {
    constructor(message?: string);
    message: string;
}

// @public
export abstract class RpcProtocol {
    constructor(configuration: RpcConfiguration);
    checkToken: boolean;
    readonly configuration: RpcConfiguration;
    static readonly events: BeEvent<RpcProtocolEventHandler>;
    readonly events: BeEvent<RpcProtocolEventHandler>;
    fulfill(request: SerializedRpcRequest): Promise<RpcRequestFulfillment>;
    getCode(status: RpcRequestStatus): number;
    getOperationFromPath(path: string): SerializedRpcOperation;
    getStatus(code: number): RpcRequestStatus;
    inflateToken(tokenFromBody: IModelRpcProps, _request: SerializedRpcRequest): IModelRpcProps;
    readonly invocationType: typeof RpcInvocation;
    // @internal (undocumented)
    onRpcClientInitialized(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcClientTerminated(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplInitialized(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // @internal (undocumented)
    onRpcImplTerminated(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    preserveStreams: boolean;
    static readonly protocolVersion = 1;
    protocolVersionHeaderName: string;
    abstract readonly requestType: typeof RpcRequest;
    serialize(request: RpcRequest): Promise<SerializedRpcRequest>;
    // (undocumented)
    serializedClientRequestContextHeaderNames: SerializedClientRequestContext;
    supplyPathForOperation(operation: RpcOperation, _request: RpcRequest | undefined): string;
    transferChunkThreshold: number;
}

// @public
export enum RpcProtocolEvent {
    // (undocumented)
    BackendErrorOccurred = 11,
    // (undocumented)
    BackendErrorReceived = 5,
    // (undocumented)
    BackendReportedNoContent = 12,
    // (undocumented)
    BackendReportedNotFound = 10,
    // (undocumented)
    BackendReportedPending = 9,
    // (undocumented)
    BackendResponseCreated = 8,
    // (undocumented)
    ConnectionAborted = 6,
    // (undocumented)
    ConnectionErrorReceived = 3,
    // (undocumented)
    RequestCreated = 0,
    // (undocumented)
    RequestReceived = 7,
    // (undocumented)
    ResponseLoaded = 1,
    // (undocumented)
    ResponseLoading = 2,
    // (undocumented)
    UnknownErrorReceived = 4
}

// @public
export type RpcProtocolEventHandler = (type: RpcProtocolEvent, object: RpcRequest | RpcInvocation) => void;

// @alpha
export class RpcPushChannel<T> {
    static create<T>(name: string, service?: RpcPushService): RpcPushChannel<T>;
    // (undocumented)
    dispose(): void;
    // @internal (undocumented)
    static enabled: boolean;
    // (undocumented)
    get enabled(): boolean;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    readonly name: string;
    static obtain<T>(name: string, service?: RpcPushService): RpcPushChannel<T>;
    // (undocumented)
    readonly service: RpcPushService;
    // (undocumented)
    static setup(transport: RpcPushTransport): void;
    // (undocumented)
    subscribe(): RpcPushSubscription<T>;
    }

// @alpha
export abstract class RpcPushConnection<T> {
    protected constructor(channel: RpcPushChannel<T>, client: unknown);
    // (undocumented)
    readonly channel: RpcPushChannel<T>;
    // (undocumented)
    readonly client: unknown;
    // (undocumented)
    static for<T>(_channel: RpcPushChannel<T>, _client?: unknown): RpcPushConnection<T>;
    // (undocumented)
    abstract send(messageData: T): Promise<void>;
}

// @alpha (undocumented)
export type RpcPushMessageListener<T> = (message: T) => void;

// @alpha
export class RpcPushService {
    constructor(name: string);
    static dedicated: RpcPushService;
    // (undocumented)
    readonly name: string;
}

// @alpha
export class RpcPushSubscription<T> {
    // @internal
    constructor(channel: RpcPushChannel<T>);
    // (undocumented)
    readonly channel: RpcPushChannel<T>;
    // (undocumented)
    readonly onMessage: BeEvent<RpcPushMessageListener<T>>;
}

// @alpha
export abstract class RpcPushTransport {
    // (undocumented)
    onMessage?: (channelId: string, messageData: any) => void;
}

// @internal (undocumented)
export class RpcRegistry {
    // (undocumented)
    definitionClasses: Map<string, RpcInterfaceDefinition>;
    // (undocumented)
    describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing?: RpcRoutingToken): T;
    // (undocumented)
    getImplForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): T;
    // (undocumented)
    id: () => number;
    // (undocumented)
    implementationClasses: Map<string, RpcInterfaceImplementation>;
    // (undocumented)
    implementations: Map<string, RpcInterface>;
    // (undocumented)
    initializeRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    static get instance(): RpcRegistry;
    // (undocumented)
    isRpcInterfaceInitialized<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): boolean;
    // (undocumented)
    lookupImpl<T extends RpcInterface>(interfaceName: string): T;
    // (undocumented)
    lookupInterfaceDefinition(name: string): RpcInterfaceDefinition;
    // (undocumented)
    proxies: Map<string, Map<number, RpcInterface>>;
    // (undocumented)
    registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    // (undocumented)
    suppliedImplementations: Map<string, RpcInterface>;
    // (undocumented)
    supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    // (undocumented)
    terminateRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @public
export abstract class RpcRequest<TResponse = any> {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    static get activeRequests(): ReadonlyMap<string, RpcRequest>;
    static get aggregateLoad(): RpcOperationsProfile;
    // (undocumented)
    cancel(): void;
    readonly client: RpcInterface;
    get connecting(): boolean;
    static current(context: RpcInterface): RpcRequest;
    // @internal (undocumented)
    dispose(): void;
    get elapsed(): number;
    static readonly events: BeEvent<RpcRequestEventHandler>;
    get extendedStatus(): string;
    findParameterOfType<T>(requiredProperties: {
        [index: string]: string;
    }): T | undefined;
    findTokenPropsParameter(): IModelRpcProps | undefined;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    readonly id: string;
    protected isHeaderAvailable(_name: string): boolean;
    get lastSubmitted(): number;
    get lastUpdated(): number;
    protected abstract load(): Promise<RpcSerializedValue>;
    method: string;
    static readonly notFoundHandlers: BeEvent<RpcRequestNotFoundHandler>;
    readonly operation: RpcOperation;
    parameters: any[];
    path: string;
    get pending(): boolean;
    readonly protocol: RpcProtocol;
    // (undocumented)
    protected _rawPromise: Promise<Response>;
    get rawResponse(): Promise<Response>;
    // (undocumented)
    protected reject(reason: any): void;
    // (undocumented)
    protected _resolveRaw: (value?: Response | PromiseLike<Response> | undefined) => void;
    readonly response: Promise<TResponse>;
    // (undocumented)
    protected _response: Response | undefined;
    retryInterval: number;
    protected abstract send(): Promise<number>;
    protected abstract setHeader(name: string, value: string): void;
    // (undocumented)
    protected setHeaders(): Promise<void>;
    protected setLastUpdatedTime(): void;
    get status(): RpcRequestStatus;
    // (undocumented)
    submit(): Promise<void>;
}

// @public
export type RpcRequestCallback_T = (request: RpcRequest) => void;

// @public
export interface RpcRequestContext {
    deserialize: (request: SerializedRpcRequest) => Promise<ClientRequestContext>;
    getId: (request: RpcRequest) => string;
    serialize: (request: RpcRequest) => Promise<SerializedClientRequestContext>;
}

// @public
export enum RpcRequestEvent {
    // (undocumented)
    PendingUpdateReceived = 1,
    // (undocumented)
    StatusChanged = 0
}

// @public
export type RpcRequestEventHandler = (type: RpcRequestEvent, request: RpcRequest) => void;

// @public
export interface RpcRequestFulfillment {
    id: string;
    interfaceName: string;
    rawResult: any;
    result: RpcSerializedValue;
    status: number;
}

// @public (undocumented)
export namespace RpcRequestFulfillment {
    // (undocumented)
    export function forUnknownError(request: SerializedRpcRequest, error: any): Promise<RpcRequestFulfillment>;
}

// @public
export type RpcRequestInitialRetryIntervalSupplier_T = (configuration: RpcConfiguration) => number;

// @public
export type RpcRequestNotFoundHandler = (request: RpcRequest, response: RpcNotFoundResponse, resubmit: () => void, reject: (reason: any) => void) => void;

// @public
export enum RpcRequestStatus {
    // (undocumented)
    Cancelled = 8,
    // (undocumented)
    Created = 1,
    // (undocumented)
    Disposed = 6,
    // (undocumented)
    NoContent = 9,
    // (undocumented)
    NotFound = 7,
    // (undocumented)
    Pending = 3,
    // (undocumented)
    Rejected = 5,
    // (undocumented)
    Resolved = 4,
    // (undocumented)
    Submitted = 2,
    // (undocumented)
    Unknown = 0
}

// @public
export type RpcRequestTokenSupplier_T = (request: RpcRequest) => IModelRpcProps | undefined;

// @public
export enum RpcResponseCacheControl {
    // (undocumented)
    Immutable = 1,
    // (undocumented)
    None = 0
}

// @public
export type RpcResponseCachingCallback_T = (request: RpcRequest) => RpcResponseCacheControl;

// @alpha (undocumented)
export interface RpcRoutingMap extends RpcConfigurationSupplier {
    // (undocumented)
    configurations: Map<number, RpcConfigurationSupplier>;
}

// @alpha (undocumented)
export namespace RpcRoutingMap {
    // (undocumented)
    export function create(): RpcRoutingMap;
}

// @public (undocumented)
export class RpcRoutingToken {
    // (undocumented)
    readonly debugLabel: string;
    // (undocumented)
    static readonly default: RpcRoutingToken;
    // (undocumented)
    static generate(debugLabel?: string): RpcRoutingToken;
    // (undocumented)
    readonly id: number;
    }

// @public (undocumented)
export interface RpcSerializedValue {
    // (undocumented)
    chunks?: number;
    // (undocumented)
    data: Uint8Array[];
    // (undocumented)
    objects: string;
    // (undocumented)
    stream?: Readable;
}

// @public (undocumented)
export namespace RpcSerializedValue {
    // (undocumented)
    export function create(objects?: string, data?: Uint8Array[]): RpcSerializedValue;
}

// @beta
export interface SectionDrawingLocationProps extends GeometricElement3dProps {
    sectionView?: RelatedElementProps;
}

// @beta
export interface SectionDrawingProps extends ElementProps {
    // (undocumented)
    jsonProperties?: {
        drawingToSpatialTransform?: TransformProps;
        sheetToSpatialTransform?: TransformProps;
        drawingBoundaryClip?: any;
    };
    sectionType?: SectionType;
    spatialView?: RelatedElementProps;
}

// @alpha @deprecated
export interface SectionLocationProps extends GeometricElement3dProps {
    // (undocumented)
    jsonProperties?: {
        spatialViewId?: Id64String;
        drawingViewId?: Id64String;
        drawingToSpatialTransform?: TransformProps;
        sheetToSpatialTransform?: TransformProps;
    };
    sectionType?: SectionType;
    viewAttachment?: RelatedElementProps;
}

// @public
export enum SectionType {
    // (undocumented)
    Detail = 4,
    // (undocumented)
    Elevation = 5,
    // (undocumented)
    Plan = 6,
    // (undocumented)
    Section = 3
}

// @public
export interface SerializedRpcOperation {
    // (undocumented)
    encodedRequest?: string;
    // (undocumented)
    interfaceDefinition: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationName: string;
}

// @public
export interface SerializedRpcRequest extends SerializedClientRequestContext {
    // (undocumented)
    caching: RpcResponseCacheControl;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    operation: SerializedRpcOperation;
    // (undocumented)
    parameters: RpcSerializedValue;
    // (undocumented)
    path: string;
    // (undocumented)
    protocolVersion?: number;
}

// @public (undocumented)
export class ServerError extends IModelError {
    constructor(errorNumber: number, message: string, log?: LogFunction);
}

// @public (undocumented)
export class ServerTimeoutError extends ServerError {
    constructor(message: string, log?: LogFunction);
}

// @beta
export interface SheetBorderTemplateProps extends ElementProps {
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @beta
export interface SheetProps extends ElementProps {
    // (undocumented)
    attachments?: Id64String[];
    // (undocumented)
    height?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sheetTemplate?: Id64String;
    // (undocumented)
    width?: number;
}

// @beta
export interface SheetTemplateProps extends ElementProps {
    // (undocumented)
    border?: Id64String;
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @internal (undocumented)
export class SilhouetteEdgeArgs extends EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    normals?: OctEncodedNormalPair[];
}

// @public
export interface SkyBoxImageProps {
    texture?: Id64String;
    textures?: SkyCubeProps;
    type?: SkyBoxImageType;
}

// @public
export enum SkyBoxImageType {
    Cube = 2,
    // @internal
    Cylindrical = 3,
    // (undocumented)
    None = 0,
    Spherical = 1
}

// @public
export interface SkyBoxProps {
    display?: boolean;
    groundColor?: ColorDefProps;
    groundExponent?: number;
    image?: SkyBoxImageProps;
    nadirColor?: ColorDefProps;
    skyColor?: ColorDefProps;
    skyExponent?: number;
    twoColor?: boolean;
    zenithColor?: ColorDefProps;
}

// @public
export interface SkyCubeProps {
    back?: Id64String;
    bottom?: Id64String;
    front?: Id64String;
    left?: Id64String;
    right?: Id64String;
    top?: Id64String;
}

// @beta
export interface SnapRequestProps {
    // (undocumented)
    closePoint: XYZProps;
    // (undocumented)
    decorationGeometry?: DecorationGeometryProps[];
    // (undocumented)
    geometryClass?: GeometryClass;
    // (undocumented)
    id: Id64String;
    // (undocumented)
    intersectCandidates?: Id64Array;
    // (undocumented)
    snapAperture?: number;
    // (undocumented)
    snapDivisor?: number;
    // (undocumented)
    snapModes?: number[];
    // (undocumented)
    subCategoryId?: Id64String;
    // (undocumented)
    testPoint: XYZProps;
    // (undocumented)
    viewFlags?: any;
    // (undocumented)
    worldToView: Matrix4dProps;
}

// @beta
export interface SnapResponseProps {
    // (undocumented)
    curve?: any;
    // (undocumented)
    geomType?: number;
    // (undocumented)
    heat?: number;
    // (undocumented)
    hitPoint?: XYZProps;
    // (undocumented)
    intersectCurve?: any;
    // (undocumented)
    intersectId?: string;
    // (undocumented)
    normal?: XYZProps;
    // (undocumented)
    parentGeomType?: number;
    // (undocumented)
    snapMode?: number;
    // (undocumented)
    snapPoint?: XYZProps;
    // (undocumented)
    status: number;
}

// @internal
export abstract class SnapshotIModelRpcInterface extends RpcInterface {
    // (undocumented)
    close(_iModelRpcProps: IModelRpcProps): Promise<boolean>;
    static getClient(): SnapshotIModelRpcInterface;
    static getClientForRouting(token: RpcRoutingToken): SnapshotIModelRpcInterface;
    static readonly interfaceName = "SnapshotIModelRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openFile(_filePath: string): Promise<IModelConnectionProps>;
    // (undocumented)
    openRemote(_key: string): Promise<IModelConnectionProps>;
}

// @public (undocumented)
export interface SnapshotOpenOptions extends IModelEncryptionProps {
    // @internal (undocumented)
    lazyBlockCache?: boolean;
}

// @public
export class SolarLight {
    constructor(json?: SolarLightProps);
    // (undocumented)
    readonly alwaysEnabled: boolean;
    clone(changedProps?: SolarLightProps): SolarLight;
    // (undocumented)
    readonly direction: Readonly<Vector3d>;
    // (undocumented)
    equals(rhs: SolarLight): boolean;
    // (undocumented)
    readonly intensity: number;
    // (undocumented)
    toJSON(): SolarLightProps | undefined;
}

// @public
export interface SolarLightProps {
    alwaysEnabled?: boolean;
    direction?: XYZProps;
    intensity?: number;
}

// @public
export class SolarShadowSettings {
    // @internal (undocumented)
    readonly bias: number;
    clone(changedProps?: SolarShadowSettingsProps): SolarShadowSettings;
    readonly color: RgbColor;
    // (undocumented)
    static defaults: SolarShadowSettings;
    // (undocumented)
    equals(rhs: SolarShadowSettings): boolean;
    // (undocumented)
    static fromJSON(props?: SolarShadowSettingsProps): SolarShadowSettings;
    // (undocumented)
    toJSON(): SolarShadowSettingsProps | undefined;
}

// @public
export interface SolarShadowSettingsProps {
    // @internal (undocumented)
    bias?: number;
    color?: ColorDefProps;
}

// @public
export interface SourceAndTarget {
    // (undocumented)
    sourceId: Id64String;
    // (undocumented)
    targetId: Id64String;
}

// @beta
export namespace SpatialClassificationProps {
    export interface Classifier {
        expand: number;
        flags: FlagsProps;
        modelId: Id64String;
        name: string;
    }
    export enum Display {
        Dimmed = 2,
        ElementColor = 4,
        Hilite = 3,
        Off = 0,
        On = 1
    }
    export function equalClassifiers(lhs: Classifier, rhs: Classifier): boolean;
    export function equalFlags(lhs: FlagsProps, rhs: FlagsProps): boolean;
    export function equalProperties(lhs: Properties, rhs: Properties): boolean;
    export class Flags implements FlagsProps {
        constructor(inside?: Display, outside?: Display, isVolumeClassifier?: boolean);
        // (undocumented)
        inside: Display;
        // (undocumented)
        isVolumeClassifier: boolean;
        // (undocumented)
        outside: Display;
        readonly type = 0;
    }
    export interface FlagsProps {
        // (undocumented)
        inside: SpatialClassificationProps.Display;
        // (undocumented)
        isVolumeClassifier?: boolean;
        // (undocumented)
        outside: SpatialClassificationProps.Display;
        readonly type: number;
    }
    export interface Properties extends Classifier {
        // (undocumented)
        isActive: boolean;
    }
}

// @public
export interface SpatialViewDefinitionProps extends ViewDefinition3dProps {
    // (undocumented)
    modelSelectorId: Id64String;
}

// @internal
export abstract class StandaloneIModelRpcInterface extends RpcInterface {
    // (undocumented)
    close(_iModelRpcProps: IModelRpcProps): Promise<boolean>;
    static getClient(): StandaloneIModelRpcInterface;
    static readonly interfaceName = "StandaloneIModelRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openFile(_filePath: string, _openMode: OpenMode): Promise<IModelConnectionProps>;
}

// @internal
export type StorageValue = string | number | boolean | null | Uint8Array;

// @public
export class SubCategoryAppearance {
    constructor(props?: SubCategoryAppearance.Props);
    // (undocumented)
    clone(): SubCategoryAppearance;
    readonly color: ColorDef;
    // (undocumented)
    static defaults: SubCategoryAppearance;
    // @internal (undocumented)
    readonly dontLocate: boolean;
    // @internal (undocumented)
    readonly dontPlot: boolean;
    // @internal (undocumented)
    readonly dontSnap: boolean;
    // (undocumented)
    equals(other: SubCategoryAppearance): boolean;
    get fillColor(): ColorDef;
    // @internal (undocumented)
    protected readonly _fillColor?: ColorDef;
    get fillTransparency(): number;
    // @internal (undocumented)
    protected readonly _fillTransparency?: number;
    readonly invisible: boolean;
    readonly materialId: Id64String;
    readonly priority: number;
    readonly styleId: Id64String;
    // @internal (undocumented)
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency: number;
    readonly weight: number;
}

// @public (undocumented)
export namespace SubCategoryAppearance {
    export interface Props {
        color?: ColorDefProps;
        // @internal (undocumented)
        dontLocate?: boolean;
        // @internal (undocumented)
        dontPlot?: boolean;
        // @internal (undocumented)
        dontSnap?: boolean;
        fill?: ColorDefProps;
        invisible?: boolean;
        material?: Id64String;
        priority?: number;
        style?: Id64String;
        transp?: number;
        transpFill?: number;
        weight?: number;
    }
}

// @public
export class SubCategoryOverride {
    get anyOverridden(): boolean;
    readonly color?: ColorDef;
    static defaults: SubCategoryOverride;
    equals(other: SubCategoryOverride): boolean;
    static fromJSON(json?: SubCategoryAppearance.Props): SubCategoryOverride;
    readonly invisible?: boolean;
    readonly material?: Id64String;
    override(appearance: SubCategoryAppearance): SubCategoryAppearance;
    readonly priority?: number;
    // @internal
    readonly style?: Id64String;
    // @internal
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency?: number;
    readonly weight?: number;
}

// @public
export interface SubCategoryProps extends DefinitionElementProps {
    // (undocumented)
    appearance?: SubCategoryAppearance.Props;
    // (undocumented)
    description?: string;
}

// @public
export interface SubjectProps extends ElementProps {
    // (undocumented)
    description?: string;
}

// @alpha (undocumented)
export type SubLayerId = string | number;

// @public
export enum SyncMode {
    // (undocumented)
    FixedVersion = 1,
    // (undocumented)
    PullAndPush = 2,
    // (undocumented)
    PullOnly = 3
}

// @public
export enum TerrainHeightOriginMode {
    Geodetic = 0,
    Geoid = 1,
    Ground = 2
}

// @public
export interface TerrainProps {
    applyLighting?: boolean;
    exaggeration?: number;
    heightOrigin?: number;
    heightOriginMode?: TerrainHeightOriginMode;
    // @deprecated (undocumented)
    nonLocatable?: boolean;
    providerName?: string;
}

// @public
export type TerrainProviderName = "CesiumWorldTerrain";

// @public
export class TerrainSettings {
    constructor(providerName?: TerrainProviderName, exaggeration?: number, applyLighting?: boolean, heightOrigin?: number, heightOriginMode?: TerrainHeightOriginMode, locatable?: boolean);
    readonly applyLighting: boolean;
    clone(changedProps?: TerrainProps): TerrainSettings;
    // (undocumented)
    equals(other: TerrainSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    readonly exaggeration: number;
    // (undocumented)
    static fromJSON(json?: TerrainProps): TerrainSettings;
    readonly heightOrigin: number;
    readonly heightOriginMode: TerrainHeightOriginMode;
    // @deprecated (undocumented)
    readonly locatable: boolean;
    readonly providerName: TerrainProviderName;
    // (undocumented)
    toJSON(): TerrainProps;
}

// @internal
export class TestRpcManager {
    // (undocumented)
    static initialize(interfaces: RpcInterfaceDefinition[]): void;
}

// @public
export class TextString {
    constructor(props: TextStringProps);
    bold?: boolean;
    font: number;
    // (undocumented)
    height: number;
    italic?: boolean;
    readonly origin: Point3d;
    readonly rotation: YawPitchRollAngles;
    text: string;
    // (undocumented)
    toJSON(): TextStringProps;
    // (undocumented)
    transformInPlace(transform: Transform): boolean;
    underline?: boolean;
    // (undocumented)
    get width(): number;
    // (undocumented)
    widthFactor?: number;
}

// @public
export interface TextStringPrimitive {
    // (undocumented)
    readonly textString: TextString;
    // (undocumented)
    type: "textString";
}

// @public
export interface TextStringProps {
    bold?: boolean;
    font: number;
    // (undocumented)
    height: number;
    italic?: boolean;
    origin?: XYZProps;
    rotation?: YawPitchRollProps;
    text: string;
    underline?: boolean;
    // (undocumented)
    widthFactor?: number;
}

// @beta (undocumented)
export enum TextureFlags {
    // (undocumented)
    None = 0
}

// @beta
export class TextureMapping {
    constructor(tx: RenderTexture, params: TextureMapping.Params);
    // @internal (undocumented)
    computeUVParams(visitor: PolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
    readonly params: TextureMapping.Params;
    readonly texture: RenderTexture;
}

// @beta (undocumented)
export namespace TextureMapping {
    export enum Mode {
        // @internal (undocumented)
        Cubic = 4,
        // @internal (undocumented)
        Cylindrical = 6,
        // @internal (undocumented)
        DirectionalDrape = 3,
        // (undocumented)
        ElevationDrape = 1,
        // @internal
        FrontProject = 8,
        // (undocumented)
        None = -1,
        // (undocumented)
        Parametric = 0,
        // (undocumented)
        Planar = 2,
        // @internal (undocumented)
        Solid = 7,
        // @internal (undocumented)
        Spherical = 5
    }
    export interface ParamProps {
        mapMode?: TextureMapping.Mode;
        textureMat2x3?: TextureMapping.Trans2x3;
        textureWeight?: number;
        // @internal (undocumented)
        worldMapping?: boolean;
    }
    export class Params {
        constructor(props?: ParamProps);
        // @internal
        computeUVParams(visitor: IndexedPolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
        mode: TextureMapping.Mode;
        textureMatrix: TextureMapping.Trans2x3;
        weight: number;
        // @internal (undocumented)
        worldMapping: boolean;
    }
    export class Trans2x3 {
        constructor(t00?: number, t01?: number, t02?: number, t10?: number, t11?: number, t12?: number);
        // (undocumented)
        setTransform(): void;
        // (undocumented)
        get transform(): Transform;
        }
}

// @beta
export interface TextureMapProps {
    pattern_angle?: number;
    pattern_flip?: boolean;
    pattern_mapping?: TextureMapping.Mode;
    pattern_offset?: DPoint2dProps;
    pattern_scale?: DPoint2dProps;
    pattern_scalemode?: TextureMapUnits;
    pattern_u_flip?: boolean;
    pattern_weight?: number;
    TextureId: Id64String;
}

// @beta (undocumented)
export enum TextureMapUnits {
    // (undocumented)
    Feet = 5,
    // (undocumented)
    Inches = 6,
    // (undocumented)
    Meters = 3,
    // (undocumented)
    Millimeters = 4,
    // (undocumented)
    Relative = 0
}

// @beta
export interface TextureProps extends DefinitionElementProps {
    data: string;
    description?: string;
    flags: TextureFlags;
    format: ImageSourceFormat;
    height: number;
    width: number;
}

// @beta
export class ThematicDisplay {
    readonly axis: Vector3d;
    readonly displayMode: ThematicDisplayMode;
    // (undocumented)
    equals(other: ThematicDisplay): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplayProps): ThematicDisplay;
    readonly gradientSettings: ThematicGradientSettings;
    readonly range: Range1d;
    // @alpha
    readonly sensorSettings: ThematicDisplaySensorSettings;
    readonly sunDirection: Vector3d;
    // (undocumented)
    toJSON(): ThematicDisplayProps;
}

// @beta
export enum ThematicDisplayMode {
    Height = 0,
    HillShade = 3,
    // @alpha
    InverseDistanceWeightedSensors = 1,
    Slope = 2
}

// @beta
export interface ThematicDisplayProps {
    axis?: XYZProps;
    displayMode?: ThematicDisplayMode;
    gradientSettings?: ThematicGradientSettingsProps;
    range?: Range1dProps;
    // @alpha
    sensorSettings?: ThematicDisplaySensorSettingsProps;
    sunDirection?: XYZProps;
}

// @alpha
export class ThematicDisplaySensor {
    // (undocumented)
    equals(other: ThematicDisplaySensor): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplaySensorProps): ThematicDisplaySensor;
    position: Readonly<Point3d>;
    // (undocumented)
    toJSON(): ThematicDisplaySensorProps;
    readonly value: number;
}

// @alpha
export interface ThematicDisplaySensorProps {
    position?: XYZProps;
    value?: number;
}

// @alpha
export class ThematicDisplaySensorSettings {
    readonly distanceCutoff: number;
    // (undocumented)
    equals(other: ThematicDisplaySensorSettings): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplaySensorSettingsProps): ThematicDisplaySensorSettings;
    readonly sensors: ThematicDisplaySensor[];
    // (undocumented)
    toJSON(): ThematicDisplaySensorSettingsProps;
}

// @alpha
export interface ThematicDisplaySensorSettingsProps {
    distanceCutoff?: number;
    sensors?: ThematicDisplaySensorProps[];
}

// @beta (undocumented)
export enum ThematicGradientColorScheme {
    // (undocumented)
    BlueRed = 0,
    // (undocumented)
    Custom = 5,
    // (undocumented)
    Monochrome = 2,
    // (undocumented)
    RedBlue = 1,
    // (undocumented)
    SeaMountain = 4,
    // (undocumented)
    Topographic = 3
}

// @beta (undocumented)
export enum ThematicGradientMode {
    IsoLines = 3,
    Smooth = 0,
    Stepped = 1,
    SteppedWithDelimiter = 2
}

// @beta
export class ThematicGradientSettings {
    clone(changedProps?: ThematicGradientSettingsProps): ThematicGradientSettings;
    readonly colorMix: number;
    readonly colorScheme: ThematicGradientColorScheme;
    // (undocumented)
    static get contentMax(): number;
    // (undocumented)
    static get contentRange(): number;
    readonly customKeys: Gradient.KeyColor[];
    // (undocumented)
    static defaults: ThematicGradientSettings;
    // (undocumented)
    equals(other: ThematicGradientSettings): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicGradientSettingsProps): ThematicGradientSettings;
    // (undocumented)
    static get margin(): number;
    readonly marginColor: ColorDef;
    readonly mode: ThematicGradientMode;
    readonly stepCount: number;
    // (undocumented)
    toJSON(): ThematicGradientSettingsProps;
}

// @beta (undocumented)
export interface ThematicGradientSettingsProps {
    colorMix?: number;
    colorScheme?: ThematicGradientColorScheme;
    customKeys?: Gradient.KeyColorProps[];
    marginColor?: ColorDefProps;
    mode?: ThematicGradientMode;
    stepCount?: number;
}

// @alpha
export interface ThumbnailFormatProps {
    format: "jpeg" | "png";
    height: number;
    width: number;
}

// @alpha
export interface ThumbnailProps extends ThumbnailFormatProps {
    image: Uint8Array;
}

// @internal (undocumented)
export interface TileContentDescription extends TileContentMetadata {
    // (undocumented)
    readonly featureTableStartPos: number;
}

// @beta (undocumented)
export interface TileContentIdentifier {
    // (undocumented)
    contentId: string;
    // (undocumented)
    guid: string | undefined;
    // (undocumented)
    tokenProps: IModelRpcProps;
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileContentMetadata {
    // (undocumented)
    readonly contentRange: Range3d;
    // (undocumented)
    readonly emptySubRangeMask: number;
    // (undocumented)
    readonly isLeaf: boolean;
    // (undocumented)
    readonly sizeMultiplier?: number;
}

// @internal
export enum TileFormat {
    // (undocumented)
    A3x = 5780289,
    // (undocumented)
    B3dm = 1835283298,
    // (undocumented)
    Cmpt = 1953525091,
    // (undocumented)
    Gltf = 1179937895,
    // (undocumented)
    I3dm = 1835283305,
    // (undocumented)
    IModel = 1818512745,
    // (undocumented)
    Pnts = 1937010288,
    // (undocumented)
    Unknown = 0
}

// @internal
export function tileFormatFromNumber(formatNumber: number): TileFormat;

// @internal
export abstract class TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get format(): TileFormat;
    protected invalidate(): void;
    abstract get isValid(): boolean;
    // (undocumented)
    version: number;
}

// @internal
export interface TileMetadata extends TileContentMetadata {
    // (undocumented)
    readonly contentId: string;
    // (undocumented)
    readonly range: Range3d;
}

// @internal
export class TileMetadataReader {
    constructor(type: BatchType, is2d: boolean, options: TileOptions);
    read(stream: ByteStream, props: TileProps): TileMetadata;
}

// @internal (undocumented)
export interface TileOptions {
    // (undocumented)
    readonly alwaysSubdivideIncompleteTiles: boolean;
    // (undocumented)
    readonly disableMagnification: boolean;
    // (undocumented)
    readonly enableImprovedElision: boolean;
    // (undocumented)
    readonly enableInstancing: boolean;
    // (undocumented)
    readonly ignoreAreaPatterns: boolean;
    // (undocumented)
    readonly maximumMajorTileFormatVersion: number;
    // (undocumented)
    readonly useProjectExtents: boolean;
}

// @internal
export interface TileProps {
    contentId: string;
    contentRange?: Range3dProps;
    isLeaf?: boolean;
    maximumSize: number;
    range: Range3dProps;
    sizeMultiplier?: number;
}

// @internal
export class TileReadError extends BentleyError {
    constructor(status: TileReadStatus, message?: string);
    // (undocumented)
    get wasCanceled(): boolean;
}

// @internal
export enum TileReadStatus {
    // (undocumented)
    Canceled = 7,
    // (undocumented)
    InvalidBatchTable = 3,
    // (undocumented)
    InvalidFeatureTable = 5,
    // (undocumented)
    InvalidHeader = 2,
    // (undocumented)
    InvalidScene = 4,
    // (undocumented)
    InvalidTileData = 1,
    // (undocumented)
    NewerMajorVersion = 6,
    // (undocumented)
    Success = 0
}

// @internal
export interface TileTreeContentIds {
    // (undocumented)
    contentIds: string[];
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileTreeMetadata {
    // (undocumented)
    readonly contentRange?: Range3d;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly modelId: Id64String;
}

// @internal
export interface TileTreeProps {
    contentRange?: Range3dProps;
    id: string;
    location: TransformProps;
    maxTilesToSkip?: number;
    rootTile: TileProps;
}

// @alpha
export interface TileVersionInfo {
    formatVersion: number;
}

// @internal
export enum TreeFlags {
    // (undocumented)
    EnforceDisplayPriority = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    UseProjectExtents = 1
}

// @beta
export class Tween {
    constructor(_group: Tweens, _object: any);
    // (undocumented)
    chain(...tweens: Tween[]): this;
    // (undocumented)
    delay(amount?: number): this;
    // (undocumented)
    duration(d: number): this;
    // (undocumented)
    easing(easingFunction?: EasingFunction): this;
    // (undocumented)
    end(): this;
    // (undocumented)
    getId(): number;
    // (undocumented)
    group(group: Tweens): this;
    // (undocumented)
    interpolation(interpolationFunction?: InterpolationFunction): this;
    // (undocumented)
    get isPaused(): boolean;
    // (undocumented)
    get isPlaying(): boolean;
    // (undocumented)
    onComplete(callback?: TweenCallback): this;
    // (undocumented)
    onRepeat(callback: TweenCallback): this;
    // (undocumented)
    onStart(callback: TweenCallback): this;
    // (undocumented)
    onStop(callback: TweenCallback): this;
    // (undocumented)
    onUpdate(callback: UpdateCallback): this;
    // (undocumented)
    pause(time: number): this;
    // (undocumented)
    repeat(times: number): this;
    // (undocumented)
    repeatDelay(amount: number): this;
    // (undocumented)
    resume(time?: number): this;
    // (undocumented)
    start(time?: string | number): this;
    // (undocumented)
    stop(): this;
    // (undocumented)
    stopChainedTweens(): void;
    // (undocumented)
    to(properties: any, duration?: number): this;
    // (undocumented)
    update(time: number): boolean;
    // (undocumented)
    yoyo(yoyo: boolean): this;
    }

// @beta (undocumented)
export type TweenCallback = (obj: any) => void;

// @beta
export class Tweens {
    // (undocumented)
    add(tween: Tween): void;
    create(from: any, opts?: {
        to: any;
        duration: number;
        onUpdate: UpdateCallback;
        onComplete?: TweenCallback;
        delay?: number;
        start?: boolean;
        easing?: EasingFunction;
        interpolation?: InterpolationFunction;
    }): Tween;
    // (undocumented)
    getAll(): any[];
    // (undocumented)
    nextId(): number;
    // (undocumented)
    remove(tween: Tween): void;
    // (undocumented)
    removeAll(): void;
    // (undocumented)
    update(time?: number, preserve?: boolean): boolean;
}

// @public
export class TypeDefinition extends RelatedElement {
}

// @public
export interface TypeDefinitionElementProps extends DefinitionElementProps {
    // (undocumented)
    recipe?: RelatedElementProps;
}

// @internal (undocumented)
export enum TypeOfChange {
    // (undocumented)
    Geometry = 2,
    // (undocumented)
    Hidden = 16,
    // (undocumented)
    Indirect = 8,
    // (undocumented)
    Placement = 4,
    // (undocumented)
    Property = 1
}

// @beta (undocumented)
export type UpdateCallback = (obj: any, t: number) => void;

// @beta
export interface UpgradeOptions {
    domain?: DomainOptions;
    profile?: ProfileOptions;
}

// @public
export interface UrlLinkProps extends ElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    url?: string;
}

// @public (undocumented)
export interface ViewAttachmentLabelProps extends GeometricElement2dProps {
    // (undocumented)
    viewAttachment?: RelatedElementProps;
}

// @public
export interface ViewAttachmentProps extends GeometricElement2dProps {
    // (undocumented)
    jsonProperties?: {
        displayPriority?: number;
        clip?: any;
        displayOptions?: {
            drawAsRaster?: boolean;
            preserveBackground?: boolean;
        };
    };
    // (undocumented)
    view: RelatedElementProps;
}

// @public
export interface ViewDefinition2dProps extends ViewDefinitionProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    baseModelId: Id64String;
    // (undocumented)
    delta: XYProps;
    // (undocumented)
    origin: XYProps;
}

// @public
export interface ViewDefinition3dProps extends ViewDefinitionProps {
    angles?: YawPitchRollProps;
    camera: CameraProps;
    cameraOn: boolean;
    extents: XYZProps;
    // @internal (undocumented)
    jsonProperties?: {
        viewDetails?: ViewDetails3dProps;
    };
    origin: XYZProps;
}

// @public
export interface ViewDefinitionProps extends DefinitionElementProps {
    // (undocumented)
    categorySelectorId: Id64String;
    // (undocumented)
    description?: string;
    // (undocumented)
    displayStyleId: Id64String;
    // @internal (undocumented)
    jsonProperties?: {
        viewDetails?: ViewDetailsProps;
    };
}

// @beta
export class ViewDetails {
    // @internal
    constructor(jsonProperties: {
        viewDetails?: ViewDetailsProps;
    });
    get aspectRatioSkew(): number;
    set aspectRatioSkew(skew: number);
    get auxiliaryCoordinateSystemId(): Id64String;
    set auxiliaryCoordinateSystemId(id: Id64String);
    get clipVector(): ClipVector | undefined;
    set clipVector(clip: ClipVector | undefined);
    // @internal
    getJSON(): ViewDetailsProps;
    get gridOrientation(): GridOrientationType;
    set gridOrientation(orientation: GridOrientationType);
    get gridSpacing(): XAndY;
    set gridSpacing(spacing: XAndY);
    get gridsPerRef(): number;
    set gridsPerRef(gridsPerRef: number);
    // @internal (undocumented)
    protected readonly _json: ViewDetailsProps;
    // @internal
    static maxSkew: number;
}

// @beta
export class ViewDetails3d extends ViewDetails {
    // @internal
    constructor(jsonProperties: {
        viewDetails?: ViewDetails3dProps;
    });
    get allow3dManipulations(): boolean;
    set allow3dManipulations(allow: boolean);
    // @internal
    getJSON(): ViewDetails3dProps;
    // @alpha
    get modelClipGroups(): ModelClipGroups;
    set modelClipGroups(groups: ModelClipGroups);
    // @internal (undocumented)
    readonly onModelClipGroupsChanged: BeEvent<(details: ViewDetails3d) => void>;
}

// @internal (undocumented)
export interface ViewDetails3dProps extends ViewDetailsProps {
    disable3dManipulations?: boolean;
    modelClipGroups?: ModelClipGroupProps[];
}

// @internal (undocumented)
export interface ViewDetailsProps {
    acs?: Id64String;
    aspectSkew?: number;
    clip?: any;
    gridOrient?: GridOrientationType;
    gridPerRef?: number;
    gridSpaceX?: number;
    gridSpaceY?: number;
}

// @public
export class ViewFlagOverrides {
    constructor(flags?: ViewFlags);
    anyOverridden(): boolean;
    apply(base: ViewFlags): ViewFlags;
    clear(): void;
    // (undocumented)
    clearClipVolume(): void;
    clearPresent(flag: ViewFlagPresence): void;
    // @internal
    get clipVolumeOverride(): boolean | undefined;
    clone(out?: ViewFlagOverrides): ViewFlagOverrides;
    copyFrom(other: ViewFlagOverrides): void;
    // @beta
    edgesRequired(viewFlags: ViewFlags): boolean;
    // (undocumented)
    static fromJSON(props?: ViewFlagOverridesProps): ViewFlagOverrides;
    isPresent(flag: ViewFlagPresence): boolean;
    overrideAll(flags?: ViewFlags): void;
    // (undocumented)
    setApplyLighting(val: boolean): void;
    // (undocumented)
    setEdgeMask(val: number): void;
    // (undocumented)
    setForceSurfaceDiscard(val: boolean): void;
    // (undocumented)
    setIgnoreGeometryMap(val: boolean): void;
    // (undocumented)
    setMonochrome(val: boolean): void;
    setPresent(flag: ViewFlagPresence): void;
    // (undocumented)
    setRenderMode(val: RenderMode): void;
    // (undocumented)
    setShowBackgroundMap(val: boolean): void;
    // (undocumented)
    setShowClipVolume(val: boolean): void;
    // (undocumented)
    setShowConstructions(val: boolean): void;
    // (undocumented)
    setShowDimensions(val: boolean): void;
    // (undocumented)
    setShowFill(val: boolean): void;
    // (undocumented)
    setShowHiddenEdges(val: boolean): void;
    // (undocumented)
    setShowMaterials(val: boolean): void;
    // (undocumented)
    setShowPatterns(val: boolean): void;
    // (undocumented)
    setShowShadows(val: boolean): void;
    // (undocumented)
    setShowStyles(val: boolean): void;
    // (undocumented)
    setShowTextures(val: boolean): void;
    // (undocumented)
    setShowTransparency(val: boolean): void;
    // (undocumented)
    setShowVisibleEdges(val: boolean): void;
    // (undocumented)
    setShowWeights(val: boolean): void;
    // (undocumented)
    setThematicDisplay(val: boolean): void;
    // (undocumented)
    setUseHlineMaterialColors(val: boolean): void;
    // (undocumented)
    setWhiteOnWhiteReversal(val: boolean): void;
    // (undocumented)
    toJSON(): ViewFlagOverridesProps;
    }

// @public
export interface ViewFlagOverridesProps {
    // (undocumented)
    backgroundMap?: boolean;
    // (undocumented)
    clipVolume?: boolean;
    // (undocumented)
    constructions?: boolean;
    // (undocumented)
    dimensions?: boolean;
    // (undocumented)
    edgeMask?: number;
    // (undocumented)
    fill?: boolean;
    // (undocumented)
    forceSurfaceDiscard?: boolean;
    // (undocumented)
    hiddenEdges?: boolean;
    // (undocumented)
    hLineMaterialColors?: boolean;
    // (undocumented)
    lighting?: boolean;
    // (undocumented)
    materials?: boolean;
    // (undocumented)
    monochrome?: boolean;
    // (undocumented)
    noGeometryMap?: boolean;
    // (undocumented)
    patterns?: boolean;
    // (undocumented)
    renderMode?: RenderMode;
    // (undocumented)
    shadows?: boolean;
    // (undocumented)
    styles?: boolean;
    // (undocumented)
    textures?: boolean;
    // (undocumented)
    thematicDisplay?: boolean;
    // (undocumented)
    transparency?: boolean;
    // (undocumented)
    visibleEdges?: boolean;
    // (undocumented)
    weights?: boolean;
    // (undocumented)
    whiteOnWhiteReversal?: boolean;
}

// @public
export enum ViewFlagPresence {
    // (undocumented)
    BackgroundMap = 20,
    // (undocumented)
    ClipVolume = 14,
    // (undocumented)
    Constructions = 15,
    // (undocumented)
    Dimensions = 1,
    // (undocumented)
    EdgeMask = 19,
    // (undocumented)
    Fill = 7,
    // (undocumented)
    ForceSurfaceDiscard = 21,
    // (undocumented)
    GeometryMap = 17,
    // (undocumented)
    HiddenEdges = 11,
    // (undocumented)
    HlineMaterialColors = 18,
    // (undocumented)
    Lighting = 12,
    // (undocumented)
    Materials = 9,
    // (undocumented)
    Monochrome = 16,
    // (undocumented)
    Patterns = 2,
    // (undocumented)
    RenderMode = 0,
    // (undocumented)
    Shadows = 13,
    // (undocumented)
    Styles = 4,
    // (undocumented)
    Textures = 8,
    // (undocumented)
    ThematicDisplay = 23,
    // (undocumented)
    Transparency = 5,
    // (undocumented)
    Unused = 6,
    // (undocumented)
    VisibleEdges = 10,
    // (undocumented)
    Weights = 3,
    // (undocumented)
    WhiteOnWhiteReversal = 22
}

// @public
export interface ViewFlagProps {
    acs?: boolean;
    ambientOcclusion?: boolean;
    backgroundMap?: boolean;
    clipVol?: boolean;
    // @internal
    edgeMask?: number;
    forceSurfaceDiscard?: boolean;
    grid?: boolean;
    hidEdges?: boolean;
    hlMatColors?: boolean;
    monochrome?: boolean;
    noCameraLights?: boolean;
    noConstruct?: boolean;
    noDim?: boolean;
    noFill?: boolean;
    noMaterial?: boolean;
    noPattern?: boolean;
    noSolarLight?: boolean;
    noSourceLights?: boolean;
    noStyle?: boolean;
    noTexture?: boolean;
    noTransp?: boolean;
    noWeight?: boolean;
    noWhiteOnWhiteReversal?: boolean;
    renderMode?: number;
    shadows?: boolean;
    thematicDisplay?: boolean;
    visEdges?: boolean;
}

// @public
export class ViewFlags {
    acsTriad: boolean;
    ambientOcclusion: boolean;
    backgroundMap: boolean;
    cameraLights: boolean;
    clipVolume: boolean;
    // (undocumented)
    clone(out?: ViewFlags): ViewFlags;
    constructions: boolean;
    // (undocumented)
    static createFrom(other?: ViewFlags, out?: ViewFlags): ViewFlags;
    dimensions: boolean;
    // @internal
    edgeMask: number;
    // @internal (undocumented)
    edgesRequired(): boolean;
    // (undocumented)
    equals(other: ViewFlags): boolean;
    fill: boolean;
    forceSurfaceDiscard: boolean;
    // (undocumented)
    static fromJSON(json?: ViewFlagProps): ViewFlags;
    grid: boolean;
    hiddenEdges: boolean;
    // @internal (undocumented)
    hiddenEdgesVisible(): boolean;
    hLineMaterialColors: boolean;
    get lighting(): boolean;
    set lighting(enable: boolean);
    materials: boolean;
    monochrome: boolean;
    // @internal
    noGeometryMap: boolean;
    patterns: boolean;
    renderMode: RenderMode;
    shadows: boolean;
    solarLight: boolean;
    sourceLights: boolean;
    styles: boolean;
    textures: boolean;
    thematicDisplay: boolean;
    // @internal
    toFullyDefinedJSON(): Required<ViewFlagProps>;
    // (undocumented)
    toJSON(): ViewFlagProps;
    transparency: boolean;
    visibleEdges: boolean;
    weights: boolean;
    whiteOnWhiteReversal: boolean;
}

// @public
export interface ViewQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
}

// @public
export interface ViewStateProps {
    // (undocumented)
    categorySelectorProps: CategorySelectorProps;
    // (undocumented)
    displayStyleProps: DisplayStyleProps;
    // @alpha
    modelExtents?: Range3dProps;
    // (undocumented)
    modelSelectorProps?: ModelSelectorProps;
    // @beta (undocumented)
    sheetAttachments?: Id64Array;
    // @beta (undocumented)
    sheetProps?: SheetProps;
    // (undocumented)
    viewDefinitionProps: ViewDefinitionProps;
}

// @internal (undocumented)
export const WEB_RPC_CONSTANTS: {
    CONTENT: string;
    TEXT: string;
    ANY_TEXT: string;
    BINARY: string;
    MULTIPART: string;
};

// @public
export abstract class WebAppRpcProtocol extends RpcProtocol {
    constructor(configuration: RpcConfiguration);
    // @internal (undocumented)
    allowedHeaders: Set<string>;
    static computeContentType(httpType: string | null | undefined): RpcContentType;
    getCode(status: RpcRequestStatus): number;
    getStatus(code: number): RpcRequestStatus;
    handleOpenApiDescriptionRequest(_req: HttpServerRequest, res: HttpServerResponse): void;
    handleOperationGetRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    handleOperationPostRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    abstract info: OpenAPIInfo;
    // @internal (undocumented)
    initialize(): Promise<void>;
    isTimeout(code: number): boolean;
    // @internal
    get openAPIDescription(): RpcOpenAPIDescription;
    pathPrefix: string;
    // (undocumented)
    preserveStreams: boolean;
    readonly requestType: typeof WebAppRpcRequest;
    // @internal
    abstract supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
}

// @public
export class WebAppRpcRequest extends RpcRequest {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    protected static computeTransportType(value: RpcSerializedValue, source: any): RpcContentType;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    // (undocumented)
    protected isHeaderAvailable(name: string): boolean;
    // (undocumented)
    protected load(): Promise<RpcSerializedValue>;
    static maxUrlComponentSize: number;
    metadata: {
        status: number;
        message: string;
    };
    method: HttpMethod_T;
    static parseRequest(protocol: WebAppRpcProtocol, req: HttpServerRequest): Promise<SerializedRpcRequest>;
    // @internal (undocumented)
    preflight(): Promise<Response | undefined>;
    readonly protocol: WebAppRpcProtocol;
    protected send(): Promise<number>;
    static sendResponse(protocol: WebAppRpcProtocol, request: SerializedRpcRequest, fulfillment: RpcRequestFulfillment, res: HttpServerResponse): void;
    protected setHeader(name: string, value: string): void;
    protected supplyFetch(): typeof fetch;
    protected supplyRequest(): typeof Request;
}

// @internal
export abstract class WipRpcInterface extends RpcInterface {
    // (undocumented)
    attachChangeCache(_iModelToken: IModelRpcProps): Promise<void>;
    // (undocumented)
    detachChangeCache(_iModelToken: IModelRpcProps): Promise<void>;
    // (undocumented)
    getChangedElements(_iModelToken: IModelRpcProps, _startChangesetId: string, _endChangesetId: string): Promise<ChangedElements | undefined>;
    static getClient(): WipRpcInterface;
    static readonly interfaceName = "WipRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    isChangeCacheAttached(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    isChangesetProcessed(_iModelToken: IModelRpcProps, _changesetId: string): Promise<boolean>;
    // (undocumented)
    placeholder(_iModelToken: IModelRpcProps): Promise<string>;
}


// (No @packageDocumentation comment for this package)

```
