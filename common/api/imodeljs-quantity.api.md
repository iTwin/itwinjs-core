## API Report File for "@bentley/imodeljs-quantity"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BentleyError } from '@bentley/bentleyjs-core';

// @alpha
export class BadUnit implements UnitProps {
    // (undocumented)
    isValid: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    system: string;
    // (undocumented)
    unitFamily: string;
}

// @alpha
export class BasicUnit implements UnitProps {
    constructor(name: string, label: string, unitFamily: string, alternateLabels?: string[], system?: string);
    // (undocumented)
    alternateLabels?: string[];
    // (undocumented)
    isValid: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    system: string;
    // (undocumented)
    unitFamily: string;
}

// @alpha
export interface CustomFormatProps extends FormatProps {
    // (undocumented)
    readonly custom: any;
}

// @alpha (undocumented)
export enum DecimalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Eleven = 11,
    // (undocumented)
    Five = 5,
    // (undocumented)
    Four = 4,
    // (undocumented)
    Nine = 9,
    // (undocumented)
    One = 1,
    // (undocumented)
    Seven = 7,
    // (undocumented)
    Six = 6,
    // (undocumented)
    Ten = 10,
    // (undocumented)
    Three = 3,
    // (undocumented)
    Twelve = 12,
    // (undocumented)
    Two = 2,
    // (undocumented)
    Zero = 0
}

// @alpha
export class Format {
    constructor(name: string);
    static createFromJSON(name: string, unitsProvider: UnitsProvider, formatProps: FormatProps): Promise<Format>;
    // (undocumented)
    get customProps(): any;
    // (undocumented)
    protected _customProps?: any;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    protected _decimalSeparator: string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    protected _formatTraits: FormatTraits;
    static formatTraitsToArray(currentFormatTrait: FormatTraits): string[];
    static formatTypeToString(type: FormatType): string;
    fromJSON(unitsProvider: UnitsProvider, jsonObj: FormatProps): Promise<void>;
    static getTraitString(trait: FormatTraits): "trailZeroes" | "keepSingleZero" | "zeroEmpty" | "keepDecimalPoint" | "applyRounding" | "fractionDash" | "showUnitLabel" | "prependUnitLabel" | "use1000Separator" | "exponentOnlyNegative";
    hasFormatTraitSet(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get hasUnits(): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // (undocumented)
    protected _includeZero: boolean;
    // (undocumented)
    static isFormatTraitSetInProps(formatProps: FormatProps, trait: FormatTraits): boolean;
    // (undocumented)
    get minWidth(): number | undefined;
    // (undocumented)
    protected _minWidth?: number;
    // (undocumented)
    get name(): string;
    static parseDecimalPrecision(jsonObjPrecision: number): DecimalPrecision;
    static parseFormatTrait(stringToCheck: string, currentFormatTrait: number): FormatTraits;
    static parseFormatTraits(formatTraitsFromJson: string | string[] | undefined): FormatTraits | undefined;
    static parseFormatType(jsonObjType: string, formatName: string): FormatType;
    static parseFractionalPrecision(jsonObjPrecision: number, formatName: string): FractionalPrecision;
    static parsePrecision(precision: number, formatName: string, type: FormatType): DecimalPrecision | FractionalPrecision;
    static parseScientificType(scientificType: string, formatName: string): ScientificType;
    static parseShowSignOption(showSignOption: string, formatName: string): ShowSignOption;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    protected _precision: number;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    protected _roundFactor: number;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    protected _scientificType?: ScientificType;
    // (undocumented)
    static scientificTypeToString(scientificType: ScientificType): string;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    protected _showSignOption: ShowSignOption;
    static showSignOptionToString(showSign: ShowSignOption): string;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    protected _spacer: string;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    protected _stationOffsetSize?: number;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    protected _stationSeparator: string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    protected _thousandSeparator: string;
    toJSON(): FormatProps;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    protected _type: FormatType;
    // (undocumented)
    get units(): Array<[UnitProps, string | undefined]> | undefined;
    // (undocumented)
    protected _units?: Array<[UnitProps, string | undefined]>;
    // (undocumented)
    get uomSeparator(): string;
    // (undocumented)
    protected _uomSeparator: string;
    }

// @alpha
export interface FormatProps {
    // (undocumented)
    readonly composite?: {
        readonly spacer?: string;
        readonly includeZero?: boolean;
        readonly units: Array<{
            readonly name: string;
            readonly label?: string;
        }>;
    };
    // (undocumented)
    readonly decimalSeparator?: string;
    // (undocumented)
    readonly formatTraits?: string | string[];
    // (undocumented)
    readonly minWidth?: number;
    // (undocumented)
    readonly precision?: number;
    // (undocumented)
    readonly roundFactor?: number;
    // (undocumented)
    readonly scientificType?: string;
    // (undocumented)
    readonly showSignOption?: string;
    // (undocumented)
    readonly stationOffsetSize?: number;
    // (undocumented)
    readonly stationSeparator?: string;
    // (undocumented)
    readonly thousandSeparator?: string;
    // (undocumented)
    readonly type: string;
    // (undocumented)
    readonly uomSeparator?: string;
}

// @alpha
export class Formatter {
    static formatQuantity(magnitude: number, spec: FormatterSpec): string;
    }

// @alpha
export class FormatterSpec {
    constructor(name: string, format: Format, conversions?: UnitConversionSpec[], persistenceUnit?: UnitProps);
    applyFormatting(magnitude: number): string;
    // (undocumented)
    protected _conversions: UnitConversionSpec[];
    static create(name: string, format: Format, unitsProvider: UnitsProvider, inputUnit?: UnitProps): Promise<FormatterSpec>;
    // (undocumented)
    get format(): Format;
    // (undocumented)
    protected _format: Format;
    static getUnitConversions(format: Format, unitsProvider: UnitsProvider, inputUnit?: UnitProps): Promise<UnitConversionSpec[]>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    protected _name: string;
    // (undocumented)
    get persistenceUnit(): UnitProps;
    // (undocumented)
    protected _persistenceUnit: UnitProps;
    get unitConversions(): UnitConversionSpec[];
}

// @alpha (undocumented)
export enum FormatTraits {
    // (undocumented)
    ApplyRounding = 16,
    // (undocumented)
    ExponentOnlyNegative = 512,
    // (undocumented)
    FractionDash = 32,
    // (undocumented)
    KeepDecimalPoint = 8,
    // (undocumented)
    KeepSingleZero = 2,
    // (undocumented)
    PrependUnitLabel = 128,
    // (undocumented)
    ShowUnitLabel = 64,
    // (undocumented)
    TrailZeroes = 1,
    // (undocumented)
    Use1000Separator = 256,
    // (undocumented)
    ZeroEmpty = 4
}

// @alpha (undocumented)
export enum FormatType {
    // (undocumented)
    Decimal = 0,
    // (undocumented)
    Fractional = 1,
    // (undocumented)
    Scientific = 2,
    // (undocumented)
    Station = 3
}

// @alpha (undocumented)
export enum FractionalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Four = 4,
    // (undocumented)
    One = 1,
    // (undocumented)
    OneHundredTwentyEight = 128,
    // (undocumented)
    Sixteen = 16,
    // (undocumented)
    SixtyFour = 64,
    // (undocumented)
    ThirtyTwo = 32,
    // (undocumented)
    Two = 2,
    // (undocumented)
    TwoHundredFiftySix = 256
}

// @alpha
export const isCustomFormatProps: (item: FormatProps) => item is CustomFormatProps;

// @alpha
export interface ParsedQuantity {
    ok: true;
    value: number;
}

// @alpha
export enum ParseError {
    // (undocumented)
    InvalidParserSpec = 6,
    // (undocumented)
    NoValueOrUnitFoundInString = 2,
    // (undocumented)
    UnableToConvertParseTokensToQuantity = 5,
    // (undocumented)
    UnableToGenerateParseTokens = 1,
    // (undocumented)
    UnitLabelSuppliedButNotMatched = 3,
    // (undocumented)
    UnknownUnit = 4
}

// @alpha
export interface ParseQuantityError {
    error: ParseError;
    ok: false;
}

// @alpha
export class Parser {
    static createUnitConversionSpecs(unitsProvider: UnitsProvider, outUnitName: string, potentialParseUnits: PotentialParseUnit[]): Promise<UnitConversionSpec[]>;
    static createUnitConversionSpecsForUnit(unitsProvider: UnitsProvider, outUnit: UnitProps): Promise<UnitConversionSpec[]>;
    // (undocumented)
    static isParsedQuantity(item: QuantityParseResult): item is ParsedQuantity;
    // (undocumented)
    static isParseError(item: QuantityParseResult): item is ParseQuantityError;
    static parseIntoQuantity(inString: string, format: Format, unitsProvider: UnitsProvider): Promise<QuantityProps>;
    static parseQuantitySpecification(quantitySpecification: string, format: Format): ParseToken[];
    static parseQuantityString(inString: string, parserSpec: ParserSpec): QuantityParseResult;
    static parseToQuantityValue(inString: string, format: Format, unitsConversions: UnitConversionSpec[]): QuantityParseResult;
    }

// @alpha
export class ParserSpec {
    constructor(outUnit: UnitProps, format: Format, conversions: UnitConversionSpec[]);
    static create(format: Format, unitsProvider: UnitsProvider, outUnit: UnitProps): Promise<ParserSpec>;
    // (undocumented)
    get format(): Format;
    // (undocumented)
    get outUnit(): UnitProps;
    parseToQuantityValue(inString: string): QuantityParseResult;
    get unitConversions(): UnitConversionSpec[];
}

// @alpha
export interface PotentialParseUnit {
    // (undocumented)
    altLabels?: string[];
    // (undocumented)
    unitName: string;
}

// @alpha
export class Quantity implements QuantityProps {
    constructor(unit?: UnitProps, magnitude?: number);
    convertTo(toUnit: UnitProps, conversion: UnitConversion): Quantity | undefined;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    protected _isValid: boolean;
    // (undocumented)
    get magnitude(): number;
    // (undocumented)
    protected _magnitude: number;
    // (undocumented)
    get unit(): UnitProps;
    // (undocumented)
    protected _unit: UnitProps;
}

// @internal
export class QuantityConstants {
    // (undocumented)
    static readonly CHAR_COMMA = 44;
    // (undocumented)
    static readonly CHAR_DIGIT_NINE = 57;
    // (undocumented)
    static readonly CHAR_DIGIT_ZERO = 48;
    // (undocumented)
    static readonly CHAR_DIVISION_SLASH = 8725;
    // (undocumented)
    static readonly CHAR_FRACTION_SLASH = 8260;
    // (undocumented)
    static readonly CHAR_LOWER_E = 101;
    // (undocumented)
    static readonly CHAR_MINUS = 45;
    // (undocumented)
    static readonly CHAR_NUMBER = 35;
    // (undocumented)
    static readonly CHAR_ONE_HALF = 189;
    // (undocumented)
    static readonly CHAR_ONE_QUARTER = 188;
    // (undocumented)
    static readonly CHAR_PERIOD = 46;
    // (undocumented)
    static readonly CHAR_PLUS = 43;
    // (undocumented)
    static readonly CHAR_SLASH = 47;
    // (undocumented)
    static readonly CHAR_SPACE = 32;
    // (undocumented)
    static readonly CHAR_THREE_QUARTER = 190;
    // (undocumented)
    static readonly CHAR_UPPER_E = 69;
    static get LocaleSpecificDecimalSeparator(): string;
    static get LocaleSpecificThousandSeparator(): string;
}

// @alpha
export class QuantityError extends BentleyError {
    constructor(errorNumber: number, message?: string);
    // (undocumented)
    readonly errorNumber: number;
}

// @alpha
export type QuantityParseResult = ParsedQuantity | ParseQuantityError;

// @alpha
export interface QuantityProps {
    // (undocumented)
    readonly isValid: boolean;
    // (undocumented)
    readonly magnitude: number;
    // (undocumented)
    readonly unit: UnitProps;
}

// @alpha
export enum QuantityStatus {
    // (undocumented)
    InvalidCompositeFormat = 35041,
    // (undocumented)
    InvalidJson = 35040,
    // (undocumented)
    NoValueOrUnitFoundInString = 35043,
    // (undocumented)
    QUANTITY_ERROR_BASE = 35039,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UnableToConvertParseTokensToQuantity = 35046,
    // (undocumented)
    UnableToGenerateParseTokens = 35042,
    // (undocumented)
    UnitLabelSuppliedButNotMatched = 35044,
    // (undocumented)
    UnknownUnit = 35045
}

// @alpha (undocumented)
export enum ScientificType {
    // (undocumented)
    Normalized = 0,
    // (undocumented)
    ZeroNormalized = 1
}

// @alpha (undocumented)
export enum ShowSignOption {
    // (undocumented)
    NegativeParentheses = 3,
    // (undocumented)
    NoSign = 0,
    // (undocumented)
    OnlyNegative = 1,
    // (undocumented)
    SignAlways = 2
}

// @alpha
export interface UnitConversion {
    // (undocumented)
    factor: number;
    // (undocumented)
    offset: number;
}

// @alpha
export interface UnitConversionSpec {
    conversion: UnitConversion;
    label: string;
    name: string;
    parseLabels?: string[];
    system: string;
}

// @alpha
export interface UnitProps {
    readonly alternateLabels?: string[];
    readonly isValid: boolean;
    readonly label: string;
    readonly name: string;
    readonly system: string;
    readonly unitFamily: string;
}

// @alpha
export interface UnitsProvider {
    // (undocumented)
    findUnit(unitLabel: string, unitFamily?: string, unitSystem?: string): Promise<UnitProps>;
    // (undocumented)
    findUnitByName(unitName: string): Promise<UnitProps>;
    // (undocumented)
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion>;
    // (undocumented)
    getUnitsByFamily(unitFamily: string): Promise<UnitProps[]>;
}


// (No @packageDocumentation comment for this package)

```
