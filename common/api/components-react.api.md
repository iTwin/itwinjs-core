## API Report File for "@itwin/components-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionButton } from '@itwin/appui-abstract';
import { AlternateDateFormats } from '@itwin/appui-abstract';
import { BeEvent } from '@itwin/core-bentley';
import { BeUiEvent } from '@itwin/core-bentley';
import { CheckBoxInfo as CheckBoxInfo_2 } from '@itwin/core-react';
import { CheckBoxState } from '@itwin/core-react';
import { CommonProps } from '@itwin/core-react';
import { CommonToolbarItem } from '@itwin/appui-abstract';
import * as CSS from 'csstype';
import { CSSProperties } from 'react';
import { CustomButtonDefinition } from '@itwin/appui-abstract';
import { DateFormatter } from '@itwin/appui-abstract';
import { DisplayMessageType } from '@itwin/appui-abstract';
import { EnumerationChoice } from '@itwin/appui-abstract';
import { GlobalContextMenuProps } from '@itwin/core-react';
import { GlobalDialogProps } from '@itwin/core-react';
import { GroupButton } from '@itwin/appui-abstract';
import { HorizontalAlignment } from '@itwin/core-react';
import { IconDefinition } from '@itwin/appui-abstract';
import { Id64String } from '@itwin/core-bentley';
import { IDisposable } from '@itwin/core-bentley';
import { immerable } from 'immer';
import * as Inspire from 'inspire-tree';
import { Interaction } from 'scheduler/tracing';
import { LinkElementsInfo } from '@itwin/appui-abstract';
import { Localization } from '@itwin/core-common';
import { MessageSeverity } from '@itwin/appui-abstract';
import { NoChildrenProps } from '@itwin/core-react';
import { NodeCheckboxRenderer } from '@itwin/core-react';
import { Observable as Observable_2 } from 'rxjs/internal/Observable';
import { Omit } from '@itwin/core-react';
import { OnItemExecutedFunc } from '@itwin/appui-abstract';
import { OptionType } from '@itwin/core-react';
import { Orientation } from '@itwin/core-react';
import { ParseResults } from '@itwin/appui-abstract';
import { Primitives } from '@itwin/appui-abstract';
import { PropertyDescription } from '@itwin/appui-abstract';
import { PropertyRecord } from '@itwin/appui-abstract';
import { PropertyValue } from '@itwin/appui-abstract';
import * as PropTypes from 'prop-types';
import { RatioChangeResult } from '@itwin/core-react';
import * as React from 'react';
import ReactDataGrid from 'react-data-grid';
import { RelativePosition } from '@itwin/appui-abstract';
import { SelectOption } from '@itwin/itwinui-react';
import { SortDirection } from '@itwin/core-react';
import { TimeDisplay } from '@itwin/appui-abstract';
import { TimeFormat } from '@itwin/core-react';
import { UiEvent } from '@itwin/core-react';
import { UiSettings } from '@itwin/core-react';
import { UiSettingsStorage } from '@itwin/core-react';

// @public
export abstract class AbstractTreeNodeLoader implements ITreeNodeLoader {
    protected constructor(modelSource: TreeModelSource);
    protected abstract load(parent: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<LoadedNodeHierarchy>;
    loadNode(parent: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<TreeNodeLoadResult>;
    // (undocumented)
    get modelSource(): TreeModelSource;
    protected updateModel(loadedHierarchy: LoadedNodeHierarchy): void;
}

// @public
export abstract class AbstractTreeNodeLoaderWithProvider<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoader implements ITreeNodeLoaderWithProvider<TDataProvider> {
    protected constructor(modelSource: TreeModelSource, dataProvider: TDataProvider);
    // (undocumented)
    get dataProvider(): TDataProvider;
    }

// @public
export class ActionButtonList extends React.PureComponent<ActionButtonListProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface ActionButtonListProps {
    actionButtonRenderers: ActionButtonRenderer[];
    isPropertyHovered?: boolean;
    orientation: Orientation;
    property: PropertyRecord;
}

// @public
export type ActionButtonRenderer = (props: ActionButtonRendererProps) => React.ReactNode;

// @public
export interface ActionButtonRendererProps {
    isPropertyHovered?: boolean;
    property: PropertyRecord;
}

// @internal (undocumented)
export function ActionItem({ item, addGroupSeparator }: {
    item: ActionButton;
    addGroupSeparator: boolean;
}): JSX.Element;

// @public
export interface ActiveMatchInfo {
    // (undocumented)
    matchIndex: number;
    // (undocumented)
    nodeId: string;
}

// @public
export function adjustDateToTimezone(inDateTime: Date, utcOffset: number): Date;

// @public
export class ArrayPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): React.ReactNode;
}

// @public
export interface AsyncErrorMessage {
    // (undocumented)
    briefMessage: string;
    // (undocumented)
    detailedMessage?: string;
    // (undocumented)
    messageType?: DisplayMessageType;
    // (undocumented)
    severity: MessageSeverity;
}

// @public
export interface AsyncValueProcessingResult {
    // (undocumented)
    encounteredError: boolean;
    // (undocumented)
    errorMessage?: AsyncErrorMessage;
    // (undocumented)
    returnValue?: PropertyValue;
}

// @public
export abstract class BasePointTypeConverter extends TypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    componentConverterName: string;
    // (undocumented)
    protected abstract constructPoint(_values: Primitives.Point): ConvertedPrimitives.Point | undefined;
    // (undocumented)
    convertFromString(value: string): ConvertedPrimitives.Point | undefined;
    // (undocumented)
    convertToString(value?: Primitives.Point): string | Promise<string>;
    // (undocumented)
    protected abstract getVectorLength(point: Primitives.Point): number | undefined;
    // (undocumented)
    sortCompare(a: Primitives.Point, b: Primitives.Point, _ignoreCase?: boolean): number;
}

// @public
export class BasicPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta @deprecated
export function BeDragDropContext(props: {
    children?: React.ReactNode;
}): JSX.Element;

// @public
export class BooleanEditor extends React.PureComponent<PropertyEditorProps, BooleanEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<BooleanEditorState>;
    }

// @public
export class BooleanPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class BooleanTypeConverter extends TypeConverter {
    // (undocumented)
    convertFromString(value: string): boolean;
    // (undocumented)
    convertToString(value?: Primitives.Boolean): string;
    // @internal (undocumented)
    static getLocalizedTrueFalse(): void;
    // (undocumented)
    get isBooleanType(): boolean;
    // @internal (undocumented)
    static sl10nFalse: string;
    // @internal (undocumented)
    static sl10nTrue: string;
    // (undocumented)
    sortCompare(a: Primitives.Boolean, b: Primitives.Boolean, _ignoreCase?: boolean): number;
}

// @beta @deprecated
export class Breadcrumb extends React.Component<BreadcrumbProps, BreadcrumbState> {
    // @internal
    constructor(props: BreadcrumbProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: BreadcrumbProps, prevState: BreadcrumbState): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static defaultProps: Partial<BreadcrumbProps>;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: BreadcrumbProps, state: BreadcrumbState): BreadcrumbState | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    shouldComponentUpdate(nextProps: BreadcrumbProps, nextState: BreadcrumbState): boolean;
    // @internal (undocumented)
    readonly state: Readonly<BreadcrumbState>;
}

// @beta @deprecated
export class BreadcrumbDetails extends React.Component<BreadcrumbDetailsProps, BreadcrumbDetailsState> {
    // @internal
    constructor(props: BreadcrumbDetailsProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: BreadcrumbDetailsProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    shouldComponentUpdate(nextProps: BreadcrumbDetailsProps, nextState: BreadcrumbDetailsState): boolean;
    // (undocumented)
    readonly state: BreadcrumbDetailsState;
    }

// @beta @deprecated
export interface BreadcrumbDetailsProps extends CommonProps {
    // (undocumented)
    columns?: ColumnDescription[];
    onChildrenLoaded?: (parent: TreeNodeItem, children: TreeNodeItem[]) => void;
    // @internal (undocumented)
    onRender?: () => void;
    onRootNodesLoaded?: (nodes: TreeNodeItem[]) => void;
    path: BreadcrumbPath;
    // (undocumented)
    renderTable?: (props: TableProps, node: TreeNodeItem | undefined, children: TreeNodeItem[]) => React.ReactNode;
}

// @internal (undocumented)
export class BreadcrumbInput extends React.Component<BreadcrumbInputProps, BreadcrumbInputState> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    readonly state: Readonly<BreadcrumbInputState>;
}

// @internal (undocumented)
export interface BreadcrumbInputProps {
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    node?: BeInspireTreeNode<TreeNodeItem>;
    // (undocumented)
    onCancel: () => void;
    // (undocumented)
    onNodeChange: (node: TreeNodeItem | undefined) => void;
    // (undocumented)
    parentsOnly?: boolean;
    // (undocumented)
    pathString: string;
    // (undocumented)
    tree: BeInspireTree<TreeNodeItem>;
    // (undocumented)
    width: number | string;
}

// @internal (undocumented)
export interface BreadcrumbInputState {
    // (undocumented)
    autocompleteList: string[];
    // (undocumented)
    autocompleting: boolean;
    // (undocumented)
    messageBoxOpened: boolean;
}

// @beta @deprecated
export enum BreadcrumbMode {
    // (undocumented)
    Dropdown = "dropdown",
    // (undocumented)
    Input = "input"
}

// @beta @deprecated
export class BreadcrumbNode extends React.Component<BreadcrumbNodeProps> {
    constructor(props: BreadcrumbNodeProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    render(): React.ReactNode;
}

// @beta @deprecated
export interface BreadcrumbNodeProps {
    icon: string;
    label: PropertyRecord;
    // @internal (undocumented)
    onRender?: () => void;
}

// @internal (undocumented)
export type BreadcrumbNodeRenderer = (props: BreadcrumbNodeProps, node?: TreeNodeItem, parent?: TreeNodeItem) => React.ReactNode;

// @beta @deprecated
export class BreadcrumbPath {
    constructor(dataProvider: TreeDataProvider);
    // (undocumented)
    get BreadcrumbUpdateEvent(): BreadcrumbUpdateEvent;
    // (undocumented)
    getCurrentNode(): TreeNodeItem | undefined;
    // (undocumented)
    getDataProvider(): TreeDataProvider;
    // (undocumented)
    setCurrentNode(currentNode: TreeNodeItem | undefined): void;
    // (undocumented)
    setDataProvider(dataProvider: TreeDataProvider): void;
}

// @beta @deprecated
export interface BreadcrumbProps extends CommonProps {
    background?: boolean;
    dataProvider: TreeDataProvider;
    delimiter?: string;
    dropdownOnly?: boolean;
    // @internal (undocumented)
    expandedNodes?: boolean;
    initialBreadcrumbMode?: BreadcrumbMode;
    initialCurrent?: TreeNodeItem;
    onChildrenLoaded?: (parent: TreeNodeItem, children: TreeNodeItem[]) => void;
    // @internal (undocumented)
    onRender?: () => void;
    onRootNodesLoaded?: (nodes: TreeNodeItem[]) => void;
    parentsOnly?: boolean;
    path?: BreadcrumbPath;
    // @internal (undocumented)
    renderNode?: BreadcrumbNodeRenderer;
    showUpDir?: boolean;
    staticOnly?: boolean;
    width?: number | string;
}

// @beta @deprecated
export class BreadcrumbTreeUtils {
    static aliasNodeListToTableDataProvider(nodes: TreeNodeItem[], columns: ColumnDescription[], treeDataProvider?: TreeDataProvider): TableDataProvider;
    }

// @beta @deprecated
export class BreadcrumbUpdateEvent extends UiEvent<BreadcrumbUpdateEventArgs> {
}

// @beta @deprecated
export interface BreadcrumbUpdateEventArgs {
    // (undocumented)
    currentNode: TreeNodeItem | undefined;
    // (undocumented)
    dataProvider: TreeDataProvider;
    // (undocumented)
    oldDataProvider: TreeDataProvider;
}

// @beta
export interface CategorizedPropertyItem extends FlatGridItemBase {
    // (undocumented)
    readonly derivedRecord: PropertyRecord;
    // (undocumented)
    getChildren(): CategorizedPropertyItem[];
    // (undocumented)
    readonly parentCategorySelectionKey: string;
    // (undocumented)
    readonly parentSelectionKey: string;
    // (undocumented)
    readonly type: CategorizedPropertyTypes;
}

// @beta
export type CategorizedPropertyTypes = FlatGridItemType.Array | FlatGridItemType.Primitive | FlatGridItemType.Struct;

// @beta
export interface CategoryRecordsDict {
    // (undocumented)
    [categoryName: string]: PropertyRecord[];
}

// @public
export interface CellItem {
    alignment?: HorizontalAlignment;
    isDisabled?: boolean;
    key: string;
    // @alpha
    mergedCellsCount?: number;
    record?: PropertyRecord;
    style?: ItemStyle;
}

// @public @deprecated
export interface CellProps {
    // (undocumented)
    displayValue: string;
    // (undocumented)
    item: CellItem;
    // (undocumented)
    render: React.ComponentType<{
        isSelected: boolean;
    }>;
}

// @public
export interface CheckBoxInfo {
    // (undocumented)
    readonly isDisabled: boolean;
    // (undocumented)
    readonly isVisible: boolean;
    // (undocumented)
    readonly state: CheckBoxState;
    // (undocumented)
    readonly tooltip?: string;
}

// @public
export interface CheckboxStateChange {
    newState: CheckBoxState;
    nodeItem: TreeNodeItem;
}

// @public
export interface ColumnDescription {
    editable?: boolean;
    filterable?: boolean;
    filterCaseSensitive?: boolean;
    filterRenderer?: FilterRenderer;
    icon?: boolean;
    key: string;
    label: string;
    propertyDescription?: PropertyDescription;
    resizable?: boolean;
    secondarySortColumn?: number;
    showDistinctValueFilters?: boolean;
    showFieldFilters?: boolean;
    sortable?: boolean;
    sortIgnoreCase?: boolean;
    sortType?: string;
    width?: number;
}

// @public
export interface ColumnFilterDescriptor extends FilterDescriptor {
    distinctFilter: DistinctValuesFilterDescriptor;
    fieldFilter: FieldFilterDescriptor;
}

// @public
export interface CommonPropertyGridProps extends CommonProps {
    actionButtonRenderers?: ActionButtonRenderer[];
    actionButtonWidth?: number;
    // @beta
    horizontalOrientationMinWidth?: number;
    // @beta
    isOrientationFixed?: boolean;
    // @beta
    isPropertyEditingEnabled?: boolean;
    isPropertyHoverEnabled?: boolean;
    isPropertySelectionEnabled?: boolean;
    isPropertySelectionOnRightClickEnabled?: boolean;
    minLabelWidth?: number;
    minValueWidth?: number;
    onPropertyContextMenu?: (args: PropertyGridContextMenuArgs) => void;
    // @beta
    onPropertyEditing?: (args: PropertyEditingArgs, category: PropertyCategory) => void;
    onPropertySelectionChanged?: (property: PropertyRecord) => void;
    // @beta
    onPropertyUpdated?: (args: PropertyUpdatedArgs, category: PropertyCategory) => Promise<boolean>;
    orientation?: Orientation;
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @public
export interface CompletionObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete: () => void;
    // (undocumented)
    error?: (err: any) => void;
    // (undocumented)
    next?: (value: T) => void;
}

// @public
export interface CompositeFilterDescriptor extends FilterDescriptor {
    filterDescriptorCollection: FilterDescriptorCollection;
    logicalOperator: FilterCompositionLogicalOperator;
}

// @public
export interface CompositeFilterDescriptorCollection {
    add(item: FilterDescriptor): void;
    clear(): void;
    count: number;
    evaluateRow(row: RowItem): boolean;
    getColumnFilterDescriptor(columnKey: string): ColumnFilterDescriptor | undefined;
    // @alpha
    getFilterExpression(): string;
    isColumnFilterActive(columnKey: string): boolean;
    logicalOperator: FilterCompositionLogicalOperator;
}

// @public
export enum CompositeFilterType {
    // (undocumented)
    And = 0,
    // (undocumented)
    Or = 1
}

// @public
export class CompositePropertyDataFilterer extends PropertyDataFiltererBase {
    constructor(_leftFilterer: IPropertyDataFilterer, _operator: CompositeFilterType, _rightFilterer: IPropertyDataFilterer);
    // (undocumented)
    categoryMatchesFilter(node: PropertyCategory, parents: PropertyCategory[]): Promise<PropertyDataFilterResult>;
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    recordMatchesFilter(node: PropertyRecord, parents: PropertyRecord[]): Promise<PropertyDataFilterResult>;
    }

// @public
export class CompositeTypeConverter extends TypeConverter {
    // (undocumented)
    convertToString(value?: Primitives.Composite): string | Promise<string>;
    // (undocumented)
    sortCompare(valueA: Primitives.Composite, valueB: Primitives.Composite, ignoreCase?: boolean | undefined): number;
}

// @public
export function computeVisibleNodes(model: TreeModel): VisibleTreeNodes;

// @public
export function ControlledSelectableContent(props: ControlledSelectableContentProps): JSX.Element;

// @public
export interface ControlledSelectableContentProps {
    // (undocumented)
    children: SelectableContentDefinition[];
    // (undocumented)
    onSelectedContentIdChanged?: (contentId: string) => void;
    // (undocumented)
    selectAriaLabel?: string;
    // (undocumented)
    selectedContentId: string;
}

// @public
export function ControlledTree(props: ControlledTreeProps): JSX.Element;

// @public
export interface ControlledTreeProps extends CommonProps {
    descriptionsEnabled?: boolean;
    eventsHandler: TreeEvents;
    height: number;
    iconsEnabled?: boolean;
    model: TreeModel;
    noDataRenderer?: () => React.ReactElement;
    nodeHighlightingProps?: HighlightableTreeProps;
    nodeLoader: ITreeNodeLoader;
    // @beta
    onItemsRendered?: (items: RenderedItemsRange) => void;
    selectionMode: SelectionMode;
    spinnerRenderer?: () => React.ReactElement;
    treeRenderer?: (props: TreeRendererProps) => React.ReactElement;
    width: number;
}

// @public
export namespace ConvertedPrimitives {
    export type Point = Point2d | Point3d;
    export interface Point2d {
        // (undocumented)
        x: number;
        // (undocumented)
        y: number;
    }
    export interface Point3d extends Point2d {
        // (undocumented)
        z: number;
    }
    export type Value = boolean | number | string | Date | Point | Id64String;
}

// @internal
export function convertPrimitiveRecordToString(record: PropertyRecord): string | Promise<string>;

// @internal (undocumented)
export function CustomItem({ item, addGroupSeparator }: {
    item: CustomToolbarItem;
    addGroupSeparator: boolean;
}): JSX.Element | null;

// @alpha
export class CustomNumberEditor extends React.PureComponent<PropertyEditorProps, CustomNumberEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<CustomNumberEditorState>;
    }

// @alpha
export class CustomNumberPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesEscape(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export interface CustomToolbarItem extends CustomButtonDefinition {
    // @deprecated
    buttonNode?: React.ReactNode;
    keepContentsLoaded?: boolean;
    panelContentNode?: React.ReactNode;
}

// @public
export interface DataController {
    // (undocumented)
    commitValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    validateValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @public
export abstract class DataControllerBase implements DataController {
    // (undocumented)
    commitValue(_newValue: PropertyValue, _record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    validateValue(_newValue: PropertyValue, _record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @internal (undocumented)
export interface DataRowItem extends RowItem {
    // (undocumented)
    _node?: TreeNodeItem;
}

// @internal
export function DateField({ initialDate, onDateChange, readOnly, dateFormatter, timeDisplay, style, className }: DateFieldProps): JSX.Element;

// @internal
export interface DateFieldProps extends CommonProps {
    dateFormatter?: DateFormatter;
    initialDate: Date;
    onDateChange?: (day: Date) => void;
    readOnly?: boolean;
    timeDisplay?: TimeDisplay;
}

// @alpha
export function DatePicker(props: DatePickerProps): JSX.Element;

// @alpha
export function DatePickerPopupButton({ displayEditField, timeDisplay, selected, onDateChange, dateFormatter, buttonToolTip, fieldStyle, fieldClassName, style }: DatePickerPopupButtonProps): JSX.Element;

// @alpha
export interface DatePickerPopupButtonProps extends CommonProps {
    buttonToolTip?: string;
    // (undocumented)
    dateFormatter?: DateFormatter;
    displayEditField?: boolean;
    fieldClassName?: string;
    fieldStyle?: React.CSSProperties;
    onDateChange?: (day: Date) => void;
    selected: Date;
    // (undocumented)
    timeDisplay?: TimeDisplay;
}

// @alpha
export interface DatePickerProps {
    onDateChange?: (day: Date) => void;
    selected: Date;
    showFocusOutline?: boolean;
}

// @internal
export class DateTimeEditor extends React.PureComponent<DateTimeEditorProps, DateTimeEditorState> implements TypeEditor {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // (undocumented)
    processDateChange(typeConverter: TypeConverter, newValue: Date): Promise<void>;
    // (undocumented)
    render(): React.ReactNode;
    // (undocumented)
    readonly state: Readonly<DateTimeEditorState>;
}

// @internal
export class DateTimePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class DateTimeTypeConverter extends DateTimeTypeConverterBase {
    // (undocumented)
    protected getTimeFormat(): TimeFormat;
}

// @public
export abstract class DateTimeTypeConverterBase extends TypeConverter implements LessGreaterOperatorProcessor {
    // (undocumented)
    convertFromString(value: string): Date | undefined;
    convertFromStringWithOptions(value: string, options?: {
        [key: string]: any;
    }): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    // (undocumented)
    convertToString(value?: Primitives.Value): string;
    // (undocumented)
    convertToStringWithOptions(value?: Primitives.Value, options?: {
        [key: string]: any;
    }): string | Promise<string>;
    // (undocumented)
    protected abstract getTimeFormat(): TimeFormat;
    // (undocumented)
    static isAlternateDateFormats(type: AlternateDateFormats): boolean;
    // (undocumented)
    isEqualTo(valueA: Date, valueB: Date): boolean;
    // (undocumented)
    isGreaterThan(a: Date, b: Date): boolean;
    // (undocumented)
    isGreaterThanOrEqualTo(a: Date, b: Date): boolean;
    // (undocumented)
    get isLessGreaterType(): boolean;
    // (undocumented)
    isLessThan(a: Date, b: Date): boolean;
    // (undocumented)
    isLessThanOrEqualTo(a: Date, b: Date): boolean;
    // (undocumented)
    isNotEqualTo(valueA: Date, valueB: Date): boolean;
    // (undocumented)
    static isValidTimeDisplay(type: TimeDisplay): boolean;
    // (undocumented)
    sortCompare(valueA: Date, valueB: Date, _ignoreCase?: boolean): number;
}

// @public
export const DEFAULT_LINKS_HANDLER: LinkElementsInfo;

// @public
export interface DelayLoadedTreeNodeItem extends TreeNodeItem {
    // (undocumented)
    hasChildren?: boolean;
}

// @public
export enum Direction {
    // (undocumented)
    Bottom = 4,
    // (undocumented)
    Left = 1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    Top = 2
}

// @internal
export class DirectionHelpers {
    static readonly BOTTOM_CLASS_NAME = "components-direction-bottom";
    // (undocumented)
    static getCssClassName(direction: Direction): string;
    // (undocumented)
    static getOrthogonalDirection(direction: Direction): OrthogonalDirection;
    static readonly LEFT_CLASS_NAME = "components-direction-left";
    static readonly RIGHT_CLASS_NAME = "components-direction-right";
    static readonly TOP_CLASS_NAME = "components-direction-top";
}

// @public
export class DisplayValuePropertyDataFilterer extends PropertyRecordDataFiltererBase {
    constructor(filterText?: string);
    // (undocumented)
    get filterText(): string;
    set filterText(value: string);
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    recordMatchesFilter(node: PropertyRecord): Promise<PropertyDataFilterResult>;
}

// @public
export class DistinctValueCollection {
    constructor();
    // (undocumented)
    get values(): TableDistinctValue[];
    set values(values: TableDistinctValue[]);
    }

// @public
export interface DistinctValuesFilterDescriptor extends FilterDescriptor {
    addDistinctValue(distinctValue: any): void;
    distinctValues: DistinctValueCollection;
    distinctValuesComparisonOperator: FilterOperator;
    filterDescriptorCollection: OperatorValueFilterDescriptorCollection;
    removeDistinctValue(distinctValue: any): boolean;
    tryFindDescriptor(distinctValue: any): FilterDescriptor | undefined;
}

// @public
export class DoublePropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @internal (undocumented)
export class DragAction<Item> {
    constructor(componentSelectionHandler: MultiSelectionHandler<Item>, itemSelectionHandlers: Array<Array<SingleSelectionHandler<Item>>>, firstItem: Item);
    // (undocumented)
    updateDragAction(latestItem: Item): {
        selections: Item[];
        deselections: Item[];
    };
}

// @public
export interface EditableTreeDataProvider extends ITreeDataProvider {
    // (undocumented)
    updateLabel(nodeItem: TreeNodeItem, newLabel: string): void;
}

// @public
export class EditorContainer extends React.PureComponent<EditorContainerProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface EditorContainerProps extends CommonProps {
    // @internal (undocumented)
    ignoreEditorBlur?: boolean;
    onCancel: () => void;
    onCommit: (args: PropertyUpdatedArgs) => void;
    propertyRecord: PropertyRecord;
    setFocus?: boolean;
    title?: string;
}

// @public
export class EnumButtonGroupEditor extends React.Component<PropertyEditorProps, EnumButtonGroupEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumButtonGroupEditorState>;
}

// @public
export class EnumEditor extends React.PureComponent<PropertyEditorProps, EnumEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumEditorState>;
    }

// @public
export class EnumPropertyButtonGroupEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class EnumPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerStopsKeydownPropagation(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class EnumTypeConverter extends TypeConverter {
    // (undocumented)
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Enum): string | Promise<string>;
    // (undocumented)
    sortCompare(a: Primitives.Enum, b: Primitives.Enum, ignoreCase?: boolean): number;
}

// @public
export interface ErrorObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete?: () => void;
    // (undocumented)
    error: (err: any) => void;
    // (undocumented)
    next?: (value: T) => void;
}

// @public
export class FavoritePropertiesRenderer {
    // (undocumented)
    hasFavorites(propertyData: PropertyData): boolean;
    // (undocumented)
    renderFavorites(propertyData: PropertyData, orientation?: Orientation): HTMLElement | string;
}

// @alpha
export function FavoritePropertyList(props: FavoritePropertyListProps): JSX.Element | null;

// @alpha
export interface FavoritePropertyListProps {
    // (undocumented)
    orientation?: Orientation;
    // (undocumented)
    propertyData: PropertyData;
    // (undocumented)
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @public
export interface FieldFilterDescriptor extends FilterDescriptor {
    addFieldValue(fieldValue: any, operator: FilterOperator, isCaseSensitive?: boolean): void;
    filterDescriptorCollection: OperatorValueFilterDescriptorCollection;
    logicalOperator: FilterCompositionLogicalOperator;
    removeFieldValue(fieldValue: any, operator: FilterOperator): boolean;
    tryFindDescriptor(fieldValue: any, operator: FilterOperator): FilterDescriptor | undefined;
}

// @public
export interface FilterableColumn {
    columnFilterDescriptor: ColumnFilterDescriptor;
    createSimpleFilterDescriptor(value: any, filterOperator: FilterOperator): OperatorValueFilterDescriptor;
    filterableTable: FilterableTable;
    filterCaseSensitive: boolean;
    filterMemberKey: string;
    filterMemberType: string;
    getDistinctValues(maximumValueCount?: number): Promise<DistinctValueCollection>;
    isFilterActive: boolean;
    showDistinctValueFilters: boolean;
    showFieldFilters: boolean;
}

// @public
export interface FilterableTable {
    filterDescriptors: CompositeFilterDescriptorCollection;
    getPropertyDisplayValueExpression(property: string): string;
}

// @public
export enum FilterCompositionLogicalOperator {
    // (undocumented)
    And = 0,
    // (undocumented)
    Or = 1
}

// @public
export interface FilterDescriptor {
    clear(): void;
    evaluateRow(row: RowItem): boolean;
    // @alpha
    getFilterExpression(): string;
    isActive: boolean;
    isFilterForColumn(columnKey: string): boolean;
}

// @public
export class FilterDescriptorCollection extends FilterDescriptorCollectionBase<FilterDescriptor> {
}

// @public
export abstract class FilterDescriptorCollectionBase<TDescriptor extends FilterDescriptor> {
    constructor();
    add(item: TDescriptor): void;
    clear(): void;
    get count(): number;
    // (undocumented)
    get descriptors(): TDescriptor[];
    get isActive(): boolean;
    remove(item: TDescriptor): boolean;
}

// @public
export interface FilteredPropertyData extends PropertyData {
    filteredTypes?: FilteredType[];
    getMatchByIndex?: (index: number) => HighlightInfo | undefined;
    matchesCount?: number;
}

// @public
export enum FilteredType {
    // (undocumented)
    Category = 0,
    // (undocumented)
    Label = 1,
    // (undocumented)
    Value = 2
}

// @public
export class FilteringInput extends React.PureComponent<FilteringInputProps, FilteringInputState> {
    constructor(props: FilteringInputProps);
    // @internal (undocumented)
    componentDidUpdate(prevProps: FilteringInputProps): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export interface FilteringInputProps extends CommonProps {
    autoFocus?: boolean;
    onFilterCancel: () => void;
    onFilterClear: () => void;
    onFilterStart: (searchText: string) => void;
    resultSelectorProps?: ResultSelectorProps;
    status: FilteringInputStatus;
}

// @public
export enum FilteringInputStatus {
    FilteringFinished = 2,
    FilteringInProgress = 1,
    ReadyToFilter = 0
}

// @public
export class FilteringPropertyDataProvider implements IPropertyDataProvider, IDisposable {
    constructor(_dataProvider: IPropertyDataProvider, _filterer: IPropertyDataFilterer);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getData(): Promise<FilteredPropertyData>;
    // (undocumented)
    onDataChanged: PropertyDataChangeEvent;
}

// @public
export enum FilterOperator {
    // (undocumented)
    Contains = 9,
    // (undocumented)
    DoesNotContain = 10,
    // (undocumented)
    EndsWith = 8,
    // (undocumented)
    IsContainedIn = 11,
    // (undocumented)
    IsEmpty = 13,
    // (undocumented)
    IsEqualTo = 0,
    // (undocumented)
    IsGreaterThan = 4,
    // (undocumented)
    IsGreaterThanOrEqualTo = 5,
    // (undocumented)
    IsLessThan = 2,
    // (undocumented)
    IsLessThanOrEqualTo = 3,
    // (undocumented)
    IsNotContainedIn = 12,
    // (undocumented)
    IsNotEmpty = 14,
    // (undocumented)
    IsNotEqualTo = 1,
    // (undocumented)
    IsNotNull = 16,
    // (undocumented)
    IsNull = 15,
    // (undocumented)
    Range = 6,
    // (undocumented)
    StartsWith = 7
}

// @public
export enum FilterRenderer {
    // (undocumented)
    MultiSelect = 2,
    // (undocumented)
    MultiValue = 5,
    // (undocumented)
    Numeric = 1,
    // (undocumented)
    SingleSelect = 3,
    // (undocumented)
    Text = 4
}

// @beta
export type FlatGridItem = CategorizedPropertyItem | GridCategoryItem;

// @beta
export interface FlatGridItemBase {
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    getChildren(): FlatGridItem[];
    // (undocumented)
    getDescendantsAndSelf(): FlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): FlatGridItem;
    // (undocumented)
    getVisibleDescendantsAndSelf(): FlatGridItem[];
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly label: string;
    // (undocumented)
    readonly lastInNumberOfCategories: number;
    // (undocumented)
    readonly parentCategorySelectionKey: string | undefined;
    // (undocumented)
    readonly parentSelectionKey: string | undefined;
    // (undocumented)
    readonly selectionKey: string;
    // (undocumented)
    readonly type: FlatGridItemType;
}

// @beta
export enum FlatGridItemType {
    // (undocumented)
    Array = 2,
    // (undocumented)
    Category = 0,
    // (undocumented)
    Primitive = 1,
    // (undocumented)
    Struct = 3
}

// @public
export class FloatTypeConverter extends NumericTypeConverterBase {
    // (undocumented)
    convertFromString(value: string): number;
    // (undocumented)
    convertToString(value?: Primitives.Float): string;
}

// @internal
export function formatInputDate(inputDate: Date, timeDisplay?: TimeDisplay, customFormatter?: DateFormatter, alternateDateFormat?: AlternateDateFormats): string | undefined;

// @public
export function from<T>(iterable: Iterable<T> | PromiseLike<T>): Observable<T>;

// @internal
export function getPropertyKey(propertyCategory: PropertyCategory, propertyRecord: PropertyRecord): string;

// @internal (undocumented)
export function getPropertyRecordAsString(label: PropertyRecord): string;

// @internal (undocumented)
export const getToolbarDirection: (expandsTo: Direction) => OrthogonalDirection;

// @internal
export function getVisibleDescendants(model: TreeModel, parentNode: TreeModelNode | TreeModelRootNode, result?: Array<TreeModelNode | TreeModelNodePlaceholder>): Array<TreeModelNode | TreeModelNodePlaceholder>;

// @beta
export interface GridCategoryItem extends FlatGridItemBase {
    // (undocumented)
    readonly derivedCategory: PropertyCategory;
    // (undocumented)
    getChildCategories(): GridCategoryItem[];
    // (undocumented)
    getDescendantCategoriesAndSelf(): GridCategoryItem[];
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly type: FlatGridItemType.Category;
}

// @internal (undocumented)
export function GroupPopupItem({ item, addGroupSeparator }: {
    item: GroupButton;
    addGroupSeparator: boolean;
}): JSX.Element;

// @internal (undocumented)
export function handleLoadedNodeHierarchy(modelSource: TreeModelSource, loadedHierarchy: LoadedNodeHierarchy): void;

// @public
export const hasChildren: (node: TreeNodeItem) => boolean;

// @public
export const hasSelectionModeFlag: (selectionMode: SelectionMode, flag: SelectionModeFlags) => boolean;

// @public
export class HexadecimalTypeConverter extends TypeConverter {
    // (undocumented)
    convertFromString(value: string): string | undefined;
    // (undocumented)
    convertToString(value?: Primitives.Hexadecimal): string;
    // (undocumented)
    sortCompare(a: Primitives.Hexadecimal, b: Primitives.Hexadecimal): number;
}

// @public
export interface HighlightableTreeNodeProps {
    // (undocumented)
    activeMatchIndex?: number;
    // (undocumented)
    searchText: string;
}

// @public
export interface HighlightableTreeProps {
    // (undocumented)
    activeMatch?: ActiveMatchInfo;
    // (undocumented)
    searchText: string;
}

// @public
export function HighlightedText(props: HighlightedTextProps): JSX.Element;

// @public
export interface HighlightedTextProps {
    // (undocumented)
    activeMatchIndex?: number;
    caseSensitive?: boolean;
    // (undocumented)
    searchText: string;
    // (undocumented)
    text: string;
}

// @public
export interface HighlightInfo {
    // (undocumented)
    highlightedItemIdentifier: string;
    // (undocumented)
    highlightIndex: number;
}

// @public
export interface HighlightingComponentProps {
    // (undocumented)
    activeHighlight?: HighlightInfo;
    // (undocumented)
    highlightedText: string;
}

// @public
export class HighlightingEngine {
    constructor(props: HighlightableTreeProps);
    // (undocumented)
    static readonly ACTIVE_CLASS_NAME = "components-activehighlight";
    // (undocumented)
    createRenderProps(node: {
        id?: string;
    }): HighlightableTreeNodeProps;
    // (undocumented)
    getActiveMatchIndex(node: {
        id?: string;
    }): number | undefined;
    // (undocumented)
    isNodeActive(node: {
        id?: string;
    }): boolean | undefined;
    // (undocumented)
    static renderNodeLabel(text: string, props: HighlightableTreeNodeProps): React.ReactNode;
    }

// @alpha
export class IconEditor extends React.PureComponent<PropertyEditorProps, IconEditorState> implements TypeEditor {
    constructor(props: PropertyEditorProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export class IconPickerButton extends React.PureComponent<IconPickerProps, IconPickerState> {
    // @internal
    constructor(props: IconPickerProps);
    // @internal (undocumented)
    static defaultProps: Partial<IconPickerProps>;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface IconPickerProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    disabled?: boolean;
    dropDownTitle?: string;
    icon: string;
    icons: string[];
    numColumns: number;
    onIconChange?: ((icon: string) => void) | undefined;
    readonly?: boolean;
}

// @alpha
export class IconPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export interface IImageLoader {
    load: (item: any) => Image | undefined;
}

// @public
export type Image = LoadedImage | LoadedBinaryImage;

// @public
export class ImageCheckBoxEditor extends React.PureComponent<PropertyEditorProps, ImageCheckBoxEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ImageCheckBoxEditorState>;
}

// @public
export class ImageCheckBoxPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export type ImageFileFormat = "png" | "jpg" | "jpge";

// @public
export type ImageSourceType = "svg" | "url" | "binary" | "core-icon" | "webfont-icon";

// @public
export interface ImmediatelyLoadedTreeNodeItem extends TreeNodeItem {
    // (undocumented)
    children?: TreeNodeItem[];
}

// @beta
export interface IMutableCategorizedPropertyItem extends IMutableFlatPropertyGridItem {
    // (undocumented)
    readonly derivedRecord: PropertyRecord;
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    readonly parentCategorySelectionKey: string;
    // (undocumented)
    readonly parentSelectionKey: string;
    // (undocumented)
    readonly type: CategorizedPropertyTypes;
}

// @beta
export type IMutableFlatGridItem = IMutableCategorizedPropertyItem | IMutableGridCategoryItem;

// @beta
export interface IMutableFlatPropertyGridItem {
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    getChildren(): IMutableFlatGridItem[];
    // (undocumented)
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): IMutableFlatGridItem;
    // (undocumented)
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly label: string;
    // (undocumented)
    lastInNumberOfCategories: number;
    // (undocumented)
    readonly parentCategorySelectionKey: string | undefined;
    // (undocumented)
    readonly parentSelectionKey: string | undefined;
    // (undocumented)
    readonly selectionKey: string;
    // (undocumented)
    readonly type: FlatGridItemType;
}

// @beta
export interface IMutableGridCategoryItem extends IMutableFlatPropertyGridItem {
    // (undocumented)
    derivedCategory: PropertyCategory;
    // (undocumented)
    getChildCategories(): IMutableGridCategoryItem[];
    // (undocumented)
    getDescendantCategoriesAndSelf(): IMutableGridCategoryItem[];
    // (undocumented)
    isRootCategory: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    type: FlatGridItemType.Category;
}

// @beta
export interface IMutableGridItemFactory {
    // (undocumented)
    createCategorizedProperty: (record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string) => IMutableCategorizedPropertyItem;
    // (undocumented)
    createGridCategory: (category: PropertyCategory, recordsDict: CategoryRecordsDict, parentSelectionKey?: string, depth?: number) => IMutableGridCategoryItem;
}

// @beta
export interface IMutablePropertyGridModel {
    // (undocumented)
    getFlatGrid: () => IMutableFlatGridItem[];
    // (undocumented)
    getItem: (selectionKey: string) => IMutableFlatGridItem;
    // (undocumented)
    getRootCategories: () => IMutableGridCategoryItem[];
    // (undocumented)
    getVisibleFlatGrid: () => IMutableFlatGridItem[];
}

// @internal (undocumented)
export class InputSwitchComponent extends React.PureComponent<InputSwitchProps> {
    // (undocumented)
    render(): React.ReactNode;
}

// @internal (undocumented)
export interface InputSwitchProps {
    // (undocumented)
    currentMode: BreadcrumbMode;
    // (undocumented)
    delimiter: string;
    // (undocumented)
    expandedNode?: boolean;
    // (undocumented)
    node?: BeInspireTreeNode<TreeNodeItem>;
    // (undocumented)
    onInputCancel: () => void;
    // (undocumented)
    onInputStart?: () => void;
    // (undocumented)
    onNodeChange: (node?: TreeNodeItem) => void;
    // (undocumented)
    parentsOnly?: boolean;
    // (undocumented)
    pathString: string;
    // (undocumented)
    renderNode?: BreadcrumbNodeRenderer;
    // (undocumented)
    showUpDir?: boolean;
    // (undocumented)
    tree: BeInspireTree<TreeNodeItem>;
    // (undocumented)
    width: number | string;
}

// @alpha
export class IntlFormatter implements DateFormatter {
    constructor(_intlFormatter?: Intl.DateTimeFormat | undefined);
    // (undocumented)
    formateDate(day: Date): string;
    // (undocumented)
    get formatter(): Intl.DateTimeFormat;
    }

// @public
export class IntTypeConverter extends NumericTypeConverterBase {
    // (undocumented)
    convertFromString(value: string): number;
    // (undocumented)
    convertToString(value?: Primitives.Int): string;
}

// @public
export interface IPropertyDataFilterer {
    // (undocumented)
    categoryMatchesFilter: (node: PropertyCategory, parents: PropertyCategory[]) => Promise<PropertyDataFilterResult>;
    // (undocumented)
    readonly isActive: boolean;
    // (undocumented)
    onFilterChanged: PropertyFilterChangeEvent;
    // (undocumented)
    recordMatchesFilter: (node: PropertyRecord, parents: PropertyRecord[]) => Promise<PropertyDataFilterResult>;
}

// @public
export interface IPropertyDataProvider {
    getData: (() => Promise<PropertyData>);
    onDataChanged: PropertyDataChangeEvent;
}

// @beta
export interface IPropertyGridEventHandler {
    // (undocumented)
    onExpansionToggled: (selectionKey: string) => void;
}

// @beta
export interface IPropertyGridModel {
    // (undocumented)
    getFlatGrid: () => FlatGridItem[];
    // (undocumented)
    getItem: (selectionKey: string) => FlatGridItem;
    // (undocumented)
    getRootCategories: () => GridCategoryItem[];
    // (undocumented)
    getVisibleFlatGrid: () => FlatGridItem[];
}

// @beta (undocumented)
export interface IPropertyGridModelSource {
    // (undocumented)
    getModel(): IPropertyGridModel | undefined;
    // (undocumented)
    modifyModel(callback: (model: IMutablePropertyGridModel) => void): void;
    // (undocumented)
    onModelChanged: PropertyGridModelChangeEvent;
    // (undocumented)
    setPropertyData: (data: PropertyData) => void;
}

// @public
export interface IPropertyValueRenderer {
    canRender: (record: PropertyRecord, context?: PropertyValueRendererContext) => boolean;
    render: (record: PropertyRecord, context?: PropertyValueRendererContext) => React.ReactNode;
}

// @internal
export function isCustomToolbarItem(item: ToolbarItem): item is CustomToolbarItem;

// @public
export const isTreeDataProviderInterface: (provider: TreeDataProvider) => provider is ITreeDataProvider;

// @public
export const isTreeDataProviderMethod: (provider: TreeDataProvider) => provider is TreeDataProviderMethod;

// @public
export const isTreeDataProviderPromise: (provider: TreeDataProvider) => provider is TreeDataProviderPromise;

// @public
export const isTreeDataProviderRaw: (provider: TreeDataProvider) => provider is TreeDataProviderRaw;

// @public
export function isTreeModelNode(obj: TreeModelNodeType | undefined): obj is TreeModelNode;

// @public
export function isTreeModelNodePlaceholder(obj: TreeModelNodeType | undefined): obj is TreeModelNodePlaceholder;

// @public
export function isTreeModelRootNode(obj: TreeModelNodeType | undefined): obj is TreeModelRootNode;

// @public
export interface ItemColorOverrides {
    backgroundColor?: number;
    backgroundColorSelected?: number;
    color?: number;
    colorSelected?: number;
}

// @public
export interface ItemStyle {
    colorOverrides?: ItemColorOverrides;
    isBold?: boolean;
    isItalic?: boolean;
}

// @public
export const ItemStyleProvider: {
    createStyle: ({ colorOverrides, isBold, isItalic }: ItemStyle, isSelected?: boolean | undefined) => CSSProperties;
};

// @public
export interface ITreeDataProvider {
    // (undocumented)
    getNodes(parent?: TreeNodeItem, page?: PageOptions): Promise<DelayLoadedTreeNodeItem[]>;
    // (undocumented)
    getNodesCount(parent?: TreeNodeItem): Promise<number>;
    // @deprecated (undocumented)
    onTreeNodeChanged?: BeEvent<TreeDataChangesListener>;
}

// @public
export interface ITreeImageLoader extends IImageLoader {
    // (undocumented)
    load: (item: TreeNodeItem) => LoadedImage | undefined;
}

// @public
export interface ITreeNodeLoader {
    loadNode(parentId: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<TreeNodeLoadResult>;
}

// @public
export interface ITreeNodeLoaderWithProvider<TDataProvider extends TreeDataProvider> extends ITreeNodeLoader {
    readonly dataProvider: TDataProvider;
}

// @public
export class LabelPropertyDataFilterer extends PropertyRecordDataFiltererBase {
    constructor(filterText?: string);
    // (undocumented)
    get filterText(): string;
    set filterText(value: string);
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    recordMatchesFilter(node: PropertyRecord): Promise<PropertyDataFilterResult>;
}

// @public
export interface LessGreaterOperatorProcessor {
    isGreaterThan(a: Primitives.Value, b: Primitives.Value): boolean;
    isGreaterThanOrEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
    isLessThan(a: Primitives.Value, b: Primitives.Value): boolean;
    isLessThanOrEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
}

// @alpha
export function LinksRenderer(props: LinksRendererProps): JSX.Element;

// @alpha
export interface LinksRendererProps {
    // (undocumented)
    highlighter?: (text: string) => React.ReactNode;
    // (undocumented)
    links?: LinkElementsInfo;
    // (undocumented)
    value: string;
}

// @public
export interface LoadedBinaryImage extends LoadedImage {
    // (undocumented)
    fileFormat: ImageFileFormat;
}

// @public
export interface LoadedImage {
    // (undocumented)
    sourceType: ImageSourceType;
    // (undocumented)
    value: string;
}

// @public
export interface LoadedNodeHierarchy {
    hierarchyItems: LoadedNodeHierarchyItem[];
    numChildren?: number;
    offset: number;
    parentId: string | undefined;
}

// @public
export interface LoadedNodeHierarchyItem {
    children?: LoadedNodeHierarchyItem[];
    item: TreeNodeItemData;
    numChildren?: number;
}

// @public
export const matchLinks: (text: string) => Array<{
    index: number;
    lastIndex: number;
    schema: string;
    url: string;
}>;

// @public
export class MergedPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(_record: PropertyRecord, context?: PropertyValueRendererContext): import("react").ReactNode;
}

// @internal (undocumented)
export class MultilineTextPropertyValueRenderer implements IPropertyValueRenderer {
    // (undocumented)
    canRender(record: PropertyRecord): boolean;
    // (undocumented)
    render(record: PropertyRecord, context?: PropertyValueRendererContext): React.ReactNode;
}

// @internal (undocumented)
export const MultilineTextRenderer: React.FC<MultilineTextRenderer_2>;

// @internal
export interface MultiSelectionHandler<TItem> {
    areEqual: (item1: TItem, item2: TItem) => boolean;
    deselectAll: () => void;
    selectBetween: (item1: TItem, item2: TItem) => TItem[];
    updateSelection: (selections: TItem[], deselections: TItem[]) => void;
}

// @beta
export class MutableCategorizedArrayProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, gridItemFactory: IMutableGridItemFactory, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getVisibleDescendants(): IMutableFlatGridItem[];
    // (undocumented)
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    get type(): FlatGridItemType.Array;
}

// @beta
export class MutableCategorizedPrimitiveProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    get type(): FlatGridItemType.Primitive;
}

// @beta
export abstract class MutableCategorizedProperty extends MutableFlatPropertyGridItem implements Partial<IMutableCategorizedPropertyItem> {
    constructor(type: CategorizedPropertyTypes, record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string);
    get derivedRecord(): PropertyRecord;
    // (undocumented)
    abstract getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    getSelf(): IMutableCategorizedPropertyItem;
    // (undocumented)
    get label(): string;
    // (undocumented)
    get parentCategorySelectionKey(): string;
    // (undocumented)
    get parentSelectionKey(): string;
    get selectionKey(): string;
    // (undocumented)
    abstract type: CategorizedPropertyTypes;
    }

// @beta
export class MutableCategorizedStructProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, gridItemFactory: IMutableGridItemFactory, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getVisibleDescendants(): IMutableFlatGridItem[];
    // (undocumented)
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    get type(): FlatGridItemType.Struct;
}

// @public
export interface MutableCheckBoxInfo extends CheckBoxInfo {
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    isVisible: boolean;
    // (undocumented)
    state: CheckBoxState;
    // (undocumented)
    tooltip?: string;
}

// @beta
export abstract class MutableFlatPropertyGridItem implements IMutableFlatPropertyGridItem {
    // (undocumented)
    [immerable]: boolean;
    constructor(_depth: number, _parentSelectionKey: string | undefined, _parentCategorySelectionKey: string | undefined);
    // (undocumented)
    get depth(): number;
    // (undocumented)
    abstract getChildren(): IMutableFlatGridItem[];
    // (undocumented)
    protected getDescendants(): IMutableFlatGridItem[];
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): IMutableFlatGridItem;
    // (undocumented)
    abstract getSelf(): IMutableFlatGridItem;
    getVisibleDescendants(): IMutableFlatGridItem[];
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    get isExpanded(): boolean;
    set isExpanded(value: boolean);
    // (undocumented)
    protected _isExpanded: boolean;
    // @internal
    get isLastInRootCategory(): boolean;
    set isLastInRootCategory(value: boolean);
    // (undocumented)
    protected _isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    abstract label: string;
    // @internal
    get lastInNumberOfCategories(): number;
    set lastInNumberOfCategories(value: number);
    // (undocumented)
    protected _lastInNumberOfCategories: number;
    // (undocumented)
    get parentCategorySelectionKey(): string | undefined;
    // (undocumented)
    get parentSelectionKey(): string | undefined;
    // (undocumented)
    abstract selectionKey: string;
    // (undocumented)
    abstract type: FlatGridItemType;
}

// @beta
export class MutableGridCategory extends MutableFlatPropertyGridItem implements IMutableGridCategoryItem {
    constructor(category: PropertyCategory, recordsDict: CategoryRecordsDict, gridItemFactory: IMutableGridItemFactory, parentSelectionKey?: string, depth?: number);
    // (undocumented)
    get derivedCategory(): PropertyCategory;
    // (undocumented)
    getChildCategories(): IMutableGridCategoryItem[];
    // (undocumented)
    getChildren(): IMutableFlatGridItem[];
    getDescendantCategoriesAndSelf(): IMutableGridCategoryItem[];
    // (undocumented)
    getSelf(): this;
    get isRootCategory(): boolean;
    // (undocumented)
    get label(): string;
    // @internal
    get lastInNumberOfCategories(): number;
    set lastInNumberOfCategories(value: number);
    // (undocumented)
    get name(): string;
    // (undocumented)
    get selectionKey(): string;
    // (undocumented)
    get type(): FlatGridItemType.Category;
}

// @beta
export class MutableGridItemFactory implements IMutableGridItemFactory {
    // (undocumented)
    protected createArrayProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedArrayProperty;
    createCategorizedProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): IMutableCategorizedPropertyItem;
    createGridCategory(category: PropertyCategory, recordsDict: CategoryRecordsDict, parentSelectionKey?: string, depth?: number): IMutableGridCategoryItem;
    // (undocumented)
    protected createPrimitiveProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedPrimitiveProperty;
    // (undocumented)
    protected createStructProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedStructProperty;
}

// @beta
export class MutablePropertyGridModel implements IPropertyGridModel, IMutablePropertyGridModel {
    // (undocumented)
    [immerable]: boolean;
    constructor(propertyData: PropertyData, _gridItemFactory: IMutableGridItemFactory);
    getFlatGrid(): IMutableFlatGridItem[];
    getItem(selectionKey: string): IMutableFlatGridItem;
    getRootCategories(): IMutableGridCategoryItem[];
    getVisibleFlatGrid(): IMutableFlatGridItem[];
    }

// @public
export interface MutableTableDataProvider extends TableDataProvider {
    addRow(rowItem: RowItem): number;
    deleteRow(rowItem: RowItem): void;
    insertRow(rowItem: RowItem, index: number): number;
    moveRow(rowItem: RowItem, newIndex: number): number;
}

// @beta @deprecated
export interface MutableTreeDataProvider extends ITreeDataProvider {
    // (undocumented)
    getNodeIndex(parent: TreeNodeItem | undefined, child: TreeNodeItem): number;
    // (undocumented)
    insertNode(parent: TreeNodeItem | undefined, child: TreeNodeItem, index?: number): void;
    // (undocumented)
    isDescendent(parent: TreeNodeItem | undefined, nodeItem: TreeNodeItem): boolean;
    // (undocumented)
    moveNode(parent: TreeNodeItem | undefined, newParent: TreeNodeItem | undefined, child: TreeNodeItem, index?: number): void;
    // (undocumented)
    removeNode(parent: TreeNodeItem | undefined, child: TreeNodeItem): void;
}

// @public
export class MutableTreeModel implements TreeModel {
    // (undocumented)
    [immerable]: boolean;
    changeNodeId(currentId: string, newId: string): boolean;
    clearChildren(parentId: string | undefined): void;
    getChildOffset(parentId: string | undefined, childId: string): number | undefined;
    getChildren(parentId: string | undefined): SparseArray<string> | undefined;
    getNode(id: string): MutableTreeModelNode | undefined;
    // (undocumented)
    getNode(parentId: string | undefined, childIndex: number): MutableTreeModelNode | TreeModelNodePlaceholder | undefined;
    getRootNode(): TreeModelRootNode;
    insertChild(parentId: string | undefined, childNodeInput: TreeModelNodeInput, offset: number): void;
    iterateTreeModelNodes(parentId?: string): IterableIterator<MutableTreeModelNode>;
    moveNode(sourceNodeId: string, targetParentId: string | undefined, targetIndex: number): boolean;
    removeChild(parentId: string | undefined, child: string | number): void;
    setChildren(parentId: string | undefined, nodeInputs: TreeModelNodeInput[], offset: number): void;
    setNumChildren(parentId: string | undefined, numChildren: number | undefined): void;
    }

// @public
export interface MutableTreeModelNode extends TreeModelNode {
    // (undocumented)
    checkbox: MutableCheckBoxInfo;
    // (undocumented)
    description: string;
    editingInfo?: TreeModelNodeEditingInfo;
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    isLoading: boolean;
    // (undocumented)
    isSelected: boolean;
    // (undocumented)
    item: TreeNodeItem;
    // (undocumented)
    label: PropertyRecord;
}

// @public
export class NavigationPropertyTypeConverter extends TypeConverter {
    // (undocumented)
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Value): string;
    // (undocumented)
    sortCompare(a: Primitives.Value, b: Primitives.Value, ignoreCase?: boolean): number;
}

// @public
export class NavigationPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @public
export interface NextObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete?: () => void;
    // (undocumented)
    error?: (err: any) => void;
    // (undocumented)
    next: (value: T) => void;
}

// @internal (undocumented)
export interface Node {
    // (undocumented)
    readonly id: string;
}

// @public
export class NonPrimitivePropertyLabelRenderer extends React.PureComponent<NonPrimitivePropertyLabelRendererProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface NonPrimitivePropertyLabelRendererProps extends PrimitivePropertyLabelRendererProps {
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    onCollapse: () => void;
    // (undocumented)
    onExpand: () => void;
}

// @public
export class NonPrimitivePropertyRenderer extends React.Component<NonPrimitivePropertyRendererProps, NonPrimitivePropertyRendererState> {
    constructor(props: NonPrimitivePropertyRendererProps);
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: NonPrimitivePropertyRendererState;
}

// @public
export interface NonPrimitivePropertyRendererProps extends PrimitiveRendererProps {
    isCollapsible?: boolean;
}

// @public
export interface NullableOperatorProcessor {
    isNotNull(value: Primitives.Value): boolean;
    isNull(value: Primitives.Value): boolean;
}

// @public
export class NumericInputEditor extends React.PureComponent<PropertyEditorProps, NumericInputEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    hasFocus: boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<NumericInputEditorState>;
    }

// @public
export class NumericInputPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export abstract class NumericTypeConverterBase extends TypeConverter implements LessGreaterOperatorProcessor {
    // (undocumented)
    isGreaterThan(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    isGreaterThanOrEqualTo(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    get isLessGreaterType(): boolean;
    // (undocumented)
    isLessThan(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    isLessThanOrEqualTo(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    sortCompare(a: Primitives.Numeric, b: Primitives.Numeric, _ignoreCase?: boolean): number;
}

// @public
export interface Observable<T> extends Subscribable<T> {
}

// @public
export type Observer<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;

// @public
export type OnItemsDeselectedCallback<Item> = (items: Item[]) => void | boolean;

// @public
export type OnItemsSelectedCallback<TItem> = (items: TItem[], replace: boolean) => void | boolean;

// @public
export type OnSelectionChanged = (shiftDown?: boolean, ctrlDown?: boolean) => void;

// @public
export interface OperatorProcessor {
    isEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
    isNotEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
}

// @public
export interface OperatorValueFilterDescriptor extends FilterDescriptor {
    isCaseSensitive: boolean;
    memberKey: string;
    memberType: string;
    operator: FilterOperator;
    value: any;
}

// @public
export class OperatorValueFilterDescriptorCollection extends FilterDescriptorCollectionBase<OperatorValueFilterDescriptor> {
}

// @alpha
export enum OrthogonalDirection {
    // (undocumented)
    Horizontal = 1,
    // (undocumented)
    Vertical = 0
}

// @internal
export class OrthogonalDirectionHelpers {
    // (undocumented)
    static getCssClassName(direction: OrthogonalDirection): string;
    static readonly HORIZONTAL_CLASS_NAME = "components-horizontal";
    // (undocumented)
    static inverse(direction: OrthogonalDirection): OrthogonalDirection;
    static readonly VERTICAL_CLASS_NAME = "components-vertical";
}

// @public
export class PagedTreeNodeLoader<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoaderWithProvider<TDataProvider> implements IDisposable {
    constructor(dataProvider: TDataProvider, modelSource: TreeModelSource, pageSize: number);
    dispose(): void;
    protected load(parentNode: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<LoadedNodeHierarchy>;
    get pageSize(): number;
    }

// @public
export interface PageOptions {
    // (undocumented)
    size?: number;
    // (undocumented)
    start?: number;
}

// @public
export const ParsedInput: (props: ParsedInputProps) => JSX.Element | null;

// @public
export interface ParsedInputProps extends CommonProps {
    formatValue: (value: number) => string;
    initialValue: number;
    onChange?: (newValue: number) => void;
    parseString: (stringValue: string) => ParseResults;
    readonly?: boolean;
    ref?: React.Ref<HTMLInputElement>;
}

// @public
export class Point2dTypeConverter extends BasePointTypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    protected constructPoint(values: Primitives.Point): ConvertedPrimitives.Point2d | undefined;
    // (undocumented)
    protected getVectorLength(point: Primitives.Point): number | undefined;
}

// @public
export class Point3dTypeConverter extends BasePointTypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    protected constructPoint(values: Primitives.Point): ConvertedPrimitives.Point3d | undefined;
    // (undocumented)
    protected getVectorLength(point: Primitives.Point): number | undefined;
}

// @public
export function PopupItem(props: PopupItemProps): JSX.Element;

// @internal (undocumented)
export function PopupItemPopup(props: PopupItemPopupProps): JSX.Element;

// @public
export interface PopupItemProps extends ToolbarButtonItemProps {
    hideIndicator?: boolean;
    keepContentsMounted?: boolean;
    panel?: React.ReactNode;
}

// @public
export function PopupItemWithDrag(props: PopupItemWithDragProps): JSX.Element;

// @public
export interface PopupItemWithDragProps extends ToolbarButtonItemProps {
    groupItem: GroupButton;
}

// @public
export class PrimitivePropertyLabelRenderer extends React.PureComponent<PrimitivePropertyLabelRendererProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface PrimitivePropertyLabelRendererProps extends PropertyLabelRendererProps {
    className?: string;
    offset?: number;
}

// @public
export class PrimitivePropertyRenderer extends React.Component<PrimitiveRendererProps> {
    constructor(props: PrimitiveRendererProps);
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export class PrimitivePropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @internal (undocumented)
export function PrimitivePropertyValueRendererImpl(props: PrimitivePropertyValueRendererImplProps): JSX.Element;

// @public
export interface PrimitiveRendererProps extends SharedRendererProps {
    highlight?: HighlightingComponentProps;
    indentation?: number;
    valueElement?: React.ReactNode;
    valueElementRenderer?: () => React.ReactNode;
}

// @public
export interface PropertyCategory {
    // (undocumented)
    childCategories?: PropertyCategory[];
    // (undocumented)
    expand: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    renderer?: {
        name: string;
    };
}

// @public
export class PropertyCategoryBlock extends React.Component<PropertyCategoryBlockProps> {
    constructor(props: PropertyCategoryBlockProps);
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @public
export interface PropertyCategoryBlockProps extends CommonProps {
    category: PropertyCategory;
    highlight?: HighlightingComponentProps;
    onExpansionToggled?: (categoryName: string) => void;
}

// @public
export abstract class PropertyCategoryDataFiltererBase extends PropertyDataFiltererBase {
    // (undocumented)
    recordMatchesFilter(): Promise<PropertyDataFilterResult>;
}

// @public
export class PropertyCategoryLabelFilterer extends PropertyCategoryDataFiltererBase {
    constructor(filterText?: string);
    // (undocumented)
    categoryMatchesFilter(node: PropertyCategory): Promise<PropertyDataFilterResult>;
    // (undocumented)
    get filterText(): string;
    set filterText(value: string);
    // (undocumented)
    get isActive(): boolean;
}

// @beta
export type PropertyCategoryRenderer = (categoryItem: GridCategoryItem) => React.ComponentType<PropertyCategoryRendererProps> | undefined;

// @beta
export class PropertyCategoryRendererManager {
    addRenderer(rendererName: string, categoryRenderer: PropertyCategoryRenderer, override?: boolean): void;
    // (undocumented)
    static defaultManager: PropertyCategoryRendererManager;
    getCategoryComponent(categoryItem: GridCategoryItem): React.ComponentType<PropertyCategoryRendererProps> | undefined;
    removeRenderer(rendererName: string): void;
}

// @beta
export interface PropertyCategoryRendererProps {
    categoryItem: GridCategoryItem;
    gridContext: VirtualizedPropertyGridContext;
    onHeightChanged: (newHeight: number) => void;
}

// @public
export enum PropertyContainerType {
    // (undocumented)
    PropertyPane = "pane",
    // (undocumented)
    Table = "table",
    // (undocumented)
    Tree = "tree"
}

// @public
export interface PropertyData {
    // (undocumented)
    categories: PropertyCategory[];
    // (undocumented)
    description?: string;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    records: {
        [categoryName: string]: PropertyRecord[];
    };
    // @alpha
    reusePropertyDataState?: boolean;
}

// @public
export class PropertyDataChangeEvent extends BeEvent<PropertyDataChangesListener> {
}

// @public
export type PropertyDataChangesListener = () => void;

// @public
export abstract class PropertyDataFiltererBase implements IPropertyDataFilterer {
    // (undocumented)
    abstract categoryMatchesFilter(node: PropertyCategory, parents: PropertyCategory[]): Promise<PropertyDataFilterResult>;
    // (undocumented)
    abstract get isActive(): boolean;
    // (undocumented)
    onFilterChanged: PropertyFilterChangeEvent;
    // (undocumented)
    abstract recordMatchesFilter(node: PropertyRecord, parents: PropertyRecord[]): Promise<PropertyDataFilterResult>;
}

// @public
export interface PropertyDataFilterResult {
    filteredTypes?: FilteredType[];
    matchesCount?: number;
    matchesFilter: boolean;
    shouldExpandNodeParents?: boolean;
    shouldForceIncludeDescendants?: boolean;
}

// @public
export interface PropertyDialogState {
    // (undocumented)
    content: React.ReactNode;
    // (undocumented)
    title: string;
}

// @public
export interface PropertyEditingArgs {
    propertyKey?: string;
    propertyRecord: PropertyRecord;
}

// @public
export abstract class PropertyEditorBase implements DataController {
    // (undocumented)
    applyEditorParams(_property: PropertyDescription, _record: PropertyRecord): void;
    // (undocumented)
    commitValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesEscape(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get containerStopsKeydownPropagation(): boolean;
    // (undocumented)
    customDataController: DataController | undefined;
    // (undocumented)
    abstract get reactNode(): React.ReactNode;
    // (undocumented)
    validateValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @public
export class PropertyEditorManager {
    // (undocumented)
    static createEditor(editType: string, editorName?: string, dataControllerName?: string): PropertyEditorBase;
    // @internal (undocumented)
    static deregisterDataController(controllerName: string): void;
    // (undocumented)
    static hasCustomEditor(editType: string, editorName: string): boolean;
    // (undocumented)
    static registerDataController(controllerName: string, controller: new () => DataControllerBase): void;
    // (undocumented)
    static registerEditor(editType: string, editor: new () => PropertyEditorBase, editorName?: string): void;
}

// @public
export interface PropertyEditorProps extends CommonProps {
    onBlur?: (event: React.FocusEvent) => void;
    onCancel?: () => void;
    onCommit?: (args: PropertyUpdatedArgs) => void;
    propertyRecord?: PropertyRecord;
    setFocus?: boolean;
}

// @public
export class PropertyFilterChangeEvent extends BeEvent<PropertyFilterChangesListener> {
}

// @public
export type PropertyFilterChangesListener = () => void;

// @public
export class PropertyGrid extends React.Component<PropertyGridProps, PropertyGridState> {
    // @internal
    constructor(props: PropertyGridProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: PropertyGridProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @public @deprecated
export interface PropertyGridCategory {
    // (undocumented)
    properties: PropertyRecord[];
    // (undocumented)
    propertyCategory: PropertyCategory;
    // (undocumented)
    propertyCount: number;
}

// @internal (undocumented)
export class PropertyGridCommons {
    // (undocumented)
    static getCurrentOrientation(width: number, preferredOrientation?: Orientation, isOrientationFixed?: boolean, horizontalOrientationMinWidth?: number): Orientation;
    static getLinks: (value: string) => Array<{
        start: number;
        end: number;
    }>;
    static handleLinkClick(text: string): void;
}

// @public
export interface PropertyGridContextMenuArgs {
    event: React_2.MouseEvent;
    propertyRecord: PropertyRecord;
}

// @beta
export class PropertyGridEventHandler {
    constructor(_modelSource: IPropertyGridModelSource);
    onExpansionToggled: (selectionKey: string) => void;
}

// @internal (undocumented)
export type PropertyGridEventsRelatedProps = Pick<PropertyListProps, "onPropertyClicked" | "onPropertyRightClicked" | "onPropertyContextMenu" | "onEditCommit" | "onEditCancel" | "selectedPropertyKey" | "editingPropertyKey"> & Pick<CommonPropertyGridProps, "isPropertySelectionOnRightClickEnabled" | "isPropertyEditingEnabled"> & Required<Pick<CommonPropertyGridProps, "isPropertyHoverEnabled" | "isPropertySelectionEnabled">>;

// @internal
export class PropertyGridEventsRelatedPropsSupplier extends React.Component<PropertyGridEventsRelatedPropsSupplierProps, PropertyGridEventsRelatedPropsSupplierState> {
    constructor(props: PropertyGridEventsRelatedPropsSupplierProps);
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export type PropertyGridEventsRelatedPropsSupplierProps = Pick<CommonPropertyGridProps, "onPropertyContextMenu" | "isPropertySelectionOnRightClickEnabled" | "isPropertySelectionOnRightClickEnabled" | "onPropertySelectionChanged" | "isPropertyEditingEnabled" | "onPropertyUpdated"> & Required<Pick<CommonPropertyGridProps, "isPropertyHoverEnabled" | "isPropertySelectionEnabled">> & {
    children: (context: PropertyGridEventsRelatedProps) => React.ReactNode;
};

// @internal
export interface PropertyGridInternalContext {
    // (undocumented)
    className?: string;
    // (undocumented)
    gridContext: VirtualizedPropertyGridContext;
    // (undocumented)
    gridEventHandler: IPropertyGridEventHandler;
    // (undocumented)
    gridItems: FlatGridItem[];
    // (undocumented)
    gridModel: IPropertyGridModel;
    // (undocumented)
    onItemHeightChanged: (index: number, key: string, height: number) => void;
    // (undocumented)
    style?: React.CSSProperties;
}

// @beta
export class PropertyGridModelChangeEvent extends BeEvent<PropertyGridModelChangeListener> {
}

// @beta
export type PropertyGridModelChangeListener = () => void;

// @beta
export class PropertyGridModelSource implements IPropertyGridModelSource {
    constructor(_gridFactory: IMutableGridItemFactory);
    getModel(): IPropertyGridModel | undefined;
    modifyModel(callback: (model: IMutablePropertyGridModel) => void): void;
    onModelChanged: PropertyGridModelChangeEvent;
    // (undocumented)
    setPropertyData(data: PropertyData): void;
}

// @public
export interface PropertyGridProps extends CommonPropertyGridProps {
    dataProvider: IPropertyDataProvider;
}

// @internal (undocumented)
export class PropertyLabelRenderer extends React.PureComponent<PropertyLabelRendererProps> {
    static getStyle(offset?: number): React.CSSProperties;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface PropertyLabelRendererProps {
    children: string | JSX.Element;
    renderColon?: boolean;
    tooltip?: string;
}

// @public
export class PropertyList extends React.Component<PropertyListProps> {
    constructor(props: PropertyListProps);
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface PropertyListProps extends CommonProps {
    actionButtonRenderers?: ActionButtonRenderer[];
    // (undocumented)
    category?: PropertyCategory;
    columnInfo?: PropertyGridColumnInfo;
    // (undocumented)
    columnRatio?: number;
    // (undocumented)
    editingPropertyKey?: string;
    isPropertyHoverEnabled?: boolean;
    isPropertyRightClickSelectionEnabled?: boolean;
    isPropertySelectionEnabled?: boolean;
    isResizeHandleBeingDragged?: boolean;
    isResizeHandleHovered?: boolean;
    onColumnChanged?: (ratio: number) => void | RatioChangeResult;
    // (undocumented)
    onEditCancel?: () => void;
    // (undocumented)
    onEditCommit?: (args: PropertyUpdatedArgs, category: PropertyCategory) => void;
    // (undocumented)
    onPropertyClicked?: (property: PropertyRecord, key?: string) => void;
    // (undocumented)
    onPropertyContextMenu?: (property: PropertyRecord, e: React.MouseEvent) => void;
    // (undocumented)
    onPropertyRightClicked?: (property: PropertyRecord, key?: string) => void;
    onResizeHandleDragChanged?: (isDragStarted: boolean) => void;
    onResizeHandleHoverChanged?: (isHovered: boolean) => void;
    // (undocumented)
    orientation: Orientation;
    // (undocumented)
    properties: PropertyRecord[];
    // (undocumented)
    propertyValueRendererManager?: PropertyValueRendererManager;
    // (undocumented)
    selectedPropertyKey?: string;
    // (undocumented)
    width: number;
}

// @public
export interface PropertyPopupState {
    // (undocumented)
    content: React.ReactNode;
    // (undocumented)
    fixedPosition: {
        top: number;
        left: number;
    };
}

// @public
export abstract class PropertyRecordDataFiltererBase extends PropertyDataFiltererBase {
    // (undocumented)
    categoryMatchesFilter(): Promise<PropertyDataFilterResult>;
}

// @public
export class PropertyRenderer extends React.Component<PropertyRendererProps, PropertyRendererState> {
    constructor(props: PropertyRendererProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyRendererProps): void;
    // (undocumented)
    static getLabelOffset(indentation?: number, orientation?: Orientation, width?: number, columnRatio?: number, minColumnLabelWidth?: number): number;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<PropertyRendererState>;
    updateDisplayValueAsEditor(props: PropertyRendererProps): void;
}

// @public
export interface PropertyRendererProps extends SharedRendererProps {
    highlight?: HighlightingComponentProps;
    indentation?: number;
    isEditing?: boolean;
    onEditCancel?: () => void;
    onEditCommit?: (args: PropertyUpdatedArgs) => void;
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @public
export interface PropertyUpdatedArgs {
    newValue: PropertyValue;
    propertyRecord: PropertyRecord;
}

// @public
export interface PropertyValueRendererContext {
    containerType?: string;
    defaultValue?: React.ReactNode;
    isExpanded?: boolean;
    onDialogOpen?: (dialogState: PropertyDialogState) => void;
    onExpansionToggled?: () => void;
    onHeightChanged?: (newHeight: number) => void;
    onPopupHide?: () => void;
    onPopupShow?: (popupState: PropertyPopupState) => void;
    orientation?: Orientation;
    style?: React.CSSProperties;
    textHighlighter?: (text: string) => React.ReactNode;
}

// @public
export class PropertyValueRendererManager {
    // (undocumented)
    protected _defaultArrayValueRenderer: IPropertyValueRenderer;
    static get defaultManager(): PropertyValueRendererManager;
    // (undocumented)
    protected _defaultMergedValueRenderer: IPropertyValueRenderer;
    // (undocumented)
    protected _defaultPrimitiveValueRenderer: IPropertyValueRenderer;
    // (undocumented)
    protected _defaultStructValueRenderer: IPropertyValueRenderer;
    getRegisteredRenderer(rendererType: string): IPropertyValueRenderer | undefined;
    // (undocumented)
    protected _propertyRenderers: Map<string, IPropertyValueRenderer>;
    registerRenderer(rendererType: string, propertyRenderer: IPropertyValueRenderer, overwrite?: boolean): void;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): React.ReactNode;
    unregisterRenderer(rendererType: string): void;
}

// @public
export class PropertyView extends React.Component<PropertyViewProps, PropertyViewState> {
    constructor(props: PropertyViewProps);
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface PropertyViewProps extends SharedRendererProps {
    labelElement: React.ReactNode;
    valueElement?: React.ReactNode;
    valueElementRenderer?: () => React.ReactNode;
}

// @public @deprecated
export interface ReactDataGridColumn extends ReactDataGrid.Column<any> {
    // (undocumented)
    filterableColumn?: FilterableColumn;
    icon?: boolean;
}

// @beta
export interface RenderedItemsRange {
    // (undocumented)
    overscanStartIndex: number;
    // (undocumented)
    overscanStopIndex: number;
    // (undocumented)
    visibleStartIndex: number;
    // (undocumented)
    visibleStopIndex: number;
}

// @public
export const renderLinks: (text: string, links: LinkElementsInfo, highlight?: ((text: string) => React.ReactNode) | undefined) => React.ReactNode;

// @public
export class ResultSelector extends React.PureComponent<ResultSelectorProps, ResultSelectorState> {
    // @internal
    constructor(props: ResultSelectorProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: ResultSelectorProps): void;
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface ResultSelectorProps extends CommonProps {
    onSelectedChanged: (index: number) => void;
    resultCount: number;
}

// @public
export interface RowItem {
    cells: CellItem[];
    colorOverrides?: ItemColorOverrides;
    extendedData?: {
        [key: string]: any;
    };
    getValueFromCell?: (columnKey: string) => any;
    isDisabled?: boolean;
    key: string;
}

// @public @deprecated
export interface RowProps {
    // (undocumented)
    cells: {
        [key: string]: CellProps;
    };
    // (undocumented)
    index: number;
    // (undocumented)
    item: RowItem;
    // (undocumented)
    render?: () => React.ReactNode;
    // (undocumented)
    style?: React.CSSProperties;
}

// @public
export function SelectableContent(props: SelectableContentProps): JSX.Element;

// @public
export interface SelectableContentDefinition {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    render: () => React.ReactNode;
}

// @public
export interface SelectableContentProps {
    // (undocumented)
    children: SelectableContentDefinition[];
    // (undocumented)
    defaultSelectedContentId: string;
    // (undocumented)
    selectAriaLabel?: string;
}

// @internal (undocumented)
export class SelectionHandler<Item> {
    constructor(selectionMode: SelectionMode, onItemsSelectedCallback?: OnItemsSelectedCallback<Item>, onItemsDeselectedCallback?: OnItemsDeselectedCallback<Item>);
    completeDragAction(): void;
    createDragAction(componentSelectionHandler: MultiSelectionHandler<Item>, items: Array<Array<SingleSelectionHandler<Item>>>, firstItem: Item): void;
    createSelectionFunction(componentHandler: MultiSelectionHandler<Item>, itemHandler: SingleSelectionHandler<Item>): OnSelectionChanged;
    // (undocumented)
    onItemsDeselectedCallback?: OnItemsDeselectedCallback<Item>;
    // (undocumented)
    onItemsSelectedCallback?: OnItemsSelectedCallback<Item>;
    get processedItem(): Item | undefined;
    selectionMode: SelectionMode;
    updateDragAction(latestItem: Item): void;
}

// @public
export enum SelectionMode {
    Extended = 12,
    Multiple = 6,
    None = 16,
    Single = 1,
    SingleAllowDeselect = 5
}

// @public
export enum SelectionModeFlags {
    // (undocumented)
    DragEnabled = 2,
    // (undocumented)
    KeysEnabled = 8,
    // (undocumented)
    None = 16,
    // (undocumented)
    SelectionLimitOne = 1,
    // (undocumented)
    ToggleEnabled = 4
}

// @public
export interface SharedRendererProps {
    actionButtonRenderers?: ActionButtonRenderer[];
    columnInfo?: PropertyGridColumnInfo;
    columnRatio?: number;
    isHoverable?: boolean;
    isResizeHandleBeingDragged?: boolean;
    isResizeHandleHovered?: boolean;
    isSelectable?: boolean;
    isSelected?: boolean;
    onClick?: (property: PropertyRecord, key?: string) => void;
    onColumnRatioChanged?: (ratio: number) => void | RatioChangeResult;
    onContextMenu?: (property: PropertyRecord, e: React.MouseEvent) => void;
    onResizeHandleDragChanged?: (isDragStarted: boolean) => void;
    onResizeHandleHoverChanged?: (isHovered: boolean) => void;
    onRightClick?: (property: PropertyRecord, key?: string) => void;
    orientation: Orientation;
    propertyRecord: PropertyRecord;
    uniqueKey?: string;
    width?: number;
}

// @public
export interface SharedTableNonPrimitiveValueRendererProps {
    onDialogOpen?: (dialogState: PropertyDialogState) => void;
}

// @internal
export class ShortDateTimePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class ShortDateTypeConverter extends DateTimeTypeConverterBase {
    // (undocumented)
    protected getTimeFormat(): TimeFormat;
}

// @public
export class ShowHideDialog<T extends ShowHideID> extends React.PureComponent<ShowHideDialogProps<T>, ShowHideDialogState<T>> {
    constructor(props: ShowHideDialogProps<T>);
    // @internal (undocumented)
    componentDidUpdate(oldProps: ShowHideDialogProps<T>): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: ShowHideDialogState<T>;
    }

// @public
export interface ShowHideDialogProps<T extends ShowHideID> extends GlobalDialogProps {
    initialHidden?: T[];
    items: Array<ShowHideItem<T>>;
    onShowHideChange?: (cols: T[]) => boolean | undefined;
}

// @public
export type ShowHideID = string | number | symbol;

// @public
export interface ShowHideItem<T extends ShowHideID> {
    // (undocumented)
    id: T;
    // (undocumented)
    label: string;
}

// @public
export class ShowHideMenu<T extends ShowHideID> extends React.PureComponent<ShowHideMenuProps<T>, ShowHideMenuState<T>> {
    // @internal
    constructor(props: ShowHideMenuProps<T>);
    // @internal (undocumented)
    componentDidUpdate(oldProps: ShowHideMenuProps<T>): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: ShowHideMenuState<T>;
    }

// @public
export interface ShowHideMenuProps<T extends ShowHideID> extends GlobalContextMenuProps {
    initialHidden?: T[];
    items: Array<ShowHideItem<T>>;
    onClose?: () => void;
    onShowHideChange?: (cols: T[]) => boolean | undefined;
    opened: boolean;
    x: number;
    y: number;
}

// @public
export class SimplePropertyDataProvider implements IPropertyDataProvider, PropertyData {
    // (undocumented)
    addCategory(category: PropertyCategory): number;
    // (undocumented)
    addProperty(propertyRecord: PropertyRecord, categoryIdx: number): void;
    // (undocumented)
    categories: PropertyCategory[];
    // (undocumented)
    description?: string;
    // (undocumented)
    findCategoryIndex(category: PropertyCategory): number;
    // (undocumented)
    getData(): Promise<PropertyData>;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    onDataChanged: PropertyDataChangeEvent;
    // (undocumented)
    records: {
        [categoryName: string]: PropertyRecord[];
    };
    // (undocumented)
    removeProperty(propertyRecord: PropertyRecord, categoryIdx: number): boolean;
    // (undocumented)
    replaceProperty(propertyRecord: PropertyRecord, categoryIdx: number, newRecord: PropertyRecord): boolean;
}

// @public
export class SimpleTableDataProvider implements MutableTableDataProvider {
    constructor(columns: ColumnDescription[]);
    addRow(rowItem: RowItem): number;
    applyFilterDescriptors(filterDescriptors: CompositeFilterDescriptorCollection): Promise<void>;
    deleteRow(rowItem: RowItem, raiseRowsChangedEvent?: boolean): void;
    getColumns(): Promise<ColumnDescription[]>;
    getDistinctValues(columnKey: string, maximumValueCount?: number): Promise<DistinctValueCollection>;
    getRow(rowIndex: number, unfiltered?: boolean): Promise<RowItem>;
    getRowsCount(): Promise<number>;
    insertRow(rowItem: RowItem, index: number): number;
    moveRow(rowItem: RowItem, newIndex: number): number;
    onColumnsChanged: TableDataChangeEvent;
    onRowsChanged: TableDataChangeEvent;
    setItems(items: RowItem[]): void;
    sort(columnIndex: number, sortDirection: SortDirection): Promise<void>;
    }

// @public
export class SimpleTreeDataProvider implements ITreeDataProvider {
    constructor(hierarchy: SimpleTreeDataProviderHierarchy);
    // (undocumented)
    getNodes(parent?: TreeNodeItem, pageOptions?: PageOptions): Promise<TreeNodeItem[]>;
    // (undocumented)
    getNodesCount(parent?: TreeNodeItem): Promise<number>;
    // (undocumented)
    onTreeNodeChanged: BeEvent<TreeDataChangesListener>;
}

// @public
export type SimpleTreeDataProviderHierarchy = Map<string | undefined, TreeNodeItem[]>;

// @internal
export interface SingleSelectionHandler<TItem> {
    deselect: () => void;
    isSelected: () => boolean;
    item: () => TItem;
    preselect: () => void;
    select: () => void;
}

// @public
export class SliderEditor extends React.PureComponent<PropertyEditorProps, SliderEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<SliderEditorState>;
    }

// @public
export class SliderPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export interface SortComparer {
    sortCompare(valueA: Primitives.Value, valueB: Primitives.Value, ignoreCase?: boolean): number;
}

// @public
export class SparseArray<T> implements Iterable<T | undefined> {
    // (undocumented)
    [immerable]: boolean;
    [Symbol.iterator](): IterableIterator<T | undefined>;
    get(index: number): T | undefined;
    getIndex(lookupValue: T): number | undefined;
    getLength(): number;
    insert(index: number, value: T): void;
    iterateValues(): IterableIterator<[T, number]>;
    remove(index: number): void;
    set(index: number, value: T): void;
    setLength(length: number): void;
}

// @internal
export class SparseTree<T extends Node> {
    // (undocumented)
    [immerable]: boolean;
    // (undocumented)
    deleteSubtree(parentId: string | undefined, deleteParent?: boolean): void;
    // (undocumented)
    getChildOffset(parentId: string | undefined, childId: string): number | undefined;
    // (undocumented)
    getChildren(parentId: string | undefined, createIfNotExist?: boolean): SparseArray<string> | undefined;
    // (undocumented)
    getNode(nodeId: string): T | undefined;
    // (undocumented)
    insertChild(parentId: string | undefined, child: T, offset: number): void;
    // (undocumented)
    moveNode(sourceParentId: string | undefined, sourceNodeId: string, targetParentId: string | undefined, targetIndex: number): void;
    // (undocumented)
    removeChild(parentId: string | undefined, child: string | number): void;
    // (undocumented)
    setChildren(parentId: string | undefined, children: T[], offset: number): void;
    // (undocumented)
    setNodeId(parentId: string | undefined, index: number, newId: string): boolean;
    // (undocumented)
    setNumChildren(parentId: string | undefined, numChildren: number): void;
}

// @public
export interface StringOperatorProcessor {
    contains(a: string, b: string, caseSensitive: boolean): boolean;
    doesNotContain(a: string, b: string, caseSensitive: boolean): boolean;
    endsWith(a: string, b: string, caseSensitive: boolean): boolean;
    isContainedIn(a: string, b: string, caseSensitive: boolean): boolean;
    isEmpty(a: string): boolean;
    isNotContainedIn(a: string, b: string, caseSensitive: boolean): boolean;
    isNotEmpty(a: string): boolean;
    startsWith(a: string, b: string, caseSensitive: boolean): boolean;
}

// @public
export class StringTypeConverter extends TypeConverter implements StringOperatorProcessor {
    // (undocumented)
    contains(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    convertFromString(value: string): string;
    // (undocumented)
    convertToString(value?: Primitives.String): string;
    // (undocumented)
    doesNotContain(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    endsWith(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isContainedIn(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isEmpty(valueA: string): boolean;
    // (undocumented)
    isNotContainedIn(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isNotEmpty(valueA: string): boolean;
    // (undocumented)
    get isStringType(): boolean;
    // (undocumented)
    sortCompare(valueA: Primitives.String, valueB: Primitives.String, ignoreCase?: boolean): number;
    // (undocumented)
    startsWith(valueA: string, valueB: string, caseSensitive: boolean): boolean;
}

// @public
export class StructPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): React.ReactNode;
}

// @public
export interface Subscribable<T> {
    // (undocumented)
    subscribe(observer?: Observer<T>): Subscription;
    // (undocumented)
    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Subscription;
    // (undocumented)
    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Subscription;
    // (undocumented)
    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription;
    // (undocumented)
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
}

// @public
export interface Subscription extends Unsubscribable {
    // (undocumented)
    add(tearDown: Unsubscribable | (() => void) | void): void;
    // (undocumented)
    readonly closed: boolean;
    // (undocumented)
    unsubscribe(): void;
}

// @public @deprecated
export class Table extends React.Component<TableProps, TableState> {
    // @internal
    constructor(props: TableProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(previousProps: TableProps, previousState: TableState): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal
    get filterDescriptors(): CompositeFilterDescriptorCollection;
    // @internal
    getPropertyDisplayValueExpression(property: string): string;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    shouldComponentUpdate(_props: TableProps): boolean;
    // @internal (undocumented)
    readonly state: TableState;
    // @internal (undocumented)
    update(): Promise<UpdateStatus>;
    // @internal (undocumented)
    updateSelectedCells(): void;
    // @internal (undocumented)
    updateSelectedRows(): void;
}

// @public
export class TableArrayValueRenderer extends React.PureComponent<TableSpecificValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public @deprecated
export class TableCell extends React.PureComponent<TableCellProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public @deprecated
export class TableCellContent extends React.PureComponent<TableCellContentProps, TableCellContentState> {
    // @internal (undocumented)
    componentDidMount(): Promise<void>;
    // @internal (undocumented)
    componentDidUpdate(prevProps: TableCellContentProps): Promise<void>;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: TableCellContentState;
}

// @public @deprecated
export interface TableCellContentProps extends CommonProps {
    cellItem: CellItem;
    height?: number;
    isSelected: boolean;
    onDialogOpen?: (state: PropertyDialogState) => void;
    propertyValueRendererManager: PropertyValueRendererManager;
}

// @public @deprecated
export interface TableCellContextMenuArgs {
    cellItem?: CellItem;
    cellKey: string;
    colIndex: number;
    event: React.MouseEvent;
    rowIndex: number;
}

// @public @deprecated
export interface TableCellEditorState {
    // (undocumented)
    active: boolean;
    // (undocumented)
    cellKey?: string;
    // (undocumented)
    colIndex?: number;
    // (undocumented)
    rowIndex?: number;
}

// @public @deprecated
export interface TableCellProps extends CommonProps {
    cellEditingProps?: Omit<EditorContainerProps, "title">;
    children?: React.ReactNode;
    className?: string;
    onClick?: (e: React.MouseEvent) => void;
    onMouseDown?: (e: React.MouseEvent) => void;
    onMouseMove?: (e: React.MouseEvent) => void;
    title: string;
}

// @public @deprecated
export interface TableCellUpdatedArgs {
    // (undocumented)
    cellKey: string;
    // (undocumented)
    colIndex: number;
    // (undocumented)
    rowIndex: number;
}

// @internal
export class TableColumn extends FilterableColumnBase {
    constructor(filterableTable: FilterableTable, columnDescription: ColumnDescription, reactDataGridColumn: ReactDataGridColumn);
    // (undocumented)
    dataProvider?: TableDataProvider;
    // (undocumented)
    distinctValueCollection?: DistinctValueCollection;
    getDistinctValues(maximumValueCount?: number): Promise<DistinctValueCollection>;
    // (undocumented)
    get key(): string;
    // (undocumented)
    readonly reactDataGridColumn: ReactDataGridColumn;
}

// @public
export class TableDataChangeEvent extends BeEvent<TableDataChangesListener> {
}

// @public
export type TableDataChangesListener = () => void;

// @public
export interface TableDataProvider {
    applyFilterDescriptors?: (filterDescriptors: CompositeFilterDescriptorCollection) => Promise<void>;
    getColumns(): Promise<ColumnDescription[]>;
    getDistinctValues?: (columnKey: string, maximumValueCount?: number) => Promise<DistinctValueCollection>;
    // @alpha
    getPropertyDisplayValueExpression?: (property: string) => string;
    getRow(rowIndex: number, unfiltered?: boolean): Promise<RowItem>;
    getRowsCount(): Promise<number>;
    onColumnsChanged: TableDataChangeEvent;
    onRowsChanged: TableDataChangeEvent;
    sort(columnIndex: number, sortDirection: SortDirection): Promise<void>;
}

// @public
export interface TableDistinctValue {
    // (undocumented)
    label: string;
    // (undocumented)
    value: Primitives.Value;
}

// @internal
export class TableFilterDescriptorCollection extends FilterDescriptorCollection implements CompositeFilterDescriptorCollection {
    constructor();
    evaluateRow(row: RowItem): boolean;
    get filterDescriptorCollection(): FilterDescriptorCollection;
    getColumnFilterDescriptor(columnKey: string): ColumnFilterDescriptor | undefined;
    // (undocumented)
    getFilterExpression(): string;
    isColumnFilterActive(columnKey: string): boolean;
    get logicalOperator(): FilterCompositionLogicalOperator;
    set logicalOperator(value: FilterCompositionLogicalOperator);
    }

// @public
export class TableIconCellContent extends React.PureComponent<TableIconCellContentProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface TableIconCellContentProps {
    iconName: string;
}

// @public
export class TableNonPrimitiveValueRenderer extends React.PureComponent<TableNonPrimitiveValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface TableNonPrimitiveValueRendererProps extends SharedTableNonPrimitiveValueRendererProps {
    buttonLabel: string;
    dialogContents: React.ReactNode;
    dialogTitle: string;
}

// @public @deprecated
export interface TableProps extends CommonProps {
    dataProvider: TableDataProvider;
    hideHeader?: boolean;
    isCellSelected?: (rowIndex: number, cell: CellItem) => boolean;
    isRowSelected?: (row: RowItem) => boolean;
    maximumDistinctValues?: number;
    // @internal (undocumented)
    onApplyFilter?: () => void;
    onCellContextMenu?: (args: TableCellContextMenuArgs) => void;
    onCellsDeselected?: (cellIterator: AsyncIterableIterator<[RowItem, CellItem]>) => Promise<boolean>;
    onCellsSelected?: (cellIterator: AsyncIterableIterator<[RowItem, CellItem]>, replace: boolean) => Promise<boolean>;
    onPropertyEditing?: (args: TableCellEditorState) => void;
    onPropertyUpdated?: (propertyArgs: PropertyUpdatedArgs, cellArgs: TableCellUpdatedArgs) => Promise<boolean>;
    // @internal
    onRender?: () => void;
    onRowsDeselected?: (rowIterator: AsyncIterableIterator<RowItem>) => Promise<boolean>;
    onRowsLoaded?: (firstRowIndex: number, lastRowIndex: number) => void;
    onRowsSelected?: (rowIterator: AsyncIterableIterator<RowItem>, replace: boolean) => Promise<boolean>;
    // @internal (undocumented)
    onScrollToRow?: (rowIndex: number) => void;
    pageAmount?: number;
    propertyValueRendererManager?: PropertyValueRendererManager;
    // @internal (undocumented)
    renderRow?: (item: RowItem, props: TableRowProps) => React.ReactNode;
    reorderableColumns?: boolean;
    scrollToRow?: number;
    selectionMode?: SelectionMode;
    settingsIdentifier?: string;
    settingsStorage?: UiSettingsStorage;
    showHideColumns?: boolean;
    stripedRows?: boolean;
    tableSelectionTarget?: TableSelectionTarget;
    // @deprecated
    uiSettings?: UiSettings;
}

// @internal
export class TableRow extends React.Component<TableRowProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface TableRowProps extends CommonProps {
    // (undocumented)
    cells: {
        [key: string]: React.ReactNode;
    };
    // (undocumented)
    isSelected?: boolean;
}

// @public
export const TableRowStyleProvider: {
    createStyle: ({ color, backgroundColor }: ItemColorOverrides) => CSSProperties;
};

// @public @deprecated
export enum TableSelectionTarget {
    // (undocumented)
    Cell = 1,
    // (undocumented)
    Row = 0
}

// @public
export interface TableSpecificValueRendererProps extends SharedTableNonPrimitiveValueRendererProps {
    orientation: Orientation;
    propertyRecord: PropertyRecord;
}

// @public
export class TableStructValueRenderer extends React.PureComponent<TableSpecificValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export class TextareaEditor extends React.PureComponent<PropertyEditorProps, TextareaEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<TextareaEditorState>;
    }

// @public
export class TextareaPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class TextEditor extends React.PureComponent<PropertyEditorProps, TextEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<TextEditorState>;
    }

// @beta @deprecated
export class ThemedEnumEditor extends React.PureComponent<ThemedEnumEditorProps, EnumEditorState_2> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumEditorState_2>;
    }

// @beta @deprecated
export interface ThemedEnumEditorProps extends PropertyEditorProps {
    isSearchable?: boolean;
    noOptionsMessage?: (obj: {
        inputValue: string;
    }) => string | null;
    placeholder?: string;
}

// @beta @deprecated
export class ThemedEnumPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesEscape(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @internal
export function TimeField({ time, timeDisplay, readOnly, onTimeChange }: TimeFieldProps): JSX.Element;

// @internal
export interface TimeFieldProps {
    // (undocumented)
    onTimeChange?: (time: TimeSpec) => void;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    time: TimeSpec;
    // (undocumented)
    timeDisplay: TimeDisplay;
}

// @internal
export interface TimeSpec {
    // (undocumented)
    hours: number;
    // (undocumented)
    minutes: number;
    // (undocumented)
    seconds: number;
}

// @public
export const toDateString: (date: Date, timeZoneOffset?: number | undefined) => string;

// @public
export class ToggleEditor extends React.PureComponent<PropertyEditorProps, ToggleEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    get hasFocus(): boolean;
    // (undocumented)
    get htmlElement(): HTMLElement | null;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ToggleEditorState>;
    }

// @public
export class TogglePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export function Toolbar(props: ToolbarProps): JSX.Element;

// @public
export const ToolbarButtonItem: React.MemoExoticComponent<React.FC<ToolbarButtonItemProps>>;

// @public
export interface ToolbarButtonItemProps extends CommonProps {
    addGroupSeparator?: boolean;
    badge?: React.ReactNode;
    icon?: React.ReactNode;
    isActive?: boolean;
    isDisabled?: boolean;
    onClick?: () => void;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    title: string;
}

// @public
export type ToolbarItem = ActionButton | GroupButton | CustomToolbarItem;

// @internal (undocumented)
export function ToolbarItemComponent({ item, addGroupSeparator }: {
    item: ToolbarItem;
    addGroupSeparator: boolean;
}): JSX.Element | null;

// @internal
export const ToolbarItemContext: React.Context<ToolbarItemContextArgs>;

// @internal
export interface ToolbarItemContextArgs {
    // (undocumented)
    readonly hasOverflow: boolean;
    // (undocumented)
    readonly onResize: (w: number) => void;
    // (undocumented)
    readonly useHeight: boolean;
}

// @public
export enum ToolbarOpacitySetting {
    Defaults = 0,
    Proximity = 1,
    Transparent = 2
}

// @internal (undocumented)
export interface ToolbarOverflowContextProps {
    // (undocumented)
    readonly direction: OrthogonalDirection;
    // (undocumented)
    readonly expandsTo: Direction;
    // (undocumented)
    readonly onItemExecuted: OnItemExecutedFunc;
    // (undocumented)
    readonly onKeyDown: (e: React.KeyboardEvent) => void;
    // (undocumented)
    readonly onPopupPanelOpenClose: (isOpening: boolean) => void;
    // (undocumented)
    readonly openPopupCount: number;
    // (undocumented)
    readonly overflowDirection: OrthogonalDirection;
    // (undocumented)
    readonly overflowDisplayActive: boolean;
    // (undocumented)
    readonly overflowExpandsTo: Direction;
    // (undocumented)
    readonly panelAlignment: ToolbarPanelAlignment;
    // (undocumented)
    readonly toolbarOpacitySetting: ToolbarOpacitySetting;
    // (undocumented)
    readonly useDragInteraction: boolean;
}

// @public
export enum ToolbarPanelAlignment {
    // (undocumented)
    End = 1,
    // (undocumented)
    Start = 0
}

// @internal
export class ToolbarPanelAlignmentHelpers {
    static readonly END_CLASS_NAME = "components-panel-alignment-end";
    // (undocumented)
    static getCssClassName(panelAlignment: ToolbarPanelAlignment): string;
    static readonly START_CLASS_NAME = "components-panel-alignment-start";
}

// @public
export const ToolbarPopupContext: React.Context<ToolbarPopupContextProps>;

// @public (undocumented)
export interface ToolbarPopupContextProps {
    // (undocumented)
    readonly closePanel: () => void;
    // (undocumented)
    readonly setSelectedItem?: (buttonItem: ActionButton) => void;
}

// @public
export interface ToolbarProps extends CommonProps, NoChildrenProps {
    expandsTo?: Direction;
    items: CommonToolbarItem[];
    onItemExecuted?: OnItemExecutedFunc;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    panelAlignment?: ToolbarPanelAlignment;
    toolbarOpacitySetting?: ToolbarOpacitySetting;
    useDragInteraction?: boolean;
}

// @public
export function ToolbarWithOverflow(props: ToolbarWithOverflowProps): JSX.Element;

// @internal
export const ToolbarWithOverflowDirectionContext: React.Context<ToolbarOverflowContextProps>;

// @public
export interface ToolbarWithOverflowProps extends CommonProps, NoChildrenProps {
    expandsTo?: Direction;
    items: CommonToolbarItem[];
    onItemExecuted?: OnItemExecutedFunc;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    overflowExpandsTo?: Direction;
    panelAlignment?: ToolbarPanelAlignment;
    toolbarOpacitySetting?: ToolbarOpacitySetting;
    useDragInteraction?: boolean;
}

// @internal (undocumented)
export function toRxjsObservable<T>(observable: Observable<T>): Observable_2<T>;

// @public
export const toTimeString: (date: Date, timeZoneOffset?: number | undefined) => string;

// @internal (undocumented)
export function toToolbarPopupRelativePosition(expandsTo: Direction, alignment: ToolbarPanelAlignment): RelativePosition;

// @public
export interface TreeActions {
    // (undocumented)
    onNodeCheckboxClicked: (nodeId: string, newState: CheckBoxState) => void;
    // (undocumented)
    onNodeClicked: (nodeId: string, event: React_2.MouseEvent) => void;
    // (undocumented)
    onNodeCollapsed: (nodeId: string) => void;
    // (undocumented)
    onNodeEditorActivated: (nodeId: string) => void;
    // (undocumented)
    onNodeExpanded: (nodeId: string) => void;
    // (undocumented)
    onNodeMouseDown: (nodeId: string) => void;
    // (undocumented)
    onNodeMouseMove: (nodeId: string) => void;
    // (undocumented)
    onTreeKeyDown: (event: React_2.KeyboardEvent) => void;
    // (undocumented)
    onTreeKeyUp: (event: React_2.KeyboardEvent) => void;
}

// @public
export interface TreeCheckboxStateChangeEventArgs {
    stateChanges: Observable<CheckboxStateChange[]>;
}

// @public
export type TreeDataChangesListener = (nodes: Array<TreeNodeItem | undefined>) => void;

// @public
export type TreeDataProvider = TreeDataProviderRaw | TreeDataProviderPromise | TreeDataProviderMethod | ITreeDataProvider;

// @public
export type TreeDataProviderMethod = (node?: TreeNodeItem) => Promise<DelayLoadedTreeNodeItem[]>;

// @public
export type TreeDataProviderPromise = Promise<TreeDataProviderRaw>;

// @public
export type TreeDataProviderRaw = ImmediatelyLoadedTreeNodeItem[];

// @internal
export class TreeDataSource implements IDisposable {
    constructor(dataProvider: TreeDataProvider);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly onItemsChanged: BeEvent<TreeDataChangesListener>;
    // (undocumented)
    requestItems(parent: TreeNodeItem | undefined, firstItemIndex: number, numItems: number, requestNumChildren: boolean): Observable_2<TreeDataSourceResult>;
}

// @public
export interface TreeEditingParams {
    onNodeUpdated: (node: TreeModelNode, newValue: string) => void;
}

// @internal
export class TreeEventDispatcher implements TreeActions {
    constructor(treeEvents: TreeEvents, nodeLoader: ITreeNodeLoader, selectionMode: SelectionMode, getVisibleNodes?: () => VisibleTreeNodes);
    // (undocumented)
    onNodeCheckboxClicked(nodeId: string, newState: CheckBoxState): void;
    // (undocumented)
    onNodeClicked(nodeId: string, event: React_2.MouseEvent<Element, MouseEvent>): void;
    // (undocumented)
    onNodeCollapsed(nodeId: string): void;
    // (undocumented)
    onNodeEditorActivated(nodeId: string): void;
    // (undocumented)
    onNodeExpanded(nodeId: string): void;
    // (undocumented)
    onNodeMouseDown(nodeId: string): void;
    // (undocumented)
    onNodeMouseMove(nodeId: string): void;
    // (undocumented)
    onTreeKeyDown(event: React_2.KeyboardEvent): void;
    // (undocumented)
    onTreeKeyUp(event: React_2.KeyboardEvent): void;
    // (undocumented)
    setVisibleNodes(visibleNodes: () => VisibleTreeNodes): void;
    }

// @public
export class TreeEventHandler implements TreeEvents, IDisposable {
    constructor(params: TreeEventHandlerParams);
    dispose(): void;
    // (undocumented)
    get modelSource(): TreeModelSource;
    onCheckboxStateChanged({ stateChanges }: TreeCheckboxStateChangeEventArgs): Subscription | undefined;
    onDelayedNodeClick({ nodeId }: TreeNodeEventArgs): void;
    onNodeCollapsed({ nodeId }: TreeNodeEventArgs): void;
    onNodeEditorActivated({ nodeId }: TreeNodeEventArgs): void;
    onNodeExpanded({ nodeId }: TreeNodeEventArgs): void;
    onSelectionModified({ modifications }: TreeSelectionModificationEventArgs): Subscription | undefined;
    onSelectionReplaced({ replacements }: TreeSelectionReplacementEventArgs): Subscription | undefined;
    }

// @public
export interface TreeEventHandlerParams {
    collapsedChildrenDisposalEnabled?: boolean;
    editingParams?: TreeEditingParams;
    modelSource: TreeModelSource;
    nodeLoader: ITreeNodeLoader;
}

// @public
export interface TreeEvents {
    onCheckboxStateChanged?(event: TreeCheckboxStateChangeEventArgs): Subscription | undefined;
    onDelayedNodeClick?(event: TreeNodeEventArgs): void;
    onNodeCollapsed?(event: TreeNodeEventArgs): void;
    onNodeEditorActivated?(event: TreeNodeEventArgs): void;
    onNodeExpanded?(event: TreeNodeEventArgs): void;
    onSelectionModified?(event: TreeSelectionModificationEventArgs): Subscription | undefined;
    onSelectionReplaced?(event: TreeSelectionReplacementEventArgs): Subscription | undefined;
}

// @public
export class TreeImageLoader implements ITreeImageLoader {
    load(item: TreeNodeItem): LoadedImage | undefined;
}

// @public
export interface TreeModel {
    // (undocumented)
    getChildOffset(parentId: string | undefined, childId: string): number | undefined;
    // (undocumented)
    getChildren(parentId: string | undefined): SparseArray<string> | undefined;
    // (undocumented)
    getNode(id: string): TreeModelNode | undefined;
    // (undocumented)
    getNode(parentId: string | undefined, childIndex: number): TreeModelNode | TreeModelNodePlaceholder | undefined;
    // (undocumented)
    getNode(nodeId: string | undefined, childIndex?: number): TreeModelNode | TreeModelNodePlaceholder | TreeModelRootNode | undefined;
    // (undocumented)
    getRootNode(): TreeModelRootNode;
    // (undocumented)
    iterateTreeModelNodes(parentId?: string): IterableIterator<TreeModelNode>;
}

// @public
export interface TreeModelChanges {
    // (undocumented)
    addedNodeIds: string[];
    // (undocumented)
    modifiedNodeIds: string[];
    // (undocumented)
    removedNodeIds: string[];
}

// @public
export interface TreeModelNode {
    // (undocumented)
    readonly checkbox: CheckBoxInfo;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    readonly description: string | undefined;
    readonly editingInfo?: TreeModelNodeEditingInfo;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLoading?: boolean;
    // (undocumented)
    readonly isSelected: boolean;
    // (undocumented)
    readonly item: TreeNodeItem;
    // (undocumented)
    readonly label: PropertyRecord;
    // (undocumented)
    readonly numChildren: number | undefined;
    // (undocumented)
    readonly parentId: string | undefined;
}

// @public
export interface TreeModelNodeEditingInfo {
    // (undocumented)
    onCancel: () => void;
    // (undocumented)
    onCommit: (node: TreeModelNode, newValue: string) => void;
}

// @public
export interface TreeModelNodeInput {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLoading: boolean;
    // (undocumented)
    readonly isSelected: boolean;
    // (undocumented)
    readonly item: TreeNodeItem;
    // (undocumented)
    readonly label: PropertyRecord;
    // (undocumented)
    readonly numChildren?: number;
}

// @public
export interface TreeModelNodePlaceholder {
    // (undocumented)
    readonly childIndex: number;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    readonly parentId?: string;
}

// @public
export type TreeModelNodeType = TreeModelNode | TreeModelNodePlaceholder | TreeModelRootNode;

// @public
export interface TreeModelRootNode {
    // (undocumented)
    readonly depth: -1;
    // (undocumented)
    readonly id: undefined;
    // (undocumented)
    readonly numChildren: number | undefined;
}

// @public
export class TreeModelSource {
    constructor(_model?: MutableTreeModel);
    getModel(): TreeModel;
    modifyModel(callback: (model: MutableTreeModel) => void): void;
    onModelChanged: BeUiEvent<[TreeModel, TreeModelChanges]>;
}

// @public
export function TreeNodeEditor(props: TreeNodeEditorProps): JSX.Element;

// @public
export interface TreeNodeEditorProps {
    // @internal (undocumented)
    ignoreEditorBlur?: boolean;
    node: TreeModelNode;
    onCancel: () => void;
    onCommit: (node: TreeModelNode, newValue: string) => void;
    style?: React.CSSProperties;
}

// @public
export type TreeNodeEditorRenderer = (props: TreeNodeEditorProps) => React.ReactNode;

// @public
export interface TreeNodeEventArgs {
    nodeId: string;
}

// @public
export interface TreeNodeItem {
    // (undocumented)
    autoExpand?: boolean;
    // (undocumented)
    checkBoxState?: CheckBoxState;
    // (undocumented)
    description?: string;
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    icon?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    isCheckboxDisabled?: boolean;
    // (undocumented)
    isCheckboxVisible?: boolean;
    // (undocumented)
    isEditable?: boolean;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    parentId?: string;
    // (undocumented)
    style?: ItemStyle;
}

// @public
export type TreeNodeItemData = ImmediatelyLoadedTreeNodeItem & DelayLoadedTreeNodeItem;

// @public
export class TreeNodeLoader<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoaderWithProvider<TDataProvider> implements IDisposable {
    constructor(dataProvider: TDataProvider, modelSource: TreeModelSource);
    dispose(): void;
    protected load(parentNode: TreeModelNode | TreeModelRootNode): Observable<LoadedNodeHierarchy>;
    }

// @public
export interface TreeNodeLoadResult {
    // (undocumented)
    loadedNodes: TreeNodeItem[];
}

// @public
export const TreeNodeRenderer: React.MemoExoticComponent<(props: TreeNodeRendererProps) => JSX.Element>;

// @public
export interface TreeNodeRendererProps extends CommonProps {
    checkboxRenderer?: NodeCheckboxRenderer;
    descriptionEnabled?: boolean;
    imageLoader?: ITreeImageLoader;
    node: TreeModelNode;
    nodeEditorRenderer?: TreeNodeEditorRenderer;
    nodeHighlightProps?: HighlightableTreeNodeProps;
    // @internal
    onLabelRendered?: (node: TreeModelNode) => void;
    treeActions: TreeActions;
}

// @public
export class TreeRenderer extends React.Component<TreeRendererProps> implements TreeRendererAttributes {
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    scrollToNode(nodeId: string, alignment?: Alignment): void;
}

// @public
export interface TreeRendererAttributes {
    scrollToNode(nodeId: string, alignment?: Alignment): void;
}

// @public
export interface TreeRendererProps {
    height: number;
    nodeHeight: (node: TreeModelNode | TreeModelNodePlaceholder, index: number) => number;
    nodeHighlightingProps?: HighlightableTreeProps;
    // (undocumented)
    nodeLoader: ITreeNodeLoader;
    nodeRenderer?: (props: TreeNodeRendererProps) => React.ReactNode;
    // @beta
    onItemsRendered?: (renderedItems: RenderedItemsRange) => void;
    // @internal
    onNodeEditorClosed?: () => void;
    // (undocumented)
    treeActions: TreeActions;
    visibleNodes: VisibleTreeNodes;
    width: number;
}

// @public
export interface TreeSelectionChange {
    deselectedNodeItems: TreeNodeItem[];
    selectedNodeItems: TreeNodeItem[];
}

// @public
export interface TreeSelectionModificationEventArgs {
    modifications: Observable<TreeSelectionChange>;
}

// @public
export interface TreeSelectionReplacementEventArgs {
    replacements: Observable<{
        selectedNodeItems: TreeNodeItem[];
    }>;
}

// @public
export abstract class TypeConverter implements SortComparer, OperatorProcessor, NullableOperatorProcessor {
    convertFromString(_value: string): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    convertFromStringToPropertyValue(value: string, propertyRecord?: PropertyRecord): Promise<PropertyValue>;
    convertFromStringWithOptions(value: string, _options?: {
        [key: string]: any;
    }): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Value): string | Promise<string>;
    convertToString(value?: Primitives.Value): string | Promise<string>;
    convertToStringWithOptions(value?: Primitives.Value, _options?: {
        [key: string]: any;
    }): string | Promise<string>;
    get isBooleanType(): boolean;
    isEqualTo(valueA: Primitives.Value, valueB: Primitives.Value): boolean;
    get isLessGreaterType(): boolean;
    isNotEqualTo(valueA: Primitives.Value, valueB: Primitives.Value): boolean;
    isNotNull(value: Primitives.Value): boolean;
    isNull(value: Primitives.Value): boolean;
    get isNullableType(): boolean;
    get isStringType(): boolean;
    abstract sortCompare(valueA: Primitives.Value, valueB: Primitives.Value, _ignoreCase?: boolean): number;
}

// @public
export class TypeConverterManager {
    // (undocumented)
    static getConverter(typename: string, converterName?: string): TypeConverter;
    // (undocumented)
    static registerConverter(typename: string, converter: new () => TypeConverter, converterName?: string): void;
    // (undocumented)
    static unregisterConverter(typename: string, converterName?: string): void;
}

// @public
export interface TypeEditor {
    // (undocumented)
    getPropertyValue: () => Promise<PropertyValue | undefined>;
    // (undocumented)
    hasFocus: boolean;
    // (undocumented)
    htmlElement: HTMLElement | null;
}

// @public
export class UiComponents {
    static initialize(localization: Localization): Promise<void>;
    static get initialized(): boolean;
    // @internal
    static get localization(): Localization;
    static get localizationNamespace(): string;
    // @internal (undocumented)
    static loggerCategory(obj: any): string;
    // @internal (undocumented)
    static get packageName(): string;
    static terminate(): void;
    // @internal
    static translate(key: string | string[]): string;
}

// @public
export interface Unsubscribable {
    // (undocumented)
    unsubscribe(): void;
}

// @public
export class UrlPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @public
export const useAsyncValue: <T extends unknown>(value: T | PromiseLike<T>) => T | undefined;

// @alpha
export function useDebouncedAsyncValue<TReturn>(valueToBeResolved: undefined | (() => Promise<TReturn>)): {
    value: TReturn | undefined;
    inProgress: boolean;
};

// @public
export function usePagedTreeNodeLoader<TDataProvider extends TreeDataProvider>(dataProvider: TDataProvider, pageSize: number, modelSource: TreeModelSource): PagedTreeNodeLoader<TDataProvider>;

// @public
export function usePropertyData(props: {
    dataProvider: IPropertyDataProvider;
}): {
    value: import("../PropertyDataProvider").PropertyData | undefined;
    inProgress: boolean;
};

// @beta
export function usePropertyGridEventHandler(props: {
    modelSource: IPropertyGridModelSource;
}): PropertyGridEventHandler;

// @beta
export function usePropertyGridModel(props: {
    modelSource: IPropertyGridModelSource;
}): IPropertyGridModel | undefined;

// @beta
export function usePropertyGridModelSource(props: {
    dataProvider: IPropertyDataProvider;
}): PropertyGridModelSource;

// @internal (undocumented)
export function useRenderedStringValue(record: PropertyRecord, stringValueCalculator: (record: PropertyRecord) => string | Promise<string>, context?: PropertyValueRendererContext, linksHandler?: LinkElementsInfo): {
    stringValue?: string;
    element: React.ReactNode;
};

// @public
export function useToolbarPopupContext(): ToolbarPopupContextProps;

// @internal (undocumented)
export function useToolbarWithOverflowDirectionContext(): ToolbarOverflowContextProps;

// @internal (undocumented)
export function useToolItemEntryContext(): ToolbarItemContextArgs;

// @public
export function useTreeEventsHandler<TEventsHandler extends TreeEventHandler>(factoryOrParams: (() => TEventsHandler) | TreeEventHandlerParams): TreeEventHandler;

// @public
export function useTreeModel(modelSource: TreeModelSource): TreeModel;

// @public
export function useTreeModelSource(dataProvider: TreeDataProvider): TreeModelSource;

// @public
export function useTreeNodeLoader<TDataProvider extends TreeDataProvider>(dataProvider: TDataProvider, modelSource: TreeModelSource): TreeNodeLoader<TDataProvider>;

// @beta
export class VirtualizedPropertyGrid extends React.Component<VirtualizedPropertyGridProps, VirtualizedPropertyGridState> {
    // @internal
    constructor(props: VirtualizedPropertyGridProps);
    // @internal (undocumented)
    componentDidUpdate(prevProps: VirtualizedPropertyGridProps, prevState: VirtualizedPropertyGridState): void;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: VirtualizedPropertyGridProps, state: VirtualizedPropertyGridState): VirtualizedPropertyGridState | null;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @beta
export interface VirtualizedPropertyGridContext {
    // (undocumented)
    actionButtonRenderers?: ActionButtonRenderer[];
    // (undocumented)
    columnInfo: PropertyGridColumnInfo;
    // (undocumented)
    columnRatio: number;
    // (undocumented)
    dataProvider: IPropertyDataProvider;
    // (undocumented)
    editingPropertyKey?: string;
    // (undocumented)
    eventHandler: IPropertyGridEventHandler;
    // (undocumented)
    gridWidth: number;
    // (undocumented)
    highlight?: HighlightingComponentProps & {
        filteredTypes?: FilteredType[];
    };
    // (undocumented)
    isPropertyHoverEnabled: boolean;
    // (undocumented)
    isPropertySelectionEnabled: boolean;
    // (undocumented)
    isResizeHandleBeingDragged: boolean;
    // (undocumented)
    isResizeHandleHovered: boolean;
    // (undocumented)
    onColumnRatioChanged: (ratio: number) => void | RatioChangeResult;
    // (undocumented)
    onEditCancel?: () => void;
    // (undocumented)
    onEditCommit?: (args: PropertyUpdatedArgs, category: PropertyCategory) => void;
    // (undocumented)
    onPropertyClicked?: (property: PropertyRecord, key?: string) => void;
    // (undocumented)
    onPropertyContextMenu?: (property: PropertyRecord, e: React.MouseEvent) => void;
    // (undocumented)
    onPropertyRightClicked?: (property: PropertyRecord, key?: string) => void;
    // (undocumented)
    onResizeHandleDragChanged: (newValue: boolean) => void;
    // (undocumented)
    onResizeHandleHoverChanged: (newValue: boolean) => void;
    // (undocumented)
    orientation: Orientation;
    // (undocumented)
    propertyCategoryRendererManager?: PropertyCategoryRendererManager;
    // (undocumented)
    propertyValueRendererManager?: PropertyValueRendererManager;
    // (undocumented)
    selectedPropertyKey?: string;
}

// @beta
export interface VirtualizedPropertyGridProps extends CommonPropertyGridProps {
    // (undocumented)
    dataProvider: IPropertyDataProvider;
    // (undocumented)
    eventHandler: IPropertyGridEventHandler;
    // (undocumented)
    height: number;
    // (undocumented)
    highlight?: HighlightingComponentProps & {
        filteredTypes?: FilteredType[];
    };
    // (undocumented)
    model: IPropertyGridModel;
    // (undocumented)
    propertyCategoryRendererManager?: PropertyCategoryRendererManager;
    // (undocumented)
    width: number;
}

// @beta
export function VirtualizedPropertyGridWithDataProvider(props: VirtualizedPropertyGridWithDataProviderProps): JSX.Element;

// @beta
export interface VirtualizedPropertyGridWithDataProviderProps extends CommonPropertyGridProps {
    // (undocumented)
    dataProvider: IPropertyDataProvider;
    // (undocumented)
    height: number;
    // (undocumented)
    highlight?: HighlightingComponentProps & {
        filteredTypes?: FilteredType[];
    };
    // (undocumented)
    propertyCategoryRendererManager?: PropertyCategoryRendererManager;
    // (undocumented)
    width: number;
}

// @public
export interface VisibleTreeNodes extends Iterable<TreeModelNode | TreeModelNodePlaceholder> {
    // (undocumented)
    getAtIndex(index: number): TreeModelNode | TreeModelNodePlaceholder | undefined;
    // (undocumented)
    getIndexOfNode(nodeId: string): number;
    // (undocumented)
    getModel(): TreeModel;
    // (undocumented)
    getNumNodes(): number;
    // (undocumented)
    getNumRootNodes(): number | undefined;
}

// @public
export const withContextStyle: (node: React.ReactNode, context?: PropertyValueRendererContext | undefined) => React.ReactNode;

// @public
export const withLinks: (stringValue: string, links?: LinkElementsInfo | undefined, highlight?: ((text: string) => React.ReactNode) | undefined) => React.ReactNode;


// (No @packageDocumentation comment for this package)

```
