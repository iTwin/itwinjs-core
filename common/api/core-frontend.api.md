## API Report File for "@itwin/core-frontend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AccessToken } from '@itwin/core-bentley';
import { AlternateUnitLabelsProvider } from '@itwin/core-quantity';
import { AmbientOcclusion } from '@itwin/core-common';
import { AnalysisStyle } from '@itwin/core-common';
import { AnalysisStyleDisplacement } from '@itwin/core-common';
import { Angle } from '@itwin/core-geometry';
import { AngleSweep } from '@itwin/core-geometry';
import { AnyCurvePrimitive } from '@itwin/core-geometry';
import { Arc3d } from '@itwin/core-geometry';
import { AsyncMethodsOf } from '@itwin/core-bentley';
import { AuthorizationClient } from '@itwin/core-common';
import { AuxChannel } from '@itwin/core-geometry';
import { AuxCoordSystem2dProps } from '@itwin/core-common';
import { AuxCoordSystem3dProps } from '@itwin/core-common';
import { AuxCoordSystemProps } from '@itwin/core-common';
import { AxisAlignedBox3d } from '@itwin/core-common';
import { BackgroundMapProps } from '@itwin/core-common';
import { BackgroundMapProviderProps } from '@itwin/core-common';
import { BackgroundMapSettings } from '@itwin/core-common';
import { BaseLayerSettings } from '@itwin/core-common';
import { BaseQuantityDescription } from '@itwin/appui-abstract';
import { BatchType } from '@itwin/core-common';
import { BeDuration } from '@itwin/core-bentley';
import { BeEvent } from '@itwin/core-bentley';
import { BentleyError } from '@itwin/core-bentley';
import { BentleyStatus } from '@itwin/core-bentley';
import { BeTimePoint } from '@itwin/core-bentley';
import { BeUiEvent } from '@itwin/core-bentley';
import { BoundingSphere } from '@itwin/core-common';
import { BriefcaseDownloader } from '@itwin/core-common';
import { BriefcaseProps } from '@itwin/core-common';
import { ByteStream } from '@itwin/core-bentley';
import { Camera } from '@itwin/core-common';
import { Capabilities } from '@itwin/webgl-compatibility';
import { Cartographic } from '@itwin/core-common';
import { CategorySelectorProps } from '@itwin/core-common';
import { ChangedEntities } from '@itwin/core-common';
import { ChangesetIndex } from '@itwin/core-common';
import { ChangesetIndexAndId } from '@itwin/core-common';
import { ClipPlane } from '@itwin/core-geometry';
import { ClipShape } from '@itwin/core-geometry';
import { ClipStyle } from '@itwin/core-common';
import { ClipVector } from '@itwin/core-geometry';
import { ClipVectorProps } from '@itwin/core-geometry';
import { Code } from '@itwin/core-common';
import { CodeProps } from '@itwin/core-common';
import { CodeSpec } from '@itwin/core-common';
import { ColorDef } from '@itwin/core-common';
import { ColorDefProps } from '@itwin/core-common';
import { ColorIndex } from '@itwin/core-common';
import { CompressedId64Set } from '@itwin/core-bentley';
import { Constructor } from '@itwin/core-bentley';
import { ContentIdProvider } from '@itwin/core-common';
import { ContextRealityModel } from '@itwin/core-common';
import { ContextRealityModelProps } from '@itwin/core-common';
import { ConvexClipPlaneSet } from '@itwin/core-geometry';
import { CurvePrimitive } from '@itwin/core-geometry';
import { DeprecatedBackgroundMapProps } from '@itwin/core-common';
import { DevToolsStatsOptions } from '@itwin/core-common';
import { DialogItem } from '@itwin/appui-abstract';
import { DialogItemValue } from '@itwin/appui-abstract';
import { DialogProperty } from '@itwin/appui-abstract';
import { DialogPropertyItem } from '@itwin/appui-abstract';
import { DialogPropertySyncItem } from '@itwin/appui-abstract';
import { Dictionary } from '@itwin/core-bentley';
import { DisplayMessageType } from '@itwin/appui-abstract';
import { DisplayStyle3dSettings } from '@itwin/core-common';
import { DisplayStyleProps } from '@itwin/core-common';
import { DisplayStyleSettings } from '@itwin/core-common';
import { DisplayStyleSettingsProps } from '@itwin/core-common';
import { EasingFunction } from '@itwin/core-common';
import { EcefLocation } from '@itwin/core-common';
import { EcefLocationProps } from '@itwin/core-common';
import { ECSqlReader } from '@itwin/core-common';
import { EdgeArgs } from '@itwin/core-common';
import { EdgeOptions } from '@itwin/core-common';
import { EditingScopeNotifications } from '@itwin/core-common';
import { ElementAlignedBox3d } from '@itwin/core-common';
import { ElementGeometryChange } from '@itwin/core-common';
import { ElementGraphicsRequestProps } from '@itwin/core-common';
import { ElementLoadOptions } from '@itwin/core-common';
import { ElementMeshRequestProps } from '@itwin/core-common';
import { ElementProps } from '@itwin/core-common';
import { Ellipsoid } from '@itwin/core-geometry';
import { EllipsoidPatch } from '@itwin/core-geometry';
import { EmphasizeElementsProps } from '@itwin/core-common';
import { EntityProps } from '@itwin/core-common';
import { EntityQueryParams } from '@itwin/core-common';
import { Environment } from '@itwin/core-common';
import { Feature } from '@itwin/core-common';
import { FeatureAppearance } from '@itwin/core-common';
import { FeatureAppearanceProvider } from '@itwin/core-common';
import { FeatureIndex } from '@itwin/core-common';
import { FeatureIndexType } from '@itwin/core-common';
import { FeatureOverrides } from '@itwin/core-common';
import { FeatureOverrideType } from '@itwin/core-common';
import { FeatureTable } from '@itwin/core-common';
import { FillFlags } from '@itwin/core-common';
import { FontMap } from '@itwin/core-common';
import { FormatProps } from '@itwin/core-quantity';
import { FormatterSpec } from '@itwin/core-quantity';
import type { FrontendStorage } from '@itwin/object-storage-core/lib/frontend';
import { Frustum } from '@itwin/core-common';
import { FrustumPlanes } from '@itwin/core-common';
import { default as Fuse_2 } from 'fuse.js';
import { GeoCoordinatesResponseProps } from '@itwin/core-common';
import { GeographicCRSProps } from '@itwin/core-common';
import { GeometricModel2dProps } from '@itwin/core-common';
import { GeometricModel3dProps } from '@itwin/core-common';
import { GeometricModelProps } from '@itwin/core-common';
import { GeometryClass } from '@itwin/core-common';
import { GeometryContainmentRequestProps } from '@itwin/core-common';
import { GeometryContainmentResponseProps } from '@itwin/core-common';
import { GeometryQuery } from '@itwin/core-geometry';
import { GeometryStreamProps } from '@itwin/core-common';
import { GeometrySummaryRequestProps } from '@itwin/core-common';
import { GlobeMode } from '@itwin/core-common';
import { Gradient } from '@itwin/core-common';
import { GraphicParams } from '@itwin/core-common';
import { GridOrientationType } from '@itwin/core-common';
import { GuidString } from '@itwin/core-bentley';
import { HiddenLine } from '@itwin/core-common';
import { Hilite } from '@itwin/core-common';
import { HydrateViewStateRequestProps } from '@itwin/core-common';
import { HydrateViewStateResponseProps } from '@itwin/core-common';
import { Id64 } from '@itwin/core-bentley';
import { Id64Arg } from '@itwin/core-bentley';
import { Id64Array } from '@itwin/core-bentley';
import { Id64Set } from '@itwin/core-bentley';
import { Id64String } from '@itwin/core-bentley';
import { IDisposable } from '@itwin/core-bentley';
import { ImageBuffer } from '@itwin/core-common';
import { ImageBufferFormat } from '@itwin/core-common';
import { ImageMapLayerSettings } from '@itwin/core-common';
import { ImageSource } from '@itwin/core-common';
import { ImageSourceFormat } from '@itwin/core-common';
import { IModel } from '@itwin/core-common';
import { IModelConnectionProps } from '@itwin/core-common';
import { IModelCoordinatesResponseProps } from '@itwin/core-common';
import { IModelRpcProps } from '@itwin/core-common';
import { IModelStatus } from '@itwin/core-common';
import { IModelTileTreeId } from '@itwin/core-common';
import { IModelTileTreeProps } from '@itwin/core-common';
import { IModelVersion } from '@itwin/core-common';
import { IndexedPolyface } from '@itwin/core-geometry';
import { IndexMap } from '@itwin/core-bentley';
import { InternetConnectivityStatus } from '@itwin/core-common';
import { IpcAppChannel } from '@itwin/core-common';
import { IpcAppFunctions } from '@itwin/core-common';
import { IpcListener } from '@itwin/core-common';
import { IpcSocketFrontend } from '@itwin/core-common';
import { LightSettings } from '@itwin/core-common';
import { LinePixels } from '@itwin/core-common';
import { Listener } from '@itwin/core-bentley';
import { LocalBriefcaseProps } from '@itwin/core-common';
import { Localization } from '@itwin/core-common';
import { LoggingMetaData } from '@itwin/core-bentley';
import { LogLevel } from '@itwin/core-bentley';
import { Loop } from '@itwin/core-geometry';
import { LowAndHighXY } from '@itwin/core-geometry';
import { LowAndHighXYZ } from '@itwin/core-geometry';
import { Map4d } from '@itwin/core-geometry';
import { MapLayerKey } from '@itwin/core-common';
import { MapLayerProps } from '@itwin/core-common';
import { MapLayerSettings } from '@itwin/core-common';
import { MapSubLayerProps } from '@itwin/core-common';
import { MassPropertiesOperation } from '@itwin/core-common';
import { MassPropertiesPerCandidateRequestProps } from '@itwin/core-common';
import { MassPropertiesPerCandidateResponseProps } from '@itwin/core-common';
import { MassPropertiesRequestProps } from '@itwin/core-common';
import { MassPropertiesResponseProps } from '@itwin/core-common';
import { Matrix3d } from '@itwin/core-geometry';
import { Matrix4d } from '@itwin/core-geometry';
import { MeshEdges } from '@itwin/core-common';
import { MeshPolyline } from '@itwin/core-common';
import { MeshPolylineList } from '@itwin/core-common';
import { MessagePresenter } from '@itwin/appui-abstract';
import { MessageSeverity } from '@itwin/appui-abstract';
import { ModelExtentsProps } from '@itwin/core-common';
import { ModelGeometryChanges } from '@itwin/core-common';
import { ModelGeometryChangesProps } from '@itwin/core-common';
import { ModelIdAndGeometryGuid } from '@itwin/core-common';
import { ModelMapLayerSettings } from '@itwin/core-common';
import { ModelProps } from '@itwin/core-common';
import { ModelQueryParams } from '@itwin/core-common';
import { ModelSelectorProps } from '@itwin/core-common';
import { MonochromeMode } from '@itwin/core-common';
import { Mutable } from '@itwin/core-bentley';
import { NativeAppFunctions } from '@itwin/core-common';
import { NonFunctionPropertiesOf } from '@itwin/core-bentley';
import { NormalMapParams } from '@itwin/core-common';
import { ObservableSet } from '@itwin/core-bentley';
import { OctEncodedNormal } from '@itwin/core-common';
import { OpenBriefcaseProps } from '@itwin/core-common';
import { OpenMode } from '@itwin/core-bentley';
import { OrbitGtBlobProps } from '@itwin/core-common';
import { OrbitGtDataManager } from '@itwin/core-orbitgt';
import { OrderedComparator } from '@itwin/core-bentley';
import { OrderedId64Array } from '@itwin/core-bentley';
import { PackedFeatureTable } from '@itwin/core-common';
import { ParseResults } from '@itwin/appui-abstract';
import { ParserSpec } from '@itwin/core-quantity';
import { Path } from '@itwin/core-geometry';
import { PickAsyncMethods } from '@itwin/core-bentley';
import { Placement } from '@itwin/core-common';
import { PlacementProps } from '@itwin/core-common';
import { PlanarClipMaskProps } from '@itwin/core-common';
import { PlanarClipMaskSettings } from '@itwin/core-common';
import { Plane3dByOriginAndUnitNormal } from '@itwin/core-geometry';
import { Point2d } from '@itwin/core-geometry';
import { Point3d } from '@itwin/core-geometry';
import { Point4d } from '@itwin/core-geometry';
import { PointCloudDisplaySettings } from '@itwin/core-common';
import { PointCloudReader } from '@itwin/core-orbitgt';
import { PointWithStatus } from '@itwin/core-common';
import { Polyface } from '@itwin/core-geometry';
import { PolyfaceVisitor } from '@itwin/core-geometry';
import { PolylineData } from '@itwin/core-common';
import { PolylineEdgeArgs } from '@itwin/core-common';
import { PolylineFlags } from '@itwin/core-common';
import { PolylineTypeFlags } from '@itwin/core-common';
import { PrimaryTileTreeId } from '@itwin/core-common';
import { PromiseReturnType } from '@itwin/core-bentley';
import { PropertyDescription } from '@itwin/appui-abstract';
import { PropertyRecord } from '@itwin/appui-abstract';
import { PropertyValue } from '@itwin/appui-abstract';
import { QParams2d } from '@itwin/core-common';
import { QParams3d } from '@itwin/core-common';
import { QPoint2dBuffer } from '@itwin/core-common';
import { QPoint2dBufferBuilder } from '@itwin/core-common';
import { QPoint3dBuffer } from '@itwin/core-common';
import { QPoint3dBufferBuilder } from '@itwin/core-common';
import { QPoint3dList } from '@itwin/core-common';
import { QuantityParseResult } from '@itwin/core-quantity';
import { QueryBinder } from '@itwin/core-common';
import { QueryOptions } from '@itwin/core-common';
import { Range1d } from '@itwin/core-geometry';
import { Range1dProps } from '@itwin/core-geometry';
import { Range2d } from '@itwin/core-geometry';
import { Range3d } from '@itwin/core-geometry';
import { Range3dProps } from '@itwin/core-geometry';
import { Ray3d } from '@itwin/core-geometry';
import { ReadonlySortedArray } from '@itwin/core-bentley';
import { RealityData } from '@itwin/core-common';
import { RealityDataAccess } from '@itwin/core-common';
import { RealityDataFormat } from '@itwin/core-common';
import { RealityDataProvider } from '@itwin/core-common';
import { RealityDataSourceKey } from '@itwin/core-common';
import { RealityDataStatus } from '@itwin/core-bentley';
import { RealityModelDisplaySettings } from '@itwin/core-common';
import { RelatedElement } from '@itwin/core-common';
import { RelativePosition } from '@itwin/appui-abstract';
import { RemoveFunction } from '@itwin/core-common';
import { RenderMaterial } from '@itwin/core-common';
import { RenderMode } from '@itwin/core-common';
import { RenderSchedule } from '@itwin/core-common';
import { RenderTexture } from '@itwin/core-common';
import { RenderTimelineProps } from '@itwin/core-common';
import { RgbColor } from '@itwin/core-common';
import { RgbColorProps } from '@itwin/core-common';
import { RootSubjectProps } from '@itwin/core-common';
import { RpcInterfaceDefinition } from '@itwin/core-common';
import { RpcRoutingToken } from '@itwin/core-common';
import { SectionDrawingViewProps } from '@itwin/core-common';
import { SheetProps } from '@itwin/core-common';
import { SilhouetteEdgeArgs } from '@itwin/core-common';
import { SkyGradient } from '@itwin/core-common';
import { SmoothTransformBetweenFrusta } from '@itwin/core-geometry';
import { SnapRequestProps } from '@itwin/core-common';
import { SnapResponseProps } from '@itwin/core-common';
import { SolarShadowSettings } from '@itwin/core-common';
import { SolidPrimitive } from '@itwin/core-geometry';
import { SortedArray } from '@itwin/core-bentley';
import { SpatialClassifier } from '@itwin/core-common';
import { SpatialClassifierInsideDisplay } from '@itwin/core-common';
import { SpatialClassifierOutsideDisplay } from '@itwin/core-common';
import { SpatialClassifiers } from '@itwin/core-common';
import { SpatialViewDefinitionProps } from '@itwin/core-common';
import { StandaloneOpenOptions } from '@itwin/core-common';
import { StopWatch } from '@itwin/core-bentley';
import { StorageValue } from '@itwin/core-common';
import { StringifiedClipVector } from '@itwin/core-geometry';
import { StrokeOptions } from '@itwin/core-geometry';
import { SubCategoryAppearance } from '@itwin/core-common';
import { SubCategoryOverride } from '@itwin/core-common';
import { SubCategoryResultRow } from '@itwin/core-common';
import { SubLayerId } from '@itwin/core-common';
import { SyncMode } from '@itwin/core-common';
import { TelemetryManager } from '@itwin/core-telemetry';
import { TextureData } from '@itwin/core-common';
import { TextureLoadProps } from '@itwin/core-common';
import { TextureMapping } from '@itwin/core-common';
import { TextureTransparency } from '@itwin/core-common';
import { ThematicDisplay } from '@itwin/core-common';
import { ThematicDisplaySensor } from '@itwin/core-common';
import { ThematicDisplaySensorSettings } from '@itwin/core-common';
import { ThumbnailProps } from '@itwin/core-common';
import { TileHeader } from '@itwin/core-common';
import { TileProps } from '@itwin/core-common';
import { TileReadStatus } from '@itwin/core-common';
import { TileVersionInfo } from '@itwin/core-common';
import { Transform } from '@itwin/core-geometry';
import { TransformProps } from '@itwin/core-geometry';
import { TransientIdSequence } from '@itwin/core-bentley';
import { Tweens } from '@itwin/core-common';
import { TxnNotifications } from '@itwin/core-common';
import { UiAdmin } from '@itwin/appui-abstract';
import { Uint16ArrayBuilder } from '@itwin/core-bentley';
import { UintArray } from '@itwin/core-bentley';
import { UintArrayBuilder } from '@itwin/core-bentley';
import { UnitConversion } from '@itwin/core-quantity';
import { UnitProps } from '@itwin/core-quantity';
import { UnitsProvider } from '@itwin/core-quantity';
import { UnitSystemKey } from '@itwin/core-quantity';
import { Vector2d } from '@itwin/core-geometry';
import { Vector3d } from '@itwin/core-geometry';
import { ViewAttachmentProps } from '@itwin/core-common';
import { ViewDefinition2dProps } from '@itwin/core-common';
import { ViewDefinition3dProps } from '@itwin/core-common';
import { ViewDefinitionProps } from '@itwin/core-common';
import { ViewDetails } from '@itwin/core-common';
import { ViewDetails3d } from '@itwin/core-common';
import { ViewFlagOverrides } from '@itwin/core-common';
import { ViewFlags } from '@itwin/core-common';
import { ViewFlagsProperties } from '@itwin/core-common';
import { ViewQueryParams } from '@itwin/core-common';
import { ViewStateProps } from '@itwin/core-common';
import { WebGLContext } from '@itwin/webgl-compatibility';
import { WebGLExtensionName } from '@itwin/webgl-compatibility';
import { WebGLRenderCompatibilityInfo } from '@itwin/webgl-compatibility';
import { WhiteOnWhiteReversalSettings } from '@itwin/core-common';
import { XAndY } from '@itwin/core-geometry';
import { XYAndZ } from '@itwin/core-geometry';
import { XYProps } from '@itwin/core-geometry';
import { XYZ } from '@itwin/core-geometry';
import { XYZProps } from '@itwin/core-geometry';

// @internal
export class AccuDraw {
    // (undocumented)
    accountForAuxRotationPlane(rot: ThreeAxes, plane: RotationMode): void;
    // (undocumented)
    protected _acsPickId?: string;
    // (undocumented)
    activate(): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, fromSnap: boolean): boolean;
    // (undocumented)
    alwaysShowCompass: boolean;
    // (undocumented)
    angleLock(): void;
    // (undocumented)
    protected _animationFrames: number;
    // (undocumented)
    autoFocusFields: boolean;
    // (undocumented)
    autoPointPlacement: boolean;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    axisIndexing: boolean;
    // (undocumented)
    readonly baseAxes: ThreeAxes;
    // (undocumented)
    changeBaseRotationMode(mode: RotationMode): void;
    // (undocumented)
    changeCompassMode(animate?: boolean): void;
    // (undocumented)
    clearTentative(): boolean;
    // (undocumented)
    compassMode: CompassMode;
    // (undocumented)
    protected _compassSizeInches: number;
    // (undocumented)
    contextSensitive: boolean;
    // (undocumented)
    currentState: CurrentState;
    // (undocumented)
    currentView?: ScreenViewport;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    readonly delta: Vector3d;
    // (undocumented)
    disableForSession(): void;
    // (undocumented)
    distanceIndexing: boolean;
    // (undocumented)
    distanceLock(synchText: boolean, saveInHistory: boolean): void;
    // (undocumented)
    doAutoPoint(index: ItemField, mode: CompassMode): Promise<void>;
    // (undocumented)
    doLockAngle(isSnapped: boolean): void;
    // (undocumented)
    dontMoveFocus: boolean;
    // (undocumented)
    downgradeInactiveState(): boolean;
    // (undocumented)
    enableForSession(): void;
    // (undocumented)
    protected readonly _fillColor: ColorDef;
    // (undocumented)
    protected readonly _fillColorNoFocus: ColorDef;
    // (undocumented)
    fixPointPolar(vp: Viewport): void;
    // (undocumented)
    fixPointRectangular(vp: Viewport): void;
    // (undocumented)
    readonly flags: Flags;
    // (undocumented)
    floatingOrigin: boolean;
    // (undocumented)
    protected readonly _frameColor: ColorDef;
    // (undocumented)
    protected readonly _frameColorNoFocus: ColorDef;
    // (undocumented)
    static getCurrentOrientation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, rMatrix?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    getFieldLock(index: ItemField): boolean;
    // (undocumented)
    getKeyinStatus(index: ItemField): KeyinStatus;
    // (undocumented)
    getRotation(rMatrix?: Matrix3d): Matrix3d;
    // (undocumented)
    static getSnapRotation(snap: SnapDetail, currentVp: Viewport | undefined, out?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    static getStandardRotation(nStandard: StandardViewId, vp: Viewport | undefined, useACS: boolean, out?: Matrix3d): Matrix3d;
    // (undocumented)
    getValueByIndex(index: ItemField): number;
    grabInputFocus(): void;
    // (undocumented)
    hardConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    get hasInputFocus(): boolean;
    // (undocumented)
    protected readonly _indexColor: ColorDef;
    // (undocumented)
    indexed: LockedStates;
    // (undocumented)
    protected _indexToleranceInches: number;
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    get isDeactivated(): boolean;
    // (undocumented)
    get isEnabled(): boolean;
    // (undocumented)
    get isInactive(): boolean;
    // (undocumented)
    isZLocked(vp: Viewport): boolean;
    // (undocumented)
    readonly lastAxes: ThreeAxes;
    // (undocumented)
    locked: LockedStates;
    // (undocumented)
    newFocus: ItemField;
    // (undocumented)
    onBeginDynamics(): boolean;
    // (undocumented)
    onCompassModeChange(): void;
    // (undocumented)
    onEndDynamics(): boolean;
    // (undocumented)
    onFieldLockChange(_index: ItemField): void;
    // (undocumented)
    onFieldValueChange(_index: ItemField): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    onInputCollectorExit(): boolean;
    // (undocumented)
    onInputCollectorInstall(): boolean;
    onMotion(_ev: BeButtonEvent): void;
    // (undocumented)
    onPostButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPrimitiveToolInstall(): boolean;
    // (undocumented)
    onRotationModeChange(): void;
    // (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // (undocumented)
    onSnap(snap: SnapDetail): boolean;
    // (undocumented)
    onTentative(): boolean;
    // (undocumented)
    onViewToolExit(): boolean;
    // (undocumented)
    onViewToolInstall(): boolean;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly planePt: Point3d;
    // (undocumented)
    readonly point: Point3d;
    // (undocumented)
    processFieldInput(index: ItemField, input: string, synchText: boolean): Promise<void>;
    // (undocumented)
    processHints(): void;
    // (undocumented)
    readonly published: AccudrawData;
    // (undocumented)
    refreshDecorationsAndDynamics(): void;
    // (undocumented)
    restoreState(stateBuffer: SavedState): void;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    saveCoordinate(index: ItemField, value: number): void;
    // (undocumented)
    readonly savedStateInputCollector: SavedState;
    // (undocumented)
    readonly savedStateViewTool: SavedState;
    // (undocumented)
    saveState(stateBuffer: SavedState): void;
    // (undocumented)
    sendDataPoint(pt: Point3d, viewport: ScreenViewport): Promise<void>;
    // (undocumented)
    setCompassMode(mode: CompassMode): void;
    // (undocumented)
    setContext(flags: AccuDrawFlags, originP?: Point3d, orientationP?: Matrix3d | Vector3d, deltaP?: Vector3d, distanceP?: number, angleP?: number, transP?: Transform): BentleyStatus;
    // (undocumented)
    setContextRotation(rMatrix: Matrix3d, locked: boolean, animate: boolean): void;
    // (undocumented)
    setFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    setFocusItem(_index: ItemField): void;
    // (undocumented)
    setKeyinStatus(index: ItemField, status: KeyinStatus): void;
    // (undocumented)
    setLastPoint(pt: Point3d): void;
    // (undocumented)
    protected setNewFocus(index: ItemField): void;
    // (undocumented)
    setRotationMode(mode: RotationMode): void;
    // (undocumented)
    setValueByIndex(index: ItemField, value: number): void;
    // (undocumented)
    smartKeyin: boolean;
    // (undocumented)
    softConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    stickyZLock: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    unlockAllFields(): void;
    // (undocumented)
    static updateAuxCoordinateSystem(acs: AuxCoordSystemState, vp: Viewport, allViews?: boolean): void;
    // (undocumented)
    updateFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    updateRotation(animate?: boolean, newRotationIn?: Matrix3d): void;
    // (undocumented)
    upgradeToActiveState(): boolean;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    protected readonly _xColor: ColorDef;
    // (undocumented)
    protected readonly _yColor: ColorDef;
}

// @internal (undocumented)
export class AccuDrawChangeModeTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccudrawData {
    // (undocumented)
    angle: number;
    // (undocumented)
    readonly delta: Point3d;
    // (undocumented)
    distance: number;
    // (undocumented)
    flags: number;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rMatrix: Matrix3d;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    zero(): void;
}

// @internal (undocumented)
export enum AccuDrawFlags {
    // (undocumented)
    AlwaysSetOrigin = 2097156,
    // (undocumented)
    Disable = 4096,
    // (undocumented)
    FixedOrigin = 8,
    // (undocumented)
    Lock_X = 512,
    // (undocumented)
    Lock_Y = 1024,
    // (undocumented)
    Lock_Z = 2048,
    // (undocumented)
    LockAngle = 524288,
    // (undocumented)
    LockDistance = 256,
    // (undocumented)
    OrientACS = 131072,
    // (undocumented)
    OrientDefault = 16384,
    // (undocumented)
    RedrawCompass = 4194304,
    // (undocumented)
    SetDistance = 128,
    // (undocumented)
    SetFocus = 32768,
    // (undocumented)
    SetModePolar = 1,
    // (undocumented)
    SetModeRect = 2,
    // (undocumented)
    SetNormal = 64,
    // (undocumented)
    SetOrigin = 4,
    // (undocumented)
    SetRMatrix = 16,
    // (undocumented)
    SetXAxis = 32,
    // (undocumented)
    SetXAxis2 = 262144,
    // (undocumented)
    SmartRotation = 16777216,
    // (undocumented)
    UpdateRotation = 8388608
}

// @public
export class AccuDrawHintBuilder {
    static activate(): void;
    static deactivate(): void;
    enableSmartRotation: boolean;
    static getBoresite(spacePt: Point3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Ray3d;
    static getContextRotation(id: ContextRotationId, vp: Viewport): Matrix3d | undefined;
    static getCurrentRotation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, matrix?: Matrix3d): Matrix3d | undefined;
    static get isActive(): boolean;
    static get isEnabled(): boolean;
    static projectPointToLineInView(spacePt: Point3d, linePt: Point3d, lineDirection: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
    static projectPointToPlaneInView(spacePt: Point3d, planePt: Point3d, planeNormal: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
    sendHints(activate?: boolean): boolean;
    setAngle(angle: number): void;
    setDistance(distance: number): void;
    setLockAngle: boolean;
    setLockDistance: boolean;
    setLockX: boolean;
    setLockY: boolean;
    setLockZ: boolean;
    setMatrix(matrix: Matrix3d): boolean;
    setModePolar(): void;
    setModeRectangular(): void;
    setNormal(normal: Vector3d): void;
    setOrigin(origin: Point3d): void;
    setOriginAlways: boolean;
    setOriginFixed: boolean;
    // @internal
    setRotation(rowMatrix: Matrix3d): void;
    setXAxis(xAxis: Vector3d): void;
    setXAxis2(xAxis: Vector3d): void;
}

// @internal (undocumented)
export class AccuDrawRotateAxesTool extends AccuDrawShortcutsTool {
    constructor(aboutCurrentZ?: boolean);
    // (undocumented)
    aboutCurrentZ: boolean;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    protected _immediateMode: boolean;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    onInstall(): Promise<boolean>;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    parseAndRun(...args: any[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateCycleTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    moveOrigin: boolean;
    // (undocumented)
    onInstall(): Promise<boolean>;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class AccuDrawRotateFrontTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateSideTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateTopTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateViewTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockAngleTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockDistanceTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockSmartTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockXTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockYTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockZTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetOriginTool extends Tool {
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class AccuDrawShortcuts {
    // (undocumented)
    static alignView(): void;
    // (undocumented)
    static changeCompassMode(): void;
    // (undocumented)
    static defineACSByElement(): Promise<boolean>;
    // (undocumented)
    static defineACSByPoints(): Promise<boolean>;
    // (undocumented)
    static getACS(acsName: string | undefined, useOrigin: boolean, useRotation: boolean): BentleyStatus;
    // (undocumented)
    static itemFieldAcceptInput(index: ItemField, str: string): Promise<void>;
    // (undocumented)
    static itemFieldLockToggle(index: ItemField): void;
    // (undocumented)
    static itemFieldNavigate(index: ItemField, str: string, forward: boolean): Promise<void>;
    // (undocumented)
    static itemFieldNewInput(index: ItemField): void;
    // (undocumented)
    static itemFieldUnlockAll(): void;
    // (undocumented)
    static itemRotationModeChange(rotation: RotationMode): void;
    // (undocumented)
    static lockAngle(): void;
    // (undocumented)
    static lockDistance(): void;
    // (undocumented)
    lockIndex(): void;
    // (undocumented)
    static lockSmart(): void;
    // (undocumented)
    static lockX(): void;
    // (undocumented)
    static lockY(): void;
    // (undocumented)
    static lockZ(): void;
    // (undocumented)
    static processPendingHints(): void;
    // @internal
    static processShortcutKey(keyEvent: KeyboardEvent): Promise<boolean>;
    // (undocumented)
    static requestInputFocus(): void;
    // (undocumented)
    static rotate90(axis: number): void;
    // (undocumented)
    static rotateAxes(aboutCurrentZ: boolean): Promise<boolean>;
    // (undocumented)
    static rotateAxesByPoint(isSnapped: boolean, aboutCurrentZ: boolean): boolean;
    // (undocumented)
    static rotateCycle(): void;
    // (undocumented)
    static rotateToACS(): void;
    // (undocumented)
    static rotateToBase(): void;
    // (undocumented)
    static rotateToElement(): Promise<boolean>;
    // (undocumented)
    static setOrigin(explicitOrigin?: Point3d): void;
    // (undocumented)
    static setStandardRotation(rotation: RotationMode): void;
    // (undocumented)
    static updateACSByPoints(acs: AuxCoordSystemState, vp: Viewport, points: Point3d[], isDynamics: boolean): boolean;
    // (undocumented)
    static writeACS(_acsName: string): BentleyStatus;
}

// @public
export class AccuSnap implements Decorator {
    // @internal (undocumented)
    adjustPointIfHot(pt: Point3d, view: Viewport): void;
    readonly areFlashed: Set<Viewport>;
    aSnapHits?: HitList<HitDetail>;
    clear(): void;
    // @internal (undocumented)
    clearIfElement(sourceId: string): void;
    // @internal (undocumented)
    clearToolTip(ev?: BeButtonEvent): void;
    readonly cross: SpriteLocation;
    currHit?: HitDetail;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    destroy(): void;
    // @internal (undocumented)
    displayToolTip(viewPt: XAndY, vp: ScreenViewport, uorPt?: Point3d): void;
    enableLocate(yesNo: boolean): void;
    enableSnap(yesNo: boolean): void;
    // @internal (undocumented)
    erase(): void;
    readonly errorIcon: SpriteLocation;
    errorKey?: string;
    explanation?: string;
    getActiveSnapModes(): SnapMode[];
    // @internal (undocumented)
    getCurrSnapDetail(): SnapDetail | undefined;
    // @internal (undocumented)
    getHitAndList(holder: HitListHolder): HitDetail | undefined;
    readonly icon: SpriteLocation;
    // @internal (undocumented)
    intersectXY(tpSnap: SnapDetail, second: SnapDetail): IntersectDetail | undefined;
    get isActive(): boolean;
    get isHot(): boolean;
    get isLocateEnabled(): boolean;
    get isSnapEnabled(): boolean;
    get isSnapEnabledByUser(): boolean;
    get keypointDivisor(): number;
    readonly needFlash: Set<Viewport>;
    neverFlash(ids?: Id64Arg): void;
    // @internal
    onEnabledStateChange(_isEnabled: boolean, _wasEnabled: boolean): void;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    onMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // @internal
    onStartTool(): void;
    // @internal (undocumented)
    onTouchCancel(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchEnd(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchMove(ev: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchStart(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // @internal
    reEvaluate(): Promise<void>;
    // @internal (undocumented)
    static requestSnap(thisHit: HitDetail, snapModes: SnapMode[], hotDistanceInches: number, keypointDivisor: number, hitList?: HitList<HitDetail>, out?: LocateResponse): Promise<SnapDetail | undefined>;
    // @internal
    resetButton(): Promise<SnapStatus>;
    // @internal (undocumented)
    setCurrHit(newHit?: HitDetail): void;
    // @internal (undocumented)
    protected _settings: AccuSnap.Settings;
    // @internal (undocumented)
    suppress(doSuppress: boolean): number;
    // @internal (undocumented)
    suspend(doSuspend: boolean): void;
    // @internal
    synchSnapMode(): void;
    // @internal (undocumented)
    readonly toolState: AccuSnap.ToolState;
    // @internal (undocumented)
    touchCursor?: TouchCursor;
    // @internal (undocumented)
    get wantVirtualCursor(): boolean;
}

// @public (undocumented)
export namespace AccuSnap {
    // (undocumented)
    export class Settings {
        // (undocumented)
        enableFlag: boolean;
        // (undocumented)
        hiliteColdHits: boolean;
        // (undocumented)
        hotDistanceFactor: number;
        // (undocumented)
        searchDistance: number;
        // (undocumented)
        stickyFactor: number;
        // (undocumented)
        toolTip: boolean;
        // (undocumented)
        toolTipDelay: BeDuration;
    }
    // (undocumented)
    export class ToolState {
        // (undocumented)
        clone(): ToolState;
        // (undocumented)
        enabled: boolean;
        // (undocumented)
        locate: boolean;
        // (undocumented)
        neverFlash?: Id64Set;
        // (undocumented)
        setFrom(other: ToolState): void;
        // (undocumented)
        suspended: number;
    }
}

// @public (undocumented)
export enum ACSDisplayOptions {
    // (undocumented)
    Active = 1,
    // (undocumented)
    CheckVisible = 8,
    // (undocumented)
    Deemphasized = 2,
    // (undocumented)
    Dynamics = 16,
    // (undocumented)
    Hilite = 4,
    // (undocumented)
    None = 0
}

// @public (undocumented)
export enum ACSType {
    // (undocumented)
    Cylindrical = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Rectangular = 1,
    // (undocumented)
    Spherical = 3
}

// @alpha (undocumented)
export type ActivationEvent = "onStartup";

// @public
export class ActivityMessageDetails {
    constructor(showProgressBar: boolean, showPercentInMessage: boolean, supportsCancellation: boolean, showDialogInitially?: boolean);
    onActivityCancelled(): void;
    onActivityCompleted(): void;
    // (undocumented)
    showDialogInitially: boolean;
    // (undocumented)
    showPercentInMessage: boolean;
    // (undocumented)
    showProgressBar: boolean;
    // (undocumented)
    supportsCancellation: boolean;
    // (undocumented)
    wasCancelled: boolean;
}

// @public
export enum ActivityMessageEndReason {
    // (undocumented)
    Cancelled = 1,
    // (undocumented)
    Completed = 0
}

// @internal (undocumented)
export function addRangeGraphic(builder: GraphicBuilder, range: Range3d, is2d: boolean): void;

// @internal
export class AlternateUnitLabelsRegistry implements AlternateUnitLabelsProvider {
    constructor(defaultAlternates?: Map<UnitNameKey, Set<string>>);
    // (undocumented)
    addAlternateLabels(key: UnitNameKey, ...labels: string[]): void;
    // (undocumented)
    getAlternateUnitLabels(unit: UnitProps): string[] | undefined;
}

// @beta
export class AngleDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export class AnimatedTreeReference extends PrimaryTreeReference {
    constructor(view: ViewState, model: GeometricModelState, transformNodeId: number);
    // (undocumented)
    protected computeBaseTransform(tree: TileTree): Transform;
    // (undocumented)
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
}

// @internal
export interface AnimationBranchState {
    // (undocumented)
    readonly clip?: RenderClipVolume;
    // (undocumented)
    readonly omit?: boolean;
}

// @internal
export interface AnimationBranchStates {
    readonly branchStates: Map<string, AnimationBranchState>;
    readonly transformNodeIds: ReadonlySet<number>;
}

// @internal (undocumented)
export namespace AnimationBranchStates {
    // (undocumented)
    export function fromScript(script: RenderSchedule.Script, time: number): AnimationBranchStates | undefined;
}

// @internal
export enum AnimationNodeId {
    // (undocumented)
    Untransformed = 4294967295
}

// @public
export interface Animator {
    animate(): boolean;
    interrupt(): void;
}

// @internal (undocumented)
export enum ArcGisErrorCode {
    // (undocumented)
    InvalidCredentials = 401,
    // (undocumented)
    InvalidToken = 498,
    // (undocumented)
    NoTokenService = 1001,
    // (undocumented)
    TokenRequired = 499,
    // (undocumented)
    UnknownError = 1000
}

// @internal
export abstract class ArcGISImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings, usesCachedTiles: boolean);
    // (undocumented)
    protected _accessClient: MapLayerAccessClient | undefined;
    protected _accessTokenRequired: boolean;
    protected fetch(url: URL, options?: RequestInit): Promise<Response>;
    protected getServiceJson(): Promise<ArcGISServiceMetadata | undefined>;
    // (undocumented)
    protected _lastAccessToken: MapLayerAccessToken | undefined;
    protected onStatusUpdated(status: MapLayerImageryProviderStatus): void;
}

// @internal (undocumented)
export class ArcGISMapLayerImageryProvider extends ArcGISImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement): void;
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    protected get _filterByCartoRange(): boolean;
    // (undocumented)
    protected _generateChildIds(tile: ImageryMapTile, resolveChildren: (childIds: QuadId[]) => void): void;
    // (undocumented)
    getFeatureInfo(featureInfos: MapLayerFeatureInfo[], quadId: QuadId, carto: Cartographic, _tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    protected getLayerString(prefix?: string): string;
    // (undocumented)
    getToolTip(strings: string[], quadId: QuadId, carto: Cartographic, tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    get minimumZoomLevel(): number;
    // (undocumented)
    serviceJson: any;
    // (undocumented)
    uintToString(uintArray: any): {
        type: "Buffer";
        data: number[];
    };
}

// @internal
export interface ArcGISServiceMetadata {
    accessTokenRequired: boolean;
    content: any;
}

// @internal (undocumented)
export class ArcGISTileMap {
    constructor(restBaseUrl: string, settings: ImageMapLayerSettings, nbLods?: number, accessClient?: MapLayerAccessClient);
    // (undocumented)
    fallbackTileMapRequestSize: number;
    // (undocumented)
    protected fetchAndReadTilemap(queryTiles: QuadId[], reqWidth: number, reqHeight: number): Promise<boolean[]>;
    // (undocumented)
    protected fetchTileMapFromServer(level: number, row: number, column: number, width: number, height: number): Promise<any>;
    // (undocumented)
    protected getAvailableTilesFromCache(tiles: QuadId[]): {
        allTilesFound: boolean;
        available: boolean[];
    };
    // (undocumented)
    getChildrenAvailability(childIds: QuadId[]): Promise<boolean[]>;
    // (undocumented)
    protected getChildrenAvailabilityFromServer(childIds: QuadId[]): Promise<boolean[]>;
    // (undocumented)
    tileMapRequestSize: number;
}

// @internal (undocumented)
export class ArcGisUtilities {
    // (undocumented)
    static appendSecurityToken(url: URL, accessClient: MapLayerAccessClient, accessTokenParams: MapLayerAccessTokenParams): Promise<MapLayerAccessToken | undefined>;
    static checkForResponseErrorCode(response: Response): Promise<number | undefined>;
    static computeZoomLevelsScales(startZoom?: number, endZoom?: number, latitude?: number, tileSize?: number, screenDpi?: number): {
        zoom: number;
        resolution: number;
        scale: number;
    }[];
    // (undocumented)
    static getNationalMapSources(): Promise<MapLayerSource[]>;
    // (undocumented)
    static getServiceDirectorySources(url: string, baseUrl?: string): Promise<MapLayerSource[]>;
    static getServiceJson(url: string, formatId: string, userName?: string, password?: string, ignoreCache?: boolean, requireToken?: boolean): Promise<ArcGISServiceMetadata | undefined>;
    // (undocumented)
    static getSourcesFromQuery(range?: MapCartoRectangle, url?: string): Promise<MapLayerSource[]>;
    static getZoomLevelsScales(defaultMaxLod: number, tileSize: number, minScale?: number, maxScale?: number, tolerance?: number): {
        minLod?: number;
        maxLod?: number;
    };
    static isEpsg3857Compatible(tileInfo: any): boolean;
    static validateSource(url: string, formatId: string, capabilitiesFilter: string[], userName?: string, password?: string, ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal
export function areaToEyeHeight(view3d: ViewState3d, area: GlobalLocationArea, offset?: number): number;

// @internal
export function areaToEyeHeightFromGcs(view3d: ViewState3d, area: GlobalLocationArea, offset?: number): Promise<number>;

// @internal
export interface AttachToViewportArgs {
    drawingToSheetTransform?: Transform;
    invalidateDecorations: () => void;
}

// @public
export class AuxCoordSystem2dState extends AuxCoordSystemState implements AuxCoordSystem2dProps {
    constructor(props: AuxCoordSystem2dProps, iModel: IModelConnection);
    // (undocumented)
    angle: number;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem2dProps;
}

// @public
export class AuxCoordSystem3dState extends AuxCoordSystemState implements AuxCoordSystem3dProps {
    constructor(props: AuxCoordSystem3dProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    pitch: number;
    // (undocumented)
    roll: number;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem3dProps;
    // (undocumented)
    yaw: number;
}

// @public
export class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export abstract class AuxCoordSystemState extends ElementState implements AuxCoordSystemProps {
    constructor(props: AuxCoordSystemProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    static createNew(acsName: string, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    description?: string;
    // (undocumented)
    display(context: DecorateContext, options: ACSDisplayOptions): void;
    // (undocumented)
    drawGrid(context: DecorateContext): void;
    // (undocumented)
    static fromProps(props: AuxCoordSystemProps, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    abstract getOrigin(result?: Point3d): Point3d;
    abstract getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    get is3d(): boolean;
    static isOriginInView(drawOrigin: Point3d, viewport: Viewport, adjustOrigin: boolean): boolean;
    // (undocumented)
    isValidForView(view: ViewState): boolean;
    // (undocumented)
    abstract setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    abstract setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystemProps;
    // (undocumented)
    type: number;
}

// @internal (undocumented)
export class AzureMapsLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement): void;
    // (undocumented)
    constructUrl(y: number, x: number, zoom: number): Promise<string>;
}

// @internal
export class B3dmReader extends GltfReader {
    // (undocumented)
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, tileCenter: Point3d, transformToRoot?: Transform, isCanceled?: ShouldAbortReadGltf, idMap?: BatchedTileIdMap, deduplicateVertices?: boolean): B3dmReader | undefined;
    // (undocumented)
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readBatchTable(mesh: Mesh, json: any): void;
}

// @internal
export class BackgroundMapGeometry {
    constructor(_bimElevationBias: number, globeMode: GlobeMode, _iModel: IModelConnection);
    // (undocumented)
    addFrustumDecorations(builder: GraphicBuilder, frustum: Frustum): void;
    // (undocumented)
    readonly cartesianChordHeight: number;
    // (undocumented)
    readonly cartesianDiagonal: number;
    // (undocumented)
    readonly cartesianPlane: Plane3dByOriginAndUnitNormal;
    // (undocumented)
    readonly cartesianRange: Range3d;
    // (undocumented)
    readonly cartesianTransitionRange: Range3d;
    // (undocumented)
    cartographicToDb(cartographic: Cartographic, result?: Point3d): Point3d;
    // (undocumented)
    cartographicToDbFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    // (undocumented)
    dbToCartographic(db: XYAndZ, result?: Cartographic): Cartographic;
    // (undocumented)
    dbToCartographicFromGcs(db: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // (undocumented)
    readonly geometry: Plane3dByOriginAndUnitNormal | Ellipsoid;
    // (undocumented)
    static getCartesianRange(iModel: IModelConnection, result?: Range3d): Range3d;
    // (undocumented)
    static getCartesianTransitionDistance(iModel: IModelConnection): number;
    // (undocumented)
    getEarthEllipsoid(radiusOffset?: number): Ellipsoid;
    // (undocumented)
    getFrustumIntersectionDepthRange(frustum: Frustum, bimRange: Range3d, heightRange?: Range1d, gridPlane?: Plane3dByOriginAndUnitNormal, doGlobalScope?: boolean): Range1d;
    // (undocumented)
    getPlane(offset?: number): Plane3dByOriginAndUnitNormal;
    // (undocumented)
    getPointHeight(point: Point3d): number | undefined;
    // (undocumented)
    getRayIntersection(ray: Ray3d, positiveOnly: boolean): Ray3d | undefined;
    // (undocumented)
    readonly globeMatrix: Matrix3d;
    // (undocumented)
    readonly globeMode: GlobeMode;
    // (undocumented)
    readonly globeOrigin: Point3d;
    // (undocumented)
    static maxCartesianDistance: number;
    // (undocumented)
    readonly maxGeometryChordHeight: number;
}

// @beta
export abstract class BaseUnitFormattingSettingsProvider implements UnitFormattingSettingsProvider {
    constructor(_quantityFormatter: QuantityFormatter, _maintainOverridesPerIModel?: boolean | undefined);
    // (undocumented)
    protected applyQuantityFormattingSettingsForIModel: (imodel?: IModelConnection | undefined) => Promise<void>;
    protected buildQuantityFormatOverridesMap(): Promise<Map<UnitSystemKey, Map<string, FormatProps>>>;
    // (undocumented)
    protected get imodelConnection(): IModelConnection | undefined;
    // (undocumented)
    protected _imodelConnection: IModelConnection | undefined;
    // (undocumented)
    loadOverrides(imodel?: IModelConnection): Promise<void>;
    // (undocumented)
    get maintainOverridesPerIModel(): boolean;
    abstract remove(quantityTypeKey: QuantityTypeKey): Promise<boolean>;
    abstract retrieve(quantityTypeKey: QuantityTypeKey): Promise<OverrideFormatEntry | undefined>;
    abstract retrieveUnitSystem(defaultKey: UnitSystemKey): Promise<UnitSystemKey>;
    abstract store(quantityTypeKey: QuantityTypeKey, overrideProps: OverrideFormatEntry): Promise<boolean>;
    // (undocumented)
    storeFormatOverrides: ({ typeKey, overrideEntry, unitSystem }: QuantityFormatOverridesChangedArgs) => Promise<void>;
    abstract storeUnitSystemKey(unitSystemKey: UnitSystemKey): Promise<boolean>;
    storeUnitSystemSetting: ({ system }: FormattingUnitSystemChangedArgs) => Promise<void>;
}

// @internal
export class BatchedTileIdMap {
    constructor(iModel: IModelConnection);
    getBatchId(properties: any): Id64String;
    getBatchProperties(id: Id64String): any;
}

// @public
export interface BatchOptions {
    locateOnly?: boolean;
    noEmphasis?: boolean;
    noFlash?: boolean;
    noHilite?: boolean;
    // @beta
    tileId?: string;
}

// @public (undocumented)
export enum BeButton {
    // (undocumented)
    Data = 0,
    // (undocumented)
    Middle = 2,
    // (undocumented)
    Reset = 1
}

// @public
export class BeButtonEvent implements BeButtonEventProps {
    constructor(props?: BeButtonEventProps);
    button: BeButton;
    clone(): this;
    coordsFrom: CoordSource;
    init(props: BeButtonEventProps): void;
    inputSource: InputSource;
    invalidate(): void;
    get isAltKey(): boolean;
    get isControlKey(): boolean;
    isDoubleClick: boolean;
    isDown: boolean;
    isDragging: boolean;
    get isShiftKey(): boolean;
    get isValid(): boolean;
    keyModifiers: BeModifierKeys;
    // @internal
    get movement(): XAndY | undefined;
    set movement(mov: XAndY | undefined);
    get point(): Point3d;
    set point(pt: Point3d);
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    setFrom(src: BeButtonEvent): this;
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    viewport?: ScreenViewport;
}

// @public
export interface BeButtonEventProps {
    button?: BeButton;
    coordsFrom?: CoordSource;
    inputSource?: InputSource;
    isDoubleClick?: boolean;
    isDown?: boolean;
    isDragging?: boolean;
    // (undocumented)
    keyModifiers?: BeModifierKeys;
    point?: Point3d;
    rawPoint?: Point3d;
    viewPoint?: Point3d;
    viewport?: ScreenViewport;
}

// @public (undocumented)
export class BeButtonState {
    // (undocumented)
    get downRawPt(): Point3d;
    set downRawPt(pt: Point3d);
    // (undocumented)
    downTime: number;
    // (undocumented)
    get downUorPt(): Point3d;
    set downUorPt(pt: Point3d);
    // (undocumented)
    init(downUorPt: Point3d, downRawPt: Point3d, downTime: number, isDown: boolean, isDoubleClick: boolean, isDragging: boolean, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    isDoubleClick: boolean;
    // (undocumented)
    isDown: boolean;
    // (undocumented)
    isDragging: boolean;
}

// @public
export enum BeModifierKeys {
    // (undocumented)
    Alt = 4,
    // (undocumented)
    Control = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Shift = 2
}

// @public
export class BeTouchEvent extends BeButtonEvent implements BeTouchEventProps {
    constructor(props: BeTouchEventProps);
    // (undocumented)
    static findTouchById(list: TouchList, id: number): Touch | undefined;
    // (undocumented)
    static getTouchListCentroid(list: TouchList, vp: ScreenViewport): Point2d | undefined;
    // (undocumented)
    static getTouchPosition(touch: Touch, vp: ScreenViewport): Point2d;
    // (undocumented)
    get isDoubleTap(): boolean;
    // (undocumented)
    get isSingleTap(): boolean;
    // (undocumented)
    get isSingleTouch(): boolean;
    // (undocumented)
    get isTwoFingerTap(): boolean;
    // (undocumented)
    get isTwoFingerTouch(): boolean;
    // (undocumented)
    setFrom(src: BeTouchEvent): this;
    // (undocumented)
    tapCount: number;
    // (undocumented)
    get touchCount(): number;
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export interface BeTouchEventProps extends BeButtonEventProps {
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export class BeWheelEvent extends BeButtonEvent implements BeWheelEventProps {
    constructor(props?: BeWheelEventProps);
    // (undocumented)
    setFrom(src: BeWheelEvent): this;
    // (undocumented)
    time: number;
    // (undocumented)
    wheelDelta: number;
}

// @public
export interface BeWheelEventProps extends BeButtonEventProps {
    // (undocumented)
    time?: number;
    // (undocumented)
    wheelDelta?: number;
}

// @public
export class BingElevationProvider {
    constructor();
    // @internal (undocumented)
    getGeodeticToSeaLevelOffset(point: Point3d, iModel: IModelConnection): Promise<number>;
    getHeight(carto: Cartographic, geodetic?: boolean): Promise<any>;
    getHeightAverage(iModel: IModelConnection): Promise<number>;
    getHeightRange(iModel: IModelConnection): Promise<Range1d>;
    // @beta
    getHeights(range: Range2d): Promise<number[] | undefined>;
    getHeightValue(point: Point3d, iModel: IModelConnection, geodetic?: boolean): Promise<number>;
}

// @public
export class BingLocationProvider {
    constructor();
    getLocation(query: string): Promise<GlobalLocation | undefined>;
}

// @internal (undocumented)
export class BingMapsImageryLayerProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement, vp: ScreenViewport): void;
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get tileHeight(): number;
    // (undocumented)
    get tileWidth(): number;
}

// @public
export class BlankConnection extends IModelConnection {
    close(): Promise<void>;
    // @internal (undocumented)
    closeSync(): void;
    static create(props: BlankConnectionProps): BlankConnection;
    get iModelId(): undefined;
    // (undocumented)
    isBlankConnection(): this is BlankConnection;
    get isClosed(): boolean;
    get iTwinId(): GuidString | undefined;
    set iTwinId(iTwinId: GuidString | undefined);
}

// @public
export interface BlankConnectionProps {
    extents: Range3dProps;
    globalOrigin?: XYZProps;
    iTwinId?: GuidString;
    location: Cartographic | EcefLocationProps;
    name: string;
}

// @public
export class BriefcaseConnection extends IModelConnection {
    protected constructor(props: IModelConnectionProps, openMode: OpenMode);
    close(): Promise<void>;
    get editingScope(): GraphicalEditingScope | undefined;
    // @alpha
    readonly editorToolSettings: BriefcaseEditorToolSettings;
    enterEditingScope(): Promise<GraphicalEditingScope>;
    hasPendingTxns(): Promise<boolean>;
    get iModelId(): GuidString;
    // @internal (undocumented)
    isBriefcaseConnection(): this is BriefcaseConnection;
    get isClosed(): boolean;
    // (undocumented)
    protected _isClosed?: boolean;
    get iTwinId(): GuidString;
    // @internal
    readonly onBufferedModelChanges: BeEvent<(changedModelIds: Set<string>) => void>;
    static openFile(briefcaseProps: OpenBriefcaseProps): Promise<BriefcaseConnection>;
    static openStandalone(filePath: string, openMode?: OpenMode, opts?: StandaloneOpenOptions): Promise<BriefcaseConnection>;
    pullChanges(toIndex?: ChangesetIndex, options?: PullChangesOptions): Promise<void>;
    pushChanges(description: string): Promise<ChangesetIndexAndId>;
    saveChanges(description?: string): Promise<void>;
    supportsGraphicalEditing(): Promise<boolean>;
    readonly txns: BriefcaseTxns;
}

// @alpha
export class BriefcaseEditorToolSettings {
    get category(): Id64String | undefined;
    set category(category: Id64String | undefined);
    get model(): Id64String | undefined;
    set model(model: Id64String | undefined);
    readonly onCategoryChanged: BeEvent<(previousCategory: Id64String | undefined) => void>;
    readonly onModelChanged: BeEvent<(previousModel: Id64String | undefined) => void>;
}

// @public
export abstract class BriefcaseNotificationHandler extends NotificationHandler {
    constructor(_key: string);
    // (undocumented)
    abstract get briefcaseChannelName(): string;
    // (undocumented)
    get channelName(): string;
}

// @public
export class BriefcaseTxns extends BriefcaseNotificationHandler implements TxnNotifications {
    // @internal
    constructor(iModel: BriefcaseConnection);
    // @internal (undocumented)
    get briefcaseChannelName(): IpcAppChannel;
    // @internal (undocumented)
    dispose(): void;
    getRedoString(): Promise<string>;
    getUndoString(): Promise<string>;
    hasPendingTxns(): Promise<boolean>;
    isRedoPossible(): Promise<boolean>;
    isUndoPossible(): Promise<boolean>;
    // @internal (undocumented)
    notifyAfterUndoRedo(isUndo: boolean): void;
    // @internal (undocumented)
    notifyBeforeUndoRedo(isUndo: boolean): void;
    // @internal (undocumented)
    notifyChangesApplied(): void;
    // @internal (undocumented)
    notifyCommit(): void;
    // @internal (undocumented)
    notifyCommitted(hasPendingTxns: boolean, time: number): void;
    // @internal (undocumented)
    notifyEcefLocationChanged(ecef: EcefLocationProps | undefined): void;
    // @internal (undocumented)
    notifyElementsChanged(changed: ChangedEntities): void;
    // @internal (undocumented)
    notifyGeographicCoordinateSystemChanged(gcs: GeographicCRSProps | undefined): void;
    // @internal (undocumented)
    notifyGeometryGuidsChanged(changes: ModelIdAndGeometryGuid[]): void;
    // @internal (undocumented)
    notifyGlobalOriginChanged(origin: XYZProps): void;
    // @internal (undocumented)
    notifyIModelNameChanged(name: string): void;
    // @internal (undocumented)
    notifyModelsChanged(changed: ChangedEntities): void;
    // @internal (undocumented)
    notifyProjectExtentsChanged(range: Range3dProps): void;
    // @internal (undocumented)
    notifyPulledChanges(parentChangeset: ChangesetIndexAndId): void;
    // @internal (undocumented)
    notifyPushedChanges(parentChangeset: ChangesetIndexAndId): void;
    // @internal (undocumented)
    notifyRootSubjectChanged(subject: RootSubjectProps): void;
    readonly onAfterUndoRedo: BeEvent<(isUndo: boolean) => void>;
    readonly onBeforeUndoRedo: BeEvent<(isUndo: boolean) => void>;
    readonly onChangesApplied: BeEvent<() => void>;
    readonly onChangesPulled: BeEvent<(parentChangeset: ChangesetIndexAndId) => void>;
    readonly onChangesPushed: BeEvent<(parentChangeset: ChangesetIndexAndId) => void>;
    readonly onCommit: BeEvent<() => void>;
    readonly onCommitted: BeEvent<(hasPendingTxns: boolean, time: number) => void>;
    readonly onElementsChanged: BeEvent<(changes: Readonly<ChangedEntities>) => void>;
    readonly onModelGeometryChanged: BeEvent<(changes: ReadonlyArray<ModelIdAndGeometryGuid>) => void>;
    readonly onModelsChanged: BeEvent<(changes: Readonly<ChangedEntities>) => void>;
    reinstateTxn(): Promise<IModelStatus>;
    restartTxnSession(): Promise<void>;
    reverseAll(): Promise<IModelStatus>;
    reverseSingleTxn(): Promise<IModelStatus>;
    reverseTxns(numOperations: number): Promise<IModelStatus>;
}

// @internal (undocumented)
export type CachedDecoration = {
    type: "graphic";
    graphicType: GraphicType;
    graphicOwner: RenderGraphicOwner;
} | {
    type: "canvas";
    canvasDecoration: CanvasDecoration;
    atFront: boolean;
} | {
    type: "html";
    htmlElement: HTMLElement;
};

// @internal
export interface CachedIModelCoordinatesResponseProps {
    missing?: XYZProps[];
    result: Array<PointWithStatus | undefined>;
}

// @public
export function calculateEcefToDbTransformAtLocation(originIn: Point3d, iModel: IModelConnection): Promise<Transform | undefined>;

// @public
export interface CanvasDecoration {
    decorationCursor?: string;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    onMouseButton?(ev: BeButtonEvent): boolean;
    onMouseEnter?(ev: BeButtonEvent): void;
    onMouseLeave?(): void;
    onMouseMove?(ev: BeButtonEvent): void;
    onWheel?(ev: BeWheelEvent): boolean;
    pick?(pt: XAndY): boolean;
    position?: XAndY;
}

// @public
export type CanvasDecorationList = CanvasDecoration[];

// @public
export function canvasToImageBuffer(canvas: HTMLCanvasElement, format?: ImageBufferFormat): ImageBuffer | undefined;

// @public
export function canvasToResizedCanvasWithBars(canvasIn: HTMLCanvasElement, targetSize: Point2d, barSize?: Point2d, barStyle?: string): HTMLCanvasElement;

// @public
export class CategorySelectorState extends ElementState {
    constructor(props: CategorySelectorProps, iModel: IModelConnection);
    addCategories(arg: Id64Arg): void;
    // (undocumented)
    get categories(): Set<string>;
    set categories(categories: Set<string>);
    changeCategoryDisplay(arg: Id64Arg, add: boolean): void;
    // @internal (undocumented)
    static get className(): string;
    dropCategories(arg: Id64Arg): void;
    equalState(other: CategorySelectorState): boolean;
    has(id: Id64String): boolean;
    isCategoryViewed(categoryId: Id64String): boolean;
    get name(): string;
    // @internal (undocumented)
    get observableCategories(): ObservableSet<string>;
    // (undocumented)
    toJSON(): CategorySelectorProps;
}

// @internal
export class CesiumIonAssetProvider {
    static isProviderUrl(url: string): boolean;
    // (undocumented)
    static osmBuildingId: string;
    // (undocumented)
    static parseCesiumUrl(url: string): {
        id: number;
        key: string;
    } | undefined;
}

// @internal
export enum ChangeFlag {
    // (undocumented)
    All = 268435455,
    // (undocumented)
    AlwaysDrawn = 1,
    // (undocumented)
    DisplayStyle = 16,
    // (undocumented)
    FeatureOverrideProvider = 32,
    // (undocumented)
    Initial = 28,
    // (undocumented)
    NeverDrawn = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Overrides = 268435319,
    // (undocumented)
    ViewedCategories = 4,
    // (undocumented)
    ViewedCategoriesPerModel = 64,
    // (undocumented)
    ViewedModels = 8,
    // (undocumented)
    ViewState = 128
}

// @public
export class ChangeFlags {
    // @internal
    constructor(flags?: ChangeFlag);
    get alwaysDrawn(): boolean;
    // @internal
    areAllSet(flags: ChangeFlag): boolean;
    get areFeatureOverridesDirty(): boolean;
    get displayStyle(): boolean;
    get featureOverrideProvider(): boolean;
    // @internal (undocumented)
    protected _flags: ChangeFlag;
    get hasChanges(): boolean;
    // @internal
    isSet(flags: ChangeFlag): boolean;
    get neverDrawn(): boolean;
    // @internal (undocumented)
    get value(): ChangeFlag;
    get viewedCategories(): boolean;
    // @beta
    get viewedCategoriesPerModel(): boolean;
    get viewedModels(): boolean;
    get viewState(): boolean;
}

// @public
export interface ChangeViewedModel2dOptions {
    doFit?: boolean;
}

// @public
export interface CheckboxFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "checkbox";
    // (undocumented)
    getBool: (props: FormatProps) => boolean;
    // (undocumented)
    setBool: (props: FormatProps, isChecked: boolean) => FormatProps;
}

// @public
export class CheckpointConnection extends IModelConnection {
    close(): Promise<void>;
    get iModelId(): GuidString;
    isCheckpointConnection(): this is CheckpointConnection;
    get isClosed(): boolean;
    // (undocumented)
    protected _isClosed?: boolean;
    get iTwinId(): GuidString;
    static openRemote(iTwinId: string, iModelId: string, version?: IModelVersion): Promise<CheckpointConnection>;
}

// @public
export enum ClipEventType {
    // (undocumented)
    Clear = 3,
    // (undocumented)
    Modify = 2,
    // (undocumented)
    New = 0,
    // (undocumented)
    NewPlane = 1
}

// @public
export class Cluster<T extends Marker> {
    constructor(markers: T[]);
    // (undocumented)
    clusterMarker?: Marker;
    getClusterLocation(): Point3d;
    // (undocumented)
    readonly markers: T[];
    // (undocumented)
    get position(): Point3d;
}

// @beta
export type CollectTileStatus = "accept" | "reject" | "continue";

// @alpha (undocumented)
export enum CompassMode {
    // (undocumented)
    Polar = 0,
    // (undocumented)
    Rectangular = 1
}

// @public
export interface ComputeChordToleranceArgs {
    readonly computeRange: () => Range3d;
    readonly graphic: GraphicBuilder;
}

// @beta
export interface ComputeDisplayTransformArgs {
    elementId?: Id64String;
    modelId: Id64String;
    output?: Transform;
    timePoint?: number;
}

// @public
export function connectViewportFrusta(viewports: Iterable<Viewport>): () => void;

// @public
export function connectViewports(viewports: Iterable<Viewport>, sync: (changedViewport: Viewport) => SynchronizeViewports): () => void;

// @public
export function connectViewportViews(viewports: Iterable<Viewport>): () => void;

// @internal (undocumented)
export enum ContextMode {
    // (undocumented)
    Locked = 0,
    // (undocumented)
    None = 15,
    // (undocumented)
    XAxis = 1,
    // (undocumented)
    XAxis2 = 4,
    // (undocumented)
    YAxis = 2,
    // (undocumented)
    ZAxis = 3
}

// @public
export class ContextRealityModelState extends ContextRealityModel {
    // @internal
    constructor(props: ContextRealityModelProps, iModel: IModelConnection, displayStyle: DisplayStyleState);
    readonly iModel: IModelConnection;
    get isGlobal(): boolean;
    get modelId(): Id64String | undefined;
    readonly rdSourceKey: RealityDataSourceKey;
    get treeRef(): TileTreeReference;
}

// @public
export enum ContextRotationId {
    // (undocumented)
    Back = 4,
    // (undocumented)
    Bottom = 3,
    // (undocumented)
    Face = 7,
    // (undocumented)
    Front = 1,
    // (undocumented)
    Left = 2,
    // (undocumented)
    Right = 5,
    // (undocumented)
    Top = 0,
    // (undocumented)
    View = 6
}

// @internal
export class ContextShareProvider {
    // (undocumented)
    static getInfoFromBlobUrl(blobUrl: string): {
        provider: RealityDataProvider;
        format: RealityDataFormat;
        id: string;
    };
    static getInfoFromUrl(tilesetUrl: string): {
        provider: RealityDataProvider;
        format: RealityDataFormat;
        id: string;
        iTwinId: string | undefined;
    };
    static isProviderUrl(tilesetUrl: string): boolean;
}

// @public (undocumented)
export enum CoordinateLockOverrides {
    // (undocumented)
    ACS = 2,
    // (undocumented)
    All = 65535,
    // (undocumented)
    Grid = 4,
    // (undocumented)
    None = 0
}

// @public
export enum CoordSource {
    ElemSnap = 3,
    Precision = 1,
    TentativePoint = 2,
    User = 0
}

// @public
export enum CoordSystem {
    Npc = 1,
    View = 0,
    World = 2
}

// @internal (undocumented)
export class CoreTools {
    // (undocumented)
    static namespace: string;
    // (undocumented)
    static outputPromptByKey(key: string): void;
    // (undocumented)
    static tools: string;
    // (undocumented)
    static translate(prompt: string): string;
}

// @internal (undocumented)
export function createClassifierTileTreeReference(classifiers: SpatialClassifiers, classifiedTree: TileTreeReference, iModel: IModelConnection, source: ViewState | DisplayStyleState): SpatialClassifierTileTreeReference;

// @internal
export function createDefaultViewFlagOverrides(options: {
    clipVolume?: boolean;
    shadows?: boolean;
    lighting?: boolean;
    thematic?: false;
}): ViewFlagOverrides;

// @internal (undocumented)
export function createEmptyRenderPlan(): RenderPlan;

// @internal (undocumented)
export function createMapLayerTreeReference(layerSettings: MapLayerSettings, layerIndex: number, iModel: IModelConnection): MapLayerTileTreeReference | undefined;

// @internal (undocumented)
export function createMaskTreeReference(view: ViewState, model: GeometricModelState): TileTreeReference;

// @internal (undocumented)
export function createModelMapLayerTileTreeReference(layerSettings: ModelMapLayerSettings, layerIndex: number, iModel: IModelConnection): ModelMapLayerTileTreeReference | undefined;

// @internal (undocumented)
export function createOrbitGtTileTreeReference(props: OrbitGtTileTree.ReferenceProps): RealityModelTileTree.Reference;

// @internal (undocumented)
export function createPrimaryTileTreeReference(view: ViewState, model: GeometricModelState): PrimaryTreeReference;

// @internal (undocumented)
export function createRealityTileTreeReference(props: RealityModelTileTree.ReferenceProps): RealityModelTileTree.Reference;

// @public
export interface CreateRenderMaterialArgs {
    alpha?: number;
    diffuse?: MaterialDiffuseProps;
    // @internal
    source?: RenderMaterialSource;
    specular?: MaterialSpecularProps;
    textureMapping?: MaterialTextureMappingProps;
}

// @internal (undocumented)
export function createRenderPlanFromViewport(vp: Viewport): RenderPlan;

// @public
export interface CreateTextureArgs {
    image: TextureImage;
    ownership?: TextureOwnership;
    type?: RenderTexture.Type;
}

// @public
export interface CreateTextureFromSourceArgs {
    ownership?: TextureCacheOwnership & {
        key: string;
    } | "external";
    source: ImageSource;
    transparency?: TextureTransparency;
    type?: RenderTexture.Type;
}

// @internal (undocumented)
export class CurrentInputState {
    // (undocumented)
    adjustLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    button: BeButtonState[];
    // (undocumented)
    changeButtonToDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    clearKeyQualifiers(): void;
    // (undocumented)
    clearViewport(vp: Viewport): void;
    // (undocumented)
    fromButton(vp: ScreenViewport, pt: XAndY, source: InputSource, applyLocks: boolean): void;
    // (undocumented)
    fromPoint(vp: ScreenViewport, pt: XAndY, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    get isAltDown(): boolean;
    // (undocumented)
    get isControlDown(): boolean;
    // (undocumented)
    isDragging(button: BeButton): boolean;
    // (undocumented)
    get isShiftDown(): boolean;
    // (undocumented)
    isStartDrag(button: BeButton): boolean;
    // (undocumented)
    lastButton: BeButton;
    // (undocumented)
    lastMotion: Point2d;
    // (undocumented)
    lastTouchStart?: BeTouchEvent;
    // (undocumented)
    lastWheelEvent?: BeWheelEvent;
    // (undocumented)
    onButtonDown(button: BeButton): void;
    // (undocumented)
    onButtonUp(button: BeButton): void;
    // (undocumented)
    onInstallTool(): void;
    // (undocumented)
    onMotion(pt2d: XAndY): void;
    // (undocumented)
    onStartDrag(button: BeButton): void;
    // (undocumented)
    get point(): Point3d;
    set point(pt: Point3d);
    // (undocumented)
    qualifiers: BeModifierKeys;
    // (undocumented)
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    // (undocumented)
    setKeyQualifiers(ev: MouseEvent | KeyboardEvent | TouchEvent): void;
    // (undocumented)
    toEvent(ev: BeButtonEvent, useSnap: boolean): void;
    // (undocumented)
    toEventFromLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    touchTapCount?: number;
    // (undocumented)
    touchTapTimer?: number;
    // (undocumented)
    updateDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal (undocumented)
export enum CurrentState {
    // (undocumented)
    Active = 3,
    // (undocumented)
    Deactivated = 1,
    // (undocumented)
    Inactive = 2,
    // (undocumented)
    NotEnabled = 0
}

// @public
export interface CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "checkbox" | "text" | "select";
    // (undocumented)
    label: string;
}

// @public
export interface CustomGraphicBuilderOptions extends GraphicBuilderOptions {
    // (undocumented)
    applyAspectRatioSkew?: never;
    computeChordTolerance: (args: ComputeChordToleranceArgs) => number;
    iModel?: IModelConnection;
    // (undocumented)
    viewport?: never;
}

// @public
export interface CustomQuantityTypeDefinition extends QuantityTypeDefinition {
    isCompatibleFormatProps: (formatProps: FormatProps) => boolean;
    primaryPropEditorSpecs?: CustomFormatPropEditorSpec[];
    secondaryPropEditorSpecs?: CustomFormatPropEditorSpec[];
}

// @internal (undocumented)
export class DebugShaderFile {
    constructor(filename: string, src: string, isVS: boolean, isGL: boolean, isUsed: boolean);
    // (undocumented)
    readonly filename: string;
    // (undocumented)
    isGL: boolean;
    // (undocumented)
    isUsed: boolean;
    // (undocumented)
    isVS: boolean;
    // (undocumented)
    readonly src: string;
}

// @public
export class DecorateContext extends RenderContext {
    // @internal
    constructor(vp: ScreenViewport, decorations: Decorations, cache: DecorationsCache);
    addCanvasDecoration(decoration: CanvasDecoration, atFront?: boolean): void;
    addDecoration(type: GraphicType, decoration: RenderGraphic): void;
    addDecorationFromBuilder(builder: GraphicBuilder): void;
    // @internal (undocumented)
    addFromDecorator(decorator: ViewportDecorator): void;
    addHtmlDecoration(decoration: HTMLElement): void;
    createGraphic(options: Omit<ViewportGraphicBuilderOptions, "viewport">): GraphicBuilder;
    createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    // @internal (undocumented)
    drawStandardGrid(gridOrigin: Point3d, rMatrix: Matrix3d, spacing: XAndY, gridsPerRef: number, _isoGrid?: boolean, _fixedRepetitions?: Point2d): void;
    setSkyBox(graphic: RenderGraphic): void;
    setViewBackground(graphic: RenderGraphic): void;
    get viewport(): ScreenViewport;
}

// @public
export class Decorations implements IDisposable {
    // (undocumented)
    canvasDecorations?: CanvasDecorationList;
    // (undocumented)
    dispose(): void;
    get normal(): GraphicList | undefined;
    set normal(normal: GraphicList | undefined);
    get skyBox(): RenderGraphic | undefined;
    set skyBox(skyBox: RenderGraphic | undefined);
    get viewBackground(): RenderGraphic | undefined;
    set viewBackground(viewBackground: RenderGraphic | undefined);
    get viewOverlay(): GraphicList | undefined;
    set viewOverlay(viewOverlay: GraphicList | undefined);
    get world(): GraphicList | undefined;
    set world(world: GraphicList | undefined);
    get worldOverlay(): GraphicList | undefined;
    set worldOverlay(worldOverlay: GraphicList | undefined);
}

// @internal
export class DecorationsCache {
    add(decorator: ViewportDecorator, decoration: CachedDecoration): void;
    clear(): void;
    delete(decorator: ViewportDecorator): void;
    get(decorator: ViewportDecorator): CachedDecoration[] | undefined;
    prohibitRemoval: boolean;
    get size(): number;
}

// @public
export interface Decorator extends ViewportDecorator {
    getDecorationGeometry?(hit: HitDetail): GeometryStreamProps | undefined;
    getDecorationToolTip?(hit: HitDetail): Promise<HTMLElement | string>;
    onDecorationButtonEvent?(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    overrideElementHit?(hit: HitDetail): boolean;
    testDecorationHit?(id: string): boolean;
}

// @internal (undocumented)
export class DefaultViewTouchTool extends ViewManip implements Animator {
    constructor(startEv: BeTouchEvent, ev: BeTouchEvent, only2dManipulations?: boolean);
    animate(): boolean;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onStart(ev: BeTouchEvent): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchStart(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class DefineACSByElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class DefineACSByPointsTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
}

// @public
export interface DepthPointOptions {
    excludeDecorations?: boolean;
    excludeExternalIModels?: boolean;
    excludeNonLocatable?: boolean;
}

// @public
export enum DepthPointSource {
    ACS = 5,
    BackgroundMap = 2,
    Geometry = 0,
    Grid = 4,
    GroundPlane = 3,
    Map = 7,
    Model = 1,
    TargetPoint = 6
}

// @public
export interface DepthRangeNpc {
    maximum: number;
    minimum: number;
}

// @internal
export class DevTools {
    static connectToBackendInstance(tokenProps: IModelRpcProps): DevTools;
    ping(count: number): Promise<PingTestResult>;
    setLogLevel(inLoggerCategory: string, newLevel: LogLevel): Promise<LogLevel | undefined>;
    stats(options?: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(): Promise<any>;
}

// @public
export class DisclosedTileTreeSet implements Iterable<TileTree> {
    [Symbol.iterator](): Iterator<TileTree>;
    constructor(comparator?: OrderedComparator<TileTree, TileTree>);
    add(tree: TileTree): void;
    clear(): void;
    disclose(discloser: TileTreeDiscloser): void;
    has(tree: TileTree): boolean;
    get size(): number;
}

// @public
export class DisplayStyle2dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // (undocumented)
    get settings(): DisplayStyleSettings;
}

// @public
export class DisplayStyle3dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection, source?: DisplayStyle3dState);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    get environment(): Environment;
    set environment(env: Environment);
    // (undocumented)
    get lights(): LightSettings;
    set lights(lights: LightSettings);
    // @internal (undocumented)
    overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // @internal (undocumented)
    protected registerSettingsEventListeners(): void;
    setSunTime(time: number): void;
    // (undocumented)
    get settings(): DisplayStyle3dSettings;
    get solarShadows(): SolarShadowSettings;
    set solarShadows(settings: SolarShadowSettings);
    get sunDirection(): Readonly<Vector3d>;
}

// @public
export abstract class DisplayStyleState extends ElementState implements DisplayStyleProps {
    constructor(props: DisplayStyleProps, iModel: IModelConnection, source?: DisplayStyleState);
    // @internal (undocumented)
    anyMapLayersVisible(overlay: boolean): boolean;
    attachMapLayer(options: {
        settings: MapLayerSettings;
        isOverlay?: boolean;
        insertIndex?: number;
    }): void;
    // @internal (undocumented)
    attachMapLayerProps(options: {
        props: MapLayerProps;
        isOverlay?: boolean;
        insertIndex?: number;
    }): void;
    attachRealityModel(props: ContextRealityModelProps): ContextRealityModelState;
    get backgroundColor(): ColorDef;
    set backgroundColor(val: ColorDef);
    get backgroundMapBase(): BaseLayerSettings;
    set backgroundMapBase(base: BaseLayerSettings);
    // @internal (undocumented)
    get backgroundMapElevationBias(): number | undefined;
    // @internal (undocumented)
    get backgroundMapLayers(): MapLayerSettings[];
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    get baseMapTransparency(): number;
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    changeBackgroundMapProvider(props: BackgroundMapProviderProps): void;
    changeBaseMapTransparency(transparency: number): void;
    // (undocumented)
    changeMapLayerCredentials(index: number, isOverlay: boolean, userName?: string, password?: string): void;
    changeMapLayerProps(props: Partial<MapLayerProps>, index: number, isOverlay: boolean): void;
    changeMapSubLayerProps(props: Partial<MapSubLayerProps>, subLayerId: SubLayerId, layerIndex: number, isOverlay: boolean): void;
    changeRenderTimeline(timelineId: Id64String | undefined): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    get contextRealityModelStates(): ReadonlyArray<ContextRealityModelState>;
    // @internal (undocumented)
    protected createRealityModel(props: ContextRealityModelProps): ContextRealityModelState;
    detachMapLayerByIndex(index: number, isOverlay: boolean): void;
    // @internal (undocumented)
    detachMapLayerByNameAndSource(name: string, source: string, isOverlay: boolean): void;
    detachRealityModelByNameAndUrl(name: string, url: string): boolean;
    // @internal (undocumented)
    get displayTerrain(): boolean;
    dropSubCategoryOverride(id: Id64String): void;
    equalState(other: DisplayStyleState): boolean;
    findMapLayerIndexByNameAndSource(name: string, source: string, isOverlay: boolean): number;
    forEachRealityModel(func: (model: ContextRealityModelState) => void): void;
    // @internal (undocumented)
    forEachRealityTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    getBackgroundMapGeometry(): BackgroundMapGeometry | undefined;
    // @internal (undocumented)
    getGlobalGeometryAndHeightRange(): {
        geometry: BackgroundMapGeometry;
        heightRange: Range1d;
    } | undefined;
    // @internal (undocumented)
    getIsBackgroundMapVisible(): boolean;
    // @internal
    getMapLayerRange(layerIndex: number, isOverlay: boolean): Promise<MapCartoRectangle | undefined>;
    // @internal (undocumented)
    getMapLayers(isOverlay: boolean): MapLayerSettings[];
    getOSMBuildingRealityModel(): ContextRealityModelState | undefined;
    // @internal (undocumented)
    getPlanarClipMaskState(modelId: Id64String): PlanarClipMaskState | undefined;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    get globeMode(): GlobeMode;
    // @internal (undocumented)
    hasAttachedMapLayer(name: string, source: string, isOverlay: boolean): boolean;
    hasAttachedRealityModel(name: string, url: string): boolean;
    get hasSubCategoryOverride(): boolean;
    is3d(): this is DisplayStyle3dState;
    load(): Promise<void>;
    // (undocumented)
    mapLayerAtIndex(index: number, isOverlay: boolean): MapLayerSettings | undefined;
    get monochromeColor(): ColorDef;
    set monochromeColor(val: ColorDef);
    moveMapLayerToBottom(index: number, isOverlay: boolean): void;
    moveMapLayerToIndex(fromIndex: number, toIndex: number, isOverlay: boolean): void;
    moveMapLayerToTop(index: number, isOverlay: boolean): void;
    get name(): string;
    readonly onOSMBuildingDisplayChanged: BeEvent<(osmBuildingDisplayEnabled: boolean) => void>;
    readonly onScheduleScriptChanged: BeEvent<(newScript: RenderSchedule.Script | undefined) => void>;
    // @deprecated
    readonly onScheduleScriptReferenceChanged: BeEvent<(newScriptReference: RenderSchedule.ScriptReference | undefined) => void>;
    // @internal (undocumented)
    get overlayMapLayers(): MapLayerSettings[];
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @internal (undocumented)
    abstract overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // @internal (undocumented)
    protected queryRenderTimelineProps(timelineId: Id64String): Promise<RenderTimelineProps | undefined>;
    // @internal (undocumented)
    protected _queryRenderTimelinePropsPromise?: Promise<RenderTimelineProps | undefined>;
    // @internal (undocumented)
    protected registerSettingsEventListeners(): void;
    get scheduleScript(): RenderSchedule.Script | undefined;
    set scheduleScript(script: RenderSchedule.Script | undefined);
    // @deprecated
    get scheduleScriptReference(): RenderSchedule.ScriptReference | undefined;
    setOSMBuildingDisplay(options: OsmBuildingDisplayOptions): boolean;
    abstract get settings(): DisplayStyleSettings;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    // @internal
    viewMapLayerRange(layerIndex: number, isOverlay: boolean, vp: ScreenViewport): Promise<boolean>;
    // @internal (undocumented)
    get wantShadows(): boolean;
}

// @internal
export function disposeTileTreesForGeometricModels(modelIds: Set<Id64String>, iModel: IModelConnection): void;

// @public
export type DownloadBriefcaseId = {
    syncMode?: SyncMode;
    briefcaseId?: never;
} | {
    briefcaseId: number;
    syncMode?: never;
};

// @public
export type DownloadBriefcaseOptions = DownloadBriefcaseId & {
    fileName?: string;
    progressCallback?: OnDownloadProgress;
    progressInterval?: number;
};

// @public
export interface DownloadProgressInfo {
    loaded: number;
    total: number;
}

// @internal
export interface DrawClipOptions {
    color?: ColorDef;
    fill?: ColorDef;
    fillClipPlanes?: boolean;
    hasPrimaryPlane?: boolean;
    hiddenStyle?: LinePixels;
    hiddenWidth?: number;
    id?: string;
    visibleWidth?: number;
}

// @public
export class DrawingModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class DrawingViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, extents: AxisAlignedBox3d, sectionDrawing?: SectionDrawingViewProps);
    // @internal
    static alwaysDisplaySpatialView: boolean;
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    // @internal
    get attachment(): Object | undefined;
    // @internal
    get attachmentInfo(): Object;
    // @internal (undocumented)
    attachToViewport(args: AttachToViewportArgs): void;
    // @internal (undocumented)
    changeViewedModel(modelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): DrawingViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // (undocumented)
    get defaultExtentLimits(): ExtentLimits;
    // @internal (undocumented)
    detachFromViewport(): void;
    // @internal (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // @internal (undocumented)
    getExtents(): Vector3d;
    // @internal (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal
    static hideDrawingGraphics: boolean;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // @internal (undocumented)
    protected postload(hydrateResponse: HydrateViewStateResponseProps): Promise<void>;
    // @internal (undocumented)
    protected preload(hydrateRequest: HydrateViewStateRequestProps): void;
    // @internal (undocumented)
    get secondaryViewports(): Iterable<Viewport>;
    // @internal
    get sectionDrawingInfo(): SectionDrawingInfo;
    // @internal
    get sectionDrawingProps(): SectionDrawingViewProps | undefined;
    // (undocumented)
    toProps(): ViewStateProps;
}

// @internal
export abstract class DynamicIModelTile extends Tile {
    protected constructor(params: TileParams, tree: TileTree);
    abstract get appearanceProvider(): FeatureAppearanceProvider;
    // (undocumented)
    static create(root: RootIModelTile, elements: Iterable<ElementGeometryChange>): DynamicIModelTile;
    abstract handleGeometryChanges(changes: Iterable<ElementGeometryChange>): void;
    abstract get hiddenElements(): Id64Array;
    abstract pruneChildren(olderThan: BeTimePoint): void;
    abstract selectTiles(selected: Tile[], args: TileDrawArgs): void;
}

// @public
export class DynamicsContext extends RenderContext {
    addGraphic(graphic: RenderGraphic): void;
    // @internal (undocumented)
    changeDynamics(): void;
    createGraphic(options: Omit<ViewportGraphicBuilderOptions, "viewport">): GraphicBuilder;
}

// @public
export namespace EditManipulator {
    export enum EventType {
        Accept = 2,
        Cancel = 1,
        Synch = 0
    }
    export abstract class HandleProvider {
        constructor(iModel: IModelConnection);
        // (undocumented)
        protected clearControls(): void;
        protected abstract createControls(): Promise<boolean>;
        decorate(_context: DecorateContext): void;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        protected _isActive: boolean;
        protected abstract modifyControls(_hit: HitDetail, _ev: BeButtonEvent): Promise<boolean>;
        onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
        protected onDoubleClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onManipulatorEvent(_eventType: EventType): void;
        onManipulatorToolEvent(_tool: Tool, event: ManipulatorToolEvent): void;
        protected onRightClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        onSelectionChanged(ev: SelectionSetEvent): void;
        protected onTouchTap(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected _removeDecorationListener?: () => void;
        // (undocumented)
        protected _removeManipulatorToolListener?: () => void;
        // (undocumented)
        protected _removeSelectionListener?: () => void;
        protected stop(): void;
        // (undocumented)
        protected updateControls(): Promise<void>;
        protected updateDecorationListener(add: boolean): void;
    }
    export abstract class HandleTool extends InputCollector {
        constructor(manipulator: HandleProvider);
        protected abstract accept(_ev: BeButtonEvent): boolean;
        protected cancel(_ev: BeButtonEvent): boolean;
        // (undocumented)
        static hidden: boolean;
        protected init(): void;
        // (undocumented)
        readonly manipulator: HandleProvider;
        protected onComplete(_ev: BeButtonEvent, event: EventType): Promise<EventHandled>;
        // (undocumented)
        onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onPostInstall(): Promise<void>;
        // (undocumented)
        onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onTouchCancel(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchComplete(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchMove(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        static toolId: string;
        protected get wantAccuSnap(): boolean;
    }
    export class HandleUtils {
        static adjustForBackgroundColor(color: ColorDef, vp: Viewport): ColorDef;
        static getArrowShape(baseStart?: number, baseWidth?: number, tipStart?: number, tipEnd?: number, tipWidth?: number, flangeStart?: number, flangeWidth?: number): Point3d[];
        static getArrowTransform(vp: Viewport, base: Point3d, direction: Vector3d, sizeInches: number): Transform | undefined;
    }
}

// @internal (undocumented)
export const ELEMENT_MARKED_FOR_REMOVAL: unique symbol;

// @alpha
export class ElementAgenda {
    constructor(iModel: IModelConnection);
    add(arg: Id64Arg): boolean;
    clear(): void;
    compressIds(): CompressedId64Set;
    // (undocumented)
    get count(): number;
    readonly elements: Id64Array;
    find(id: Id64String): boolean;
    getSource(): ModifyElementSource;
    readonly groupMarks: GroupMark[];
    has(id: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(arg: Id64Arg): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    manageHiliteState: boolean;
    orderIds(): OrderedId64Array;
    popGroup(): void;
    // (undocumented)
    remove(arg: Id64Arg): boolean;
    setSource(val: ModifyElementSource): void;
}

// @public (undocumented)
export class ElementLocateManager {
    // (undocumented)
    get apertureInches(): number;
    // (undocumented)
    clear(): void;
    // (undocumented)
    currHit?: HitDetail;
    // (undocumented)
    doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, view: ScreenViewport | undefined, source: InputSource, filterHits?: boolean): Promise<HitDetail | undefined>;
    // (undocumented)
    filterHit(hit: HitDetail, _action: LocateAction, out: LocateResponse): Promise<LocateFilterStatus>;
    static getFailureMessageKey(key: string): string;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    getPreLocatedHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    initLocateOptions(): void;
    // (undocumented)
    initToolLocate(): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    readonly options: LocateOptions;
    // (undocumented)
    readonly picker: ElementPicker;
    // (undocumented)
    setCurrHit(hit?: HitDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    get touchApertureInches(): number;
}

// @public (undocumented)
export class ElementPicker {
    doPick(vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): number;
    // (undocumented)
    empty(): void;
    getHit(i: number): HitDetail | undefined;
    getHitList(takeOwnership: boolean): HitList<HitDetail>;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    readonly pickPointWorld: Point3d;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    testHit(hit: HitDetail, vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): boolean;
    // (undocumented)
    viewport?: Viewport;
}

// @alpha
export abstract class ElementSetTool extends PrimitiveTool {
    protected get agenda(): ElementAgenda;
    protected get allowDragSelect(): boolean;
    protected get allowGroups(): boolean;
    protected get allowSelectionSet(): boolean;
    protected anchorPoint?: Point3d;
    protected buildDragSelectAgenda(vp: Viewport, origin: Point3d, corner: Point3d, method: SelectionMethod, overlap: boolean): Promise<boolean>;
    protected buildLocateAgenda(hit: HitDetail): Promise<boolean>;
    protected buildSelectionSetAgenda(ss: SelectionSet): Promise<boolean>;
    protected chooseNextHit(ev: BeButtonEvent): Promise<EventHandled>;
    protected get clearSelectionSet(): boolean;
    protected get controlKeyContinuesSelection(): boolean;
    protected get controlKeyInvertsSelection(): boolean;
    protected get currentElementCount(): number;
    decorate(context: DecorateContext): void;
    protected doLocate(ev: BeButtonEvent, newSearch: boolean): Promise<boolean>;
    protected doProcessSelectionSetImmediate(): Promise<void>;
    protected dragStartPoint?: Point3d;
    filterHit(hit: HitDetail, out?: LocateResponse): Promise<LocateFilterStatus>;
    protected gatherElements(ev: BeButtonEvent): Promise<EventHandled | undefined>;
    protected gatherInput(ev: BeButtonEvent): Promise<EventHandled | undefined>;
    protected getDragSelectCandidates(vp: Viewport, origin: Point3d, corner: Point3d, method: SelectionMethod, overlap: boolean): Promise<Id64Arg>;
    protected getGroupIds(id: Id64String): Promise<Id64Arg>;
    protected getLocateCandidates(hit: HitDetail): Promise<Id64Arg>;
    protected getSelectionSetCandidates(ss: SelectionSet): Promise<Id64Arg>;
    // (undocumented)
    protected initAgendaDynamics(): Promise<boolean>;
    protected isElementIdValid(id: Id64String, source: ModifyElementSource): boolean;
    protected isElementValidForOperation(hit: HitDetail, _out?: LocateResponse): Promise<boolean>;
    protected get isSelectByPoints(): boolean;
    protected get isSelectionSetModify(): boolean;
    protected onAgendaModified(): Promise<void>;
    onCleanup(): Promise<void>;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onPostInstall(): Promise<void>;
    protected onProcessComplete(): Promise<void>;
    onReinitialize(): Promise<void>;
    // (undocumented)
    onResetButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    onUnsuspend(): Promise<void>;
    protected processAgenda(_ev: BeButtonEvent): Promise<void>;
    protected processAgendaImmediate(): Promise<void>;
    protected processDataButton(ev: BeButtonEvent): Promise<EventHandled>;
    protected processResetButton(ev: BeButtonEvent): Promise<EventHandled>;
    protected provideToolAssistance(mainInstrText?: string, additionalInstr?: ToolAssistanceInstruction[]): void;
    protected get requireAcceptForSelectionSetDynamics(): boolean;
    protected get requireAcceptForSelectionSetOperation(): boolean;
    protected get requiredElementCount(): number;
    protected selectByPointsDecorate(context: DecorateContext): void;
    protected selectByPointsEnd(ev: BeButtonEvent): Promise<boolean>;
    protected selectByPointsStart(ev: BeButtonEvent): Promise<boolean>;
    protected setPreferredElementSource(): void;
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected get shouldEnableLocate(): boolean;
    // (undocumented)
    protected get shouldEnableSnap(): boolean;
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    protected get wantAccuSnap(): boolean;
    protected get wantAdditionalElements(): boolean;
    protected get wantAdditionalInput(): boolean;
    protected get wantDynamics(): boolean;
    protected wantProcessAgenda(_ev: BeButtonEvent): boolean;
}

// @public
export class ElementState extends EntityState implements ElementProps {
    constructor(props: ElementProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    readonly code: Code;
    readonly federationGuid?: GuidString;
    readonly model: Id64String;
    readonly parent?: RelatedElement;
    toJSON(): ElementProps;
    readonly userLabel?: string;
}

// @internal
export class EllipsoidTerrainProvider extends TerrainMeshProvider {
    constructor(opts: TerrainMeshProviderOptions);
    // (undocumented)
    getChildHeightRange(_quadId: QuadId, _rectangle: MapCartoRectangle, _parent: MapTile): Range1d | undefined;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    readMesh(args: ReadMeshArgs): Promise<RealityMeshParams | undefined>;
    // (undocumented)
    requestMeshData(): Promise<TileRequest.Response>;
    // (undocumented)
    get tilingScheme(): MapTilingScheme;
}

// @public
export class EmphasizeElements implements FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, vp: Viewport): void;
    static clear(vp: Viewport, inactiveOnly?: boolean): void;
    clearAlwaysDrawnElements(vp: Viewport): boolean;
    clearEmphasizedElements(vp: Viewport): boolean;
    clearEmphasizedIsolatedElements(vp: Viewport, setToAlwaysDrawn: boolean): boolean;
    clearHiddenElements(vp: Viewport): boolean;
    clearIsolatedElements(vp: Viewport): boolean;
    clearNeverDrawnElements(vp: Viewport): boolean;
    clearOverriddenElements(vp: Viewport, keyOrIds?: number | Id64Arg): boolean;
    // @internal (undocumented)
    protected createAppearanceFromKey(key: number): FeatureAppearance;
    createDefaultAppearance(): FeatureAppearance;
    createOverrideKey(color: ColorDef, override: FeatureOverrideType): number | undefined;
    get defaultAppearance(): FeatureAppearance | undefined;
    set defaultAppearance(appearance: FeatureAppearance | undefined);
    emphasizeElements(ids: Id64Arg, vp: Viewport, defaultAppearance?: FeatureAppearance, replace?: boolean): boolean;
    emphasizeSelectedElements(vp: Viewport, defaultAppearance?: FeatureAppearance, replace?: boolean, clearSelection?: boolean): boolean;
    fromJSON(props: EmphasizeElementsProps, vp: Viewport): boolean;
    static get(vp: Viewport): EmphasizeElements | undefined;
    getAlwaysDrawnElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedIsolatedElements(): Id64Set | undefined;
    getHiddenElements(vp: Viewport): Id64Set | undefined;
    getIsolatedElements(vp: Viewport): Id64Set | undefined;
    getNeverDrawnElements(vp: Viewport): Id64Set | undefined;
    static getOrCreate(vp: Viewport): EmphasizeElements;
    getOverriddenElements(): Map<number, Id64Set> | undefined;
    getOverriddenElementsByKey(key: number): Id64Set | undefined;
    getOverrideFromKey(key: number): {
        overrideType: FeatureOverrideType;
        color: ColorDef;
    };
    hideElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    hideSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    isActive(vp: Viewport): boolean;
    isolateElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    isolateSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    overrideElements(ids: Id64Arg, vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean): boolean;
    overrideSelectedElements(vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean, clearSelection?: boolean): boolean;
    // @internal
    setAlwaysDrawnElements(ids: Id64Arg, vp: Viewport, exclusive?: boolean, replace?: boolean): boolean;
    // @internal
    setNeverDrawnElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    toJSON(vp: Viewport): EmphasizeElementsProps;
    get unanimatedAppearance(): FeatureAppearance | undefined;
    set unanimatedAppearance(appearance: FeatureAppearance | undefined);
    // @internal (undocumented)
    protected updateIdSet(ids: Id64Arg, replace: boolean, existingIds?: Id64Set): Id64Set | undefined;
    wantEmphasis: boolean;
}

// @beta
export class EngineeringLengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @public
export class EntityState implements EntityProps {
    constructor(props: EntityProps, iModel: IModelConnection, _state?: EntityState);
    readonly classFullName: string;
    static get classFullName(): string;
    static get className(): string;
    get className(): string;
    clone(iModel?: IModelConnection): this;
    equals(other: this): boolean;
    readonly id: Id64String;
    readonly iModel: IModelConnection;
    readonly jsonProperties: {
        [key: string]: any;
    };
    static get schemaName(): string;
    // @internal (undocumented)
    toJSON(): EntityProps;
}

// @internal (undocumented)
export class EnvironmentDecorations {
    constructor(view: ViewState3d, onLoaded: () => void, onDispose: () => void);
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected _environment: Environment;
    // (undocumented)
    protected _ground?: GroundPlaneDecorations;
    // (undocumented)
    protected readonly _onDispose: () => void;
    // (undocumented)
    protected readonly _onLoaded: () => void;
    // (undocumented)
    setEnvironment(env: Environment): void;
    // (undocumented)
    protected _sky: SkyBoxDecorations;
    // (undocumented)
    protected readonly _view: ViewState3d;
}

// @public
export class EventController {
    constructor(vp: ScreenViewport);
    // (undocumented)
    destroy(): void;
    // (undocumented)
    vp: ScreenViewport;
}

// @public (undocumented)
export enum EventHandled {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @alpha
export interface ExtensionManifest {
    readonly activationEvents: ActivationEvent[];
    readonly description?: string;
    readonly displayName?: string;
    readonly main: string;
    readonly module?: string;
    readonly name: string;
    readonly version: string;
}

// @alpha
export interface ExtensionProvider {
    execute: ResolveFunc;
    getManifest: ResolveManifestFunc;
    readonly hostname?: string;
}

// @public
export interface ExtentLimits {
    max: number;
    min: number;
}

// @internal
export interface ExternalTileStatistics {
    // (undocumented)
    ready: number;
    // (undocumented)
    requested: number;
    // (undocumented)
    selected: number;
}

// @public
export function extractImageSourceDimensions(source: ImageSource): Promise<Point2d>;

// @internal
export function eyeToCartographicOnGlobe(viewport: ScreenViewport, preserveHeight?: boolean): Cartographic | undefined;

// @internal
export function eyeToCartographicOnGlobeFromGcs(viewport: ScreenViewport, preserveHeight?: boolean): Promise<Cartographic | undefined>;

// @public
export interface FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void;
}

// @public
export namespace FeatureSymbology {
    export class Overrides extends FeatureOverrides {
        constructor(view?: ViewState | Viewport);
        // @internal
        initFromView(view: ViewState): void;
        // @internal
        initFromViewport(viewport: Viewport): void;
        // @alpha (undocumented)
        get source(): Source | undefined;
        // @alpha
        static withSource(source: Source, view?: ViewState | Viewport): Overrides;
    }
    // @alpha
    export interface Source {
        readonly onSourceDisposed: BeEvent<() => void>;
    }
}

// @public
export class FitViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    doFit(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isolatedOnly: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class Flags {
    // (undocumented)
    animateRotation: boolean;
    // (undocumented)
    auxRotationPlane: RotationMode;
    // (undocumented)
    baseMode: number;
    // (undocumented)
    baseRotation: RotationMode;
    // (undocumented)
    bearingFixToPlane2D: boolean;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    dialogNeedsUpdate: boolean;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    haveValidOrigin: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    inDataPoint: boolean;
    // (undocumented)
    indexLocked: boolean;
    // (undocumented)
    lockedRotation: boolean;
    // (undocumented)
    pointIsOnPlane: boolean;
    // (undocumented)
    redrawCompass: boolean;
    // (undocumented)
    rotationNeedsUpdate: boolean;
    // (undocumented)
    softAngleLock: boolean;
}

// @public
export enum FlashMode {
    Brighten = 1,
    Hilite = 0
}

// @public
export class FlashSettings {
    constructor(options?: FlashSettingsOptions);
    clone(options?: FlashSettingsOptions): FlashSettings;
    readonly duration: BeDuration;
    readonly litMode: FlashMode;
    readonly maxIntensity: number;
}

// @public
export type FlashSettingsOptions = Mutable<Partial<FlashSettings>>;

// @public
export class FlyViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export function formatAnimationBranchId(modelId: Id64String, branchId: number): string;

// @beta
export abstract class FormattedQuantityDescription extends BaseQuantityDescription {
    constructor(name: string, displayLabel: string, iconSpec?: string);
    // (undocumented)
    abstract get formatterQuantityType(): QuantityType;
    // (undocumented)
    get formatterSpec(): FormatterSpec | undefined;
    // (undocumented)
    protected formatValue(numberValue: number): string;
    // (undocumented)
    abstract get parseError(): string;
    // (undocumented)
    get parserSpec(): ParserSpec | undefined;
    // (undocumented)
    protected parseString(userInput: string): ParseResults;
}

// @public
export interface FormatterParserSpecsProvider {
    createFormatterSpec: (unitSystem: UnitSystemKey) => Promise<FormatterSpec>;
    createParserSpec: (unitSystem: UnitSystemKey) => Promise<ParserSpec>;
    quantityType: QuantityTypeArg;
}

// @public
export interface FormattingUnitSystemChangedArgs {
    readonly system: UnitSystemKey;
}

// @internal (undocumented)
export interface FrameBeforeRenderData {
    // (undocumented)
    renderSystem: System;
    // (undocumented)
    setSceneNeedRedraw: (redraw: boolean) => void;
    // (undocumented)
    viewport: Viewport;
}

// @internal (undocumented)
export interface FrameCameraFrustumData {
    // (undocumented)
    back: number;
    // (undocumented)
    bottom: number;
    // (undocumented)
    front: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
    // (undocumented)
    type: FrustumUniformType;
}

// @internal (undocumented)
export interface FrameCameraViewData {
    // (undocumented)
    cameraPosition: Point3d;
    // (undocumented)
    viewX: Vector3d;
    // (undocumented)
    viewY: Vector3d;
    // (undocumented)
    viewZ: Vector3d;
}

// @internal (undocumented)
export interface FrameRenderData {
    // (undocumented)
    commands: RenderCommands;
    // (undocumented)
    compositeFlags: CompositeFlags;
    // (undocumented)
    fbo: FrameBuffer;
    // (undocumented)
    frameBufferStack: FrameBufferStack;
    // (undocumented)
    needComposite: boolean;
}

// @alpha
export interface FrameStats {
    animationTime: number;
    backgroundTime: number;
    classifiersTime: number;
    createChangeSceneTime: number;
    decorationsTime: number;
    frameId: number;
    onBeforeRenderTime: number;
    onRenderOpaqueTime: number;
    opaqueTime: number;
    overlaysTime: number;
    screenspaceEffectsTime: number;
    setupViewTime: number;
    shadowsTime: number;
    totalFrameTime: number;
    totalSceneTime: number;
    translucentTime: number;
    validateRenderPlanTime: number;
}

// @internal (undocumented)
export class FrameStatsCollector {
    constructor(onFrameStatsReady?: OnFrameStatsReadyEvent);
    // (undocumented)
    beginFrame(): void;
    // (undocumented)
    beginTime(entry: keyof FrameStats): void;
    // (undocumented)
    endFrame(wasFrameDrawn?: boolean): void;
    // (undocumented)
    endTime(entry: keyof FrameStats): void;
}

// @public (undocumented)
export interface FrontendHubAccess {
    getChangesetFromNamedVersion(arg: IModelIdArg & {
        versionName?: string;
    }): Promise<ChangesetIndexAndId>;
    // (undocumented)
    getChangesetFromVersion(arg: IModelIdArg & {
        version: IModelVersion;
    }): Promise<ChangesetIndexAndId>;
    // (undocumented)
    getLatestChangeset(arg: IModelIdArg): Promise<ChangesetIndexAndId>;
}

// @public
export enum FrontendLoggerCategory {
    // @alpha
    Extensions = "core-frontend.Extensions",
    // @alpha
    FeatureTracking = "core-frontend.FeatureTracking",
    IModelConnection = "core-frontend.IModelConnection",
    NativeApp = "core-frontend.NativeApp",
    // (undocumented)
    Package = "core-frontend",
    // @alpha
    RealityData = "core-frontend.RealityData",
    Render = "core-frontend.Render",
    Request = "core-frontend.Request"
}

// @public
export interface FrontendSecurityOptions {
    readonly csrfProtection?: {
        readonly enabled: boolean;
        readonly cookieName?: string;
        readonly headerName?: string;
    };
}

// @public
export namespace Frustum2d {
    const minimumZDistance = 1;
    const minimumZExtents: Readonly<Range1d>;
    export function depthFromDisplayPriority(priority: number): number;
}

// @public
export class FrustumAnimator implements Animator {
    constructor(options: ViewAnimationOptions, viewport: ScreenViewport, begin: ViewPose, end: ViewPose);
    // @internal (undocumented)
    animate(): boolean;
    // @internal (undocumented)
    interrupt(): void;
    // (undocumented)
    options: ViewAnimationOptions;
}

// @public (undocumented)
export class FuzzySearch<T> {
    onGetMultiWordSearchOptions(): Fuse_2.FuseOptions<T>;
    onGetSingleWordSearchOptions(): Fuse_2.FuseOptions<T>;
    search(searchedObjects: T[], keys: Array<keyof T>, pattern: string): FuzzySearchResults<T>;
}

// @public
export interface FuzzySearchResult<T> {
    getBoldMask(): boolean[];
    getMatchedKey(): string;
    getMatchedValue(): string;
    getResult(): T;
}

// @public
export class FuzzySearchResults<T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator](): any;
    constructor(results: any[] | undefined);
    // (undocumented)
    getResult(resultIndex: number): FuzzySearchResult<T> | undefined;
    // (undocumented)
    get length(): number;
    // (undocumented)
    results: any[];
}

// @beta
export interface GenericAbortSignal {
    addEventListener: (type: "abort", listener: (this: GenericAbortSignal, ev: any) => any) => void;
    removeEventListener: (type: "abort", listener: (this: GenericAbortSignal, ev: any) => any) => void;
}

// @internal
export class GeoConverter {
    constructor(iModel: IModelConnection, datumOrGCRS: string | GeographicCRSProps);
    // (undocumented)
    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps;
    // (undocumented)
    getGeoCoordinatesFromIModelCoordinates(iModelPoints: XYZProps[]): Promise<GeoCoordinatesResponseProps>;
    // (undocumented)
    getIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): Promise<IModelCoordinatesResponseProps>;
}

// @beta
export class GeographicTilingScheme extends MapTilingScheme {
    constructor(numberOfLevelZeroTilesX?: number, numberOfLevelZeroTilesY?: number, rowZeroAtNorthPole?: boolean);
    // @internal
    latitudeToYFraction(latitude: number): number;
    // @internal
    yFractionToLatitude(yFraction: number): number;
}

// @public
export class GeometricModel2dState extends GeometricModelState implements GeometricModel2dProps {
    constructor(props: GeometricModel2dProps, iModel: IModelConnection, state?: GeometricModel2dState);
    // @internal (undocumented)
    get asGeometricModel2d(): GeometricModel2dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    readonly globalOrigin: Point2d;
    // @internal (undocumented)
    get is3d(): boolean;
    // (undocumented)
    toJSON(): GeometricModel2dProps;
}

// @public
export class GeometricModel3dState extends GeometricModelState {
    constructor(props: GeometricModel3dProps, iModel: IModelConnection, state?: GeometricModel3dState);
    // @internal (undocumented)
    get asGeometricModel3d(): GeometricModel3dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    get is3d(): boolean;
    readonly isNotSpatiallyLocated: boolean;
    readonly isPlanProjection: boolean;
    get isSpatiallyLocated(): boolean;
    // @internal (undocumented)
    toJSON(): GeometricModel3dProps;
}

// @public
export abstract class GeometricModelState extends ModelState implements GeometricModelProps {
    constructor(props: GeometricModelProps, iModel: IModelConnection, state?: GeometricModelState);
    // @internal (undocumented)
    get asGeometricModel(): GeometricModelState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    createTileTreeReference(view: ViewState): TileTreeReference;
    // @internal (undocumented)
    geometryGuid?: string;
    get is2d(): boolean;
    abstract get is3d(): boolean;
    // @internal (undocumented)
    get isGeometricModel(): boolean;
    queryModelRange(): Promise<Range3d>;
    // @internal (undocumented)
    get treeModelId(): Id64String;
}

// @beta
export interface GeometryTileTreeReference extends TileTreeReference {
    collectTileGeometry: (collector: TileGeometryCollector) => void;
}

// @internal
export class GeoServices {
    constructor(iModel: IModelConnection);
    // (undocumented)
    getConverter(datumOrGCRS?: string | GeographicCRSProps): GeoConverter | undefined;
}

// @public
export function getCenteredViewRect(viewRect: ViewRect, aspectRatio?: number): ViewRect;

// @internal (undocumented)
export function getCesiumAccessTokenAndEndpointUrl(assetId?: number, requestKey?: string): Promise<{
    token?: string;
    url?: string;
}>;

// @public
export function getCesiumAssetUrl(osmAssetId: number, requestKey: string): string;

// @internal (undocumented)
export function getCesiumOSMBuildingsUrl(): string | undefined;

// @internal (undocumented)
export function getCesiumTerrainProvider(opts: TerrainMeshProviderOptions): Promise<TerrainMeshProvider | undefined>;

// @public
export function getCompressedJpegFromCanvas(canvas: HTMLCanvasElement, maxBytes?: number, minCompressionQuality?: number): string | undefined;

// @internal (undocumented)
export function getFrustumPlaneIntersectionDepthRange(frustum: Frustum, plane: Plane3dByOriginAndUnitNormal): Range1d;

// @internal
export function getGcsConverterAvailable(iModel: IModelConnection): Promise<boolean>;

// @public
export function getImageSourceFormatForMimeType(mimeType: string): ImageSourceFormat | undefined;

// @public
export function getImageSourceMimeType(format: ImageSourceFormat): string;

// @public
export interface GetPixelDataWorldPointArgs {
    out?: Point3d;
    pixels: Pixel.Buffer;
    preserveModelDisplayTransforms?: boolean;
    x: number;
    y: number;
}

// @public
export function getQuantityTypeKey(type: QuantityTypeArg): QuantityTypeKey;

// @public
export interface GlobalAlignmentOptions {
    target: Point3d;
    transition?: boolean;
}

// @public
export interface GlobalLocation {
    // (undocumented)
    area?: GlobalLocationArea;
    // (undocumented)
    center: Cartographic;
}

// @public
export interface GlobalLocationArea {
    // (undocumented)
    northeast: Cartographic;
    // (undocumented)
    southwest: Cartographic;
}

// @public
export class GlobeAnimator implements Animator {
    protected constructor(viewport: ScreenViewport, destination: GlobalLocation, afterLanding: Frustum, afterFocus: number);
    // (undocumented)
    protected _afterFocusDistance: number;
    // (undocumented)
    protected _afterLanding: Frustum;
    // @internal (undocumented)
    animate(): boolean;
    // (undocumented)
    protected _columbusLine: Point3d[];
    static create(viewport: ScreenViewport, destination: GlobalLocation): Promise<GlobeAnimator | undefined>;
    // (undocumented)
    protected _ellipsoidArc?: Arc3d;
    // (undocumented)
    protected _endHeight?: number;
    // (undocumented)
    protected _endLocation: GlobalLocation;
    // (undocumented)
    protected readonly _fixLandingFraction: number;
    // (undocumented)
    protected _fixLandingInterpolator?: SmoothTransformBetweenFrusta;
    // (undocumented)
    protected _fixTakeoffFraction?: number;
    // (undocumented)
    protected _fixTakeoffInterpolator?: SmoothTransformBetweenFrusta;
    // (undocumented)
    protected _flightLength: number;
    // (undocumented)
    protected _flightTweens: Tweens;
    // @internal (undocumented)
    interrupt(): void;
    // (undocumented)
    protected _midHeight?: number;
    protected _moveFixToFraction(fract: number, interpolator: SmoothTransformBetweenFrusta): boolean;
    // (undocumented)
    protected _moveFlightToFraction(fraction: number): boolean;
    // (undocumented)
    protected readonly _scratchFrustum: Frustum;
    // (undocumented)
    protected _startCartographic?: Cartographic;
    // (undocumented)
    protected _startHeight?: number;
    // (undocumented)
    protected _viewport: ScreenViewport;
}

// @internal
export interface Gltf extends GltfProperty {
    // (undocumented)
    accessors?: GltfDictionary<GltfAccessor>;
    animations?: GltfDictionary<any>;
    asset?: GltfAsset;
    // (undocumented)
    buffers?: GltfDictionary<GltfBuffer>;
    // (undocumented)
    bufferViews?: GltfDictionary<GltfBufferViewProps>;
    cameras?: GltfDictionary<any>;
    // (undocumented)
    extensions?: GltfExtensions & {
        CESIUM_RTC?: {
            center?: number[];
        };
        KHR_techniques_webgl?: {
            techniques?: Array<{
                uniforms?: {
                    [key: string]: {
                        type: GltfDataType;
                        value?: any;
                    } | undefined;
                };
            }>;
        };
    };
    extensionsRequired?: string[];
    extensionsUsed?: string[];
    // (undocumented)
    images?: GltfDictionary<GltfImage>;
    // (undocumented)
    materials?: GltfDictionary<GltfMaterial>;
    // (undocumented)
    meshes?: GltfDictionary<GltfMesh>;
    // (undocumented)
    nodes?: GltfDictionary<GltfNode>;
    // (undocumented)
    samplers?: GltfDictionary<GltfSampler>;
    scene?: GltfId;
    // (undocumented)
    scenes?: GltfDictionary<GltfScene>;
    skins?: GltfDictionary<any>;
    techniques?: GltfDictionary<GltfTechnique>;
    // (undocumented)
    textures?: GltfDictionary<GltfTexture>;
}

// @internal
export type Gltf1Id = string;

// @internal
export type Gltf2Id = number;

// @internal
export class GltfBufferData {
    constructor(buffer: GltfDataBuffer, count: number);
    // (undocumented)
    readonly buffer: GltfDataBuffer;
    // (undocumented)
    readonly count: number;
    static create(bytes: Uint8Array, actualType: GltfDataType, expectedType: GltfDataType, count: number): GltfBufferData | undefined;
}

// @internal (undocumented)
export type GltfDataBuffer = Uint8Array | Uint16Array | Uint32Array | Float32Array;

// @internal
export enum GltfDataType {
    // (undocumented)
    Float = 5126,
    // (undocumented)
    FloatMat3 = 35675,
    // (undocumented)
    FloatMat4 = 35676,
    // (undocumented)
    FloatVec2 = 35664,
    // (undocumented)
    FloatVec3 = 35665,
    // (undocumented)
    FloatVec4 = 35666,
    // (undocumented)
    IntVec2 = 35667,
    // (undocumented)
    IntVec3 = 35668,
    // (undocumented)
    Rgb = 6407,
    // (undocumented)
    Rgba = 6408,
    // (undocumented)
    Sampler2d = 35678,
    // (undocumented)
    SignedByte = 5120,
    // (undocumented)
    SignedShort = 5122,
    // (undocumented)
    UInt32 = 5125,
    // (undocumented)
    UnsignedByte = 5121,
    // (undocumented)
    UnsignedShort = 5123
}

// @internal
export class GltfGraphicsReader extends GltfReader {
    constructor(props: GltfReaderProps, args: ReadGltfGraphicsArgs);
    // (undocumented)
    readonly binaryData?: Uint8Array;
    // (undocumented)
    get nodes(): GltfDictionary<GltfNode>;
    // (undocumented)
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    get sceneNodes(): GltfId[];
    // (undocumented)
    get scenes(): GltfDictionary<GltfScene>;
    // (undocumented)
    get textures(): GltfDictionary<GltfTexture>;
}

// @internal
export class GltfHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly binaryPosition: number;
    // (undocumented)
    readonly gltfLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly scenePosition: number;
    // (undocumented)
    readonly sceneStrLength: number;
}

// @internal
export type GltfId = Gltf1Id | Gltf2Id;

// @internal
export class GltfMeshData {
    constructor(props: Mesh);
    // (undocumented)
    indices?: Uint8Array | Uint16Array | Uint32Array;
    // (undocumented)
    normals?: Uint16Array;
    // (undocumented)
    pointQParams?: QParams3d;
    // (undocumented)
    pointRange?: Range3d;
    // (undocumented)
    points?: Uint16Array;
    // (undocumented)
    primitive: Mesh;
    // (undocumented)
    uvQParams?: QParams2d;
    // (undocumented)
    uvRange?: Range2d;
    // (undocumented)
    uvs?: Uint16Array;
}

// @internal
export type GltfNode = Gltf1Node | Gltf2Node;

// @internal
export abstract class GltfReader {
    protected constructor(args: GltfReaderArgs);
    // (undocumented)
    protected get _accessors(): GltfDictionary<GltfAccessor>;
    // (undocumented)
    protected readonly _baseUrl?: string;
    // (undocumented)
    protected get _buffers(): GltfDictionary<GltfBuffer & {
        resolvedBuffer?: Uint8Array;
    }>;
    // (undocumented)
    protected get _bufferViews(): GltfDictionary<GltfBufferViewProps>;
    // (undocumented)
    protected _computedContentRange?: ElementAlignedBox3d;
    // (undocumented)
    protected createDisplayParams(material: GltfMaterial, hasBakedLighting: boolean): DisplayParams | undefined;
    // (undocumented)
    protected readonly _deduplicateVertices: boolean;
    defaultWrapMode: GltfWrapMode;
    // (undocumented)
    protected findTextureMapping(id: string | undefined, isTransparent: boolean, normalMapId: string | undefined): TextureMapping | undefined;
    // (undocumented)
    getBufferView(json: {
        [k: string]: any;
    }, accessorName: string): GltfBufferView | undefined;
    getTextureType(sampler?: GltfSampler): RenderTexture.Type;
    // (undocumented)
    protected readonly _glTF: Gltf;
    // (undocumented)
    protected get _images(): GltfDictionary<GltfImage & {
        resolvedImage?: TextureImageSource;
    }>;
    // (undocumented)
    protected readonly _iModel: IModelConnection;
    // (undocumented)
    protected readonly _is3d: boolean;
    // (undocumented)
    protected get _isCanceled(): boolean;
    // (undocumented)
    protected get _isVolumeClassifier(): boolean;
    // (undocumented)
    protected get _materials(): GltfDictionary<GltfMaterial>;
    // (undocumented)
    protected get _meshes(): GltfDictionary<GltfMesh>;
    // (undocumented)
    protected get _nodes(): GltfDictionary<GltfNode>;
    abstract read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readBatchTable(_mesh: Mesh, _json: any): void;
    // (undocumented)
    protected readBufferData(json: {
        [k: string]: any;
    }, accessorName: string, type: GltfDataType): GltfBufferData | undefined;
    // (undocumented)
    readBufferData16(json: {
        [k: string]: any;
    }, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData32(json: {
        [k: string]: any;
    }, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData8(json: {
        [k: string]: any;
    }, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferDataFloat(json: {
        [k: string]: any;
    }, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    protected readFeatureIndices(_json: any): number[] | undefined;
    // (undocumented)
    readGltfAndCreateGeometry(transformToRoot?: Transform, needNormals?: boolean, needParams?: boolean): RealityTileGeometry;
    // (undocumented)
    protected readGltfAndCreateGraphics(isLeaf: boolean, featureTable: FeatureTable | undefined, contentRange: ElementAlignedBox3d | undefined, transformToRoot?: Transform, pseudoRtcBias?: Vector3d, instances?: InstancedGraphicParams): GltfReaderResult;
    // (undocumented)
    protected readIndices(json: {
        [k: string]: any;
    }, accessorName: string): number[] | undefined;
    // (undocumented)
    protected readMeshIndices(mesh: GltfMeshData, json: {
        [k: string]: any;
    }): boolean;
    // (undocumented)
    protected readMeshPrimitive(primitive: GltfMeshPrimitive, featureTable?: FeatureTable, pseudoRtcBias?: Vector3d): GltfMeshData | undefined;
    // (undocumented)
    protected readNormals(mesh: GltfMeshData, json: {
        [k: string]: any;
    }, accessorName: string): boolean;
    // (undocumented)
    protected readPolylines(polylines: MeshPolylineList, json: {
        [k: string]: any;
    }, accessorName: string, disjoint: boolean): boolean;
    // (undocumented)
    protected resolveResources(): Promise<void>;
    // (undocumented)
    protected readonly _returnToCenter?: Point3d;
    // (undocumented)
    protected get _samplers(): GltfDictionary<GltfSampler>;
    // (undocumented)
    protected readonly _sceneNodes: GltfId[];
    // (undocumented)
    protected readonly _system: RenderSystem;
    // (undocumented)
    protected get _textures(): GltfDictionary<GltfTexture>;
    traverseNodes(nodeIds: Iterable<GltfId>): Iterable<GltfNode>;
    traverseScene(): Iterable<GltfNode>;
    // (undocumented)
    protected readonly _type: BatchType;
    // (undocumented)
    protected readonly _version: number;
    // (undocumented)
    protected readonly _vertexTableRequired: boolean;
    // (undocumented)
    protected readonly _yAxisUp: boolean;
}

// @internal
export interface GltfReaderArgs {
    deduplicateVertices?: boolean;
    iModel: IModelConnection;
    is2d?: boolean;
    props: GltfReaderProps;
    shouldAbort?: ShouldAbortReadGltf;
    system?: RenderSystem;
    type?: BatchType;
    vertexTableRequired?: boolean;
}

// @internal
export class GltfReaderProps {
    // (undocumented)
    readonly baseUrl?: string;
    // (undocumented)
    readonly binaryData?: Uint8Array;
    static create(source: Uint8Array | Gltf, yAxisUp?: boolean, baseUrl?: string): GltfReaderProps | undefined;
    // (undocumented)
    readonly glTF: Gltf;
    // (undocumented)
    readonly version: number;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal
export interface GltfReaderResult extends TileContent {
    // (undocumented)
    readStatus: TileReadStatus;
}

// @internal
export interface GltfSampler extends GltfChildOfRootProperty {
    magFilter?: GltfMagFilter;
    minFilter?: GltfMinFilter;
    wrapS?: GltfWrapMode;
    wrapT?: GltfWrapMode;
}

// @internal
export enum GltfWrapMode {
    // (undocumented)
    ClampToEdge = 33071,
    // (undocumented)
    MirroredRepeat = 33648,
    // (undocumented)
    Repeat = 10497
}

// @internal (undocumented)
export interface GLTimerResult {
    children?: GLTimerResult[];
    label: string;
    nanoseconds: number;
}

// @internal (undocumented)
export type GLTimerResultCallback = (result: GLTimerResult) => void;

// @public
export type GpuMemoryLimit = "none" | "default" | "aggressive" | "relaxed" | number;

// @public
export interface GpuMemoryLimits {
    mobile?: GpuMemoryLimit;
    nonMobile?: GpuMemoryLimit;
}

// @public
export class GraphicalEditingScope extends BriefcaseNotificationHandler implements EditingScopeNotifications {
    // (undocumented)
    get briefcaseChannelName(): IpcAppChannel;
    // @internal
    static enter(imodel: BriefcaseConnection): Promise<GraphicalEditingScope>;
    exit(): Promise<void>;
    getGeometryChanges(): Iterable<ModelGeometryChanges>;
    getGeometryChangesForModel(modelId: Id64String): Iterable<ElementGeometryChange> | undefined;
    readonly iModel: BriefcaseConnection;
    // @internal (undocumented)
    get isDisposed(): boolean;
    // @internal (undocumented)
    notifyGeometryChanged(props: ModelGeometryChangesProps[]): void;
    static readonly onEnter: BeEvent<(scope: GraphicalEditingScope) => void>;
    readonly onExited: BeEvent<(scope: GraphicalEditingScope) => void>;
    readonly onExiting: BeEvent<(scope: GraphicalEditingScope) => void>;
    readonly onGeometryChanges: BeEvent<(changes: Iterable<ModelGeometryChanges>, scope: GraphicalEditingScope) => void>;
}

// @public
export interface GraphicArc {
    // (undocumented)
    arc: Arc3d;
    // (undocumented)
    filled?: boolean;
    // (undocumented)
    isEllipse?: boolean;
    // (undocumented)
    type: "arc";
}

// @public
export interface GraphicArc2d {
    // (undocumented)
    arc: Arc3d;
    // (undocumented)
    filled?: boolean;
    // (undocumented)
    isEllipse?: boolean;
    // (undocumented)
    type: "arc2d";
    // (undocumented)
    zDepth: number;
}

// @public
export class GraphicBranch implements IDisposable {
    constructor(ownsEntries?: boolean);
    add(graphic: RenderGraphic): void;
    // @internal
    animationId?: string;
    // @internal
    animationNodeId?: AnimationNodeId | number;
    clear(): void;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    dispose(): void;
    readonly entries: RenderGraphic[];
    getViewFlags(flags: ViewFlags): ViewFlags;
    get isEmpty(): boolean;
    readonly ownsEntries: boolean;
    // @beta
    realityModelDisplaySettings?: RealityModelDisplaySettings;
    // @internal (undocumented)
    realityModelRange?: Range3d;
    setViewFlagOverrides(ovr: ViewFlagOverrides): void;
    setViewFlags(flags: ViewFlags): void;
    symbologyOverrides?: FeatureSymbology.Overrides;
    viewFlagOverrides: ViewFlagOverrides;
}

// @internal
export interface GraphicBranchFrustum {
    // (undocumented)
    is3d: boolean;
    // (undocumented)
    scale: {
        x: number;
        y: number;
    };
}

// @public
export interface GraphicBranchOptions {
    appearanceProvider?: FeatureAppearanceProvider;
    // @internal (undocumented)
    classifierOrDrape?: RenderPlanarClassifier | RenderTextureDrape;
    clipVolume?: RenderClipVolume;
    // @internal (undocumented)
    frustum?: GraphicBranchFrustum;
    hline?: HiddenLine.Settings;
    iModel?: IModelConnection;
    // @internal
    secondaryClassifiers?: Map<number, RenderPlanarClassifier>;
}

// @public
export abstract class GraphicBuilder {
    // @internal
    protected constructor(options: ViewportGraphicBuilderOptions | CustomGraphicBuilderOptions);
    activateFeature(feature: Feature): void;
    protected _activateFeature(_feature: Feature): void;
    abstract activateGraphicParams(graphicParams: GraphicParams): void;
    activatePickableId(id: Id64String): void;
    abstract addArc(arc: Arc3d, isEllipse: boolean, filled: boolean): void;
    abstract addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void;
    addCurvePrimitive(curve: AnyCurvePrimitive): void;
    addFrustum(frustum: Frustum): void;
    abstract addLineString(points: Point3d[]): void;
    abstract addLineString2d(points: Point2d[], zDepth: number): void;
    abstract addLoop(loop: Loop): void;
    abstract addPath(path: Path): void;
    abstract addPointString(points: Point3d[]): void;
    abstract addPointString2d(points: Point2d[], zDepth: number): void;
    abstract addPolyface(meshData: Polyface, filled: boolean): void;
    addPrimitive(primitive: GraphicPrimitive): void;
    addRangeBox(range: Range3d): void;
    addRangeBoxFromCorners(p: Point3d[]): void;
    abstract addShape(points: Point3d[]): void;
    abstract addShape2d(points: Point2d[], zDepth: number): void;
    abstract addSolidPrimitive(solidPrimitive: SolidPrimitive): void;
    // @alpha (undocumented)
    readonly analysisStyle?: AnalysisStyle;
    // (undocumented)
    protected readonly _computeChordTolerance: (args: ComputeChordToleranceArgs) => number;
    abstract finish(): RenderGraphic;
    readonly iModel?: IModelConnection;
    get isOverlay(): boolean;
    get isSceneGraphic(): boolean;
    get isViewBackground(): boolean;
    get isViewCoordinates(): boolean;
    get isWorldCoordinates(): boolean;
    // (undocumented)
    protected readonly _options: CustomGraphicBuilderOptions | ViewportGraphicBuilderOptions;
    readonly pickable?: Readonly<PickableGraphicOptions>;
    // @deprecated
    get pickId(): Id64String | undefined;
    readonly placement: Transform;
    readonly preserveOrder: boolean;
    setBlankingFill(fillColor: ColorDef): void;
    setSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): void;
    readonly type: GraphicType;
    readonly wantEdges: boolean;
    readonly wantNormals: boolean;
}

// @public
export interface GraphicBuilderOptions {
    generateEdges?: boolean;
    pickable?: PickableGraphicOptions;
    placement?: Transform;
    preserveOrder?: boolean;
    type: GraphicType;
    viewIndependentOrigin?: Point3d;
    wantNormals?: boolean;
}

// @public
export interface GraphicLineString {
    // (undocumented)
    points: Point3d[];
    // (undocumented)
    type: "linestring";
}

// @public
export interface GraphicLineString2d extends GraphicPrimitive2d {
    // (undocumented)
    points: Point2d[];
    // (undocumented)
    type: "linestring2d";
}

// @public
export type GraphicList = RenderGraphic[];

// @public
export interface GraphicLoop {
    // (undocumented)
    loop: Loop;
    // (undocumented)
    type: "loop";
}

// @public
export interface GraphicPath {
    // (undocumented)
    path: Path;
    // (undocumented)
    type: "path";
}

// @public
export interface GraphicPointString {
    // (undocumented)
    points: Point3d[];
    // (undocumented)
    type: "pointstring";
}

// @public
export interface GraphicPointString2d extends GraphicPrimitive2d {
    // (undocumented)
    points: Point2d[];
    // (undocumented)
    type: "pointstring2d";
}

// @public
export interface GraphicPolyface {
    // (undocumented)
    filled?: boolean;
    // (undocumented)
    polyface: Polyface;
    // (undocumented)
    type: "polyface";
}

// @public
export type GraphicPrimitive = GraphicLineString | GraphicLineString2d | GraphicPointString | GraphicPointString2d | GraphicShape | GraphicShape2d | GraphicArc | GraphicArc2d | GraphicPath | GraphicLoop | GraphicPolyface | GraphicSolidPrimitive;

// @public
export interface GraphicPrimitive2d {
    zDepth: number;
}

// @internal (undocumented)
export interface GraphicsCollector {
    // (undocumented)
    addGraphic(graphic: RenderGraphic): void;
}

// @internal (undocumented)
export class GraphicsCollectorDrawArgs extends TileDrawArgs {
    // (undocumented)
    static create(context: SceneContext, collector: GraphicsCollector, ref: TileTreeReference, planes: FrustumPlanes, worldToViewMap: Map4d): TileDrawArgs | undefined;
    // (undocumented)
    drawGraphics(): void;
    // (undocumented)
    drawGraphicsWithType(_graphicType: TileGraphicType, graphics: GraphicBranch): void;
    // (undocumented)
    get frustumPlanes(): FrustumPlanes;
    // (undocumented)
    get worldToViewMap(): Map4d;
}

// @public
export interface GraphicShape {
    // (undocumented)
    points: Point3d[];
    // (undocumented)
    type: "shape";
}

// @public
export interface GraphicShape2d extends GraphicPrimitive2d {
    // (undocumented)
    points: Point2d[];
    // (undocumented)
    type: "shape2d";
}

// @public
export interface GraphicSolidPrimitive {
    // (undocumented)
    solidPrimitive: SolidPrimitive;
    // (undocumented)
    type: "solidPrimitive";
}

// @public
export enum GraphicType {
    Scene = 1,
    ViewBackground = 0,
    ViewOverlay = 4,
    WorldDecoration = 2,
    WorldOverlay = 3
}

// @internal (undocumented)
export interface GroundPlaneDecorations {
    // (undocumented)
    readonly aboveParams: GraphicParams;
    // (undocumented)
    readonly belowParams: GraphicParams;
}

// @alpha (undocumented)
export interface GroupMark {
    // (undocumented)
    source: ModifyElementSource;
    // (undocumented)
    start: number;
}

// @internal (undocumented)
export interface Hilites {
    // (undocumented)
    readonly elements: Id64.Uint32Set;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    // (undocumented)
    readonly modelSubCategoryMode: ModelSubCategoryHiliteMode;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
}

// @public
export class HiliteSet {
    // @internal
    constructor(iModel: IModelConnection, syncWithSelectionSet?: boolean);
    clear(): void;
    get elements(): Id64.Uint32Set;
    // (undocumented)
    iModel: IModelConnection;
    get isEmpty(): boolean;
    readonly models: Id64.Uint32Set;
    get modelSubCategoryMode(): ModelSubCategoryHiliteMode;
    set modelSubCategoryMode(mode: ModelSubCategoryHiliteMode);
    readonly onModelSubCategoryModeChanged: BeEvent<(newMode: ModelSubCategoryHiliteMode) => void>;
    setHilite(arg: Id64Arg, onOff: boolean): void;
    readonly subcategories: Id64.Uint32Set;
    get wantSyncWithSelectionSet(): boolean;
    set wantSyncWithSelectionSet(want: boolean);
}

// @public
export class HitDetail {
    constructor(testPoint: Point3d, viewport: ScreenViewport, hitSource: HitSource, hitPoint: Point3d, sourceId: string, priority: HitPriority, distXY: number, distFraction: number, subCategoryId?: string | undefined, geometryClass?: GeometryClass | undefined, modelId?: string | undefined, iModel?: IModelConnection, tileId?: string, isClassifier?: boolean);
    clone(): HitDetail;
    // (undocumented)
    readonly distFraction: number;
    // (undocumented)
    readonly distXY: number;
    draw(_context: DecorateContext): void;
    // (undocumented)
    readonly geometryClass?: GeometryClass | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    getToolTip(): Promise<HTMLElement | string>;
    // (undocumented)
    readonly hitPoint: Point3d;
    // (undocumented)
    readonly hitSource: HitSource;
    get iModel(): IModelConnection;
    // @alpha (undocumented)
    readonly isClassifier: boolean;
    get isElementHit(): boolean;
    get isExternalIModelHit(): boolean;
    // (undocumented)
    get isMapHit(): boolean;
    // (undocumented)
    get isModelHit(): boolean;
    isSameHit(otherHit?: HitDetail): boolean;
    // (undocumented)
    readonly modelId?: string | undefined;
    // (undocumented)
    readonly priority: HitPriority;
    // (undocumented)
    readonly sourceId: string;
    // (undocumented)
    readonly subCategoryId?: string | undefined;
    // (undocumented)
    readonly testPoint: Point3d;
    // @internal
    readonly tileId?: string;
    // (undocumented)
    readonly viewport: ScreenViewport;
}

// @public (undocumented)
export enum HitDetailType {
    // (undocumented)
    Hit = 1,
    // (undocumented)
    Intersection = 3,
    // (undocumented)
    Snap = 2
}

// @public
export enum HitGeomType {
    // (undocumented)
    Arc = 4,
    // (undocumented)
    Curve = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Point = 1,
    // (undocumented)
    Segment = 2,
    // (undocumented)
    Surface = 5
}

// @public
export class HitList<T extends HitDetail> {
    addHit(newHit: T): number;
    compare(hit1: HitDetail | undefined, hit2: HitDetail | undefined): -1 | 1 | 0;
    // (undocumented)
    currHit: number;
    // (undocumented)
    dropNulls(): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    getCurrentHit(): T | undefined;
    getHit(hitNum: number): T | undefined;
    // (undocumented)
    getNextHit(): T | undefined;
    // (undocumented)
    hits: T[];
    insertHit(i: number, hit: T): void;
    // (undocumented)
    get length(): number;
    removeCurrentHit(): void;
    removeHit(hitNum: number): void;
    removeHitsFrom(sourceId: string): boolean;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    setCurrentHit(hit: T): void;
    setHit(i: number, p: T | undefined): void;
}

// @public (undocumented)
export interface HitListHolder {
    // (undocumented)
    setHitList(list: HitList<HitDetail> | undefined): void;
}

// @public
export enum HitParentGeomType {
    // (undocumented)
    Mesh = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sheet = 2,
    // (undocumented)
    Solid = 3,
    // (undocumented)
    Text = 5,
    // (undocumented)
    Wire = 1
}

// @public (undocumented)
export enum HitPriority {
    // (undocumented)
    NonPlanarEdge = 2,
    // (undocumented)
    NonPlanarSurface = 5,
    // (undocumented)
    PlanarEdge = 1,
    // (undocumented)
    PlanarSurface = 4,
    // (undocumented)
    SilhouetteEdge = 3,
    // (undocumented)
    Unknown = 6,
    // (undocumented)
    WireEdge = 0
}

// @public
export enum HitSource {
    // (undocumented)
    AccuSnap = 3,
    // (undocumented)
    Application = 6,
    // (undocumented)
    DataPoint = 5,
    // (undocumented)
    EditAction = 7,
    // (undocumented)
    EditActionSS = 8,
    // (undocumented)
    FromUser = 1,
    // (undocumented)
    MotionLocate = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    TentativeSnap = 4
}

// @internal
export class I3dmReader extends GltfReader {
    // (undocumented)
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, isCanceled?: ShouldAbortReadGltf, idMap?: BatchedTileIdMap, deduplicateVertices?: boolean): I3dmReader | undefined;
    // (undocumented)
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readFeatures(_features: Mesh.Features, _json: any): boolean;
}

// @public
export class IconSprites {
    static emptyAll(): void;
    static getSpriteFromUrl(spriteUrl: string): Sprite;
}

// @public
export class IdleTool extends InteractiveTool {
    // (undocumented)
    exitTool(): Promise<void>;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    onMiddleButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(ev: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @public
export function imageBitmapFromImageSource(source: ImageSource): Promise<ImageBitmap>;

// @public
export function imageBufferToBase64EncodedPng(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageBufferToCanvas(buffer: ImageBuffer, preserveAlpha?: boolean): HTMLCanvasElement | undefined;

// @public
export function imageBufferToPngDataUrl(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageElementFromImageSource(source: ImageSource): Promise<HTMLImageElement>;

// @public
export function imageElementFromUrl(url: string, skipCrossOriginCheck?: boolean): Promise<HTMLImageElement>;

// @beta
export class ImageryMapLayerFormat extends MapLayerFormat {
    // @internal (undocumented)
    static createMapLayerTree(layerSettings: ImageMapLayerSettings, layerIndex: number, iModel: IModelConnection): MapLayerTileTreeReference | undefined;
}

// @internal
export class ImageryMapLayerTreeReference extends MapLayerTileTreeReference {
    constructor(layerSettings: MapLayerSettings, layerIndex: number, iModel: IModelConnection);
    // (undocumented)
    get castsShadows(): boolean;
    // (undocumented)
    get imageryProvider(): MapLayerImageryProvider | undefined;
    // (undocumented)
    resetTreeOwner(): void;
    get treeOwner(): TileTreeOwner;
}

// @internal (undocumented)
export class ImageryMapTile extends RealityTile {
    constructor(params: TileParams, imageryTree: ImageryMapTileTree, quadId: QuadId, rectangle: MapCartoRectangle);
    // (undocumented)
    protected _collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    disposeContents(): void;
    // (undocumented)
    freeMemory(): void;
    // (undocumented)
    imageryTree: ImageryMapTileTree;
    // (undocumented)
    get isDisplayable(): boolean;
    // (undocumented)
    get isOutOfLodRange(): boolean;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, _reject: (error: Error) => void): void;
    // (undocumented)
    markMapTileUsage(): void;
    // (undocumented)
    quadId: QuadId;
    // (undocumented)
    rectangle: MapCartoRectangle;
    // (undocumented)
    releaseMapTileUsage(): void;
    // (undocumented)
    selectCartoDrapeTiles(drapeTiles: ImageryMapTile[], rectangleToDrape: MapCartoRectangle, drapePixelSize: number, args: TileDrawArgs): TileTreeLoadStatus;
    // (undocumented)
    setContent(content: ImageryTileContent): void;
    // (undocumented)
    setLeaf(): void;
    // (undocumented)
    get texture(): RenderTexture | undefined;
    // (undocumented)
    get tilingScheme(): MapTilingScheme;
}

// @internal (undocumented)
export class ImageryMapTileTree extends RealityTileTree {
    constructor(params: RealityTileTreeParams, _imageryLoader: ImageryTileLoader);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement, vp: ScreenViewport): void;
    // (undocumented)
    cartoRectangleFromQuadId(quadId: QuadId): MapCartoRectangle;
    // (undocumented)
    draw(_args: TileDrawArgs): void;
    // (undocumented)
    getTileRectangle(quadId: QuadId): MapCartoRectangle;
    // (undocumented)
    get imageryLoader(): ImageryTileLoader;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    selectCartoDrapeTiles(drapeTiles: ImageryMapTile[], tileToDrape: MapTile, args: TileDrawArgs): TileTreeLoadStatus;
    // (undocumented)
    protected _selectTiles(_args: TileDrawArgs): Tile[];
    // (undocumented)
    get tilingScheme(): MapTilingScheme;
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
}

// @internal (undocumented)
export interface ImageryTileContent extends TileContent {
    // (undocumented)
    imageryTexture?: RenderTexture;
}

// @internal
export class ImageryTileTreeState {
    constructor();
    clone(): ImageryTileTreeState;
    getScaleRangeVisibility(): MapTileTreeScaleRangeVisibility;
    reset(): void;
    setScaleRangeVisibility(visible: boolean): void;
}

// @internal
export interface Imdl {
    // (undocumented)
    animationNodes?: ImdlAnimationNodes;
    // (undocumented)
    bufferViews: ImdlDictionary<ImdlBufferView>;
    // (undocumented)
    materials?: ImdlDictionary<ImdlDisplayParams>;
    // (undocumented)
    meshes: ImdlDictionary<ImdlMesh>;
    // (undocumented)
    namedTextures?: ImdlDictionary<ImdlNamedTexture>;
    nodes: ImdlDictionary<string>;
    // (undocumented)
    patternSymbols?: ImdlDictionary<ImdlAreaPatternSymbol>;
    // (undocumented)
    renderMaterials?: ImdlDictionary<ImdlRenderMaterial>;
    rtcCenter?: number[];
    scene: string;
    scenes: ImdlDictionary<ImdlScene>;
}

// @internal
export class ImdlReader {
    // (undocumented)
    protected colorDefFromMaterialJson(json: ImdlColorDef | undefined): ColorDef | undefined;
    static create(args: ImdlReaderCreateArgs): ImdlReader | undefined;
    // (undocumented)
    protected createDisplayParams(json: ImdlDisplayParams): DisplayParams | undefined;
    // (undocumented)
    protected materialFromJson(key: string): RenderMaterial | undefined;
    read(): Promise<ImdlReaderResult>;
    // (undocumented)
    protected readFeatureTable(startPos: number): PackedFeatureTable | undefined;
}

// @internal
export interface ImdlReaderCreateArgs {
    // (undocumented)
    containsTransformNodes?: boolean;
    // (undocumented)
    iModel: IModelConnection;
    // (undocumented)
    is3d: boolean;
    // (undocumented)
    isCanceled?: ShouldAbortImdlReader;
    // (undocumented)
    loadEdges?: boolean;
    // (undocumented)
    modelId: Id64String;
    // (undocumented)
    options?: BatchOptions | false;
    // (undocumented)
    sizeMultiplier?: number;
    // (undocumented)
    stream: ByteStream;
    // (undocumented)
    system: RenderSystem;
    timeline?: RenderSchedule.ModelTimeline;
    // (undocumented)
    type?: BatchType;
}

// @internal (undocumented)
export interface ImdlReaderResult extends IModelTileContent {
    // (undocumented)
    readStatus: TileReadStatus;
}

// @public
export class IModelApp {
    protected constructor();
    // @internal
    static get accuDraw(): AccuDraw;
    static get accuSnap(): AccuSnap;
    // @beta
    static get animationInterval(): BeDuration | undefined;
    static set animationInterval(interval: BeDuration | undefined);
    static get applicationId(): string;
    // @beta
    static applicationLogoCard?: () => HTMLTableRowElement;
    static get applicationVersion(): string;
    static authorizationClient?: AuthorizationClient;
    // @internal (undocumented)
    static createRenderSys(opts?: RenderSystem.Options): RenderSystem;
    // @alpha (undocumented)
    static readonly extensionAdmin: ExtensionAdmin;
    // @alpha
    static formatElementToolTip(msg: string[]): HTMLElement;
    static getAccessToken(): Promise<AccessToken>;
    // @internal (undocumented)
    static get hasRenderSystem(): boolean;
    // @internal
    static get hubAccess(): FrontendHubAccess | undefined;
    // @internal (undocumented)
    static get initialized(): boolean;
    static get localization(): Localization;
    // (undocumented)
    static get locateManager(): ElementLocateManager;
    // @internal (undocumented)
    static lookupEntityClass(classFullName: string): typeof EntityState | undefined;
    // @internal
    static makeHTMLElement<K extends keyof HTMLElementTagNameMap>(type: K, opt?: {
        parent?: HTMLElement;
        className?: string;
        id?: string;
        innerHTML?: string;
        innerText?: string;
    }): HTMLElementTagNameMap[K];
    // @internal
    static makeIModelJsLogoCard(): HTMLTableRowElement;
    // @beta
    static makeLogoCard(opts: {
        heading: string | HTMLElement;
        iconSrc?: string | HTMLImageElement;
        iconWidth?: number;
        notice?: string | HTMLElement;
    }): HTMLTableRowElement;
    // @internal
    static makeModalDiv(options: ModalOptions): ModalReturn;
    // @internal
    static get mapLayerFormatRegistry(): MapLayerFormatRegistry;
    static get notifications(): NotificationManager;
    // @internal
    static readonly onAfterStartup: BeEvent<() => void>;
    static readonly onBeforeShutdown: BeEvent<() => void>;
    // @beta
    static get publicPath(): string;
    static get quantityFormatter(): QuantityFormatter;
    static queryRenderCompatibility(): WebGLRenderCompatibilityInfo;
    // @beta
    static get realityDataAccess(): RealityDataAccess | undefined;
    // @alpha
    static get realityDataSourceProviders(): RealityDataSourceProviderRegistry;
    // @internal
    static registerEntityState(classFullName: string, classType: typeof EntityState): void;
    // @internal
    static registerModuleEntities(moduleObj: any): void;
    static get renderSystem(): RenderSystem;
    // @internal (undocumented)
    static requestNextAnimation(): void;
    static get securityOptions(): FrontendSecurityOptions;
    static sessionId: GuidString;
    static shutdown(): Promise<void>;
    // @internal (undocumented)
    static startEventLoop(): void;
    static startup(opts?: IModelAppOptions): Promise<void>;
    // @internal
    static stopEventLoop(): void;
    // @internal
    static readonly telemetry: TelemetryManager;
    // @internal (undocumented)
    static get tentativePoint(): TentativePoint;
    // @beta
    static get terrainProviderRegistry(): TerrainProviderRegistry;
    static get tileAdmin(): TileAdmin;
    static get toolAdmin(): ToolAdmin;
    static readonly tools: ToolRegistry;
    // @beta
    static translateStatus(status: number): string;
    static get uiAdmin(): UiAdmin;
    // @beta
    static get userPreferences(): UserPreferencesAccess | undefined;
    static get viewManager(): ViewManager;
}

// @public
export interface IModelAppOptions {
    // @internal
    accuDraw?: AccuDraw;
    accuSnap?: AccuSnap;
    applicationId?: string;
    applicationVersion?: string;
    authorizationClient?: AuthorizationClient;
    hubAccess?: FrontendHubAccess;
    localization?: Localization;
    // @internal (undocumented)
    locateManager?: ElementLocateManager;
    // @beta
    mapLayerOptions?: MapLayerOptions;
    // @internal
    noRender?: boolean;
    notifications?: NotificationManager;
    // @beta
    publicPath?: string;
    // @internal (undocumented)
    quantityFormatter?: QuantityFormatter;
    // @beta (undocumented)
    realityDataAccess?: RealityDataAccess;
    renderSys?: RenderSystem | RenderSystem.Options;
    // (undocumented)
    rpcInterfaces?: RpcInterfaceDefinition[];
    security?: FrontendSecurityOptions;
    // @internal (undocumented)
    sessionId?: GuidString;
    // @internal (undocumented)
    tentativePoint?: TentativePoint;
    tileAdmin?: TileAdmin.Props;
    toolAdmin?: ToolAdmin;
    uiAdmin?: UiAdmin;
    // @beta
    userPreferences?: UserPreferencesAccess;
    viewManager?: ViewManager;
}

// @public
export abstract class IModelConnection extends IModel {
    // @internal
    protected constructor(iModelProps: IModelConnectionProps);
    // @internal
    protected beforeClose(): void;
    cartographicToSpatial(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    cartographicToSpatialFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    readonly categories: IModelConnection.Categories;
    abstract close(): Promise<void>;
    readonly codeSpecs: IModelConnection.CodeSpecs;
    static connectionTimeout: number;
    // @beta
    createQueryReader(ecsql: string, params?: QueryBinder, config?: QueryOptions): ECSqlReader;
    // @internal (undocumented)
    disableGCS(disable: boolean): void;
    readonly displayedExtents: AxisAlignedBox3d;
    readonly elements: IModelConnection.Elements;
    expandDisplayedExtents(range: Range3d): void;
    findClassFor<T extends typeof EntityState>(className: string, defaultClass: T | undefined): Promise<T | undefined>;
    fontMap?: FontMap;
    // @internal
    protected _gcsDisabled: boolean;
    // @beta
    generateElementMeshes(requestProps: ElementMeshRequestProps): Promise<Uint8Array>;
    // @internal
    get geodeticToSeaLevel(): number | undefined;
    // @internal
    readonly geoServices: GeoServices;
    getGeometryContainment(requestProps: GeometryContainmentRequestProps): Promise<GeometryContainmentResponseProps>;
    getGeometrySummary(requestProps: GeometrySummaryRequestProps): Promise<string>;
    // @internal (undocumented)
    getMapEcefToDb(bimElevationBias: number): Transform;
    getMassProperties(requestProps: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    getMassPropertiesPerCandidate(requestProps: MassPropertiesPerCandidateRequestProps): Promise<MassPropertiesPerCandidateResponseProps[]>;
    getToolTipMessage(id: Id64String): Promise<string[]>;
    readonly hilited: HiliteSet;
    get isBlank(): boolean;
    isBlankConnection(): this is BlankConnection;
    get isBriefcase(): boolean;
    isBriefcaseConnection(): this is BriefcaseConnection;
    // @beta
    isCheckpointConnection(): this is CheckpointConnection;
    abstract get isClosed(): boolean;
    get isOpen(): boolean;
    get isReadonly(): boolean;
    get isSnapshot(): boolean;
    isSnapshotConnection(): this is SnapshotConnection;
    loadFontMap(): Promise<FontMap>;
    readonly models: IModelConnection.Models;
    // @internal
    get noGcsDefined(): boolean;
    static readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    // @beta
    readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    // @internal
    readonly onDisplayedExtentsExpansion: BeEvent<() => void>;
    // @internal
    readonly onMapElevationLoaded: BeEvent<(_imodel: IModelConnection) => void>;
    static readonly onOpen: BeEvent<(_imodel: IModelConnection) => void>;
    // @internal
    get projectCenterAltitude(): number | undefined;
    query(ecsql: string, params?: QueryBinder, options?: QueryOptions): AsyncIterableIterator<any>;
    queryEntityIds(params: EntityQueryParams): Promise<Id64Set>;
    queryRowCount(ecsql: string, params?: QueryBinder): Promise<number>;
    // @internal
    querySubCategories(compressedCategoryIds: CompressedId64Set): Promise<SubCategoryResultRow[]>;
    queryTextureData(textureLoadProps: TextureLoadProps): Promise<TextureData | undefined>;
    // @internal
    requestSnap(props: SnapRequestProps): Promise<SnapResponseProps>;
    restartQuery(token: string, ecsql: string, params?: QueryBinder, options?: QueryOptions): AsyncIterableIterator<any>;
    routingContext: IModelRoutingContext;
    readonly selectionSet: SelectionSet;
    spatialToCartographic(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    spatialToCartographicFromGcs(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // @internal
    get subcategories(): SubCategoriesCache;
    readonly tiles: Tiles;
    readonly transientIds: TransientIdSequence;
    readonly views: IModelConnection.Views;
}

// @public (undocumented)
export namespace IModelConnection {
    // (undocumented)
    export namespace Categories {
        export interface CategoryInfo {
            readonly id: Id64String;
            readonly subCategories: Map<Id64String, SubCategoryInfo>;
        }
        export interface SubCategoryInfo {
            readonly appearance: Readonly<SubCategoryAppearance>;
            readonly categoryId: Id64String;
            readonly id: Id64String;
        }
    }
    export class Categories {
        // @internal
        constructor(iModel: IModelConnection);
        // @internal (undocumented)
        readonly cache: SubCategoriesCache;
        getCategoryInfo(categoryIds: Iterable<Id64String>): Promise<Map<Id64String, Categories.CategoryInfo>>;
        getSubCategoryInfo(args: {
            category: Id64String;
            subCategories: Iterable<Id64String>;
        }): Promise<Map<Id64String, Categories.SubCategoryInfo>>;
    }
    export class CodeSpecs {
        // @internal
        constructor(_iModel: IModelConnection);
        getById(codeSpecId: Id64String): Promise<CodeSpec>;
        getByName(name: string): Promise<CodeSpec>;
    }
    export class Elements {
        // @internal
        constructor(_iModel: IModelConnection);
        getPlacements(elementIds: Iterable<Id64String>, options?: Readonly<GetPlacementsOptions>): Promise<Array<Placement & {
            elementId: Id64String;
        }>>;
        getProps(arg: Id64Arg): Promise<ElementProps[]>;
        loadProps(identifier: Id64String | GuidString | CodeProps, options?: ElementLoadOptions): Promise<ElementProps | undefined>;
        queryIds(params: EntityQueryParams): Promise<Id64Set>;
        queryProps(params: EntityQueryParams): Promise<ElementProps[]>;
        get rootSubjectId(): Id64String;
    }
    export interface GetPlacementsOptions {
        type?: "3d" | "2d";
    }
    export class Models implements Iterable<ModelState> {
        [Symbol.iterator](): Iterator<ModelState>;
        // @internal
        constructor(_iModel: IModelConnection);
        filterLoaded(modelIds: Id64Arg): Id64Set | undefined;
        // @internal (undocumented)
        getDictionaryModel(): Promise<Id64String>;
        getLoaded(id: string): ModelState | undefined;
        getProps(modelIds: Id64Arg): Promise<ModelProps[]>;
        load(modelIds: Id64Arg): Promise<void>;
        // @internal (undocumented)
        get loaded(): Map<string, ModelState>;
        query(queryParams: ModelQueryParams): AsyncIterableIterator<ModelProps>;
        queryExtents(modelIds: Id64String | Id64String[]): Promise<ModelExtentsProps[]>;
        queryModelRanges(modelIds: Id64Arg): Promise<Range3dProps[]>;
        queryProps(queryParams: ModelQueryParams): Promise<ModelProps[]>;
        get repositoryModelId(): string;
        // @internal
        unload(modelId: Id64String): void;
        updateLoadedWithModelProps(modelProps: ModelProps[]): Promise<void>;
    }
    export class Views {
        // @internal
        constructor(_iModel: IModelConnection);
        convertViewStatePropsToViewState(viewProps: ViewStateProps): Promise<ViewState>;
        // @deprecated
        getThumbnail(_viewId: Id64String): Promise<ThumbnailProps>;
        getViewList(queryParams: ViewQueryParams): Promise<ViewSpec[]>;
        load(viewDefinitionId: Id64String): Promise<ViewState>;
        queryDefaultViewId(): Promise<Id64String>;
        queryProps(queryParams: ViewQueryParams): Promise<ViewDefinitionProps[]>;
    }
    export interface ViewSpec {
        class: string;
        id: string;
        name: string;
    }
}

// @internal (undocumented)
export class IModelFrameLifecycle {
    // (undocumented)
    static readonly onBeforeRender: BeEvent<(data: FrameBeforeRenderData) => void>;
    // (undocumented)
    static readonly onChangeCameraFrustum: BeEvent<(data: FrameCameraFrustumData) => void>;
    // (undocumented)
    static readonly onChangeCameraView: BeEvent<(data: FrameCameraViewData) => void>;
    // (undocumented)
    static readonly onRenderOpaque: BeEvent<(data: FrameRenderData) => void>;
}

// @public (undocumented)
export interface IModelIdArg {
    // (undocumented)
    accessToken: AccessToken;
    // (undocumented)
    iModelId: GuidString;
}

// @public
export class IModelRoutingContext {
    // (undocumented)
    get active(): boolean;
    // (undocumented)
    static get current(): IModelRoutingContext | undefined;
    // (undocumented)
    static readonly default: IModelRoutingContext;
    // (undocumented)
    static for(token: RpcRoutingToken): IModelRoutingContext;
    // (undocumented)
    route<T>(handler: () => T): T;
    // (undocumented)
    readonly token: RpcRoutingToken;
}

// @internal
export class IModelTile extends Tile {
    constructor(params: IModelTileParams, tree: IModelTileTree);
    // (undocumented)
    protected addRangeGraphic(builder: GraphicBuilder, type: TileBoundingBoxes): void;
    // (undocumented)
    get channel(): TileRequestChannel;
    // (undocumented)
    get emptySubRangeMask(): number;
    // (undocumented)
    get hasSizeMultiplier(): boolean;
    // (undocumented)
    get iModelChildren(): IModelTile[] | undefined;
    // (undocumented)
    get iModelTree(): IModelTileTree;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[]) => void, reject: (error: Error) => void): void;
    // (undocumented)
    get maximumSize(): number;
    // (undocumented)
    pruneChildren(olderThan: BeTimePoint): void;
    // (undocumented)
    protected get rangeGraphicColor(): ColorDef;
    // (undocumented)
    readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<IModelTileContent>;
    requestChannel?: TileRequestChannel;
    // (undocumented)
    requestContent(): Promise<TileRequest.Response>;
    // (undocumented)
    selectTiles(selected: Tile[], args: TileDrawArgs, numSkipped: number): SelectParent;
    // (undocumented)
    setContent(content: IModelTileContent): void;
    // (undocumented)
    get sizeMultiplier(): number | undefined;
}

// @internal (undocumented)
export interface IModelTileContent extends TileContent {
    emptySubRangeMask?: number;
    sizeMultiplier?: number;
}

// @internal
export interface IModelTileParams extends TileParams {
    // (undocumented)
    sizeMultiplier?: number;
}

// @internal (undocumented)
export function iModelTileParamsFromJSON(props: TileProps, parent: IModelTile | undefined): IModelTileParams;

// @internal
export class IModelTileRequestChannels {
    // (undocumented)
    [Symbol.iterator](): Iterator<TileRequestChannel>;
    constructor(args: {
        concurrency: number;
        usesHttp: boolean;
        cacheMetadata: boolean;
        cacheConcurrency: number;
    });
    // (undocumented)
    get cloudStorage(): TileRequestChannel;
    getCachedContent(tile: IModelTile): IModelTileContent | undefined;
    // (undocumented)
    getChannelForTile(tile: IModelTile): TileRequestChannel;
    // (undocumented)
    readonly rpc: TileRequestChannel;
    // (undocumented)
    setRpcConcurrency(concurrency: number): void;
}

// @internal
export class IModelTileTree extends TileTree {
    constructor(params: IModelTileTreeParams, treeId: IModelTileTreeId);
    // (undocumented)
    get batchType(): BatchType;
    // (undocumented)
    get containsTransformNodes(): boolean;
    // (undocumented)
    readonly contentIdProvider: ContentIdProvider;
    // (undocumented)
    readonly contentIdQualifier?: string;
    debugMaxDepth?: number;
    // (undocumented)
    draw(args: TileDrawArgs): void;
    // (undocumented)
    get edgeOptions(): EdgeOptions | false;
    // (undocumented)
    readonly geometryGuid?: string;
    // (undocumented)
    getTransformNodeRange(nodeId: number): Range3d | undefined;
    get hiddenElements(): Id64Array;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    get loadPriority(): TileLoadPriority;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    readonly maxInitialTilesToSkip: number;
    // (undocumented)
    readonly maxTilesToSkip: number;
    // (undocumented)
    prune(): void;
    // (undocumented)
    get rootTile(): Tile;
    // (undocumented)
    protected _selectTiles(args: TileDrawArgs): Tile[];
    get staticBranch(): IModelTile;
    // (undocumented)
    readonly stringifiedSectionClip?: string;
    // (undocumented)
    readonly tileScreenSize: number;
    get tileState(): "static" | "dynamic" | "interactive" | "disposed";
    // (undocumented)
    get timeline(): RenderSchedule.ModelTimeline | undefined;
    // (undocumented)
    get viewFlagOverrides(): {};
}

// @internal (undocumented)
export interface IModelTileTreeOptions {
    // (undocumented)
    readonly allowInstancing: boolean;
    // (undocumented)
    readonly batchType: BatchType;
    // (undocumented)
    readonly edges: EdgeOptions | false;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly timeline: RenderSchedule.ModelTimeline | undefined;
}

// @internal
export interface IModelTileTreeParams extends TileTreeParams {
    // (undocumented)
    contentIdQualifier?: string;
    // (undocumented)
    formatVersion?: number;
    // (undocumented)
    geometryGuid?: GuidString;
    // (undocumented)
    maxInitialTilesToSkip?: number;
    // (undocumented)
    options: IModelTileTreeOptions;
    // (undocumented)
    rootTile: TileProps;
    // (undocumented)
    tileScreenSize: number;
    // (undocumented)
    transformNodeRanges?: Map<number, Range3d>;
}

// @internal (undocumented)
export function iModelTileTreeParamsFromJSON(props: IModelTileTreeProps, iModel: IModelConnection, modelId: Id64String, options: IModelTileTreeOptions): IModelTileTreeParams;

// @public
export abstract class InputCollector extends InteractiveTool {
    // (undocumented)
    exitTool(): Promise<void>;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): Promise<boolean>;
}

// @public
export enum InputSource {
    Mouse = 1,
    Touch = 2,
    Unknown = 0
}

// @internal
export interface InstancedGraphicParams {
    readonly count: number;
    readonly featureIds?: Uint8Array;
    readonly range?: Range3d;
    readonly symbologyOverrides?: Uint8Array;
    readonly transformCenter: Point3d;
    readonly transforms: Float32Array;
}

// @public
export abstract class InteractiveTool extends Tool {
    // @beta
    applyToolSettingPropertyChange(_updatedValue: DialogPropertySyncItem): Promise<boolean>;
    beginDynamics(): void;
    bumpToolSetting(_settingIndex?: number): Promise<boolean>;
    changeLocateState(enableLocate: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    protected changeToolSettingPropertyValue(syncItem: DialogPropertySyncItem): boolean;
    decorate(_context: DecorateContext): void;
    decorateSuspended(_context: DecorateContext): void;
    endDynamics(): void;
    // (undocumented)
    abstract exitTool(): Promise<void>;
    filterHit(_hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    getCurrentButtonEvent(ev: BeButtonEvent): void;
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    // @internal (undocumented)
    protected getToolSettingPropertyByName(propertyName: string): DialogProperty<any>;
    protected getToolSettingPropertyLocked(_property: DialogProperty<any>): DialogProperty<any> | undefined;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string>;
    protected initializeToolSettingPropertyValues(properties: DialogProperty<any>[]): void;
    initLocateElements(enableLocate?: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    // (undocumented)
    isCompatibleViewport(_vp: ScreenViewport, _isSelectedViewChange: boolean): boolean;
    get isControlDown(): boolean;
    get isDynamicsStarted(): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    onCleanup(): Promise<void>;
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onDynamicFrame(_ev: BeButtonEvent, _context: DynamicsContext): void;
    onInstall(): Promise<boolean>;
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): Promise<EventHandled>;
    onMiddleButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onMiddleButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(_ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled>;
    onMouseWheel(_ev: BeWheelEvent): Promise<EventHandled>;
    onPostInstall(): Promise<void>;
    onReinitialize(): Promise<void>;
    onResetButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onSelectedViewportChanged(_previous: ScreenViewport | undefined, _current: ScreenViewport | undefined): void;
    onSuspend(): Promise<void>;
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    onTouchEnd(_ev: BeTouchEvent): Promise<void>;
    onTouchMove(_ev: BeTouchEvent): Promise<void>;
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): Promise<EventHandled>;
    onTouchStart(_ev: BeTouchEvent): Promise<void>;
    onTouchTap(_ev: BeTouchEvent): Promise<EventHandled>;
    onUnsuspend(): Promise<void>;
    receivedDownEvent: boolean;
    reloadToolSettingsProperties(): void;
    // @internal (undocumented)
    protected restoreToolSettingPropertyValue(property: DialogProperty<any>): boolean;
    // @internal (undocumented)
    protected saveToolSettingPropertyValue(property: DialogProperty<any>, itemValue: DialogItemValue): boolean;
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // @internal (undocumented)
    protected syncToolSettingPropertyValue(property: DialogProperty<any>, isDisabled?: boolean): void;
    syncToolSettingsProperties(syncData: DialogPropertySyncItem[]): void;
    testDecorationHit(_id: string): boolean;
    // @internal (undocumented)
    protected toolSettingProperties?: Map<string, DialogProperty<any>>;
}

// @internal (undocumented)
export const internalMapLayerImageryFormats: (typeof WmsMapLayerFormat)[];

// @public (undocumented)
export class IntersectDetail extends SnapDetail {
    constructor(from: SnapDetail, heat: SnapHeat | undefined, snapPoint: XYZProps, otherPrimitive: CurvePrimitive, otherId: string);
    // (undocumented)
    draw(context: DecorateContext): void;
    // (undocumented)
    readonly otherId: string;
    // (undocumented)
    readonly otherPrimitive: CurvePrimitive;
}

// @public
export class IpcApp {
    static addListener(channel: string, handler: IpcListener): RemoveFunction;
    static appFunctionIpc: PickAsyncMethods<IpcAppFunctions>;
    // @internal
    static callIpcChannel(channelName: string, methodName: string, ...args: any[]): Promise<any>;
    // @deprecated (undocumented)
    static callIpcHost<T extends AsyncMethodsOf<IpcAppFunctions>>(methodName: T, ...args: Parameters<IpcAppFunctions[T]>): Promise<PromiseReturnType<IpcAppFunctions[T]>>;
    static invoke(channel: string, ...args: any[]): Promise<any>;
    static get isValid(): boolean;
    // @internal
    static makeIpcFunctionProxy<K>(channelName: string, functionName: string): PickAsyncMethods<K>;
    static makeIpcProxy<K>(channelName: string): PickAsyncMethods<K>;
    static removeListener(channel: string, listener: IpcListener): void;
    static send(channel: string, ...data: any[]): void;
    // @internal (undocumented)
    static shutdown(): Promise<void>;
    static startup(ipc: IpcSocketFrontend, opts?: IpcAppOptions): Promise<void>;
}

// @public
export interface IpcAppOptions {
    // (undocumented)
    iModelApp?: IModelAppOptions;
}

// @public
export const isCheckboxFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is CheckboxFormatPropEditorSpec;

// @public
export function isCustomQuantityTypeDefinition(item: QuantityTypeDefinition): item is CustomQuantityTypeDefinition;

// @public
export const isTextInputFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is TextInputFormatPropEditorSpec;

// @public
export const isTextSelectFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is TextSelectFormatPropEditorSpec;

// @alpha (undocumented)
export enum ItemField {
    // (undocumented)
    ANGLE_Item = 1,
    // (undocumented)
    DIST_Item = 0,
    // (undocumented)
    X_Item = 2,
    // (undocumented)
    Y_Item = 3,
    // (undocumented)
    Z_Item = 4
}

// @beta
export interface ITwinIdArg {
    // (undocumented)
    readonly iModelId?: GuidString;
    // (undocumented)
    readonly iTwinId?: GuidString;
}

// @public (undocumented)
export const ITWINJS_CORE_VERSION: string;

// @public
export enum KeyinParseError {
    MismatchedQuotes = 4,
    ToolNotFound = 1
}

// @internal (undocumented)
export enum KeyinStatus {
    // (undocumented)
    DontUpdate = 2,
    // (undocumented)
    Dynamic = 0,
    // (undocumented)
    Partial = 1
}

// @beta
export class LengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export function linePlaneIntersect(outP: Point3d, linePt: Point3d, lineNormal: Vector3d | undefined, planePt: Point3d, planeNormal: Vector3d, perpendicular: boolean): void;

// @alpha
export class LocalExtensionProvider implements ExtensionProvider {
    constructor(_props: LocalExtensionProviderProps);
    execute(): Promise<any>;
    getManifest(): Promise<ExtensionManifest>;
}

// @alpha
export interface LocalExtensionProviderProps {
    main: ResolveFunc;
    manifestPromise: Promise<any>;
}

// @internal
export class LocalhostIpcApp {
    // (undocumented)
    static buildUrlForSocket(base: URL, path?: string): URL;
    // (undocumented)
    static startup(opts: LocalHostIpcAppOpts): Promise<void>;
}

// @internal (undocumented)
export interface LocalHostIpcAppOpts {
    // (undocumented)
    iModelApp?: IModelAppOptions;
    // (undocumented)
    localhostIpcApp?: {
        socketPort?: number;
        socketUrl?: URL;
    };
}

// @beta
export class LocalUnitFormatProvider extends BaseUnitFormattingSettingsProvider {
    constructor(quantityFormatter: QuantityFormatter, maintainOverridesPerIModel?: boolean);
    // (undocumented)
    remove(quantityTypeKey: QuantityTypeKey): Promise<boolean>;
    // (undocumented)
    retrieve(quantityTypeKey: QuantityTypeKey): Promise<OverrideFormatEntry | undefined>;
    // (undocumented)
    retrieveUnitSystem(defaultKey: UnitSystemKey): Promise<UnitSystemKey>;
    // (undocumented)
    store(quantityTypeKey: QuantityTypeKey, overrideProps: OverrideFormatEntry): Promise<boolean>;
    // (undocumented)
    storeUnitSystemKey(unitSystemKey: UnitSystemKey): Promise<boolean>;
}

// @public
export enum LocateAction {
    // (undocumented)
    AutoLocate = 1,
    // (undocumented)
    Identify = 0
}

// @public
export enum LocateFilterStatus {
    // (undocumented)
    Accept = 0,
    // (undocumented)
    Reject = 1
}

// @public
export class LocateOptions {
    allowDecorations: boolean;
    allowExternalIModels: boolean;
    allowNonLocatable: boolean;
    clone(): LocateOptions;
    hitSource: HitSource;
    // (undocumented)
    init(): void;
    maxHits: number;
    preserveModelDisplayTransforms: boolean;
    // (undocumented)
    setFrom(other: LocateOptions): void;
}

// @public (undocumented)
export class LocateResponse {
    // @internal (undocumented)
    clone(): LocateResponse;
    // (undocumented)
    explanation: string;
    // (undocumented)
    reason?: string;
    // @internal (undocumented)
    setFrom(other: LocateResponse): void;
    // (undocumented)
    snapStatus: SnapStatus;
}

// @internal (undocumented)
export enum LockedStates {
    // (undocumented)
    ANGLE_BM = 7,
    // (undocumented)
    DIST_BM = 8,
    // (undocumented)
    NONE_LOCKED = 0,
    // (undocumented)
    VEC_BM = 4,
    // (undocumented)
    X_BM = 1,
    // (undocumented)
    XY_BM = 3,
    // (undocumented)
    Y_BM = 2
}

// @public
export class LookAndMoveTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @public
export interface LookAtArgs {
    readonly backDistance?: number;
    readonly eyePoint: XYAndZ;
    readonly frontDistance?: number;
    readonly newExtents?: XAndY;
    readonly opts?: OnViewExtentsError;
    readonly upVector: Vector3d;
}

// @public
export interface LookAtOrthoArgs extends LookAtArgs {
    // (undocumented)
    readonly lensAngle?: never;
    // (undocumented)
    readonly targetPoint?: never;
    readonly viewDirection: XYAndZ;
}

// @public
export interface LookAtPerspectiveArgs extends LookAtArgs {
    // (undocumented)
    readonly lensAngle?: never;
    readonly targetPoint: XYAndZ;
    // (undocumented)
    readonly viewDirection?: never;
}

// @public
export interface LookAtUsingLensAngle extends LookAtArgs {
    readonly lensAngle: Angle;
    readonly targetPoint: XYAndZ;
    // (undocumented)
    readonly viewDirection?: never;
}

// @public
export class LookViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal
export class LRUTileList {
    constructor();
    add(tile: Tile): void;
    // (undocumented)
    protected append(tile: Tile): void;
    // (undocumented)
    protected assertList(): void;
    clearUsed(userId: number): void;
    // (undocumented)
    protected computeBytesUsed(tile: Tile): number;
    // (undocumented)
    dispose(): void;
    drop(tile: Tile): void;
    freeMemory(maxBytes: number): void;
    // (undocumented)
    protected _head: LRUTileListNode;
    markUsed(userId: number, tiles: Iterable<Tile>): void;
    // (undocumented)
    protected moveBeforeSentinel(tile: Tile): void;
    // (undocumented)
    protected moveToEnd(tile: Tile): void;
    get selectedTiles(): Iterable<Tile>;
    // (undocumented)
    protected readonly _sentinel: LRUTileListNode;
    // (undocumented)
    protected readonly _stats: RenderMemory.Statistics;
    // (undocumented)
    protected _tail: LRUTileListNode;
    get totalBytesUsed(): number;
    // (undocumented)
    protected _totalBytesUsed: number;
    // (undocumented)
    protected unlink(tile: Tile): void;
    get unselectedTiles(): Iterable<Tile>;
    // (undocumented)
    protected readonly _userIdSets: TileUserIdSets;
}

// @internal
export interface LRUTileListNode {
    bytesUsed: number;
    // (undocumented)
    next?: LRUTileListNode;
    // (undocumented)
    previous?: LRUTileListNode;
    tileUserIds?: TileUserIdSet | undefined;
}

// @public (undocumented)
export enum ManipulatorToolEvent {
    // (undocumented)
    Start = 1,
    // (undocumented)
    Stop = 2,
    // (undocumented)
    Suspend = 3,
    // (undocumented)
    Unsuspend = 4
}

// @internal
export class MapBoxLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement): void;
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    get minimumZoomLevel(): number;
    // (undocumented)
    get tileHeight(): number;
    // (undocumented)
    get tileWidth(): number;
}

// @beta
export class MapCartoRectangle extends Range2d {
    protected constructor(west: number, south: number, east: number, north: number);
    get cartoCenter(): Cartographic;
    containsCartographic(carto: Cartographic): boolean;
    static createMaximum(): MapCartoRectangle;
    static createZero(): MapCartoRectangle;
    get east(): number;
    set east(x: number);
    fractionFromCartographic(carto: Cartographic): Point2d | undefined;
    static fromDegrees(west: number, south: number, east: number, north: number, result?: MapCartoRectangle): MapCartoRectangle;
    static fromRadians(west: number, south: number, east: number, north: number, result?: MapCartoRectangle): MapCartoRectangle;
    getCenter(result?: Cartographic): Cartographic;
    // @internal (undocumented)
    getTileFractionRange(tilingScheme: MapTilingScheme): Range2d;
    get globalLocation(): GlobalLocation;
    get globalLocationArea(): GlobalLocationArea;
    get latLongString(): string;
    get north(): number;
    set north(y: number);
    setRadians(west?: number, south?: number, east?: number, north?: number): void;
    get south(): number;
    set south(y: number);
    get west(): number;
    set west(x: number);
}

// @alpha (undocumented)
export interface MapFeatureInfo {
    // (undocumented)
    hitPoint?: Cartographic;
    // (undocumented)
    layerInfo?: MapLayerFeatureInfo[];
}

// @alpha (undocumented)
export class MapFeatureInfoRecord extends PropertyRecord {
    constructor(value: PropertyValue, property: PropertyDescription);
}

// @beta (undocumented)
export interface MapLayerAccessClient {
    // (undocumented)
    getAccessToken(params: MapLayerAccessTokenParams): Promise<MapLayerAccessToken | undefined>;
    // (undocumented)
    getTokenServiceEndPoint?(mapLayerUrl: string): Promise<MapLayerTokenEndpoint | undefined>;
    // (undocumented)
    invalidateToken?(token: MapLayerAccessToken): boolean;
    // (undocumented)
    onOAuthProcessEnd?: BeEvent<Listener>;
}

// @beta (undocumented)
export interface MapLayerAccessToken {
    // (undocumented)
    token: string;
}

// @beta (undocumented)
export interface MapLayerAccessTokenParams {
    // (undocumented)
    mapLayerUrl: URL;
    // (undocumented)
    password?: string;
    // (undocumented)
    userName?: string;
}

// @beta (undocumented)
export interface MapLayerAuthenticationInfo {
    // (undocumented)
    tokenEndpoint?: MapLayerTokenEndpoint;
}

// @internal (undocumented)
export type MapLayerClassifiers = Map<number, RenderPlanarClassifier>;

// @alpha (undocumented)
export interface MapLayerFeatureInfo {
    // (undocumented)
    info?: MapSubLayerFeatureInfo[] | HTMLElement;
    // (undocumented)
    layerName: string;
}

// @beta
export class MapLayerFormat {
    // @internal
    static createImageryProvider(_settings: MapLayerSettings): MapLayerImageryProvider | undefined;
    // @internal (undocumented)
    static createMapLayerTree(_layerSettings: MapLayerSettings, _layerIndex: number, _iModel: IModelConnection): MapLayerTileTreeReference | undefined;
    // (undocumented)
    static formatId: string;
    static register(): void;
    static validateSource(_url: string, _userName?: string, _password?: string, _ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal (undocumented)
export interface MapLayerFormatEntry {
    // (undocumented)
    accessClient?: MapLayerAccessClient;
    // (undocumented)
    type: MapLayerFormatType;
}

// @beta (undocumented)
export class MapLayerFormatRegistry {
    constructor(opts?: MapLayerOptions);
    // (undocumented)
    get configOptions(): MapLayerOptions;
    // @internal (undocumented)
    createImageryMapLayerTree(layerSettings: ImageMapLayerSettings, layerIndex: number, iModel: IModelConnection): ImageryMapLayerTreeReference | undefined;
    // @internal (undocumented)
    createImageryProvider(layerSettings: ImageMapLayerSettings): MapLayerImageryProvider | undefined;
    // (undocumented)
    getAccessClient(formatId: string): MapLayerAccessClient | undefined;
    // (undocumented)
    isRegistered(formatId: string): boolean;
    // (undocumented)
    register(formatClass: MapLayerFormatType, accessClient?: MapLayerAccessClient): void;
    // (undocumented)
    setAccessClient(formatId: string, accessClient: MapLayerAccessClient): boolean;
    // (undocumented)
    validateSource(formatId: string, url: string, userName?: string, password?: string, ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @beta (undocumented)
export type MapLayerFormatType = typeof MapLayerFormat;

// @internal
export abstract class MapLayerImageryProvider {
    constructor(_settings: ImageMapLayerSettings, _usesCachedTiles: boolean);
    // (undocumented)
    addLogoCards(_cards: HTMLTableElement, _viewport: ScreenViewport): void;
    // (undocumented)
    protected _areChildrenAvailable(_tile: ImageryMapTile): Promise<boolean>;
    // (undocumented)
    cartoRange?: MapCartoRectangle;
    // (undocumented)
    abstract constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    protected readonly defaultMaximumZoomLevel = 22;
    // (undocumented)
    protected readonly defaultMinimumZoomLevel = 0;
    // (undocumented)
    protected get _filterByCartoRange(): boolean;
    // (undocumented)
    generateChildIds(tile: ImageryMapTile, resolveChildren: (childIds: QuadId[]) => void): void;
    // (undocumented)
    protected _generateChildIds(tile: ImageryMapTile, resolveChildren: (childIds: QuadId[]) => void): void;
    // (undocumented)
    getEPSG3857Extent(row: number, column: number, zoomLevel: number): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    // (undocumented)
    getEPSG3857ExtentString(row: number, column: number, zoomLevel: number): string;
    // (undocumented)
    getEPSG3857X(longitude: number): number;
    // (undocumented)
    getEPSG3857Y(latitude: number): number;
    // (undocumented)
    getEPSG4326Extent(row: number, column: number, zoomLevel: number): {
        longitudeLeft: number;
        longitudeRight: number;
        latitudeTop: number;
        latitudeBottom: number;
    };
    // (undocumented)
    getEPSG4326ExtentString(row: number, column: number, zoomLevel: number, latLongAxisOrdering: boolean): string;
    // (undocumented)
    getEPSG4326Lat(y3857: number): number;
    // (undocumented)
    getEPSG4326Lon(x3857: number): number;
    // (undocumented)
    getFeatureInfo(featureInfos: MapLayerFeatureInfo[], _quadId: QuadId, _carto: Cartographic, _tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    protected getImageFromTileResponse(tileResponse: Response, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    getPotentialChildIds(tile: ImageryMapTile): QuadId[];
    // (undocumented)
    getToolTip(strings: string[], quadId: QuadId, _carto: Cartographic, tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    get hasSuccessfullyFetchedTile(): boolean;
    // (undocumented)
    protected _hasSuccessfullyFetchedTile: boolean;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    makeTileRequest(url: string): Promise<Response>;
    // (undocumented)
    matchesMissingTile(tileData: Uint8Array): boolean;
    // (undocumented)
    get maximumScreenSize(): number;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    get minimumZoomLevel(): number;
    // (undocumented)
    protected _missingTileData?: Uint8Array;
    // (undocumented)
    get mutualExclusiveSubLayer(): boolean;
    // (undocumented)
    readonly onStatusChanged: BeEvent<(provider: MapLayerImageryProvider) => void>;
    protected onStatusUpdated(_newStatus: MapLayerImageryProviderStatus): void;
    // (undocumented)
    resetStatus(): void;
    // (undocumented)
    protected setRequestAuthorization(headers: Headers): void;
    setStatus(status: MapLayerImageryProviderStatus): void;
    // (undocumented)
    protected readonly _settings: ImageMapLayerSettings;
    // (undocumented)
    get status(): MapLayerImageryProviderStatus;
    // (undocumented)
    get tileSize(): number;
    // (undocumented)
    get tilingScheme(): MapTilingScheme;
    // (undocumented)
    protected toolTipFromUrl(strings: string[], url: string): Promise<void>;
    // (undocumented)
    get transparentBackgroundString(): string;
    // (undocumented)
    get useGeographicTilingScheme(): boolean;
    // (undocumented)
    get usesCachedTiles(): boolean;
    // (undocumented)
    protected _usesCachedTiles: boolean;
}

// @beta (undocumented)
export enum MapLayerImageryProviderStatus {
    // (undocumented)
    RequireAuth = 1,
    // (undocumented)
    Valid = 0
}

// @internal
export interface MapLayerIndex {
    index: number;
    isOverlay: boolean;
}

// @beta
export interface MapLayerOptions {
    [format: string]: MapLayerKey | undefined;
    AzureMaps?: MapLayerKey;
    BingMaps?: MapLayerKey;
    MapboxImagery?: MapLayerKey;
}

// @beta
export interface MapLayerScaleRangeVisibility {
    index: number;
    isOverlay: boolean;
    visibility: MapTileTreeScaleRangeVisibility;
}

// @public
export class MapLayerSource {
    // (undocumented)
    baseMap: boolean;
    // (undocumented)
    formatId: string;
    // @internal (undocumented)
    static fromBackgroundMapProps(props: DeprecatedBackgroundMapProps): MapLayerSource | undefined;
    // (undocumented)
    static fromJSON(json: MapLayerSourceProps): MapLayerSource | undefined;
    // (undocumented)
    name: string;
    // (undocumented)
    password?: string;
    // (undocumented)
    toJSON(): {
        url: string;
        name: string;
        formatId: string;
        transparentBackground: boolean | undefined;
    };
    // (undocumented)
    toLayerSettings(subLayers?: MapSubLayerProps[]): ImageMapLayerSettings | undefined;
    // (undocumented)
    transparentBackground?: boolean;
    // (undocumented)
    url: string;
    // (undocumented)
    userName?: string;
    // (undocumented)
    validateSource(ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal
export class MapLayerSources {
    // (undocumented)
    static addSourceToMapLayerSources(mapLayerSource?: MapLayerSource): Promise<MapLayerSources | undefined>;
    // (undocumented)
    get allSource(): MapLayerSource[];
    // (undocumented)
    get bases(): MapLayerSource[];
    // (undocumented)
    static create(iModel?: IModelConnection, queryForPublicSources?: boolean, addMapBoxSources?: boolean): Promise<MapLayerSources>;
    // (undocumented)
    findByName(name: string, baseMap?: boolean): MapLayerSource | undefined;
    // (undocumented)
    static getInstance(): MapLayerSources | undefined;
    // (undocumented)
    get layers(): MapLayerSource[];
    // (undocumented)
    static removeLayerByName(name: string): boolean;
}

// @public
export enum MapLayerSourceStatus {
    InvalidCoordinateSystem = 6,
    InvalidCredentials = 1,
    InvalidFormat = 2,
    InvalidTileTree = 3,
    InvalidUrl = 4,
    RequireAuth = 5,
    Valid = 0
}

// @public (undocumented)
export interface MapLayerSourceValidation {
    // @beta (undocumented)
    authInfo?: MapLayerAuthenticationInfo;
    // (undocumented)
    status: MapLayerSourceStatus;
    // (undocumented)
    subLayers?: MapSubLayerProps[];
}

// @internal (undocumented)
export abstract class MapLayerTileTreeReference extends TileTreeReference {
    constructor(_layerSettings: MapLayerSettings, _layerIndex: number, iModel: IModelConnection);
    // (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string | undefined>;
    // (undocumented)
    get imageryProvider(): MapLayerImageryProvider | undefined;
    // (undocumented)
    iModel: IModelConnection;
    // (undocumented)
    get isOpaque(): boolean;
    // (undocumented)
    get layerIndex(): number;
    // (undocumented)
    protected _layerIndex: number;
    // (undocumented)
    get layerName(): string;
    set layerSettings(layerSettings: MapLayerSettings);
    // (undocumented)
    get layerSettings(): MapLayerSettings;
    // (undocumented)
    protected _layerSettings: MapLayerSettings;
    // (undocumented)
    get transparency(): number | undefined;
    // (undocumented)
    protected get _transparency(): number | undefined;
}

// @beta (undocumented)
export interface MapLayerTokenEndpoint {
    // (undocumented)
    getLoginUrl(stateData?: any): string | undefined;
    // (undocumented)
    getUrl(): string;
}

// @alpha (undocumented)
export interface MapSubLayerFeatureInfo {
    // (undocumented)
    displayFieldName?: string;
    // (undocumented)
    records?: MapFeatureInfoRecord[];
    // (undocumented)
    subLayerName: string;
}

// @beta
export class MapTile extends RealityTile {
    // @internal
    constructor(params: RealityTileParams, mapTree: MapTileTree, quadId: QuadId, patch: TilePatch, rectangle: MapCartoRectangle, heightRange: Range1d | undefined, cornerRays: Ray3d[] | undefined);
    // @internal (undocumented)
    addBoundingGraphic(builder: GraphicBuilder, color: ColorDef): void;
    adjustHeights(minHeight: number, maxHeight: number): void;
    // @internal (undocumented)
    get baseImageryIsReady(): boolean;
    // @internal (undocumented)
    clearLayers(): void;
    // @internal (undocumented)
    protected _collectStatistics(stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    static computeRangeCorners(corners: Point3d[], normal: Vector3d, chordHeight: number, result?: Point3d[], heightRange?: Range1d): Point3d[];
    // @internal (undocumented)
    protected _cornerRays?: Ray3d[];
    // @internal (undocumented)
    disposeContents(): void;
    // @internal (undocumented)
    everLoaded: boolean;
    // @internal
    forceSelectRealityTile(): boolean;
    // @internal (undocumented)
    freeMemory(): void;
    // @internal (undocumented)
    getClipShape(): Point3d[];
    // @internal (undocumented)
    getContentClip(): ClipVector | undefined;
    // @internal (undocumented)
    getDrapeTextures(): TerrainTexture[] | undefined;
    // @internal (undocumented)
    getGraphic(_system: RenderSystem, _texture: RenderTexture): RenderGraphic | undefined;
    getProjection(heightRange?: Range1d): MapTileProjection;
    // @internal (undocumented)
    getRangeCorners(result: Point3d[]): Point3d[];
    // @internal (undocumented)
    getSizeProjectionCorners(): Point3d[] | undefined;
    // @internal (undocumented)
    get graphicType(): TileGraphicType;
    // @internal (undocumented)
    get hasGraphics(): boolean;
    // @internal
    get heightRange(): Range1d | undefined;
    // @internal (undocumented)
    protected _heightRange: Range1d | undefined;
    // @internal
    get hiddenImageryTiles(): ImageryMapTile[] | undefined;
    // @internal (undocumented)
    get imageryIsReady(): boolean;
    // @internal (undocumented)
    get imageryTiles(): ImageryMapTile[] | undefined;
    // @internal (undocumented)
    isContentCulled(args: TileDrawArgs): boolean;
    // @internal
    get isDisplayable(): boolean;
    // @internal (undocumented)
    isOccluded(viewingSpace: ViewingSpace): boolean;
    // @internal (undocumented)
    get isPlanar(): boolean;
    // @internal (undocumented)
    get isReady(): boolean;
    // @internal (undocumented)
    isRegionCulled(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    get isUpsampled(): boolean;
    // @internal (undocumented)
    get loadableTerrainTile(): MapTile;
    // @internal (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, _reject: (error: Error) => void): void;
    // @internal (undocumented)
    get mapLoader(): MapTileLoader;
    // @internal (undocumented)
    get mapTilingScheme(): MapTilingScheme;
    readonly mapTree: MapTileTree;
    // @internal (undocumented)
    markUsed(args: TileDrawArgs): void;
    // @internal (undocumented)
    get mesh(): RealityMeshParams | undefined;
    // @internal (undocumented)
    protected _mesh?: RealityMeshParams;
    // @internal (undocumented)
    produceGraphics(): RenderGraphic | undefined;
    readonly quadId: QuadId;
    readonly rectangle: MapCartoRectangle;
    // @internal (undocumented)
    get renderGeometry(): RenderTerrainGeometry | undefined;
    // @internal (undocumented)
    protected _renderGeometry?: RenderTerrainGeometry;
    // @internal
    selectSecondaryTiles(args: TileDrawArgs, context: TraversalSelectionContext): void;
    // @internal (undocumented)
    setContent(content: TerrainTileContent): void;
    // @internal (undocumented)
    setNotFound(): void;
    // @internal (undocumented)
    tileFromQuadId(quadId: QuadId): MapTile | undefined;
}

// @internal (undocumented)
export class MapTiledGraphicsProvider implements TiledGraphicsProvider {
    constructor(viewportId: number, displayStyle: DisplayStyleState);
    // (undocumented)
    readonly backgroundDrapeMap: MapTileTreeReference;
    // (undocumented)
    readonly backgroundMap: MapTileTreeReference;
    // (undocumented)
    detachFromDisplayStyle(): void;
    // (undocumented)
    forEachTileTreeRef(viewport: Viewport, func: (ref: TileTreeReference) => void): void;
    // (undocumented)
    getMapLayerImageryProvider(index: number, isOverlay: boolean): MapLayerImageryProvider | undefined;
    getMapLayerIndexesFromIds(mapTreeId: Id64String, layerTreeId: Id64String): MapLayerIndex[];
    // (undocumented)
    mapLayerFromIds(mapTreeId: Id64String, layerTreeId: Id64String): MapLayerSettings | undefined;
    // (undocumented)
    readonly overlayMap: MapTileTreeReference;
    // (undocumented)
    resetMapLayer(index: number, isOverlay: boolean): void;
    // (undocumented)
    setView(newView: ViewState): void;
}

// @internal
export class MapTileLoader extends RealityTileLoader {
    constructor(_iModel: IModelConnection, _modelId: Id64String, _groundBias: number, _terrainProvider: TerrainMeshProvider);
    // (undocumented)
    protected _applyLights: boolean;
    // (undocumented)
    get clipLowResolutionTiles(): boolean;
    // (undocumented)
    readonly featureTable: FeatureTable;
    // (undocumented)
    forceTileLoad(tile: MapTile): boolean;
    // (undocumented)
    getChildHeightRange(quadId: QuadId, rectangle: MapCartoRectangle, parent: MapTile): Range1d | undefined;
    // (undocumented)
    getFeatureIndex(layerModelId: Id64String): number;
    // (undocumented)
    getRequestChannel(_tile: Tile): TileRequestChannel;
    // (undocumented)
    protected _groundBias: number;
    // (undocumented)
    protected readonly _heightRange: Range1d | undefined;
    // (undocumented)
    protected _iModel: IModelConnection;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    isTileAvailable(quadId: QuadId): boolean;
    // (undocumented)
    loadChildren(_tile: RealityTile): Promise<Tile[] | undefined>;
    // (undocumented)
    loadPolyfaces(): Polyface[] | undefined;
    // (undocumented)
    loadTileContent(tile: MapTile, data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TerrainTileContent>;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    get minDepth(): number;
    // (undocumented)
    protected _modelId: Id64String;
    // (undocumented)
    get priority(): TileLoadPriority;
    // (undocumented)
    requestTileContent(tile: MapTile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    get terrainProvider(): TerrainMeshProvider;
}

// @beta
export abstract class MapTileProjection {
    // @alpha (undocumented)
    get ellipsoidPatch(): EllipsoidPatch | undefined;
    // @alpha (undocumented)
    getGlobalPoint(u: number, v: number, z: number, result?: Point3d): Point3d;
    abstract getPoint(u: number, v: number, height: number, result?: Point3d): Point3d;
    abstract get localRange(): Range3d;
    // @alpha (undocumented)
    abstract get transformFromLocal(): Transform;
}

// @beta
export class MapTileTree extends RealityTileTree {
    // @internal
    constructor(params: RealityTileTreeParams, ecefToDb: Transform, bimElevationBias: number, geodeticOffset: number, sourceTilingScheme: MapTilingScheme, id: MapTreeId, applyTerrain: boolean);
    // @internal
    addImageryLayer(tree: ImageryMapTileTree, settings: MapLayerSettings, index: number): void;
    // @internal (undocumented)
    addModelLayer(layerTreeRef: ModelMapLayerTileTreeReference, context: SceneContext): void;
    // @internal (undocumented)
    baseColor?: ColorDef;
    // @internal (undocumented)
    baseTransparent: boolean;
    // @internal (undocumented)
    bimElevationBias: number;
    // @internal (undocumented)
    clearImageryTreesAndClassifiers(): void;
    // @internal (undocumented)
    clearLayers(): void;
    // @internal
    cloneImageryTreeState(): Map<string, ImageryTileTreeState>;
    // @internal (undocumented)
    protected collectClassifierGraphics(args: TileDrawArgs, selectedTiles: RealityTile[]): void;
    // @internal (undocumented)
    createGlobeChild(params: TileParams, quadId: QuadId, _rangeCorners: Point3d[], rectangle: MapCartoRectangle, ellipsoidPatch: EllipsoidPatch, heightRange?: Range1d): MapTile;
    // @internal (undocumented)
    createPlanarChild(params: TileParams, quadId: QuadId, corners: Point3d[], normal: Vector3d, rectangle: MapCartoRectangle, chordHeight: number, heightRange?: Range1d): MapTile | undefined;
    // @internal (undocumented)
    doCreateGlobeChildren(tile: Tile): boolean;
    // @internal (undocumented)
    doReprojectChildren(tile: Tile): boolean;
    // @internal (undocumented)
    earthEllipsoid: Ellipsoid;
    // @internal (undocumented)
    ecefToDb: Transform;
    // @internal (undocumented)
    geodeticOffset: number;
    // @internal (undocumented)
    getBaseRealityDepth(sceneContext: SceneContext): number;
    // @internal (undocumented)
    getCachedReprojectedPoints(gridPoints: Point3d[]): (Point3d | undefined)[] | undefined;
    // @internal (undocumented)
    getChildHeightRange(quadId: QuadId, rectangle: MapCartoRectangle, parent: MapTile): Range1d | undefined;
    // @internal (undocumented)
    getCornerRays(rectangle: MapCartoRectangle): Ray3d[] | undefined;
    // @internal (undocumented)
    getFractionalTileCorners(quadId: QuadId): Point3d[];
    // @internal
    getImageryTreeState(imageryTreeId: string): ImageryTileTreeState | undefined;
    // @internal (undocumented)
    getLayerIndex(imageryTreeId: Id64String): number;
    // @internal (undocumented)
    getLayerTransparency(imageryTreeId: Id64String): number;
    // @internal
    getPlanarChildCorners(tile: MapTile, columnCount: number, rowCount: number, resolve: (childCorners: Point3d[][]) => void): void;
    // @internal (undocumented)
    getTileRectangle(quadId: QuadId): MapCartoRectangle;
    readonly globeMode: GlobeMode;
    // @internal (undocumented)
    globeOrigin: Point3d;
    // @internal (undocumented)
    isOverlay: boolean;
    // @internal (undocumented)
    get isTransparent(): boolean;
    // @internal (undocumented)
    layerClassifiers: Map<number, RenderPlanarClassifier>;
    // @internal (undocumented)
    layerImageryTrees: MapLayerTreeSetting[];
    // @internal
    loadReprojectionCache(tile: MapTile): Promise<void>;
    // @internal (undocumented)
    get mapLoader(): MapTileLoader;
    // @internal (undocumented)
    mapTransparent: boolean;
    // @internal (undocumented)
    get maxDepth(): number;
    // @internal (undocumented)
    maxEarthEllipsoid: Ellipsoid;
    // @internal (undocumented)
    static maxGlobeDisplayDepth: number;
    // @internal (undocumented)
    static minDisplayableDepth: number;
    // @internal (undocumented)
    minEarthEllipsoid: Ellipsoid;
    // @internal
    static minReprojectionDepth: number;
    // @internal (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // @internal (undocumented)
    pointAboveEllipsoid(point: Point3d): boolean;
    // @internal (undocumented)
    produceGeometry?: boolean;
    // @internal
    reportTileVisibility(args: TileDrawArgs, selected: RealityTile[]): void;
    // @internal (undocumented)
    sourceTilingScheme: MapTilingScheme;
    // @internal (undocumented)
    terrainExaggeration: number;
    // @internal (undocumented)
    tileFromQuadId(quadId: QuadId): MapTile | undefined;
    // @internal (undocumented)
    useDepthBuffer: boolean;
}

// @internal
export class MapTileTreeReference extends TileTreeReference {
    constructor(settings: BackgroundMapSettings, _baseLayerSettings: BaseLayerSettings | undefined, _layerSettings: MapLayerSettings[], iModel: IModelConnection, tileUserId: number, isOverlay: boolean, _isDrape: boolean, _overrideTerrainDisplay?: CheckTerrainDisplayOverride | undefined);
    addLogoCards(cards: HTMLTableElement, vp: ScreenViewport): void;
    addToScene(context: SceneContext): void;
    // (undocumented)
    get baseColor(): ColorDef | undefined;
    // (undocumented)
    get castsShadows(): boolean;
    // (undocumented)
    clearLayers(): void;
    // (undocumented)
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
    // (undocumented)
    protected _createGeometryTreeReference(): GeometryTileTreeReference | undefined;
    // (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    getLayerImageryTreeRef(index: number): MapLayerTileTreeReference | undefined;
    // (undocumented)
    getMapFeatureInfo(hit: HitDetail): Promise<MapLayerFeatureInfo[] | undefined>;
    getMapLayerScaleRangeVisibility(index: number): MapTileTreeScaleRangeVisibility;
    // (undocumented)
    protected getSymbologyOverrides(_tree: TileTree): FeatureSymbology.Overrides | undefined;
    // (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string | undefined>;
    // (undocumented)
    protected getViewFlagOverrides(_tree: TileTree): Partial<Mutable<NonFunctionPropertiesOf<ViewFlags>>>;
    // (undocumented)
    imageryTreeFromTreeModelIds(mapTreeModelId: Id64String, layerTreeModelId: Id64String): ImageryMapLayerTreeReference | undefined;
    // (undocumented)
    initializeLayers(context: SceneContext): boolean;
    // (undocumented)
    get isGlobal(): boolean;
    // (undocumented)
    protected get _isLoadingComplete(): boolean;
    // (undocumented)
    isOverlay: boolean;
    // (undocumented)
    layerFromTreeModelIds(mapTreeModelId: Id64String, layerTreeModelId: Id64String): MapLayerSettings | undefined;
    // (undocumented)
    get layerSettings(): MapLayerSettings[];
    // (undocumented)
    get planarclipMaskPriority(): number;
    // (undocumented)
    setBaseLayerSettings(baseLayerSettings: BaseLayerSettings): void;
    // (undocumented)
    setLayerSettings(layerSettings: MapLayerSettings[]): void;
    // (undocumented)
    get settings(): BackgroundMapSettings;
    set settings(settings: BackgroundMapSettings);
    // (undocumented)
    get treeOwner(): TileTreeOwner;
    unionFitRange(_range: Range3d): void;
    // (undocumented)
    get useDepthBuffer(): boolean;
}

// @beta
export enum MapTileTreeScaleRangeVisibility {
    Hidden = 2,
    Partial = 3,
    Unknown = 0,
    Visible = 1
}

// @beta
export abstract class MapTilingScheme {
    protected constructor(numberOfLevelZeroTilesX: number, numberOfLevelZeroTilesY: number, rowZeroAtNorthPole: boolean);
    cartographicToFraction(latitudeRadians: number, longitudeRadians: number, result: Point2d): Point2d;
    cartographicToTileXY(carto: Cartographic, level: number, result?: Point2d): Point2d;
    // @alpha (undocumented)
    computeMercatorFractionToDb(ecefToDb: Transform, bimElevationOffset: number, iModel: IModelConnection, applyTerrain: boolean): Transform;
    fractionToCartographic(xFraction: number, yFraction: number, result: Cartographic, height?: number): Cartographic;
    // @alpha (undocumented)
    getNumberOfXChildrenAtLevel(level: number): number;
    getNumberOfXTilesAtLevel(level: number): number;
    // @alpha (undocumented)
    getNumberOfYChildrenAtLevel(level: number): number;
    getNumberOfYTilesAtLevel(level: number): number;
    abstract latitudeToYFraction(latitude: number): number;
    longitudeToXFraction(longitude: number): number;
    readonly numberOfLevelZeroTilesX: number;
    readonly numberOfLevelZeroTilesY: number;
    // @alpha (undocumented)
    get rootLevel(): 0 | -1;
    readonly rowZeroAtNorthPole: boolean;
    tileBordersNorthPole(row: number, level: number): boolean;
    tileBordersSouthPole(row: number, level: number): boolean;
    tileXToFraction(x: number, level: number): number;
    tileXToLongitude(x: number, level: number): number;
    tileXYToCartographic(x: number, y: number, level: number, result: Cartographic, height?: number): Cartographic;
    tileXYToFraction(x: number, y: number, level: number, result?: Point2d): Point2d;
    tileXYToRectangle(x: number, y: number, level: number, result?: MapCartoRectangle): MapCartoRectangle;
    tileYToFraction(y: number, level: number): number;
    tileYToLatitude(y: number, level: number): number;
    xFractionToLongitude(xFraction: number): number;
    xFractionToTileX(xFraction: number, level: number): number;
    // @alpha (undocumented)
    protected yFractionFlip(fraction: number): number;
    abstract yFractionToLatitude(yFraction: number): number;
    yFractionToTileY(yFraction: number, level: number): number;
}

// @public
export interface MarginOptions {
    marginPercent?: MarginPercent;
    paddingPercent?: PaddingPercent | number;
}

// @public
export class MarginPercent {
    constructor(left: number, top: number, right: number, bottom: number);
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public
export class Marker implements CanvasDecoration {
    constructor(worldLocation: XYAndZ, size: XAndY);
    addDecoration(context: DecorateContext): void;
    addMarker(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    drawFunc?(ctx: CanvasRenderingContext2D): void;
    protected drawHilited(ctx: CanvasRenderingContext2D): boolean;
    protected _hiliteColor?: ColorDef;
    htmlElement?: HTMLElement;
    image?: MarkerImage;
    imageOffset?: XAndY;
    imageSize?: XAndY;
    protected _isHilited: boolean;
    label?: string;
    labelAlign?: MarkerTextAlign;
    labelBaseline?: MarkerTextBaseline;
    labelColor?: MarkerFillStyle;
    labelFont?: string;
    labelMaxWidth?: number;
    labelOffset?: XAndY;
    static makeFrom<T extends Marker>(other: Marker, ...args: any[]): T;
    onMouseButton?(_ev: BeButtonEvent): boolean;
    onMouseEnter(ev: BeButtonEvent): void;
    onMouseLeave(): void;
    onMouseMove(ev: BeButtonEvent): void;
    pick(pt: XAndY): boolean;
    position: Point3d;
    protected positionHtml(): void;
    readonly rect: ViewRect;
    // (undocumented)
    protected _scaleFactor?: Point2d;
    // (undocumented)
    protected _scaleFactorRange?: Range1d;
    setImage(image: MarkerImage | Promise<MarkerImage>): void;
    setImageUrl(url: string): void;
    setPosition(vp: Viewport, markerSet?: MarkerSet<Marker>): boolean;
    setScaleFactor(range: Range1dProps): void;
    size: Point2d;
    title?: HTMLElement | string;
    tooltipOptions?: ToolTipOptions;
    visible: boolean;
    get wantImage(): boolean;
    worldLocation: Point3d;
}

// @public (undocumented)
export type MarkerFillStyle = string | CanvasGradient | CanvasPattern;

// @public
export type MarkerImage = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;

// @public
export abstract class MarkerSet<T extends Marker> {
    constructor(viewport?: ScreenViewport);
    addDecoration(context: DecorateContext): void;
    // @beta
    changeViewport(viewport: ScreenViewport): void;
    protected clusterRadius: number;
    // @internal (undocumented)
    protected _entries: Array<T | Cluster<T>>;
    protected abstract getClusterMarker(cluster: Cluster<T>): Marker;
    getMinScaleViewW(vp: Viewport): number;
    markDirty(): void;
    get markers(): Set<T>;
    minimumClusterSize: number;
    // @internal (undocumented)
    protected _minScaleViewW?: number;
    get viewport(): ScreenViewport | undefined;
    // @internal (undocumented)
    protected readonly _worldToViewMap: Matrix4d;
}

// @public (undocumented)
export type MarkerTextAlign = "left" | "right" | "center" | "start" | "end";

// @public (undocumented)
export type MarkerTextBaseline = "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";

// @public
export interface MaterialDiffuseProps {
    color?: ColorDef | RgbColorProps;
    weight?: number;
}

// @public
export interface MaterialSpecularProps {
    color?: ColorDef | RgbColorProps;
    exponent?: number;
    weight?: number;
}

// @public
export interface MaterialTextureMappingProps {
    mode?: TextureMapping.Mode;
    normalMapParams?: NormalMapParams;
    texture: RenderTexture;
    transform?: TextureMapping.Trans2x3;
    weight?: number;
    // @internal (undocumented)
    worldMapping?: boolean;
}

// @public
export class MeasureAreaByPointsTool extends PrimitiveTool {
    // @internal (undocumented)
    protected _acceptedMeasurement?: MeasureMarker;
    // @internal (undocumented)
    protected allowView(vp: Viewport): boolean;
    // @internal (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): Promise<boolean>;
    // @internal (undocumented)
    protected _area: number;
    // @internal (undocumented)
    protected _centroid: Point3d;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // @internal (undocumented)
    protected static enumAsOrientationMessage(str: string): string;
    // @internal (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    protected getMarkerToolTip(): Promise<HTMLElement>;
    // @internal (undocumented)
    protected getShapePoints(cursorPt: Point3d): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    protected _isComplete: boolean;
    // @internal (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // @internal (undocumented)
    protected _lastMotionPt?: Point3d;
    // @internal (undocumented)
    protected _marker?: MeasureLabel;
    // @internal (undocumented)
    protected _matrix?: Matrix3d;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    onReinitialize(): Promise<void>;
    // @internal (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    onUnsuspend(): Promise<void>;
    // @internal (undocumented)
    get orientation(): ContextRotationId;
    set orientation(option: ContextRotationId);
    // @internal (undocumented)
    protected static _orientationName: string;
    // @internal (undocumented)
    protected _perimeter: number;
    // @internal (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected reportMeasurements(): void;
    // @internal (undocumented)
    requireWriteableTarget(): boolean;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // @internal (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @public
export class MeasureAreaTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export class MeasureDistanceTool extends PrimitiveTool {
    // @internal (undocumented)
    protected readonly _acceptedSegments: Segment[];
    // @internal (undocumented)
    protected acceptNewSegments(): Promise<void>;
    // @internal (undocumented)
    protected allowView(vp: Viewport): boolean;
    // @internal (undocumented)
    protected createDecorations(context: DecorateContext, isSuspended: boolean): void;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // @internal (undocumented)
    protected displayDelta(context: DecorateContext, seg: any): void;
    // @internal (undocumented)
    protected displayDynamicDistance(context: DecorateContext, points: Point3d[], adjustedPoints: Point3d[]): void;
    // @internal (undocumented)
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    protected getMarkerToolTip(distance: number, slope: number, start: Point3d, end: Point3d, delta?: Vector3d): Promise<HTMLElement>;
    // @internal (undocumented)
    protected getReferenceAxes(vp?: Viewport): Matrix3d;
    // @internal (undocumented)
    protected getSnapPoints(): Point3d[] | undefined;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // @internal (undocumented)
    protected _lastMotionAdjustedPt?: Point3d;
    // @internal (undocumented)
    protected _lastMotionPt?: Point3d;
    // @internal (undocumented)
    protected readonly _locationData: Location_2[];
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    protected reportMeasurements(): void;
    // @internal (undocumented)
    requireWriteableTarget(): boolean;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // @internal (undocumented)
    protected _snapGeomId?: string;
    // @internal (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toolId: string;
    // @internal (undocumented)
    protected _totalDistance: number;
    // @internal (undocumented)
    protected _totalDistanceMarker?: MeasureLabel;
    // @internal (undocumented)
    protected updateSelectedMarkerToolTip(seg: any, ev: BeButtonEvent, reopenToolTip: boolean): Promise<void>;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @public
export abstract class MeasureElementTool extends PrimitiveTool {
    // @internal (undocumented)
    protected readonly _acceptedIds: Id64Array;
    // @internal (undocumented)
    protected readonly _acceptedMeasurements: MeasureMarker[];
    // @internal (undocumented)
    protected allowView(vp: Viewport): boolean;
    // @internal (undocumented)
    protected readonly _checkedIds: Map<string, MassPropertiesResponseProps>;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // @internal (undocumented)
    doMeasureSelectedElements(viewport: Viewport): Promise<void>;
    // @internal (undocumented)
    filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    protected getMarkerToolTip(responseProps: MassPropertiesResponseProps): Promise<HTMLElement>;
    // (undocumented)
    protected abstract getOperation(): MassPropertiesOperation;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    onCleanup(): Promise<void>;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    onReinitialize(): Promise<void>;
    // @internal (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    protected reportMeasurements(): void;
    // @internal (undocumented)
    requireWriteableTarget(): boolean;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // @internal (undocumented)
    protected _totalMarker?: MeasureLabel;
    // @internal (undocumented)
    protected _totalValue: number;
    // (undocumented)
    protected updateTotals(selectionSetResult?: MassPropertiesResponseProps): Promise<void>;
    // @internal (undocumented)
    protected _useSelection: boolean;
}

// @public
export class MeasureLengthTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export class MeasureLocationTool extends PrimitiveTool {
    // @internal (undocumented)
    protected readonly _acceptedLocations: MeasureMarker[];
    // @internal (undocumented)
    protected allowView(vp: Viewport): boolean;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getMarkerToolTip(point: Point3d): Promise<HTMLElement>;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    protected reportMeasurements(): void;
    // @internal (undocumented)
    requireWriteableTarget(): boolean;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class MeasureVolumeTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export enum MessageBoxIconType {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Information = 1,
    // (undocumented)
    NoSymbol = 0,
    // (undocumented)
    Question = 2,
    // (undocumented)
    Success = 5,
    // (undocumented)
    Warning = 3
}

// @public
export enum MessageBoxType {
    // (undocumented)
    LargeOk = 2,
    // (undocumented)
    MediumAlert = 3,
    // (undocumented)
    Ok = 1,
    // (undocumented)
    OkCancel = 0,
    // (undocumented)
    YesNo = 5,
    // (undocumented)
    YesNoCancel = 4
}

// @public
export enum MessageBoxValue {
    // (undocumented)
    Apply = 1,
    // (undocumented)
    Cancel = 4,
    // (undocumented)
    Default = 5,
    // (undocumented)
    Help = 10,
    // (undocumented)
    No = 7,
    // (undocumented)
    NoToAll = 12,
    // (undocumented)
    Ok = 3,
    // (undocumented)
    Reset = 2,
    // (undocumented)
    Retry = 8,
    // (undocumented)
    Stop = 9,
    // (undocumented)
    Yes = 6,
    // (undocumented)
    YesToAll = 11
}

// @internal
export function metersToRange(inputMeters: number, minimumOutput?: number, maximumOutput?: number, maximumInputMeters?: number): number;

// @internal
export namespace MockRender {
    export class App {
        // (undocumented)
        protected static createDefaultRenderSystem(): System;
        // (undocumented)
        static shutdown(): Promise<void>;
        // (undocumented)
        static startup(opts?: IModelAppOptions): Promise<void>;
        // (undocumented)
        static systemFactory: SystemFactory;
    }
    // (undocumented)
    export class AreaPattern implements RenderAreaPattern {
        // (undocumented)
        collectStatistics(): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class Batch extends Graphic {
        constructor(graphic: RenderGraphic, featureTable: PackedFeatureTable, range: ElementAlignedBox3d);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        // (undocumented)
        readonly graphic: RenderGraphic;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
    }
    // (undocumented)
    export class Branch extends Graphic {
        constructor(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions | undefined);
        // (undocumented)
        readonly branch: GraphicBranch;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly options?: GraphicBranchOptions | undefined;
        // (undocumented)
        readonly transform: Transform;
    }
    // (undocumented)
    export class Builder extends PrimitiveBuilder {
        constructor(system: System, options: CustomGraphicBuilderOptions | ViewportGraphicBuilderOptions);
    }
    // (undocumented)
    export class Geometry implements RenderGeometry {
        // (undocumented)
        collectStatistics(): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class Graphic extends RenderGraphic {
        constructor();
        // (undocumented)
        collectStatistics(_stats: RenderMemory.Statistics): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class List extends Graphic {
        constructor(graphics: RenderGraphic[]);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly graphics: RenderGraphic[];
    }
    // (undocumented)
    export class OffScreenTarget extends Target {
        constructor(system: RenderSystem, _viewRect: ViewRect);
        // (undocumented)
        setViewRect(rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
    }
    // (undocumented)
    export class OnScreenTarget extends Target {
        constructor(system: RenderSystem, _canvas: HTMLCanvasElement);
        // (undocumented)
        setViewRect(_rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
    }
    // (undocumented)
    export class System extends RenderSystem {
        constructor();
        // (undocumented)
        createAreaPattern(): AreaPattern;
        // (undocumented)
        createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): Batch;
        // (undocumented)
        createGraphic(options: CustomGraphicBuilderOptions | ViewportGraphicBuilderOptions): Builder;
        // (undocumented)
        createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): Branch;
        // (undocumented)
        createGraphicList(primitives: RenderGraphic[]): List;
        // (undocumented)
        createMesh(_params: MeshParams): Graphic;
        // (undocumented)
        createMeshGeometry(): Geometry;
        // (undocumented)
        createOffscreenTarget(rect: ViewRect): RenderTarget;
        // (undocumented)
        createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): Graphic;
        // (undocumented)
        createPointString(_params: PointStringParams): Graphic;
        // (undocumented)
        createPointStringGeometry(): Geometry;
        // (undocumented)
        createPolyline(_params: PolylineParams): Graphic;
        // (undocumented)
        createPolylineGeometry(): Geometry;
        // (undocumented)
        createRenderGraphic(): Graphic;
        // (undocumented)
        createTarget(canvas: HTMLCanvasElement): OnScreenTarget;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        doIdleWork(): boolean;
        // (undocumented)
        get isValid(): boolean;
        // (undocumented)
        get maxTextureSize(): number;
    }
    // (undocumented)
    export type SystemFactory = () => RenderSystem;
    // (undocumented)
    export abstract class Target extends RenderTarget {
        protected constructor(_system: RenderSystem);
        // (undocumented)
        get analysisFraction(): number;
        set analysisFraction(_fraction: number);
        // (undocumented)
        changeDecorations(_decs: Decorations): void;
        // (undocumented)
        changeDynamics(_dynamics?: GraphicList): void;
        // (undocumented)
        changeRenderPlan(_plan: RenderPlan): void;
        // (undocumented)
        changeScene(_scene: Scene): void;
        // (undocumented)
        drawFrame(_sceneTime?: number): void;
        // (undocumented)
        readPixels(_rect: ViewRect, _selector: Pixel.Selector, receiver: Pixel.Receiver, _excludeNonLocatable: boolean): void;
        // (undocumented)
        get renderSystem(): RenderSystem;
        // (undocumented)
        get screenSpaceEffects(): Iterable<string>;
        set screenSpaceEffects(_effects: Iterable<string>);
        // (undocumented)
        updateViewRect(): boolean;
        // (undocumented)
        get wantInvertBlackBackground(): boolean;
    }
}

// @internal
export interface ModalOptions {
    autoClose?: boolean;
    closeBox?: boolean;
    rootDiv?: HTMLElement;
    width?: number;
}

// @internal
export interface ModalReturn {
    modal: HTMLDivElement;
    stop: (_ev: Event) => void;
}

// @beta
export interface ModelDisplayTransformProvider {
    getModelDisplayTransform(modelId: Id64String): Transform | undefined;
}

// @internal (undocumented)
export class ModelMapLayerTileTreeReference extends MapLayerTileTreeReference {
    constructor(layerSettings: MapLayerSettings, _classifier: SpatialClassifier, layerIndex: number, iModel: IModelConnection, _source?: DisplayStyleState | undefined);
    // (undocumented)
    get activeClassifier(): SpatialClassifier;
    // (undocumented)
    protected createTreeId(): PrimaryTileTreeId;
    // (undocumented)
    get isPlanar(): boolean;
    // (undocumented)
    get treeOwner(): TileTreeOwner;
    // (undocumented)
    get viewFlags(): Partial<ViewFlagsProperties>;
}

// @public
export class ModelSelectorState extends ElementState {
    constructor(props: ModelSelectorProps, iModel: IModelConnection);
    addModels(arg: Id64Arg): void;
    // @internal (undocumented)
    static get className(): string;
    containsModel(modelId: Id64String): boolean;
    dropModels(arg: Id64Arg): void;
    equalState(other: ModelSelectorState): boolean;
    has(id: string): boolean;
    load(): Promise<void>;
    get models(): Set<string>;
    set models(models: Set<string>);
    get name(): string;
    // @internal (undocumented)
    get observableModels(): ObservableSet<string>;
    // (undocumented)
    toJSON(): ModelSelectorProps;
}

// @public
export class ModelState extends EntityState implements ModelProps {
    constructor(props: ModelProps, iModel: IModelConnection, state?: ModelState);
    get asGeometricModel(): GeometricModelState | undefined;
    get asGeometricModel2d(): GeometricModel2dState | undefined;
    get asGeometricModel3d(): GeometricModel3dState | undefined;
    get asSpatialModel(): SpatialModelState | undefined;
    // @internal (undocumented)
    static get className(): string;
    // @internal
    getToolTip(_hit: HitDetail): HTMLElement | string | undefined;
    get isGeometricModel(): boolean;
    // (undocumented)
    readonly isPrivate: boolean;
    // (undocumented)
    readonly isTemplate: boolean;
    // (undocumented)
    readonly modeledElement: RelatedElement;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    parentModel: Id64String;
    toJSON(): ModelProps;
}

// @public
export type ModelSubCategoryHiliteMode = "union" | "intersection";

// @alpha (undocumented)
export enum ModifyElementSource {
    DragSelect = 3,
    Selected = 1,
    SelectionSet = 2,
    Unknown = 0
}

// @internal
export class MutableChangeFlags extends ChangeFlags {
    constructor(flags?: ChangeFlag);
    clear(flags?: ChangeFlag): void;
    // (undocumented)
    setAlwaysDrawn(): void;
    // (undocumented)
    setDisplayStyle(): void;
    // (undocumented)
    setFeatureOverrideProvider(): void;
    // (undocumented)
    setNeverDrawn(): void;
    // (undocumented)
    setViewedCategories(): void;
    // (undocumented)
    setViewedCategoriesPerModel(): void;
    // (undocumented)
    setViewedModels(): void;
    // (undocumented)
    setViewState(): void;
}

// @public
export class NativeApp {
    // @deprecated (undocumented)
    static callNativeHost<T extends AsyncMethodsOf<NativeAppFunctions>>(methodName: T, ...args: Parameters<NativeAppFunctions[T]>): Promise<PromiseReturnType<NativeAppFunctions[T]>>;
    static checkInternetConnectivity(): Promise<InternetConnectivityStatus>;
    static closeStorage(storage: Storage_2, deleteStorage?: boolean): Promise<void>;
    static deleteBriefcase(fileName: string): Promise<void>;
    static getBriefcaseFileName(props: BriefcaseProps): Promise<string>;
    static getCachedBriefcases(iModelId?: GuidString): Promise<LocalBriefcaseProps[]>;
    static getStorageNames(): Promise<string[]>;
    // (undocumented)
    static get isValid(): boolean;
    static nativeAppIpc: PickAsyncMethods<NativeAppFunctions>;
    static onInternetConnectivityChanged: BeEvent<(status: InternetConnectivityStatus) => void>;
    static openStorage(name: string): Promise<Storage_2>;
    // @internal (undocumented)
    static overrideInternetConnectivity(status: InternetConnectivityStatus): Promise<void>;
    // (undocumented)
    static requestDownloadBriefcase(iTwinId: string, iModelId: string, downloadOptions: DownloadBriefcaseOptions, asOf?: IModelVersion): Promise<BriefcaseDownloader>;
    // @deprecated (undocumented)
    static requestDownloadBriefcase(iTwinId: string, iModelId: string, downloadOptions: DownloadBriefcaseOptions, asOf?: IModelVersion, progress?: ProgressCallback): Promise<BriefcaseDownloader>;
    // @internal (undocumented)
    static shutdown(): Promise<void>;
    // @internal
    static startup(ipc: IpcSocketFrontend, opts?: NativeAppOpts): Promise<void>;
}

// @internal
export class NativeAppLogger {
    // (undocumented)
    static flush(): Promise<void>;
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static logError(category: string, message: string, metaData: LoggingMetaData): void;
    // (undocumented)
    static logInfo(category: string, message: string, metaData: LoggingMetaData): void;
    // (undocumented)
    static logTrace(category: string, message: string, metaData: LoggingMetaData): void;
    // (undocumented)
    static logWarning(category: string, message: string, metaData: LoggingMetaData): void;
}

// @public
export interface NativeAppOpts extends IpcAppOptions {
    // (undocumented)
    nativeApp?: {};
}

// @internal
export class NoRenderApp {
    // (undocumented)
    static startup(opts?: IModelAppOptions): Promise<void>;
}

// @public
export abstract class NotificationHandler {
    abstract get channelName(): string;
    static register(): RemoveFunction;
    // (undocumented)
    registerImpl(): RemoveFunction;
}

// @public
export class NotificationManager implements MessagePresenter {
    clearToolTip(): void;
    closeInputFieldMessage(): void;
    closePointerMessage(): void;
    displayInputFieldMessage(inputField: HTMLElement, severity: MessageSeverity, briefMessage: HTMLElement | string, detailedMessage?: HTMLElement | string): void;
    displayMessage(severity: MessageSeverity, briefMessage: HTMLElement | string, detailedMessage?: HTMLElement | string, messageType?: DisplayMessageType): void;
    endActivityMessage(_reason: ActivityMessageEndReason): boolean;
    get isToolTipOpen(): boolean;
    get isToolTipSupported(): boolean;
    openMessageBox(_mbType: MessageBoxType, _message: HTMLElement | string, _icon: MessageBoxIconType): Promise<MessageBoxValue>;
    openToolTip(htmlElement: HTMLElement, message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    outputActivityMessage(_messageText: HTMLElement | string, _percentComplete: number): boolean;
    outputMessage(_message: NotifyMessageDetails): void;
    outputPrompt(_prompt: string): void;
    outputPromptByKey(key: string): void;
    setToolAssistance(instructions: ToolAssistanceInstructions | undefined): void;
    setupActivityMessage(_details: ActivityMessageDetails): boolean;
    protected _showToolTip(_htmlElement: HTMLElement, _message: HTMLElement | string, _location?: XAndY, _options?: ToolTipOptions): void;
    // (undocumented)
    readonly toolTipLocation: Point2d;
    updatePointerMessage(_displayPoint: XAndY, _relativePosition?: RelativePosition): void;
}

// @public
export class NotifyMessageDetails {
    constructor(priority: OutputMessagePriority, briefMessage: HTMLElement | string, detailedMessage?: string | HTMLElement | undefined, msgType?: OutputMessageType, openAlert?: OutputMessageAlert);
    // (undocumented)
    briefMessage: HTMLElement | string;
    // (undocumented)
    detailedMessage?: string | HTMLElement | undefined;
    // (undocumented)
    displayPoint?: Point2d;
    // (undocumented)
    displayTime: BeDuration;
    // (undocumented)
    inputField?: HTMLElement;
    // (undocumented)
    msgType: OutputMessageType;
    // (undocumented)
    openAlert: OutputMessageAlert;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    relativePosition: RelativePosition;
    setInputFieldTypeDetails(inputField: HTMLElement): void;
    setPointerTypeDetails(viewport: HTMLElement, displayPoint: XAndY, relativePosition?: RelativePosition): void;
    // (undocumented)
    viewport?: HTMLElement;
}

// @internal
export class NullRenderSystem extends RenderSystem {
    constructor();
    // (undocumented)
    createBatch(): any;
    // (undocumented)
    createGraphic(): any;
    // (undocumented)
    createGraphicBranch(): any;
    // (undocumented)
    createGraphicList(): any;
    // (undocumented)
    createOffscreenTarget(): NullTarget;
    // (undocumented)
    createRenderGraphic(): undefined;
    // (undocumented)
    createTarget(): NullTarget;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doIdleWork(): boolean;
    // (undocumented)
    get isValid(): boolean;
}

// @internal
export class NullTarget extends RenderTarget {
    // (undocumented)
    get analysisFraction(): number;
    set analysisFraction(_fraction: number);
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_branches: AnimationBranchStates | undefined);
    // (undocumented)
    changeDecorations(): void;
    // (undocumented)
    changeDynamics(): void;
    // (undocumented)
    changeRenderPlan(): void;
    // (undocumented)
    changeScene(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawFrame(_sceneMilSecElapsed?: number): void;
    // (undocumented)
    onDestroy(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(): void;
    // (undocumented)
    readPixels(): void;
    // (undocumented)
    get renderSystem(): any;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(_effects: Iterable<string>);
    // (undocumented)
    setFlashed(): void;
    // (undocumented)
    setHiliteSet(): void;
    // (undocumented)
    setViewRect(): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
}

// @internal (undocumented)
export class OffScreenTarget extends Target {
    constructor(rect: ViewRect);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(fbo: FrameBuffer): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setViewRect(rect: ViewRect, temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
}

// @public
export class OffScreenViewport extends Viewport {
    // (undocumented)
    static create(options: OffScreenViewportOptions): OffScreenViewport;
    // @internal
    static createViewport(view: ViewState, target: RenderTarget, lockAspectRatio?: boolean): OffScreenViewport;
    // @internal
    get drawingToSheetTransform(): Transform | undefined;
    set drawingToSheetTransform(transform: Transform | undefined);
    // @internal (undocumented)
    get isAspectRatioLocked(): boolean;
    // (undocumented)
    protected _isAspectRatioLocked: boolean;
    setRect(rect: ViewRect): void;
    // @internal (undocumented)
    get viewRect(): ViewRect;
}

// @public
export interface OffScreenViewportOptions {
    lockAspectRatio?: boolean;
    view: ViewState;
    viewRect: ViewRect;
}

// @internal
export interface OldTextureImage {
    format: ImageSourceFormat;
    image: HTMLImageElement;
}

// @public
export type OnDownloadProgress = (progress: DownloadProgressInfo) => void;

// @public
export type OnFlashedIdChangedEventArgs = {
    readonly current: Id64String;
    readonly previous: Id64String;
} | {
    readonly current: Id64String;
    readonly previous: undefined;
} | {
    readonly previous: Id64String;
    readonly current: undefined;
};

// @alpha
export type OnFrameStatsReadyEvent = BeEvent<(frameStats: Readonly<FrameStats>) => void>;

// @internal
export class OnScreenTarget extends Target {
    constructor(canvas: HTMLCanvasElement);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(fbo: FrameBuffer): void;
    checkFboDimensions(): boolean;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    get devicePixelRatioOverride(): number | undefined;
    set devicePixelRatioOverride(ovr: number | undefined);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    pickOverlayDecoration(pt: XAndY): CanvasDecoration | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setRenderToScreen(toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    setViewRect(_rect: ViewRect, _temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
}

// @public
export interface OnViewExtentsError {
    onExtentsError?: (status: ViewStatus) => ViewStatus;
}

// @internal
export class OPCFormatInterpreter {
    static getFileReaderFromBlobFileURL(blobFileURL: string): Promise<PointCloudReader>;
    static getSpatialLocationAndExtents(fileReader: PointCloudReader): Promise<SpatialLocationAndExtents>;
}

// @beta
export function openImageDataUrlInNewWindow(url: string, title?: string): void;

// @internal (undocumented)
export class OrbitGtTileTree extends TileTree {
    constructor(treeParams: TileTreeParams, _dataManager: OrbitGtDataManager, cloudRange: Range3d, _centerOffset: Vector3d, _ecefTransform: Transform);
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(args: TileDrawArgs): void;
    // (undocumented)
    getEcefTransform(): Promise<Transform | undefined>;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    get maxDepth(): number | undefined;
    // (undocumented)
    prune(): void;
    // (undocumented)
    rootTile: OrbitGtRootTile;
    // (undocumented)
    protected _selectTiles(_args: TileDrawArgs): Tile[];
    // (undocumented)
    viewFlagOverrides: ViewFlagOverrides;
}

// @internal (undocumented)
export namespace OrbitGtTileTree {
    // (undocumented)
    export function createOrbitGtTileTree(rdSourceKey: RealityDataSourceKey, iModel: IModelConnection, modelId: Id64String): Promise<TileTree | undefined>;
    // (undocumented)
    export interface ReferenceProps extends RealityModelTileTree.ReferenceBaseProps {
        // (undocumented)
        modelId?: Id64String;
        // (undocumented)
        orbitGtBlob?: OrbitGtBlobProps;
    }
}

// @public
export class OrthographicViewState extends SpatialViewState {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    supportsCamera(): boolean;
}

// @public
export interface OsmBuildingDisplayOptions {
    appearanceOverrides?: FeatureAppearance;
    onOff?: boolean;
}

// @public
export enum OutputMessageAlert {
    // (undocumented)
    Balloon = 2,
    // (undocumented)
    Dialog = 1,
    // (undocumented)
    None = 0
}

// @public
export enum OutputMessagePriority {
    // (undocumented)
    Debug = 13,
    // (undocumented)
    Error = 10,
    // (undocumented)
    Fatal = 17,
    // (undocumented)
    Info = 12,
    // (undocumented)
    None = 0,
    // (undocumented)
    Success = 1,
    // (undocumented)
    Warning = 11
}

// @public
export enum OutputMessageType {
    Alert = 4,
    InputField = 3,
    Pointer = 1,
    Sticky = 2,
    Toast = 0
}

// @public
export interface OverrideFormatEntry {
    imperial?: FormatProps;
    metric?: FormatProps;
    usCustomary?: FormatProps;
    usSurvey?: FormatProps;
}

// @internal
export function overrideRequestTileTreeProps(func: RequestTileTreePropsFunc | undefined): void;

// @public
export interface PaddingPercent {
    // (undocumented)
    bottom?: number;
    // (undocumented)
    left?: number;
    // (undocumented)
    right?: number;
    // (undocumented)
    top?: number;
}

// @public
export class PanViewTool extends ViewManip {
    constructor(vp: ScreenViewport | undefined, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export enum ParseAndRunResult {
    BadArgumentCount = 2,
    FailedToRun = 3,
    MismatchedQuotes = 4,
    Success = 0,
    ToolNotFound = 1
}

// @public
export interface ParsedKeyin {
    args: string[];
    ok: true;
    tool: ToolType;
}

// @public
export interface ParseKeyinError {
    error: KeyinParseError;
    ok: false;
}

// @public
export type ParseKeyinResult = ParsedKeyin | ParseKeyinError;

// @public
export interface ParticleCollectionBuilder {
    addParticle: (particle: ParticleProps) => void;
    finish: () => RenderGraphic | undefined;
    size: XAndY;
    transparency: number;
}

// @public (undocumented)
export namespace ParticleCollectionBuilder {
    export function create(params: ParticleCollectionBuilderParams): ParticleCollectionBuilder;
}

// @public
export interface ParticleCollectionBuilderParams {
    isViewCoords?: boolean;
    origin?: XYAndZ;
    pickableId?: Id64String;
    size: XAndY | number;
    texture: RenderTexture;
    transparency?: number;
    viewport: Viewport;
}

// @public
export interface ParticleProps extends XYAndZ {
    rotationMatrix?: Matrix3d;
    size?: XAndY | number;
    transparency?: number;
}

// @internal
export interface PatternGraphicParams {
    // (undocumented)
    readonly featureId?: number;
    // (undocumented)
    readonly orgTransform: Transform;
    // (undocumented)
    readonly origin: Point2d;
    readonly patternToModel: Transform;
    readonly range: Range3d;
    // (undocumented)
    readonly scale: number;
    // (undocumented)
    readonly spacing: Point2d;
    // (undocumented)
    readonly symbolTranslation: Point3d;
    // (undocumented)
    readonly viewIndependentOrigin?: Point3d;
    // (undocumented)
    readonly xyOffsets: Float32Array;
}

// @internal (undocumented)
export class PerformanceMetrics {
    constructor(gatherGlFinish?: boolean, gatherCurPerformanceMetrics?: boolean, gpuResults?: GLTimerResultCallback);
    // (undocumented)
    beginFrame(sceneTime?: number): void;
    // (undocumented)
    beginOperation(operationName: string): void;
    // (undocumented)
    completeFrameTimings(fbo: FrameBuffer): void;
    // (undocumented)
    curSpfTimeIndex: number;
    // (undocumented)
    endFrame(): void;
    // (undocumented)
    endOperation(): void;
    // (undocumented)
    fpsTimer: StopWatch;
    // (undocumented)
    fpsTimerStart: number;
    // (undocumented)
    frameTimings: Map<string, number>;
    // (undocumented)
    gatherCurPerformanceMetrics: boolean;
    // (undocumented)
    gatherGlFinish: boolean;
    // (undocumented)
    spfSum: number;
    // (undocumented)
    spfTimes: number[];
}

// @public
export namespace PerModelCategoryVisibility {
    // (undocumented)
    export function createOverrides(viewport: Viewport): PerModelCategoryVisibility.Overrides;
    export enum Override {
        Hide = 2,
        None = 0,
        Show = 1
    }
    export interface OverrideEntry {
        readonly categoryId: Id64String;
        readonly modelId: Id64String;
        readonly visible: boolean;
    }
    export interface Overrides {
        [Symbol.iterator]: () => Iterator<OverrideEntry>;
        addOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
        clearOverrides(modelIds?: Id64Arg): void;
        getOverride(modelId: Id64String, categoryId: Id64String): Override;
        setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: Override): void;
        // @beta
        setOverrides(perModelCategoryVisibility: Props[], iModel?: IModelConnection): Promise<void>;
    }
    // @beta
    export interface Props {
        categoryIds: Iterable<Id64String>;
        modelId: string;
        visOverride: PerModelCategoryVisibility.Override;
    }
}

// @public
export class PhysicalModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export interface PickableGraphicOptions extends BatchOptions {
    geometryClass?: GeometryClass;
    id: Id64String;
    modelId?: Id64String;
    subCategoryId?: Id64String;
}

// @internal
export interface PingTestResult {
    avg: number | undefined;
    max: number | undefined;
    min: number | undefined;
}

// @public
export namespace Pixel {
    export interface Buffer {
        getPixel(x: number, y: number): Data;
    }
    export class Data {
        // @internal
        constructor(feature?: Feature, distanceFraction?: number, type?: GeometryType, planarity?: Planarity, featureTable?: PackedFeatureTable, iModel?: IModelConnection, tileId?: string);
        readonly distanceFraction: number;
        get elementId(): Id64String | undefined;
        readonly feature?: Feature;
        // @internal (undocumented)
        readonly featureTable?: PackedFeatureTable;
        get geometryClass(): GeometryClass | undefined;
        readonly iModel?: IModelConnection;
        // @internal (undocumented)
        get isClassifier(): boolean;
        readonly planarity: Planarity;
        get subCategoryId(): Id64String | undefined;
        // @internal (undocumented)
        readonly tileId?: string;
        readonly type: GeometryType;
    }
    export enum GeometryType {
        Edge = 4,
        Linear = 3,
        None = 1,
        Silhouette = 5,
        Surface = 2,
        Unknown = 0
    }
    export enum Planarity {
        None = 1,
        NonPlanar = 3,
        Planar = 2,
        Unknown = 0
    }
    export type Receiver = (pixels: Buffer | undefined) => void;
    export enum Selector {
        All = 5,
        Feature = 1,
        GeometryAndDistance = 4,
        // (undocumented)
        None = 0
    }
}

// @internal (undocumented)
export type PlanarClassifierMap = Map<string, RenderPlanarClassifier>;

// @internal (undocumented)
export interface PlanarClassifierTarget {
    // (undocumented)
    isPointCloud: boolean;
    // (undocumented)
    location: Transform;
    // (undocumented)
    modelId: Id64String;
    // (undocumented)
    tiles: Tile[];
}

// @beta
export class PlanarClipMaskState {
    // (undocumented)
    static create(settings: PlanarClipMaskSettings): PlanarClipMaskState;
    // (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    static fromJSON(props: PlanarClipMaskProps): PlanarClipMaskState;
    // (undocumented)
    getPlanarClipMaskSymbologyOverrides(): FeatureSymbology.Overrides | undefined;
    // (undocumented)
    getTileTrees(view: ViewState3d, classifiedModelId: Id64String): TileTreeReference[] | undefined;
    // (undocumented)
    readonly settings: PlanarClipMaskSettings;
}

// @alpha
export interface PlanarGridProps {
    color: ColorDef;
    gridsPerRef: number;
    origin: Point3d;
    rMatrix: Matrix3d;
    spacing: XAndY;
    transparency?: PlanarGridTransparency;
}

// @alpha
export class PlanarGridTransparency {
    readonly lineTransparency = 0.75;
    readonly planeTransparency = 0.9;
    readonly refTransparency = 0.5;
}

// @internal (undocumented)
export class PlanarTilePatch {
    constructor(corners: Point3d[], normal: Vector3d, _chordHeight: number);
    // (undocumented)
    corners: Point3d[];
    // (undocumented)
    getClipShape(): Point3d[];
    // (undocumented)
    getRangeCorners(heightRange: Range1d, result: Point3d[]): Point3d[];
    // (undocumented)
    normal: Vector3d;
}

// @beta
export interface PreferenceArg extends PreferenceKeyArg {
    // (undocumented)
    readonly content?: any;
}

// @beta
export interface PreferenceKeyArg {
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly namespace?: string;
}

// @public
export abstract class PrimitiveTool extends InteractiveTool {
    autoLockTarget(): void;
    get briefcase(): BriefcaseConnection | undefined;
    // (undocumented)
    exitTool(): Promise<void>;
    getPrompt(): string;
    get iModel(): IModelConnection;
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    onRedoPreviousStep(): Promise<boolean>;
    onReinitialize(): Promise<void>;
    abstract onRestartTool(): Promise<void>;
    onSelectedViewportChanged(_previous: Viewport | undefined, current: Viewport | undefined): Promise<void>;
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    redoPreviousStep(): Promise<boolean>;
    requireWriteableTarget(): boolean;
    run(..._args: any[]): Promise<boolean>;
    saveChanges(): Promise<void>;
    // (undocumented)
    targetIsLocked: boolean;
    // (undocumented)
    get targetModelId(): string | undefined;
    set targetModelId(v: string | undefined);
    targetView?: Viewport;
    // @internal (undocumented)
    undoPreviousStep(): Promise<boolean>;
}

// @internal
export enum PrimitiveVisibility {
    All = 0,
    Instanced = 1,
    Uninstanced = 2
}

// @alpha
export interface PublisherProductInfo {
    engine: string;
    product: string;
    version: string;
}

// @public
export interface PullChangesOptions {
    // @beta
    abortSignal?: GenericAbortSignal;
    downloadProgressCallback?: OnDownloadProgress;
    // @deprecated
    progressCallback?: ProgressCallback;
    progressInterval?: number;
}

// @beta
export class QuadId {
    constructor(level: number, column: number, row: number);
    bordersNorthPole(mapTilingScheme: MapTilingScheme): boolean;
    bordersSouthPole(mapTilingScheme: MapTilingScheme): boolean;
    column: number;
    compare(other: QuadId): number;
    // @alpha (undocumented)
    get contentId(): string;
    // @alpha (undocumented)
    static createFromContentId(stringId: string): QuadId;
    // @alpha (undocumented)
    get debugString(): string;
    // @alpha (undocumented)
    getAngleSweep(mapTilingScheme: MapTilingScheme): {
        longitude: AngleSweep;
        latitude: AngleSweep;
    };
    getChildIds(columnCount?: number, rowCount?: number): QuadId[];
    getLatLongRangeDegrees(mapTilingScheme: MapTilingScheme): Range2d;
    getLatLongRangeRadians(mapTilingScheme: MapTilingScheme): Range2d;
    // @alpha (undocumented)
    static getTileContentId(level: number, column: number, row: number): string;
    // @alpha (undocumented)
    get isValid(): boolean;
    level: number;
    row: number;
}

// @public
export interface QuantityFormatOverridesChangedArgs {
    readonly overrideEntry?: OverrideFormatEntry;
    readonly typeKey: QuantityTypeKey;
    readonly unitSystem?: UnitSystemKey;
}

// @public
export interface QuantityFormatsChangedArgs {
    readonly quantityType: string;
}

// @public
export class QuantityFormatter implements UnitsProvider {
    constructor(showMetricOrUnitSystem?: boolean | UnitSystemKey);
    protected _activeFormatSpecsByType: Map<string, FormatterSpec>;
    protected _activeParserSpecsByType: Map<string, ParserSpec>;
    get activeUnitSystem(): UnitSystemKey;
    protected _activeUnitSystem: UnitSystemKey;
    addAlternateLabels(key: UnitNameKey, ...labels: string[]): void;
    get alternateUnitLabelsProvider(): AlternateUnitLabelsProvider;
    clearAllOverrideFormats(): Promise<void>;
    clearOverrideFormats(type: QuantityTypeArg): Promise<void>;
    findFormatterSpecByQuantityType(type: QuantityTypeArg, _unused?: boolean): FormatterSpec | undefined;
    findParserSpecByQuantityType(type: QuantityTypeArg): ParserSpec | undefined;
    findUnit(unitLabel: string, schemaName?: string, phenomenon?: string, unitSystem?: string): Promise<UnitProps>;
    findUnitByName(unitName: string): Promise<UnitProps>;
    formatQuantity(magnitude: number, formatSpec: FormatterSpec | undefined): string;
    generateFormatterSpecByType(type: QuantityTypeArg, formatProps: FormatProps): Promise<FormatterSpec>;
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion>;
    getFormatPropsByQuantityType(quantityType: QuantityTypeArg, requestedSystem?: UnitSystemKey, ignoreOverrides?: boolean): FormatProps | undefined;
    getFormatterSpecByQuantityType(type: QuantityTypeArg, isImperial?: boolean): Promise<FormatterSpec | undefined>;
    getFormatterSpecByQuantityTypeAndSystem(type: QuantityTypeArg, system?: UnitSystemKey): Promise<FormatterSpec | undefined>;
    getParserSpecByQuantityType(type: QuantityTypeArg, isImperial?: boolean): Promise<ParserSpec | undefined>;
    getParserSpecByQuantityTypeAndSystem(type: QuantityTypeArg, system?: UnitSystemKey): Promise<ParserSpec | undefined>;
    getQuantityDefinition(type: QuantityTypeArg): QuantityTypeDefinition | undefined;
    getQuantityTypeKey(type: QuantityTypeArg): string;
    getUnitsByFamily(phenomenon: string): Promise<UnitProps[]>;
    getUnitSystemFromString(inputSystem: string, fallback?: UnitSystemKey): UnitSystemKey;
    hasActiveOverride(type: QuantityTypeArg, checkOnlyActiveUnitSystem?: boolean): boolean;
    protected initializeQuantityTypesRegistry(): Promise<void>;
    // @internal
    protected loadFormatAndParsingMapsForSystem(systemType?: UnitSystemKey): Promise<void>;
    readonly onActiveFormattingUnitSystemChanged: BeUiEvent<FormattingUnitSystemChangedArgs>;
    // @internal
    onInitialized(): Promise<void>;
    readonly onQuantityFormatsChanged: BeUiEvent<QuantityFormatsChangedArgs>;
    readonly onUnitsProviderChanged: BeUiEvent<void>;
    protected _overrideFormatPropsByUnitSystem: Map<UnitSystemKey, Map<string, FormatProps>>;
    parseToQuantityValue(inString: string, parserSpec: ParserSpec | undefined): QuantityParseResult;
    protected _quantityTypeRegistry: Map<QuantityTypeKey, QuantityTypeDefinition>;
    get quantityTypesRegistry(): Map<string, QuantityTypeDefinition>;
    registerQuantityType(entry: CustomQuantityTypeDefinition, replace?: boolean): Promise<boolean>;
    reinitializeFormatAndParsingsMaps(overrideFormatPropsByUnitSystem: Map<UnitSystemKey, Map<QuantityTypeKey, FormatProps>>, unitSystemKey?: UnitSystemKey, fireUnitSystemChanged?: boolean, startDefaultTool?: boolean): Promise<void>;
    resetToUseInternalUnitsProvider(): Promise<void>;
    setActiveUnitSystem(isImperialOrUnitSystem: UnitSystemKey | boolean, restartActiveTool?: boolean): Promise<void>;
    setOverrideFormat(type: QuantityTypeArg, overrideFormat: FormatProps): Promise<void>;
    setOverrideFormats(type: QuantityTypeArg, overrideEntry: OverrideFormatEntry): Promise<void>;
    setUnitFormattingSettingsProvider(provider: UnitFormattingSettingsProvider): Promise<void>;
    setUnitsProvider(unitsProvider: UnitsProvider): Promise<void>;
    protected _unitFormattingSettingsProvider: UnitFormattingSettingsProvider | undefined;
    get unitsProvider(): UnitsProvider;
    set unitsProvider(unitsProvider: UnitsProvider);
}

// @public
export enum QuantityType {
    Angle = 2,
    Area = 3,
    Coordinate = 6,
    LatLong = 5,
    Length = 1,
    LengthEngineering = 9,
    LengthSurvey = 8,
    Stationing = 7,
    Volume = 4
}

// @public
export type QuantityTypeArg = QuantityType | string;

// @public
export interface QuantityTypeDefinition {
    description: string;
    generateFormatterSpec: (formatProps: FormatProps, unitsProvider: UnitsProvider) => Promise<FormatterSpec>;
    generateParserSpec: (formatProps: FormatProps, unitsProvider: UnitsProvider, alternateUnitLabelsProvider?: AlternateUnitLabelsProvider) => Promise<ParserSpec>;
    // (undocumented)
    getDefaultFormatPropsBySystem: (requestedSystem: UnitSystemKey) => FormatProps;
    readonly key: QuantityTypeKey;
    label: string;
    readonly persistenceUnit: UnitProps;
    readonly type: QuantityTypeArg;
}

// @public
export type QuantityTypeKey = string;

// @public
export interface QueryScreenFeaturesOptions {
    includeNonLocatable?: boolean;
    rect?: ViewRect;
    source: "screen";
}

// @public
export function queryTerrainElevationOffset(viewport: ScreenViewport, carto: Cartographic): Promise<number>;

// @public
export interface QueryTileFeaturesOptions {
    includeNonLocatable?: boolean;
    source: "tiles";
}

// @internal
export function queryVisibleFeatures(viewport: Viewport, options: QueryVisibleFeaturesOptions, callback: QueryVisibleFeaturesCallback): void;

// @public
export type QueryVisibleFeaturesCallback = (features: Iterable<VisibleFeature>) => void;

// @public
export type QueryVisibleFeaturesOptions = QueryScreenFeaturesOptions | QueryTileFeaturesOptions;

// @internal
export function rangeToCartographicArea(view3d: ViewState3d, range: Range3d): GlobalLocationArea | undefined;

// @public
export function readElementGraphics(bytes: Uint8Array, iModel: IModelConnection, modelId: Id64String, is3d: boolean, options?: BatchOptions | false): Promise<RenderGraphic | undefined>;

// @public
export function readGltfGraphics(args: ReadGltfGraphicsArgs): Promise<RenderGraphic | undefined>;

// @public
export interface ReadGltfGraphicsArgs {
    baseUrl?: string;
    // @alpha (undocumented)
    contentRange?: ElementAlignedBox3d;
    gltf: Uint8Array | Object;
    // @alpha (undocumented)
    hasChildren?: boolean;
    iModel: IModelConnection;
    pickableOptions?: PickableGraphicOptions;
    // @alpha (undocumented)
    transform?: Transform;
}

// @public
export interface ReadImageBufferArgs {
    rect?: ViewRect;
    size?: XAndY;
    upsideDown?: boolean;
}

// @beta
export interface ReadMeshArgs {
    data: any;
    isCanceled(): boolean;
    tile: MapTile;
}

// @internal
export class ReadonlyTileUserSet extends ReadonlySortedArray<TileUser> {
    constructor(user?: TileUser);
}

// @internal
export function readPointCloudTileContent(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, _is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem): Promise<RenderGraphic | undefined>;

// @alpha
export class RealityDataError extends BentleyError {
    constructor(errorNumber: RealityDataStatus, message: string, getMetaData?: LoggingMetaData);
}

// @beta
export interface RealityDataSource {
    // @alpha
    getPublisherProductInfo(): Promise<PublisherProductInfo | undefined>;
    // @internal
    getRootDocument(iTwinId: GuidString | undefined): Promise<any>;
    getServiceUrl(iTwinId: GuidString | undefined): Promise<string | undefined>;
    // @alpha
    getSpatialLocationAndExtents(): Promise<SpatialLocationAndExtents | undefined>;
    // @internal
    getTileContent(name: string): Promise<any>;
    // @alpha
    getTileContentType(url: string): "tile" | "tileset";
    // @internal
    getTileJson(name: string): Promise<any>;
    // (undocumented)
    readonly isContextShare: boolean;
    // (undocumented)
    readonly key: RealityDataSourceKey;
    // @alpha
    readonly maximumScreenSpaceError?: number;
    readonly realityData: RealityData | undefined;
    // (undocumented)
    readonly realityDataId: string | undefined;
    readonly realityDataType: string | undefined;
    // @alpha
    readonly usesGeometricError?: boolean;
}

// @beta
export namespace RealityDataSource {
    // @internal
    export function createCesiumIonAssetKey(osmAssetId: number, requestKey: string): RealityDataSourceKey;
    // @alpha
    export function createKeyFromBlobUrl(blobUrl: string, inputProvider?: RealityDataProvider, inputFormat?: RealityDataFormat): RealityDataSourceKey;
    // @alpha
    export function createKeyFromOrbitGtBlobProps(orbitGtBlob: OrbitGtBlobProps, inputProvider?: RealityDataProvider, inputFormat?: RealityDataFormat): RealityDataSourceKey;
    export function createKeyFromUrl(tilesetUrl: string, inputProvider?: RealityDataProvider, inputFormat?: RealityDataFormat): RealityDataSourceKey;
    // @alpha
    export function createOrbitGtBlobPropsFromKey(rdSourceKey: RealityDataSourceKey): OrbitGtBlobProps | undefined;
    // @alpha
    export function fromKey(key: RealityDataSourceKey, iTwinId: GuidString | undefined): Promise<RealityDataSource | undefined>;
}

// @alpha
export interface RealityDataSourceProvider {
    createRealityDataSource(key: RealityDataSourceKey, iTwinId: GuidString | undefined): Promise<RealityDataSource | undefined>;
}

// @alpha
export class RealityDataSourceProviderRegistry {
    // @internal
    constructor();
    find(name: string): RealityDataSourceProvider | undefined;
    register(name: string, provider: RealityDataSourceProvider): void;
}

// @internal (undocumented)
export interface RealityMeshGraphicParams {
    // (undocumented)
    readonly baseColor: ColorDef | undefined;
    // (undocumented)
    readonly baseTransparent: boolean;
    // (undocumented)
    readonly featureTable: PackedFeatureTable;
    // (undocumented)
    readonly layerClassifiers?: MapLayerClassifiers;
    // (undocumented)
    readonly projection: MapTileProjection;
    // (undocumented)
    readonly realityMesh: RenderTerrainGeometry;
    // (undocumented)
    readonly textures?: TerrainTexture[];
    // (undocumented)
    readonly tileId: string | undefined;
    // (undocumented)
    readonly tileRectangle: MapCartoRectangle;
}

// @beta
export interface RealityMeshParams {
    // @alpha
    featureID?: number;
    indices: UintArray;
    normals?: Uint16Array;
    positions: QPoint3dBuffer;
    // @alpha
    texture?: RenderTexture;
    uvs: QPoint2dBuffer;
}

// @beta (undocumented)
export namespace RealityMeshParams {
    // @internal (undocumented)
    export function fromGltfMesh(mesh: GltfMeshData): RealityMeshParams | undefined;
    // @alpha (undocumented)
    export function toPolyface(params: RealityMeshParams, options?: {
        transform?: Transform;
        wantNormals?: boolean;
        wantParams?: boolean;
    }): Polyface | undefined;
}

// @beta
export class RealityMeshParamsBuilder {
    constructor(options: RealityMeshParamsBuilderOptions);
    addIndices(indices: Iterable<number>): void;
    addQuad(i0: number, i1: number, i2: number, i3: number): void;
    addQuantizedVertex(position: XYAndZ, uv: XAndY, normal?: number): number;
    addTriangle(i0: number, i1: number, i2: number): void;
    addUnquantizedVertex(position: XYAndZ, uv: XAndY, normal?: XYAndZ): number;
    // @internal
    addVertex(position: XYAndZ, uv: XAndY, normal?: number): void;
    finish(): RealityMeshParams;
    readonly indices: UintArrayBuilder;
    normals?: Uint16ArrayBuilder;
    readonly positions: QPoint3dBufferBuilder;
    readonly uvs: QPoint2dBufferBuilder;
}

// @beta
export interface RealityMeshParamsBuilderOptions {
    initialIndexCapacity?: number;
    initialVertexCapacity?: number;
    positionRange: Range3d;
    uvRange?: Range2d;
    wantNormals?: boolean;
}

// @internal (undocumented)
export type RealityModelSource = ViewState | DisplayStyleState;

// @internal (undocumented)
export class RealityModelTileTree extends RealityTileTree {
    constructor(params: RealityTileTreeParams);
    // (undocumented)
    get isContentUnbounded(): boolean;
}

// @internal (undocumented)
export namespace RealityModelTileTree {
    // (undocumented)
    export function createRealityModelTileTree(rdSourceKey: RealityDataSourceKey, iModel: IModelConnection, modelId: Id64String, tilesetToDb: Transform | undefined, opts?: {
        deduplicateVertices?: boolean;
        produceGeometry?: boolean;
    }): Promise<TileTree | undefined>;
    // (undocumented)
    export abstract class Reference extends TileTreeReference {
        constructor(props: RealityModelTileTree.ReferenceBaseProps);
        // (undocumented)
        protected addPlanarClassifierOrMaskToScene(context: SceneContext): void;
        // (undocumented)
        addToScene(context: SceneContext): void;
        // (undocumented)
        protected _classifier?: SpatialClassifierTileTreeReference;
        // (undocumented)
        collectStatistics(stats: RenderMemory.Statistics): void;
        // (undocumented)
        createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
        // (undocumented)
        discloseTileTrees(trees: DisclosedTileTreeSet): void;
        // (undocumented)
        protected _getDisplaySettings: () => RealityModelDisplaySettings;
        // (undocumented)
        protected _iModel: IModelConnection;
        // (undocumented)
        get isGlobal(): boolean;
        // (undocumented)
        protected _mapDrapeTree?: TileTreeReference;
        // (undocumented)
        protected get maskModelIds(): string | undefined;
        // (undocumented)
        get modelId(): string;
        // (undocumented)
        protected readonly _name: string;
        // (undocumented)
        get planarClassifierTreeRef(): SpatialClassifierTileTreeReference | undefined;
        // (undocumented)
        get planarClipMask(): PlanarClipMaskState | undefined;
        set planarClipMask(planarClipMask: PlanarClipMaskState | undefined);
        // (undocumented)
        protected _planarClipMask?: PlanarClipMaskState;
        // (undocumented)
        get planarClipMaskPriority(): number;
        // (undocumented)
        protected readonly _source: RealityModelSource;
        // (undocumented)
        protected _transform?: Transform;
        // (undocumented)
        unionFitRange(union: Range3d): void;
    }
    // (undocumented)
    export interface ReferenceBaseProps {
        // (undocumented)
        classifiers?: SpatialClassifiers;
        // (undocumented)
        getDisplaySettings(): RealityModelDisplaySettings;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        modelId?: Id64String;
        // (undocumented)
        name?: string;
        // (undocumented)
        planarClipMask?: PlanarClipMaskSettings;
        // (undocumented)
        rdSourceKey: RealityDataSourceKey;
        // (undocumented)
        source: RealityModelSource;
        // (undocumented)
        tilesetToDbTransform?: TransformProps;
        // (undocumented)
        tilesetToEcefTransform?: TransformProps;
    }
    // (undocumented)
    export interface ReferenceProps extends ReferenceBaseProps {
        // (undocumented)
        produceGeometry?: boolean;
        // (undocumented)
        requestAuthorization?: string;
        // (undocumented)
        url?: string;
    }
}

// @internal (undocumented)
export class RealityModelTileUtils {
    // (undocumented)
    static maximumSizeFromGeometricTolerance(range: Range3d, geometricError: number): number;
    // (undocumented)
    static rangeFromBoundingVolume(boundingVolume: any): {
        range: Range3d;
        corners?: Point3d[];
        region?: RealityTileRegion;
    } | undefined;
    // (undocumented)
    static transformFromJson(jTrans: number[] | undefined): Transform;
}

// @beta
export class RealityTile extends Tile {
    // @internal
    constructor(props: RealityTileParams, tree: RealityTileTree);
    // @internal (undocumented)
    addBoundingGraphic(builder: GraphicBuilder, color: ColorDef): void;
    // @internal (undocumented)
    readonly additiveRefinement?: boolean;
    // @internal (undocumented)
    allChildrenIncluded(tiles: Tile[]): boolean;
    // @internal (undocumented)
    protected get _anyChildNotFound(): boolean;
    // @internal (undocumented)
    get channel(): TileRequestChannel;
    // @internal (undocumented)
    collectTileGeometry(collector: TileGeometryCollector): void;
    // @internal (undocumented)
    computeLoadPriority(viewports: Iterable<Viewport>, users: Iterable<TileUser>): number;
    // @internal (undocumented)
    computeVisibilityFactor(args: TileDrawArgs): number;
    // @internal (undocumented)
    disposeContents(): void;
    // @internal (undocumented)
    forceSelectRealityTile(): boolean;
    // @internal (undocumented)
    get geometry(): RealityTileGeometry | undefined;
    // @internal (undocumented)
    protected _geometry?: RealityTileGeometry;
    // @internal (undocumented)
    getContentClip(): ClipVector | undefined;
    // @internal (undocumented)
    protected getLoadedRealityChildren(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    getSizeProjectionCorners(): Point3d[] | undefined;
    // @internal (undocumented)
    get graphicType(): TileGraphicType | undefined;
    // @internal (undocumented)
    get isDisplayable(): boolean;
    // @internal (undocumented)
    get isLoaded(): boolean;
    // @internal (undocumented)
    isOccluded(_viewingSpace: ViewingSpace): boolean;
    // @internal (undocumented)
    get isPointCloud(): boolean;
    // @internal (undocumented)
    get isStepChild(): boolean;
    // @internal
    get loadableTile(): RealityTile;
    // @internal (undocumented)
    protected loadAdditiveRefinementChildren(resolve: (children: Tile[]) => void): void;
    // @internal (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, reject: (error: Error) => void): void;
    // @internal (undocumented)
    markDisplayed(): void;
    // @internal (undocumented)
    markUsed(args: TileDrawArgs): void;
    // @internal (undocumented)
    get maxDepth(): number;
    // @internal (undocumented)
    readonly noContentButTerminateOnSelection?: boolean;
    // @internal (undocumented)
    preloadRealityTilesAtDepth(depth: number, context: TraversalSelectionContext, args: TileDrawArgs): void;
    // @internal (undocumented)
    preloadTilesInFrustum(args: TileDrawArgs, context: TraversalSelectionContext, preloadSizeModifier: number): void;
    // @internal (undocumented)
    produceGraphics(): RenderGraphic | undefined;
    // @internal (undocumented)
    purgeContents(olderThan: BeTimePoint): void;
    // @internal (undocumented)
    readonly rangeCorners?: Point3d[];
    // @internal (undocumented)
    readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // @internal (undocumented)
    get realityChildren(): RealityTile[] | undefined;
    // @internal (undocumented)
    get realityParent(): RealityTile;
    // @internal (undocumented)
    get realityRoot(): RealityTileTree;
    // @internal (undocumented)
    readonly region?: RealityTileRegion;
    // @internal (undocumented)
    reproject(rootReprojection: Transform): void;
    // @internal (undocumented)
    protected _reprojectionTransform?: Transform;
    // @internal (undocumented)
    requestContent(isCanceled: () => boolean): Promise<TileRequest.Response>;
    // @internal (undocumented)
    protected selectRealityChildren(context: TraversalSelectionContext, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
    // @internal (undocumented)
    selectRealityTiles(context: TraversalSelectionContext, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
    // @internal
    selectSecondaryTiles(_args: TileDrawArgs, _context: TraversalSelectionContext): void;
    // @internal (undocumented)
    setContent(content: RealityTileContent): void;
    // @internal (undocumented)
    readonly transformToRoot?: Transform;
    // @internal (undocumented)
    get unprojectedGraphic(): RenderGraphic | undefined;
}

// @internal (undocumented)
export interface RealityTileContent extends TileContent {
    // (undocumented)
    geometry?: RealityTileGeometry;
}

// @internal (undocumented)
export class RealityTileDrawArgs extends TileDrawArgs {
    constructor(args: TileDrawArgs, worldToViewMap: Map4d, frustumPlanes: FrustumPlanes, maxSelectionCount?: number | undefined, _secondaryClassifiers?: Map<number, RenderPlanarClassifier> | undefined);
    // (undocumented)
    maxSelectionCount?: number | undefined;
    // (undocumented)
    get secondaryClassifiers(): Map<number, RenderPlanarClassifier> | undefined;
    // (undocumented)
    get worldToViewMap(): Map4d;
}

// @alpha
export interface RealityTileGeometry {
    // (undocumented)
    polyfaces?: Polyface[];
}

// @internal
export abstract class RealityTileLoader {
    constructor(_produceGeometry?: boolean | undefined);
    // (undocumented)
    protected get _batchType(): BatchType;
    // (undocumented)
    static computeTileLocationPriority(tile: Tile, viewports: Iterable<Viewport>, location: Transform): number;
    // (undocumented)
    computeTilePriority(tile: Tile, viewports: Iterable<Viewport>, _users: Iterable<TileUser>): number;
    // (undocumented)
    get containsPointClouds(): boolean;
    // (undocumented)
    forceTileLoad(_tile: Tile): boolean;
    // (undocumented)
    getBatchIdMap(): BatchedTileIdMap | undefined;
    // (undocumented)
    abstract getRequestChannel(tile: Tile): TileRequestChannel;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    abstract loadChildren(tile: RealityTile): Promise<Tile[] | undefined>;
    // (undocumented)
    protected get _loadEdges(): boolean;
    // (undocumented)
    loadGeometryFromStream(tile: RealityTile, streamBuffer: ByteStream, system: RenderSystem): Promise<RealityTileContent>;
    // (undocumented)
    loadTileContent(tile: Tile, data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<RealityTileContent>;
    // (undocumented)
    abstract get maxDepth(): number;
    // (undocumented)
    get maximumScreenSpaceError(): number | undefined;
    // (undocumented)
    abstract get minDepth(): number;
    // (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // (undocumented)
    readonly preloadRealityParentDepth: number;
    // (undocumented)
    readonly preloadRealityParentSkip: number;
    // (undocumented)
    abstract get priority(): TileLoadPriority;
    // (undocumented)
    processSelectedTiles(selected: Tile[], _args: TileDrawArgs): Tile[];
    // (undocumented)
    abstract requestTileContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
    // (undocumented)
    get wantDeduplicatedVertices(): boolean;
}

// @internal (undocumented)
export interface RealityTileParams extends TileParams {
    // (undocumented)
    readonly additiveRefinement?: boolean;
    // (undocumented)
    readonly geometricError?: number;
    // (undocumented)
    readonly noContentButTerminateOnSelection?: boolean;
    // (undocumented)
    readonly rangeCorners?: Point3d[];
    // (undocumented)
    readonly region?: RealityTileRegion;
    // (undocumented)
    readonly transformToRoot?: Transform;
}

// @internal (undocumented)
export class RealityTileRegion {
    constructor(values: {
        minLongitude: number;
        minLatitude: number;
        minHeight: number;
        maxLongitude: number;
        maxLatitude: number;
        maxHeight: number;
    });
    // (undocumented)
    static create(region: number[]): RealityTileRegion;
    // (undocumented)
    getRange(): {
        range: Range3d;
        corners?: Point3d[];
    };
    // (undocumented)
    static isGlobal(boundingVolume: any): boolean;
    // (undocumented)
    maxHeight: number;
    // (undocumented)
    maxLatitude: number;
    // (undocumented)
    maxLongitude: number;
    // (undocumented)
    minHeight: number;
    // (undocumented)
    minLatitude: number;
    // (undocumented)
    minLongitude: number;
}

// @beta
export class RealityTileTree extends TileTree {
    // @internal
    constructor(params: RealityTileTreeParams);
    // @internal (undocumented)
    cartesianRange: Range3d;
    // @internal (undocumented)
    cartesianTransitionDistance: number;
    // @internal (undocumented)
    protected collectClassifierGraphics(args: TileDrawArgs, selectedTiles: RealityTile[]): void;
    // @internal
    collectTileGeometry(collector: TileGeometryCollector): void;
    // @internal (undocumented)
    createTile(props: TileParams): RealityTile;
    // @internal (undocumented)
    doReprojectChildren(tile: Tile): boolean;
    // @internal (undocumented)
    draw(args: TileDrawArgs): void;
    // @internal (undocumented)
    protected _ecefToDb?: Transform;
    // @internal (undocumented)
    protected _gcsConverter: GeoConverter | undefined;
    // @internal (undocumented)
    getBaseRealityDepth(_sceneContext: SceneContext): number;
    // @internal (undocumented)
    getTraversalChildren(depth: number): TraversalChildrenDetails;
    // @internal (undocumented)
    get is3d(): boolean;
    // @internal (undocumented)
    get isContentUnbounded(): boolean;
    // @internal (undocumented)
    get isTransparent(): boolean;
    // @internal (undocumented)
    readonly loader: RealityTileLoader;
    // @internal (undocumented)
    protected logTiles(label: string, tiles: IterableIterator<Tile>): void;
    // @internal (undocumented)
    get maxDepth(): number;
    // @internal (undocumented)
    get minDepth(): number;
    // @internal (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // @internal (undocumented)
    preloadTilesForScene(args: TileDrawArgs, context: TraversalSelectionContext, frustumTransform?: Transform): void;
    // @internal (undocumented)
    prune(): void;
    // @internal
    reportTileVisibility(_args: TileDrawArgs, _selected: RealityTile[]): void;
    // @internal (undocumented)
    reprojectAndResolveChildren(parent: Tile, children: Tile[], resolve: (children: Tile[] | undefined) => void): void;
    // @internal (undocumented)
    get rootTile(): RealityTile;
    // @internal (undocumented)
    protected _rootTile: RealityTile;
    // @internal (undocumented)
    protected _rootToEcef?: Transform;
    // @internal (undocumented)
    selectRealityTiles(args: TileDrawArgs, displayedDescendants: RealityTile[][], preloadDebugBuilder?: GraphicBuilder): RealityTile[];
    // @internal (undocumented)
    protected _selectTiles(args: TileDrawArgs): Tile[];
    // @internal (undocumented)
    traversalChildrenByDepth: TraversalChildrenDetails[];
    // @internal (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
    // @internal (undocumented)
    readonly yAxisUp: boolean;
}

// @internal (undocumented)
export interface RealityTileTreeParams extends TileTreeParams {
    // (undocumented)
    readonly gcsConverterAvailable: boolean;
    // (undocumented)
    readonly loader: RealityTileLoader;
    // (undocumented)
    readonly rootTile: RealityTileParams;
    // (undocumented)
    readonly rootToEcef?: Transform;
    // (undocumented)
    readonly yAxisUp?: boolean;
}

// @internal
export class RealityTreeReference extends RealityModelTileTree.Reference {
    constructor(props: RealityModelTileTree.ReferenceProps);
    // (undocumented)
    addLogoCards(cards: HTMLTableElement): void;
    // (undocumented)
    addToScene(context: SceneContext): void;
    // (undocumented)
    get castsShadows(): boolean;
    // (undocumented)
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
    // (undocumented)
    protected _createGeometryTreeReference(): GeometryTileTreeReference;
    // (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string | undefined>;
    // (undocumented)
    protected get _isLoadingComplete(): boolean;
    // (undocumented)
    protected _rdSourceKey: RealityDataSourceKey;
    // (undocumented)
    get treeOwner(): TileTreeOwner;
}

// @alpha
export class RemoteExtensionProvider implements ExtensionProvider {
    constructor(_props: RemoteExtensionProviderProps);
    execute(): Promise<string>;
    getManifest(): Promise<ExtensionManifest>;
    readonly hostname: string;
}

// @alpha
export interface RemoteExtensionProviderProps {
    jsUrl: string;
    manifestUrl: string;
}

// @internal
export type RenderAreaPattern = IDisposable & RenderMemory.Consumer;

// @public
export abstract class RenderClipVolume {
    protected constructor(clipVector: ClipVector);
    readonly clipVector: ClipVector;
}

// @public
export class RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // @internal
    adjustPixelSizeForLOD(cssPixelSize: number): number;
    createBranch(branch: GraphicBranch, location: Transform): RenderGraphic;
    createGraphicBranch(branch: GraphicBranch, location: Transform, opts?: GraphicBranchOptions): RenderGraphic;
    // @internal (undocumented)
    protected _createGraphicBuilder(options: Omit<ViewportGraphicBuilderOptions, "viewport">): GraphicBuilder;
    createSceneGraphicBuilder(transform?: Transform): GraphicBuilder;
    readonly frustum: Frustum;
    readonly frustumPlanes: FrustumPlanes;
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    get renderSystem(): RenderSystem;
    // @internal (undocumented)
    get target(): RenderTarget;
    readonly viewFlags: ViewFlags;
    get viewport(): Viewport;
}

// @internal (undocumented)
export enum RenderDiagnostics {
    All = 6,
    DebugOutput = 2,
    None = 0,
    WebGL = 4
}

// @internal
export type RenderGeometry = IDisposable & RenderMemory.Consumer;

// @public
export abstract class RenderGraphic implements IDisposable {
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @public
export abstract class RenderGraphicOwner extends RenderGraphic {
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    dispose(): void;
    disposeGraphic(): void;
    abstract get graphic(): RenderGraphic;
}

// @internal
export interface RenderMaterialSource {
    // (undocumented)
    id: Id64String;
    // (undocumented)
    iModel: IModelConnection;
}

// @internal
export namespace RenderMemory {
    export class Buffers extends Consumers {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get indexedEdges(): Consumers;
        // (undocumented)
        get instances(): Consumers;
        // (undocumented)
        get pointClouds(): Consumers;
        // (undocumented)
        get pointStrings(): Consumers;
        // (undocumented)
        get polylineEdges(): Consumers;
        // (undocumented)
        get polylines(): Consumers;
        // (undocumented)
        get reality(): Consumers;
        // (undocumented)
        get silhouetteEdges(): Consumers;
        // (undocumented)
        get surfaces(): Consumers;
        // (undocumented)
        get terrain(): Consumers;
        // (undocumented)
        get visibleEdges(): Consumers;
    }
    // (undocumented)
    export enum BufferType {
        // (undocumented)
        COUNT = 11,
        // (undocumented)
        IndexedEdges = 4,
        // (undocumented)
        Instances = 8,
        // (undocumented)
        PointClouds = 7,
        // (undocumented)
        PointStrings = 6,
        // (undocumented)
        PolylineEdges = 3,
        // (undocumented)
        Polylines = 5,
        // (undocumented)
        RealityMesh = 10,
        // (undocumented)
        SilhouetteEdges = 2,
        // (undocumented)
        Surfaces = 0,
        // (undocumented)
        Terrain = 9,
        // (undocumented)
        VisibleEdges = 1
    }
    // (undocumented)
    export interface Consumer {
        // (undocumented)
        collectStatistics(stats: Statistics): void;
    }
    export class Consumers {
        // (undocumented)
        addConsumer(numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        count: number;
        // (undocumented)
        maxBytes: number;
        // (undocumented)
        totalBytes: number;
    }
    // (undocumented)
    export enum ConsumerType {
        // (undocumented)
        ClipVolumes = 5,
        // (undocumented)
        COUNT = 10,
        // (undocumented)
        EdgeTables = 2,
        // (undocumented)
        FeatureOverrides = 4,
        // (undocumented)
        FeatureTables = 3,
        // (undocumented)
        PlanarClassifiers = 6,
        // (undocumented)
        ShadowMaps = 7,
        // (undocumented)
        TextureAttachments = 8,
        // (undocumented)
        Textures = 0,
        // (undocumented)
        ThematicTextures = 9,
        // (undocumented)
        VertexTables = 1
    }
    // (undocumented)
    export class Statistics {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        addClipVolume(numBytes: number): void;
        // (undocumented)
        addConsumer(type: ConsumerType, numBytes: number): void;
        // (undocumented)
        addEdgeTable(numBytes: number): void;
        // (undocumented)
        addFeatureOverrides(numBytes: number): void;
        // (undocumented)
        addFeatureTable(numBytes: number): void;
        // (undocumented)
        addIndexedEdges(numBytes: number): void;
        // (undocumented)
        addInstances(numBytes: number): void;
        // (undocumented)
        addPlanarClassifier(numBytes: number): void;
        // (undocumented)
        addPointCloud(numBytes: number): void;
        // (undocumented)
        addPointString(numBytes: number): void;
        // (undocumented)
        addPolyline(numBytes: number): void;
        // (undocumented)
        addPolylineEdges(numBytes: number): void;
        // (undocumented)
        addRealityMesh(numBytes: number): void;
        // (undocumented)
        addShadowMap(numBytes: number): void;
        // (undocumented)
        addSilhouetteEdges(numBytes: number): void;
        // (undocumented)
        addSurface(numBytes: number): void;
        // (undocumented)
        addTerrain(numBytes: number): void;
        // (undocumented)
        addTexture(numBytes: number): void;
        // (undocumented)
        addTextureAttachment(numBytes: number): void;
        // (undocumented)
        addThematicTexture(numBytes: number): void;
        // (undocumented)
        addVertexTable(numBytes: number): void;
        // (undocumented)
        addVisibleEdges(numBytes: number): void;
        // (undocumented)
        readonly buffers: Buffers;
        // (undocumented)
        clear(): void;
        // (undocumented)
        get clipVolumes(): Consumers;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get edgeTables(): Consumers;
        // (undocumented)
        get featureOverrides(): Consumers;
        // (undocumented)
        get featureTables(): Consumers;
        // (undocumented)
        get planarClassifiers(): Consumers;
        // (undocumented)
        get shadowMaps(): Consumers;
        // (undocumented)
        get textureAttachments(): Consumers;
        // (undocumented)
        get textures(): Consumers;
        // (undocumented)
        get thematicTextures(): Consumers;
        // (undocumented)
        get totalBytes(): number;
        // (undocumented)
        get vertexTables(): Consumers;
    }
}

// @internal
export interface RenderPlan {
    // (undocumented)
    readonly analysisStyle?: AnalysisStyle;
    // (undocumented)
    readonly analysisTexture?: RenderTexture;
    // (undocumented)
    readonly ao?: AmbientOcclusion.Settings;
    // (undocumented)
    readonly backgroundMapOn: boolean;
    // (undocumented)
    readonly bgColor: ColorDef;
    // (undocumented)
    readonly clip?: ClipVector;
    // (undocumented)
    readonly clipStyle: ClipStyle;
    // (undocumented)
    readonly emphasisSettings: Hilite.Settings;
    // (undocumented)
    readonly flashSettings: FlashSettings;
    // (undocumented)
    readonly fraction: number;
    // (undocumented)
    readonly frustum: Frustum;
    // (undocumented)
    readonly globalViewTransition: number;
    // (undocumented)
    readonly hiliteSettings: Hilite.Settings;
    // (undocumented)
    readonly hline?: HiddenLine.Settings;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly isFadeOutActive: boolean;
    // (undocumented)
    readonly isGlobeMode3D: boolean;
    // (undocumented)
    readonly lights?: LightSettings;
    // (undocumented)
    readonly monochromeMode: MonochromeMode;
    // (undocumented)
    readonly monoColor: ColorDef;
    // (undocumented)
    readonly thematic?: ThematicDisplay;
    // (undocumented)
    readonly upVector: Vector3d;
    // (undocumented)
    readonly viewFlags: ViewFlags;
    // (undocumented)
    readonly whiteOnWhiteReversal: WhiteOnWhiteReversalSettings;
}

// @internal
export abstract class RenderPlanarClassifier implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext, target: PlanarClassifierTarget): void;
    // (undocumented)
    abstract dispose(): void;
    // (undocumented)
    abstract setSource(classifierTreeRef?: SpatialClassifierTileTreeReference, planarClipMask?: PlanarClipMaskState): void;
}

// @internal (undocumented)
export type RenderSkyBoxParams = RenderSkyGradientParams | RenderSkySphereParams | RenderSkyCubeParams;

// @internal (undocumented)
export interface RenderSkyCubeParams {
    // (undocumented)
    texture: RenderTexture;
    // (undocumented)
    type: "cube";
}

// @internal (undocumented)
export interface RenderSkyGradientParams {
    // (undocumented)
    gradient: SkyGradient;
    // (undocumented)
    type: "gradient";
    // (undocumented)
    zOffset: number;
}

// @internal (undocumented)
export interface RenderSkySphereParams {
    // (undocumented)
    rotation: number;
    // (undocumented)
    texture: RenderTexture;
    // (undocumented)
    type: "sphere";
    // (undocumented)
    zOffset: number;
}

// @public
export abstract class RenderSystem implements IDisposable {
    // @internal
    protected constructor(options?: RenderSystem.Options);
    // @beta
    antialiasSamples?: number;
    // @internal (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    static contextLossHandler(): Promise<any>;
    // @internal
    createAnimationTransformNode(graphic: RenderGraphic, _nodeId: number): RenderGraphic;
    // @internal (undocumented)
    createAreaPattern(_params: PatternGraphicParams): RenderAreaPattern | undefined;
    // @internal (undocumented)
    createBackgroundMapDrape(_drapedTree: TileTreeReference, _mapTree: MapTileTreeReference): RenderTextureDrape | undefined;
    // @internal
    abstract createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d, options?: BatchOptions): RenderGraphic;
    createBranch(branch: GraphicBranch, transform: Transform): RenderGraphic;
    createClipVolume(_clipVector: ClipVector): RenderClipVolume | undefined;
    abstract createGraphic(options: CustomGraphicBuilderOptions | ViewportGraphicBuilderOptions): GraphicBuilder;
    abstract createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): RenderGraphic;
    createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder;
    // @internal
    createGraphicLayer(graphic: RenderGraphic, _layerId: string): RenderGraphic;
    // @internal
    createGraphicLayerContainer(graphic: RenderGraphic, _drawAsOverlay: boolean, _transparency: number, _elevation: number): RenderGraphic;
    abstract createGraphicList(primitives: RenderGraphic[]): RenderGraphic;
    createGraphicOwner(ownedGraphic: RenderGraphic): RenderGraphicOwner;
    // @internal (undocumented)
    createIndexedPolylines(args: PolylineArgs, instances?: InstancedGraphicParams | RenderAreaPattern | Point3d): RenderGraphic | undefined;
    // @deprecated
    createMaterial(_params: RenderMaterial.Params, _imodel: IModelConnection): RenderMaterial | undefined;
    // @internal (undocumented)
    createMesh(params: MeshParams, instances?: InstancedGraphicParams | RenderAreaPattern | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createMeshGeometry(_params: MeshParams, _viewIndependentOrigin?: Point3d): RenderGeometry | undefined;
    // @internal (undocumented)
    abstract createOffscreenTarget(rect: ViewRect): RenderTarget;
    // @internal (undocumented)
    createPlanarGrid(_frustum: Frustum, _grid: PlanarGridProps): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointString(params: PointStringParams, instances?: InstancedGraphicParams | RenderAreaPattern | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointStringGeometry(_params: PointStringParams, _viewIndependentOrigin?: Point3d): RenderGeometry | undefined;
    // @internal (undocumented)
    createPolyline(params: PolylineParams, instances?: InstancedGraphicParams | RenderAreaPattern | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createPolylineGeometry(_params: PolylineParams, _viewIndependentOrigin?: Point3d): RenderGeometry | undefined;
    // @internal (undocumented)
    createRealityMesh(_realityMesh: RealityMeshParams, _disableTextureDisposal?: boolean): RenderGraphic | undefined;
    // @internal (undocumented)
    createRealityMeshGraphic(_params: RealityMeshGraphicParams, _disableTextureDisposal?: boolean): RenderGraphic | undefined;
    // @internal
    abstract createRenderGraphic(_geometry: RenderGeometry, instances?: InstancedGraphicParams | RenderAreaPattern): RenderGraphic | undefined;
    createRenderMaterial(_args: CreateRenderMaterialArgs): RenderMaterial | undefined;
    createScreenSpaceEffectBuilder(_params: ScreenSpaceEffectBuilderParams): ScreenSpaceEffectBuilder | undefined;
    // @internal
    createSkyBox(_params: RenderSkyBoxParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createTarget(canvas: HTMLCanvasElement): RenderTarget;
    // @internal (undocumented)
    createTerrainMesh(_params: RealityMeshParams, _transform?: Transform, _disableTextureDisposal?: boolean): RenderTerrainGeometry | undefined;
    // (undocumented)
    createTexture(_args: CreateTextureArgs): RenderTexture | undefined;
    // @internal
    createTextureFromCubeImages(_posX: HTMLImageElement, _negX: HTMLImageElement, _posY: HTMLImageElement, _negY: HTMLImageElement, _posZ: HTMLImageElement, _negZ: HTMLImageElement, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromElement(_id: Id64String, _imodel: IModelConnection, _params: RenderTexture.Params, _format: ImageSourceFormat): RenderTexture | undefined;
    // @deprecated
    createTextureFromImage(image: HTMLImageElement, hasAlpha: boolean, iModel: IModelConnection | undefined, params: RenderTexture.Params): RenderTexture | undefined;
    // @deprecated
    createTextureFromImageBuffer(image: ImageBuffer, iModel: IModelConnection, params: RenderTexture.Params): RenderTexture | undefined;
    // @deprecated
    createTextureFromImageSource(source: ImageSource, iModel: IModelConnection | undefined, params: RenderTexture.Params): Promise<RenderTexture | undefined>;
    createTextureFromSource(args: CreateTextureFromSourceArgs): Promise<RenderTexture | undefined>;
    // @internal (undocumented)
    createTile(tileTexture: RenderTexture, corners: Point3d[], featureIndex?: number): RenderGraphic | undefined;
    // @internal (undocumented)
    createTriMesh(args: MeshArgs, instances?: InstancedGraphicParams | RenderAreaPattern | Point3d): RenderGraphic | undefined;
    // @beta
    get debugControl(): RenderSystemDebugControl | undefined;
    // @internal (undocumented)
    abstract dispose(): void;
    // @internal
    abstract doIdleWork(): boolean;
    // @internal (undocumented)
    get dpiAwareLOD(): boolean;
    // @internal (undocumented)
    enableDiagnostics(_enable: RenderDiagnostics): void;
    findMaterial(_key: string, _imodel: IModelConnection): RenderMaterial | undefined;
    findTexture(_key: TextureCacheKey, _imodel: IModelConnection): RenderTexture | undefined;
    getGradientTexture(_symb: Gradient.Symb, _imodel?: IModelConnection): RenderTexture | undefined;
    // @internal (undocumented)
    get hasExternalTextureRequests(): boolean;
    // @internal (undocumented)
    get isMobile(): boolean;
    // @internal (undocumented)
    abstract get isValid(): boolean;
    // @internal
    loadTexture(id: Id64String, iModel: IModelConnection): Promise<RenderTexture | undefined>;
    // @internal
    loadTextureImage(id: Id64String, iModel: IModelConnection): Promise<OldTextureImage | undefined>;
    // @internal (undocumented)
    get maxRealityImageryLayers(): number;
    // @internal (undocumented)
    get maxTextureSize(): number;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    readonly options: RenderSystem.Options;
    // @internal (undocumented)
    get supportsCreateImageBitmap(): boolean;
    // @internal (undocumented)
    get supportsIndexedEdges(): boolean;
    // @internal (undocumented)
    get supportsInstancing(): boolean;
    // @internal (undocumented)
    get supportsLogZBuffer(): boolean;
    // @internal (undocumented)
    get supportsNonuniformScaledInstancing(): boolean;
    waitForAllExternalTextures(): Promise<void>;
}

// @public
export namespace RenderSystem {
    export interface Options {
        antialiasSamples?: number;
        // @internal
        contextAttributes?: WebGLContextAttributes;
        // @internal
        debugShaders?: boolean;
        devicePixelRatioOverride?: number;
        disabledExtensions?: WebGLExtensionName[];
        // @beta
        displaySolarShadows?: boolean;
        // @beta
        doIdleWork?: boolean;
        dpiAwareLOD?: boolean;
        dpiAwareViewports?: boolean;
        errorOnMissingUniform?: boolean;
        // @internal
        filterMapDrapeTextures?: boolean;
        // @internal
        filterMapTextures?: boolean;
        logarithmicDepthBuffer?: boolean;
        planProjections?: boolean;
        preserveShaderSourceCode?: boolean;
        useWebGL2?: boolean;
    }
}

// @beta
export interface RenderSystemDebugControl {
    // @internal
    compileAllShaders(): boolean;
    // @internal
    debugShaderFiles?: DebugShaderFile[];
    // @internal
    dpiAwareLOD: boolean;
    // @internal
    readonly isGLTimerSupported: boolean;
    loseContext(): boolean;
    // @internal
    resultsCallback?: GLTimerResultCallback;
}

// @internal
export abstract class RenderTarget implements IDisposable, RenderMemory.Consumer {
    adjustPixelSizeForLOD(cssPixelSize: number): number;
    // (undocumented)
    abstract get analysisFraction(): number;
    abstract set analysisFraction(fraction: number);
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_transforms: AnimationBranchStates | undefined);
    // (undocumented)
    get antialiasSamples(): number;
    set antialiasSamples(_numSamples: number);
    // (undocumented)
    assignFrameStatsCollector(_collector: FrameStatsCollector): void;
    // (undocumented)
    abstract changeDecorations(decorations: Decorations): void;
    // (undocumented)
    abstract changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    abstract changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    abstract changeScene(scene: Scene): void;
    // (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    // (undocumented)
    createGraphicBuilder(options: CustomGraphicBuilderOptions | ViewportGraphicBuilderOptions): GraphicBuilder;
    // (undocumented)
    createPlanarClassifier(_properties?: SpatialClassifier): RenderPlanarClassifier | undefined;
    // (undocumented)
    cssPixelsToDevicePixels(cssPixels: number, floor?: boolean): number;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl | undefined;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    abstract drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    getPlanarClassifier(_id: string): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrape(_id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    onBeforeRender(_viewport: Viewport, _setSceneNeedRedraw: (redraw: boolean) => void): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(_ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    pickOverlayDecoration(_pt: XAndY): CanvasDecoration | undefined;
    queryVisibleTileFeatures(_options: QueryTileFeaturesOptions, _iModel: IModelConnection, callback: QueryVisibleFeaturesCallback): void;
    // @deprecated (undocumented)
    readImage(_rect: ViewRect, _targetSize: Point2d, _flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    readImageBuffer(_args?: ReadImageBufferArgs): ImageBuffer | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    abstract readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    abstract get renderSystem(): RenderSystem;
    // (undocumented)
    reset(): void;
    abstract get screenSpaceEffects(): Iterable<string>;
    abstract set screenSpaceEffects(_effectNames: Iterable<string>);
    // (undocumented)
    setFlashed(_elementId: Id64String, _intensity: number): void;
    // (undocumented)
    setHiliteSet(_hilited: HiliteSet): void;
    setRenderToScreen(_toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    abstract setViewRect(_rect: ViewRect, _temporary: boolean): void;
    updateSolarShadows(_context: SceneContext | undefined): void;
    // (undocumented)
    abstract updateViewRect(): boolean;
    abstract get viewRect(): ViewRect;
    // (undocumented)
    abstract get wantInvertBlackBackground(): boolean;
}

// @internal
export interface RenderTargetDebugControl {
    devicePixelRatioOverride?: number;
    // (undocumented)
    displayDrapeFrustum: boolean;
    // (undocumented)
    displayNormalMaps: boolean;
    // (undocumented)
    displayRealityTilePreload: boolean;
    // (undocumented)
    displayRealityTileRanges: boolean;
    drawForReadPixels: boolean;
    // (undocumented)
    freezeRealityTiles: boolean;
    getRenderCommands(): Array<{
        name: string;
        count: number;
    }>;
    // (undocumented)
    logRealityTiles: boolean;
    // (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // (undocumented)
    readonly shadowFrustum: Frustum | undefined;
    // (undocumented)
    vcSupportIntersectingVolumes: boolean;
}

// @internal (undocumented)
export abstract class RenderTerrainGeometry implements IDisposable, RenderMemory.Consumer {
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
    // (undocumented)
    abstract get transform(): Transform | undefined;
}

// @internal
export abstract class RenderTextureDrape implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext): void;
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @beta
export interface RequestMeshDataArgs {
    isCanceled(): boolean;
    tile: MapTile;
}

// @internal (undocumented)
export type RequestTileTreePropsFunc = (iModel: IModelConnection, treeId: string) => Promise<IModelTileTreeProps>;

// @alpha (undocumented)
export type ResolveFunc = () => Promise<any>;

// @alpha (undocumented)
export type ResolveManifestFunc = () => Promise<ExtensionManifest>;

// @internal
export type RootIModelTile = Tile & {
    tileScreenSize: number;
    updateDynamicRange: (childTile: Tile) => void;
};

// @public
export class RotateViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum RotationMode {
    // (undocumented)
    ACS = 5,
    // (undocumented)
    Context = 6,
    // (undocumented)
    Front = 2,
    // (undocumented)
    Side = 3,
    // (undocumented)
    Top = 1,
    // (undocumented)
    View = 4
}

// @internal (undocumented)
export class RoundOff {
    // (undocumented)
    active: boolean;
    // (undocumented)
    units: Set<number>;
}

// @internal (undocumented)
export class SavedState {
    // (undocumented)
    auxRotationPlane: number;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    ignoreFlags: AccuDrawFlags;
    // (undocumented)
    mode: CompassMode;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    state: CurrentState;
}

// @public
export class Scene {
    readonly background: RenderGraphic[];
    readonly foreground: RenderGraphic[];
    readonly overlay: RenderGraphic[];
    // @internal (undocumented)
    readonly planarClassifiers: Map<string, RenderPlanarClassifier>;
    // @internal (undocumented)
    readonly textureDrapes: Map<string, RenderTextureDrape>;
    // @internal (undocumented)
    volumeClassifier?: SceneVolumeClassifier;
}

// @public
export class SceneContext extends RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // @internal (undocumented)
    addBackgroundDrapedModel(drapedTreeRef: TileTreeReference, _heightRange: Range1d | undefined): RenderTextureDrape | undefined;
    // @internal (undocumented)
    addPlanarClassifier(classifiedModelId: Id64String, classifierTree?: SpatialClassifierTileTreeReference, planarClipMask?: PlanarClipMaskState): RenderPlanarClassifier | undefined;
    get backgroundGraphics(): RenderGraphic[];
    // @internal (undocumented)
    getPlanarClassifierForModel(modelId: Id64String): RenderPlanarClassifier | undefined;
    // @internal (undocumented)
    getTextureDrapeForModel(modelId: Id64String): RenderTextureDrape | undefined;
    get graphics(): RenderGraphic[];
    // @internal (undocumented)
    get graphicType(): TileGraphicType;
    // @internal (undocumented)
    get hasMissingTiles(): boolean;
    insertMissingTile(tile: Tile): void;
    // @internal (undocumented)
    markChildrenLoading(): void;
    // @internal (undocumented)
    readonly missingTiles: Set<Tile>;
    outputGraphic(graphic: RenderGraphic): void;
    get overlayGraphics(): RenderGraphic[];
    // @internal (undocumented)
    get planarClassifiers(): Map<string, RenderPlanarClassifier>;
    // @internal (undocumented)
    requestMissingTiles(): void;
    readonly scene: Scene;
    // @internal (undocumented)
    setVolumeClassifier(classifier: SpatialClassifier, modelId: Id64String): void;
    // @internal (undocumented)
    get textureDrapes(): Map<string, RenderTextureDrape>;
    get viewingSpace(): ViewingSpace;
    // @internal (undocumented)
    withGraphicType(type: TileGraphicType, func: () => void): void;
}

// @internal
export interface SceneVolumeClassifier {
    // (undocumented)
    classifier: SpatialClassifier;
    // (undocumented)
    modelId: Id64String;
}

// @public
export interface ScreenSpaceEffectBuilder {
    addUniform: (params: UniformParams) => void;
    addUniformArray: (params: UniformArrayParams) => void;
    addVarying: (name: string, type: VaryingType) => void;
    finish: () => void;
    readonly isWebGL2: boolean;
    shouldApply?: (context: ScreenSpaceEffectContext) => boolean;
}

// @public
export interface ScreenSpaceEffectBuilderParams {
    name: string;
    source: ScreenSpaceEffectSource;
    textureCoordFromPosition?: boolean;
}

// @public
export interface ScreenSpaceEffectContext {
    viewport: Viewport;
}

// @public
export interface ScreenSpaceEffectSource {
    fragment: string;
    sampleSourcePixel?: string;
    vertex: string;
}

// @public
export class ScreenViewport extends Viewport {
    // @internal
    protected constructor(canvas: HTMLCanvasElement, parentDiv: HTMLDivElement, target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(decorations: Decorations): void;
    // @internal (undocumented)
    protected addLogo(): void;
    // @internal (undocumented)
    addNewDiv(className: string, overflowHidden: boolean, z: number): HTMLDivElement;
    animateFlyoverToGlobalLocation(destination: GlobalLocation): Promise<void>;
    animateFrustumChange(options?: ViewAnimationOptions): void;
    // @internal
    animateToCurrent(_start: Frustum, options?: ViewAnimationOptions): void;
    static animation: {
        time: {
            fast: BeDuration;
            normal: BeDuration;
            slow: BeDuration;
            wheel: BeDuration;
        };
        easing: (k: number) => number;
        zoomOut: {
            enable: boolean;
            interpolation: (v: any, k: number) => number;
            heights: number[];
            positions: number[];
            margin: number;
            durationFactor: number;
        };
    };
    readonly canvas: HTMLCanvasElement;
    changeView(view: ViewState, opts?: ViewChangeOptions): void;
    clearViewUndo(): void;
    static create(parentDiv: HTMLDivElement, view: ViewState): ScreenViewport;
    // @internal
    readonly decorationDiv: HTMLDivElement;
    // @internal (undocumented)
    dispose(): void;
    doRedo(animationTime?: BeDuration): void;
    doUndo(animationTime?: BeDuration): void;
    // @internal (undocumented)
    drawLocateCursor(context: DecorateContext, viewPt: Point3d, aperture: number, isLocateCircleOn: boolean, hit?: HitDetail): void;
    getClientRect(): DOMRect;
    invalidateCachedDecorations(decorator: ViewportDecorator): void;
    // @internal (undocumented)
    invalidateScene(): void;
    get isRedoPossible(): boolean;
    get isUndoPossible(): boolean;
    // @beta
    get logo(): HTMLImageElement;
    // @internal (undocumented)
    static markAllChildrenForRemoval(el: HTMLDivElement): void;
    maxUndoSteps: number;
    // @internal (undocumented)
    mouseMovementFromEvent(ev: MouseEvent): XAndY;
    // @internal (undocumented)
    mousePosFromEvent(ev: MouseEvent): XAndY;
    // @internal
    onViewManagerAdd(): void;
    // @internal
    onViewManagerDrop(): void;
    openToolTip(message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    readonly parentDiv: HTMLDivElement;
    // @internal (undocumented)
    pickCanvasDecoration(pt: XAndY): CanvasDecoration | undefined;
    pickDepthPoint(pickPoint: Point3d, radius?: number, options?: DepthPointOptions): {
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        sourceId?: string;
    };
    // @internal (undocumented)
    picker: ElementPicker;
    pickNearestVisibleGeometry(pickPoint: Point3d, radius?: number, allowNonLocatable?: boolean, out?: Point3d): Point3d | undefined;
    // @internal
    static removeAllChildren(el: HTMLDivElement): void;
    // @internal (undocumented)
    static removeMarkedChildren(el: HTMLDivElement): void;
    // @internal
    get rendersToScreen(): boolean;
    set rendersToScreen(toScreen: boolean);
    resetUndo(): void;
    saveViewUndo(): void;
    setCursor(cursor?: string): void;
    // @deprecated
    setEventController(controller?: EventController): void;
    // @internal
    static setToParentSize(div: HTMLElement): void;
    // @internal (undocumented)
    synchWithView(options?: ViewChangeOptions): void;
    readonly toolTipDiv: HTMLDivElement;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    // @internal (undocumented)
    get viewCmdTargetCenter(): Point3d | undefined;
    set viewCmdTargetCenter(center: Point3d | undefined);
    get viewRect(): ViewRect;
    readonly vpDiv: HTMLDivElement;
    // @internal
    waitForSceneCompletion(): Promise<void>;
}

// @public
export class ScrollViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal
export interface SectionDrawingInfo {
    // (undocumented)
    readonly drawingToSpatialTransform: Transform;
    // (undocumented)
    readonly spatialView: Id64String;
}

// @public
export class SectionDrawingModelState extends DrawingModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export interface SelectAddEvent {
    added: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Add;
}

// @internal
export interface SelectedAndReadyTiles {
    readonly external: ExternalTileStatistics;
    readonly ready: Set<Tile>;
    readonly selected: Set<Tile>;
}

// @public
export interface SelectedViewportChangedArgs {
    // (undocumented)
    current?: ScreenViewport;
    // (undocumented)
    previous?: ScreenViewport;
}

// @public
export enum SelectionMethod {
    Box = 2,
    Line = 1,
    Pick = 0
}

// @public
enum SelectionMode_2 {
    Add = 1,
    Remove = 2,
    Replace = 0
}
export { SelectionMode_2 as SelectionMode }

// @public
export enum SelectionProcessing {
    AddElementToSelection = 0,
    InvertElementInSelection = 2,
    RemoveElementFromSelection = 1,
    ReplaceSelectionWithElement = 3
}

// @public
export class SelectionSet {
    constructor(iModel: IModelConnection);
    add(elem: Id64Arg): boolean;
    addAndRemove(adds: Id64Arg, removes: Id64Arg): boolean;
    get elements(): Set<string>;
    emptyAll(): void;
    has(elemId?: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(elem: Id64Arg): boolean;
    get isActive(): boolean;
    isSelected(elemId?: Id64String): boolean;
    readonly onChanged: BeEvent<(ev: SelectionSetEvent) => void>;
    remove(elem: Id64Arg): boolean;
    replace(elem: Id64Arg): void;
    get size(): number;
}

// @public
export type SelectionSetEvent = SelectAddEvent | SelectRemoveEvent | SelectReplaceEvent;

// @public
export enum SelectionSetEventType {
    Add = 0,
    Clear = 3,
    Remove = 1,
    Replace = 2
}

// @public
export class SelectionTool extends PrimitiveTool {
    // @beta
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): Promise<boolean>;
    // (undocumented)
    autoLockTarget(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    filterHit(hit: HitDetail, out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    protected initSelectTool(): void;
    // (undocumented)
    protected _isSelectByPoints: boolean;
    // (undocumented)
    protected _isSuspended: boolean;
    // (undocumented)
    onCleanup(): Promise<void>;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    onSuspend(): Promise<void>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected processMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    processSelection(elementId: Id64Arg, process: SelectionProcessing): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected selectByPointsEnd(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected selectByPointsProcess(origin: Point3d, corner: Point3d, ev: BeButtonEvent, method: SelectionMethod, overlap: boolean): void;
    // (undocumented)
    protected selectByPointsStart(ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecoration(ev: BeButtonEvent, currHit?: HitDetail): Promise<EventHandled>;
    // (undocumented)
    get selectionMethod(): SelectionMethod;
    set selectionMethod(method: SelectionMethod);
    // (undocumented)
    get selectionMode(): SelectionMode_2;
    set selectionMode(mode: SelectionMode_2);
    // (undocumented)
    protected showPrompt(mode: SelectionMode_2, method: SelectionMethod): void;
    // (undocumented)
    static startTool(): Promise<boolean>;
    // @beta
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateSelection(elementId: Id64Arg, process: SelectionProcessing): boolean;
    // (undocumented)
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantEditManipulators(): boolean;
    // (undocumented)
    protected wantPickableDecorations(): boolean;
    // (undocumented)
    protected wantSelectionClearOnMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantToolSettings(): boolean;
}

// @internal
export enum SelectParent {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @public
export interface SelectRemoveEvent {
    removed: Id64Arg;
    set: SelectionSet;
    type: SelectionSetEventType.Remove | SelectionSetEventType.Clear;
}

// @public
export interface SelectReplaceEvent {
    added: Id64Arg;
    removed: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Replace;
}

// @public
export class SetupCameraTool extends PrimitiveTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): Promise<boolean>;
    // (undocumented)
    get cameraHeight(): number;
    set cameraHeight(value: number);
    // (undocumented)
    get cameraHeightProperty(): DialogProperty<number>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    static drawCameraFrustum(context: DecorateContext, vp: ScreenViewport, eyePtWorld: Point3d, targetPtWorld: Point3d, eyeSnapPtWorld?: Point3d, targetSnapPtWorld?: Point3d): void;
    // (undocumented)
    protected _eyePtWorld: Point3d;
    // (undocumented)
    protected getAdjustedEyePoint(): Point3d;
    // (undocumented)
    protected getAdjustedTargetPoint(): Point3d;
    // (undocumented)
    protected _haveEyePt: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    onUnsuspend(): Promise<void>;
    // @beta (undocumented)
    protected provideToolAssistance(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    get targetHeight(): number;
    set targetHeight(value: number);
    // (undocumented)
    get targetHeightProperty(): DialogProperty<number>;
    // (undocumented)
    protected _targetPtWorld: Point3d;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    get useCameraHeight(): boolean;
    set useCameraHeight(option: boolean);
    // (undocumented)
    get useCameraHeightProperty(): DialogProperty<boolean>;
    // (undocumented)
    get useTargetHeight(): boolean;
    set useTargetHeight(value: boolean);
    // (undocumented)
    get useTargetHeightProperty(): DialogProperty<boolean>;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @public
export class SetupWalkCameraTool extends PrimitiveTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    static drawFigure(context: DecorateContext, vp: Viewport, groundPt: Point3d, eyeHeight: number): void;
    // (undocumented)
    protected _eyePtWorld: Point3d;
    // (undocumented)
    protected getAdjustedEyePoint(): Point3d;
    // (undocumented)
    protected getAdjustedTargetPoint(): Point3d;
    // (undocumented)
    protected _haveEyePt: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    onUnsuspend(): Promise<void>;
    // @beta (undocumented)
    protected provideToolAssistance(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected _targetPtWorld: Point3d;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @public
export class SheetModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SheetViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, sheetProps: SheetProps, attachments: Id64Array);
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    // (undocumented)
    get attachmentIds(): Id64Array;
    // @internal
    get attachments(): Object[] | undefined;
    // @internal (undocumented)
    attachToViewport(args: AttachToViewportArgs): void;
    // @internal (undocumented)
    changeViewedModel(modelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    collectNonTileTreeStatistics(stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    static createFromProps(viewStateData: ViewStateProps, iModel: IModelConnection): SheetViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // @internal (undocumented)
    detachFromViewport(): void;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // @internal (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // @internal (undocumented)
    isSheetView(): this is SheetViewState;
    // @internal (undocumented)
    protected postload(hydrateResponse: HydrateViewStateResponseProps): Promise<void>;
    // @internal (undocumented)
    protected preload(hydrateRequest: HydrateViewStateRequestProps): void;
    // @internal (undocumented)
    get secondaryViewports(): Iterable<Viewport>;
    readonly sheetSize: Point2d;
    // (undocumented)
    toProps(): ViewStateProps;
    // @internal
    get viewAttachmentProps(): Array<Readonly<ViewAttachmentProps>>;
}

// @internal (undocumented)
export type ShouldAbortImdlReader = (reader: ImdlReader) => boolean;

// @internal
export type ShouldAbortReadGltf = (reader: GltfReader) => boolean;

// @internal (undocumented)
export interface SkyBoxDecorations {
    // (undocumented)
    params?: RenderSkyBoxParams;
    // (undocumented)
    promise?: Promise<boolean>;
}

// @public
export class SnapDetail extends HitDetail {
    constructor(from: HitDetail, snapMode?: SnapMode, heat?: SnapHeat, snapPoint?: XYZProps);
    readonly adjustedPoint: Point3d;
    clone(): SnapDetail;
    // (undocumented)
    draw(context: DecorateContext): void;
    geomType?: HitGeomType;
    // (undocumented)
    getCurvePrimitive(singleSegment?: boolean): CurvePrimitive | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    // (undocumented)
    heat: SnapHeat;
    get isHot(): boolean;
    get isPointAdjusted(): boolean;
    normal?: Vector3d;
    parentGeomType?: HitParentGeomType;
    primitive?: CurvePrimitive;
    setCurvePrimitive(primitive?: CurvePrimitive, localToWorld?: Transform, geomType?: HitGeomType): void;
    setSnapPoint(point: Point3d, heat: SnapHeat): void;
    // (undocumented)
    snapMode: SnapMode;
    readonly snapPoint: Point3d;
    sprite?: Sprite;
}

// @public (undocumented)
export enum SnapHeat {
    // (undocumented)
    InRange = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    NotInRange = 1
}

// @public (undocumented)
export enum SnapMode {
    // (undocumented)
    Bisector = 32,
    // (undocumented)
    Center = 8,
    // (undocumented)
    Intersection = 64,
    // (undocumented)
    MidPoint = 4,
    // (undocumented)
    Nearest = 1,
    // (undocumented)
    NearestKeypoint = 2,
    // (undocumented)
    Origin = 16
}

// @public
export class SnapshotConnection extends IModelConnection {
    close(): Promise<void>;
    get iModelId(): GuidString;
    get isClosed(): boolean;
    get isRemote(): boolean;
    isSnapshotConnection(): this is SnapshotConnection;
    static openFile(filePath: string): Promise<SnapshotConnection>;
    static openRemote(fileKey: string): Promise<SnapshotConnection>;
}

// @public (undocumented)
export enum SnapStatus {
    // (undocumented)
    Aborted = 1,
    // (undocumented)
    Disabled = 100,
    // (undocumented)
    FilteredByApp = 600,
    // (undocumented)
    FilteredByAppQuietly = 700,
    // (undocumented)
    NoElements = 2,
    // (undocumented)
    NoSnapPossible = 200,
    // (undocumented)
    NotSnappable = 300,
    // (undocumented)
    Success = 0
}

// @internal (undocumented)
export abstract class SpatialClassifierTileTreeReference extends TileTreeReference {
    // (undocumented)
    abstract get activeClassifier(): SpatialClassifier | undefined;
    // (undocumented)
    get isOpaque(): boolean;
    // (undocumented)
    abstract get isPlanar(): boolean;
    // (undocumented)
    get transparency(): number | undefined;
    // (undocumented)
    abstract get viewFlags(): Partial<ViewFlagsProperties>;
}

// @alpha
export interface SpatialLocationAndExtents {
    isGeolocated: boolean;
    location: Cartographic | EcefLocation;
    worldRange: Range3d;
}

// @public
export class SpatialLocationModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SpatialModelState extends GeometricModel3dState {
    constructor(props: ModelProps, iModel: IModelConnection, state?: SpatialModelState);
    // @internal (undocumented)
    get asSpatialModel(): SpatialModelState;
    readonly classifiers?: SpatialClassifiers;
    // @internal (undocumented)
    static get className(): string;
    get isRealityModel(): boolean;
}

// @internal
export interface SpatialTileTreeReferences extends Iterable<TileTreeReference> {
    [Symbol.iterator](): Iterator<TileTreeReference>;
    setDeactivated(modelIds: Id64String | Id64String[] | undefined, deactivated: boolean | undefined, refs: "all" | "animated" | "primary" | "section" | number[]): void;
    update(): void;
}

// @internal
export namespace SpatialTileTreeReferences {
    export function create(view: SpatialViewState): SpatialTileTreeReferences;
}

// @public
export class SpatialViewState extends ViewState3d {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, arg3: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // (undocumented)
    addViewedModel(id: Id64String): void;
    // @internal (undocumented)
    attachToViewport(args: AttachToViewportArgs): void;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    clearViewedModels(): void;
    computeFitRange(): AxisAlignedBox3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    static createBlank(iModel: IModelConnection, origin: XYAndZ, extents: XYAndZ, rotation?: Matrix3d): SpatialViewState;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): SpatialViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // @internal (undocumented)
    detachFromViewport(): void;
    // (undocumented)
    equals(other: this): boolean;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    protected getDisplayedExtents(): AxisAlignedBox3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal (undocumented)
    isSpatialView(): this is SpatialViewState;
    // @internal (undocumented)
    markModelSelectorChanged(): void;
    // (undocumented)
    get modelSelector(): ModelSelectorState;
    set modelSelector(selector: ModelSelectorState);
    readonly onViewedModelsChanged: BeEvent<() => void>;
    // @internal (undocumented)
    protected postload(hydrateResponse: HydrateViewStateResponseProps): Promise<void>;
    // @internal (undocumented)
    protected preload(hydrateRequest: HydrateViewStateRequestProps): void;
    // (undocumented)
    removeViewedModel(id: Id64String): void;
    // @internal
    setTileTreeReferencesDeactivated(modelIds: Id64String | Id64String[] | undefined, deactivated: boolean | undefined, which: "all" | "animated" | "primary" | "section" | number[]): void;
    // (undocumented)
    toJSON(): SpatialViewDefinitionProps;
    // (undocumented)
    toProps(): ViewStateProps;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export class Sprite {
    constructor(src: ImageSource | string);
    image?: HTMLImageElement;
    get isLoaded(): boolean;
    loadPromise: Promise<HTMLImageElement>;
    get offset(): Point2d;
    readonly size: Point2d;
}

// @public
export class SpriteLocation implements CanvasDecoration {
    activate(sprite: Sprite, viewport: ScreenViewport, locationWorld: XYAndZ, alpha?: number): void;
    deactivate(): void;
    decorate(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    get isActive(): boolean;
    readonly position: Point3d;
}

// @public
export class StandardView {
    static adjustToStandardRotation(matrix: Matrix3d): void;
    // (undocumented)
    static get back(): Matrix3d;
    // (undocumented)
    static get bottom(): Matrix3d;
    // (undocumented)
    static get front(): Matrix3d;
    static getStandardRotation(id: StandardViewId): Matrix3d;
    // (undocumented)
    static get iso(): Matrix3d;
    // (undocumented)
    static get left(): Matrix3d;
    // (undocumented)
    static get right(): Matrix3d;
    // (undocumented)
    static get rightIso(): Matrix3d;
    // (undocumented)
    static get top(): Matrix3d;
}

// @public
export enum StandardViewId {
    // (undocumented)
    Back = 5,
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    Front = 4,
    // (undocumented)
    Iso = 6,
    // (undocumented)
    Left = 2,
    NotStandard = -1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    RightIso = 7,
    // (undocumented)
    Top = 0
}

// @public
export class StandardViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, _standardViewId: StandardViewId);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public (undocumented)
export enum StartOrResume {
    // (undocumented)
    Resume = 2,
    // (undocumented)
    Start = 1
}

// @public
class Storage_2 {
    constructor(id: string);
    getData(key: string): Promise<StorageValue>;
    getKeys(): Promise<string[]>;
    getValueType(key: string): Promise<"number" | "string" | "boolean" | "Uint8Array" | "null" | undefined>;
    // (undocumented)
    readonly id: string;
    removeAll(): Promise<void>;
    removeData(key: string): Promise<void>;
    setData(key: string, value: StorageValue): Promise<void>;
}
export { Storage_2 as Storage }

// @internal
export class SubCategoriesCache {
    constructor(imodel: IModelConnection);
    // (undocumented)
    clear(): void;
    // (undocumented)
    getCategoryInfo(inputCategoryIds: Id64String | Iterable<Id64String>): Promise<Map<Id64String, IModelConnection.Categories.CategoryInfo>>;
    getSubCategories(categoryId: string): Id64Set | undefined;
    getSubCategoryAppearance(subCategoryId: Id64String): SubCategoryAppearance | undefined;
    // (undocumented)
    getSubCategoryInfo(categoryId: Id64String, inputSubCategoryIds: Id64String | Iterable<Id64String>): Promise<Map<Id64String, IModelConnection.Categories.SubCategoryInfo>>;
    load(categoryIds: Id64Arg): SubCategoriesRequest | undefined;
    // (undocumented)
    onIModelConnectionClose(): void;
}

// @internal
export namespace SubCategoriesCache {
    export class Queue {
        // (undocumented)
        protected _current?: QueueEntry;
        dispose(): void;
        // (undocumented)
        protected _disposed: boolean;
        // (undocumented)
        get isEmpty(): boolean;
        // (undocumented)
        protected _next?: QueueEntry;
        push(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void;
        // (undocumented)
        protected _request?: SubCategoriesRequest;
    }
    // (undocumented)
    export class QueueEntry {
        constructor(categoryIds: Id64Set, func: QueueFunc);
        // (undocumented)
        readonly categoryIds: Id64Set;
        // (undocumented)
        readonly funcs: QueueFunc[];
    }
    // (undocumented)
    export type QueueFunc = () => void;
    // (undocumented)
    export class Request {
        constructor(categoryIds: Set<string>, imodel: IModelConnection, maxCategoriesPerQuery?: number);
        // (undocumented)
        cancel(): void;
        // (undocumented)
        dispatch(): Promise<Result | undefined>;
        // (undocumented)
        get wasCanceled(): boolean;
    }
    // (undocumented)
    export type Result = SubCategoryResultRow[];
}

// @internal
export interface SubCategoriesRequest {
    cancel(): void;
    readonly missingCategoryIds: Id64Set;
    readonly promise: Promise<boolean>;
}

// @beta
export class SurveyLengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export class SuspendedToolState {
    constructor();
    // (undocumented)
    stop(): void;
}

// @public
export function synchronizeViewportFrusta(source: Viewport): SynchronizeViewports;

// @public
export type SynchronizeViewports = (source: Viewport, target: Viewport) => void;

// @public
export function synchronizeViewportViews(source: Viewport): SynchronizeViewports;

// @internal (undocumented)
export abstract class Target extends RenderTarget implements RenderTargetDebugControl, WebGLDisposable {
    protected constructor(rect?: ViewRect);
    // (undocumented)
    activeVolumeClassifierModelId?: Id64String;
    // (undocumented)
    activeVolumeClassifierProps?: SpatialClassifier;
    // (undocumented)
    activeVolumeClassifierTexture?: WebGLTexture;
    // (undocumented)
    addBatch(batch: Batch): void;
    // (undocumented)
    protected allocateFbo(): FrameBuffer | undefined;
    // (undocumented)
    ambientOcclusionSettings: AmbientOcclusion.Settings;
    // (undocumented)
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    // (undocumented)
    analysisStyle?: AnalysisStyle;
    // (undocumented)
    analysisTexture?: RenderTexture;
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(branches: AnimationBranchStates | undefined);
    // (undocumented)
    get antialiasSamples(): number;
    set antialiasSamples(numSamples: number);
    // (undocumented)
    protected abstract _assignDC(): boolean;
    // (undocumented)
    assignFrameStatsCollector(collector: FrameStatsCollector): void;
    // (undocumented)
    protected abstract _beginPaint(fbo: FrameBuffer): void;
    // (undocumented)
    beginPerfMetricFrame(sceneMilSecElapsed?: number, readPixels?: boolean): void;
    // (undocumented)
    beginPerfMetricRecord(operation: string, readPixels?: boolean): void;
    // (undocumented)
    changeDecorations(decs: Decorations): void;
    // (undocumented)
    changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    changeFrustum(newFrustum: Frustum, newFraction: number, is3d: boolean): void;
    // (undocumented)
    changePlanarClassifiers(planarClassifiers?: PlanarClassifierMap): void;
    // (undocumented)
    changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    changeScene(scene: Scene): void;
    // (undocumented)
    changeTextureDrapes(textureDrapes: TextureDrapeMap | undefined): void;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get compositor(): SceneCompositor;
    // (undocumented)
    protected _compositor: SceneCompositor;
    // (undocumented)
    computeEdgeColor(baseColor: ColorInfo): ColorInfo;
    // (undocumented)
    computeEdgeLineCode(pass: RenderPass, baseCode: number): number;
    // (undocumented)
    computeEdgeWeight(pass: RenderPass, baseWeight: number): number;
    // (undocumented)
    copyImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    createPlanarClassifier(properties?: SpatialClassifier): PlanarClassifier;
    // (undocumented)
    protected cssViewRectToDeviceViewRect(rect: ViewRect): ViewRect;
    // (undocumented)
    get currentAnimationTransformNodeId(): number | undefined;
    set currentAnimationTransformNodeId(id: number | undefined);
    // (undocumented)
    get currentBranch(): BranchState;
    // (undocumented)
    get currentEdgeSettings(): EdgeSettings;
    // (undocumented)
    get currentFeatureSymbologyOverrides(): FeatureSymbology.Overrides;
    // (undocumented)
    get currentlyDrawingClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifierOrDrape(): PlanarClassifier | TextureDrape | undefined;
    // (undocumented)
    get currentTextureDrape(): TextureDrape | undefined;
    // (undocumented)
    get currentTransform(): Transform;
    // (undocumented)
    get currentTransparencyThreshold(): number;
    // (undocumented)
    get currentViewFlags(): ViewFlags;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl;
    // (undocumented)
    readonly decorationsState: BranchState;
    // (undocumented)
    displayDrapeFrustum: boolean;
    // (undocumented)
    displayNormalMaps: boolean;
    // (undocumented)
    displayRealityTilePreload: boolean;
    // (undocumented)
    displayRealityTileRanges: boolean;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected disposeFbo(): void;
    // (undocumented)
    drawForReadPixels: boolean;
    // (undocumented)
    drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    drawingBackgroundForReadPixels: boolean;
    // (undocumented)
    get drawNonLocatable(): boolean;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    drawPlanarClassifiers(): void;
    // (undocumented)
    drawSolarShadowMap(): void;
    // (undocumented)
    drawTextureDrapes(): void;
    // (undocumented)
    protected abstract _endPaint(): void;
    // (undocumented)
    endPerfMetricFrame(readPixels?: boolean): void;
    // (undocumented)
    endPerfMetricRecord(readPixels?: boolean): void;
    // (undocumented)
    protected _fbo?: FrameBuffer;
    // (undocumented)
    get flashed(): Id64.Uint32Pair | undefined;
    // (undocumented)
    get flashedId(): Id64String;
    // (undocumented)
    get flashIntensity(): number;
    // (undocumented)
    get frameStatsCollector(): FrameStatsCollector;
    // (undocumented)
    freezeRealityTiles: boolean;
    getAnimationTransformNodeId(animationNodeId: number | undefined): number | undefined;
    // (undocumented)
    getPlanarClassifier(id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getRenderCommands(): Array<{
        name: string;
        count: number;
    }>;
    // (undocumented)
    getTextureDrape(id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    getWorldDecorations(decs: GraphicList): Branch;
    // (undocumented)
    readonly graphics: TargetGraphics;
    // (undocumented)
    get hilites(): Hilites;
    // (undocumented)
    get hiliteSyncTarget(): SyncTarget;
    // (undocumented)
    get is2d(): boolean;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    get isDrawingShadowMap(): boolean;
    // (undocumented)
    isFadeOutActive: boolean;
    // (undocumented)
    isGeometryOutsideActiveVolume(geom: CachedGeometry): boolean;
    // (undocumented)
    isRangeOutsideActiveVolume(range: Range3d): boolean;
    // (undocumented)
    get isReadPixelsInProgress(): boolean;
    // (undocumented)
    logRealityTiles: boolean;
    // (undocumented)
    modelToView(modelPt: XYZ, result?: Point3d): Point3d;
    // (undocumented)
    onBatchDisposed(batch: Batch): void;
    // (undocumented)
    onBeforeRender(viewport: Viewport, setSceneNeedRedraw: (redraw: boolean) => void): void;
    // (undocumented)
    overrideFeatureSymbology(ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    performanceMetrics?: PerformanceMetrics;
    // (undocumented)
    plan: RenderPlan;
    // (undocumented)
    get planFraction(): number;
    // (undocumented)
    get planFrustum(): Frustum;
    // (undocumented)
    popBatch(): void;
    // (undocumented)
    popBranch(): void;
    // (undocumented)
    popViewClip(): void;
    // (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // (undocumented)
    pushBatch(batch: Batch): void;
    // (undocumented)
    pushBranch(branch: Branch): void;
    // (undocumented)
    pushState(state: BranchState): void;
    // (undocumented)
    pushViewClip(): void;
    // (undocumented)
    queryVisibleTileFeatures(options: QueryTileFeaturesOptions, iModel: IModelConnection, callback: QueryVisibleFeaturesCallback): void;
    readImage(wantRectIn: ViewRect, targetSizeIn: Point2d, flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    readImageBuffer(args?: ReadImageBufferArgs): ImageBuffer | undefined;
    // (undocumented)
    protected readImagePixels(out: Uint8Array, x: number, y: number, w: number, h: number): boolean;
    // (undocumented)
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    get readPixelsSelector(): Pixel.Selector;
    // (undocumented)
    readonly renderRect: ViewRect;
    // (undocumented)
    get renderSystem(): System;
    reset(): void;
    // (undocumented)
    get screenSpaceEffectContext(): ScreenSpaceEffectContext;
    // (undocumented)
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(effects: Iterable<string>);
    // (undocumented)
    setFlashed(id: Id64String, intensity: number): void;
    // (undocumented)
    setHiliteSet(hilite: HiliteSet): void;
    // (undocumented)
    get shadowFrustum(): Frustum | undefined;
    // (undocumented)
    get solarShadowMap(): SolarShadowMap;
    // (undocumented)
    get techniques(): Techniques;
    // (undocumented)
    readonly uniforms: TargetUniforms;
    // (undocumented)
    updateSolarShadows(context: SceneContext | undefined): void;
    // (undocumented)
    vcSupportIntersectingVolumes: boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    // (undocumented)
    get wantAmbientOcclusion(): boolean;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
    // (undocumented)
    get wantThematicDisplay(): boolean;
    // (undocumented)
    get wantThematicSensors(): boolean;
}

// @internal (undocumented)
export class TentativeOrAccuSnap {
    // (undocumented)
    static getCurrentPoint(): Point3d;
    // (undocumented)
    static getCurrentSnap(checkIsHot?: boolean): SnapDetail | undefined;
    // (undocumented)
    static getCurrentView(): ScreenViewport | undefined;
    // (undocumented)
    static get isHot(): boolean;
}

// @public (undocumented)
export class TentativePoint {
    // (undocumented)
    clear(doErase: boolean): void;
    // (undocumented)
    currSnap?: SnapDetail;
    // (undocumented)
    decorate(context: DecorateContext): void;
    getCurrSnap(): SnapDetail | undefined;
    // (undocumented)
    getHitAndList(holder: HitListHolder): SnapDetail | undefined;
    // (undocumented)
    getPoint(): Point3d;
    // (undocumented)
    isActive: boolean;
    get isSnapped(): boolean;
    // (undocumented)
    onButtonEvent(ev: BeButtonEvent): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    process(ev: BeButtonEvent): void;
    // (undocumented)
    removeTentative(): void;
    // (undocumented)
    setCurrSnap(newSnap?: SnapDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    setPoint(point: Point3d): void;
    // (undocumented)
    showTentative(): void;
    // (undocumented)
    tpHits?: HitList<HitDetail>;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal (undocumented)
export class TerrainDisplayOverrides {
    // (undocumented)
    produceGeometry?: boolean;
    // (undocumented)
    wantNormals?: boolean;
    // (undocumented)
    wantSkirts?: boolean;
}

// @beta
export abstract class TerrainMeshProvider {
    addLogoCards(_cards: HTMLTableElement, _vp: ScreenViewport): void;
    forceTileLoad(_tile: MapTile): boolean;
    getChildHeightRange(quadId: QuadId, rectangle: MapCartoRectangle, parent: MapTile): Range1d | undefined;
    isTileAvailable(_quadId: QuadId): boolean;
    abstract get maxDepth(): number;
    abstract readMesh(args: ReadMeshArgs): Promise<RealityMeshParams | undefined>;
    abstract requestMeshData(args: RequestMeshDataArgs): Promise<any>;
    abstract get tilingScheme(): MapTilingScheme;
}

// @beta
export interface TerrainMeshProviderOptions {
    exaggeration: number;
    wantNormals: boolean;
    wantSkirts: boolean;
}

// @beta
export interface TerrainProvider {
    createTerrainMeshProvider(options: TerrainMeshProviderOptions): Promise<TerrainMeshProvider | undefined>;
}

// @beta
export class TerrainProviderRegistry {
    // @internal
    constructor();
    find(name: string): TerrainProvider | undefined;
    register(name: string, provider: TerrainProvider): void;
}

// @internal (undocumented)
export class TerrainTexture {
    constructor(texture: RenderTexture, featureId: number, scale: Vector2d, translate: Vector2d, targetRectangle: Range2d, layerIndex: number, transparency: number, clipRectangle?: Range2d | undefined);
    // (undocumented)
    readonly clipRectangle?: Range2d | undefined;
    // (undocumented)
    cloneWithClip(clipRectangle: Range2d): TerrainTexture;
    // (undocumented)
    featureId: number;
    // (undocumented)
    readonly layerIndex: number;
    // (undocumented)
    readonly scale: Vector2d;
    // (undocumented)
    readonly targetRectangle: Range2d;
    // (undocumented)
    readonly texture: RenderTexture;
    // (undocumented)
    readonly translate: Vector2d;
    // (undocumented)
    transparency: number;
}

// @internal (undocumented)
export interface TerrainTileContent extends TileContent {
    // (undocumented)
    terrain?: {
        renderGeometry?: RenderTerrainGeometry;
        mesh?: RealityMeshParams;
    };
}

// @public
export interface TextInputFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "text";
    // (undocumented)
    getString: (props: FormatProps) => string;
    // (undocumented)
    setString: (props: FormatProps, value: string) => FormatProps;
}

// @public
export interface TextSelectFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "select";
    // (undocumented)
    getString: (props: FormatProps) => string;
    // (undocumented)
    selectOptions: {
        label: string;
        value: string;
    }[];
    // (undocumented)
    setString: (props: FormatProps, value: string) => FormatProps;
}

// @public
export type TextureCacheKey = string | Gradient.Symb;

// @public
export interface TextureCacheOwnership {
    iModel: IModelConnection;
    key: string | Gradient.Symb;
}

// @internal (undocumented)
export type TextureDrapeMap = Map<Id64String, RenderTextureDrape>;

// @public
export interface TextureImage {
    source: TextureImageSource;
    transparency?: TextureTransparency;
}

// @public
export type TextureImageSource = HTMLImageElement | ImageBuffer | ImageBitmap;

// @public
export type TextureOwnership = TextureCacheOwnership | "external";

// @internal (undocumented)
export class ThreeAxes {
    // (undocumented)
    clone(): ThreeAxes;
    // (undocumented)
    static createFromMatrix3d(rMatrix: Matrix3d, result?: ThreeAxes): ThreeAxes;
    // (undocumented)
    equals(other: ThreeAxes): boolean;
    // (undocumented)
    fromMatrix3d(rMatrix: Matrix3d): void;
    // (undocumented)
    setFrom(other: ThreeAxes): void;
    // (undocumented)
    toMatrix3d(out?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly x: Vector3d;
    // (undocumented)
    readonly y: Vector3d;
    // (undocumented)
    readonly z: Vector3d;
}

// @internal
export interface ThreeDTileFileInfo {
    rootChildren?: number;
}

// @internal
export class ThreeDTileFormatInterpreter {
    static getFileInfo(rootDocjson: any): ThreeDTileFileInfo;
    // @alpha
    static getPublisherProductInfo(rootDocjson: any): PublisherProductInfo;
    static getSpatialLocationAndExtents(json: any): SpatialLocationAndExtents;
    static maximumSizeFromGeometricTolerance(range: Range3d, geometricError: number): number;
    static rangeFromBoundingVolume(boundingVolume: any): Range3d | undefined;
    static transformFromJson(jTrans: number[] | undefined): Transform | undefined;
}

// @public
export abstract class Tile {
    protected constructor(params: TileParams, tree: TileTree);
    // @internal (undocumented)
    protected addRangeGraphic(builder: GraphicBuilder, type: TileBoundingBoxes): void;
    readonly boundingSphere: BoundingSphere;
    // @internal
    bytesUsed: number;
    get center(): Point3d;
    abstract get channel(): TileRequestChannel;
    get children(): Tile[] | undefined;
    protected _childrenLoadStatus: TileTreeLoadStatus;
    // @internal
    collectStatistics(stats: RenderMemory.Statistics, includeChildren?: boolean): void;
    // @internal
    protected _collectStatistics(_stats: RenderMemory.Statistics): void;
    computeLoadPriority(_viewports: Iterable<Viewport>, _users: Iterable<TileUser>): number;
    computeVisibility(args: TileDrawArgs): TileVisibility;
    get contentId(): string;
    protected _contentId: string;
    get contentRange(): ElementAlignedBox3d;
    protected _contentRange?: ElementAlignedBox3d;
    countDescendants(): number;
    readonly depth: number;
    dispose(): void;
    protected disposeChildren(): void;
    disposeContents(): void;
    drawGraphics(args: TileDrawArgs): void;
    // @internal (undocumented)
    extendRangeForContent(range: Range3d, matrix: Matrix4d, treeTransform: Transform, frustumPlanes?: FrustumPlanes): void;
    // @alpha
    freeMemory(): void;
    // @internal (undocumented)
    getRangeGraphic(context: SceneContext): RenderGraphic | undefined;
    getSizeProjectionCorners(): Point3d[] | undefined;
    protected _graphic?: RenderGraphic;
    protected _hadGraphics: boolean;
    get hasContentRange(): boolean;
    get hasGraphics(): boolean;
    get iModel(): IModelConnection;
    protected isContentCulled(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    get isDisplayable(): boolean;
    // @internal (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    protected isFrustumCulled(box: Frustum, args: TileDrawArgs, testClipIntersection: boolean, sphere?: BoundingSphere): boolean;
    get isLeaf(): boolean;
    // @internal (undocumented)
    protected _isLeaf: boolean;
    get isLoading(): boolean;
    get isNotFound(): boolean;
    // @alpha
    get isOutOfLodRange(): boolean;
    // @internal (undocumented)
    get isParentDisplayable(): boolean;
    get isQueued(): boolean;
    get isReady(): boolean;
    protected isRegionCulled(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    get isUndisplayableRootTile(): boolean;
    protected loadChildren(): TileTreeLoadStatus;
    protected abstract _loadChildren(resolve: (children: Tile[] | undefined) => void, reject: (error: Error) => void): void;
    get loadStatus(): TileLoadStatus;
    get maximumSize(): number;
    protected _maximumSize: number;
    // @internal
    next?: LRUTileListNode;
    readonly parent: Tile | undefined;
    // @internal
    previous?: LRUTileListNode;
    produceGraphics(): RenderGraphic | undefined;
    get radius(): number;
    readonly range: ElementAlignedBox3d;
    // @internal (undocumented)
    protected get rangeGraphicColor(): ColorDef;
    abstract readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // @internal (undocumented)
    get request(): TileRequest | undefined;
    set request(request: TileRequest | undefined);
    // @internal (undocumented)
    protected _request?: TileRequest;
    abstract requestContent(isCanceled: () => boolean): Promise<TileRequest.Response>;
    setContent(content: TileContent): void;
    // (undocumented)
    protected setGraphic(graphic: RenderGraphic | undefined): void;
    // (undocumented)
    setIsReady(): void;
    // (undocumented)
    setLeaf(): void;
    // (undocumented)
    setNotFound(): void;
    // @internal
    tileUserIds?: TileUserIdSet;
    readonly tree: TileTree;
    readonly usageMarker: TileUsageMarker;
}

// @public
export class TileAdmin {
    // @internal
    constructor(isMobile: boolean, rpcConcurrency: number | undefined, options?: TileAdmin.Props);
    // @internal
    addExternalTilesForUser(user: TileUser, statistics: ExternalTileStatistics): void;
    addLoadListener(callback: (imodel: IModelConnection) => void): () => void;
    // @internal
    addTilesForUser(user: TileUser, selected: Tile[], ready: Set<Tile>): void;
    // @internal (undocumented)
    readonly alwaysRequestEdges: boolean;
    // @internal (undocumented)
    readonly alwaysSubdivideIncompleteTiles: boolean;
    // @beta (undocumented)
    readonly cesiumIonKey?: string;
    // (undocumented)
    readonly channels: TileRequestChannels;
    clearTilesForUser(user: TileUser): void;
    // @internal
    clearUsageForUser(user: TileUser): void;
    // @internal (undocumented)
    readonly contextPreloadParentDepth: number;
    // @internal (undocumented)
    readonly contextPreloadParentSkip: number;
    static create(props?: TileAdmin.Props): Promise<TileAdmin>;
    get defaultTileSizeModifier(): number;
    set defaultTileSizeModifier(modifier: number);
    // @internal (undocumented)
    readonly disableMagnification: boolean;
    // @internal (undocumented)
    get edgeOptions(): EdgeOptions;
    // @internal (undocumented)
    get emptyTileUserSet(): ReadonlyTileUserSet;
    // @internal (undocumented)
    readonly enableExternalTextures: boolean;
    // @internal (undocumented)
    readonly enableFrontendScheduleScripts: boolean;
    // @internal (undocumented)
    readonly enableImprovedElision: boolean;
    // @internal (undocumented)
    get enableIndexedEdges(): boolean;
    // @internal (undocumented)
    get enableInstancing(): boolean;
    forgetUser(user: TileUser): void;
    // @internal
    freeMemory(): void;
    // @internal (undocumented)
    get generateAllPolyfaceEdges(): boolean;
    set generateAllPolyfaceEdges(val: boolean);
    // @internal (undocumented)
    generateTileContent(tile: {
        iModelTree: IModelTileTree;
        contentId: string;
        request?: {
            isCanceled: boolean;
        };
    }): Promise<Uint8Array>;
    getMaximumMajorTileFormatVersion(formatVersion?: number): number;
    getNumRequestsForUser(user: TileUser): number;
    getNumRequestsForViewport(vp: Viewport): number;
    // @internal
    getRequestsForUser(user: TileUser): Set<Tile> | undefined;
    // @internal
    getScriptInfoForTreeId(modelId: Id64String, script: RenderSchedule.ScriptReference | undefined): {
        timeline?: RenderSchedule.ModelTimeline;
        animationId?: Id64String;
    } | undefined;
    // @internal (undocumented)
    getTileRequestProps(tile: {
        iModelTree: IModelTileTree;
        contentId: string;
    }): {
        tokenProps: IModelRpcProps;
        treeId: string;
        contentId: string;
        guid: string;
    };
    // @internal
    getTilesForUser(user: TileUser): SelectedAndReadyTiles | undefined;
    // @internal
    getTileUserSetForRequest(user: TileUser, users?: ReadonlyTileUserSet): ReadonlyTileUserSet;
    get gpuMemoryLimit(): GpuMemoryLimit;
    set gpuMemoryLimit(limit: GpuMemoryLimit);
    // @internal (undocumented)
    readonly ignoreAreaPatterns: boolean;
    // @internal (undocumented)
    invalidateAllScenes(): void;
    // @internal
    isTileInUse(marker: TileUsageMarker): boolean;
    // @internal
    markTileUsed(marker: TileUsageMarker, user: TileUser): void;
    // @internal (undocumented)
    readonly maximumLevelsToSkip: number;
    // @internal (undocumented)
    readonly maximumMajorTileFormatVersion: number;
    get maxTotalTileContentBytes(): number | undefined;
    // @internal (undocumented)
    readonly minimumSpatialTolerance: number;
    // @internal (undocumented)
    readonly mobileRealityTileMinToleranceRatio: number;
    // @internal (undocumented)
    onShutDown(): void;
    readonly onTileChildrenLoad: BeEvent<(parentTile: Tile) => void>;
    // @internal
    onTileContentDisposed(tile: Tile): void;
    // @internal
    onTileContentLoaded(tile: Tile): void;
    readonly onTileLoad: BeEvent<(tile: Tile) => void>;
    // @internal (undocumented)
    onTilesElided(numElided: number): void;
    readonly onTileTreeLoad: BeEvent<(tileTree: TileTreeOwner) => void>;
    // @internal (undocumented)
    readonly optimizeBRepProcessing: boolean;
    // @internal
    process(): void;
    // @internal
    purgeTileTrees(iModel: IModelConnection, modelIds: Id64Array | undefined): Promise<void>;
    queryVersionInfo(): Promise<Readonly<TileVersionInfo>>;
    registerUser(user: TileUser): void;
    // @internal (undocumented)
    requestCachedTileContent(tile: {
        iModelTree: IModelTileTree;
        contentId: string;
    }): Promise<Uint8Array | undefined>;
    requestElementGraphics(iModel: IModelConnection, requestProps: ElementGraphicsRequestProps): Promise<Uint8Array | undefined>;
    // @internal
    requestTiles(user: TileUser, tiles: Set<Tile>): void;
    // @internal (undocumented)
    requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<IModelTileTreeProps>;
    resetStatistics(): void;
    // @alpha
    get selectedLoadedTiles(): Iterable<Tile>;
    get statistics(): TileAdmin.Statistics;
    // @internal (undocumented)
    terminateTileTreePropsRequest(request: TileTreePropsRequest): void;
    // @internal (undocumented)
    readonly tileExpirationTime: BeDuration;
    // @internal (undocumented)
    readonly tileTreeExpirationTime: BeDuration;
    // @alpha
    get tileUsers(): Iterable<TileUser>;
    get totalTileContentBytes(): number;
    // @alpha
    get unselectedLoadedTiles(): Iterable<Tile>;
    // @internal (undocumented)
    readonly useLargerTiles: boolean;
    // @internal (undocumented)
    readonly useProjectExtents: boolean;
}

// @public (undocumented)
export namespace TileAdmin {
    export interface Props {
        alwaysRequestEdges?: boolean;
        // @internal
        alwaysSubdivideIncompleteTiles?: boolean;
        // @internal
        cacheTileMetadata?: boolean;
        cesiumIonKey?: string;
        // @alpha
        contextPreloadParentDepth?: number;
        // @alpha
        contextPreloadParentSkip?: number;
        defaultTileSizeModifier?: number;
        // @alpha
        disableMagnification?: boolean;
        enableExternalTextures?: boolean;
        enableFrontendScheduleScripts?: boolean;
        enableImprovedElision?: boolean;
        enableIndexedEdges?: boolean;
        enableInstancing?: boolean;
        // @beta
        generateAllPolyfaceEdges?: boolean;
        gpuMemoryLimits?: GpuMemoryLimit | GpuMemoryLimits;
        ignoreAreaPatterns?: boolean;
        // @internal
        ignoreMinimumExpirationTimes?: boolean;
        // @alpha
        maxActiveTileTreePropsRequests?: number;
        // @alpha
        maximumLevelsToSkip?: number;
        // @internal
        maximumMajorTileFormatVersion?: number;
        minimumSpatialTolerance?: number;
        mobileRealityTileMinToleranceRatio?: number;
        // @internal
        optimizeBRepProcessing?: boolean;
        retryInterval?: number;
        tileExpirationTime?: number;
        // @beta
        tileStorage?: FrontendStorage;
        tileTreeExpirationTime?: number;
        useLargerTiles?: boolean;
        // @internal
        useProjectExtents?: boolean;
    }
    export interface Statistics {
        numActiveRequests: number;
        numActiveTileTreePropsRequests: number;
        numCanceled: number;
        numPendingRequests: number;
        numPendingTileTreePropsRequests: number;
        totalAbortedRequests: number;
        totalCacheMisses: number;
        totalCompletedRequests: number;
        totalDispatchedRequests: number;
        totalElidedTiles: number;
        totalEmptyTiles: number;
        totalFailedRequests: number;
        totalTimedOutRequests: number;
        totalUndisplayableTiles: number;
    }
    const nonMobileGpuMemoryLimits: {
        default: number;
        aggressive: number;
        relaxed: number;
    };
    const mobileGpuMemoryLimits: {
        default: number;
        aggressive: number;
        relaxed: number;
    };
}

// @internal (undocumented)
export class TileAvailability {
    constructor(_tilingScheme: MapTilingScheme, _maximumLevel: number);
    addAvailableTileRange(level: number, startX: number, startY: number, endX: number, endY: number): void;
    // (undocumented)
    computeMaximumLevelAtPosition(position: Cartographic): number;
    // (undocumented)
    findNode(level: number, x: number, y: number, nodes: QuadTreeNode[]): boolean;
    isTileAvailable(level: number, x: number, y: number): boolean;
    // (undocumented)
    static rectangleScratch: MapCartoRectangle;
}

// @public
export enum TileBoundingBoxes {
    Both = 3,
    ChildVolumes = 4,
    Content = 2,
    None = 0,
    Sphere = 5,
    Volume = 1
}

// @public
export interface TileContent {
    contentRange?: ElementAlignedBox3d;
    graphic?: RenderGraphic;
    isLeaf?: boolean;
}

// @public
export interface TiledGraphicsProvider {
    addToScene?: (context: SceneContext) => void;
    forEachTileTreeRef(viewport: Viewport, func: (ref: TileTreeReference) => void): void;
    isLoadingComplete?: (viewport: Viewport) => boolean;
}

// @public (undocumented)
export namespace TiledGraphicsProvider {
    // @internal
    export function addToScene(provider: TiledGraphicsProvider, context: SceneContext): void;
    // @internal
    export function isLoadingComplete(provider: TiledGraphicsProvider, viewport: Viewport): boolean;
}

// @public
export interface TileDrawArgParams {
    // @internal
    animationTransformNodeId?: number;
    appearanceProvider?: FeatureAppearanceProvider;
    boundingRange?: Range3d;
    clipVolume?: RenderClipVolume;
    context: SceneContext;
    hiddenLineSettings?: HiddenLine.Settings;
    intersectionClip?: ClipVector;
    location: Transform;
    // @alpha (undocumented)
    maximumScreenSpaceError?: number;
    now: BeTimePoint;
    parentsAndChildrenExclusive: boolean;
    symbologyOverrides: FeatureSymbology.Overrides | undefined;
    tree: TileTree;
    viewFlagOverrides: ViewFlagOverrides;
}

// @public
export class TileDrawArgs {
    constructor(params: TileDrawArgParams);
    addAppearanceProvider(provider: FeatureAppearanceProvider): void;
    // @internal (undocumented)
    readonly animationTransformNodeId?: number;
    get appearanceProvider(): FeatureAppearanceProvider | undefined;
    boundingRange?: Range3d;
    // @internal (undocumented)
    get clip(): ClipVector | undefined;
    clipVolume: RenderClipVolume | undefined;
    computePixelSizeInMetersAtClosestPoint(center: Point3d, radius: number): number;
    readonly context: SceneContext;
    // @internal (undocumented)
    drape?: RenderTextureDrape;
    drawGraphics(): void;
    drawGraphicsWithType(graphicType: TileGraphicType, graphics: GraphicBranch): void;
    get frustumPlanes(): FrustumPlanes;
    protected _frustumPlanes?: FrustumPlanes;
    getPixelSize(tile: Tile): number;
    getPixelSizeInMetersAtClosestPoint(tile: Tile): number;
    getRangePixelSize(range: Range3d): number;
    // @internal (undocumented)
    getTileCenter(tile: Tile): Point3d;
    // @internal (undocumented)
    getTileGraphics(tile: Tile): RenderGraphic | undefined;
    // @internal (undocumented)
    getTileRadius(tile: Tile): number;
    readonly graphics: GraphicBranch;
    hiddenLineSettings?: HiddenLine.Settings;
    insertMissing(tile: Tile): void;
    intersectionClip?: ClipVector;
    readonly location: Transform;
    markChildrenLoading(): void;
    markReady(tile: Tile): void;
    markUsed(tile: Tile): void;
    // @alpha (undocumented)
    maximumScreenSpaceError: number;
    // (undocumented)
    get maxRealityTreeSelectionCount(): number | undefined;
    // @internal (undocumented)
    readonly now: BeTimePoint;
    parentsAndChildrenExclusive: boolean;
    // @internal (undocumented)
    readonly pixelSizeScaleFactor: number;
    // @internal (undocumented)
    planarClassifier?: RenderPlanarClassifier;
    // @internal
    processSelectedTiles(_tiles: Tile[]): void;
    // @internal (undocumented)
    produceGraphics(): RenderGraphic | undefined;
    readonly readyTiles: Set<Tile>;
    // @internal (undocumented)
    get secondaryClassifiers(): Map<number, RenderPlanarClassifier> | undefined;
    get symbologyOverrides(): FeatureSymbology.Overrides | undefined;
    get tileSizeModifier(): number;
    readonly tree: TileTree;
    readonly viewClip?: ClipVector;
    get viewFlagOverrides(): ViewFlagOverrides;
    viewingSpace: ViewingSpace;
    get worldToViewMap(): Map4d;
}

// @beta
export class TileGeometryCollector {
    constructor(options: TileGeometryCollectorOptions);
    addMissingTile(tile: Tile): void;
    collectTile(tile: Tile): CollectTileStatus;
    get isAllGeometryLoaded(): boolean;
    markLoading(): void;
    protected readonly _options: TileGeometryCollectorOptions;
    readonly polyfaces: Polyface[];
    requestMissingTiles(): void;
}

// @beta
export interface TileGeometryCollectorOptions {
    chordTolerance: number;
    range: Range3d;
    transform?: Transform;
    user: TileUser;
}

// @public
export enum TileGraphicType {
    BackgroundMap = 0,
    Overlay = 2,
    Scene = 1
}

// @public
export enum TileLoadPriority {
    Classifier = 50,
    Context = 40,
    Dynamic = 5,
    Map = 15,
    Primary = 20,
    Terrain = 10
}

// @public
export enum TileLoadStatus {
    Abandoned = 5,
    Loading = 2,
    NotFound = 4,
    NotLoaded = 0,
    Queued = 1,
    Ready = 3
}

// @public
export interface TileParams {
    contentId: string;
    contentRange?: ElementAlignedBox3d;
    isLeaf?: boolean;
    maximumSize: number;
    parent?: Tile;
    range: ElementAlignedBox3d;
}

// @internal (undocumented)
export type TilePatch = PlanarTilePatch | EllipsoidPatch;

// @public
export class TileRequest {
    constructor(tile: Tile, user: TileUser);
    // @internal
    addUser(user: TileUser): void;
    // @internal
    cancel(): void;
    readonly channel: TileRequestChannel;
    // @internal
    dispatch(onHttpResponse: () => void): Promise<void>;
    get isCanceled(): boolean;
    get isQueued(): boolean;
    priority: number;
    get state(): TileRequest.State;
    readonly tile: Tile;
    get tree(): TileTree;
    // @internal
    users: ReadonlyTileUserSet;
    get viewports(): Iterable<Viewport>;
}

// @public (undocumented)
export namespace TileRequest {
    export type Response = Uint8Array | ArrayBuffer | string | ImageSource | {
        content: TileContent;
    } | {
        data: any;
    } | undefined;
    export type ResponseData = Uint8Array | ImageSource | {
        data: any;
    };
    export enum State {
        Completed = 3,
        Dispatched = 1,
        Failed = 4,
        Loading = 2,
        Queued = 0
    }
}

// @public
export class TileRequestChannel {
    constructor(name: string, concurrency: number);
    // @internal
    protected readonly _active: Set<TileRequest>;
    // @internal
    append(request: TileRequest): void;
    // @internal
    protected cancel(request: TileRequest): void;
    // @internal
    cancelAndClearAll(): void;
    get concurrency(): number;
    set concurrency(max: number);
    // @internal
    contentCallback?: (tile: Tile, content: TileContent) => void;
    // @internal
    protected dispatch(request: TileRequest): void;
    // @internal
    protected dropActiveRequest(request: TileRequest): void;
    readonly name: string;
    get numActive(): number;
    get numPending(): number;
    onActiveRequestCanceled(_request: TileRequest): void;
    onIModelClosed(_iModel: IModelConnection): void;
    onNoContent(_request: TileRequest): boolean;
    // @internal
    process(): void;
    processCancellations(): void;
    // @internal
    recordCompletion(tile: Tile, content: TileContent): void;
    // @internal
    recordFailure(): void;
    // @internal
    recordTimeout(): void;
    requestContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    resetStatistics(): void;
    get size(): number;
    get statistics(): Readonly<TileRequestChannelStatistics>;
    // (undocumented)
    protected _statistics: TileRequestChannelStatistics;
    // @internal
    swapPending(): void;
}

// @public
export class TileRequestChannels {
    [Symbol.iterator](): Iterator<TileRequestChannel>;
    // @internal
    constructor(rpcConcurrency: number | undefined, cacheMetadata: boolean);
    add(channel: TileRequestChannel): void;
    readonly elementGraphicsRpc: TileRequestChannel;
    get(name: string): TileRequestChannel | undefined;
    getForHttp(name: string): TileRequestChannel;
    // @internal (undocumented)
    getIModelTileChannel(tile: IModelTile): TileRequestChannel;
    static getNameFromUrl(url: URL | string): string;
    has(channel: TileRequestChannel): boolean;
    readonly httpConcurrency = 6;
    // @internal (undocumented)
    readonly iModelChannels: IModelTileRequestChannels;
    // @internal
    onIModelClosed(iModel: IModelConnection): void;
    // @internal
    onShutDown(): void;
    // @internal
    process(): void;
    resetStatistics(): void;
    get rpcConcurrency(): number;
    // @internal
    setRpcConcurrency(concurrency: number): void;
    get size(): number;
    get statistics(): TileRequestChannelStatistics;
    // @internal
    swapPending(): void;
}

// @public
export class TileRequestChannelStatistics {
    // @internal (undocumented)
    addTo(stats: TileRequestChannelStatistics): void;
    numActiveRequests: number;
    numCanceled: number;
    numPendingRequests: number;
    totalAbortedRequests: number;
    totalCacheMisses: number;
    totalCompletedRequests: number;
    totalDispatchedRequests: number;
    totalEmptyTiles: number;
    totalFailedRequests: number;
    totalTimedOutRequests: number;
    totalUndisplayableTiles: number;
}

// @public
export class Tiles implements Iterable<{
    supplier: TileTreeSupplier;
    id: any;
    owner: TileTreeOwner;
}> {
    [Symbol.iterator](): Iterator<{
        supplier: TileTreeSupplier;
        id: any;
        owner: TileTreeOwner;
    }>;
    // @internal
    constructor(iModel: IModelConnection);
    // @internal (undocumented)
    dispose(): void;
    dropSupplier(supplier: TileTreeSupplier): void;
    forEachTreeOwner(func: (owner: TileTreeOwner) => void): void;
    getTileTreeOwner(id: any, supplier: TileTreeSupplier): TileTreeOwner;
    getTreeOwnersForSupplier(supplier: TileTreeSupplier): Iterable<{
        id: any;
        owner: TileTreeOwner;
    }>;
    // @internal (undocumented)
    get isDisposed(): boolean;
    // @internal
    purge(olderThan: BeTimePoint, exclude?: Set<TileTree>): void;
    // @internal (undocumented)
    purgeTileTrees(modelIds: Id64Array | undefined): Promise<void>;
    // @internal
    reset(): void;
    // @internal
    resetTileTreeOwner(id: any, supplier: TileTreeSupplier): void;
    updateForScheduleScript(scriptSourceElementId: Id64String): Promise<void>;
}

// @beta (undocumented)
export class TileStorage {
    constructor(storage: FrontendStorage);
    // (undocumented)
    downloadTile(tokenProps: IModelRpcProps, iModelId: string, changesetId: string, treeId: string, contentId: string, guid?: string): Promise<Uint8Array | undefined>;
    // (undocumented)
    readonly storage: FrontendStorage;
}

// @public
export abstract class TileTree {
    protected constructor(params: TileTreeParams);
    // @internal (undocumented)
    accumulateTransformedRange(range: Range3d, matrix: Matrix4d, location: Transform, frustumPlanes?: FrustumPlanes): void;
    // @internal (undocumented)
    get clipVolume(): RenderClipVolume | undefined;
    // @internal (undocumented)
    protected _clipVolume?: RenderClipVolume;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // @beta
    collectTileGeometry(_collector: TileGeometryCollector): void;
    readonly contentRange?: ElementAlignedBox3d;
    countTiles(): number;
    dispose(): void;
    abstract draw(args: TileDrawArgs): void;
    readonly expirationTime: BeDuration;
    // @beta
    getEcefTransform(): Promise<Transform | undefined>;
    readonly id: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    readonly iModelTransform: Transform;
    get is2d(): boolean;
    abstract get is3d(): boolean;
    get isContentUnbounded(): boolean;
    get isDisposed(): boolean;
    // @internal (undocumented)
    get isPointCloud(): boolean;
    // @internal (undocumented)
    protected _lastSelected: BeTimePoint;
    get lastSelectedTime(): BeTimePoint;
    // @internal (undocumented)
    get loadPriority(): TileLoadPriority;
    abstract get maxDepth(): number | undefined;
    readonly modelId: Id64String;
    get parentsAndChildrenExclusive(): boolean;
    abstract prune(): void;
    get range(): ElementAlignedBox3d;
    abstract get rootTile(): Tile;
    selectTiles(args: TileDrawArgs): Tile[];
    protected abstract _selectTiles(args: TileDrawArgs): Tile[];
    abstract get viewFlagOverrides(): ViewFlagOverrides;
}

// @public
export interface TileTreeDiscloser {
    discloseTileTrees: (trees: DisclosedTileTreeSet) => void;
}

// @public
export enum TileTreeLoadStatus {
    Loaded = 2,
    Loading = 1,
    NotFound = 3,
    NotLoaded = 0
}

// @public
export interface TileTreeOwner {
    // @internal
    dispose(): void;
    readonly iModel: IModelConnection;
    load(): TileTree | undefined;
    readonly loadStatus: TileTreeLoadStatus;
    loadTree(): Promise<TileTree | undefined>;
    readonly tileTree: TileTree | undefined;
}

// @public
export interface TileTreeParams {
    clipVolume?: RenderClipVolume;
    contentRange?: ElementAlignedBox3d;
    expirationTime?: BeDuration;
    id: string;
    iModel: IModelConnection;
    location: Transform;
    modelId: Id64String;
    priority: TileLoadPriority;
}

// @public
export abstract class TileTreeReference {
    // (undocumented)
    accumulateTransformedRange(range: Range3d, matrix: Matrix4d, frustumPlanes?: FrustumPlanes): void;
    addLogoCards(_cards: HTMLTableElement, _vp: ScreenViewport): void;
    addToScene(context: SceneContext): void;
    get castsShadows(): boolean;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // @beta
    collectTileGeometry?: (collector: TileGeometryCollector) => void;
    // @beta
    protected _collectTileGeometry(collector: TileGeometryCollector): void;
    protected computeTransform(tree: TileTree): Transform;
    computeWorldContentRange(): ElementAlignedBox3d;
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
    // @beta
    createGeometryTreeReference(): GeometryTileTreeReference | undefined;
    // @beta
    protected _createGeometryTreeReference(): GeometryTileTreeReference | undefined;
    decorate(_context: DecorateContext): void;
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    draw(args: TileDrawArgs): void;
    // @internal (undocumented)
    protected getAnimationTransformNodeId(_tree: TileTree): number | undefined;
    protected getAppearanceProvider(_tree: TileTree): FeatureAppearanceProvider | undefined;
    protected getClipVolume(tree: TileTree): RenderClipVolume | undefined;
    protected getHiddenLineSettings(_tree: TileTree): HiddenLine.Settings | undefined;
    getLocation(): Transform | undefined;
    // @alpha
    getMapFeatureInfo(_hit: HitDetail): Promise<MapLayerFeatureInfo[] | undefined>;
    protected getSymbologyOverrides(_tree: TileTree): FeatureSymbology.Overrides | undefined;
    // @internal (undocumented)
    getTerrainHeight(_terrainHeights: Range1d): void;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string | undefined>;
    protected getViewFlagOverrides(tree: TileTree): ViewFlagOverrides;
    get isGlobal(): boolean;
    get isLoadingComplete(): boolean;
    protected get _isLoadingComplete(): boolean;
    // @alpha
    get planarclipMaskPriority(): number;
    // @internal
    resetTreeOwner(): void;
    abstract get treeOwner(): TileTreeOwner;
    unionFitRange(union: Range3d): void;
}

// @public
export interface TileTreeSupplier {
    // @internal
    addModelsAnimatedByScript?: (modelIds: Set<Id64String>, scriptSourceId: Id64String, trees: Iterable<{
        id: any;
        owner: TileTreeOwner;
    }>) => void;
    // @internal
    addSpatialModels?: (modelIds: Set<Id64String>, trees: Iterable<{
        id: any;
        owner: TileTreeOwner;
    }>) => void;
    compareTileTreeIds(lhs: any, rhs: any): number;
    createTileTree(id: any, iModel: IModelConnection): Promise<TileTree | undefined>;
    readonly isEcefDependent?: true;
}

// @internal
export class TileUrlImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, level: number): Promise<string>;
    // (undocumented)
    static validateUrlTemplate(template: string): MapLayerSourceValidation;
}

// @public
export class TileUsageMarker {
    constructor();
    isExpired(expirationTime: BeTimePoint): boolean;
    mark(user: TileUser, time: BeTimePoint): void;
}

// @public
export interface TileUser {
    readonly discloseTileTrees: (trees: DisclosedTileTreeSet) => void;
    readonly iModel: IModelConnection;
    readonly onRequestStateChanged?: (req: TileRequest) => void;
    readonly tileUserId: number;
}

// @public (undocumented)
export namespace TileUser {
    // (undocumented)
    export function generateId(): number;
    export function viewportsFromUsers(users: Iterable<TileUser>): Iterable<Viewport>;
}

// @internal
export class TileUserIdSet extends ReadonlySortedArray<number> {
    constructor(userId?: number);
    // (undocumented)
    add(userId: number): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    clone(): TileUserIdSet;
    // (undocumented)
    copyFrom(src: TileUserIdSet): void;
    // (undocumented)
    drop(userId: number): void;
    // (undocumented)
    equals(set: TileUserIdSet): boolean;
}

// @internal
export class TileUserIdSets extends SortedArray<TileUserIdSet> {
    constructor();
    drop(userId: number): void;
    minus(userId: number, userIds?: TileUserIdSet): TileUserIdSet | undefined;
    plus(userId: number, userIds?: TileUserIdSet): TileUserIdSet;
}

// @public
export enum TileVisibility {
    OutsideFrustum = 0,
    TooCoarse = 1,
    Visible = 2
}

// @beta
export interface TokenArg {
    // (undocumented)
    accessToken?: AccessToken;
}

// @public
export class Tool {
    constructor(..._args: any[]);
    // @internal (undocumented)
    get ctor(): typeof Tool;
    static get description(): string;
    get description(): string;
    static get englishKeyin(): string;
    static get flyover(): string;
    get flyover(): string;
    static hidden: boolean;
    static iconSpec: string;
    get iconSpec(): string;
    static get keyin(): string;
    get keyin(): string;
    static get maxArgs(): number | undefined;
    static get minArgs(): number;
    static namespace: string;
    parseAndRun(..._args: string[]): Promise<boolean>;
    static register(namespace?: string): void;
    run(..._args: any[]): Promise<boolean>;
    static toolId: string;
    get toolId(): string;
}

// @public
export class ToolAdmin {
    acsContextLock: boolean;
    acsPlaneSnapLock: boolean;
    get activeTool(): InteractiveTool | undefined;
    readonly activeToolChanged: BeEvent<(tool: Tool, start: StartOrResume) => void>;
    // @internal
    static addEvent(ev: Event, vp?: ScreenViewport): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, projectToACS?: boolean, applyLocks?: boolean): void;
    // (undocumented)
    adjustPointToACS(pointActive: Point3d, vp: Viewport, perpendicular: boolean): void;
    // (undocumented)
    adjustPointToGrid(pointActive: Point3d, vp: Viewport): void;
    // (undocumented)
    adjustSnapPoint(perpendicular?: boolean): void;
    assemblyLock: boolean;
    // @internal (undocumented)
    beginDynamics(): void;
    // @beta
    bumpToolSetting(settingIndex?: number): Promise<boolean>;
    // @internal (undocumented)
    callOnCleanup(): Promise<void>;
    convertTouchEndToButtonUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveStartToButtonDownAndMotion(startEv: BeTouchEvent, ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveToMotion(ev: BeTouchEvent): Promise<void>;
    convertTouchStartToButtonDown(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchTapToButtonDownAndUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    // @internal (undocumented)
    readonly currentInputState: CurrentInputState;
    get currentTool(): InteractiveTool;
    get cursorView(): ScreenViewport | undefined;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    get defaultToolArgs(): any[] | undefined;
    set defaultToolArgs(args: any[] | undefined);
    get defaultToolId(): string;
    set defaultToolId(toolId: string);
    // @beta
    dispatchImmediateUiSyncEvent(specificSyncEventId?: string, toolId?: string): void;
    // @beta
    dispatchUiSyncEvent(specificSyncEventId?: string, toolId?: string): void;
    doRedoOperation(): Promise<boolean>;
    doUndoOperation(): Promise<boolean>;
    // @internal (undocumented)
    endDynamics(): void;
    static exceptionHandler(exception: any): Promise<any>;
    static exceptionOptions: {
        log: boolean;
        alertBox: boolean;
        details: boolean;
        launchDebugger: boolean;
    };
    // @internal (undocumented)
    exitInputCollector(): Promise<void>;
    // @internal (undocumented)
    exitViewTool(): Promise<void>;
    // @internal (undocumented)
    fillEventFromCursorLocation(ev: BeButtonEvent): void;
    // @internal (undocumented)
    fillEventFromLastDataButton(ev: BeButtonEvent): void;
    protected filterViewport(vp: ScreenViewport): boolean;
    // @internal
    forgetViewport(vp: ScreenViewport): void;
    // @internal (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    gridLock: boolean;
    get idleTool(): InteractiveTool;
    set idleTool(idleTool: InteractiveTool);
    // (undocumented)
    get isLocateCircleOn(): boolean;
    readonly manipulatorToolEvent: BeEvent<(tool: Tool, event: ManipulatorToolEvent) => void>;
    // (undocumented)
    markupView?: ScreenViewport;
    onCtrlKeyPressed(keyEvent: KeyboardEvent): Promise<{
        handled: boolean;
        result: boolean;
    }>;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onInstallTool(tool: InteractiveTool): Promise<boolean>;
    // @internal (undocumented)
    onMouseLeave(vp: ScreenViewport): void;
    // @internal (undocumented)
    onPostInstallTool(tool: InteractiveTool): Promise<void>;
    // @internal (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): Promise<void>;
    // @internal (undocumented)
    onShutDown(): void;
    // (undocumented)
    get primitiveTool(): PrimitiveTool | undefined;
    // @internal
    processEvent(): Promise<void>;
    processShortcutKey(_keyEvent: KeyboardEvent, _wentDown: boolean): Promise<boolean>;
    processWheelEvent(ev: BeWheelEvent, doUpdate: boolean): Promise<EventHandled>;
    // @internal
    get reloadToolSettingsHandler(): (() => void) | undefined;
    set reloadToolSettingsHandler(handler: (() => void) | undefined);
    // @beta
    reloadToolSettingsProperties(): void;
    // @internal (undocumented)
    sendButtonEvent(ev: BeButtonEvent): Promise<any>;
    // (undocumented)
    sendEndDragEvent(ev: BeButtonEvent): Promise<any>;
    // @internal (undocumented)
    setAdjustedDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    setCursor(cursor: string | undefined): void;
    // @internal (undocumented)
    setIncompatibleViewportCursor(restore: boolean): void;
    // @internal (undocumented)
    setInputCollector(newTool?: InputCollector): Promise<void>;
    // (undocumented)
    setLocateCircleOn(locateOn: boolean): void;
    // (undocumented)
    setLocateCursor(enableLocate: boolean): void;
    // @internal (undocumented)
    setPrimitiveTool(newTool?: PrimitiveTool): Promise<void>;
    // @internal (undocumented)
    setViewTool(newTool?: ViewTool): Promise<void>;
    startDefaultTool(): Promise<void>;
    // @internal (undocumented)
    startInputCollector(newTool: InputCollector): Promise<void>;
    // @internal (undocumented)
    startPrimitiveTool(newTool?: PrimitiveTool): Promise<void>;
    // @internal (undocumented)
    startViewTool(newTool: ViewTool): Promise<void>;
    // @beta
    syncToolSettingsProperties(toolId: string, syncProperties: DialogPropertySyncItem[]): void;
    // @internal (undocumented)
    testDecorationHit(id: string): boolean;
    // @internal
    get toolSettingsChangeHandler(): ((toolId: string, syncProperties: DialogPropertySyncItem[]) => void) | undefined;
    set toolSettingsChangeHandler(handler: ((toolId: string, syncProperties: DialogPropertySyncItem[]) => void) | undefined);
    // @internal (undocumented)
    readonly toolSettingsState: ToolSettingsState;
    // @internal (undocumented)
    readonly toolState: ToolState;
    // @internal
    get toolSyncUiEventDispatcher(): ((syncEventId: string, useImmediateDispatch?: boolean) => void) | undefined;
    set toolSyncUiEventDispatcher(handler: ((syncEventId: string, useImmediateDispatch?: boolean) => void) | undefined);
    // @internal (undocumented)
    updateDynamics(ev?: BeButtonEvent, useLastData?: boolean, adjustPoint?: boolean): void;
    // (undocumented)
    get viewTool(): ViewTool | undefined;
}

// @public
export class ToolAssistance {
    static get altKey(): string;
    static get altKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly altSymbol: string;
    static get altSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly arrowKeyboardInfo: ToolAssistanceKeyboardInfo;
    static createInstruction(image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod, keyboardInfo?: ToolAssistanceKeyboardInfo): ToolAssistanceInstruction;
    static createInstructions(mainInstruction: ToolAssistanceInstruction, sections?: ToolAssistanceSection[]): ToolAssistanceInstructions;
    static createKeyboardInfo(keys: string[], bottomKeys?: string[]): ToolAssistanceKeyboardInfo;
    static createKeyboardInstruction(keyboardInfo: ToolAssistanceKeyboardInfo, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createModifierKeyInstruction(modifierKey: string, image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createSection(instructions: ToolAssistanceInstruction[], label?: string): ToolAssistanceSection;
    static createTouchCursorInstructions(instructions: ToolAssistanceInstruction[]): boolean;
    static get ctrlKey(): string;
    static get ctrlKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly ctrlSymbol: string;
    static get ctrlSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly downSymbol: string;
    static get inputsLabel(): string;
    static readonly leftSymbol: string;
    static readonly rightSymbol: string;
    static get shiftKey(): string;
    static get shiftKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static get shiftKeyboardInfoNoSymbol(): ToolAssistanceKeyboardInfo;
    static readonly shiftSymbol: string;
    static get shiftSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly upSymbol: string;
}

// @public
export enum ToolAssistanceImage {
    AcceptPoint = 1,
    CursorClick = 2,
    Keyboard = 0,
    LeftClick = 3,
    LeftClickDrag = 6,
    MouseWheel = 5,
    MouseWheelClickDrag = 8,
    OneTouchDoubleTap = 10,
    OneTouchDrag = 11,
    OneTouchTap = 9,
    RightClick = 4,
    RightClickDrag = 7,
    TouchCursorDrag = 16,
    TouchCursorTap = 15,
    TwoTouchDrag = 13,
    TwoTouchPinch = 14,
    TwoTouchTap = 12
}

// @public
export enum ToolAssistanceInputMethod {
    Both = 0,
    Mouse = 1,
    Touch = 2
}

// @public
export interface ToolAssistanceInstruction {
    image: string | ToolAssistanceImage;
    inputMethod?: ToolAssistanceInputMethod;
    isNew?: boolean;
    keyboardInfo?: ToolAssistanceKeyboardInfo;
    text: string;
}

// @public
export interface ToolAssistanceInstructions {
    mainInstruction: ToolAssistanceInstruction;
    sections?: ToolAssistanceSection[];
}

// @public
export interface ToolAssistanceKeyboardInfo {
    bottomKeys?: string[];
    keys: string[];
}

// @public
export interface ToolAssistanceSection {
    instructions: ToolAssistanceInstruction[];
    label?: string;
}

// @public (undocumented)
export type ToolList = ToolType[];

// @public
export class ToolRegistry {
    create(toolId: string, ...args: any[]): Tool | undefined;
    find(toolId: string): ToolType | undefined;
    findExactMatch(keyin: string): ToolType | undefined;
    findPartialMatches(keyin: string): FuzzySearchResults<ToolType>;
    getToolList(): ToolList;
    parseAndRun(keyin: string): Promise<ParseAndRunResult>;
    parseKeyin(keyin: string): ParseKeyinResult;
    register(toolClass: ToolType, namespace?: string): void;
    registerModule(moduleObj: any, namespace?: string): void;
    run(toolId: string, ...args: any[]): Promise<boolean>;
    // (undocumented)
    shutdown(): void;
    // (undocumented)
    readonly tools: Map<string, typeof Tool>;
    unRegister(toolId: string): void;
}

// @public
export class ToolSettings {
    static doubleClickTimeout: BeDuration;
    static doubleClickToleranceInches: number;
    static doubleTapTimeout: BeDuration;
    // @beta
    static enableVirtualCursorForLocate: boolean;
    static maxOnMotionSnapCallPerSecond: number;
    static preserveWorldUp: boolean;
    static scrollSpeed: number;
    static startDragDelay: BeDuration;
    static startDragDistanceInches: number;
    static touchMoveDelay: BeDuration;
    static touchMoveDistanceInches: number;
    static touchZoomChangeThresholdInches: number;
    static viewingInertia: {
        enabled: boolean;
        damping: number;
        duration: BeDuration;
    };
    static viewToolPickRadiusInches: number;
    static walkCameraAngle: Angle;
    // @beta
    static walkCollisions: boolean;
    // @beta
    static walkDetectFloor: boolean;
    static walkEnforceZUp: boolean;
    // @beta
    static walkEyeHeight: number;
    static walkRequestPointerLock: boolean;
    // @beta
    static walkStepHeight: number;
    static walkVelocity: number;
    // @beta
    static walkVelocityChange: number;
    static wheelLineFactor: number;
    static wheelPageFactor: number;
    static wheelZoomBumpDistance: number;
    static wheelZoomRatio: number;
    static zoomSpeed: number;
}

// @internal
export class ToolSettingsState {
    getInitialToolSettingValue(toolId: string, propertyName: string): DialogItemValue | undefined;
    getInitialToolSettingValues(toolId: string, propertyNames: string[]): DialogPropertyItem[] | undefined;
    saveToolSettingProperties(toolId: string, tsProps: DialogPropertyItem[]): void;
    saveToolSettingProperty(toolId: string, item: DialogPropertyItem): void;
}

// @internal (undocumented)
export class ToolState {
    // (undocumented)
    clone(): ToolState;
    // (undocumented)
    coordLockOvr: CoordinateLockOverrides;
    // (undocumented)
    locateCircleOn: boolean;
    // (undocumented)
    setFrom(other: ToolState): void;
}

// @public
export interface ToolTipOptions {
    // (undocumented)
    duration?: BeDuration;
    // (undocumented)
    placement?: string;
}

// @internal
export interface ToolTipProvider {
    augmentToolTip(hit: HitDetail, tooltip: Promise<HTMLElement | string>): Promise<HTMLElement | string>;
}

// @public (undocumented)
export type ToolType = typeof Tool;

// @internal
export class TouchCursor implements CanvasDecoration {
    protected constructor(vp: ScreenViewport);
    // (undocumented)
    static createFromTouchTap(ev: BeTouchEvent): TouchCursor | undefined;
    // (undocumented)
    doTouchEnd(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchMove(ev: BeTouchEvent): boolean;
    // (undocumented)
    doTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // (undocumented)
    doTouchStart(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    protected drawHandle(ctx: CanvasRenderingContext2D, filled: boolean): void;
    // (undocumented)
    protected _inTouchTap: boolean;
    // (undocumented)
    isButtonHandled(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _isDragging: boolean;
    // (undocumented)
    protected isSelected(pt: XAndY): boolean;
    // (undocumented)
    protected _isSelected: boolean;
    // (undocumented)
    protected _offsetPosition: Point3d;
    // (undocumented)
    position: Point3d;
    // (undocumented)
    protected setPosition(vp: Viewport, worldLocation: Point3d): boolean;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    viewport: Viewport;
    // (undocumented)
    protected _yOffset: number;
}

// @internal (undocumented)
export class TraversalChildrenDetails {
    // (undocumented)
    combine(parentDetails: TraversalDetails): void;
    // (undocumented)
    getChildDetail(index: number): TraversalDetails;
    // (undocumented)
    initialize(): void;
}

// @internal (undocumented)
export class TraversalDetails {
    // (undocumented)
    childrenLoading: boolean;
    // (undocumented)
    childrenSelected: boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    queuedChildren: Tile[];
}

// @internal (undocumented)
export class TraversalSelectionContext {
    constructor(selected: Tile[], displayedDescendants: Tile[][], preloadDebugBuilder?: GraphicBuilder | undefined, _maxSelectionCount?: number | undefined);
    // (undocumented)
    displayedDescendants: Tile[][];
    // (undocumented)
    missing: RealityTile[];
    // (undocumented)
    preload(tile: RealityTile, args: TileDrawArgs): void;
    // (undocumented)
    preloadDebugBuilder?: GraphicBuilder | undefined;
    // (undocumented)
    preloaded: Set<RealityTile>;
    // (undocumented)
    select(tiles: RealityTile[], args: TileDrawArgs): void;
    // (undocumented)
    selected: Tile[];
    // (undocumented)
    get selectionCountExceeded(): boolean;
    // (undocumented)
    selectOrQueue(tile: RealityTile, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
}

// @public
export function tryImageElementFromUrl(url: string, skipCrossOriginCheck?: boolean): Promise<HTMLImageElement | undefined>;

// @public
export class TwoWayViewportFrustumSync extends TwoWayViewportSync {
    // @internal
    protected connectViewports(source: Viewport, target: Viewport): void;
    // @internal
    protected syncViewports(source: Viewport, target: Viewport): void;
}

// @public
export class TwoWayViewportSync {
    connect(viewport1: Viewport, viewport2: Viewport): void;
    protected connectViewports(source: Viewport, target: Viewport): void;
    disconnect(): void;
    // (undocumented)
    protected readonly _disconnect: VoidFunction[];
    protected syncViewports(source: Viewport, target: Viewport): void;
}

// @public
export interface Uniform {
    setUniform1f: (value: number) => void;
    setUniform1fv: (value: Float32Array | number[]) => void;
    setUniform1i: (value: number) => void;
    setUniform1iv: (value: Int32Array | number[]) => void;
    setUniform2fv: (value: Float32Array | number[]) => void;
    setUniform3fv: (value: Float32Array | number[]) => void;
    setUniform4fv: (value: Float32Array | number[]) => void;
}

// @public
export interface UniformArrayParams extends UniformParams {
    length: number;
}

// @public
export interface UniformContext {
    viewport: Viewport;
}

// @public
export interface UniformParams {
    bind: (uniform: Uniform, context: UniformContext) => void;
    name: string;
    type: UniformType;
}

// @public
export enum UniformType {
    Bool = 0,
    Float = 2,
    Int = 1,
    Vec2 = 3,
    Vec3 = 4,
    Vec4 = 5
}

// @internal
export class UniqueTileUserSets {
    // (undocumented)
    clear(): void;
    // (undocumented)
    clearAll(): void;
    // (undocumented)
    static get emptySet(): ReadonlyTileUserSet;
    // (undocumented)
    getTileUserSet(user: TileUser, users?: ReadonlyTileUserSet): ReadonlyTileUserSet;
    // (undocumented)
    remove(user: TileUser): void;
}

// @public
export interface UnitFormattingSettingsProvider {
    loadOverrides(imodel: IModelConnection | undefined): Promise<void>;
    readonly maintainOverridesPerIModel: boolean;
    remove(quantityTypeKey: QuantityTypeKey): Promise<boolean>;
    retrieve(quantityTypeKey: QuantityTypeKey): Promise<OverrideFormatEntry | undefined>;
    retrieveUnitSystem(defaultKey: UnitSystemKey): Promise<UnitSystemKey>;
    store(quantityTypeKey: QuantityTypeKey, overrideProps: OverrideFormatEntry): Promise<boolean>;
    storeFormatOverrides(args: QuantityFormatOverridesChangedArgs): Promise<void>;
    storeUnitSystemKey(unitSystemKey: UnitSystemKey): Promise<boolean>;
    storeUnitSystemSetting(args: FormattingUnitSystemChangedArgs): Promise<void>;
}

// @public
export type UnitNameKey = string;

// @internal (undocumented)
export class UpsampledMapTile extends MapTile {
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    get isNotFound(): boolean;
    // (undocumented)
    get isQueued(): boolean;
    // (undocumented)
    get isReady(): boolean;
    // (undocumented)
    get isUpsampled(): boolean;
    // (undocumented)
    get loadableTile(): RealityTile;
    // (undocumented)
    markUsed(args: TileDrawArgs): void;
    // (undocumented)
    get renderGeometry(): RenderTerrainGeometry | undefined;
}

// @beta
export interface UserPreferencesAccess {
    delete: (arg: PreferenceKeyArg & ITwinIdArg & TokenArg) => Promise<void>;
    get: (arg: PreferenceKeyArg & ITwinIdArg & TokenArg) => Promise<any>;
    save: (arg: PreferenceArg & ITwinIdArg & TokenArg) => Promise<void>;
}

// @public
export enum VaryingType {
    Float = 0,
    Vec2 = 1,
    Vec3 = 2,
    Vec4 = 3
}

// @public
export interface ViewAnimationOptions {
    animationFinishedCallback?(didComplete: boolean): void;
    animationTime?: number;
    cancelOnAbort?: boolean;
    easingFunction?: EasingFunction;
}

// @public
export interface ViewChangeOptions extends OnViewExtentsError, ViewAnimationOptions {
    animateFrustumChange?: boolean;
    globalAlignment?: GlobalAlignmentOptions;
    noSaveInUndo?: boolean;
}

// @public
export class ViewClipByElementTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _alwaysUseRange?: boolean);
    // (undocumented)
    protected _alwaysUseRange: boolean;
    // (undocumented)
    protected doClipToElements(viewport: Viewport, ids: Id64Arg, alwaysUseRange?: boolean, modelId?: Id64String): Promise<boolean>;
    // @internal (undocumented)
    doClipToSelectedElements(viewport: Viewport): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewClipByPlaneTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _clearExistingPlanes?: boolean);
    // @internal (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): Promise<boolean>;
    // (undocumented)
    protected _clearExistingPlanes: boolean;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    get orientation(): ContextRotationId;
    set orientation(option: ContextRotationId);
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // @internal (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewClipByRangeTool extends ViewClipTool {
    // @internal (undocumented)
    protected _corner?: Point3d;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipRange(range: Range3d, transform: Transform, ev: BeButtonEvent): boolean;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewClipByShapeTool extends ViewClipTool {
    // @internal (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): Promise<boolean>;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipPoints(ev: BeButtonEvent): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    // @internal (undocumented)
    protected _matrix?: Matrix3d;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    get orientation(): ContextRotationId;
    set orientation(option: ContextRotationId);
    // @internal (undocumented)
    protected readonly _points: Point3d[];
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // @internal (undocumented)
    protected showPrompt(): void;
    // @internal (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // @internal (undocumented)
    protected _zHigh?: number;
    // @internal (undocumented)
    protected _zLow?: number;
}

// @public
export class ViewClipClearTool extends ViewClipTool {
    // (undocumented)
    protected doClipClear(viewport: Viewport): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @internal
export class ViewClipControlArrow {
    constructor(origin: Point3d, direction: Vector3d, sizeInches: number, fill?: ColorDef, outline?: ColorDef, name?: string);
    // (undocumented)
    direction: Vector3d;
    // (undocumented)
    fill?: ColorDef;
    // (undocumented)
    floatingOrigin?: Point3d;
    // (undocumented)
    name?: string;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    outline?: ColorDef;
    // (undocumented)
    sizeInches: number;
}

// @internal
export class ViewClipDecoration extends EditManipulator.HandleProvider {
    constructor(_clipView: ScreenViewport, _clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static clear(): void;
    // (undocumented)
    protected clearControls(): void;
    // (undocumented)
    protected _clip?: ClipVector;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    get clipId(): string | undefined;
    // (undocumented)
    protected _clipId?: string;
    // (undocumented)
    protected _clipPlanes?: ConvexClipPlaneSet;
    // (undocumented)
    get clipPlaneSet(): ConvexClipPlaneSet | undefined;
    // (undocumented)
    protected _clipPlanesLoops?: GeometryQuery[];
    // (undocumented)
    protected _clipPlanesLoopsNoncontributing?: GeometryQuery[];
    // (undocumented)
    get clipShape(): ClipShape | undefined;
    // (undocumented)
    protected _clipShape?: ClipShape;
    // (undocumented)
    protected _clipShapeExtents?: Range1d;
    // (undocumented)
    protected _clipView: ScreenViewport;
    // (undocumented)
    protected _controlIds: string[];
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    static create(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected createControls(): Promise<boolean>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doClipPlaneClear(index: number): boolean;
    // (undocumented)
    doClipPlaneNegate(index: number): boolean;
    // (undocumented)
    doClipPlaneOrientView(index: number): boolean;
    // (undocumented)
    doClipShapeSetZExtents(extents: Range1d): boolean;
    // (undocumented)
    static get(vp: ScreenViewport): ViewClipDecoration | undefined;
    // (undocumented)
    getControlIndex(id: string): number;
    // (undocumented)
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // (undocumented)
    isClipShapeAlignedWithWorldUp(extents?: Range1d): boolean;
    // (undocumented)
    protected modifyControls(hit: HitDetail, _ev: BeButtonEvent): Promise<boolean>;
    // (undocumented)
    onManipulatorEvent(eventType: EditManipulator.EventType): void;
    // (undocumented)
    protected onRightClick(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected onTouchTap(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onViewClose(vp: ScreenViewport): void;
    // (undocumented)
    protected _removeViewCloseListener?: () => void;
    // (undocumented)
    protected stop(): void;
    // (undocumented)
    protected _suspendDecorator: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toggle(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): Promise<string | undefined>;
    // (undocumented)
    protected updateDecorationListener(_add: boolean): void;
}

// @public
export class ViewClipDecorationProvider implements ViewClipEventHandler {
    // (undocumented)
    static clear(): void;
    // (undocumented)
    clearDecorationOnDeselect: boolean;
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    static create(): ViewClipDecorationProvider;
    // (undocumented)
    hideDecoration(): void;
    readonly onActiveClipChanged: BeEvent<(viewport: Viewport, eventType: ClipEventType, provider: ViewClipDecorationProvider) => void>;
    readonly onActiveClipRightClick: BeEvent<(hit: HitDetail, ev: BeButtonEvent, provider: ViewClipDecorationProvider) => void>;
    // (undocumented)
    onClearClip(viewport: ScreenViewport): void;
    // (undocumented)
    onModifyClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClipPlane(viewport: ScreenViewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecorationOnCreate: boolean;
    // (undocumented)
    selectOnCreate(): boolean;
    // (undocumented)
    showDecoration(vp: ScreenViewport): void;
    // (undocumented)
    toggleDecoration(vp: ScreenViewport): Promise<string | undefined>;
}

// @public
export interface ViewClipEventHandler {
    clearOnDeselect(): boolean;
    onClearClip(viewport: Viewport): void;
    onModifyClip(viewport: Viewport): void;
    onNewClip(viewport: Viewport): void;
    onNewClipPlane(viewport: Viewport): void;
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    selectOnCreate(): boolean;
}

// @internal
export abstract class ViewClipModifyTool extends EditManipulator.HandleTool {
    constructor(manipulator: EditManipulator.HandleProvider, clip: ClipVector, vp: Viewport, hitId: string, ids: string[], controls: ViewClipControlArrow[]);
    // (undocumented)
    protected accept(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _anchorIndex: number;
    // (undocumented)
    protected _clip: ClipVector;
    // (undocumented)
    protected _clipView: Viewport;
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    protected _currentDistance: number;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected drawAnchorOffset(context: DecorateContext, color: ColorDef, weight: number, transformFromClip?: Transform): void;
    // (undocumented)
    protected abstract drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected getOffsetValue(ev: BeButtonEvent, transformFromClip?: Transform): number | undefined;
    // (undocumented)
    protected _ids: string[];
    // (undocumented)
    protected init(): void;
    // (undocumented)
    onCleanup(): Promise<void>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected _restoreClip: boolean;
    // (undocumented)
    protected abstract updateViewClip(ev: BeButtonEvent, isAccept: boolean): boolean;
    // (undocumented)
    protected _viewRange: Range3d;
    // (undocumented)
    protected get wantAccuSnap(): boolean;
}

// @internal
export class ViewClipPlanesModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @internal
export class ViewClipShapeModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @public
export class ViewClipTool extends PrimitiveTool {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // @internal (undocumented)
    static addClipPlanesLoops(builder: GraphicBuilder, loops: GeometryQuery[], outline: boolean): void;
    // (undocumented)
    static areClipsEqual(clipA: ClipVector, clipB: ClipVector): boolean;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    static doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static doClipToConvexClipPlaneSet(viewport: Viewport, planes: ConvexClipPlaneSet): boolean;
    // (undocumented)
    static doClipToPlane(viewport: Viewport, origin: Point3d, normal: Vector3d, clearExistingPlanes: boolean): boolean;
    // (undocumented)
    static doClipToRange(viewport: Viewport, range: Range3d, transform?: Transform): boolean;
    // (undocumented)
    static doClipToShape(viewport: Viewport, xyPoints: Point3d[], transform?: Transform, zLow?: number, zHigh?: number): boolean;
    // @internal (undocumented)
    static drawClip(context: DecorateContext, clip: ClipVector, viewExtents?: Range3d, options?: DrawClipOptions): void;
    // (undocumented)
    static drawClipPlanesLoops(context: DecorateContext, loops: GeometryQuery[], color: ColorDef, weight: number, dashed?: boolean, fill?: ColorDef, id?: string): void;
    // (undocumented)
    static drawClipShape(context: DecorateContext, shape: ClipShape, extents: Range1d, color: ColorDef, weight: number, id?: string): void;
    // (undocumented)
    static enableClipVolume(viewport: Viewport): boolean;
    // @internal (undocumented)
    protected static enumAsOrientationMessage(str: string): string;
    // @internal (undocumented)
    static getClipRayTransformed(origin: Point3d, direction: Vector3d, transform?: Transform): Ray3d;
    // @internal (undocumented)
    static getClipShapeExtents(shape: ClipShape, viewRange: Range3d): Range1d;
    // @internal (undocumented)
    static getClipShapePoints(shape: ClipShape, z: number): Point3d[];
    // @internal (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // @internal (undocumented)
    static getOffsetValueTransformed(offset: number, transform?: Transform): number;
    // @internal (undocumented)
    static getPlaneInwardNormal(orientation: ContextRotationId, viewport: Viewport): Vector3d | undefined;
    // (undocumented)
    static hasClip(viewport: Viewport): boolean;
    // @internal (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // @internal (undocumented)
    static isSingleClipPlane(clip: ClipVector): ClipPlane | undefined;
    // @internal (undocumented)
    static isSingleClipShape(clip: ClipVector): ClipShape | undefined;
    // @internal (undocumented)
    static isSingleConvexClipPlaneSet(clip: ClipVector): ConvexClipPlaneSet | undefined;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // @internal (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // @internal (undocumented)
    onRestartTool(): Promise<void>;
    // @internal (undocumented)
    onUnsuspend(): Promise<void>;
    // @internal (undocumented)
    protected static _orientationName: string;
    // @internal (undocumented)
    requireWriteableTarget(): boolean;
    // @internal (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    static setViewClip(viewport: Viewport, clip?: ClipVector): boolean;
    // @internal (undocumented)
    protected showPrompt(): void;
}

// @public
export class ViewCreator2d {
    constructor(_imodel: IModelConnection);
    createViewForModel(modelId: Id64String, options?: ViewCreator2dOptions): Promise<ViewState>;
}

// @public
export interface ViewCreator2dOptions {
    bgColor?: ColorDef;
    useSeedView?: boolean;
    vpAspect?: number;
}

// @public
export class ViewCreator3d {
    constructor(_imodel: IModelConnection);
    createDefaultView(options?: ViewCreator3dOptions, modelIds?: Id64String[]): Promise<ViewState>;
}

// @public
export interface ViewCreator3dOptions {
    cameraOn?: boolean;
    skyboxOn?: boolean;
    standardViewId?: StandardViewId;
    useSeedView?: boolean;
    vpAspect?: number;
}

// @internal (undocumented)
export function viewGlobalLocation(viewport: ScreenViewport, doAnimate: boolean, eyeHeight?: number, pitchAngleRadians?: number, location?: GlobalLocation): number;

// @internal (undocumented)
export class ViewGlobalLocationConstants {
    // (undocumented)
    static readonly birdHeightAboveEarthInMeters = 713;
    // (undocumented)
    static readonly birdPitchAngleRadians = 0;
    // (undocumented)
    static readonly largestEarthArc = 20037500;
    // (undocumented)
    static readonly maximumDistanceToDrive = 96560.6;
    // (undocumented)
    static readonly satelliteHeightAboveEarthInMeters: number;
}

// @public
export class ViewGlobeBirdTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewGlobeIModelTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewGlobeLocationTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    static get maxArgs(): undefined;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    oneShot: boolean;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @public
export class ViewGlobeSatelliteTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // @internal (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // @internal (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class ViewHandleArray {
    constructor(viewTool: ViewManip);
    // (undocumented)
    add(handle: ViewingToolHandle): void;
    // (undocumented)
    get count(): number;
    // (undocumented)
    drawHandles(context: DecorateContext): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    focus: number;
    // (undocumented)
    focusDrag: boolean;
    // (undocumented)
    get focusHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    focusHitHandle(): void;
    // (undocumented)
    getByIndex(index: number): ViewingToolHandle | undefined;
    // (undocumented)
    handles: ViewingToolHandle[];
    hasHandle(handleType: ViewHandleType): boolean;
    // (undocumented)
    get hitHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    hitHandleIndex: number;
    // (undocumented)
    motion(ev: BeButtonEvent): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onWheel(ev: BeWheelEvent): boolean;
    // (undocumented)
    setFocus(index: number): void;
    // (undocumented)
    testHit(ptScreen: Point3d, forced?: ViewHandleType): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @internal (undocumented)
export enum ViewHandleType {
    // (undocumented)
    Fly = 64,
    // (undocumented)
    Look = 128,
    // (undocumented)
    LookAndMove = 256,
    // (undocumented)
    None = 0,
    // (undocumented)
    Pan = 4,
    // (undocumented)
    Rotate = 1,
    // (undocumented)
    Scroll = 8,
    // (undocumented)
    TargetCenter = 2,
    // (undocumented)
    Walk = 32,
    // (undocumented)
    Zoom = 16
}

// @public
export class ViewingSpace {
    // (undocumented)
    calcNpcToView(): Map4d;
    static createFromViewport(vp: Viewport): ViewingSpace | undefined;
    readonly eyePoint: Point3d | undefined;
    // @internal (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    frustFraction: number;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @internal (undocumented)
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // @internal (undocumented)
    getPreloadFrustum(transformOrScale?: Transform | number, result?: Frustum): Frustum;
    // @internal (undocumented)
    getTerrainHeightRange(): Range1d | undefined;
    // (undocumented)
    getViewCorners(): Range3d;
    // @internal
    static nearScaleLog24: number;
    // @internal
    static nearScaleNonLog24: number;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    get view(): ViewState;
    set view(view: ViewState);
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    readonly viewDelta: Vector3d;
    readonly viewDeltaUnexpanded: Vector3d;
    readonly viewOrigin: Point3d;
    readonly viewOriginUnexpanded: Point3d;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    readonly worldToNpcMap: Map4d;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    readonly worldToViewMap: Map4d;
    // @internal (undocumented)
    readonly zClipAdjusted: boolean;
}

// @internal (undocumented)
export abstract class ViewingToolHandle {
    constructor(viewTool: ViewManip);
    // (undocumented)
    adjustDepthPoint(isValid: boolean, _vp: Viewport, _plane: Plane3dByOriginAndUnitNormal, source: DepthPointSource): boolean;
    // (undocumented)
    protected changeFocusFromDepthPoint(): void;
    // (undocumented)
    checkOneShot(): boolean;
    // (undocumented)
    protected _depthPoint?: Point3d;
    // (undocumented)
    abstract doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // (undocumented)
    drawHandle(_context: DecorateContext, _hasFocus: boolean): void;
    // (undocumented)
    abstract firstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    focusIn(): void;
    // (undocumented)
    focusOut(): void;
    // (undocumented)
    getHandleCursor(): string;
    // (undocumented)
    abstract get handleType(): ViewHandleType;
    // (undocumented)
    protected readonly _lastPtNpc: Point3d;
    // (undocumented)
    motion(_ev: BeButtonEvent): boolean;
    // (undocumented)
    needDepthPoint(_ev: BeButtonEvent, _isPreview: boolean): boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): boolean;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    onTouchEnd(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMove(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): boolean;
    // (undocumented)
    onTouchStart(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchTap(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onWheel(_ev: BeWheelEvent): boolean;
    // (undocumented)
    protected pickDepthPoint(ev: BeButtonEvent): void;
    // (undocumented)
    abstract testHandleForHit(ptScreen: Point3d, out: {
        distance: number;
        priority: ViewManipPriority;
    }): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @public
export class ViewManager implements Iterable<ScreenViewport> {
    [Symbol.iterator](): Iterator<ScreenViewport>;
    addDecorator(decorator: Decorator): () => void;
    // @internal
    addToolTipProvider(provider: ToolTipProvider): () => void;
    addViewport(newVp: ScreenViewport): BentleyStatus;
    // @internal (undocumented)
    beginDynamicsMode(): void;
    clearSelectedView(): void;
    // (undocumented)
    get crossHairCursor(): string;
    // (undocumented)
    cursor: string;
    // (undocumented)
    readonly decorators: Decorator[];
    // @internal (undocumented)
    get doesHostHaveFocus(): boolean;
    dropDecorator(decorator: Decorator): boolean;
    // @internal
    dropToolTipProvider(provider: ToolTipProvider): void;
    dropViewport(vp: ScreenViewport, disposeOfViewport?: boolean): BentleyStatus;
    // (undocumented)
    get dynamicsCursor(): string;
    // @internal (undocumented)
    endDynamicsMode(): void;
    // @internal
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // @internal
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // @beta
    getElementToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getFirstOpenView(): ScreenViewport | undefined;
    // (undocumented)
    get grabbingCursor(): string;
    // (undocumented)
    get grabCursor(): string;
    hasViewport(viewport: ScreenViewport): boolean;
    // (undocumented)
    inDynamicsMode: boolean;
    // @beta
    invalidateCachedDecorationsAllViews(decorator: ViewportDecorator): void;
    invalidateDecorationsAllViews(): void;
    // @internal (undocumented)
    invalidateScenes(): void;
    // @alpha
    invalidateSymbologyOverridesAllViews(): void;
    // @internal (undocumented)
    invalidateViewportScenes(): void;
    // (undocumented)
    get lookCursor(): string;
    // @internal (undocumented)
    notifySelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    readonly onBeginRender: BeEvent<() => void>;
    // @internal
    onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    readonly onFinishRender: BeEvent<() => void>;
    // @internal (undocumented)
    onInitialized(): void;
    readonly onSelectedViewportChanged: BeUiEvent<SelectedViewportChangedArgs>;
    // @internal (undocumented)
    onSelectionSetChanged(_iModel: IModelConnection): void;
    // @internal (undocumented)
    onShutDown(): void;
    readonly onViewClose: BeUiEvent<ScreenViewport>;
    readonly onViewOpen: BeUiEvent<ScreenViewport>;
    readonly onViewResume: BeUiEvent<ScreenViewport>;
    readonly onViewSuspend: BeUiEvent<ScreenViewport>;
    // @internal
    overrideElementButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // @internal
    overrideElementGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // @internal
    overrideElementToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // @internal
    purgeTileTrees(olderThan: BeTimePoint): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    // @internal
    renderLoop(): void;
    // (undocumented)
    get rotateCursor(): string;
    // @internal (undocumented)
    get sceneInvalidated(): boolean;
    get selectedView(): ScreenViewport | undefined;
    setAntialiasingAllViews(numSamples: number): void;
    setSelectedView(vp: ScreenViewport | undefined): Promise<BentleyStatus>;
    setViewCursor(cursor?: string): void;
    // @internal (undocumented)
    readonly toolTipProviders: ToolTipProvider[];
    // @internal (undocumented)
    validateViewportScenes(): void;
    // (undocumented)
    get walkCursor(): string;
    // (undocumented)
    get zoomCursor(): string;
}

// @public
export abstract class ViewManip extends ViewTool {
    constructor(viewport: ScreenViewport | undefined, handleMask: number, oneShot: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    changeViewport(vp?: ScreenViewport): void;
    // @internal (undocumented)
    clearDepthPoint(): boolean;
    // @internal (undocumented)
    static computeFitRange(viewport: ScreenViewport): Range3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    protected _depthPreview?: {
        testPoint: Point3d;
        pickRadius: number;
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        isDefaultDepth: boolean;
        sourceId?: string;
    };
    // (undocumented)
    enforceZUp(pivotPoint: Point3d): boolean;
    // (undocumented)
    static fitView(viewport: ScreenViewport, animateFrustumChange: boolean, options?: ViewChangeOptions & MarginOptions): void;
    // @internal (undocumented)
    static fitViewWithGlobeAnimation(viewport: ScreenViewport, animateFrustumChange: boolean, options?: ViewChangeOptions & MarginOptions): void;
    // @internal (undocumented)
    forcedHandle: ViewHandleType;
    // (undocumented)
    frustumValid: boolean;
    // (undocumented)
    static getDefaultTargetPointWorld(vp: Viewport): Point3d;
    // @internal (undocumented)
    getDepthPointGeometryId(): string | undefined;
    // (undocumented)
    static getFocusPlaneNpc(vp: Viewport): number;
    // (undocumented)
    handleMask: number;
    // (undocumented)
    inHandleModify: boolean;
    // (undocumented)
    isDragging: boolean;
    // (undocumented)
    isDraggingRequired: boolean;
    isPointVisible(testPt: Point3d): boolean;
    // (undocumented)
    get isZUp(): boolean;
    // (undocumented)
    lensAngleMatches(angle: Angle, tolerance: number): boolean;
    // (undocumented)
    nPts: number;
    // (undocumented)
    onCleanup(): Promise<void>;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(wentDown: boolean, modifier: BeModifierKeys, event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(inputEv: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchEnd(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchStart(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @internal (undocumented)
    pickDepthPoint(ev: BeButtonEvent, isPreview?: boolean): Point3d | undefined;
    // @internal (undocumented)
    previewDepthPoint(context: DecorateContext): void;
    // (undocumented)
    processFirstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    processPoint(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string, additionalInstr?: ToolAssistanceInstruction[]): void;
    // (undocumented)
    setCameraLensAngle(lensAngle: Angle, retainEyePoint: boolean): ViewStatus;
    setTargetCenterWorld(pt: Point3d, lockTarget: boolean, saveTarget: boolean): void;
    // @internal (undocumented)
    startHandleDrag(ev: BeButtonEvent, forcedHandle?: ViewHandleType): Promise<EventHandled>;
    // @internal (undocumented)
    protected _startPose?: ViewPose;
    // (undocumented)
    targetCenterLocked: boolean;
    // (undocumented)
    targetCenterValid: boolean;
    // (undocumented)
    readonly targetCenterWorld: Point3d;
    // (undocumented)
    updateTargetCenter(): void;
    // @internal (undocumented)
    viewHandles: ViewHandleArray;
    // (undocumented)
    static zoomToAlwaysDrawnExclusive(viewport: ScreenViewport, options?: ViewChangeOptions & MarginOptions): Promise<boolean>;
}

// @public
export abstract class Viewport implements IDisposable, TileUser {
    // @internal
    protected constructor(target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(_decorations: Decorations): void;
    addFeatureOverrideProvider(provider: FeatureOverrideProvider): boolean;
    // @internal (undocumented)
    addFeatureOverrides(ovrs: FeatureSymbology.Overrides): void;
    // @internal
    addModelSubCategoryVisibilityOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
    addOnAnalysisStyleChangedListener(listener: (newStyle: AnalysisStyle | undefined) => void): () => void;
    addScreenSpaceEffect(effectName: string): void;
    addTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    addViewedModels(models: Id64Arg): Promise<void>;
    get alwaysDrawn(): Id64Set | undefined;
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    // @internal (undocumented)
    get analysisFractionValid(): boolean;
    get antialiasSamples(): number;
    set antialiasSamples(numSamples: number);
    // @internal
    applyViewState(val: ViewState): void;
    get areAllTileTreesLoaded(): boolean;
    // @internal
    protected attachToView(): void;
    // (undocumented)
    get auxCoordSystem(): AuxCoordSystemState;
    // @internal (undocumented)
    get backgroundDrapeMap(): MapTileTreeReference | undefined;
    // @internal (undocumented)
    get backgroundMap(): MapTileTreeReference | undefined;
    // @internal (undocumented)
    get backgroundMapGeometry(): BackgroundMapGeometry | undefined;
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    changeBackgroundMapProvider(props: BackgroundMapProviderProps): void;
    changeCategoryDisplay(categories: Id64Arg, display: boolean, enableAllSubCategories?: boolean): void;
    // @internal (undocumented)
    changeDynamics(dynamics: GraphicList | undefined): void;
    // @internal (undocumented)
    protected _changeFlags: MutableChangeFlags;
    changeModelDisplay(models: Id64Arg, display: boolean): boolean;
    changeSubCategoryDisplay(subCategoryId: Id64String, display: boolean): void;
    changeView(view: ViewState, _opts?: ViewChangeOptions): void;
    changeViewedModel2d(baseModelId: Id64String, options?: ChangeViewedModel2dOptions & ViewChangeOptions & MarginOptions): Promise<void>;
    changeViewedModels(modelIds: Id64Arg): boolean;
    clearAlwaysDrawn(): void;
    clearNeverDrawn(): void;
    get clipStyle(): ClipStyle;
    set clipStyle(style: ClipStyle);
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    computeViewRange(): Range3d;
    get continuousRendering(): boolean;
    set continuousRendering(contRend: boolean);
    // @internal (undocumented)
    get controllerValid(): boolean;
    // @internal (undocumented)
    protected _controllerValid: boolean;
    createScene(context: SceneContext): void;
    createSceneContext(): SceneContext;
    cssPixelsToDevicePixels(cssPixels: number): number;
    get debugBoundingBoxes(): TileBoundingBoxes;
    set debugBoundingBoxes(boxes: TileBoundingBoxes);
    // @internal (undocumented)
    protected _decorationsValid: boolean;
    // @internal
    protected detachFromView(): void;
    determineVisibleDepthRange(rect?: ViewRect, result?: DepthRangeNpc): DepthRangeNpc | undefined;
    get devicePixelRatio(): number;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    get displayStyle(): DisplayStyleState;
    set displayStyle(style: DisplayStyleState);
    // (undocumented)
    dispose(): void;
    dropFeatureOverrideProvider(provider: FeatureOverrideProvider): boolean;
    dropModelAppearanceOverride(id: Id64String): void;
    dropSubCategoryOverride(id: Id64String): void;
    dropTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    get emphasisSettings(): Hilite.Settings;
    set emphasisSettings(settings: Hilite.Settings);
    get featureOverrideProviders(): Iterable<FeatureOverrideProvider>;
    findFeatureOverrideProvider(predicate: (provider: FeatureOverrideProvider) => boolean): FeatureOverrideProvider | undefined;
    findFeatureOverrideProviderOfType<T>(type: Constructor<T>): T | undefined;
    get flashedId(): Id64String | undefined;
    set flashedId(id: Id64String | undefined);
    get flashSettings(): FlashSettings;
    set flashSettings(settings: FlashSettings);
    // @internal (undocumented)
    forEachMapTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTiledGraphicsProvider(func: (provider: TiledGraphicsProvider) => void): void;
    // @internal (undocumented)
    protected forEachTiledGraphicsProviderTree(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal
    get freezeScene(): boolean;
    set freezeScene(freeze: boolean);
    // @internal (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    get frustFraction(): number;
    // (undocumented)
    getAuxCoordOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getAuxCoordRotation(result?: Matrix3d): Matrix3d;
    getContrastToBackgroundColor(): ColorDef;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @alpha (undocumented)
    getMapFeatureInfo(hit: HitDetail): Promise<MapFeatureInfo>;
    // @internal (undocumented)
    getMapLayerImageryProvider(index: number, isOverlay: boolean): MapLayerImageryProvider | undefined;
    // @internal
    getMapLayerIndexesFromIds(mapTreeId: Id64String, layerTreeId: Id64String): MapLayerIndex[];
    // @beta
    getMapLayerScaleRangeVisibility(index: number, isOverlay: boolean): MapTileTreeScaleRangeVisibility;
    getPixelDataNpcPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    getPixelDataWorldPoint(args: GetPixelDataWorldPointArgs): Point3d | undefined;
    getPixelSizeAtPoint(point?: Point3d): number;
    // @internal (undocumented)
    getSubCategories(categoryId: Id64String): Id64Set | undefined;
    getSubCategoryAppearance(id: Id64String): SubCategoryAppearance;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    getTerrainHeightRange(): Range1d;
    // @internal (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getWorldFrustum(box?: Frustum): Frustum;
    // @internal
    protected hasAdditionalTiles(): boolean;
    // @internal (undocumented)
    protected _hasMissingTiles: boolean;
    hasTiledGraphicsProvider(provider: TiledGraphicsProvider): boolean;
    get hilite(): Hilite.Settings;
    set hilite(hilite: Hilite.Settings);
    get iModel(): IModelConnection;
    // @internal (undocumented)
    invalidateController(): void;
    invalidateDecorations(): void;
    // @internal (undocumented)
    invalidateRenderPlan(): void;
    invalidateScene(): void;
    // @internal (undocumented)
    protected _inViewChangedEvent: boolean;
    get isAlwaysDrawnExclusive(): boolean;
    // @internal (undocumented)
    get isAspectRatioLocked(): boolean;
    get isCameraOn(): boolean;
    // @internal (undocumented)
    get isContextRotationRequired(): boolean;
    get isDisposed(): boolean;
    get isFadeOutActive(): boolean;
    set isFadeOutActive(active: boolean);
    get isGridOn(): boolean;
    // @internal (undocumented)
    isPixelSelectable(pixel: Pixel.Data): boolean;
    // @internal (undocumented)
    get isPointAdjustmentRequired(): boolean;
    isPointVisibleXY(point: Point3d, coordSys?: CoordSystem, borderPaddingFactor?: number): boolean;
    // @internal (undocumented)
    get isSnapAdjustmentRequired(): boolean;
    isSubCategoryVisible(id: Id64String): boolean;
    get lastFlashedElementId(): Id64String | undefined;
    get lightSettings(): LightSettings | undefined;
    // @internal (undocumented)
    mapLayerFromHit(hit: HitDetail): MapLayerSettings | undefined;
    // @internal (undocumented)
    mapLayerFromIds(mapTreeId: Id64String, layerTreeId: Id64String): MapLayerSettings | undefined;
    // @internal (undocumented)
    markSelectionSetDirty(): void;
    get neverDrawn(): Id64Set | undefined;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    get numReadyTiles(): number;
    get numRequestedTiles(): number;
    get numSelectedTiles(): number;
    readonly onAlwaysDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onChangeView: BeEvent<(vp: Viewport, previousViewState: ViewState) => void>;
    readonly onDisplayStyleChanged: BeEvent<(vp: Viewport) => void>;
    readonly onDisposed: BeEvent<(vp: Viewport) => void>;
    readonly onFeatureOverrideProviderChanged: BeEvent<(vp: Viewport) => void>;
    readonly onFeatureOverridesChanged: BeEvent<(vp: Viewport) => void>;
    readonly onFlashedIdChanged: BeEvent<(vp: Viewport, args: OnFlashedIdChangedEventArgs) => void>;
    // @alpha
    readonly onFrameStats: BeEvent<(frameStats: Readonly<FrameStats>) => void>;
    // @beta
    readonly onMapLayerScaleRangeVisibilityChanged: BeEvent<(layerIndexes: MapLayerScaleRangeVisibility[]) => void>;
    readonly onNeverDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onRender: BeEvent<(vp: Viewport) => void>;
    // @internal
    onRequestStateChanged(): void;
    readonly onResized: BeEvent<(vp: Viewport) => void>;
    readonly onViewChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedCategoriesChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedCategoriesPerModelChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedModelsChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewportChanged: BeEvent<(vp: Viewport, changed: ChangeFlags) => void>;
    readonly onViewUndoRedo: BeEvent<(vp: Viewport, event: ViewUndoEvent) => void>;
    // @internal (undocumented)
    get overlayMap(): MapTileTreeReference | undefined;
    overrideDisplayStyle(overrides: DisplayStyleSettingsProps): void;
    overrideModelAppearance(id: Id64String, ovr: FeatureAppearance): void;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    get perModelCategoryVisibility(): PerModelCategoryVisibility.Overrides;
    pixelsFromInches(inches: number): number;
    // @internal (undocumented)
    get pixelsPerInch(): number;
    // @internal (undocumented)
    pointToGrid(point: Point3d): void;
    queryVisibleFeatures(options: QueryVisibleFeaturesOptions, callback: QueryVisibleFeaturesCallback): void;
    // @deprecated
    readImage(rect?: ViewRect, targetSize?: Point2d, flipVertically?: boolean): ImageBuffer | undefined;
    readImageBuffer(args?: ReadImageBufferArgs): ImageBuffer | undefined;
    readImageToCanvas(): HTMLCanvasElement;
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable?: boolean): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    removeScreenSpaceEffects(): void;
    renderFrame(): void;
    // @internal (undocumented)
    get renderPlanValid(): boolean;
    // @internal (undocumented)
    protected _renderPlanValid: boolean;
    replaceViewedModels(modelIds: Id64Arg): Promise<void>;
    requestRedraw(): void;
    // @beta
    resetMapLayer(index: number, isOverlay: boolean): void;
    get rotation(): Matrix3d;
    // @internal (undocumented)
    get sceneValid(): boolean;
    // @internal (undocumented)
    protected _sceneValid: boolean;
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(effects: Iterable<string>);
    scroll(screenDist: XAndY, options?: ViewChangeOptions): void;
    // @internal
    setAllValid(): void;
    setAlwaysDrawn(ids: Id64Set, exclusive?: boolean): void;
    setAnimator(animator?: Animator): void;
    setFeatureOverrideProviderChanged(): void;
    // (undocumented)
    setLightSettings(settings: LightSettings): void;
    // @internal
    setModelDisplayTransformProvider(provider: ModelDisplayTransformProvider): void;
    setNeverDrawn(ids: Id64Set): void;
    // @internal (undocumented)
    setRenderPlanValid(): void;
    // (undocumented)
    setSolarShadowSettings(settings: SolarShadowSettings): void;
    setStandardRotation(id: StandardViewId): void;
    // @alpha
    setTileSizeModifier(modifier: number | undefined): void;
    setupFromView(pose?: ViewPose): ViewStatus;
    setupViewFromFrustum(inFrustum: Frustum): boolean;
    // @internal (undocumented)
    setValidScene(): void;
    // @internal (undocumented)
    setViewedCategoriesPerModelChanged(): void;
    get solarShadowSettings(): SolarShadowSettings | undefined;
    // @internal (undocumented)
    readonly subcategories: SubCategoriesCache.Queue;
    synchWithView(_options?: ViewChangeOptions): void;
    // @internal (undocumented)
    get target(): RenderTarget;
    get tiledGraphicsProviders(): Iterable<TiledGraphicsProvider>;
    // @alpha
    get tileSizeModifier(): number;
    // @internal
    get tileUserId(): number;
    get timePoint(): number | undefined;
    set timePoint(time: number | undefined);
    // @internal (undocumented)
    get timePointValid(): boolean;
    // @internal (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    turnCameraOff(): void;
    turnCameraOn(lensAngle?: Angle): ViewStatus;
    static undoDelay: BeDuration;
    protected updateChangeFlags(newView: ViewState): void;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    get view(): ViewState;
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    get viewDelta(): Vector3d;
    get viewFlags(): ViewFlags;
    set viewFlags(viewFlags: ViewFlags);
    // @alpha
    get viewingGlobe(): boolean;
    // (undocumented)
    get viewingSpace(): ViewingSpace;
    get viewportId(): number;
    // @internal (undocumented)
    protected readonly _viewRange: ViewRect;
    abstract get viewRect(): ViewRect;
    viewsModel(modelId: Id64String): boolean;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    waitForSceneCompletion(): Promise<void>;
    // @internal
    get wantViewAttachmentBoundaries(): boolean;
    set wantViewAttachmentBoundaries(want: boolean);
    // @internal
    get wantViewAttachmentClipShapes(): boolean;
    set wantViewAttachmentClipShapes(want: boolean);
    // @internal
    get wantViewAttachments(): boolean;
    set wantViewAttachments(want: boolean);
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    get worldToNpcMap(): Map4d;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    get worldToViewMap(): Map4d;
    zoom(newCenter: Point3d | undefined, factor: number, options?: ViewChangeOptions & MarginOptions & OnViewExtentsError): ViewStatus;
    zoomToElementProps(elementProps: ElementProps[], options?: ViewChangeOptions & MarginOptions & ZoomToOptions): void;
    zoomToElements(ids: Id64Arg, options?: ViewChangeOptions & MarginOptions & ZoomToOptions): Promise<void>;
    zoomToPlacementProps(placementProps: PlacementProps[], options?: ViewChangeOptions & MarginOptions & ZoomToOptions): void;
    zoomToPlacements(placements: Placement[], options?: ViewChangeOptions & MarginOptions & ZoomToOptions): void;
    zoomToVolume(volume: LowAndHighXYZ | LowAndHighXY, options?: ViewChangeOptions & MarginOptions): void;
}

// @public
export interface ViewportDecorator {
    decorate(context: DecorateContext): void;
    readonly useCachedDecorations?: true;
}

// @public
export interface ViewportGraphicBuilderOptions extends GraphicBuilderOptions {
    applyAspectRatioSkew?: boolean;
    // (undocumented)
    computeChordTolerance?: never;
    // (undocumented)
    iModel?: never;
    viewport: Viewport;
}

// @public
export abstract class ViewPose {
    constructor(cameraOn: boolean);
    cameraOn: boolean;
    get center(): Point3d;
    abstract equal(other: ViewPose): boolean;
    abstract equalState(view: ViewState): boolean;
    abstract extents: Vector3d;
    abstract origin: Point3d;
    abstract rotation: Matrix3d;
    get target(): Point3d;
    undoTime?: BeTimePoint;
    get zVec(): Vector3d;
}

// @public
export class ViewPose2d extends ViewPose {
    constructor(view: ViewState2d);
    readonly angle: Angle;
    readonly delta: Point2d;
    // @internal
    equal(other: ViewPose): boolean;
    // @internal
    equalState(view: ViewState): boolean;
    // @internal
    get extents(): Vector3d;
    // @internal
    get origin(): Point3d;
    readonly origin2d: Point2d;
    // @internal
    get rotation(): Matrix3d;
}

// @public
export class ViewPose3d extends ViewPose {
    constructor(view: ViewState3d);
    readonly camera: Camera;
    // @internal
    equal(other: ViewPose): boolean;
    // @internal
    equalState(view: ViewState): boolean;
    // @internal
    readonly extents: Vector3d;
    // @internal
    readonly origin: Point3d;
    // @internal
    readonly rotation: Matrix3d;
    // @internal
    get target(): Point3d;
}

// @public
export class ViewRect {
    constructor(left?: number, top?: number, right?: number, bottom?: number);
    get area(): number;
    get aspect(): number;
    get bottom(): number;
    set bottom(val: number);
    clone(result?: ViewRect): ViewRect;
    computeOverlap(other: ViewRect, out?: ViewRect): ViewRect | undefined;
    containsPoint(point: XAndY): boolean;
    equals(other: ViewRect): boolean;
    // (undocumented)
    extend(other: ViewRect): void;
    get height(): number;
    set height(height: number);
    init(left: number, top: number, right: number, bottom: number): void;
    initFromPoints(topLeft: XAndY, bottomRight: XAndY): void;
    initFromRange(input: LowAndHighXY): void;
    inset(deltaX: number, deltaY: number): void;
    insetByPercent(percent: number): void;
    insetUniform(offset: number): void;
    isContained(other: ViewRect): boolean;
    get isNull(): boolean;
    get isValid(): boolean;
    get left(): number;
    set left(val: number);
    overlaps(other: ViewRect): boolean;
    get right(): number;
    set right(val: number);
    scaleAboutCenter(xScale: number, yScale: number): void;
    setFrom(other: ViewRect): void;
    get top(): number;
    set top(val: number);
    get width(): number;
    set width(width: number);
}

// @public
export class ViewRedoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewState extends ElementState {
    // @internal
    protected constructor(props: ViewDefinitionProps, iModel: IModelConnection, categoryOrClone: CategorySelectorState, displayStyle: DisplayStyleState);
    adjustAspectRatio(aspect: number): void;
    // @internal (undocumented)
    adjustViewDelta(delta: Vector3d, origin: XYZ, rot: Matrix3d, aspect?: number, opts?: OnViewExtentsError): ViewStatus;
    abstract allow3dManipulations(): boolean;
    get analysisStyle(): AnalysisStyle | undefined;
    abstract applyPose(props: ViewPose): this;
    get areAllTileTreesLoaded(): boolean;
    // @internal
    attachToViewport(_args: AttachToViewportArgs): void;
    get auxiliaryCoordinateSystem(): AuxCoordSystemState;
    get backgroundColor(): ColorDef;
    // (undocumented)
    calculateFocusCorners(): Point3d[];
    calculateFrustum(result?: Frustum): Frustum | undefined;
    get categorySelector(): CategorySelectorState;
    set categorySelector(selector: CategorySelectorState);
    // @internal (undocumented)
    static get className(): string;
    // @internal
    collectNonTileTreeStatistics(_stats: RenderMemory.Statistics): void;
    // @internal
    collectStatistics(stats: RenderMemory.Statistics): void;
    // @beta
    computeDisplayTransform(args: ComputeDisplayTransformArgs): Transform | undefined;
    abstract computeFitRange(): Range3d;
    // @internal (undocumented)
    computeWorldToNpc(viewRot?: Matrix3d, inOrigin?: Point3d, delta?: Vector3d, enforceFrontToBackRatio?: boolean): {
        map: Map4d | undefined;
        frustFraction: number;
    };
    // @internal (undocumented)
    abstract createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    static createFromProps(_props: ViewStateProps, _iModel: IModelConnection): ViewState | undefined;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal
    decorate(context: DecorateContext): void;
    abstract get defaultExtentLimits(): ExtentLimits;
    // (undocumented)
    description?: string;
    // @internal
    detachFromViewport(): void;
    abstract get details(): ViewDetails;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    get displayStyle(): DisplayStyleState;
    set displayStyle(style: DisplayStyleState);
    // @internal (undocumented)
    drawGrid(context: DecorateContext): void;
    equals(other: this): boolean;
    get extentLimits(): ExtentLimits;
    set extentLimits(limits: ExtentLimits);
    // @internal
    fixAspectRatio(windowAspect: number): void;
    abstract forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal
    abstract forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    // @internal
    forEachTileTreeRef(func: (treeRef: TileTreeReference) => void): void;
    getAspectRatio(): number;
    getAspectRatioSkew(): number;
    getAuxiliaryCoordinateSystemId(): Id64String;
    getCenter(result?: Point3d): Point3d;
    abstract getExtents(): Vector3d;
    getGlobeRotation(): Matrix3d | undefined;
    getGridOrientation(): GridOrientationType;
    getGridSettings(vp: Viewport, origin: Point3d, rMatrix: Matrix3d, orientation: GridOrientationType): void;
    // (undocumented)
    getGridSpacing(): XAndY;
    // (undocumented)
    getGridsPerRef(): number;
    getIsViewingProject(): boolean;
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    // @internal
    getModelElevation(_modelId: Id64String): number;
    abstract getOrigin(): Point3d;
    abstract getRotation(): Matrix3d;
    // @internal (undocumented)
    static getStandardViewMatrix(id: StandardViewId): Matrix3d;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    getTargetPoint(result?: Point3d): Point3d;
    // (undocumented)
    getUpVector(point: Point3d): Vector3d;
    getViewClip(): ClipVector | undefined;
    abstract getViewedExtents(): AxisAlignedBox3d;
    getXVector(result?: Vector3d): Vector3d;
    getYVector(result?: Vector3d): Vector3d;
    getZVector(result?: Vector3d): Vector3d;
    get globalScopeFactor(): number;
    // @internal
    get globeMode(): GlobeMode;
    hasSameCoordinates(other: ViewState): boolean;
    is2d(): this is ViewState2d;
    abstract is3d(): this is ViewState3d;
    get isAttachedToViewport(): boolean;
    abstract isDrawingView(): this is DrawingViewState;
    // (undocumented)
    isPrivate?: boolean;
    isSheetView(): this is SheetViewState;
    abstract isSpatialView(): this is SpatialViewState;
    // @internal (undocumented)
    isSubCategoryVisible(id: Id64String): boolean;
    load(): Promise<void>;
    lookAtViewAlignedVolume(volume: Range3d, aspect?: number, options?: MarginOptions & OnViewExtentsError): void;
    lookAtVolume(volume: LowAndHighXYZ | LowAndHighXY, aspect?: number, options?: MarginOptions & OnViewExtentsError): void;
    // @internal
    get maxGlobalScopeFactor(): number;
    // @beta
    get modelDisplayTransformProvider(): ModelDisplayTransformProvider | undefined;
    set modelDisplayTransformProvider(provider: ModelDisplayTransformProvider | undefined);
    get name(): string;
    readonly onDisplayStyleChanged: BeEvent<(newStyle: DisplayStyleState) => void>;
    // @beta
    readonly onModelDisplayTransformProviderChanged: BeEvent<(newProvider: ModelDisplayTransformProvider | undefined) => void>;
    readonly onViewedCategoriesChanged: BeEvent<() => void>;
    // @internal (undocumented)
    outputStatusMessage(status: ViewStatus): ViewStatus;
    // (undocumented)
    protected postload(hydrateResponse: HydrateViewStateResponseProps): Promise<void>;
    protected preload(hydrateRequest: HydrateViewStateRequestProps): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): boolean;
    resetExtentLimits(): void;
    abstract savePose(): ViewPose;
    get scheduleScript(): RenderSchedule.Script | undefined;
    // @internal (undocumented)
    get scheduleScriptReference(): RenderSchedule.ScriptReference | undefined;
    // @internal
    get secondaryViewports(): Iterable<Viewport>;
    setAspectRatioSkew(val: number): void;
    setAuxiliaryCoordinateSystem(acs?: AuxCoordSystemState): void;
    setCategorySelector(categories: CategorySelectorState): void;
    setCenter(center: Point3d): void;
    // (undocumented)
    setDisplayStyle(style: DisplayStyleState): void;
    abstract setExtents(viewDelta: Vector3d): void;
    setGridSettings(orientation: GridOrientationType, spacing: Point2d, gridsPerRef: number): void;
    abstract setOrigin(viewOrg: XYAndZ): void;
    abstract setRotation(viewRot: Matrix3d): void;
    setRotationAboutPoint(rotation: Matrix3d, point?: Point3d): void;
    setStandardGlobalRotation(id: StandardViewId): void;
    setStandardRotation(id: StandardViewId): void;
    setupFromFrustum(inFrustum: Frustum, opts?: OnViewExtentsError): ViewStatus;
    setViewClip(clip?: ClipVector): void;
    toJSON(): ViewDefinitionProps;
    toProps(): ViewStateProps;
    // (undocumented)
    protected _updateMaxGlobalScopeFactor(): void;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    viewsCategory(id: Id64String): boolean;
    abstract viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState2d extends ViewState {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // (undocumented)
    readonly angle: Angle;
    // @internal
    applyPose(val: ViewPose): this;
    // (undocumented)
    get baseModelId(): Id64String;
    // (undocumented)
    protected _baseModelId: Id64String;
    changeViewedModel(newViewedModelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    readonly delta: Point2d;
    get details(): ViewDetails;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (ref: TileTreeReference) => void): void;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getViewedModel(): GeometricModel2dState | undefined;
    // @internal (undocumented)
    is3d(): this is ViewState3d;
    // @internal (undocumented)
    isSpatialView(): this is SpatialViewState;
    // (undocumented)
    readonly origin: Point2d;
    // @internal (undocumented)
    protected postload(hydrateResponse: HydrateViewStateResponseProps): Promise<void>;
    // @internal (undocumented)
    protected preload(hydrateRequest: HydrateViewStateRequestProps): void;
    savePose(): ViewPose2d;
    // (undocumented)
    setExtents(delta: XAndY): void;
    // (undocumented)
    setOrigin(origin: XAndY): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // @internal (undocumented)
    protected get _tileTreeRef(): TileTreeReference | undefined;
    // (undocumented)
    toJSON(): ViewDefinition2dProps;
    // @internal (undocumented)
    protected _treeRef?: TileTreeReference;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState3d extends ViewState {
    constructor(props: ViewDefinition3dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState);
    alignToGlobe(target: Point3d, transition?: boolean): ViewStatus;
    // (undocumented)
    allow3dManipulations(): boolean;
    // @internal
    applyPose(val: ViewPose): this;
    // @internal (undocumented)
    attachToViewport(args: AttachToViewportArgs): void;
    calcLensAngle(): Angle;
    // (undocumented)
    protected static calculateMaxDepth(delta: Vector3d, zVec: Vector3d): number;
    readonly camera: Camera;
    protected _cameraOn: boolean;
    cartographicToRoot(cartographic: Cartographic, result?: Point3d): Point3d | undefined;
    cartographicToRootFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d | undefined>;
    centerEyePoint(backDistance?: number): void;
    centerFocusDistance(): void;
    // @internal
    changeFocusDistance(newDist: number): ViewStatus;
    // @internal
    changeFocusFromPoint(pt: Point3d): ViewStatus;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    detachFromViewport(): void;
    get details(): ViewDetails3d;
    get displayStyle(): DisplayStyle3dState;
    set displayStyle(style: DisplayStyle3dState);
    // @internal (undocumented)
    protected enableCamera(): void;
    readonly extents: Vector3d;
    forceMinFrontDist: number;
    getBackDistance(): number;
    // (undocumented)
    getCartographicHeight(point: XYAndZ): number | undefined;
    getDisplayStyle3d(): DisplayStyle3dState;
    getEarthFocalPoint(): Point3d | undefined;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getEyeCartographicHeight(): number | undefined;
    // @internal (undocumented)
    getEyeOrOrthographicViewPoint(): Point3d;
    getEyePoint(): Point3d;
    getFocusDistance(): number;
    getFrontDistance(): number;
    getGroundElevation(): number;
    getGroundExtents(vp?: Viewport): AxisAlignedBox3d;
    getLensAngle(): Angle;
    // @internal (undocumented)
    getModelClip(modelId: Id64String): RenderClipVolume | undefined;
    // @internal (undocumented)
    getModelElevation(modelId: Id64String): number;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getTargetPoint(result?: Point3d): Point3d;
    get globalScopeFactor(): number;
    globalViewTransition(): number;
    // @internal (undocumented)
    is3d(): this is ViewState3d;
    // (undocumented)
    get isCameraOn(): boolean;
    get isCameraValid(): boolean;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // (undocumented)
    isEyePointAbove(elevation: number): boolean;
    // (undocumented)
    isEyePointGlobalView(eyePoint: XYAndZ): boolean;
    // (undocumented)
    get isGlobalView(): boolean;
    lookAt(args: LookAtPerspectiveArgs | LookAtOrthoArgs | LookAtUsingLensAngle): ViewStatus;
    lookAtGlobalLocation(eyeHeight: number, pitchAngleRadians?: number, location?: GlobalLocation, eyePoint?: Point3d): number;
    lookAtGlobalLocationFromGcs(eyeHeight: number, pitchAngleRadians?: number, location?: GlobalLocation, eyePoint?: Point3d): Promise<number>;
    // (undocumented)
    minimumFrontDistance(): number;
    moveCameraGlobal(fromPoint: Point3d, toPoint: Point3d): ViewStatus;
    moveCameraLocal(distance: Vector3d): ViewStatus;
    moveCameraWorld(distance: Vector3d): ViewStatus;
    readonly origin: Point3d;
    rootToCartographic(root: XYAndZ, result?: Cartographic): Cartographic | undefined;
    rootToCartographicFromGcs(root: XYAndZ, result?: Cartographic): Promise<Cartographic | undefined>;
    rotateCameraLocal(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    rotateCameraWorld(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    readonly rotation: Matrix3d;
    savePose(): ViewPose3d;
    setAllow3dManipulations(allow: boolean): void;
    // (undocumented)
    setExtents(extents: XYAndZ): void;
    setEyePoint(pt: XYAndZ): void;
    setFocusDistance(dist: number): void;
    setLensAngle(angle: Angle): void;
    // (undocumented)
    setOrigin(origin: XYAndZ): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // (undocumented)
    setupFromFrustum(frustum: Frustum, opts?: OnViewExtentsError): ViewStatus;
    // (undocumented)
    supportsCamera(): boolean;
    // (undocumented)
    toJSON(): ViewDefinition3dProps;
    turnCameraOff(): void;
    verifyFocusPlane(): void;
}

// @public
export enum ViewStatus {
    // (undocumented)
    AlreadyAttached = 2,
    // (undocumented)
    DegenerateGeometry = 21,
    // (undocumented)
    DrawFailure = 4,
    // (undocumented)
    HeightBelowTransition = 22,
    // (undocumented)
    InvalidDirection = 16,
    // (undocumented)
    InvalidLens = 14,
    // (undocumented)
    InvalidTargetPoint = 13,
    // (undocumented)
    InvalidUpVector = 12,
    // (undocumented)
    InvalidViewport = 15,
    // (undocumented)
    InvalidWindow = 7,
    // (undocumented)
    MaxDisplayDepth = 11,
    // (undocumented)
    MaxWindow = 9,
    // (undocumented)
    MaxZoom = 10,
    // (undocumented)
    MinWindow = 8,
    // (undocumented)
    ModelNotFound = 6,
    // (undocumented)
    NotAttached = 3,
    // (undocumented)
    NotCameraView = 18,
    // (undocumented)
    NotEllipsoidGlobeMode = 19,
    // (undocumented)
    NotGeolocated = 17,
    // (undocumented)
    NotOrthographicView = 20,
    // (undocumented)
    NoTransitionRequired = 23,
    // (undocumented)
    NotResized = 5,
    // (undocumented)
    Success = 0,
    // (undocumented)
    ViewNotInitialized = 1
}

// @public
export class ViewToggleCameraTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onInstall(): Promise<boolean>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewTool extends InteractiveTool {
    constructor(viewport?: ScreenViewport | undefined);
    // (undocumented)
    beginDynamicUpdate(): void;
    // (undocumented)
    endDynamicUpdate(): void;
    exitTool(): Promise<void>;
    // (undocumented)
    inDynamicUpdate: boolean;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): Promise<boolean>;
    // (undocumented)
    static showPrompt(prompt: string): void;
    // (undocumented)
    static translate(val: string): string;
    // (undocumented)
    viewport?: ScreenViewport | undefined;
}

// @public
export enum ViewUndoEvent {
    // (undocumented)
    Redo = 1,
    // (undocumented)
    Undo = 0
}

// @public
export class ViewUndoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export interface VisibleFeature {
    readonly elementId: Id64String;
    readonly geometryClass: GeometryClass;
    iModel: IModelConnection;
    readonly modelId: Id64String;
    readonly subCategoryId: Id64String;
}

// @public
export class WalkViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class WebMercatorProjection {
    // (undocumented)
    static geodeticLatitudeToMercatorAngle(latitude: number): number;
    // (undocumented)
    static maximumLatitude: number;
    static mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;
}

// @beta
export class WebMercatorTilingScheme extends MapTilingScheme {
    constructor(numberOfLevelZeroTilesX?: number, numberOfLevelZeroTilesY?: number, rowZeroAtNorthPole?: boolean);
    // @internal
    latitudeToYFraction(latitude: number): number;
    // @internal
    yFractionToLatitude(yFraction: number): number;
}

// @internal
export class WheelEventProcessor {
    // (undocumented)
    static process(ev: BeWheelEvent, doUpdate: boolean): Promise<void>;
}

// @public
export class WindowAreaTool extends ViewTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class WmsCapabilities {
    constructor(_json: any);
    // (undocumented)
    get cartoRange(): MapCartoRectangle | undefined;
    // (undocumented)
    static create(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<WmsCapabilities | undefined>;
    // (undocumented)
    get featureInfoFormats(): string[] | undefined;
    // (undocumented)
    get featureInfoSupported(): boolean;
    // (undocumented)
    getSubLayers(visible?: boolean): undefined | MapSubLayerProps[];
    // (undocumented)
    getSubLayersCrs(subLayerNames: string[]): Map<string, string[]> | undefined;
    // (undocumented)
    readonly isVersion13: boolean;
    // (undocumented)
    get json(): any;
    // (undocumented)
    readonly layer?: WmsCapability.Layer;
    // (undocumented)
    get maxLevel(): number;
    // (undocumented)
    readonly service: WmsCapability.Service;
    // (undocumented)
    readonly version?: string;
}

// @internal
export namespace WmsCapability {
    // (undocumented)
    export class Layer {
        constructor(json: any, capabilities: WmsCapabilities);
        // (undocumented)
        readonly cartoRange?: MapCartoRectangle;
        // (undocumented)
        getSubLayers(visible?: boolean): MapSubLayerProps[];
        // (undocumented)
        getSubLayersCrs(layerNameFilter: string[]): Map<string, string[]>;
        // (undocumented)
        readonly queryable: boolean;
        // (undocumented)
        readonly srs?: string[];
        // (undocumented)
        readonly subLayers: SubLayer[];
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class Service {
        constructor(json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly accessConstraints?: string;
        // (undocumented)
        readonly contactInformation?: string;
        // (undocumented)
        readonly name: string;
        // (undocumented)
        readonly onlineResource?: string;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class SubLayer {
        constructor(_json: any, capabilities: WmsCapabilities, parent?: SubLayer | undefined);
        // (undocumented)
        readonly cartoRange?: MapCartoRectangle;
        // (undocumented)
        readonly children?: SubLayer[];
        // (undocumented)
        readonly crs: string[];
        // (undocumented)
        readonly name: string;
        // (undocumented)
        readonly ownCrs: string[];
        // (undocumented)
        readonly parent?: SubLayer | undefined;
        // (undocumented)
        readonly queryable: boolean;
        // (undocumented)
        readonly title: string;
    }
}

// @internal (undocumented)
export interface WmsCrsSupport {
    // (undocumented)
    support3857: boolean;
    // (undocumented)
    support4326: boolean;
}

// @internal (undocumented)
export class WmsMapLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    getCrsSupport(): WmsCrsSupport;
    // (undocumented)
    getToolTip(strings: string[], quadId: QuadId, carto: Cartographic, tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    initialize(): Promise<void>;
}

// @internal (undocumented)
export class WmsUtilities {
    // (undocumented)
    static getBaseUrl(url: string): string;
}

// @internal (undocumented)
export class WmtsCapabilities {
    constructor(xmlDoc: Document);
    // (undocumented)
    readonly contents?: WmtsCapability.Contents;
    // (undocumented)
    static create(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<WmtsCapabilities | undefined>;
    // (undocumented)
    static createFromXml(xmlCapabilities: string): WmtsCapabilities | undefined;
    // (undocumented)
    readonly operationsMetadata?: WmtsCapability.OperationMetadata;
    // (undocumented)
    readonly serviceIdentification?: WmtsCapability.ServiceIdentification;
    // (undocumented)
    readonly version?: string;
}

// @internal
export namespace WmtsCapability {
    // (undocumented)
    export class BoundingBox {
        constructor(elem: Element);
        // (undocumented)
        readonly crs?: string;
        // (undocumented)
        readonly range?: Range2d;
    }
    // (undocumented)
    export class Contents {
        constructor(elem: Element);
        // (undocumented)
        getEpsg4326CompatibleTileMatrixSet(): TileMatrixSet[];
        // (undocumented)
        getGoogleMapsCompatibleTileMatrixSet(): TileMatrixSet[];
        // (undocumented)
        readonly layers: Layer[];
        // (undocumented)
        readonly tileMatrixSets: TileMatrixSet[];
    }
    // (undocumented)
    export class HttpDcp {
        constructor(elem: Element);
        // (undocumented)
        readonly constraintName?: string;
        // (undocumented)
        readonly encoding?: string;
        // (undocumented)
        readonly url?: string;
    }
    // (undocumented)
    export class Layer {
        constructor(elem: Element);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly boundingBox?: BoundingBox;
        // (undocumented)
        readonly format?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly styles: Style[];
        // (undocumented)
        readonly tileMatrixSetLinks: TileMatrixSetLink[];
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly wsg84BoundingBox?: MapCartoRectangle;
    }
    // (undocumented)
    export class Operation {
        constructor(elem: Element);
        // (undocumented)
        get getDcpHttp(): HttpDcp[] | undefined;
        // (undocumented)
        readonly name?: string;
        // (undocumented)
        get postDcpHttp(): HttpDcp[] | undefined;
    }
    // (undocumented)
    export class OperationMetadata {
        constructor(elem: Element);
        // (undocumented)
        get getCapabilities(): Operation | undefined;
        // (undocumented)
        get getFeatureInfo(): Operation | undefined;
        // (undocumented)
        get getTile(): Operation | undefined;
    }
    // (undocumented)
    export class ServiceIdentification {
        constructor(elem: Element);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly accessConstraints?: string;
        // (undocumented)
        readonly fees?: string;
        // (undocumented)
        readonly keywords?: string[];
        // (undocumented)
        readonly serviceType?: string;
        // (undocumented)
        readonly serviceTypeVersion?: string;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class Style {
        constructor(elem: Element);
        // (undocumented)
        readonly identifier?: string;
        // (undocumented)
        readonly isDefault: boolean;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class TileMatrix {
        constructor(elem: Element);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly matrixHeight: number;
        // (undocumented)
        readonly matrixWidth: number;
        // (undocumented)
        readonly scaleDenominator: number;
        // (undocumented)
        readonly tileHeight: number;
        // (undocumented)
        readonly tileWidth: number;
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly topLeftCorner: Point2d;
    }
    // (undocumented)
    export class TileMatrixSet {
        constructor(elem: Element);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly supportedCrs: string;
        // (undocumented)
        readonly tileMatrix: TileMatrix[];
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly wellKnownScaleSet: string;
    }
    // (undocumented)
    export class TileMatrixSetLimits {
        constructor(elem: Element);
        // (undocumented)
        limits?: Range2d;
        // (undocumented)
        tileMatrix?: string;
    }
    // (undocumented)
    export class TileMatrixSetLink {
        constructor(elem: Element);
        // (undocumented)
        readonly tileMatrixSet: string;
        // (undocumented)
        readonly tileMatrixSetLimits: TileMatrixSetLimits[];
    }
}

// @internal (undocumented)
export enum WmtsConstants {
    // (undocumented)
    GOOGLEMAPS_COMPATIBLE_WELLKNOWNNAME = "googlemapscompatible",
    // (undocumented)
    GOOGLEMAPS_LEVEL0_SCALE_DENOM = 559082264.0287178
}

// @internal (undocumented)
export class WmtsMapLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: ImageMapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    displayedLayerName: string;
    // (undocumented)
    protected _generateChildIds(tile: ImageryMapTile, resolveChildren: (childIds: QuadId[]) => void): void;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get mutualExclusiveSubLayer(): boolean;
    // (undocumented)
    get useGeographicTilingScheme(): boolean;
}

// @public
export interface ZoomToOptions {
    placementRelativeId?: StandardViewId;
    standardViewId?: StandardViewId;
    viewRotation?: Matrix3d;
}

// @public
export class ZoomViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// (No @packageDocumentation comment for this package)

```
