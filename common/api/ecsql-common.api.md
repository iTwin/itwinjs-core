## API Report File for "@itwin/ecsql-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Constructor } from '@itwin/core-bentley';

// @alpha
export type AllOrAnyOp = "ONLY" | "ALL";

// @alpha
export type AllOrDistinctOp = "DISTINCT" | "ALL";

// @alpha
export class AssignmentExpr extends Expr {
    constructor(propertyName: PropertyNameExpr, valueExpr: ValueExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): AssignmentExpr;
    // (undocumented)
    readonly propertyName: PropertyNameExpr;
    // (undocumented)
    static readonly type = ExprType.Assignment;
    // (undocumented)
    readonly valueExpr: ValueExpr;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class BetweenExpr extends BooleanExpr {
    constructor(lhsExpr: ValueExpr, lowerBoundExpr: ValueExpr, upperBoundExpr: ValueExpr, not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): BetweenExpr;
    // (undocumented)
    readonly lhsExpr: ValueExpr;
    // (undocumented)
    readonly lowerBoundExpr: ValueExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    static parseOp(op: string): boolean[];
    // (undocumented)
    static readonly type = ExprType.Between;
    // (undocumented)
    readonly upperBoundExpr: ValueExpr;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class BinaryBooleanExpr extends BooleanExpr {
    constructor(op: BinaryBooleanOp, lhsExpr: ComputedExpr, rhsExpr: ComputedExpr, not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): BinaryBooleanExpr;
    // (undocumented)
    readonly lhsExpr: ComputedExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    readonly op: BinaryBooleanOp;
    // (undocumented)
    readonly rhsExpr: ComputedExpr;
    // (undocumented)
    static readonly type = ExprType.BinaryBoolean;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type BinaryBooleanOp = "AND" | "OR" | "=" | ">=" | ">" | "<=" | "<" | "<>" | "!=";

// @alpha
export class BinaryValueExpr extends ValueExpr {
    constructor(op: BinaryValueOp, lhsExpr: ValueExpr, rhsExpr: ValueExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): BinaryValueExpr;
    // (undocumented)
    readonly lhsExpr: ValueExpr;
    // (undocumented)
    readonly op: BinaryValueOp;
    // (undocumented)
    readonly rhsExpr: ValueExpr;
    // (undocumented)
    static readonly type = ExprType.BinaryValue;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type BinaryValueOp = "&" | "|" | "<<" | "||" | "/" | "-" | "*" | "+" | "%";

// @alpha
export abstract class BooleanExpr extends ComputedExpr {
    // (undocumented)
    static readonly deserializableIds: NativeExpIds[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): BooleanExpr | SubqueryTestExpr | BetweenExpr | LikeExpr | InExpr | IsNullExpr | IsOfTypeExpr | NotExpr | BinaryBooleanExpr;
}

// @alpha
export class CastExpr extends ValueExpr {
    constructor(valueExpr: ValueExpr, targetType: string);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): CastExpr;
    // (undocumented)
    readonly targetType: string;
    // (undocumented)
    static readonly type = ExprType.Cast;
    // (undocumented)
    readonly valueExpr: ValueExpr;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class ClassNameExpr extends ClassRefExpr {
    constructor(schemaNameOrAlias: string, className: string, tablespace?: string | undefined, alias?: string | undefined, polymorphicInfo?: PolymorphicInfo | undefined, memberFunc?: MemberFuncCallExpr | undefined);
    // (undocumented)
    readonly alias?: string | undefined;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly className: string;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): ClassNameExpr;
    // (undocumented)
    static fromECSql(ecsql: string): ClassNameExpr;
    // (undocumented)
    readonly memberFunc?: MemberFuncCallExpr | undefined;
    // (undocumented)
    polymorphicInfo?: PolymorphicInfo | undefined;
    // (undocumented)
    readonly schemaNameOrAlias: string;
    // (undocumented)
    readonly tablespace?: string | undefined;
    // (undocumented)
    static readonly type = ExprType.ClassName;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export abstract class ClassRefExpr extends Expr {
    // (undocumented)
    static readonly deserializableIds: NativeExpIds[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): ClassNameExpr | SubqueryRefExpr | UsingRelationshipJoinExpr | QualifiedJoinExpr | CteBlockRefExpr | TableValuedFuncExpr;
}

// @alpha
export type CompoundSelectOp = "UNION" | "UNION ALL" | "INTERSECT" | "EXCEPT";

// @alpha
export abstract class ComputedExpr extends Expr {
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): BooleanExpr | ValueExpr;
}

// @alpha
export class CteBlockExpr extends Expr {
    constructor(name: string, query: SelectStatementExpr, props: string[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): CteBlockExpr;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly props: string[];
    // (undocumented)
    readonly query: SelectStatementExpr;
    // (undocumented)
    static readonly type = ExprType.CteBlock;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class CteBlockRefExpr extends ClassRefExpr {
    constructor(name: string, alias?: string | undefined);
    // (undocumented)
    readonly alias?: string | undefined;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): CteBlockRefExpr;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static readonly type = ExprType.CteBlockRef;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class CteExpr extends StatementExpr {
    constructor(cteBlocks: CteBlockExpr[], query: SelectStatementExpr, recursive?: RecursiveCte | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly cteBlocks: CteBlockExpr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): CteExpr;
    // (undocumented)
    readonly query: SelectStatementExpr;
    // (undocumented)
    readonly recursive?: RecursiveCte | undefined;
    // (undocumented)
    static readonly type = ExprType.Cte;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class DeleteStatementExpr extends StatementExpr {
    constructor(className: ClassNameExpr, where?: WhereClauseExp | undefined, options?: ECSqlOptionsClauseExpr | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly className: ClassNameExpr;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): DeleteStatementExpr;
    // (undocumented)
    readonly options?: ECSqlOptionsClauseExpr | undefined;
    // (undocumented)
    static readonly type = ExprType.DeleteStatement;
    // (undocumented)
    readonly where?: WhereClauseExp | undefined;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class DerivedPropertyExpr extends Expr {
    constructor(computedExpr: ComputedExpr, alias?: string | undefined);
    // (undocumented)
    readonly alias?: string | undefined;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly computedExpr: ComputedExpr;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): DerivedPropertyExpr;
    // (undocumented)
    static readonly type = ExprType.DerivedProperty;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type DisqualifyOp = "+";

// @alpha
export interface ECSqlOption {
    // (undocumented)
    name: ECSqlSupportedOptions;
    // (undocumented)
    value?: string;
}

// @alpha
export class ECSqlOptionsClauseExpr extends Expr {
    constructor(options: ECSqlOption[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): ECSqlOptionsClauseExpr;
    // (undocumented)
    readonly options: ECSqlOption[];
    // (undocumented)
    static readonly type = ExprType.ECSqlOptionsClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type ECSqlSupportedOptions = "NoECClassIdFilter" | "ReadonlyPropertiesAreUpdatable";

// @alpha
export class ECSqlWriter {
    constructor(options?: ECSqlWriterArgs);
    // (undocumented)
    append(val: string): this;
    // (undocumented)
    appendBinaryOp(val: string): this;
    // (undocumented)
    appendComma(): void;
    // (undocumented)
    appendExp(exp: Expr): this;
    // (undocumented)
    appendKeyword(val: Keywords): this;
    // (undocumented)
    appendLine(): this;
    // (undocumented)
    appendLineOrSpace(): this;
    // (undocumented)
    appendParenLeft(): this;
    // (undocumented)
    appendParenRight(): this;
    // (undocumented)
    appendQuoted(val: string): this;
    // (undocumented)
    appendSpace(): this;
    // (undocumented)
    appendStringLiteral(val: string): this;
    // (undocumented)
    clear(): this;
    // (undocumented)
    indent(): void;
    // (undocumented)
    readonly options: ECSqlWriterArgs;
    // (undocumented)
    squash(): this;
    // (undocumented)
    toString(): string;
    // (undocumented)
    unindent(): void;
}

// @alpha
export interface ECSqlWriterArgs {
    // (undocumented)
    readonly eol: "\r\n" | "\n";
    // (undocumented)
    readonly indent: {
        readonly size: number;
        readonly char: string;
    };
    // (undocumented)
    readonly keywordCasing: "lower" | "UPPER";
    // (undocumented)
    readonly multiline: boolean;
    // (undocumented)
    readonly spaceAfterComma: boolean;
    // (undocumented)
    readonly spaceAroundBinOp: boolean;
}

// @alpha
export abstract class Expr {
    constructor(expType: ExprType);
    // (undocumented)
    asInstanceOf<T extends Expr>(type: Constructor<T>): T | undefined;
    // (undocumented)
    abstract get children(): Expr[];
    // (undocumented)
    readonly expType: ExprType;
    findInstancesOf<T extends Expr>(type: Constructor<T>): T[];
    isInstanceOf<T extends Expr>(type: Constructor<T>): boolean;
    toECSql(args?: ECSqlWriterArgs): string;
    traverse(callback: (expr: Expr, parent?: Expr) => void | boolean): void;
    abstract writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class ExprFactory {
    constructor(provider: NativeECSqlParseNodeProvider);
    // (undocumented)
    parseStatement(ecsql: string): Promise<StatementExpr>;
    // (undocumented)
    readonly provider: NativeECSqlParseNodeProvider;
}

// @alpha
export enum ExprType {
    // (undocumented)
    Assignment = "Assignment",
    // (undocumented)
    Between = "Between",
    // (undocumented)
    BinaryBoolean = "BinaryBoolean",
    // (undocumented)
    BinaryValue = "BinaryValue",
    // (undocumented)
    Cast = "Cast",
    // (undocumented)
    ClassName = "ClassName",
    // (undocumented)
    Cte = "Cte",
    // (undocumented)
    CteBlock = "CteBlock",
    // (undocumented)
    CteBlockRef = "CteBlockRef",
    // (undocumented)
    DeleteStatement = "DeleteStatement",
    // (undocumented)
    DerivedProperty = "DerivedProperty",
    // (undocumented)
    ECSqlOptionsClause = "ECSqlOptions",
    // (undocumented)
    FromClause = "FromClause",
    // (undocumented)
    FuncCall = "FuncCall",
    // (undocumented)
    GroupByClause = "GroupByClause",
    // (undocumented)
    HavingClause = "HavingCluase",
    // (undocumented)
    IIF = "IIF",
    // (undocumented)
    In = "In",
    // (undocumented)
    InsertStatement = "InsertStatement",
    // (undocumented)
    IsNull = "IsNull",
    // (undocumented)
    IsOfType = "IsOfType",
    // (undocumented)
    Like = "Like",
    // (undocumented)
    LimitClause = "LimitClause",
    // (undocumented)
    Literal = "Literal",
    // (undocumented)
    MemberFuncCall = "MemberFuncCall",
    // (undocumented)
    NavValueCreationFunc = "NavValueCreationFunc",
    // (undocumented)
    Not = "Not",
    // (undocumented)
    OrderByClause = "OrderByClause",
    // (undocumented)
    OrderBySpec = "OrderBySpec",
    // (undocumented)
    Parameter = "Parameter",
    // (undocumented)
    PropertyName = "PropertyName",
    // (undocumented)
    QualifiedJoin = "QualifiedJoin",
    // (undocumented)
    SearchCase = "SearchCase",
    // (undocumented)
    Select = "Select",
    // (undocumented)
    SelectionClause = "SelectionClause",
    // (undocumented)
    SelectStatement = "SelectStatement",
    // (undocumented)
    SetClause = "SetClause",
    // (undocumented)
    Subquery = "Subquery",
    // (undocumented)
    SubqueryRef = "SubqueryRef",
    // (undocumented)
    SubqueryTest = "SubqueryTest",
    // (undocumented)
    TableValuedFunc = "TableValuedFunc",
    // (undocumented)
    Unary = "Unary",
    // (undocumented)
    UpdateStatement = "UpdateStatement",
    // (undocumented)
    UsingRelationshipJoin = "UsingRelationshipJoin",
    // (undocumented)
    WhereClause = "WhereClause"
}

// @alpha
export type FirstOrLast = "FIRST" | "LAST";

// @alpha
export class FromClauseExpr extends Expr {
    constructor(classRefs: ClassRefExpr[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly classRefs: ClassRefExpr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): FromClauseExpr;
    // (undocumented)
    static readonly type = ExprType.FromClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class FuncCallExpr extends ValueExpr {
    constructor(functionName: string, args: ValueExpr[], allOrDistinct?: AllOrDistinctOp | undefined);
    // (undocumented)
    readonly allOrDistinct?: AllOrDistinctOp | undefined;
    // (undocumented)
    readonly args: ValueExpr[];
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): FuncCallExpr;
    // (undocumented)
    readonly functionName: string;
    // (undocumented)
    static makeAbs(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeEcClassId(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeEcClassName(arg0: ValueExpr, fmt?: "s:c" | "a:c" | "s" | "a" | "c" | "s.c" | "a.c"): FuncCallExpr;
    // (undocumented)
    static makeGuidToStr(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeHexToId(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeIdToHex(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeInstanceOf(arg0: ValueExpr, arg1: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeInstr(arg0: ValueExpr, arg1: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLength(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLHex(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLIfNull(arg0: ValueExpr, arg1: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLike(arg0: ValueExpr, arg1: ValueExpr, arg2?: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLikelihood(arg0: ValueExpr, arg1: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLower(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeLTrim(arg0: ValueExpr, arg1?: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeMax(arg: ValueExpr, ...optionalArgs: ValueExpr[]): FuncCallExpr;
    // (undocumented)
    static makeMin(arg: ValueExpr, ...optionalArgs: ValueExpr[]): FuncCallExpr;
    // (undocumented)
    static makePrintf(arg: ValueExpr, ...optionalArgs: ValueExpr[]): FuncCallExpr;
    // (undocumented)
    static makeQuote(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeRandom(): FuncCallExpr;
    // (undocumented)
    static makeRandomBlob(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeReplace(arg0: ValueExpr, arg1: ValueExpr, arg2: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeRound(arg0: ValueExpr, arg1?: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeRTrim(arg0: ValueExpr, arg1?: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeSign(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeSoundex(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeStrToGuid(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeSubstring(arg0: ValueExpr, arg1: ValueExpr, arg2: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeTrim(arg0: ValueExpr, arg1?: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeTypeOf(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeUnhex(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeUnlikely(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeUpper(arg: ValueExpr): FuncCallExpr;
    // (undocumented)
    static makeZeroBlob(arg0: ValueExpr): FuncCallExpr;
    // (undocumented)
    static readonly type = ExprType.FuncCall;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class GroupByClauseExpr extends Expr {
    constructor(exprList: ValueExpr[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): GroupByClauseExpr;
    // (undocumented)
    readonly exprList: ValueExpr[];
    // (undocumented)
    static readonly type = ExprType.GroupByClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class HavingClauseExpr extends Expr {
    constructor(filterExpr: ComputedExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): HavingClauseExpr;
    // (undocumented)
    readonly filterExpr: ComputedExpr;
    // (undocumented)
    static readonly type = ExprType.HavingClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class IIFExpr extends ValueExpr {
    constructor(whenExpr: BooleanExpr, thenExpr: ValueExpr, elseExpr: ValueExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): IIFExpr;
    // (undocumented)
    readonly elseExpr: ValueExpr;
    // (undocumented)
    readonly thenExpr: ValueExpr;
    // (undocumented)
    static readonly type = ExprType.IIF;
    // (undocumented)
    readonly whenExpr: BooleanExpr;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class InExpr extends BooleanExpr {
    constructor(lhsExpr: ValueExpr, rhsExpr: ValueExpr[] | SubqueryExpr, not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): InExpr;
    // (undocumented)
    readonly lhsExpr: ValueExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    static parseOp(op: string): boolean[];
    // (undocumented)
    readonly rhsExpr: ValueExpr[] | SubqueryExpr;
    // (undocumented)
    static readonly type = ExprType.In;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class InsertStatementExpr extends StatementExpr {
    constructor(className: ClassNameExpr, values: ValueExpr[], propertyNames?: PropertyNameExpr[] | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly className: ClassNameExpr;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): InsertStatementExpr;
    // (undocumented)
    readonly propertyNames?: PropertyNameExpr[] | undefined;
    // (undocumented)
    static readonly type = ExprType.InsertStatement;
    // (undocumented)
    readonly values: ValueExpr[];
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class IsNullExpr extends BooleanExpr {
    constructor(operandExpr: ValueExpr, not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): IsNullExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    readonly operandExpr: ValueExpr;
    // (undocumented)
    static parseOp(node: NativeECSqlParseNode): boolean[];
    // (undocumented)
    static readonly type = ExprType.IsNull;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class IsOfTypeExpr extends BooleanExpr {
    constructor(lhsExpr: ValueExpr, typeNames: ClassNameExpr[], not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): IsOfTypeExpr;
    // (undocumented)
    readonly lhsExpr: ValueExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    static parseOp(node: NativeECSqlParseNode): boolean[];
    // (undocumented)
    static readonly type = ExprType.IsOfType;
    // (undocumented)
    readonly typeNames: ClassNameExpr[];
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type JoinDirection = "FORWARD" | "BACKWARD";

// @alpha
export type JoinSpec = BooleanExpr | string[] | undefined;

// @alpha
export enum JoinType {
    // (undocumented)
    FullOuter = "FULL OUTER JOIN",
    // (undocumented)
    Inner = "INNER JOIN",
    // (undocumented)
    LeftOuter = "LEFT OUTER JOIN",
    // (undocumented)
    RightOuter = "RIGHT OUTER JOIN"
}

// @alpha
export type Keywords = "ALL" | "AND" | "AS" | "ASC" | "BACKWARD" | "BETWEEN" | "BY" | "CASE" | "CAST" | "CROSS" | "DATE" | "DELETE" | "DESC" | "DISTINCT" | "ECSQLOPTIONS" | "ELSE" | "END" | "ESCAPE" | "EXCEPT" | "EXISTS" | "FIRST" | "FORWARD" | "FROM" | "FULL" | "GROUP" | "HAVING" | "IIF" | "IN" | "INNER" | "INSERT" | "INTERSECT" | "INTO" | "IS" | "JOIN" | "LAST" | "LEFT" | "LIKE" | "LIMIT" | "NATURAL" | "NOT" | "NULL" | "NULLS" | "OFFSET" | "ON" | "ONLY" | "OR" | "ORDER" | "OUTER" | "RECURSIVE" | "RIGHT" | "SELECT" | "SET" | "THEN" | "TIME" | "TIMESTAMP" | "UNION" | "UPDATE" | "USING" | "VALUES" | "WHEN" | "WHERE" | "WITH";

// @alpha
export class LikeExpr extends BooleanExpr {
    constructor(lhsExpr: ValueExpr, patternExpr: ValueExpr, escapeExpr?: ValueExpr | undefined, not?: UnaryBooleanOp | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): LikeExpr;
    // (undocumented)
    readonly escapeExpr?: ValueExpr | undefined;
    // (undocumented)
    readonly lhsExpr: ValueExpr;
    // (undocumented)
    readonly not?: UnaryBooleanOp | undefined;
    // (undocumented)
    static parseOp(op: string): boolean[];
    // (undocumented)
    readonly patternExpr: ValueExpr;
    // (undocumented)
    static readonly type = ExprType.Like;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class LimitClauseExpr extends Expr {
    constructor(limit: ValueExpr, offset?: ValueExpr | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): LimitClauseExpr;
    // (undocumented)
    readonly limit: ValueExpr;
    // (undocumented)
    readonly offset?: ValueExpr | undefined;
    // (undocumented)
    static readonly type = ExprType.LimitClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class LiteralExpr extends ValueExpr {
    constructor(valueType: LiteralValueType, rawValue: string);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): LiteralExpr;
    // (undocumented)
    static makeDate(val: Date): LiteralExpr;
    // (undocumented)
    static makeNull(): LiteralExpr;
    // (undocumented)
    static makeNumber(val: number): LiteralExpr;
    // (undocumented)
    static makeRaw(val: string): LiteralExpr;
    // (undocumented)
    static makeString(val: string): LiteralExpr;
    // (undocumented)
    static makeTime(val: Date): LiteralExpr;
    // (undocumented)
    static makeTimestamp(val: Date): LiteralExpr;
    // (undocumented)
    readonly rawValue: string;
    // (undocumented)
    static readonly type = ExprType.Literal;
    // (undocumented)
    readonly valueType: LiteralValueType;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export enum LiteralValueType {
    // (undocumented)
    Date = "DATE",
    // (undocumented)
    Null = "NULL",
    // (undocumented)
    Raw = "RAW",
    // (undocumented)
    String = "STRING",
    // (undocumented)
    Time = "TIME",
    // (undocumented)
    Timestamp = "TIMESTAMP"
}

// @alpha
export class MemberFuncCallExpr extends Expr {
    constructor(functionName: string, args: ValueExpr[]);
    // (undocumented)
    readonly args: ValueExpr[];
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): MemberFuncCallExpr;
    // (undocumented)
    readonly functionName: string;
    // (undocumented)
    static readonly type = ExprType.MemberFuncCall;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export interface NativeECSqlParseNode {
    // (undocumented)
    [key: string]: any;
}

// @alpha
export interface NativeECSqlParseNodeProvider {
    // (undocumented)
    parseECSql: (ecsql: string) => Promise<NativeECSqlParseNode>;
}

// @alpha
export class NavValueCreationFuncExpr extends ValueExpr {
    constructor(columnRefExp: DerivedPropertyExpr, idArgExp: ValueExpr, classNameExp: ClassNameExpr, relECClassIdExp?: ValueExpr | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly classNameExp: ClassNameExpr;
    // (undocumented)
    readonly columnRefExp: DerivedPropertyExpr;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): NavValueCreationFuncExpr;
    // (undocumented)
    readonly idArgExp: ValueExpr;
    // (undocumented)
    static readonly navValueCreationFuncExprName = "NAVIGATION_VALUE";
    // (undocumented)
    readonly relECClassIdExp?: ValueExpr | undefined;
    // (undocumented)
    static readonly type = ExprType.NavValueCreationFunc;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export interface NextSelect {
    // (undocumented)
    op: CompoundSelectOp;
    // (undocumented)
    select: SelectStatementExpr;
}

// @alpha
export class NotExpr extends BooleanExpr {
    constructor(operandExpr: ComputedExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): NotExpr;
    // (undocumented)
    readonly operandExpr: ComputedExpr;
    // (undocumented)
    static readonly type = ExprType.Not;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class OrderByClauseExpr extends Expr {
    constructor(terms: OrderBySpecExpr[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): OrderByClauseExpr;
    // (undocumented)
    readonly terms: OrderBySpecExpr[];
    // (undocumented)
    static readonly type = ExprType.OrderByClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class OrderBySpecExpr extends Expr {
    constructor(term: ValueExpr, sortDirection?: SortDirection | undefined, nulls?: FirstOrLast | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): OrderBySpecExpr;
    // (undocumented)
    readonly nulls?: FirstOrLast | undefined;
    // (undocumented)
    readonly sortDirection?: SortDirection | undefined;
    // (undocumented)
    readonly term: ValueExpr;
    // (undocumented)
    static readonly type = ExprType.OrderBySpec;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class ParameterExpr extends ValueExpr {
    constructor(name?: string | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): ParameterExpr;
    // (undocumented)
    readonly name?: string | undefined;
    // (undocumented)
    static readonly type = ExprType.Parameter;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export interface PolymorphicInfo {
    // (undocumented)
    allOrAny: AllOrAnyOp;
    // (undocumented)
    disqualify?: DisqualifyOp;
}

// @alpha
export class PropertyNameExpr extends ValueExpr {
    constructor(propertyPath: string);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): PropertyNameExpr;
    // (undocumented)
    readonly propertyPath: string;
    // (undocumented)
    static readonly type = ExprType.PropertyName;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class QualifiedJoinExpr extends ClassRefExpr {
    constructor(joinType: JoinType, from: ClassRefExpr, to: ClassRefExpr, spec: JoinSpec);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): QualifiedJoinExpr;
    // (undocumented)
    readonly from: ClassRefExpr;
    // (undocumented)
    readonly joinType: JoinType;
    // (undocumented)
    readonly spec: JoinSpec;
    // (undocumented)
    readonly to: ClassRefExpr;
    // (undocumented)
    static readonly type = ExprType.QualifiedJoin;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type RecursiveCte = "RECURSIVE";

// @alpha
export class SearchCaseExpr extends ValueExpr {
    constructor(whenThenList: WhenThenBlock[], elseExpr?: ValueExpr | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SearchCaseExpr;
    // (undocumented)
    readonly elseExpr?: ValueExpr | undefined;
    // (undocumented)
    static readonly type = ExprType.SearchCase;
    // (undocumented)
    readonly whenThenList: WhenThenBlock[];
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SelectExpr extends Expr {
    constructor(selection: SelectionClauseExpr, rowQuantifier?: AllOrDistinctOp | undefined, from?: FromClauseExpr | undefined, where?: WhereClauseExp | undefined, groupBy?: GroupByClauseExpr | undefined, having?: HavingClauseExpr | undefined, orderBy?: OrderByClauseExpr | undefined, limit?: LimitClauseExpr | undefined, options?: ECSqlOptionsClauseExpr | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SelectExpr;
    // (undocumented)
    readonly from?: FromClauseExpr | undefined;
    // (undocumented)
    readonly groupBy?: GroupByClauseExpr | undefined;
    // (undocumented)
    readonly having?: HavingClauseExpr | undefined;
    // (undocumented)
    readonly limit?: LimitClauseExpr | undefined;
    // (undocumented)
    readonly options?: ECSqlOptionsClauseExpr | undefined;
    // (undocumented)
    readonly orderBy?: OrderByClauseExpr | undefined;
    // (undocumented)
    readonly rowQuantifier?: AllOrDistinctOp | undefined;
    // (undocumented)
    readonly selection: SelectionClauseExpr;
    // (undocumented)
    static readonly type = ExprType.Select;
    // (undocumented)
    readonly where?: WhereClauseExp | undefined;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SelectionClauseExpr extends Expr {
    constructor(derivedPropertyList: DerivedPropertyExpr[]);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly derivedPropertyList: DerivedPropertyExpr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SelectionClauseExpr;
    // (undocumented)
    static readonly type = ExprType.SelectionClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SelectStatementExpr extends StatementExpr {
    constructor(singleSelect: SelectExpr, nextSelect?: NextSelect | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SelectStatementExpr;
    // (undocumented)
    readonly nextSelect?: NextSelect | undefined;
    // (undocumented)
    readonly singleSelect: SelectExpr;
    // (undocumented)
    static readonly type = ExprType.SelectStatement;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SetClauseExpr extends Expr {
    constructor(assignments: AssignmentExpr[]);
    // (undocumented)
    readonly assignments: AssignmentExpr[];
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SetClauseExpr;
    // (undocumented)
    static readonly type = ExprType.SetClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type SortDirection = "ASC" | "DESC";

// @alpha
export abstract class StatementExpr extends Expr {
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): StatementExpr | InsertStatementExpr | UpdateStatementExpr | DeleteStatementExpr | CteExpr;
}

// @alpha
export class SubqueryExpr extends ValueExpr {
    constructor(query: SelectStatementExpr | CteExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SubqueryExpr;
    // (undocumented)
    readonly query: SelectStatementExpr | CteExpr;
    // (undocumented)
    static readonly type = ExprType.Subquery;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SubqueryRefExpr extends ClassRefExpr {
    constructor(query: SubqueryExpr, polymorphicInfo?: PolymorphicInfo | undefined, alias?: string | undefined);
    // (undocumented)
    readonly alias?: string | undefined;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SubqueryRefExpr;
    // (undocumented)
    readonly polymorphicInfo?: PolymorphicInfo | undefined;
    // (undocumented)
    readonly query: SubqueryExpr;
    // (undocumented)
    static readonly type = ExprType.SubqueryRef;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class SubqueryTestExpr extends BooleanExpr {
    constructor(op: SubqueryTestOp, query: SubqueryExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SubqueryTestExpr;
    // (undocumented)
    readonly op: SubqueryTestOp;
    // (undocumented)
    readonly query: SubqueryExpr;
    // (undocumented)
    static readonly type = ExprType.SubqueryTest;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type SubqueryTestOp = "EXISTS";

// @alpha
export class TableValuedFuncExpr extends ClassRefExpr {
    constructor(schemaName: string, memberFunc: MemberFuncCallExpr, alias?: string | undefined);
    // (undocumented)
    readonly alias?: string | undefined;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): TableValuedFuncExpr;
    // (undocumented)
    readonly memberFunc: MemberFuncCallExpr;
    // (undocumented)
    readonly schemaName: string;
    // (undocumented)
    static readonly type = ExprType.TableValuedFunc;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type UnaryBooleanOp = "NOT";

// @alpha
export class UnaryValueExpr extends ValueExpr {
    constructor(op: UnaryValueOp, valueExpr: ValueExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): UnaryValueExpr;
    // (undocumented)
    readonly op: UnaryValueOp;
    // (undocumented)
    static readonly type = ExprType.Unary;
    // (undocumented)
    readonly valueExpr: ValueExpr;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export type UnaryValueOp = "-" | "+" | "~";

// @alpha
export class UpdateStatementExpr extends StatementExpr {
    constructor(className: ClassNameExpr, assignement: SetClauseExpr, where?: WhereClauseExp | undefined, options?: ECSqlOptionsClauseExpr | undefined);
    // (undocumented)
    readonly assignement: SetClauseExpr;
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    readonly className: ClassNameExpr;
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): UpdateStatementExpr;
    // (undocumented)
    readonly options?: ECSqlOptionsClauseExpr | undefined;
    // (undocumented)
    static readonly type = ExprType.UpdateStatement;
    // (undocumented)
    readonly where?: WhereClauseExp | undefined;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export class UsingRelationshipJoinExpr extends ClassRefExpr {
    constructor(fromClassName: ClassRefExpr, toClassName: ClassNameExpr, toRelClassName: ClassNameExpr, direction?: JoinDirection | undefined);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): UsingRelationshipJoinExpr;
    // (undocumented)
    readonly direction?: JoinDirection | undefined;
    // (undocumented)
    readonly fromClassName: ClassRefExpr;
    // (undocumented)
    readonly toClassName: ClassNameExpr;
    // (undocumented)
    readonly toRelClassName: ClassNameExpr;
    // (undocumented)
    static readonly type = ExprType.UsingRelationshipJoin;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// @alpha
export abstract class ValueExpr extends ComputedExpr {
    // (undocumented)
    static readonly deserializableIds: NativeExpIds[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): SubqueryExpr | ValueExpr | UnaryValueExpr | FuncCallExpr | CastExpr | BinaryValueExpr | SearchCaseExpr | IIFExpr | LiteralExpr | PropertyNameExpr | NavValueCreationFuncExpr;
}

// @alpha
export interface WhenThenBlock {
    // (undocumented)
    thenExpr: ValueExpr;
    // (undocumented)
    whenExpr: BooleanExpr;
}

// @alpha
export class WhereClauseExp extends Expr {
    constructor(filterExpr: ComputedExpr);
    // (undocumented)
    get children(): Expr[];
    // (undocumented)
    static deserialize(node: NativeECSqlParseNode): WhereClauseExp;
    // (undocumented)
    readonly filterExpr: ComputedExpr;
    // (undocumented)
    static readonly type = ExprType.WhereClause;
    // (undocumented)
    writeTo(writer: ECSqlWriter): void;
}

// (No @packageDocumentation comment for this package)

```
