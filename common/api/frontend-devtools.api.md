## API Report File for "@itwin/frontend-devtools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AxisAlignedBox3d } from '@itwin/core-common';
import { BeButtonEvent } from '@itwin/core-frontend';
import { BeDuration } from '@itwin/core-bentley';
import { Camera } from '@itwin/core-common';
import { ColorDef } from '@itwin/core-common';
import { ContextRealityModelState } from '@itwin/core-frontend';
import { DecorateContext } from '@itwin/core-frontend';
import { Decorator } from '@itwin/core-frontend';
import { EmphasizeElements } from '@itwin/core-frontend';
import { EventHandled } from '@itwin/core-frontend';
import { FlashSettings } from '@itwin/core-frontend';
import { GeometrySummaryOptions } from '@itwin/core-common';
import { GpuMemoryLimit } from '@itwin/core-frontend';
import { Hilite } from '@itwin/core-common';
import { HitDetail } from '@itwin/core-frontend';
import { Id64Arg } from '@itwin/core-bentley';
import { Id64String } from '@itwin/core-bentley';
import { IModelConnection } from '@itwin/core-frontend';
import { LinePixels } from '@itwin/core-common';
import { LocateFilterStatus } from '@itwin/core-frontend';
import { LocateResponse } from '@itwin/core-frontend';
import { MapLayerSource } from '@itwin/core-frontend';
import { ParticleProps } from '@itwin/core-frontend';
import { PlanarClipMaskSettings } from '@itwin/core-common';
import { Point3d } from '@itwin/core-geometry';
import { PrimitiveTool } from '@itwin/core-frontend';
import { Range1d } from '@itwin/core-geometry';
import { Range2d } from '@itwin/core-geometry';
import { Range3d } from '@itwin/core-geometry';
import { RenderSystemDebugControl } from '@itwin/core-frontend';
import { RenderTargetDebugControl } from '@itwin/core-frontend';
import { RgbColor } from '@itwin/core-common';
import { RgbColorProps } from '@itwin/core-common';
import { ScreenSpaceEffectBuilder } from '@itwin/core-frontend';
import { ScreenSpaceEffectSource } from '@itwin/core-frontend';
import { ScreenViewport } from '@itwin/core-frontend';
import { TileBoundingBoxes } from '@itwin/core-frontend';
import { Tool } from '@itwin/core-frontend';
import { Vector2d } from '@itwin/core-geometry';
import { ViewFlags } from '@itwin/core-common';
import { Viewport } from '@itwin/core-frontend';
import { ViewState } from '@itwin/core-frontend';
import { ViewStateProps } from '@itwin/core-common';

// @beta
export abstract class AddEffectTool extends Tool {
    protected abstract defineEffect(builder: ScreenSpaceEffectBuilder): void;
    protected abstract get effectName(): string;
    // (undocumented)
    run(): Promise<boolean>;
    protected abstract get source(): ScreenSpaceEffectSource;
    protected abstract get textureCoordFromPosition(): boolean;
}

// @beta
export class AnimationIntervalTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(interval?: BeDuration): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export function appendDataListEntries(dl: DataList, entries: DataListEntry[]): void;

// @beta
export class ApplyRenderingStyleTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ApplyViewByIdTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(viewId?: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ApplyViewTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(view?: ViewState): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachArcGISMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {
    constructor();
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachCesiumAssetTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(assetId: number, requestKey: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachMapLayerTool extends AttachMapLayerBaseTool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachMapOverlayTool extends AttachMapLayerTool {
    constructor();
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachRealityModelTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(data: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachTileURLMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {
    constructor();
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachWmsMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {
    constructor();
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class AttachWmtsMapLayerByUrlTool extends AttachMapLayerByURLBaseTool {
    constructor();
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha
export interface Button {
    // (undocumented)
    button: HTMLInputElement;
    // (undocumented)
    div: HTMLElement;
}

// @alpha
export type ButtonHandler = (button: HTMLInputElement) => void;

// @alpha
export interface ButtonProps {
    // (undocumented)
    handler: ButtonHandler;
    // (undocumented)
    id?: string;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    value: string;
}

// @beta
export class ChangeBackgroundColorTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeCameraTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...inArgs: string[]): Promise<boolean>;
    // (undocumented)
    run(camera?: Camera): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeEmphasisSettingsTool extends ChangeHiliteTool {
    // (undocumented)
    protected apply(vp: Viewport, settings?: Hilite.Settings): void;
    // (undocumented)
    protected getCurrentSettings(vp: Viewport): Hilite.Settings;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeFlashSettingsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...inputArgs: string[]): Promise<boolean>;
    // (undocumented)
    run(settings?: FlashSettings): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeHiliteSettingsTool extends ChangeHiliteTool {
    // (undocumented)
    protected apply(vp: Viewport, settings?: Hilite.Settings): void;
    // (undocumented)
    protected getCurrentSettings(vp: Viewport): Hilite.Settings;
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class ChangeHiliteTool extends Tool {
    // (undocumented)
    protected abstract apply(vp: Viewport, settings: Hilite.Settings | undefined): void;
    // (undocumented)
    protected abstract getCurrentSettings(vp: Viewport): Hilite.Settings;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...inputArgs: string[]): Promise<boolean>;
    // (undocumented)
    run(settings?: Hilite.Settings): Promise<boolean>;
}

// @beta
export abstract class ChangePlanProjectionSettingsTool extends DisplayStyleTool {
    // (undocumented)
    protected execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected parse(inputArgs: string[]): Promise<boolean>;
    // (undocumented)
    protected get require3d(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeUnitsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(useMetric?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ChangeViewFlagsTool extends Tool {
    // (undocumented)
    static get maxArgs(): undefined;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(vf: ViewFlags, vp?: Viewport): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export interface CheckBox {
    // (undocumented)
    checkbox: HTMLInputElement;
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    label: HTMLLabelElement;
}

// @alpha (undocumented)
export type CheckBoxHandler = (checkbox: HTMLInputElement) => void;

// @alpha (undocumented)
export interface CheckBoxProps {
    // (undocumented)
    handler: CheckBoxHandler;
    // (undocumented)
    id: string;
    // (undocumented)
    isChecked?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    typeOverride?: string;
}

// @beta
export class ClearEffectsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ClearEmphasizedElementsTool extends EmphasizeElementsTool {
    // (undocumented)
    execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected get _wantClear(): boolean;
    // (undocumented)
    protected get _wantCreate(): boolean;
}

// @beta
export class ClearIsolatedElementsTool extends EmphasizeElementsTool {
    // (undocumented)
    execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected get _wantCreate(): boolean;
}

// @beta
export class ClearModelAppearanceOverrides extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(name?: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ClearRealityModelAppearanceOverrides extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ClipColorTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export interface ColorInput {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    input: HTMLInputElement;
    // (undocumented)
    label?: HTMLLabelElement;
}

// @alpha (undocumented)
export type ColorInputHandler = (value: string) => void;

// @alpha (undocumented)
export interface ColorInputProps {
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    display?: "inline" | "none" | "block";
    // (undocumented)
    handler: ColorInputHandler;
    // (undocumented)
    id?: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    value: string;
}

// @alpha (undocumented)
export interface ComboBox {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    label?: HTMLLabelElement;
    // (undocumented)
    select: HTMLSelectElement;
}

// @alpha (undocumented)
export interface ComboBoxEntry {
    // (undocumented)
    name: string;
    // (undocumented)
    value: number | string | undefined;
}

// @alpha (undocumented)
export type ComboBoxHandler = (select: HTMLSelectElement) => void;

// @alpha (undocumented)
export interface ComboBoxProps {
    // (undocumented)
    entries: ComboBoxEntry[];
    // (undocumented)
    handler?: ComboBoxHandler;
    // (undocumented)
    id: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    value?: number | string;
}

// @beta
export class CompileShadersTool extends RenderSystemDebugControlTool {
    // (undocumented)
    execute(control: RenderSystemDebugControl): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export function convertHexToRgb(hex: string): RgbColor | undefined;

// @beta
export abstract class ConvolutionEffect extends AddEffectTool {
    // (undocumented)
    protected defineEffect(builder: ScreenSpaceEffectBuilder): void;
    // (undocumented)
    protected abstract get matrix(): number[];
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected get source(): {
        vertex: string;
        fragment: string;
    };
    // (undocumented)
    protected get textureCoordFromPosition(): boolean;
}

// @beta
export function copyStringToClipboard(str: string): void;

// @alpha
export function createButton(props: ButtonProps): Button;

// @alpha (undocumented)
export function createCheckBox(props: CheckBoxProps): CheckBox;

// @alpha (undocumented)
export function createColorInput(props: ColorInputProps): ColorInput;

// @alpha (undocumented)
export function createComboBox(props: ComboBoxProps): ComboBox;

// @alpha (undocumented)
export function createDataList(props: DataListProps): DataList;

// @alpha (undocumented)
export function createLabeledNumericInput(props: LabeledNumericInputProps): LabeledNumericInput;

// @alpha (undocumented)
export function createNestedMenu(props: NestedMenuProps): NestedMenu;

// @alpha (undocumented)
export function createNumericInput(props: NumericInputProps, useFloat?: boolean): HTMLInputElement;

// @alpha (undocumented)
export function createRadioBox(props: RadioBoxProps): RadioBox;

// @alpha (undocumented)
export function createSlider(props: SliderProps): Slider;

// @alpha (undocumented)
export function createTextBox(props: TextBoxProps): TextBox;

// @alpha (undocumented)
export interface DataList {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    list: HTMLDataListElement;
}

// @alpha (undocumented)
export interface DataListEntry {
    // (undocumented)
    value: number | string | undefined;
}

// @alpha (undocumented)
export type DataListHandler = (list: HTMLDataListElement) => void;

// @alpha (undocumented)
export interface DataListProps {
    // (undocumented)
    entries: DataListEntry[];
    // (undocumented)
    handler?: DataListHandler;
    // (undocumented)
    id: string;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    parent?: HTMLElement;
}

// @beta
export class DefaultTileSizeModifierTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(modifier?: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export function deserializeViewState(props: ViewStateProps, iModel: IModelConnection): Promise<ViewState>;

// @beta
export class DetachMapLayersTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(..._args: string[]): Promise<boolean>;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class DetachRealityModelTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class DiagnosticsPanel {
    constructor(vp: Viewport, props?: DiagnosticsPanelProps);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get element(): HTMLElement;
    // (undocumented)
    readonly keyinField?: KeyinField;
    }

// @beta
export interface DiagnosticsPanelProps {
    exclude?: {
        keyin?: boolean;
        fps?: boolean;
        tileStats?: boolean;
        memory?: boolean;
        tileMemoryBreakdown?: boolean;
        renderCommands?: boolean;
        gpuProfiler?: boolean;
        toolSettings?: boolean;
    };
}

// @beta
export abstract class DisplayStyleTool extends Tool {
    // (undocumented)
    protected abstract execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    protected abstract parse(args: string[], vp: Viewport): Promise<boolean>;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    protected get require3d(): boolean;
    // (undocumented)
    run(): Promise<boolean>;
}

// @beta
export class DumpPlanProjectionSettingsTool extends DisplayStyleTool {
    // (undocumented)
    protected execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected parse(args: string[]): Promise<boolean>;
    // (undocumented)
    protected get require3d(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class EdgeDetectionEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @beta
export class ElementIdFromSourceAspectIdTool extends SourceAspectIdTool {
    // (undocumented)
    protected getECSql(queryId: string): string;
    // (undocumented)
    static toolId: string;
}

// @beta
export class EmbossEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class EmphasizeElementsTool extends Tool {
    // (undocumented)
    protected abstract execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    run(_args: any[]): Promise<boolean>;
    // (undocumented)
    protected get _wantClear(): boolean;
    // (undocumented)
    protected get _wantCreate(): boolean;
}

// @beta
export class EmphasizeSelectedElementsTool extends EmphasizeElementsTool {
    // (undocumented)
    execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
    }

// @beta
export class EmphasizeVisibleElementsTool extends EmphasizeElementsTool {
    // (undocumented)
    execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...input: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected get _wantClear(): boolean;
}

// @beta
export class ExplosionEffect extends Tool {
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class FadeOutTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class FlipImageConfig extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...input: string[]): Promise<boolean>;
    // (undocumented)
    run(horizontal?: boolean, vertical?: boolean, color?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class FlipImageEffect extends AddEffectTool {
    // (undocumented)
    protected defineEffect(builder: ScreenSpaceEffectBuilder): void;
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get source(): {
        vertex: string;
        fragment: string;
        sampleSourcePixel: string;
    };
    // (undocumented)
    protected get textureCoordFromPosition(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export function formatMemory(numBytes: number): string;

// @beta
export class FpsTracker {
    constructor(parent: HTMLElement, viewport: Viewport);
    // (undocumented)
    dispose(): void;
    }

// @beta
export class FreezeSceneTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class FrontendDevTools {
    static initialize(): Promise<void>;
    }

// @beta
export class FrustumDecorator implements Decorator {
    // (undocumented)
    decorate(context: DecorateContext): void;
    static disable(): void;
    static enable(vp: Viewport, options?: FrustumDecorationOptions): void;
    // (undocumented)
    static get isEnabled(): boolean;
    readonly useCachedDecorations = true;
}

// @beta
export class GaussianBlurEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class GpuProfiler {
    constructor(parent: HTMLElement);
    // (undocumented)
    dispose(): void;
    }

// @beta
export class InspectElementTool extends PrimitiveTool {
    constructor(options?: GeometrySummaryOptions, elementIds?: Id64String[]);
    // (undocumented)
    autoLockTarget(): void;
    // (undocumented)
    filterHit(hit: HitDetail, _out: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onReinitialize(): Promise<void>;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    parseAndRun(...inputArgs: string[]): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    static toolId: string;
    }

// @beta
export class IsolateSelectedElementsTool extends EmphasizeElementsTool {
    // (undocumented)
    execute(emph: EmphasizeElements, vp: ScreenViewport): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class KeyinField {
    constructor(props: KeyinFieldProps);
    // @alpha (undocumented)
    readonly autoCompleteList: DataList;
    // (undocumented)
    focus(): void;
    // (undocumented)
    readonly keyins: string[];
    // (undocumented)
    loseFocus(): void;
    // (undocumented)
    selectAll(): void;
    // (undocumented)
    readonly textBox: TextBox;
}

// @beta
export enum KeyinFieldLocalization {
    Both = 2,
    Localized = 1,
    NonLocalized = 0
}

// @beta
export interface KeyinFieldProps {
    baseId: string;
    historyLength?: number;
    localization?: KeyinFieldLocalization;
    parent?: HTMLElement;
    wantButton?: boolean;
    wantLabel?: boolean;
}

// @alpha (undocumented)
export interface LabeledNumericInput {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    input: HTMLInputElement;
    // (undocumented)
    label: HTMLLabelElement;
}

// @alpha (undocumented)
export interface LabeledNumericInputProps extends NumericInputProps {
    // (undocumented)
    id: string;
    // (undocumented)
    name: string;
}

// @beta
export class LensDistortionConfig extends Tool {
    // (undocumented)
    static cylindricalRatio: number;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...input: string[]): Promise<boolean>;
    // (undocumented)
    run(strength?: number, ratio?: number): Promise<boolean>;
    // (undocumented)
    static strength: number;
    // (undocumented)
    static toolId: string;
}

// @beta
export class LensDistortionEffect extends AddEffectTool {
    // (undocumented)
    protected defineEffect(builder: ScreenSpaceEffectBuilder): void;
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get source(): {
        vertex: string;
        fragment: string;
        sampleSourcePixel: string;
    };
    // (undocumented)
    protected get textureCoordFromPosition(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class LoseWebGLContextTool extends RenderSystemDebugControlTool {
    // (undocumented)
    execute(control: RenderSystemDebugControl): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapBaseColorTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(color: ColorDef): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapBaseTransparencyTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(transparency: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapBaseVisibilityTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(visible: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapLayerSubLayerVisibilityTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(layerIndex: number, visible: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapLayerTransparencyTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(layerIndex: number, transparency: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapLayerVisibilityTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(layerIndex: number, enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MapLayerZoomTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(layerIndex: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskBackgroundMapByElementTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskBackgroundMapByExcludedElementTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskBackgroundMapByModelTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskBackgroundMapBySubCategoryTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected allowSelection(): boolean;
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskRealityModelByElementTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskRealityModelByExcludedElementTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskRealityModelByModelTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MaskRealityModelBySubCategoryTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected allowSelection(): boolean;
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MeasureTileLoadTimeTool extends Tool {
    run(_args: any[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class MemoryTracker {
    constructor(parent: HTMLElement, vp: Viewport);
    // (undocumented)
    dispose(): void;
    }

// @alpha (undocumented)
export interface NestedMenu {
    // (undocumented)
    body: HTMLElement;
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    label: HTMLLabelElement;
}

// @alpha (undocumented)
export interface NestedMenuProps {
    // (undocumented)
    body?: HTMLElement;
    // (undocumented)
    expand?: boolean;
    // (undocumented)
    handler?: NestMenuHandler;
    // (undocumented)
    id?: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    parent?: HTMLElement;
}

// @alpha (undocumented)
export type NestMenuHandler = (expanded: boolean) => void;

// @alpha (undocumented)
export type NumericInputHandler = (value: number, input: HTMLInputElement) => void;

// @alpha (undocumented)
export interface NumericInputProps {
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    display?: "inline" | "none" | "block";
    // (undocumented)
    handler: NumericInputHandler;
    // (undocumented)
    id?: string;
    // (undocumented)
    max?: number;
    // (undocumented)
    min?: number;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    parseAsFloat?: true;
    // (undocumented)
    step?: number;
    // (undocumented)
    tooltip?: string;
    // (undocumented)
    value: number;
}

// @beta
export abstract class OverrideSubCategoryPriorityTool extends DisplayStyleTool {
    // (undocumented)
    protected execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected parse(args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class OverrideSubCategoryTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(inArgs: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export function parseArgs(args: string[]): ToolArgs;

// @beta
export function parseBoolean(arg: string | undefined): boolean | undefined;

// @beta
export function parseToggle(arg: string | undefined): string | boolean | undefined;

// @beta
export abstract class PlanarMaskBaseTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedElementIds: Set<string>;
    // (undocumented)
    protected readonly _acceptedModelIds: Set<string>;
    // (undocumented)
    protected readonly _acceptedSubCategoryIds: Set<string>;
    // (undocumented)
    protected allowSelection(): boolean;
    // (undocumented)
    protected abstract applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createElementMask(option: "include" | "exclude"): PlanarClipMaskSettings;
    // (undocumented)
    protected createModelMask(): PlanarClipMaskSettings;
    // (undocumented)
    protected createSubCategoryMask(): PlanarClipMaskSettings;
    // (undocumented)
    protected abstract createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    protected elementRequired(): boolean;
    // (undocumented)
    exitTool(): Promise<void>;
    // (undocumented)
    filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    protected _invert: boolean;
    // (undocumented)
    onCleanup(): Promise<void>;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): Promise<void>;
    // (undocumented)
    onRestartTool(): Promise<void>;
    // (undocumented)
    onUnsuspend(): Promise<void>;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setRealityModelMask(vp: ScreenViewport, mask: PlanarClipMaskSettings): void;
    // (undocumented)
    protected abstract showPrompt(): void;
    // (undocumented)
    protected _targetMaskModel?: Id64String | ContextRealityModelState;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    protected _transparency: number;
    // (undocumented)
    protected _useSelection: boolean;
}

// @beta (undocumented)
export class ProjectExtentsDecoration {
    constructor(iModel: IModelConnection);
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected _extents: AxisAlignedBox3d;
    // (undocumented)
    protected _removeDecorationListener?: () => void;
    // (undocumented)
    protected stop(): void;
    // (undocumented)
    static toggle(imodel: IModelConnection, enabled?: boolean): boolean;
    // (undocumented)
    protected updateDecorationListener(add: boolean): void;
    readonly useCachedDecorations = true;
}

// @beta
export class QueryScheduleScriptTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(input: string[], vp: Viewport): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export interface RadioBox {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    label?: HTMLLabelElement;
    // (undocumented)
    setValue: (newValue: number | string) => boolean;
}

// @alpha (undocumented)
export interface RadioBoxEntry {
    // (undocumented)
    label: string;
    // (undocumented)
    value: number | string | undefined;
}

// @alpha (undocumented)
export type RadioBoxHandler = (value: string, form: HTMLFormElement) => void;

// @alpha (undocumented)
export interface RadioBoxProps {
    // (undocumented)
    defaultValue?: number | string;
    // (undocumented)
    entries: RadioBoxEntry[];
    // (undocumented)
    handler: RadioBoxHandler;
    // (undocumented)
    id: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    vertical?: boolean;
}

// @beta
export function randomFloat(min: number, max: number): number;

// @beta
export function randomFloatInRange(range: Range1d): number;

// @beta
export function randomInteger(min: number, max: number): number;

// @beta
export function randomIntegerInRange(range: Range1d): number;

// @beta
export function randomPositionInRange(range: Range3d): Point3d;

// @beta
export class RealityTransitionTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(fadeMode?: FadeMode): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export function refreshViewportsForEffect(effectName: string): void;

// @beta
export abstract class RenderSystemDebugControlTool extends Tool {
    // (undocumented)
    protected abstract execute(_control: RenderSystemDebugControl): void;
    // (undocumented)
    run(_args: any[]): Promise<boolean>;
}

// @beta
export abstract class RenderTargetDebugControlToggleTool extends RenderTargetDebugControlTool {
    // (undocumented)
    protected abstract get aspect(): DebugControlBoolean;
    // (undocumented)
    protected execute(control: RenderTargetDebugControl, vp: ScreenViewport): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
}

// @beta
export abstract class RenderTargetDebugControlTool extends Tool {
    // (undocumented)
    protected abstract execute(_control: RenderTargetDebugControl, _vp: ScreenViewport): void;
    // (undocumented)
    run(_args: any[]): Promise<boolean>;
}

// @beta
export class ReorderMapLayers extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(from: number, to: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ReportWebGLCompatibilityTool extends Tool {
    // (undocumented)
    run(_args: any[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SaturationConfig extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    static multiplier: number;
    // (undocumented)
    parseAndRun(...input: string[]): Promise<boolean>;
    // (undocumented)
    run(multiplier?: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SaturationEffect extends AddEffectTool {
    // (undocumented)
    protected defineEffect(builder: ScreenSpaceEffectBuilder): void;
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get source(): {
        vertex: string;
        fragment: string;
    };
    // (undocumented)
    protected get textureCoordFromPosition(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SaveRealityModelTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(name: string | undefined): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SaveRenderingStyleTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(inputArgs: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SaveViewTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(inputArgs: string[]): boolean;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SelectElementsByIdTool extends Tool {
    // (undocumented)
    static get maxArgs(): undefined;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(ids?: Id64Arg): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export function serializeViewState(view: ViewState): ViewStateProps;

// @beta
export class SetAASamplesTool extends RenderTargetDebugControlTool {
    // (undocumented)
    execute(_control: RenderTargetDebugControl, vp: ScreenViewport): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetAspectRatioSkewTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(skew?: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetGpuMemoryLimitTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(limit?: GpuMemoryLimit): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetHigherPriorityRealityModelMasking extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    protected elementRequired(): boolean;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetMapBaseTool extends AttachMapLayerTool {
    constructor();
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetMapHigherPriorityMasking extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(transparency: number, invert: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelColorTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(rgb: RgbColorProps, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelEmphasizedTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(emphasized: true | undefined, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelIgnoresMaterialsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(ignoresMaterial: true | undefined, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelLineCodeTool extends Tool {
    // (undocumented)
    static linePixels: LinePixels[];
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(lineCode: number, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelLineWeightTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(weight: number, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelLocateTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(locate: boolean, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetModelTransparencyTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(transparency: number, name: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetRealityModelColorTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(rgb: RgbColorProps, index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetRealityModelEmphasizedTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(emphasized: true | undefined, index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetRealityModelLocateTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(locate: boolean, index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SetRealityModelTransparencyTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(transparency: number, index: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SharpenEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @beta
export class SharpnessEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @beta
export class ShowTileVolumesTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(boxes?: TileBoundingBoxes): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SkyCubeTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    get require3d(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class SkySphereTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    get require3d(): boolean;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export interface Slider {
    // (undocumented)
    div: HTMLDivElement;
    // (undocumented)
    label: HTMLLabelElement;
    // (undocumented)
    slider: HTMLInputElement;
}

// @alpha (undocumented)
export type SliderHandler = (slider: HTMLInputElement) => void;

// @alpha (undocumented)
export interface SliderProps {
    // (undocumented)
    handler: SliderHandler;
    // (undocumented)
    id: string;
    // (undocumented)
    max: string;
    // (undocumented)
    min: string;
    // (undocumented)
    name: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    step: string;
    // (undocumented)
    value: string;
}

// @beta
export class SnowDecorator implements Decorator {
    configure(params: Partial<SnowParams>): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    readonly dispose: VoidFunction;
    static toggle(viewport: Viewport, enable?: boolean): Promise<void>;
    readonly viewport: Viewport;
}

// @beta
export class SnowEffect extends Tool {
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export interface SnowParams {
    accelerationRange: Range2d;
    numParticles: number;
    sizeRange: Range1d;
    transparencyRange: Range1d;
    velocityRange: Range2d;
    windVelocity: number;
}

// @beta
export interface SnowParticle extends ParticleProps {
    velocity: Vector2d;
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    z: number;
}

// @beta
export class SourceAspectIdFromElementIdTool extends SourceAspectIdTool {
    // (undocumented)
    protected getECSql(queryId: string): string;
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class SourceAspectIdTool extends Tool {
    // (undocumented)
    protected abstract getECSql(queryId: string): string;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...keyinArgs: string[]): Promise<boolean>;
    // (undocumented)
    run(idToQuery?: string, copyToClipboard?: boolean): Promise<boolean>;
}

// @beta
export class TestClipStyleTool extends DisplayStyleTool {
    // (undocumented)
    protected execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    protected parse(args: string[]): Promise<boolean>;
    // (undocumented)
    protected get require3d(): boolean;
    // (undocumented)
    static toolId: string;
    }

// @beta
export interface TextBox {
    div: HTMLDivElement;
    label?: HTMLLabelElement;
    textbox: HTMLInputElement;
}

// @alpha (undocumented)
export type TextBoxHandler = (textbox: HTMLInputElement) => void;

// @alpha (undocumented)
export type TextBoxKeyPressHandler = (textbox: HTMLInputElement, ev: KeyboardEvent) => void;

// @alpha (undocumented)
export interface TextBoxProps {
    // (undocumented)
    focushandler?: TextBoxHandler;
    // (undocumented)
    handler?: TextBoxHandler;
    // (undocumented)
    id?: string;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    keypresshandler?: TextBoxKeyPressHandler;
    // (undocumented)
    label?: string;
    // (undocumented)
    list?: string;
    // (undocumented)
    parent?: HTMLElement;
    // (undocumented)
    tooltip?: string;
}

// @beta
export class TileMemoryBreakdown {
    constructor(parent: HTMLElement);
    // (undocumented)
    dispose(): void;
    }

// @beta
export class TileStatisticsTracker {
    constructor(parent: HTMLElement, vp: Viewport);
    // (undocumented)
    dispose(): void;
    }

// @beta
export class Toggle3dManipulationsTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, allow?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleDPIForLODTool extends RenderSystemDebugControlTool {
    // (undocumented)
    execute(control: RenderSystemDebugControl): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleDrapeFrustumTool extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleDrawingGraphicsTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleFrustumSnapshotTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean, showPreloadFrustum?: boolean, showBackgroundIntersections?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleOSMBuildingDisplay extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(onOff?: boolean, transparency?: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class TogglePrimitiveVisibilityTool extends RenderTargetDebugControlTool {
    // (undocumented)
    execute(control: RenderTargetDebugControl, vp: ScreenViewport): void;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
    }

// @beta
export function toggleProjectExtents(imodel: IModelConnection, enabled?: boolean): boolean;

// @beta
export class ToggleProjectExtentsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleReadPixelsTool extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleRealityTileBounds extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleRealityTileFreeze extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleRealityTileLogging extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleRealityTilePreload extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleSectionCutTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(produceCutGeometry?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleSectionDrawingSpatialViewTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleSelectedViewFrustumTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleShadowFrustumTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleSkyboxTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    parse(_args: string[]): Promise<boolean>;
    // (undocumented)
    get require3d(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleTerrainTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleTileRequestDecorationTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleTileTreeBoundsDecorationTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleTileTreeReferencesTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
    }

// @beta
export class ToggleToolTipsTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleViewAttachmentBoundariesTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleViewAttachmentClipShapesTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleViewAttachmentsTool extends ViewportToggleTool {
    // (undocumented)
    protected toggle(vp: Viewport, enable?: boolean): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleVolClassIntersect extends RenderTargetDebugControlToggleTool {
    // (undocumented)
    get aspect(): DebugControlBoolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ToggleWiremeshTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export interface ToolArgs {
    get(namePrefix: string): string | undefined;
    getBoolean(namePrefix: string): boolean | undefined;
    getFloat(namePrefix: string): number | undefined;
    getInteger(namePrefix: string): number | undefined;
}

// @alpha
export class ToolSettingsTracker {
    constructor(parent: HTMLElement, _vp: Viewport);
    // (undocumented)
    dispose(): void;
    }

// @beta
export class UnmaskMapTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    run(): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class UnmaskRealityModelTool extends PlanarMaskBaseTool {
    // (undocumented)
    protected applyMask(vp: ScreenViewport): void;
    // (undocumented)
    protected createToolInstance(): PlanarMaskBaseTool;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected targetModelRequired(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class UnsharpenEffect extends ConvolutionEffect {
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get matrix(): number[];
    // (undocumented)
    static toolId: string;
}

// @beta
export class ViewportAddRealityModel extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(url: string): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ViewportTileSizeModifierTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    parseAndRun(...args: string[]): Promise<boolean>;
    run(modifier?: number): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class ViewportToggleTool extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...args: string[]): Promise<boolean>;
    // (undocumented)
    run(enable?: boolean): Promise<boolean>;
    // (undocumented)
    protected abstract toggle(vp: Viewport, enable?: boolean): Promise<void>;
}

// @beta
export class VignetteConfig extends Tool {
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parseAndRun(...input: string[]): Promise<boolean>;
    static roundness: number;
    // (undocumented)
    run(width?: number, height?: number, roundness?: number, smoothness?: number): Promise<boolean>;
    static readonly size: Float32Array;
    static smoothness: number;
    // (undocumented)
    static toolId: string;
}

// @beta
export class VignetteEffect extends AddEffectTool {
    // (undocumented)
    protected defineEffect(builder: ScreenSpaceEffectBuilder): void;
    // (undocumented)
    protected get effectName(): string;
    // (undocumented)
    protected get source(): {
        vertex: string;
        fragment: string;
    };
    // (undocumented)
    protected get textureCoordFromPosition(): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class WoWIgnoreBackgroundTool extends DisplayStyleTool {
    // (undocumented)
    execute(vp: Viewport): Promise<boolean>;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    parse(args: string[]): Promise<boolean>;
    // (undocumented)
    static toolId: string;
}


// (No @packageDocumentation comment for this package)

```
