## API Report File for "@bentley/ecschema-metadata"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BentleyError } from '@bentley/bentleyjs-core';
import { I18N } from '@bentley/imodeljs-i18n';

// @beta (undocumented)
export type AnyArrayProperty = PrimitiveArrayProperty | EnumerationArrayProperty | StructArrayProperty;

// @beta (undocumented)
export type AnyClass = EntityClass | Mixin | StructClass | CustomAttributeClass | RelationshipClass;

// @beta (undocumented)
export type AnyClassProps = EntityClassProps | MixinProps | CustomAttributeClassProps | RelationshipClassProps;

// @beta
export type AnyDiagnostic = IDiagnostic<AnyECType, any[]>;

// @beta (undocumented)
export type AnyECType = Schema | SchemaItem | AnyProperty | RelationshipConstraint | CustomAttributeContainerProps | CustomAttribute | OverrideFormat | AnyEnumerator;

// @beta (undocumented)
export type AnyEnumerationProperty = EnumerationProperty | EnumerationArrayProperty;

// @beta (undocumented)
export type AnyEnumerator = Enumerator<string | number>;

// @beta (undocumented)
export type AnyPrimitiveProperty = PrimitiveProperty | PrimitiveArrayProperty;

// @beta (undocumented)
export type AnyProperty = AnyPrimitiveProperty | AnyEnumerationProperty | AnyStructProperty | NavigationProperty;

// @beta (undocumented)
export type AnyPropertyProps = PrimitivePropertyProps | StructPropertyProps | PrimitiveArrayPropertyProps | StructArrayPropertyProps | NavigationPropertyProps;

// @beta (undocumented)
export type AnySchemaItem = AnyClass | Enumeration | KindOfQuantity | PropertyCategory | Unit | InvertedUnit | Constant | Phenomenon | UnitSystem | Format;

// @beta (undocumented)
export type AnySchemaItemProps = AnyClassProps | EnumerationProps | KindOfQuantityProps | PropertyCategoryProps | UnitProps | InvertedUnitProps | ConstantProps | PhenomenonProps | FormatProps;

// @beta (undocumented)
export type AnyStructProperty = StructProperty | StructArrayProperty;

// @beta (undocumented)
export abstract class ArrayProperty extends Property {
    // (undocumented)
    get maxOccurs(): number | undefined;
    // (undocumented)
    protected _maxOccurs?: number;
    // (undocumented)
    get minOccurs(): number;
    // (undocumented)
    protected _minOccurs: number;
}

// @beta (undocumented)
export interface ArrayPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly maxOccurs?: number;
    // (undocumented)
    readonly minOccurs?: number;
}

// @alpha
export class BaseClassDelta extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @beta
export abstract class BaseDiagnostic<TYPE extends AnyECType, ARGS extends any[]> implements IDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: TYPE, messageArgs?: ARGS, category?: DiagnosticCategory);
    category: DiagnosticCategory;
    abstract get code(): string;
    abstract get diagnosticType(): DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    abstract get messageText(): string;
    abstract get schema(): Schema;
}

// @beta (undocumented)
export type BaseRule<T extends AnyECType, U extends AnyECType> = IRule<T, U>;

// @alpha
export abstract class BaseSchemaChange implements ISchemaChange {
    constructor(diagnostic: AnyDiagnostic);
    get changeType(): ChangeType;
    set changeType(changeType: ChangeType);
    abstract get defaultChangeType(): ChangeType;
    get diagnostic(): AnyDiagnostic;
    protected getNameFromArgument(index: number, itemType: typeof SchemaItem | typeof OverrideFormat | typeof Schema, allowUndefined?: boolean, fullName?: boolean): string;
    protected getStringFromArgument(index: number): string;
    protected getValueFromArgument(index: number): any;
    abstract get topLevelSchemaItem(): SchemaItem | Schema;
    abstract toString(): string;
}

// @alpha
export abstract class BaseSchemaChanges implements ISchemaChanges {
    constructor(schema: Schema, anyECTypeName: string);
    abstract addChange(change: ISchemaChange): void;
    protected addChangeToMap<V extends ISchemaChanges>(changes: Map<string, V>, changesType: SchemaChangesConstructor, change: ISchemaChange, changeKey: string): void;
    get ecTypeName(): string;
    protected isCAContainerChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string | undefined): boolean;
    protected isPropertyValueChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string): boolean;
    get propertyValueChanges(): PropertyValueChange[];
    get schema(): Schema;
    }

// @alpha
export enum ChangeType {
    // (undocumented)
    Delta = 0,
    // (undocumented)
    Missing = 1
}

// @alpha
export class ClassChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get baseClassDelta(): BaseClassDelta | undefined;
    get entityMixinChanges(): Map<string, EntityMixinChanges>;
    get propertyChanges(): Map<string, PropertyChanges>;
    get sourceConstraintChanges(): Map<string, RelationshipConstraintChanges>;
    get targetConstraintChanges(): Map<string, RelationshipConstraintChanges>;
    }

// @beta
export abstract class ClassDiagnostic<ARGS extends any[]> extends SchemaItemDiagnostic<AnyClass, ARGS> {
    constructor(ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory);
    get schema(): Schema;
}

// @beta
export function classModifierToString(modifier: ECClassModifier): string;

// @beta (undocumented)
export interface ClassProps extends SchemaItemProps {
    // (undocumented)
    readonly baseClass?: string;
    // (undocumented)
    readonly modifier?: string;
    // (undocumented)
    readonly properties?: PropertyProps[];
}

// @beta
export class Constant extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    fromJSON(constantProps: ConstantProps): Promise<void>;
    // (undocumented)
    fromJSONSync(constantProps: ConstantProps): void;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Constant;
    // @alpha
    protected setDefinition(definition: string): void;
    // @alpha
    protected setDenominator(denominator: number): void;
    // @alpha
    protected setNumerator(numerator: number): void;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): void;
    toJSON(standalone: boolean, includeSchemaVersion: boolean): ConstantProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface ConstantProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly phenomenon: string;
}

// @beta
export function containerTypeToString(type: CustomAttributeContainerType): string;

// @beta
export function createClassDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyClass;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createCustomAttributeContainerDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: CustomAttributeContainerProps;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createPropertyDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (property: AnyProperty, messageArgs?: ARGS | undefined, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyProperty;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
};

// @beta
export function createRelationshipConstraintDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: RelationshipConstraint;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createSchemaDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: Schema;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
    diagnosticType: DiagnosticType;
};

// @beta
export function createSchemaItemDiagnosticClass<ITEM extends SchemaItem, ARGS extends any[]>(code: string, messageText: string): {
    new (ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: ITEM;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export class CustomAttributeClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    get containerType(): CustomAttributeContainerType;
    // (undocumented)
    protected _containerType?: CustomAttributeContainerType;
    // (undocumented)
    fromJSON(customAttributeProps: CustomAttributeClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(customAttributeProps: CustomAttributeClassProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.CustomAttributeClass;
    // @alpha
    protected setContainerType(containerType: CustomAttributeContainerType): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): CustomAttributeClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface CustomAttributeClassProps extends ClassProps {
    // (undocumented)
    readonly appliesTo: string;
}

// @alpha
export class CustomAttributeContainerChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class CustomAttributeContainerChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): CustomAttributeContainerChange[];
    }

// @beta
export abstract class CustomAttributeContainerDiagnostic<ARGS extends any[]> extends BaseDiagnostic<CustomAttributeContainerProps, ARGS> {
    constructor(container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @beta
export enum CustomAttributeContainerType {
    // (undocumented)
    Any = 4095,
    // (undocumented)
    AnyClass = 30,
    // (undocumented)
    AnyProperty = 992,
    // (undocumented)
    AnyRelationshipConstraint = 3072,
    // (undocumented)
    CustomAttributeClass = 4,
    // (undocumented)
    EntityClass = 2,
    // (undocumented)
    NavigationProperty = 512,
    // (undocumented)
    PrimitiveArrayProperty = 128,
    // (undocumented)
    PrimitiveProperty = 32,
    // (undocumented)
    RelationshipClass = 16,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SourceRelationshipConstraint = 1024,
    // (undocumented)
    StructArrayProperty = 256,
    // (undocumented)
    StructClass = 8,
    // (undocumented)
    StructProperty = 64,
    // (undocumented)
    TargetRelationshipConstraint = 2048
}

// @beta
export enum DecimalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Eleven = 11,
    // (undocumented)
    Five = 5,
    // (undocumented)
    Four = 4,
    // (undocumented)
    Nine = 9,
    // (undocumented)
    One = 1,
    // (undocumented)
    Seven = 7,
    // (undocumented)
    Six = 6,
    // (undocumented)
    Ten = 10,
    // (undocumented)
    Three = 3,
    // (undocumented)
    Twelve = 12,
    // (undocumented)
    Two = 2,
    // (undocumented)
    Zero = 0
}

// @beta
export class DelayedPromise<T> implements Promise<T> {
    // (undocumented)
    readonly [Symbol.toStringTag]: "Promise";
    constructor(startCallback: () => Promise<T>);
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | undefined | null): Promise<T>;
    start: () => Promise<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
}

// @beta (undocumented)
export const DelayedPromiseWithProps: DelayedPromiseWithPropsConstructor;

// @beta
export type DelayedPromiseWithProps<TProps, TPayload> = Readonly<TProps> & DelayedPromise<TPayload>;

// @beta (undocumented)
export interface DelayedPromiseWithPropsConstructor {
    new <TProps extends NoDelayedPromiseMethods, TPayload>(props: TProps, startCallback: () => Promise<TPayload>): Readonly<TProps> & DelayedPromise<TPayload>;
}

// @beta
export enum DiagnosticCategory {
    // (undocumented)
    Error = 1,
    // (undocumented)
    Message = 3,
    // (undocumented)
    Suggestion = 2,
    // (undocumented)
    Warning = 0
}

// @beta (undocumented)
export function diagnosticCategoryToString(category: DiagnosticCategory): "Error" | "Warning" | "Message" | "Suggestion";

// @beta
export const DiagnosticCodes: {
    BaseClassIsSealed: string;
    BaseClassOfDifferentType: string;
    AbstractClassWithNonAbstractBase: string;
    CustomAttributeNotOfConcreteClass: string;
    CustomAttributeSchemaMustBeReferenced: string;
    CustomAttributeClassNotFound: string;
    EnumerationTypeUnsupported: string;
    MixinAppliedToClassMustDeriveFromConstraint: string;
    IncompatibleValueTypePropertyOverride: string;
    IncompatibleTypePropertyOverride: string;
    IncompatibleUnitPropertyOverride: string;
    AbstractConstraintMustNarrowBaseConstraints: string;
    DerivedConstraintsMustNarrowBaseConstraints: string;
    ConstraintClassesDeriveFromAbstractContraint: string;
    AtLeastOneConstraintClassDefined: string;
    AbstractConstraintMustExistWithMultipleConstraints: string;
};

// @beta
export const Diagnostics: {
    SupplementalSchemasCannotBeReferenced: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaRefAliasMustBeUnique: {
        new (schema: Schema, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ReferenceCyclesNotAllowed: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsSealed: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsOfDifferentType: {
        new (ecClass: AnyClass, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AbstractClassWithNonAbstractBase: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeNotOfConcreteClass: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
    };
    CustomAttributeSchemaMustBeReferenced: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
    };
    CustomAttributeClassNotFound: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
    };
    EnumerationTypeUnsupported: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinAppliedToClassMustDeriveFromConstraint: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    IncompatibleValueTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    IncompatibleTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    IncompatibleUnitPropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    NavigationRelationshipMustBeRoot: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    NavigationTargetMustHaveSingularMultiplicity: {
        new (property: AnyProperty, messageArgs?: [string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    NavigationRelationshipAbstractConstraintEntityOrMixin: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    NavigationClassMustBeAConstraintClassOfRelationship: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        code: string;
    };
    AbstractConstraintMustNarrowBaseConstraints: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    DerivedConstraintsMustNarrowBaseConstraints: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstraintClassesDeriveFromAbstractContraint: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AtLeastOneConstraintClassDefined: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
    };
    AbstractConstraintMustExistWithMultipleConstraints: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory; /**
             * The list of [[IDiagnostic]] implementation classes used by the EC rule implementations.
             * @beta
             */
        };
    };
};

// @beta
export enum DiagnosticType {
    // (undocumented)
    CustomAttributeContainer = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Property = 3,
    // (undocumented)
    RelationshipConstraint = 5,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SchemaItem = 2
}

// @beta (undocumented)
export function diagnosticTypeToString(type: DiagnosticType): "Schema" | "None" | "CustomAttributeContainer" | "Property" | "RelationshipConstraint" | "SchemaItem";

// @beta
export abstract class ECClass extends SchemaItem implements CustomAttributeContainerProps {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    protected addProperty<T extends Property>(prop: T): T;
    // (undocumented)
    get baseClass(): LazyLoadedECClass | undefined;
    set baseClass(baseClass: LazyLoadedECClass | undefined);
    // (undocumented)
    protected _baseClass?: LazyLoadedECClass;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    protected createPrimitiveArrayProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveArrayProperty>;
    // (undocumented)
    protected createPrimitiveArrayProperty(name: string, primitiveType: Enumeration): Promise<EnumerationArrayProperty>;
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: PrimitiveType): PrimitiveArrayProperty;
    // (undocumented)
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: Enumeration): EnumerationArrayProperty;
    protected createPrimitiveProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveProperty>;
    // (undocumented)
    protected createPrimitiveProperty(name: string, primitiveType: Enumeration): Promise<EnumerationProperty>;
    protected createPrimitivePropertySync(name: string, primitiveType: PrimitiveType): PrimitiveProperty;
    // (undocumented)
    protected createPrimitivePropertySync(name: string, primitiveType: Enumeration): EnumerationProperty;
    // (undocumented)
    protected createStructArrayProperty(name: string, structType: string | StructClass): Promise<StructArrayProperty>;
    // (undocumented)
    protected createStructArrayPropertySync(name: string, structType: string | StructClass): StructArrayProperty;
    // (undocumented)
    protected createStructProperty(name: string, structType: string | StructClass): Promise<StructProperty>;
    // (undocumented)
    protected createStructPropertySync(name: string, structType: string | StructClass): StructProperty;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    fromJSON(classProps: ClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(classProps: ClassProps): void;
    getAllBaseClasses(): AsyncIterableIterator<ECClass>;
    // (undocumented)
    getAllBaseClassesSync(): Iterable<AnyClass>;
    // (undocumented)
    getBaseClassSync(): ECClass | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    getInheritedProperty(name: string): Promise<Property | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    getProperties(resetCache?: boolean): Promise<Property[]>;
    getPropertiesSync(resetCache?: boolean): Property[];
    getProperty(name: string, includeInherited?: boolean): Promise<Property | undefined>;
    getPropertySync(name: string, includeInherited?: boolean): Property | undefined;
    is(targetClass: string, schemaName: string): Promise<boolean>;
    // (undocumented)
    is(targetClass: ECClass): Promise<boolean>;
    isSync(targetClass: ECClass): boolean;
    // (undocumented)
    protected loadPrimitiveType(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): Promise<PrimitiveType | Enumeration>;
    // (undocumented)
    protected loadPrimitiveTypeSync(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): PrimitiveType | Enumeration;
    // (undocumented)
    protected loadStructType(structType: string | StructClass | undefined, schema: Schema): Promise<StructClass>;
    // (undocumented)
    protected loadStructTypeSync(structType: string | StructClass | undefined, schema: Schema): StructClass;
    // (undocumented)
    protected static mergeProperties(target: Property[], existingValues: Map<string, number>, propertiesToMerge: Property[], overwriteExisting: boolean): void;
    // (undocumented)
    get modifier(): ECClassModifier;
    // (undocumented)
    protected _modifier: ECClassModifier;
    // (undocumented)
    get properties(): Property[] | undefined;
    // (undocumented)
    protected _properties?: Property[];
    // @alpha
    protected setModifier(modifier: ECClassModifier): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): ClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    traverseBaseClasses(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): Promise<boolean>;
    traverseBaseClassesSync(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): boolean;
}

// @beta (undocumented)
export enum ECClassModifier {
    // (undocumented)
    Abstract = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sealed = 2
}

// @beta
export class ECName {
    constructor(name: string);
    // (undocumented)
    get name(): string;
    // (undocumented)
    static validate(newName: string): boolean;
}

// @internal (undocumented)
export class ECObjectsError extends BentleyError {
    constructor(errorNumber: number, message?: string);
    // (undocumented)
    readonly errorNumber: number;
    // (undocumented)
    toDebugString(): string;
}

// @beta (undocumented)
export enum ECObjectsStatus {
    // (undocumented)
    ClassNotFound = 35074,
    // (undocumented)
    DifferentSchemaContexts = 35076,
    // (undocumented)
    DuplicateItem = 35053,
    // (undocumented)
    DuplicateProperty = 35054,
    // (undocumented)
    DuplicateSchema = 35055,
    // (undocumented)
    ECOBJECTS_ERROR_BASE = 35052,
    // (undocumented)
    ImmutableSchema = 35056,
    // (undocumented)
    InvalidContainerType = 35057,
    // (undocumented)
    InvalidECJson = 35058,
    // (undocumented)
    InvalidECName = 35059,
    // (undocumented)
    InvalidECVersion = 35060,
    // (undocumented)
    InvalidEnumValue = 35061,
    // (undocumented)
    InvalidModifier = 35062,
    // (undocumented)
    InvalidMultiplicity = 35063,
    // (undocumented)
    InvalidPrimitiveType = 35064,
    // (undocumented)
    InvalidRelationshipEnd = 35068,
    // (undocumented)
    InvalidSchemaAlias = 35078,
    // (undocumented)
    InvalidSchemaComparisonArgument = 35077,
    // (undocumented)
    InvalidSchemaItemType = 35065,
    // (undocumented)
    InvalidSchemaString = 35073,
    // (undocumented)
    InvalidSchemaXML = 35072,
    // (undocumented)
    InvalidStrength = 35066,
    // (undocumented)
    InvalidStrengthDirection = 35067,
    // (undocumented)
    InvalidType = 35069,
    // (undocumented)
    MissingSchemaUrl = 35070,
    // (undocumented)
    SchemaContextUndefined = 35075,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UnableToLocateSchema = 35071
}

// @beta
export const ECRuleSet: IRuleSet;

// @internal (undocumented)
export class ECStringConstants {
    // (undocumented)
    static readonly CONTAINERTYPE_ANY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_CUSTOMATTRIBUTECLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ENTITYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_NAVIGATIONPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_RELATIONSHIPCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SCHEMA: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SOURCERELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_TARGETRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_SOURCE: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_TARGET: string;
}

// @beta (undocumented)
export class ECVersion {
    constructor(read?: number, write?: number, minor?: number);
    compare(rhv: ECVersion): number;
    static fromString(versionString: string): ECVersion;
    // (undocumented)
    get minor(): number;
    // (undocumented)
    get read(): number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get write(): number;
    }

// @alpha (undocumented)
export namespace Editors {
    export class Constants {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, phenomenon: SchemaItemKey, definition: string, displayLabel?: string, numerator?: number, denominator?: number): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, constantProps: ConstantProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class CustomAttributes extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, containerType: CustomAttributeContainerType, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, caProps: CustomAttributeClassProps): Promise<SchemaItemEditResults>;
    }
    export class ECClasses {
        protected constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        createEnumerationProperty(classKey: SchemaItemKey, name: string, type: Enumeration): Promise<PropertyEditResults>;
        // (undocumented)
        createEnumerationPropertyFromProps(classKey: SchemaItemKey, name: string, type: Enumeration, enumProps: EnumerationPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitiveArrayProperty(classKey: SchemaItemKey, name: string, type: PrimitiveType): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitiveArrayPropertyFromProps(classKey: SchemaItemKey, name: string, type: PrimitiveType, primitiveProps: PrimitiveArrayPropertyProps): Promise<PropertyEditResults>;
        createPrimitiveProperty(classKey: SchemaItemKey, name: string, type: PrimitiveType): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitivePropertyFromProps(classKey: SchemaItemKey, name: string, type: PrimitiveType, primitiveProps: PrimitivePropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createStructArrayProperty(classKey: SchemaItemKey, name: string, type: StructClass): Promise<PropertyEditResults>;
        // (undocumented)
        createStructArrayPropertyFromProps(classKey: SchemaItemKey, name: string, type: StructClass, structProps: StructArrayPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createStructProperty(classKey: SchemaItemKey, name: string, type: StructClass): Promise<PropertyEditResults>;
        // (undocumented)
        createStructPropertyFromProps(classKey: SchemaItemKey, name: string, type: StructClass, structProps: StructPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Entities extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addMixin(entityKey: SchemaItemKey, mixinKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, modifier: ECClassModifier, displayLabel?: string, baseClass?: SchemaItemKey, mixins?: Mixin[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, entityProps: EntityClassProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(entityKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Enumerations {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addEnumerator(enumerationKey: SchemaItemKey, enumerator: AnyEnumerator): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, type: PrimitiveType.Integer | PrimitiveType.String, displayLabel?: string, isStrict?: boolean, enumerators?: AnyEnumerator[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, enumProps: EnumerationProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Formats {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, formatType: FormatType, displayLabel?: string, units?: SchemaItemKey[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, formatProps: FormatProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class InvertedUnits {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, invertsUnitKey: SchemaItemKey, unitSystemKey: SchemaItemKey, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, invertedUnitProps: InvertedUnitProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
        // (undocumented)
        setInvertsUnit(invertedUnitKey: SchemaItemKey, invertsUnitKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        setUnitSystem(invertedUnitKey: SchemaItemKey, unitSystemKey: SchemaItemKey): Promise<void>;
    }
    export class KindOfQuantities {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addPresentationFormat(koqKey: SchemaItemKey, format: SchemaItemKey, isDefault?: boolean): Promise<void>;
        // (undocumented)
        addPresentationOverrideFormat(koqKey: SchemaItemKey, overrideFormat: OverrideFormat, isDefault?: boolean): Promise<void>;
        // (undocumented)
        createFormatOverride(koqKey: SchemaItemKey, parent: SchemaItemKey, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): Promise<OverrideFormat>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, koqProps: KindOfQuantityProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Mixins extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addMixin(entityKey: SchemaItemKey, mixinKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, appliesTo: SchemaItemKey, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, mixinProps: MixinProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(mixinKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Phenomenons {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, definition: string, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, phenomenonProps: PhenomenonProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class PropertyCategories {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, priority: number, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, propertyCategoryProps: PropertyCategoryProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
        // (undocumented)
        setPriority(propCategoryKey: SchemaItemKey, priority: number): Promise<void>;
    }
    export class RelationshipClasses extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        createFromProps(schemaKey: SchemaKey, relationshipProps: RelationshipClassProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(relationshipKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Structs extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, structProps: StructClassProps): Promise<SchemaItemEditResults>;
    }
    export class Units {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, definition: string, phenomenon: SchemaItemKey, unitSystem: SchemaItemKey, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, unitProps: UnitProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class UnitSystems {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, unitSystemProps: UnitSystemProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
}

// @beta
export class EntityClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addMixin(mixin: Mixin): void;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(entityClassProps: EntityClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(entityClassProps: EntityClassProps): void;
    getInheritedProperty(name: string): Promise<AnyProperty | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    // (undocumented)
    getMixinsSync(): Iterable<Mixin>;
    // (undocumented)
    get mixins(): LazyLoadedMixin[];
    // (undocumented)
    protected _mixins?: LazyLoadedMixin[];
    // (undocumented)
    readonly schemaItemType: SchemaItemType.EntityClass;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EntityClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EntityClassProps extends ClassProps {
    // (undocumented)
    readonly mixins?: string[];
}

// @alpha
export class EntityMixinChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class EntityMixinChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get entityMixinChange(): EntityMixinChange[];
    }

// @beta
export class Enumeration extends SchemaItem {
    constructor(schema: Schema, name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String);
    protected addEnumerator(enumerator: AnyEnumerator): void;
    createEnumerator(name: string, value: string | number, label?: string, description?: string): AnyEnumerator;
    // (undocumented)
    get enumerators(): AnyEnumerator[];
    // (undocumented)
    protected _enumerators: AnyEnumerator[];
    // (undocumented)
    fromJSON(enumerationProps: EnumerationProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationProps: EnumerationProps): void;
    getEnumerator(value: string): Enumerator<string> | undefined;
    // (undocumented)
    getEnumerator(value: number): Enumerator<number> | undefined;
    getEnumeratorByName(name: string): AnyEnumerator | undefined;
    // (undocumented)
    get isInt(): boolean;
    // (undocumented)
    get isStrict(): boolean;
    // (undocumented)
    protected _isStrict: boolean;
    // (undocumented)
    get isString(): boolean;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Enumeration;
    // @alpha
    protected setIsStrict(isStrict: boolean): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EnumerationProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): PrimitiveType.Integer | PrimitiveType.String | undefined;
    // (undocumented)
    protected _type?: PrimitiveType.Integer | PrimitiveType.String;
}

// @beta (undocumented)
export class EnumerationArrayProperty extends EnumerationArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
}

// @alpha
export class EnumerationChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorChanges(): Map<string, EnumeratorChanges>;
    }

// @beta (undocumented)
export class EnumerationProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
    // (undocumented)
    get enumeration(): LazyLoadedEnumeration | undefined;
    // (undocumented)
    protected _enumeration?: LazyLoadedEnumeration;
    // (undocumented)
    fromJSON(enumerationPropertyProps: EnumerationPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationPropertyProps: EnumerationPropertyProps): void;
    toJSON(): EnumerationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EnumerationPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export interface EnumerationProps extends SchemaItemProps {
    // (undocumented)
    readonly enumerators: EnumeratorProps[];
    // (undocumented)
    readonly isStrict: boolean;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
export interface Enumerator<T> {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: T;
}

// @alpha
export class EnumeratorChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorDeltas(): EnumeratorDelta[];
    get enumeratorMissing(): EnumeratorMissing | undefined;
    }

// @alpha
export class EnumeratorDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class EnumeratorMissing extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta (undocumented)
export interface EnumeratorProps {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: string | number;
}

// @beta (undocumented)
export class Format extends SchemaItem {
    constructor(schema: Schema, name: string);
    protected addUnit(unit: Unit | InvertedUnit, label?: string): void;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    protected _decimalSeparator: string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    protected _formatTraits: FormatTraits;
    // (undocumented)
    fromJSON(formatProps: FormatProps): Promise<void>;
    // (undocumented)
    fromJSONSync(formatProps: FormatProps): void;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // (undocumented)
    protected _includeZero: boolean;
    // (undocumented)
    get minWidth(): number | undefined;
    // (undocumented)
    protected _minWidth?: number;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    protected _precision: number;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    protected _roundFactor: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Format;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    protected _scientificType?: ScientificType;
    // @alpha
    protected setDecimalSeparator(separator: string): void;
    // @alpha
    protected setFormatType(formatType: FormatType): void;
    // (undocumented)
    protected setPrecision(precision: number): void;
    // @alpha
    protected setRoundFactor(roundFactor: number): void;
    // @alpha
    protected setShowSignOption(signOption: ShowSignOption): void;
    // @alpha
    protected setStationSeparator(separator: string): void;
    // @alpha
    protected setThousandSeparator(separator: string): void;
    // @alpha
    protected setUomSeparator(separator: string): void;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    protected _showSignOption: ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    protected _spacer: string;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    protected _stationOffsetSize?: number;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    protected _stationSeparator: string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    protected _thousandSeparator: string;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): FormatProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    protected _type: FormatType;
    // (undocumented)
    get units(): Array<[Unit | InvertedUnit, string | undefined]> | undefined;
    // (undocumented)
    protected _units?: Array<[Unit | InvertedUnit, string | undefined]>;
    // (undocumented)
    get uomSeparator(): string;
    // (undocumented)
    protected _uomSeparator: string;
}

// @alpha
export class FormatChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): Map<string, FormatUnitChanges>;
    }

// @beta
export abstract class FormatDiagnosticReporter extends SuppressionDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>, i18n?: I18N);
    protected formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string;
    i18N?: I18N;
    protected abstract reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
    reportInternal(diagnostic: AnyDiagnostic): void;
    }

// @beta (undocumented)
export interface FormatProps extends SchemaItemProps {
    // (undocumented)
    readonly composite?: {
        readonly spacer?: string;
        readonly includeZero?: boolean;
        readonly units: Array<{
            readonly name: string;
            readonly label?: string;
        }>;
    };
    // (undocumented)
    readonly decimalSeparator?: string;
    // (undocumented)
    readonly formatTraits?: string | string[];
    // (undocumented)
    readonly minWidth?: number;
    // (undocumented)
    readonly precision?: number;
    // (undocumented)
    readonly roundFactor?: number;
    // (undocumented)
    readonly scientificType?: string;
    // (undocumented)
    readonly showSignOption?: string;
    // (undocumented)
    readonly stationOffsetSize?: number;
    // (undocumented)
    readonly stationSeparator?: string;
    // (undocumented)
    readonly thousandSeparator?: string;
    // (undocumented)
    readonly type: string;
    // (undocumented)
    readonly uomSeparator?: string;
}

// @internal
export const formatStringRgx: RegExp;

// @beta
export enum FormatTraits {
    // (undocumented)
    ApplyRounding = 16,
    // (undocumented)
    ExponentOnlyNegative = 512,
    // (undocumented)
    FractionDash = 32,
    // (undocumented)
    KeepDecimalPoint = 8,
    // (undocumented)
    KeepSingleZero = 2,
    // (undocumented)
    PrependUnitLabel = 128,
    // (undocumented)
    ShowUnitLabel = 64,
    // (undocumented)
    TrailZeroes = 1,
    // (undocumented)
    Use1000Separator = 256,
    // (undocumented)
    ZeroEmpty = 4
}

// @internal
export function formatTraitsToArray(currentFormatTrait: FormatTraits): string[];

// @beta
export enum FormatType {
    // (undocumented)
    Decimal = 0,
    // (undocumented)
    Fractional = 1,
    // (undocumented)
    Scientific = 2,
    // (undocumented)
    Station = 3
}

// @internal
export function formatTypeToString(type: FormatType): string;

// @alpha
export class FormatUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class FormatUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): FormatUnitChange[];
    get unitLabelOverrideDeltas(): UnitLabelOverrideDelta[];
    }

// @beta
export enum FractionalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Four = 4,
    // (undocumented)
    One = 1,
    // (undocumented)
    OneHundredTwentyEight = 128,
    // (undocumented)
    Sixteen = 16,
    // (undocumented)
    SixtyFour = 64,
    // (undocumented)
    ThirtyTwo = 32,
    // (undocumented)
    Two = 2,
    // (undocumented)
    TwoHundredFiftySix = 256
}

// @internal
export function getItemNamesFromFormatString(formatString: string): Iterable<string>;

// @beta
export interface IDiagnostic<TYPE extends AnyECType, ARGS extends any[]> {
    category: DiagnosticCategory;
    code: string;
    diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    messageText: string;
    schema: Schema;
}

// @beta
export interface IDiagnosticReporter {
    i18N?: I18N;
    report(diagnostic: AnyDiagnostic): void;
    suppressions?: Map<string, string[]>;
}

// @beta
export class InvertedUnit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(invertedUnitProps: InvertedUnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(invertedUnitProps: InvertedUnitProps): void;
    // (undocumented)
    get invertsUnit(): LazyLoadedUnit | undefined;
    // (undocumented)
    protected _invertsUnit?: LazyLoadedUnit;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.InvertedUnit;
    // @alpha
    protected setInvertsUnit(invertsUnit: LazyLoadedUnit): void;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): InvertedUnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta (undocumented)
export interface InvertedUnitProps extends SchemaItemProps {
    // (undocumented)
    readonly invertsUnit: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta
export type IRule<T extends AnyECType, U = {}> = (ecDefinition: T, ...args: U[]) => AsyncIterable<BaseDiagnostic<T, any[]>>;

// @beta
export interface IRuleSet {
    classRules?: Array<IRule<AnyClass>>;
    constantRules?: Array<IRule<Constant>>;
    customAttributeClassRules?: Array<IRule<CustomAttributeClass>>;
    customAttributeContainerRules?: Array<IRule<CustomAttributeContainerProps>>;
    customAttributeInstanceRules?: Array<BaseRule<CustomAttributeContainerProps, CustomAttribute>>;
    entityClassRules?: Array<IRule<EntityClass>>;
    enumerationRules?: Array<IRule<Enumeration>>;
    formatRules?: Array<IRule<Format>>;
    invertedUnitRules?: Array<IRule<InvertedUnit>>;
    kindOfQuantityRules?: Array<IRule<KindOfQuantity>>;
    mixinRules?: Array<IRule<Mixin>>;
    name: string;
    phenomenonRules?: Array<IRule<Phenomenon>>;
    propertyCategoryRules?: Array<IRule<PropertyCategory>>;
    propertyRules?: Array<IRule<AnyProperty>>;
    relationshipConstraintRules?: Array<IRule<RelationshipConstraint>>;
    relationshipRules?: Array<IRule<RelationshipClass>>;
    schemaExclusionSet?: string[];
    schemaItemRules?: Array<IRule<SchemaItem>>;
    schemaRules?: Array<IRule<Schema>>;
    structClassRules?: Array<IRule<StructClass>>;
    unitRules?: Array<IRule<Unit>>;
    unitSystemRules?: Array<IRule<UnitSystem>>;
}

// @beta
export interface IRuleSuppressionMap<T extends AnyECType, U = {}> {
    // (undocumented)
    rule: ISuppressionRule<T, U>;
    // (undocumented)
    ruleCode: string;
}

// @beta
export interface IRuleSuppressionSet {
    // (undocumented)
    classRuleSuppressions?: Array<IRuleSuppressionMap<AnyClass>>;
    // (undocumented)
    constantRuleSuppressions?: Array<IRuleSuppressionMap<Constant>>;
    // (undocumented)
    customAttributeContainerSuppressions?: Array<IRuleSuppressionMap<CustomAttributeContainerProps>>;
    // (undocumented)
    customAttributeInstanceSuppressions?: Array<BaseRuleSuppressionMap<CustomAttributeContainerProps, CustomAttribute>>;
    // (undocumented)
    customAttributeRuleSuppressions?: Array<IRuleSuppressionMap<CustomAttributeClass>>;
    // (undocumented)
    entityRuleSuppressions?: Array<IRuleSuppressionMap<EntityClass>>;
    // (undocumented)
    enumerationRuleSuppressions?: Array<IRuleSuppressionMap<Enumeration>>;
    // (undocumented)
    formatRuleSuppressions?: Array<IRuleSuppressionMap<Format>>;
    // (undocumented)
    invertedUnitRuleSuppressions?: Array<IRuleSuppressionMap<InvertedUnit>>;
    // (undocumented)
    koqRuleSuppressions?: Array<IRuleSuppressionMap<KindOfQuantity>>;
    // (undocumented)
    mixinRuleSuppressions?: Array<IRuleSuppressionMap<Mixin>>;
    // (undocumented)
    name: string;
    // (undocumented)
    phenomenonRuleSuppressions?: Array<IRuleSuppressionMap<Phenomenon>>;
    // (undocumented)
    propertyCategoryRuleSuppressions?: Array<IRuleSuppressionMap<PropertyCategory>>;
    // (undocumented)
    propertyRuleSuppressions?: Array<IRuleSuppressionMap<AnyProperty>>;
    // (undocumented)
    relationshipConstraintRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipConstraint>>;
    // (undocumented)
    relationshipRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipClass>>;
    // (undocumented)
    schemaItemRuleSuppressions?: Array<IRuleSuppressionMap<SchemaItem>>;
    // (undocumented)
    schemaRuleSuppressions?: Array<IRuleSuppressionMap<Schema>>;
    // (undocumented)
    structRuleSuppressions?: Array<IRuleSuppressionMap<StructClass>>;
    // (undocumented)
    unitRuleSuppressions?: Array<IRuleSuppressionMap<Unit>>;
    // (undocumented)
    unitSystemRuleSuppressions?: Array<IRuleSuppressionMap<UnitSystem>>;
}

// @alpha
export interface ISchemaChange {
    changeType: ChangeType;
    diagnostic: AnyDiagnostic;
    topLevelSchemaItem: SchemaItem | Schema;
    toString(): string;
}

// @alpha
export interface ISchemaChanges {
    // (undocumented)
    addChange(change: ISchemaChange): void;
    // (undocumented)
    ecTypeName: string;
    // (undocumented)
    schema: Schema;
}

// @alpha
export interface ISchemaComparer {
    // (undocumented)
    compareClasses(classA: AnyClass, classB: AnyClass | undefined): void;
    // (undocumented)
    compareConstants(constantA: Constant, constantB: Constant | undefined): void;
    // (undocumented)
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass | undefined): void;
    // (undocumented)
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps | undefined): void;
    // (undocumented)
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass | undefined): void;
    // (undocumented)
    compareEnumerations(enumA: Enumeration, enumB: Enumeration | undefined): void;
    // (undocumented)
    compareFormats(formatA: Format, formatB: Format | undefined): void;
    // (undocumented)
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit | undefined): void;
    // (undocumented)
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity | undefined): void;
    // (undocumented)
    compareMixins(mixinA: Mixin, mixinB: Mixin | undefined): void;
    // (undocumented)
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon | undefined): void;
    // (undocumented)
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): void;
    // (undocumented)
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory | undefined): void;
    // (undocumented)
    compareRelationshipClasses(relationshipClassA: RelationshipClass, relationshipClassB: RelationshipClass | undefined): void;
    // (undocumented)
    compareRelationshipConstraints(relationshipConstraintA: RelationshipConstraint, relationshipConstraintB: RelationshipConstraint | undefined): void;
    // (undocumented)
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): void;
    // (undocumented)
    compareSchemaProps(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareSchemas(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareUnits(unitA: Unit, unitB: Unit | undefined): void;
}

// @alpha
export interface ISchemaCompareReporter {
    // (undocumented)
    report(schemaChanges: ISchemaChanges): void;
}

// @beta (undocumented)
export interface ISchemaItemLocater {
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
}

// @beta
export interface ISchemaLocater {
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): Promise<T | undefined>;
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): T | undefined;
}

// @beta
export interface ISchemaPartVisitor {
    visitClass?: (ecClass: AnyClass) => Promise<void>;
    visitClassSync?: (ecClass: AnyClass) => void;
    visitConstant?: (constant: Constant) => Promise<void>;
    visitConstantSync?: (constant: Constant) => void;
    visitCustomAttributeClass?: (customAttributeClass: CustomAttributeClass) => Promise<void>;
    visitCustomAttributeClassSync?: (customAttributeClass: CustomAttributeClass) => void;
    visitCustomAttributeContainer?: (customAttributeContainer: CustomAttributeContainerProps) => Promise<void>;
    visitCustomAttributeContainerSync?: (customAttributeContainer: CustomAttributeContainerProps) => void;
    visitEmptySchema?: (schema: Schema) => Promise<void>;
    visitEmptySchemaSync?: (schema: Schema) => void;
    visitEntityClass?: (entityClass: EntityClass) => Promise<void>;
    visitEntityClassSync?: (entityClass: EntityClass) => void;
    visitEnumeration?: (enumeration: Enumeration) => Promise<void>;
    visitEnumerationSync?: (enumeration: Enumeration) => void;
    visitFormat?: (format: Format) => Promise<void>;
    visitFormatSync?: (format: Format) => void;
    visitFullSchema?: (schema: Schema) => Promise<void>;
    visitFullSchemaSync?: (schema: Schema) => void;
    visitInvertedUnit?: (invertedUnit: InvertedUnit) => Promise<void>;
    visitInvertedUnitSync?: (invertedUnit: InvertedUnit) => void;
    visitKindOfQuantity?: (koq: KindOfQuantity) => Promise<void>;
    visitKindOfQuantitySync?: (koq: KindOfQuantity) => void;
    visitMixin?: (mixin: Mixin) => Promise<void>;
    visitMixinSync?: (mixin: Mixin) => void;
    visitPhenomenon?: (phenomena: Phenomenon) => Promise<void>;
    visitPhenomenonSync?: (phenomena: Phenomenon) => void;
    visitProperty?: (property: AnyProperty) => Promise<void>;
    visitPropertyCategory?: (category: PropertyCategory) => Promise<void>;
    visitPropertyCategorySync?: (category: PropertyCategory) => void;
    visitPropertySync?: (property: AnyProperty) => void;
    visitRelationshipClass?: (relationshipClass: RelationshipClass) => Promise<void>;
    visitRelationshipClassSync?: (relationshipClass: RelationshipClass) => void;
    visitRelationshipConstraint?: (relationshipConstraint: RelationshipConstraint) => Promise<void>;
    visitRelationshipConstraintSync?: (relationshipConstraint: RelationshipConstraint) => void;
    visitSchemaItem?: (schemaItem: SchemaItem) => Promise<void>;
    visitSchemaItemSync?: (schemaItem: SchemaItem) => void;
    visitStructClass?: (structClass: StructClass) => Promise<void>;
    visitStructClassSync?: (structClass: StructClass) => void;
    visitUnit?: (unit: Unit) => Promise<void>;
    visitUnitSync?: (unit: Unit) => void;
    visitUnitSystem?: (unitSystem: UnitSystem) => Promise<void>;
    visitUnitSystemSync?: (unitSystem: UnitSystem) => void;
}

// @beta
export type ISuppressionRule<T extends AnyECType, U = {}> = (diagnostic: AnyDiagnostic, ecDefinition: T, ...args: U[]) => Promise<boolean>;

// @beta
export class KindOfQuantity extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    protected addPresentationFormat(format: Format | OverrideFormat, isDefault?: boolean): void;
    protected createFormatOverride(parent: Format, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): OverrideFormat;
    get defaultPresentationFormat(): Format | OverrideFormat | undefined;
    // (undocumented)
    fromJSON(kindOfQuantityProps: KindOfQuantityProps): Promise<void>;
    // (undocumented)
    fromJSONSync(kindOfQuantityProps: KindOfQuantityProps): void;
    // (undocumented)
    get persistenceUnit(): LazyLoadedUnit | LazyLoadedInvertedUnit | undefined;
    // (undocumented)
    protected _persistenceUnit?: LazyLoadedUnit | LazyLoadedInvertedUnit;
    get presentationFormats(): Array<Format | OverrideFormat>;
    // (undocumented)
    protected _presentationFormats: Array<Format | OverrideFormat>;
    // (undocumented)
    get relativeError(): number;
    // (undocumented)
    protected _relativeError: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.KindOfQuantity;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): KindOfQuantityProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @alpha
export class KindOfQuantityChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChanges(): Map<string, PresentationUnitChanges>;
    }

// @beta (undocumented)
export interface KindOfQuantityProps extends SchemaItemProps {
    // (undocumented)
    readonly persistenceUnit: string;
    // (undocumented)
    readonly presentationUnits?: string | string[];
    // (undocumented)
    readonly relativeError: number;
}

// @beta (undocumented)
export type LazyLoadedConstant = LazyLoadedSchemaItem<Constant>;

// @beta (undocumented)
export type LazyLoadedCustomAttributeClass = LazyLoadedSchemaItem<CustomAttributeClass>;

// @beta (undocumented)
export type LazyLoadedECClass = LazyLoadedSchemaItem<ECClass>;

// @beta (undocumented)
export type LazyLoadedEntityClass = LazyLoadedSchemaItem<EntityClass>;

// @beta (undocumented)
export type LazyLoadedEnumeration = LazyLoadedSchemaItem<Enumeration>;

// @beta (undocumented)
export type LazyLoadedFormat = LazyLoadedSchemaItem<Format>;

// @beta (undocumented)
export type LazyLoadedInvertedUnit = LazyLoadedSchemaItem<InvertedUnit>;

// @beta (undocumented)
export type LazyLoadedKindOfQuantity = LazyLoadedSchemaItem<KindOfQuantity>;

// @beta (undocumented)
export type LazyLoadedMixin = LazyLoadedSchemaItem<Mixin>;

// @beta (undocumented)
export type LazyLoadedPhenomenon = LazyLoadedSchemaItem<Phenomenon>;

// @beta (undocumented)
export type LazyLoadedPropertyCategory = LazyLoadedSchemaItem<PropertyCategory>;

// @beta (undocumented)
export type LazyLoadedRelationshipClass = LazyLoadedSchemaItem<RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedRelationshipConstraintClass = LazyLoadedSchemaItem<EntityClass | Mixin | RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedSchema = Readonly<SchemaKey> & DelayedPromise<Schema> & Promise<Schema>;

// @beta (undocumented)
export type LazyLoadedSchemaItem<T extends SchemaItem> = Readonly<SchemaItemKey> & DelayedPromise<T> & Promise<T>;

// @beta (undocumented)
export type LazyLoadedStructClass = LazyLoadedSchemaItem<StructClass>;

// @beta (undocumented)
export type LazyLoadedUnit = LazyLoadedSchemaItem<Unit>;

// @beta (undocumented)
export type LazyLoadedUnitSystem = LazyLoadedSchemaItem<UnitSystem>;

// @beta
export class LoggingDiagnosticReporter extends FormatDiagnosticReporter {
    // (undocumented)
    reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
}

// @beta
export class Mixin extends ECClass {
    constructor(schema: Schema, name: string);
    // (undocumented)
    applicableTo(entityClass: EntityClass): Promise<boolean>;
    // (undocumented)
    get appliesTo(): LazyLoadedEntityClass | undefined;
    // (undocumented)
    protected _appliesTo?: LazyLoadedEntityClass;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(mixinProps: MixinProps): Promise<void>;
    // (undocumented)
    fromJSONSync(mixinProps: MixinProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Mixin;
    // @alpha
    protected setAppliesTo(appliesTo: LazyLoadedEntityClass): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): MixinProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface MixinProps extends ClassProps {
    // (undocumented)
    readonly appliesTo: string;
}

// @beta (undocumented)
export class NavigationProperty extends Property {
    constructor(ecClass: ECClass, name: string, relationship: LazyLoadedRelationshipClass, direction?: StrengthDirection);
    // (undocumented)
    get direction(): StrengthDirection;
    // (undocumented)
    protected _direction: StrengthDirection;
    // (undocumented)
    getRelationshipClassSync(): RelationshipClass | undefined;
    // (undocumented)
    get relationshipClass(): LazyLoadedRelationshipClass;
    // (undocumented)
    protected _relationshipClass: LazyLoadedRelationshipClass;
    toJSON(): NavigationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface NavigationPropertyProps extends PropertyProps {
    // (undocumented)
    readonly direction: string;
    // (undocumented)
    readonly relationshipName: string;
}

// @beta (undocumented)
export interface NoDelayedPromiseMethods {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    catch?: never;
    // (undocumented)
    start?: never;
    // (undocumented)
    then?: never;
}

// @beta
export class OverrideFormat {
    constructor(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>);
    static createOverrideFormatFullName(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>): string;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    get fullName(): string;
    // @alpha
    fullNameXml(koqSchema: Schema): string;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // (undocumented)
    get minWidth(): number | undefined;
    readonly name: string;
    readonly parent: Format;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    get units(): [Unit | InvertedUnit, string | undefined][] | undefined;
    // (undocumented)
    get uomSeparator(): string;
}

// @beta
export function parseClassModifier(modifier: string): ECClassModifier | undefined;

// @beta
export function parseCustomAttributeContainerType(type: string): CustomAttributeContainerType | undefined;

// @internal
export function parseDecimalPrecision(jsonObjPrecision: number): DecimalPrecision | undefined;

// @internal
export function parseFormatTrait(formatTraitsString: string): FormatTraits | undefined;

// @internal
export function parseFormatType(jsonObjType: string): FormatType | undefined;

// @internal
export function parseFractionalPrecision(jsonObjPrecision: number): FractionalPrecision | undefined;

// @internal
export function parsePrecision(precision: number, type: FormatType): DecimalPrecision | FractionalPrecision | undefined;

// @beta
export function parsePrimitiveType(type: string): PrimitiveType | undefined;

// @beta (undocumented)
export function parseRelationshipEnd(end: string): RelationshipEnd | undefined;

// @beta
export function parseSchemaItemType(type: string): SchemaItemType | undefined;

// @internal
export function parseScientificType(scientificType: string): ScientificType | undefined;

// @internal
export function parseShowSignOption(showSignOption: string): ShowSignOption | undefined;

// @beta
export function parseStrength(strength: string): StrengthType | undefined;

// @beta (undocumented)
export function parseStrengthDirection(direction: string): StrengthDirection | undefined;

// @beta (undocumented)
export class Phenomenon extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    fromJSON(phenomenonProps: PhenomenonProps): Promise<void>;
    // (undocumented)
    fromJSONSync(phenomenonProps: PhenomenonProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Phenomenon;
    // (undocumented)
    protected setDefinition(definition: string): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PhenomenonProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PhenomenonProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
}

// @alpha
export class PresentationUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class PresentationUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChange(): PresentationUnitChange[];
    }

// @beta (undocumented)
export class PrimitiveArrayProperty extends PrimitiveArrayProperty_base {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    toJSON(): PrimitiveArrayPropertyProps;
}

// @beta (undocumented)
export interface PrimitiveArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export abstract class PrimitiveOrEnumPropertyBase extends Property {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    get extendedTypeName(): string | undefined;
    // (undocumented)
    protected _extendedTypeName?: string;
    // (undocumented)
    fromJSON(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): void;
    // (undocumented)
    get maxLength(): number | undefined;
    // (undocumented)
    protected _maxLength?: number;
    // (undocumented)
    get maxValue(): number | undefined;
    // (undocumented)
    protected _maxValue?: number;
    // (undocumented)
    get minLength(): number | undefined;
    // (undocumented)
    protected _minLength?: number;
    // (undocumented)
    get minValue(): number | undefined;
    // (undocumented)
    protected _minValue?: number;
    toJSON(): PrimitiveOrEnumPropertyBaseProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitiveOrEnumPropertyBaseProps extends PropertyProps {
    // (undocumented)
    readonly extendedTypeName?: string;
    // (undocumented)
    readonly maxLength?: number;
    // (undocumented)
    readonly maxValue?: number;
    // (undocumented)
    readonly minLength?: number;
    // (undocumented)
    readonly minValue?: number;
}

// @beta (undocumented)
export class PrimitiveProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    // (undocumented)
    fromJSON(primitivePropertyProps: PrimitivePropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(primitivePropertyProps: PrimitivePropertyProps): void;
    // (undocumented)
    get primitiveType(): PrimitiveType;
    toJSON(): PrimitivePropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitivePropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export enum PrimitiveType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta (undocumented)
export function primitiveTypeToString(type: PrimitiveType): string;

// @beta
export abstract class Property implements CustomAttributeContainerProps {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    get category(): LazyLoadedPropertyCategory | undefined;
    // (undocumented)
    protected _category?: LazyLoadedPropertyCategory;
    // (undocumented)
    get class(): AnyClass;
    // (undocumented)
    protected _class: AnyClass;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    fromJSON(propertyProps: PropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyProps: PropertyProps): void;
    get fullName(): string;
    // (undocumented)
    getCategorySync(): PropertyCategory | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    // (undocumented)
    getKindOfQuantitySync(): KindOfQuantity | undefined;
    // (undocumented)
    isArray(): this is AnyArrayProperty;
    // (undocumented)
    isEnumeration(): this is AnyEnumerationProperty;
    // (undocumented)
    isNavigation(): this is NavigationProperty;
    // (undocumented)
    isPrimitive(): this is AnyPrimitiveProperty;
    // (undocumented)
    get isReadOnly(): boolean;
    // (undocumented)
    protected _isReadOnly?: boolean;
    // (undocumented)
    isStruct(): this is AnyStructProperty;
    // (undocumented)
    get kindOfQuantity(): LazyLoadedKindOfQuantity | undefined;
    // (undocumented)
    protected _kindOfQuantity?: LazyLoadedKindOfQuantity;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    // (undocumented)
    protected _name: ECName;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority?: number;
    // (undocumented)
    get propertyType(): PropertyType;
    get schema(): Schema;
    toJSON(): PropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    protected _type: PropertyType;
}

// @beta (undocumented)
export class PropertyCategory extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(propertyCategoryProps: PropertyCategoryProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyCategoryProps: PropertyCategoryProps): void;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.PropertyCategory;
    // @alpha
    protected setPriority(priority: number): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PropertyCategoryProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PropertyCategoryProps extends SchemaItemProps {
    // (undocumented)
    readonly priority: number;
}

// @alpha
export class PropertyChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get propertyMissing(): PropertyMissing | undefined;
    }

// @beta
export abstract class PropertyDiagnostic<ARGS extends any[]> extends BaseDiagnostic<AnyProperty, ARGS> {
    constructor(property: AnyProperty, messageArgs?: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface PropertyEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
    // (undocumented)
    propertyName?: string;
}

// @alpha
export class PropertyMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta (undocumented)
export interface PropertyProps {
    // (undocumented)
    readonly category?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly inherited?: boolean;
    // (undocumented)
    readonly isReadOnly?: boolean;
    // (undocumented)
    readonly kindOfQuantity?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly priority?: number;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
export enum PropertyType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Binary_Array = 261,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    Boolean_Array = 517,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    DateTime_Array = 773,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Double_Array = 1029,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    IGeometry_Array = 2565,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Integer_Array = 1285,
    // (undocumented)
    Integer_Enumeration = 1297,
    // (undocumented)
    Integer_Enumeration_Array = 1301,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Long_Array = 1541,
    // (undocumented)
    Navigation = 8,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point2d_Array = 1797,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    Point3d_Array = 2053,
    // (undocumented)
    String = 2305,
    // (undocumented)
    String_Array = 2309,
    // (undocumented)
    String_Enumeration = 2321,
    // (undocumented)
    String_Enumeration_Array = 2325,
    // (undocumented)
    Struct = 2,
    // (undocumented)
    Struct_Array = 6
}

// @beta (undocumented)
export function propertyTypeToString(type: PropertyType): "PrimitiveProperty" | "StructProperty" | "StructArrayProperty" | "NavigationProperty" | "PrimitiveArrayProperty";

// @beta (undocumented)
export namespace PropertyTypeUtils {
    // (undocumented)
    export function asArray(t: PropertyType): PropertyType;
    // (undocumented)
    export function fromPrimitiveType(t: PrimitiveType): PropertyType;
    // (undocumented)
    export function getPrimitiveType(t: PropertyType): PrimitiveType;
    // (undocumented)
    export function isArray(t: PropertyType): boolean;
    // (undocumented)
    export function isEnumeration(t: PropertyType): boolean;
    // (undocumented)
    export function isNavigation(t: PropertyType): boolean;
    // (undocumented)
    export function isPrimitive(t: PropertyType): boolean;
    // (undocumented)
    export function isStruct(t: PropertyType): boolean;
}

// @alpha
export class PropertyValueChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta
export class RelationshipClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(relationshipClassProps: RelationshipClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipClassProps: RelationshipClassProps): void;
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.RelationshipClass;
    // @alpha
    protected setStrength(strength: StrengthType): void;
    // @alpha
    protected setStrengthDirection(direction: StrengthDirection): void;
    // (undocumented)
    get source(): RelationshipConstraint;
    // (undocumented)
    protected _source: RelationshipConstraint;
    // (undocumented)
    get strength(): StrengthType;
    // (undocumented)
    protected _strength: StrengthType;
    // (undocumented)
    get strengthDirection(): StrengthDirection;
    // (undocumented)
    protected _strengthDirection: StrengthDirection;
    // (undocumented)
    get target(): RelationshipConstraint;
    // (undocumented)
    protected _target: RelationshipConstraint;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): RelationshipClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface RelationshipClassProps extends ClassProps {
    // (undocumented)
    readonly source: RelationshipConstraintProps;
    // (undocumented)
    readonly strength: string;
    // (undocumented)
    readonly strengthDirection: string;
    // (undocumented)
    readonly target: RelationshipConstraintProps;
}

// @beta
export class RelationshipConstraint implements CustomAttributeContainerProps {
    constructor(relClass: RelationshipClass, relEnd: RelationshipEnd, roleLabel?: string, polymorphic?: boolean);
    // (undocumented)
    get abstractConstraint(): LazyLoadedRelationshipConstraintClass | undefined;
    set abstractConstraint(abstractConstraint: LazyLoadedRelationshipConstraintClass | undefined);
    // (undocumented)
    protected _abstractConstraint?: LazyLoadedRelationshipConstraintClass;
    addClass(constraint: EntityClass | Mixin | RelationshipClass): void;
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    static classCompatibleWithConstraint(constraintClass: ECClass, testClass: ECClass, isPolymorphic: boolean): Promise<boolean>;
    // (undocumented)
    get constraintClasses(): LazyLoadedRelationshipConstraintClass[] | undefined;
    // (undocumented)
    protected _constraintClasses?: LazyLoadedRelationshipConstraintClass[];
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // @deprecated (undocumented)
    deserialize(relationshipConstraintProps: RelationshipConstraintProps): Promise<void>;
    // @deprecated (undocumented)
    deserializeSync(relationshipConstraintProps: RelationshipConstraintProps): void;
    // (undocumented)
    fromJSON(relationshipConstraintProps: RelationshipConstraintProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipConstraintProps: RelationshipConstraintProps): void;
    get fullName(): string;
    get isSource(): boolean;
    // (undocumented)
    get multiplicity(): RelationshipMultiplicity | undefined;
    // (undocumented)
    protected _multiplicity?: RelationshipMultiplicity;
    // (undocumented)
    get polymorphic(): boolean | undefined;
    // (undocumented)
    protected _polymorphic?: boolean;
    // (undocumented)
    get relationshipClass(): RelationshipClass;
    // (undocumented)
    protected _relationshipClass: RelationshipClass;
    // (undocumented)
    get relationshipEnd(): RelationshipEnd;
    // (undocumented)
    protected _relationshipEnd: RelationshipEnd;
    // (undocumented)
    get roleLabel(): string | undefined;
    // (undocumented)
    protected _roleLabel?: string;
    get schema(): Schema;
    supportsClass(ecClass: ECClass): Promise<boolean>;
    toJSON(): RelationshipConstraintProps;
    // @deprecated (undocumented)
    toJson(): void;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @alpha
export class RelationshipConstraintChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get constraintClassChanges(): RelationshipConstraintClassChange[];
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    }

// @alpha
export class RelationshipConstraintClassChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta
export abstract class RelationshipConstraintDiagnostic<ARGS extends any[]> extends BaseDiagnostic<RelationshipConstraint, ARGS> {
    constructor(constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @beta (undocumented)
export interface RelationshipConstraintProps {
    // (undocumented)
    readonly abstractConstraint?: string;
    // (undocumented)
    readonly constraintClasses: string[];
    // (undocumented)
    readonly multiplicity: string;
    // (undocumented)
    readonly polymorphic: boolean;
    // (undocumented)
    readonly roleLabel: string;
}

// @beta
export enum RelationshipEnd {
    // (undocumented)
    Source = 0,
    // (undocumented)
    Target = 1
}

// @beta (undocumented)
export function relationshipEndToString(end: RelationshipEnd): string;

// @beta (undocumented)
export class RelationshipMultiplicity {
    constructor(lowerLimit: number, upperLimit: number);
    // (undocumented)
    equals(rhs: RelationshipMultiplicity): boolean;
    // (undocumented)
    static fromString(str: string): RelationshipMultiplicity | undefined;
    // (undocumented)
    readonly lowerLimit: number;
    // (undocumented)
    static readonly oneMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly oneOne: RelationshipMultiplicity;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly upperLimit: number;
    // (undocumented)
    static readonly zeroMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly zeroOne: RelationshipMultiplicity;
}

// @beta (undocumented)
export class Schema implements CustomAttributeContainerProps {
    constructor(context: SchemaContext, name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number);
    constructor(context: SchemaContext, key: SchemaKey, alias: string);
    // @internal
    constructor(context: SchemaContext);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    protected addItem<T extends SchemaItem>(item: T): void;
    // (undocumented)
    protected addReference(refSchema: Schema): Promise<void>;
    // (undocumented)
    protected addReferenceSync(refSchema: Schema): void;
    // (undocumented)
    get alias(): string;
    // (undocumented)
    protected _alias?: string;
    get context(): SchemaContext;
    // @alpha (undocumented)
    protected createClass<T extends AnyClass>(type: (new (schema: Schema, name: string, modifier?: ECClassModifier) => T), name: string, modifier?: ECClassModifier): T;
    protected createConstant(name: string): Promise<Constant>;
    // (undocumented)
    protected createConstantSync(name: string): Constant;
    protected createCustomAttributeClass(name: string, modifier?: ECClassModifier): Promise<CustomAttributeClass>;
    // (undocumented)
    protected createCustomAttributeClassSync(name: string, modifier?: ECClassModifier): CustomAttributeClass;
    protected createEntityClass(name: string, modifier?: ECClassModifier): Promise<EntityClass>;
    // (undocumented)
    protected createEntityClassSync(name: string, modifier?: ECClassModifier): EntityClass;
    protected createEnumeration(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Promise<Enumeration>;
    // (undocumented)
    protected createEnumerationSync(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Enumeration;
    protected createFormat(name: string): Promise<Format>;
    // (undocumented)
    protected createFormatSync(name: string): Format;
    protected createInvertedUnit(name: string): Promise<InvertedUnit>;
    // (undocumented)
    protected createInvertedUnitSync(name: string): InvertedUnit;
    // @alpha (undocumented)
    protected createItem<T extends AnySchemaItem>(type: (new (schema: Schema, name: string) => T), name: string): T;
    protected createKindOfQuantity(name: string): Promise<KindOfQuantity>;
    // (undocumented)
    protected createKindOfQuantitySync(name: string): KindOfQuantity;
    protected createMixinClass(name: string): Promise<Mixin>;
    // (undocumented)
    protected createMixinClassSync(name: string): Mixin;
    protected createPhenomenon(name: string): Promise<Phenomenon>;
    // (undocumented)
    protected createPhenomenonSync(name: string): Phenomenon;
    protected createPropertyCategory(name: string): Promise<PropertyCategory>;
    // (undocumented)
    protected createPropertyCategorySync(name: string): PropertyCategory;
    protected createRelationshipClass(name: string, modifier?: ECClassModifier): Promise<RelationshipClass>;
    // (undocumented)
    protected createRelationshipClassSync(name: string, modifier?: ECClassModifier): RelationshipClass;
    protected createStructClass(name: string, modifier?: ECClassModifier): Promise<StructClass>;
    // (undocumented)
    protected createStructClassSync(name: string, modifier?: ECClassModifier): StructClass;
    protected createUnit(name: string): Promise<Unit>;
    // (undocumented)
    protected createUnitSync(name: string): Unit;
    protected createUnitSystem(name: string): Promise<UnitSystem>;
    // (undocumented)
    protected createUnitSystemSync(name: string): UnitSystem;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    fromJSON(schemaProps: SchemaProps): Promise<void>;
    // (undocumented)
    static fromJson(jsonObj: object | string, context: SchemaContext): Promise<Schema>;
    // (undocumented)
    fromJSONSync(schemaProps: SchemaProps): void;
    // (undocumented)
    static fromJsonSync(jsonObj: object | string, context: SchemaContext): Schema;
    get fullName(): string;
    // (undocumented)
    getClasses(): IterableIterator<ECClass>;
    getItem<T extends SchemaItem>(name: string): Promise<T | undefined>;
    // (undocumented)
    getItems<T extends AnySchemaItem>(): IterableIterator<T>;
    getItemSync<T extends SchemaItem>(name: string): T | undefined;
    // (undocumented)
    getReference<T extends Schema>(refSchemaName: string): Promise<T | undefined>;
    // (undocumented)
    getReferenceNameByAlias(alias: string): string | undefined;
    // (undocumented)
    getReferenceSync<T extends Schema>(refSchemaName: string): T | undefined;
    getSchemaItemKey(fullName: string): SchemaItemKey;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    lookupItem<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): Promise<T | undefined>;
    lookupItemSync<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): T | undefined;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get readVersion(): number;
    // (undocumented)
    readonly references: Schema[];
    get schema(): Schema;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey?: SchemaKey;
    // @alpha
    protected setContext(context: SchemaContext): void;
    toJSON(): SchemaProps;
    toXml(schemaXml: Document): Promise<Document>;
    // (undocumented)
    get writeVersion(): number;
}

// @beta (undocumented)
export class SchemaCache implements ISchemaLocater {
    constructor();
    addSchema<T extends Schema>(schema: T): Promise<void>;
    addSchemaSync<T extends Schema>(schema: T): void;
    // (undocumented)
    get count(): number;
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @alpha
export class SchemaChanges extends BaseSchemaChanges {
    constructor(schema: Schema);
    addChange(change: ISchemaChange): void;
    addDiagnostic(diagnostic: AnyDiagnostic): void;
    get allDiagnostics(): AnyDiagnostic[];
    get classChanges(): Map<string, ClassChanges>;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get enumerationChanges(): Map<string, EnumerationChanges>;
    get formatChanges(): Map<string, FormatChanges>;
    get kindOfQuantityChanges(): Map<string, KindOfQuantityChanges>;
    get missingSchemaReferences(): SchemaReferenceMissing[];
    get schemaItemChanges(): Map<string, SchemaItemChanges>;
    get schemaReferenceDeltas(): SchemaReferenceDelta[];
    }

// @beta
export const SchemaCompareCodes: {
    SchemaDelta: string;
    SchemaReferenceMissing: string;
    SchemaItemDelta: string;
    SchemaItemMissing: string;
    ClassDelta: string;
    BaseClassDelta: string;
    PropertyDelta: string;
    PropertyMissing: string;
    EntityMixinMissing: string;
    MixinDelta: string;
    RelationshipDelta: string;
    RelationshipConstraintDelta: string;
    RelationshipConstraintClassMissing: string;
    CustomAttributeClassDelta: string;
    CustomAttributeInstanceClassMissing: string;
    EnumerationDelta: string;
    EnumeratorMissing: string;
    EnumeratorDelta: string;
    KoqDelta: string;
    PresentationUnitMissing: string;
    PropertyCategoryDelta: string;
    FormatDelta: string;
    FormatUnitMissing: string;
    UnitLabelOverrideDelta: string;
    UnitDelta: string;
    InvertedUnitDelta: string;
    PhenomenonDelta: string;
    ConstantDelta: string;
    SchemaReferenceDelta: string;
};

// @beta
export const SchemaCompareDiagnostics: {
    SchemaDelta: {
        new (schema: Schema, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceMissing: {
        new (schema: Schema, messageArgs: [Schema], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceDelta: {
        new (schema: Schema, messageArgs: [Schema, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ClassDelta: {
        new (ecClass: AnyClass, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassDelta: {
        new (ecClass: AnyClass, messageArgs: [CustomAttributeClass | Mixin | EntityClass | RelationshipClass | import("../ecschema-metadata").StructClass | undefined, CustomAttributeClass | Mixin | EntityClass | RelationshipClass | import("../ecschema-metadata").StructClass | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [CustomAttributeClass | Mixin | EntityClass | RelationshipClass | import("../ecschema-metadata").StructClass | undefined, CustomAttributeClass | Mixin | EntityClass | RelationshipClass | import("../ecschema-metadata").StructClass | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyDelta: {
        new (property: import("../ecschema-metadata").AnyProperty, messageArgs?: [string, any, any] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("../ecschema-metadata").AnyProperty;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    PropertyMissing: {
        new (property: import("../ecschema-metadata").AnyProperty, messageArgs?: [] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("../ecschema-metadata").AnyProperty;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    EntityMixinMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Mixin], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [Mixin] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Mixin;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipConstraintDelta: {
        new (constraint: import("../Metadata/RelationshipClass").RelationshipConstraint, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("../Metadata/RelationshipClass").RelationshipConstraint;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    RelationshipConstraintClassMissing: {
        new (constraint: import("../Metadata/RelationshipClass").RelationshipConstraint, messageArgs: [AnyClass], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("../Metadata/RelationshipClass").RelationshipConstraint;
            messageArgs?: [AnyClass] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeClassDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeInstanceClassMissing: {
        new (container: import("../Metadata/CustomAttribute").CustomAttributeContainerProps, messageArgs: [CustomAttribute], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("../Metadata/CustomAttribute").CustomAttributeContainerProps;
            messageArgs?: [CustomAttribute] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    EnumerationDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator, string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator, string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    KoqDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PresentationUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Format | OverrideFormat], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [Format | OverrideFormat] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyCategoryDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: PropertyCategory;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitLabelOverrideDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit, string | undefined, string | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit, string | undefined, string | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    InvertedUnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PhenomenonDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstantDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Constant;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
};

// @alpha
export enum SchemaCompareDirection {
    // (undocumented)
    Backward = 1,
    // (undocumented)
    Forward = 0
}

// @alpha
export class SchemaComparer {
    constructor(...reporters: ISchemaCompareReporter[]);
    compareClasses(classA: AnyClass, classB: AnyClass | undefined): Promise<void>;
    compareConstants(constantA: Constant, constantB: Constant | undefined): Promise<void>;
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass | undefined): Promise<void>;
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps | undefined): Promise<void>;
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass | undefined): Promise<void>;
    compareEnumerations(enumA: Enumeration, enumB: Enumeration | undefined): Promise<void>;
    compareFormats(formatA: Format, formatB: Format | undefined): Promise<void>;
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit | undefined): Promise<void>;
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity | undefined): Promise<void>;
    compareMixins(mixinA: Mixin, mixinB: Mixin | undefined): Promise<void>;
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon | undefined): Promise<void>;
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): Promise<void>;
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory | undefined): Promise<void>;
    compareRelationshipClasses(relationshipA: RelationshipClass, relationshipB: RelationshipClass | undefined): Promise<void>;
    compareRelationshipConstraints(constraintA: RelationshipConstraint, constraintB: RelationshipConstraint | undefined): Promise<void>;
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): Promise<void>;
    compareSchemaProps(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareSchemas(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareUnits(unitA: Unit, unitB: Unit | undefined): Promise<void>;
    }

// @beta
export class SchemaContext implements ISchemaLocater, ISchemaItemLocater {
    constructor();
    // (undocumented)
    addLocater(locater: ISchemaLocater): void;
    addSchema(schema: Schema): Promise<void>;
    addSchemaItem(schemaItem: SchemaItem): Promise<void>;
    addSchemaSync(schema: Schema): void;
    // @internal
    getCachedSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // @internal
    getCachedSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Schema | undefined;
    // (undocumented)
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
    // (undocumented)
    getSchemaItemSync<T extends SchemaItem>(schemaItemKey: SchemaItemKey): T | undefined;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @alpha
export class SchemaContextEditor {
    constructor(schemaContext: SchemaContext);
    addCustomAttribute(schemaKey: SchemaKey, customAttribute: CustomAttribute): Promise<SchemaEditResults>;
    addSchemaReference(schemaKey: SchemaKey, refSchema: Schema): Promise<SchemaEditResults>;
    // (undocumented)
    readonly constants: Editors.Constants;
    createSchema(name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number): Promise<SchemaEditResults>;
    // (undocumented)
    readonly customAttributes: Editors.CustomAttributes;
    // (undocumented)
    readonly entities: Editors.Entities;
    // (undocumented)
    readonly enumerations: Editors.Enumerations;
    // (undocumented)
    finish(): Promise<SchemaContext>;
    // (undocumented)
    readonly formats: Editors.Formats;
    // (undocumented)
    readonly invertedUnits: Editors.InvertedUnits;
    // (undocumented)
    readonly kindOfQuantities: Editors.KindOfQuantities;
    // (undocumented)
    readonly mixins: Editors.Mixins;
    // (undocumented)
    readonly phenomenons: Editors.Phenomenons;
    // (undocumented)
    readonly propertyCategories: Editors.PropertyCategories;
    // (undocumented)
    readonly relationships: Editors.RelationshipClasses;
    get schemaContext(): SchemaContext;
    // (undocumented)
    readonly structs: Editors.Structs;
    // (undocumented)
    readonly units: Editors.Units;
    // (undocumented)
    readonly unitSystems: Editors.UnitSystems;
}

// @beta
export abstract class SchemaDiagnostic<ARGS extends any[]> extends BaseDiagnostic<Schema, ARGS> {
    constructor(schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    schemaKey?: SchemaKey;
}

// @internal
export class SchemaGraphUtil {
    static buildDependencyOrderedSchemaList(insertSchema: Schema, schemas?: Schema[]): Schema[];
    }

// @beta
export abstract class SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    static equalByKey(thisSchemaItem: SchemaItem, thatSchemaItemOrKey?: SchemaItem | SchemaItemKey): boolean;
    // (undocumented)
    fromJSON(schemaItemProps: SchemaItemProps): Promise<void>;
    // (undocumented)
    fromJSONSync(schemaItemProps: SchemaItemProps): void;
    // (undocumented)
    get fullName(): string;
    // (undocumented)
    get key(): SchemaItemKey;
    // (undocumented)
    protected _key: SchemaItemKey;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    static parseFullName(fullName: string): [string, string];
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // @alpha
    protected setDescription(description: string): void;
    // @alpha
    protected setDisplayLabel(displayLabel: string): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): SchemaItemProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @alpha
export abstract class SchemaItemChange extends BaseSchemaChange {
    // (undocumented)
    get topLevelSchemaItem(): Schema | SchemaItem;
}

// @alpha
export class SchemaItemChanges extends BaseSchemaChanges {
    constructor(schema: Schema, schemaItemName: string, schemaItemType: SchemaItemType);
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    // (undocumented)
    protected getSchemaItemNameFromChange(change: ISchemaChange): string | undefined;
    get schemaItemMissing(): SchemaItemMissing | undefined;
    get schemaItemType(): SchemaItemType;
    }

// @beta
export abstract class SchemaItemDiagnostic<TYPE extends SchemaItem, ARGS extends any[]> extends BaseDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaItemEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
}

// @beta
export class SchemaItemKey {
    constructor(name: string, schema: SchemaKey);
    get fullName(): string;
    matches(rhs: SchemaItemKey): boolean;
    // (undocumented)
    matchesFullName(name: string): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey: SchemaKey;
    // (undocumented)
    get schemaName(): string;
}

// @alpha
export class SchemaItemMissing extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @beta (undocumented)
export interface SchemaItemProps {
    // (undocumented)
    readonly $schema?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name?: string;
    // (undocumented)
    readonly schema?: string;
    // (undocumented)
    readonly schemaItemType?: string;
    // (undocumented)
    readonly schemaVersion?: string;
}

// @beta (undocumented)
export enum SchemaItemType {
    // (undocumented)
    Constant = 10,
    // (undocumented)
    CustomAttributeClass = 3,
    // (undocumented)
    EntityClass = 0,
    // (undocumented)
    Enumeration = 5,
    // (undocumented)
    Format = 13,
    // (undocumented)
    InvertedUnit = 9,
    // (undocumented)
    KindOfQuantity = 6,
    // (undocumented)
    Mixin = 1,
    // (undocumented)
    Phenomenon = 11,
    // (undocumented)
    PropertyCategory = 7,
    // (undocumented)
    RelationshipClass = 4,
    // (undocumented)
    StructClass = 2,
    // (undocumented)
    Unit = 8,
    // (undocumented)
    UnitSystem = 12
}

// @beta
export function schemaItemTypeToString(value: SchemaItemType): string;

// @internal (undocumented)
export function schemaItemTypeToXmlString(value: SchemaItemType): string;

// @beta
export class SchemaKey {
    constructor(name: string, version: ECVersion);
    constructor(name: string, readVersion?: number, writeVersion?: number, minorVersion?: number);
    // (undocumented)
    compareByName(rhs: SchemaKey | string | undefined): boolean;
    compareByVersion(rhs: SchemaKey): number;
    // (undocumented)
    matches(rhs: SchemaKey, matchType?: SchemaMatchType): boolean;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static parseString(fullName: string): SchemaKey;
    // (undocumented)
    get readVersion(): number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get version(): ECVersion;
    // (undocumented)
    protected _version: ECVersion;
    // (undocumented)
    get writeVersion(): number;
}

// @beta (undocumented)
export class SchemaMap extends Array<Schema> {
}

// @beta
export enum SchemaMatchType {
    // (undocumented)
    Exact = 1,
    // (undocumented)
    Identical = 0,
    // (undocumented)
    Latest = 3,
    // (undocumented)
    LatestReadCompatible = 4,
    // (undocumented)
    LatestWriteCompatible = 2
}

// @beta
export class SchemaPartVisitorDelegate {
    constructor(visitor: ISchemaPartVisitor);
    visitSchema(schema: Schema, fullSchema?: boolean): Promise<void>;
    visitSchemaPart(schemaPart: AnyECType): Promise<void>;
    visitSchemaPartSync(schemaPart: AnyECType): void;
    visitSchemaSync(schema: Schema, fullSchema?: boolean): void;
}

// @beta (undocumented)
export interface SchemaProps {
    // (undocumented)
    readonly $schema: string;
    // (undocumented)
    readonly alias: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly items?: {
        [name: string]: SchemaItemProps;
    };
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly references?: SchemaReferenceProps[];
    // (undocumented)
    readonly version: string;
}

// @internal
export class SchemaReadHelper<T = unknown> {
    constructor(parserType: AbstractParserConstructor<T>, context?: SchemaContext, visitor?: ISchemaPartVisitor);
    readSchema<U extends Schema>(schema: U, rawSchema: T): Promise<U>;
    readSchemaSync<U extends Schema>(schema: U, rawSchema: T): U;
    }

// @alpha
export class SchemaReferenceDelta extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class SchemaReferenceMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta (undocumented)
export interface SchemaReferenceProps {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly version: string;
}

// @beta
export class SchemaValidater {
    static validateSchema(schema: Schema, validaterRuleSet?: IRuleSet): Promise<AnyDiagnostic[]>;
}

// @beta
export class SchemaValidationVisitor implements ISchemaPartVisitor {
    // (undocumented)
    applyClassRules(ecClass: AnyClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyConstantRules(constant: Constant, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeContainerRules(container: CustomAttributeContainerProps, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeInstanceRules(container: CustomAttributeContainerProps, customAttribute: CustomAttribute, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeRules(customAttribute: CustomAttributeClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEntityRules(entityClass: EntityClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEnumerationRules(enumeration: Enumeration, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyFormatRules(format: Format, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyInvertedUnitRules(invertedUnit: InvertedUnit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyKindOfQuantityRules(kindOfQuantity: KindOfQuantity, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyMixinRules(mixin: Mixin, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPhenomenonRules(phenomenon: Phenomenon, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyCategoryRules(propertyCategory: PropertyCategory, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyRules(property: AnyProperty, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipConstraintRules(constraint: RelationshipConstraint, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipRules(relationship: RelationshipClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaItemRules(schemaItem: SchemaItem, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaRules(schema: Schema, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyStructRules(structClass: StructClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitRules(unit: Unit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitSystemRules(unitSystem: UnitSystem, ruleSet: IRuleSet): Promise<void>;
    get diagnosticReporters(): IDiagnosticReporter[];
    registerReporter(...reporters: IDiagnosticReporter[]): void;
    registerRuleSet(ruleSet: IRuleSet): void;
    registerRuleSuppressionSet(suppressionSet: IRuleSuppressionSet): void;
    get ruleSets(): RuleSetArray;
    // (undocumented)
    get suppressionSet(): IRuleSuppressionSet | undefined;
    visitClass(ecClass: AnyClass): Promise<void>;
    visitConstant(constant: Constant): Promise<void>;
    visitCustomAttributeClass(customAttribute: CustomAttributeClass): Promise<void>;
    visitCustomAttributeContainer(container: CustomAttributeContainerProps): Promise<void>;
    visitEntityClass(entity: EntityClass): Promise<void>;
    visitEnumeration(enumeration: Enumeration): Promise<void>;
    visitFormat(format: Format): Promise<void>;
    visitFullSchema(schema: Schema): Promise<void>;
    visitInvertedUnit(invertedUnit: InvertedUnit): Promise<void>;
    visitKindOfQuantity(koq: KindOfQuantity): Promise<void>;
    visitMixin(mixin: Mixin): Promise<void>;
    visitPhenomenon(phenomenon: Phenomenon): Promise<void>;
    visitProperty(property: AnyProperty): Promise<void>;
    visitPropertyCategory(category: PropertyCategory): Promise<void>;
    visitRelationshipClass(relationship: RelationshipClass): Promise<void>;
    visitRelationshipConstraint(constraint: RelationshipConstraint): Promise<void>;
    visitSchemaItem(schemaItem: SchemaItem): Promise<void>;
    visitStructClass(struct: StructClass): Promise<void>;
    visitUnit(unit: Unit): Promise<void>;
    visitUnitSystem(unitSystem: UnitSystem): Promise<void>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
    }

// @beta
export enum ScientificType {
    // (undocumented)
    Normalized = 0,
    // (undocumented)
    ZeroNormalized = 1
}

// @internal
export function scientificTypeToString(scientificType: ScientificType): string;

// @beta
export enum ShowSignOption {
    // (undocumented)
    NegativeParentheses = 3,
    // (undocumented)
    NoSign = 0,
    // (undocumented)
    OnlyNegative = 1,
    // (undocumented)
    SignAlways = 2
}

// @internal
export function showSignOptionToString(showSign: ShowSignOption): string;

// @beta (undocumented)
export enum StrengthDirection {
    // (undocumented)
    Backward = 2,
    // (undocumented)
    Forward = 1
}

// @beta (undocumented)
export function strengthDirectionToString(direction: StrengthDirection): string;

// @beta (undocumented)
export function strengthToString(strength: StrengthType): string;

// @beta (undocumented)
export enum StrengthType {
    // (undocumented)
    Embedding = 2,
    // (undocumented)
    Holding = 1,
    // (undocumented)
    Referencing = 0
}

// @beta (undocumented)
export class StructArrayProperty extends StructArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: StructClass);
}

// @beta (undocumented)
export interface StructArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export class StructClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.StructClass;
}

// @beta (undocumented)
export type StructClassProps = ClassProps;

// @beta (undocumented)
export class StructProperty extends Property {
    constructor(ecClass: ECClass, name: string, type: StructClass);
    // (undocumented)
    fromJSON(structPropertyProps: StructPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(structPropertyProps: StructPropertyProps): void;
    // (undocumented)
    get structClass(): StructClass;
    // (undocumented)
    protected _structClass: StructClass;
    toJSON(): StructPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface StructPropertyProps extends PropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export abstract class SuppressionDiagnosticReporter implements IDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>);
    report(diagnostic: AnyDiagnostic): void;
    protected abstract reportInternal(diagnostic: AnyDiagnostic): void;
    get suppressions(): Map<string, string[]> | undefined;
    }

// @beta
export class Unit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    fromJSON(unitProps: UnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(unitProps: UnitProps): void;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    protected _offset: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Unit;
    // @alpha
    protected setDefinition(definition: string): Promise<void>;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): Promise<void>;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): UnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @alpha
export class UnitLabelOverrideDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta (undocumented)
export interface UnitProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly offset?: number;
    // (undocumented)
    readonly phenomenon: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta (undocumented)
export class UnitSystem extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.UnitSystem;
}

// @beta (undocumented)
export type UnitSystemProps = SchemaItemProps;

// @internal (undocumented)
export class XmlParser extends AbstractParser<Element> {
    constructor(rawSchema: Readonly<Document>);
    // (undocumented)
    findItem(itemName: string): [string, string, Element] | undefined;
    // (undocumented)
    getClassCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    getItems(): Iterable<[string, string, Element]>;
    // (undocumented)
    getProperties(xmlElement: Element): Iterable<[string, string, Element]>;
    // (undocumented)
    getPropertyCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    getReferences(): Iterable<SchemaReferenceProps>;
    // (undocumented)
    getRelationshipConstraintCustomAttributeProviders(xmlElement: Element): [Iterable<CAProviderTuple>, Iterable<CAProviderTuple>];
    // (undocumented)
    getSchemaCustomAttributeProviders(): Iterable<CAProviderTuple>;
    // (undocumented)
    parseConstant(xmlElement: Element): ConstantProps;
    // (undocumented)
    parseCustomAttributeClass(xmlElement: Element): CustomAttributeClassProps;
    // (undocumented)
    parseEntityClass(xmlElement: Element): EntityClassProps;
    // (undocumented)
    parseEnumeration(xmlElement: Element): EnumerationProps;
    // (undocumented)
    parseFormat(xmlElement: Element): FormatProps;
    // (undocumented)
    parseInvertedUnit(xmlElement: Element): InvertedUnitProps;
    // (undocumented)
    parseKindOfQuantity(xmlElement: Element): KindOfQuantityProps;
    // (undocumented)
    parseMixin(xmlElement: Element): MixinProps;
    // (undocumented)
    parseNavigationProperty(xmlElement: Element): NavigationPropertyProps;
    // (undocumented)
    parsePhenomenon(xmlElement: Element): PhenomenonProps;
    // (undocumented)
    parsePrimitiveArrayProperty(xmlElement: Element): PrimitiveArrayPropertyProps;
    // (undocumented)
    parsePrimitiveProperty(xmlElement: Element): PrimitivePropertyProps;
    // (undocumented)
    parsePropertyCategory(xmlElement: Element): PropertyCategoryProps;
    // (undocumented)
    parseRelationshipClass(xmlElement: Element): RelationshipClassProps;
    // (undocumented)
    parseSchema(): SchemaProps;
    // (undocumented)
    parseStructArrayProperty(xmlElement: Element): StructArrayPropertyProps;
    // (undocumented)
    parseStructClass(xmlElement: Element): StructClassProps;
    // (undocumented)
    parseStructProperty(xmlElement: Element): StructPropertyProps;
    // (undocumented)
    parseUnit(xmlElement: Element): UnitProps;
    // (undocumented)
    parseUnitSystem(xmlElement: Element): UnitSystemProps;
    }


// (No @packageDocumentation comment for this package)

```
