## API Report File for "@bentley/ecschema-metadata"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BentleyError } from '@bentley/bentleyjs-core';
import { I18N } from '@bentley/imodeljs-i18n';

// @beta (undocumented)
export type AnyArrayProperty = PrimitiveArrayProperty | EnumerationArrayProperty | StructArrayProperty;

// @beta (undocumented)
export type AnyClass = EntityClass | Mixin | StructClass | CustomAttributeClass | RelationshipClass;

// @beta
export type AnyDiagnostic = IDiagnostic<AnyECType, any[]>;

// Warning: (ae-forgotten-export) The symbol "CustomAttributeContainerProps" needs to be exported by the entry point ecschema-metadata.d.ts
// Warning: (ae-forgotten-export) The symbol "CustomAttribute" needs to be exported by the entry point ecschema-metadata.d.ts
// 
// @beta (undocumented)
export type AnyECType = Schema | SchemaItem | AnyProperty | RelationshipConstraint | CustomAttributeContainerProps | CustomAttribute;

// @beta (undocumented)
export type AnyEnumerationProperty = EnumerationProperty | EnumerationArrayProperty;

// @beta (undocumented)
export type AnyEnumerator = Enumerator<string | number>;

// @beta (undocumented)
export type AnyPrimitiveProperty = PrimitiveProperty | PrimitiveArrayProperty;

// @beta (undocumented)
export type AnyProperty = AnyPrimitiveProperty | AnyEnumerationProperty | AnyStructProperty | NavigationProperty;

// @beta (undocumented)
export type AnySchemaItem = AnyClass | Enumeration | KindOfQuantity | PropertyCategory | Unit | InvertedUnit | Constant | Phenomenon | UnitSystem | Format;

// @beta (undocumented)
export type AnyStructProperty = StructProperty | StructArrayProperty;

// @beta (undocumented)
export abstract class ArrayProperty extends Property {
    // (undocumented)
    readonly maxOccurs: number | undefined;
    // (undocumented)
    protected _maxOccurs?: number;
    // (undocumented)
    readonly minOccurs: number;
    // (undocumented)
    protected _minOccurs: number;
}

// @beta
export abstract class BaseDiagnostic<TYPE extends AnyECType, ARGS extends any[]> implements IDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: TYPE, messageArgs: ARGS);
    abstract readonly category: DiagnosticCategory;
    abstract readonly code: string;
    abstract readonly diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs: ARGS;
    abstract readonly messageText: string;
    abstract readonly schema: Schema;
}

// @beta (undocumented)
export type BaseRule<T extends AnyECType, U extends AnyECType> = IRule<T, U>;

// @beta
export abstract class ClassDiagnostic<ARGS extends any[]> extends SchemaItemDiagnostic<AnyClass, ARGS> {
    constructor(ecClass: AnyClass, messageArgs: ARGS);
    readonly schema: Schema;
}

// @beta
export function classModifierToString(modifier: ECClassModifier): string;

// @beta
export class Constant extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    readonly denominator: number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    deserialize(constantProps: ConstantProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "ConstantProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(constantProps: ConstantProps): void;
    // (undocumented)
    readonly numerator: number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    readonly phenomenon: LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Constant;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta
export function containerTypeToString(type: CustomAttributeContainerType): string;

// @beta
export function createClassDiagnosticClass<ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (ecClass: AnyClass, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyClass;
        messageArgs: ARGS;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createCustomAttributeContainerDiagnosticClass<ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (container: CustomAttributeContainerProps, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: CustomAttributeContainerProps;
        messageArgs: ARGS;
    };
};

// @beta
export function createPropertyDiagnosticClass<ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (property: AnyProperty, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyProperty;
        messageArgs: ARGS;
    };
};

// @beta
export function createRelationshipConstraintDiagnosticClass<ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (constraint: RelationshipConstraint, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: RelationshipConstraint;
        messageArgs: ARGS;
    };
};

// @beta
export function createSchemaDiagnosticClass<ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (schema: Schema, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: Schema;
        messageArgs: ARGS;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createSchemaItemDiagnosticClass<ITEM extends SchemaItem, ARGS extends any[]>(code: string, messageText: string, category?: DiagnosticCategory): {
    new (ecDefinition: SchemaItem, messageArgs: ARGS): {
        readonly code: string;
        readonly category: DiagnosticCategory;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: ITEM;
        messageArgs: ARGS;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export class CustomAttributeClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    readonly containerType: CustomAttributeContainerType;
    // (undocumented)
    protected _containerType?: CustomAttributeContainerType;
    // (undocumented)
    deserialize(customAttributeProps: CustomAttributeClassProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "CustomAttributeClassProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(customAttributeProps: CustomAttributeClassProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.CustomAttributeClass;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta
export abstract class CustomAttributeContainerDiagnostic<ARGS extends any[]> extends BaseDiagnostic<CustomAttributeContainerProps, ARGS> {
    constructor(container: CustomAttributeContainerProps, messageArgs: ARGS);
    readonly diagnosticType: DiagnosticType;
    readonly schema: Schema;
}

// @beta
export const enum CustomAttributeContainerType {
    // (undocumented)
    Any = 4095,
    // (undocumented)
    AnyClass = 30,
    // (undocumented)
    AnyProperty = 992,
    // (undocumented)
    AnyRelationshipConstraint = 3072,
    // (undocumented)
    CustomAttributeClass = 4,
    // (undocumented)
    EntityClass = 2,
    // (undocumented)
    NavigationProperty = 512,
    // (undocumented)
    PrimitiveArrayProperty = 128,
    // (undocumented)
    PrimitiveProperty = 32,
    // (undocumented)
    RelationshipClass = 16,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SourceRelationshipConstraint = 1024,
    // (undocumented)
    StructArrayProperty = 256,
    // (undocumented)
    StructClass = 8,
    // (undocumented)
    StructProperty = 64,
    // (undocumented)
    TargetRelationshipConstraint = 2048
}

// @internal
export const enum DecimalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Eleven = 11,
    // (undocumented)
    Five = 5,
    // (undocumented)
    Four = 4,
    // (undocumented)
    Nine = 9,
    // (undocumented)
    One = 1,
    // (undocumented)
    Seven = 7,
    // (undocumented)
    Six = 6,
    // (undocumented)
    Ten = 10,
    // (undocumented)
    Three = 3,
    // (undocumented)
    Twelve = 12,
    // (undocumented)
    Two = 2,
    // (undocumented)
    Zero = 0
}

// @internal
export class DelayedPromise<T> implements Promise<T> {
    // (undocumented)
    readonly [Symbol.toStringTag]: "Promise";
    constructor(startCallback: () => Promise<T>);
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | undefined | null): Promise<T>;
    start: () => Promise<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
}

// @beta (undocumented)
export const DelayedPromiseWithProps: DelayedPromiseWithPropsConstructor;

// Warning: (ae-incompatible-release-tags) The symbol "DelayedPromiseWithProps" is marked as @beta, but its signature references "DelayedPromise" which is marked as @internal
// 
// @beta (undocumented)
export type DelayedPromiseWithProps<TProps, TPayload> = Readonly<TProps> & DelayedPromise<TPayload>;

// @beta (undocumented)
export interface DelayedPromiseWithPropsConstructor {
    // Warning: (ae-incompatible-release-tags) The symbol "__new" is marked as @beta, but its signature references "DelayedPromise" which is marked as @internal
    new <TProps extends NoDelayedPromiseMethods, TPayload>(props: TProps, startCallback: () => Promise<TPayload>): Readonly<TProps> & DelayedPromise<TPayload>;
}

// @beta
export const enum DiagnosticCategory {
    // (undocumented)
    Error = 1,
    // (undocumented)
    Message = 3,
    // (undocumented)
    Suggestion = 2,
    // (undocumented)
    Warning = 0
}

// @beta (undocumented)
export function diagnosticCategoryToString(category: DiagnosticCategory): "Error" | "Warning" | "Message" | "Suggestion";

// @beta
export const DiagnosticCodes: {
    BaseClassIsSealed: string;
    BaseClassOfDifferentType: string;
    CustomAttributeNotOfConcreteClass: string;
    EnumerationTypeUnsupported: string;
    MixinAppliedToClassMustDeriveFromConstraint: string;
    IncompatibleValueTypePropertyOverride: string;
    IncompatibleTypePropertyOverride: string;
    IncompatibleUnitPropertyOverride: string;
    AbstractConstraintMustNarrowBaseConstraints: string;
    DerivedConstraintsMustNarrowBaseConstraints: string;
    ConstraintClassesDeriveFromAbstractContraint: string;
    AtLeastOneConstraintClassDefined: string;
    AbstractConstraintMustExistWithMultipleConstraints: string;
};

// @beta
export const Diagnostics: {
    BaseClassIsSealed: {
        new (ecClass: AnyClass, messageArgs: [string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs: [string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsOfDifferentType: {
        new (ecClass: AnyClass, messageArgs: [string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs: [string, string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeNotOfConcreteClass: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs: [string, string];
        };
    };
    EnumerationTypeUnsupported: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs: [string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinAppliedToClassMustDeriveFromConstraint: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs: [string, string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    IncompatibleValueTypePropertyOverride: {
        new (property: AnyProperty, messageArgs: [string, string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs: [string, string, string, string, string];
        };
    };
    IncompatibleTypePropertyOverride: {
        new (property: AnyProperty, messageArgs: [string, string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs: [string, string, string, string, string];
        };
    };
    IncompatibleUnitPropertyOverride: {
        new (property: AnyProperty, messageArgs: [string, string, string, string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs: [string, string, string, string, string, string, string];
        };
    };
    AbstractConstraintMustNarrowBaseConstraints: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs: [string, string, string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    DerivedConstraintsMustNarrowBaseConstraints: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs: [string, string, string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstraintClassesDeriveFromAbstractContraint: {
        new (ecDefinition: import("../ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs: [string, string, string, string];
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AtLeastOneConstraintClassDefined: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs: [string, string];
        };
    };
    AbstractConstraintMustExistWithMultipleConstraints: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string]): {
            readonly code: string;
            readonly category: import("./Diagnostic").DiagnosticCategory;
            readonly messageText: string;
            readonly schema: import("../ecschema-metadata").Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs: [string, string];
        };
    };
};

// @beta
export const enum DiagnosticType {
    // (undocumented)
    CustomAttributeContainer = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Property = 3,
    // (undocumented)
    RelationshipConstraint = 5,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SchemaItem = 2
}

// @beta (undocumented)
export function diagnosticTypeToString(type: DiagnosticType): "Schema" | "None" | "CustomAttributeContainer" | "Property" | "RelationshipConstraint" | "SchemaItem";

// @beta
export abstract class ECClass extends SchemaItem implements CustomAttributeContainerProps {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    protected addProperty<T extends Property>(prop: T): T;
    // (undocumented)
    baseClass: LazyLoadedECClass | undefined;
    // (undocumented)
    protected _baseClass?: LazyLoadedECClass;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    // (undocumented)
    protected createPrimitiveArrayProperty(name: string, primitiveType: Enumeration): Promise<EnumerationArrayProperty>;
    protected createPrimitiveArrayProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveArrayProperty>;
    // (undocumented)
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: Enumeration): EnumerationArrayProperty;
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: PrimitiveType): PrimitiveArrayProperty;
    // (undocumented)
    protected createPrimitiveProperty(name: string, primitiveType: Enumeration): Promise<EnumerationProperty>;
    protected createPrimitiveProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveProperty>;
    protected createPrimitivePropertySync(name: string, primitiveType: PrimitiveType): PrimitiveProperty;
    // (undocumented)
    protected createPrimitivePropertySync(name: string, primitiveType: Enumeration): EnumerationProperty;
    // (undocumented)
    protected createStructArrayProperty(name: string, structType: string | StructClass): Promise<StructArrayProperty>;
    // (undocumented)
    protected createStructArrayPropertySync(name: string, structType: string | StructClass): StructArrayProperty;
    // (undocumented)
    protected createStructProperty(name: string, structType: string | StructClass): Promise<StructProperty>;
    // (undocumented)
    protected createStructPropertySync(name: string, structType: string | StructClass): StructProperty;
    // Warning: (ae-forgotten-export) The symbol "CustomAttributeSet" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    readonly customAttributes: CustomAttributeSet | undefined;
    // (undocumented)
    deserialize(classProps: ClassProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "ClassProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(classProps: ClassProps): void;
    getAllBaseClasses(): AsyncIterableIterator<ECClass>;
    // (undocumented)
    getAllBaseClassesSync(): Iterable<AnyClass>;
    // (undocumented)
    getBaseClassSync(): ECClass | undefined;
    getInheritedProperty(name: string): Promise<Property | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    getProperties(resetCache?: boolean): Promise<Property[]>;
    getPropertiesSync(resetCache?: boolean): Property[];
    getProperty(name: string, includeInherited?: boolean): Promise<Property | undefined>;
    getPropertySync(name: string, includeInherited?: boolean): Property | undefined;
    is(targetClass: string, schemaName: string): Promise<boolean>;
    // (undocumented)
    is(targetClass: ECClass): Promise<boolean>;
    isSync(targetClass: ECClass): boolean;
    // (undocumented)
    protected loadPrimitiveType(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): Promise<PrimitiveType | Enumeration>;
    // (undocumented)
    protected loadPrimitiveTypeSync(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): PrimitiveType | Enumeration;
    // (undocumented)
    protected loadStructType(structType: string | StructClass | undefined, schema: Schema): Promise<StructClass>;
    // (undocumented)
    protected loadStructTypeSync(structType: string | StructClass | undefined, schema: Schema): StructClass;
    // (undocumented)
    protected static mergeProperties(target: Property[], existingValues: Map<string, number>, propertiesToMerge: Property[], overwriteExisting: boolean): void;
    // (undocumented)
    readonly modifier: ECClassModifier;
    // (undocumented)
    protected _modifier: ECClassModifier;
    // (undocumented)
    readonly properties: Property[] | undefined;
    // (undocumented)
    protected _properties?: Property[];
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
    traverseBaseClasses(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): Promise<boolean>;
    traverseBaseClassesSync(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): boolean;
}

// @beta (undocumented)
export const enum ECClassModifier {
    // (undocumented)
    Abstract = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sealed = 2
}

// @beta
export class ECName {
    constructor(name: string);
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static validate(newName: string): boolean;
}

// @internal (undocumented)
export class ECObjectsError extends BentleyError {
    constructor(errorNumber: number, message?: string);
    // (undocumented)
    readonly errorNumber: number;
    // (undocumented)
    toDebugString(): string;
}

// @internal (undocumented)
export const enum ECObjectsStatus {
    // (undocumented)
    ClassNotFound = 35074,
    // (undocumented)
    DifferentSchemaContexts = 35076,
    // (undocumented)
    DuplicateItem = 35053,
    // (undocumented)
    DuplicateProperty = 35054,
    // (undocumented)
    DuplicateSchema = 35055,
    // (undocumented)
    ECOBJECTS_ERROR_BASE = 35052,
    // (undocumented)
    ImmutableSchema = 35056,
    // (undocumented)
    InvalidContainerType = 35057,
    // (undocumented)
    InvalidECJson = 35058,
    // (undocumented)
    InvalidECName = 35059,
    // (undocumented)
    InvalidECVersion = 35060,
    // (undocumented)
    InvalidEnumValue = 35061,
    // (undocumented)
    InvalidModifier = 35062,
    // (undocumented)
    InvalidMultiplicity = 35063,
    // (undocumented)
    InvalidPrimitiveType = 35064,
    // (undocumented)
    InvalidRelationshipEnd = 35068,
    // (undocumented)
    InvalidSchemaItemType = 35065,
    // (undocumented)
    InvalidSchemaString = 35073,
    // (undocumented)
    InvalidSchemaXML = 35072,
    // (undocumented)
    InvalidStrength = 35066,
    // (undocumented)
    InvalidStrengthDirection = 35067,
    // (undocumented)
    InvalidType = 35069,
    // (undocumented)
    MissingSchemaUrl = 35070,
    // (undocumented)
    SchemaContextUndefined = 35075,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UnableToLocateSchema = 35071
}

// @beta
export const ECRuleSet: IRuleSet;

// @internal (undocumented)
export class ECStringConstants {
    // (undocumented)
    static readonly CONTAINERTYPE_ANY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_CUSTOMATTRIBUTECLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ENTITYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_NAVIGATIONPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_RELATIONSHIPCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SCHEMA: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SOURCERELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_TARGETRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_SOURCE: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_TARGET: string;
}

// @beta (undocumented)
export class ECVersion {
    constructor(read?: number, write?: number, minor?: number);
    compare(rhv: ECVersion): number;
    static fromString(versionString: string): ECVersion;
    // (undocumented)
    readonly minor: number;
    // (undocumented)
    readonly read: number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    readonly write: number;
    }

// @beta
export class EntityClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addMixin(mixin: Mixin): void;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // Warning: (ae-forgotten-export) The symbol "EntityClassProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserialize(entityClassProps: EntityClassProps): Promise<void>;
    // (undocumented)
    deserializeSync(entityClassProps: EntityClassProps): void;
    getInheritedProperty(name: string): Promise<AnyProperty | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    // (undocumented)
    getMixinsSync(): Iterable<Mixin>;
    // (undocumented)
    readonly mixins: LazyLoadedMixin[];
    // (undocumented)
    protected _mixins?: LazyLoadedMixin[];
    // (undocumented)
    readonly schemaItemType: SchemaItemType.EntityClass;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): any | void;
}

// @beta
export class Enumeration extends SchemaItem {
    constructor(schema: Schema, name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String);
    protected addEnumerator(enumerator: AnyEnumerator): void;
    createEnumerator(name: string, value: string | number, label?: string, description?: string): AnyEnumerator;
    // (undocumented)
    deserialize(enumerationProps: EnumerationProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "EnumerationProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(enumerationProps: EnumerationProps): void;
    // (undocumented)
    readonly enumerators: Enumerator<string | number>[];
    // (undocumented)
    protected _enumerators: AnyEnumerator[];
    getEnumerator(value: string): Enumerator<string> | undefined;
    // (undocumented)
    getEnumerator(value: number): Enumerator<number> | undefined;
    getEnumeratorByName(name: string): AnyEnumerator | undefined;
    // (undocumented)
    readonly isInt: boolean;
    // (undocumented)
    readonly isStrict: boolean;
    // (undocumented)
    protected _isStrict: boolean;
    // (undocumented)
    readonly isString: boolean;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Enumeration;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
    // (undocumented)
    readonly type: PrimitiveType.Integer | PrimitiveType.String | undefined;
    // (undocumented)
    protected _type?: PrimitiveType.Integer | PrimitiveType.String;
}

// Warning: (ae-forgotten-export) The symbol "EnumerationArrayProperty_base" needs to be exported by the entry point ecschema-metadata.d.ts
// 
// @beta (undocumented)
export class EnumerationArrayProperty extends EnumerationArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
}

// @beta (undocumented)
export class EnumerationProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
    // (undocumented)
    deserialize(enumerationPropertyProps: EnumerationPropertyProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "EnumerationPropertyProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(enumerationPropertyProps: EnumerationPropertyProps): void;
    // (undocumented)
    readonly enumeration: LazyLoadedEnumeration | undefined;
    // (undocumented)
    protected _enumeration?: LazyLoadedEnumeration;
    // (undocumented)
    toJson(): any;
}

// @beta (undocumented)
export interface Enumerator<T> {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: T;
}

// @internal
export class FileSchemaKey extends SchemaKey {
    constructor(key: SchemaKey, fileName: string, schemaJson?: string);
    // (undocumented)
    fileName: string;
    // (undocumented)
    schemaText?: string;
}

// @beta (undocumented)
export class Format extends SchemaItem {
    constructor(schema: Schema, name: string);
    protected addUnit(unit: Unit | InvertedUnit, label?: string): void;
    // (undocumented)
    readonly decimalSeparator: string;
    // (undocumented)
    protected _decimalSeparator: string;
    // (undocumented)
    deserialize(formatProps: FormatProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "FormatProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(formatProps: FormatProps): void;
    // Warning: (ae-incompatible-release-tags) The symbol "formatTraits" is marked as @beta, but its signature references "FormatTraits" which is marked as @internal
    // 
    // (undocumented)
    readonly formatTraits: FormatTraits;
    // Warning: (ae-incompatible-release-tags) The symbol "_formatTraits" is marked as @beta, but its signature references "FormatTraits" which is marked as @internal
    // 
    // (undocumented)
    protected _formatTraits: FormatTraits;
    // Warning: (ae-incompatible-release-tags) The symbol "hasFormatTrait" is marked as @beta, but its signature references "FormatTraits" which is marked as @internal
    // 
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    readonly includeZero: boolean | undefined;
    // (undocumented)
    protected _includeZero: boolean;
    // (undocumented)
    readonly minWidth: number | undefined;
    // (undocumented)
    protected _minWidth?: number;
    // Warning: (ae-incompatible-release-tags) The symbol "precision" is marked as @beta, but its signature references "DecimalPrecision" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "precision" is marked as @beta, but its signature references "FractionalPrecision" which is marked as @internal
    // 
    // (undocumented)
    readonly precision: DecimalPrecision | FractionalPrecision;
    // (undocumented)
    protected _precision: number;
    // (undocumented)
    readonly roundFactor: number;
    // (undocumented)
    protected _roundFactor: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Format;
    // Warning: (ae-incompatible-release-tags) The symbol "scientificType" is marked as @beta, but its signature references "ScientificType" which is marked as @internal
    // 
    // (undocumented)
    readonly scientificType: ScientificType | undefined;
    // Warning: (ae-incompatible-release-tags) The symbol "_scientificType" is marked as @beta, but its signature references "ScientificType" which is marked as @internal
    // 
    // (undocumented)
    protected _scientificType?: ScientificType;
    // (undocumented)
    protected setPrecision(precision: number): void;
    // Warning: (ae-incompatible-release-tags) The symbol "showSignOption" is marked as @beta, but its signature references "ShowSignOption" which is marked as @internal
    // 
    // (undocumented)
    readonly showSignOption: ShowSignOption;
    // Warning: (ae-incompatible-release-tags) The symbol "_showSignOption" is marked as @beta, but its signature references "ShowSignOption" which is marked as @internal
    // 
    // (undocumented)
    protected _showSignOption: ShowSignOption;
    // (undocumented)
    readonly spacer: string | undefined;
    // (undocumented)
    protected _spacer: string;
    // (undocumented)
    readonly stationOffsetSize: number | undefined;
    // (undocumented)
    protected _stationOffsetSize?: number;
    // (undocumented)
    readonly stationSeparator: string;
    // (undocumented)
    protected _stationSeparator: string;
    // (undocumented)
    readonly thousandSeparator: string;
    // (undocumented)
    protected _thousandSeparator: string;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
    // Warning: (ae-incompatible-release-tags) The symbol "type" is marked as @beta, but its signature references "FormatType" which is marked as @internal
    // 
    // (undocumented)
    readonly type: FormatType;
    // Warning: (ae-incompatible-release-tags) The symbol "_type" is marked as @beta, but its signature references "FormatType" which is marked as @internal
    // 
    // (undocumented)
    protected _type: FormatType;
    // (undocumented)
    readonly units: Array<[Unit | InvertedUnit, string | undefined]> | undefined;
    // (undocumented)
    protected _units?: Array<[Unit | InvertedUnit, string | undefined]>;
    // (undocumented)
    readonly uomSeparator: string;
    // (undocumented)
    protected _uomSeparator: string;
}

// @beta
export abstract class FormatDiagnosticReporter extends SuppressionDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>, i18n?: I18N);
    protected formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string;
    i18N?: I18N;
    protected abstract reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
    reportInternal(diagnostic: AnyDiagnostic): void;
    }

// @internal
export const formatStringRgx: RegExp;

// @internal
export const enum FormatTraits {
    // (undocumented)
    ApplyRounding = 16,
    // (undocumented)
    ExponentOnlyNegative = 512,
    // (undocumented)
    FractionDash = 32,
    // (undocumented)
    KeepDecimalPoint = 8,
    // (undocumented)
    KeepSingleZero = 2,
    // (undocumented)
    PrependUnitLabel = 128,
    // (undocumented)
    ShowUnitLabel = 64,
    // (undocumented)
    TrailZeroes = 1,
    // (undocumented)
    Use1000Separator = 256,
    // (undocumented)
    ZeroEmpty = 4
}

// @internal
export function formatTraitsToArray(currentFormatTrait: FormatTraits): string[];

// @internal
export const enum FormatType {
    // (undocumented)
    Decimal = 0,
    // (undocumented)
    Fractional = 1,
    // (undocumented)
    Scientific = 2,
    // (undocumented)
    Station = 3
}

// @internal
export function formatTypeToString(type: FormatType): string;

// @internal
export const enum FractionalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Four = 4,
    // (undocumented)
    One = 1,
    // (undocumented)
    OneHundredTwentyEight = 128,
    // (undocumented)
    Sixteen = 16,
    // (undocumented)
    SixtyFour = 64,
    // (undocumented)
    ThirtyTwo = 32,
    // (undocumented)
    Two = 2,
    // (undocumented)
    TwoHundredFiftySix = 256
}

// @beta
export interface IDiagnostic<TYPE extends AnyECType, ARGS extends any[]> {
    category: DiagnosticCategory;
    code: string;
    diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs: ARGS;
    messageText: string;
    schema: Schema;
}

// @beta
export interface IDiagnosticReporter {
    i18N?: I18N;
    report(diagnostic: AnyDiagnostic): void;
    suppressions?: Map<string, string[]>;
}

// @beta
export class InvertedUnit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    deserialize(invertedUnitProps: InvertedUnitProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "InvertedUnitProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(invertedUnitProps: InvertedUnitProps): void;
    // (undocumented)
    readonly invertsUnit: LazyLoadedUnit | undefined;
    // (undocumented)
    protected _invertsUnit?: LazyLoadedUnit;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.InvertedUnit;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
    // (undocumented)
    readonly unitSystem: LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta
export type IRule<T extends AnyECType, U = {}> = (ecDefinition: T, ...args: U[]) => AsyncIterable<BaseDiagnostic<T, any[]>>;

// @beta
export interface IRuleSet {
    classRules?: Array<IRule<AnyClass>>;
    constantRules?: Array<IRule<Constant>>;
    customAttributeClassRules?: Array<IRule<CustomAttributeClass>>;
    customAttributeContainerRules?: Array<IRule<CustomAttributeContainerProps>>;
    customAttributeInstanceRules?: Array<BaseRule<CustomAttributeContainerProps, CustomAttribute>>;
    entityClassRules?: Array<IRule<EntityClass>>;
    enumerationRules?: Array<IRule<Enumeration>>;
    formatRules?: Array<IRule<Format>>;
    invertedUnitRules?: Array<IRule<InvertedUnit>>;
    kindOfQuantityRules?: Array<IRule<KindOfQuantity>>;
    mixinRules?: Array<IRule<Mixin>>;
    name: string;
    phenomenonRules?: Array<IRule<Phenomenon>>;
    propertyCategoryRules?: Array<IRule<PropertyCategory>>;
    propertyRules?: Array<IRule<AnyProperty>>;
    relationshipConstraintRules?: Array<IRule<RelationshipConstraint>>;
    relationshipRules?: Array<IRule<RelationshipClass>>;
    schemaItemRules?: Array<IRule<SchemaItem>>;
    schemaRules?: Array<IRule<Schema>>;
    structClassRules?: Array<IRule<StructClass>>;
    unitRules?: Array<IRule<Unit>>;
    unitSystemRules?: Array<IRule<UnitSystem>>;
}

// @beta (undocumented)
export interface ISchemaItemLocater {
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
}

// @beta
export interface ISchemaLocater {
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): Promise<T | undefined>;
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): T | undefined;
}

// @beta
export interface ISchemaPartVisitor {
    visitClass?: (ecClass: AnyClass) => Promise<void>;
    visitClassSync?: (ecClass: AnyClass) => void;
    visitConstant?: (constant: Constant) => Promise<void>;
    visitConstantSync?: (constant: Constant) => void;
    visitCustomAttributeClass?: (customAttributeClass: CustomAttributeClass) => Promise<void>;
    visitCustomAttributeClassSync?: (customAttributeClass: CustomAttributeClass) => void;
    visitCustomAttributeContainer?: (customAttributeContainer: CustomAttributeContainerProps) => Promise<void>;
    visitCustomAttributeContainerSync?: (customAttributeContainer: CustomAttributeContainerProps) => void;
    visitEmptySchema?: (schema: Schema) => Promise<void>;
    visitEmptySchemaSync?: (schema: Schema) => void;
    visitEntityClass?: (entityClass: EntityClass) => Promise<void>;
    visitEntityClassSync?: (entityClass: EntityClass) => void;
    visitEnumeration?: (enumeration: Enumeration) => Promise<void>;
    visitEnumerationSync?: (enumeration: Enumeration) => void;
    visitFormat?: (format: Format) => Promise<void>;
    visitFormatSync?: (format: Format) => void;
    visitFullSchema?: (schema: Schema) => Promise<void>;
    visitFullSchemaSync?: (schema: Schema) => void;
    visitInvertedUnit?: (invertedUnit: InvertedUnit) => Promise<void>;
    visitInvertedUnitSync?: (invertedUnit: InvertedUnit) => void;
    visitKindOfQuantity?: (koq: KindOfQuantity) => Promise<void>;
    visitKindOfQuantitySync?: (koq: KindOfQuantity) => void;
    visitMixin?: (mixin: Mixin) => Promise<void>;
    visitMixinSync?: (mixin: Mixin) => void;
    visitPhenomenon?: (phenomena: Phenomenon) => Promise<void>;
    visitPhenomenonSync?: (phenomena: Phenomenon) => void;
    visitProperty?: (property: AnyProperty) => Promise<void>;
    visitPropertyCategory?: (category: PropertyCategory) => Promise<void>;
    visitPropertyCategorySync?: (category: PropertyCategory) => void;
    visitPropertySync?: (property: AnyProperty) => void;
    visitRelationshipClass?: (relationshipClass: RelationshipClass) => Promise<void>;
    visitRelationshipClassSync?: (relationshipClass: RelationshipClass) => void;
    visitRelationshipConstraint?: (relationshipConstraint: RelationshipConstraint) => Promise<void>;
    visitRelationshipConstraintSync?: (relationshipConstraint: RelationshipConstraint) => void;
    visitSchemaItem?: (schemaItem: SchemaItem) => Promise<void>;
    visitSchemaItemSync?: (schemaItem: SchemaItem) => void;
    visitStructClass?: (structClass: StructClass) => Promise<void>;
    visitStructClassSync?: (structClass: StructClass) => void;
    visitUnit?: (unit: Unit) => Promise<void>;
    visitUnitSync?: (unit: Unit) => void;
    visitUnitSystem?: (unitSystem: UnitSystem) => Promise<void>;
    visitUnitSystemSync?: (unitSystem: UnitSystem) => void;
}

// @beta
export class KindOfQuantity extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    protected addPresentationFormat(format: Format | OverrideFormat, isDefault?: boolean): void;
    // (undocumented)
    protected createFormatOverride(parent: Format, name: string, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): OverrideFormat;
    // (undocumented)
    readonly defaultPresentationFormat: undefined | Format | OverrideFormat;
    // (undocumented)
    deserialize(kindOfQuantityProps: KindOfQuantityProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "KindOfQuantityProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(kindOfQuantityProps: KindOfQuantityProps): void;
    // (undocumented)
    persistenceUnit: LazyLoadedUnit | LazyLoadedInvertedUnit | undefined;
    // (undocumented)
    protected _persistenceUnit?: LazyLoadedUnit | LazyLoadedInvertedUnit;
    // (undocumented)
    readonly presentationUnits: Array<Format | OverrideFormat> | undefined;
    // (undocumented)
    protected _presentationUnits: Array<Format | OverrideFormat>;
    // (undocumented)
    readonly relativeError: number;
    // (undocumented)
    protected _relativeError: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.KindOfQuantity;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta (undocumented)
export type LazyLoadedConstant = LazyLoadedSchemaItem<Constant>;

// @beta (undocumented)
export type LazyLoadedCustomAttributeClass = LazyLoadedSchemaItem<CustomAttributeClass>;

// @beta (undocumented)
export type LazyLoadedECClass = LazyLoadedSchemaItem<ECClass>;

// @beta (undocumented)
export type LazyLoadedEntityClass = LazyLoadedSchemaItem<EntityClass>;

// @beta (undocumented)
export type LazyLoadedEnumeration = LazyLoadedSchemaItem<Enumeration>;

// @beta (undocumented)
export type LazyLoadedFormat = LazyLoadedSchemaItem<Format>;

// @beta (undocumented)
export type LazyLoadedInvertedUnit = LazyLoadedSchemaItem<InvertedUnit>;

// @beta (undocumented)
export type LazyLoadedKindOfQuantity = LazyLoadedSchemaItem<KindOfQuantity>;

// @beta (undocumented)
export type LazyLoadedMixin = LazyLoadedSchemaItem<Mixin>;

// @beta (undocumented)
export type LazyLoadedPhenomenon = LazyLoadedSchemaItem<Phenomenon>;

// @beta (undocumented)
export type LazyLoadedPropertyCategory = LazyLoadedSchemaItem<PropertyCategory>;

// @beta (undocumented)
export type LazyLoadedRelationshipClass = LazyLoadedSchemaItem<RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedRelationshipConstraintClass = LazyLoadedSchemaItem<EntityClass | Mixin | RelationshipClass>;

// Warning: (ae-incompatible-release-tags) The symbol "LazyLoadedSchema" is marked as @beta, but its signature references "DelayedPromise" which is marked as @internal
// 
// @beta (undocumented)
export type LazyLoadedSchema = Readonly<SchemaKey> & DelayedPromise<Schema> & Promise<Schema>;

// Warning: (ae-incompatible-release-tags) The symbol "LazyLoadedSchemaItem" is marked as @beta, but its signature references "DelayedPromise" which is marked as @internal
// 
// @beta (undocumented)
export type LazyLoadedSchemaItem<T extends SchemaItem> = Readonly<SchemaItemKey> & DelayedPromise<T> & Promise<T>;

// @beta (undocumented)
export type LazyLoadedStructClass = LazyLoadedSchemaItem<StructClass>;

// @beta (undocumented)
export type LazyLoadedUnit = LazyLoadedSchemaItem<Unit>;

// @beta (undocumented)
export type LazyLoadedUnitSystem = LazyLoadedSchemaItem<UnitSystem>;

// @beta
export class LoggingDiagnosticReporter extends FormatDiagnosticReporter {
    // (undocumented)
    reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
}

// @beta
export class Mixin extends ECClass {
    constructor(schema: Schema, name: string);
    // (undocumented)
    applicableTo(entityClass: EntityClass): Promise<boolean>;
    // (undocumented)
    readonly appliesTo: LazyLoadedEntityClass | undefined;
    // (undocumented)
    protected _appliesTo?: LazyLoadedEntityClass;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    deserialize(mixinProps: MixinProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "MixinProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(mixinProps: MixinProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Mixin;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta (undocumented)
export class NavigationProperty extends Property {
    constructor(ecClass: ECClass, name: string, relationship: LazyLoadedRelationshipClass, direction?: StrengthDirection);
    // (undocumented)
    readonly direction: StrengthDirection;
    // (undocumented)
    protected _direction: StrengthDirection;
    // (undocumented)
    getRelationshipClassSync(): RelationshipClass | undefined;
    // (undocumented)
    readonly relationshipClass: LazyLoadedRelationshipClass;
    // (undocumented)
    protected _relationshipClass: LazyLoadedRelationshipClass;
    // (undocumented)
    toJson(): any;
}

// @beta (undocumented)
export interface NoDelayedPromiseMethods {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    catch?: never;
    // (undocumented)
    start?: never;
    // (undocumented)
    then?: never;
}

// @beta
export class OverrideFormat {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @beta, but its signature references "DecimalPrecision" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @beta, but its signature references "FractionalPrecision" which is marked as @internal
    constructor(parent: Format, name: string, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>);
    // (undocumented)
    readonly decimalSeparator: string;
    // Warning: (ae-incompatible-release-tags) The symbol "formatTraits" is marked as @beta, but its signature references "FormatTraits" which is marked as @internal
    // 
    // (undocumented)
    readonly formatTraits: FormatTraits;
    // (undocumented)
    readonly fullName: string;
    // Warning: (ae-incompatible-release-tags) The symbol "hasFormatTrait" is marked as @beta, but its signature references "FormatTraits" which is marked as @internal
    // 
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    readonly includeZero: boolean | undefined;
    // (undocumented)
    readonly minWidth: number | undefined;
    readonly name: string;
    readonly parent: Format;
    // Warning: (ae-incompatible-release-tags) The symbol "precision" is marked as @beta, but its signature references "DecimalPrecision" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "precision" is marked as @beta, but its signature references "FractionalPrecision" which is marked as @internal
    // 
    // (undocumented)
    readonly precision: DecimalPrecision | FractionalPrecision;
    // (undocumented)
    readonly roundFactor: number;
    // Warning: (ae-incompatible-release-tags) The symbol "scientificType" is marked as @beta, but its signature references "ScientificType" which is marked as @internal
    // 
    // (undocumented)
    readonly scientificType: ScientificType | undefined;
    // Warning: (ae-incompatible-release-tags) The symbol "showSignOption" is marked as @beta, but its signature references "ShowSignOption" which is marked as @internal
    // 
    // (undocumented)
    readonly showSignOption: ShowSignOption;
    // (undocumented)
    readonly spacer: string | undefined;
    // (undocumented)
    readonly stationOffsetSize: number | undefined;
    // (undocumented)
    readonly stationSeparator: string;
    // (undocumented)
    readonly thousandSeparator: string;
    // Warning: (ae-incompatible-release-tags) The symbol "type" is marked as @beta, but its signature references "FormatType" which is marked as @internal
    // 
    // (undocumented)
    readonly type: FormatType;
    // (undocumented)
    readonly units: [Unit | InvertedUnit, string | undefined][] | undefined;
    // (undocumented)
    readonly uomSeparator: string;
}

// @beta
export function parseClassModifier(modifier: string): ECClassModifier | undefined;

// @beta
export function parseCustomAttributeContainerType(type: string): CustomAttributeContainerType | undefined;

// @internal
export function parseDecimalPrecision(jsonObjPrecision: number): DecimalPrecision | undefined;

// @internal
export function parseFormatTrait(formatTraitsString: string): FormatTraits | undefined;

// @internal
export function parseFormatType(jsonObjType: string): FormatType | undefined;

// @internal
export function parseFractionalPrecision(jsonObjPrecision: number): FractionalPrecision | undefined;

// @internal
export function parsePrecision(precision: number, type: FormatType): DecimalPrecision | FractionalPrecision | undefined;

// @beta
export function parsePrimitiveType(type: string): PrimitiveType | undefined;

// @beta (undocumented)
export function parseRelationshipEnd(end: string): RelationshipEnd | undefined;

// @beta
export function parseSchemaItemType(type: string): SchemaItemType | undefined;

// @internal
export function parseScientificType(scientificType: string): ScientificType | undefined;

// @internal
export function parseShowSignOption(showSignOption: string): ShowSignOption | undefined;

// @beta
export function parseStrength(strength: string): StrengthType | undefined;

// @beta (undocumented)
export function parseStrengthDirection(direction: string): StrengthDirection | undefined;

// @beta (undocumented)
export class Phenomenon extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    deserialize(phenomenonProps: PhenomenonProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "PhenomenonProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(phenomenonProps: PhenomenonProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Phenomenon;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// Warning: (ae-forgotten-export) The symbol "PrimitiveArrayProperty_base" needs to be exported by the entry point ecschema-metadata.d.ts
// 
// @beta (undocumented)
export class PrimitiveArrayProperty extends PrimitiveArrayProperty_base {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
}

// @beta (undocumented)
export abstract class PrimitiveOrEnumPropertyBase extends Property {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    deserialize(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "PrimitiveOrEnumPropertyBaseProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): void;
    // (undocumented)
    readonly extendedTypeName: string | undefined;
    // (undocumented)
    protected _extendedTypeName?: string;
    // (undocumented)
    readonly maxLength: number | undefined;
    // (undocumented)
    protected _maxLength?: number;
    // (undocumented)
    readonly maxValue: number | undefined;
    // (undocumented)
    protected _maxValue?: number;
    // (undocumented)
    readonly minLength: number | undefined;
    // (undocumented)
    protected _minLength?: number;
    // (undocumented)
    readonly minValue: number | undefined;
    // (undocumented)
    protected _minValue?: number;
    // (undocumented)
    toJson(): any;
}

// @beta (undocumented)
export class PrimitiveProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    // (undocumented)
    deserialize(primitivePropertyProps: PrimitivePropertyProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "PrimitivePropertyProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(primitivePropertyProps: PrimitivePropertyProps): void;
    // (undocumented)
    readonly primitiveType: PrimitiveType;
    // (undocumented)
    toJson(): any;
}

// @beta
export const enum PrimitiveType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta (undocumented)
export function primitiveTypeToString(type: PrimitiveType): string;

// @beta
export abstract class Property implements CustomAttributeContainerProps {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    readonly category: LazyLoadedPropertyCategory | undefined;
    // (undocumented)
    protected _category?: LazyLoadedPropertyCategory;
    // (undocumented)
    readonly class: AnyClass;
    // (undocumented)
    protected _class: AnyClass;
    // (undocumented)
    readonly customAttributes: CustomAttributeSet | undefined;
    // (undocumented)
    readonly description: string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    deserialize(propertyProps: PropertyProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "PropertyProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(propertyProps: PropertyProps): void;
    readonly fullName: string;
    // (undocumented)
    getCategorySync(): PropertyCategory | undefined;
    // (undocumented)
    getKindOfQuantitySync(): KindOfQuantity | undefined;
    // (undocumented)
    isArray(): this is AnyArrayProperty;
    // (undocumented)
    isEnumeration(): this is AnyEnumerationProperty;
    // (undocumented)
    isNavigation(): this is NavigationProperty;
    // (undocumented)
    isPrimitive(): this is AnyPrimitiveProperty;
    // (undocumented)
    readonly isReadOnly: boolean;
    // (undocumented)
    protected _isReadOnly?: boolean;
    // (undocumented)
    isStruct(): this is AnyStructProperty;
    // (undocumented)
    readonly kindOfQuantity: LazyLoadedKindOfQuantity | undefined;
    // (undocumented)
    protected _kindOfQuantity?: LazyLoadedKindOfQuantity;
    // (undocumented)
    readonly label: string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected _name: ECName;
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    protected _priority?: number;
    readonly schema: Schema;
    // (undocumented)
    toJson(): any;
    // (undocumented)
    protected _type: PropertyType;
}

// @beta (undocumented)
export class PropertyCategory extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    deserialize(propertyCategoryProps: PropertyCategoryProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "PropertyCategoryProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(propertyCategoryProps: PropertyCategoryProps): void;
    // (undocumented)
    readonly priority: number;
    // (undocumented)
    protected _priority: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.PropertyCategory;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta
export abstract class PropertyDiagnostic<ARGS extends any[]> extends BaseDiagnostic<AnyProperty, ARGS> {
    constructor(property: AnyProperty, messageArgs: ARGS);
    readonly diagnosticType: DiagnosticType;
    readonly schema: Schema;
}

// @beta (undocumented)
export const enum PropertyType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Binary_Array = 261,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    Boolean_Array = 517,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    DateTime_Array = 773,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Double_Array = 1029,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    IGeometry_Array = 2565,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Integer_Array = 1285,
    // (undocumented)
    Integer_Enumeration = 1297,
    // (undocumented)
    Integer_Enumeration_Array = 1301,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Long_Array = 1541,
    // (undocumented)
    Navigation = 8,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point2d_Array = 1797,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    Point3d_Array = 2053,
    // (undocumented)
    String = 2305,
    // (undocumented)
    String_Array = 2309,
    // (undocumented)
    String_Enumeration = 2321,
    // (undocumented)
    String_Enumeration_Array = 2325,
    // (undocumented)
    Struct = 2,
    // (undocumented)
    Struct_Array = 6
}

// @beta (undocumented)
export function propertyTypeToString(type: PropertyType): "PrimitiveProperty" | "StructProperty" | "StructArrayProperty" | "NavigationProperty" | "PrimitiveArrayProperty";

// @beta (undocumented)
export namespace PropertyTypeUtils {
    // (undocumented)
    export function asArray(t: PropertyType): PropertyType;
    // (undocumented)
    export function fromPrimitiveType(t: PrimitiveType): PropertyType;
    // (undocumented)
    export function getPrimitiveType(t: PropertyType): PrimitiveType;
    // (undocumented)
    export function isArray(t: PropertyType): boolean;
    // (undocumented)
    export function isEnumeration(t: PropertyType): boolean;
    // (undocumented)
    export function isNavigation(t: PropertyType): boolean;
    // (undocumented)
    export function isPrimitive(t: PropertyType): boolean;
    // (undocumented)
    export function isStruct(t: PropertyType): boolean;
}

// @beta
export class RelationshipClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    deserialize(relationshipClassProps: RelationshipClassProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "RelationshipClassProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(relationshipClassProps: RelationshipClassProps): void;
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.RelationshipClass;
    // (undocumented)
    readonly source: RelationshipConstraint;
    // (undocumented)
    protected _source: RelationshipConstraint;
    // (undocumented)
    readonly strength: StrengthType;
    // (undocumented)
    protected _strength: StrengthType;
    // (undocumented)
    readonly strengthDirection: StrengthDirection;
    // (undocumented)
    protected _strengthDirection: StrengthDirection;
    // (undocumented)
    readonly target: RelationshipConstraint;
    // (undocumented)
    protected _target: RelationshipConstraint;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta
export class RelationshipConstraint implements CustomAttributeContainerProps {
    constructor(relClass: RelationshipClass, relEnd: RelationshipEnd, roleLabel?: string, polymorphic?: boolean);
    // (undocumented)
    abstractConstraint: LazyLoadedRelationshipConstraintClass | undefined;
    // (undocumented)
    protected _abstractConstraint?: LazyLoadedRelationshipConstraintClass;
    addClass(constraint: EntityClass | Mixin | RelationshipClass): void;
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    static classCompatibleWithConstraint(constraintClass: ECClass, testClass: ECClass, isPolymorphic: boolean): Promise<boolean>;
    // (undocumented)
    readonly constraintClasses: LazyLoadedRelationshipConstraintClass[] | undefined;
    // (undocumented)
    protected _constraintClasses?: LazyLoadedRelationshipConstraintClass[];
    // (undocumented)
    readonly customAttributes: CustomAttributeSet | undefined;
    // (undocumented)
    deserialize(relationshipConstraintProps: RelationshipConstraintProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "RelationshipConstraintProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(relationshipConstraintProps: RelationshipConstraintProps): void;
    readonly fullName: "Source" | "Target";
    readonly isSource: boolean;
    // (undocumented)
    readonly multiplicity: RelationshipMultiplicity | undefined;
    // (undocumented)
    protected _multiplicity?: RelationshipMultiplicity;
    // (undocumented)
    readonly polymorphic: boolean | undefined;
    // (undocumented)
    protected _polymorphic?: boolean;
    // (undocumented)
    readonly relationshipClass: RelationshipClass;
    // (undocumented)
    protected _relationshipClass: RelationshipClass;
    // (undocumented)
    readonly relationshipEnd: RelationshipEnd;
    // (undocumented)
    protected _relationshipEnd: RelationshipEnd;
    // (undocumented)
    readonly roleLabel: string | undefined;
    // (undocumented)
    protected _roleLabel?: string;
    readonly schema: Schema;
    supportsClass(ecClass: ECClass): Promise<boolean>;
    // (undocumented)
    toJson(): {
        [value: string]: any;
    };
}

// @beta
export abstract class RelationshipConstraintDiagnostic<ARGS extends any[]> extends BaseDiagnostic<RelationshipConstraint, ARGS> {
    constructor(constraint: RelationshipConstraint, messageArgs: ARGS);
    readonly diagnosticType: DiagnosticType;
    readonly schema: Schema;
}

// @beta
export const enum RelationshipEnd {
    // (undocumented)
    Source = 0,
    // (undocumented)
    Target = 1
}

// @beta (undocumented)
export function relationshipEndToString(end: RelationshipEnd): string;

// @beta (undocumented)
export class RelationshipMultiplicity {
    constructor(lowerLimit: number, upperLimit: number);
    // (undocumented)
    equals(rhs: RelationshipMultiplicity): boolean;
    // (undocumented)
    static fromString(str: string): RelationshipMultiplicity | undefined;
    // (undocumented)
    readonly lowerLimit: number;
    // (undocumented)
    static readonly oneMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly oneOne: RelationshipMultiplicity;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly upperLimit: number;
    // (undocumented)
    static readonly zeroMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly zeroOne: RelationshipMultiplicity;
}

// @beta (undocumented)
export class Schema implements CustomAttributeContainerProps {
    constructor(context: SchemaContext);
    constructor(context: SchemaContext, name: string, readVersion: number, writeVersion: number, minorVersion: number);
    constructor(context: SchemaContext, key: SchemaKey);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    protected addItem<T extends SchemaItem>(item: T): void;
    // (undocumented)
    protected addReference(refSchema: Schema): Promise<void>;
    // (undocumented)
    protected addReferenceSync(refSchema: Schema): void;
    // (undocumented)
    readonly alias: string | undefined;
    // (undocumented)
    protected _alias?: string;
    readonly context: SchemaContext;
    protected createConstant(name: string): Promise<Constant>;
    // (undocumented)
    protected createConstantSync(name: string): Constant;
    protected createCustomAttributeClass(name: string, modifier?: ECClassModifier): Promise<CustomAttributeClass>;
    // (undocumented)
    protected createCustomAttributeClassSync(name: string, modifier?: ECClassModifier): CustomAttributeClass;
    protected createEntityClass(name: string, modifier?: ECClassModifier): Promise<EntityClass>;
    // (undocumented)
    protected createEntityClassSync(name: string, modifier?: ECClassModifier): EntityClass;
    protected createEnumeration(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Promise<Enumeration>;
    // (undocumented)
    protected createEnumerationSync(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Enumeration;
    protected createFormat(name: string): Promise<Format>;
    // (undocumented)
    protected createFormatSync(name: string): Format;
    protected createInvertedUnit(name: string): Promise<InvertedUnit>;
    // (undocumented)
    protected createInvertedUnitSync(name: string): InvertedUnit;
    protected createKindOfQuantity(name: string): Promise<KindOfQuantity>;
    // (undocumented)
    protected createKindOfQuantitySync(name: string): KindOfQuantity;
    protected createMixinClass(name: string): Promise<Mixin>;
    // (undocumented)
    protected createMixinClassSync(name: string): Mixin;
    protected createPhenomenon(name: string): Promise<Phenomenon>;
    // (undocumented)
    protected createPhenomenonSync(name: string): Phenomenon;
    protected createPropertyCategory(name: string): Promise<PropertyCategory>;
    // (undocumented)
    protected createPropertyCategorySync(name: string): PropertyCategory;
    protected createRelationshipClass(name: string, modifier?: ECClassModifier): Promise<RelationshipClass>;
    // (undocumented)
    protected createRelationshipClassSync(name: string, modifier?: ECClassModifier): RelationshipClass;
    protected createStructClass(name: string, modifier?: ECClassModifier): Promise<StructClass>;
    // (undocumented)
    protected createStructClassSync(name: string, modifier?: ECClassModifier): StructClass;
    protected createUnit(name: string): Promise<Unit>;
    // (undocumented)
    protected createUnitSync(name: string): Unit;
    protected createUnitSystem(name: string): Promise<UnitSystem>;
    // (undocumented)
    protected createUnitSystemSync(name: string): UnitSystem;
    // (undocumented)
    readonly customAttributes: CustomAttributeSet | undefined;
    // (undocumented)
    readonly description: string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    deserialize(schemaProps: SchemaProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "SchemaProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(schemaProps: SchemaProps): void;
    // (undocumented)
    static fromJson(jsonObj: object | string, context: SchemaContext): Promise<Schema>;
    // (undocumented)
    static fromJsonSync(jsonObj: object | string, context: SchemaContext): Schema;
    readonly fullName: string;
    // (undocumented)
    getClasses(): IterableIterator<ECClass>;
    getItem<T extends SchemaItem>(name: string): Promise<T | undefined>;
    // (undocumented)
    getItems<T extends AnySchemaItem>(): IterableIterator<T>;
    getItemSync<T extends SchemaItem>(name: string): T | undefined;
    // (undocumented)
    getReference<T extends Schema>(refSchemaName: string): Promise<T | undefined>;
    // (undocumented)
    getReferenceSync<T extends Schema>(refSchemaName: string): T | undefined;
    getSchemaItemKey(fullName: string): SchemaItemKey;
    // (undocumented)
    readonly label: string | undefined;
    // (undocumented)
    protected _label?: string;
    lookupItem<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): Promise<T | undefined>;
    lookupItemSync<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): T | undefined;
    // (undocumented)
    readonly minorVersion: number;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly readVersion: number;
    // (undocumented)
    readonly references: Schema[];
    readonly schema: Schema;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    protected _schemaKey?: SchemaKey;
    // (undocumented)
    toJson(): {
        [value: string]: any;
    };
    // (undocumented)
    readonly writeVersion: number;
}

// @beta (undocumented)
export class SchemaCache implements ISchemaLocater {
    constructor();
    addSchema<T extends Schema>(schema: T): Promise<void>;
    addSchemaSync<T extends Schema>(schema: T): void;
    // (undocumented)
    readonly count: number;
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @beta
export class SchemaContext implements ISchemaLocater, ISchemaItemLocater {
    constructor();
    // (undocumented)
    addLocater(locater: ISchemaLocater): void;
    addSchema(schema: Schema): Promise<void>;
    addSchemaItem(schemaItem: SchemaItem): Promise<void>;
    addSchemaSync(schema: Schema): void;
    // (undocumented)
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
    // (undocumented)
    getSchemaItemSync<T extends SchemaItem>(schemaItemKey: SchemaItemKey): T | undefined;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @beta
export abstract class SchemaDiagnostic<ARGS extends any[]> extends BaseDiagnostic<Schema, ARGS> {
    constructor(schema: Schema, messageArgs: ARGS);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    readonly diagnosticType: DiagnosticType;
    readonly schema: Schema;
}

// @alpha
export abstract class SchemaFileLocater {
    constructor();
    addSchemaSearchPath(schemaPath: string): void;
    addSchemaSearchPaths(schemaPaths: string[]): void;
    // Warning: (ae-incompatible-release-tags) The symbol "compareSchemaKeyByVersion" is marked as @alpha, but its signature references "FileSchemaKey" which is marked as @internal
    compareSchemaKeyByVersion(lhs: FileSchemaKey, rhs: FileSchemaKey): number;
    // (undocumented)
    fileExists(filePath: string): Promise<boolean | undefined>;
    // Warning: (ae-incompatible-release-tags) The symbol "findEligibleSchemaKeys" is marked as @alpha, but its signature references "FileSchemaKey" which is marked as @internal
    protected findEligibleSchemaKeys(desiredKey: SchemaKey, matchType: SchemaMatchType, format: string): FileSchemaKey[];
    // (undocumented)
    abstract getSchema<T extends Schema>(key: SchemaKey, matchType: SchemaMatchType, context: SchemaContext): Promise<T | undefined>;
    // (undocumented)
    protected abstract getSchemaKey(data: string): SchemaKey;
    // (undocumented)
    readUtf8FileToString(filePath: string): Promise<string | undefined>;
    // (undocumented)
    searchPaths: string[];
}

// @internal
export class SchemaGraphUtil {
    static buildDependencyOrderedSchemaList(insertSchema: Schema, schemas?: Schema[]): Schema[];
    }

// @beta
export abstract class SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly description: string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    deserialize(schemaItemProps: SchemaItemProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "SchemaItemProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(schemaItemProps: SchemaItemProps): void;
    static equalByKey(thisSchemaItem: SchemaItem, thatSchemaItemOrKey?: SchemaItem | SchemaItemKey): boolean;
    // (undocumented)
    readonly fullName: string;
    // (undocumented)
    readonly key: SchemaItemKey;
    // (undocumented)
    protected _key: SchemaItemKey;
    // (undocumented)
    readonly label: string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    readonly name: string;
    static parseFullName(fullName: string): [string, string];
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
}

// @beta
export abstract class SchemaItemDiagnostic<TYPE extends SchemaItem, ARGS extends any[]> extends BaseDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: SchemaItem, messageArgs: ARGS);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    readonly diagnosticType: DiagnosticType;
    readonly schema: Schema;
}

// @beta
export class SchemaItemKey {
    constructor(name: string, schema: SchemaKey);
    // (undocumented)
    readonly fullName: string;
    matches(rhs: SchemaItemKey): boolean;
    // (undocumented)
    matchesFullName(rhs: string): boolean;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    protected _schemaKey: SchemaKey;
    // (undocumented)
    readonly schemaName: string;
}

// @beta (undocumented)
export const enum SchemaItemType {
    // (undocumented)
    Constant = 10,
    // (undocumented)
    CustomAttributeClass = 3,
    // (undocumented)
    EntityClass = 0,
    // (undocumented)
    Enumeration = 5,
    // (undocumented)
    Format = 13,
    // (undocumented)
    InvertedUnit = 9,
    // (undocumented)
    KindOfQuantity = 6,
    // (undocumented)
    Mixin = 1,
    // (undocumented)
    Phenomenon = 11,
    // (undocumented)
    PropertyCategory = 7,
    // (undocumented)
    RelationshipClass = 4,
    // (undocumented)
    StructClass = 2,
    // (undocumented)
    Unit = 8,
    // (undocumented)
    UnitSystem = 12
}

// @beta
export function schemaItemTypeToString(value: SchemaItemType): string;

// @alpha
export class SchemaJsonFileLocater extends SchemaFileLocater implements ISchemaLocater {
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context: SchemaContext): Promise<T | undefined>;
    protected getSchemaKey(data: string): SchemaKey;
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context: SchemaContext): T | undefined;
}

// @beta
export class SchemaKey {
    constructor(name: string, version: ECVersion);
    constructor(name: string, readVersion?: number, writeVersion?: number, minorVersion?: number);
    // (undocumented)
    compareByName(rhs: SchemaKey | string | undefined): boolean;
    compareByVersion(rhs: SchemaKey): number;
    // (undocumented)
    matches(rhs: SchemaKey, matchType?: SchemaMatchType): boolean;
    // (undocumented)
    readonly minorVersion: number;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    static parseString(fullName: string): SchemaKey;
    // (undocumented)
    readonly readVersion: number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    readonly version: ECVersion;
    // (undocumented)
    protected _version: ECVersion;
    // (undocumented)
    readonly writeVersion: number;
}

// @beta (undocumented)
export class SchemaMap extends Array<Schema> {
}

// @beta
export const enum SchemaMatchType {
    // (undocumented)
    Exact = 1,
    // (undocumented)
    Identical = 0,
    // (undocumented)
    Latest = 3,
    // (undocumented)
    LatestReadCompatible = 4,
    // (undocumented)
    LatestWriteCompatible = 2
}

// @beta
export class SchemaPartVisitorDelegate {
    constructor(visitor: ISchemaPartVisitor);
    visitSchema(schema: Schema, fullSchema?: boolean): Promise<void>;
    visitSchemaPart(schemaPart: AnyECType): Promise<void>;
    visitSchemaPartSync(schemaPart: AnyECType): void;
    visitSchemaSync(schema: Schema, fullSchema?: boolean): void;
}

// @beta
export class SchemaValidationVisitor implements ISchemaPartVisitor {
    // (undocumented)
    applyClassRules(ecClass: AnyClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyConstantRules(constant: Constant, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeContainerRules(container: CustomAttributeContainerProps, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeInstanceRules(container: CustomAttributeContainerProps, customAttribute: CustomAttribute, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeRules(customAttribute: CustomAttributeClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEntityRules(entityClass: EntityClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEnumerationRules(enumeration: Enumeration, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyFormatRules(format: Format, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyInvertedUnitRules(invertedUnit: InvertedUnit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyKindOfQuantityRules(kindOfQuantity: KindOfQuantity, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyMixinRules(mixin: Mixin, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPhenomenonRules(phenomenon: Phenomenon, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyCategoryRules(propertyCategory: PropertyCategory, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyRules(property: AnyProperty, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipConstraintRules(constraint: RelationshipConstraint, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipRules(relationship: RelationshipClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaItemRules(schemaItem: SchemaItem, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaRules(schema: Schema, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyStructRules(structClass: StructClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitRules(unit: Unit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitSystemRules(unitSystem: UnitSystem, ruleSet: IRuleSet): Promise<void>;
    readonly diagnosticReporters: IDiagnosticReporter[];
    registerReporter(...reporters: IDiagnosticReporter[]): void;
    registerRuleSet(ruleSet: IRuleSet): void;
    // Warning: (ae-forgotten-export) The symbol "RuleSetArray" needs to be exported by the entry point ecschema-metadata.d.ts
    readonly ruleSets: RuleSetArray;
    visitClass(ecClass: AnyClass): Promise<void>;
    visitConstant(constant: Constant): Promise<void>;
    visitCustomAttributeClass(customAttribute: CustomAttributeClass): Promise<void>;
    visitCustomAttributeContainer(container: CustomAttributeContainerProps): Promise<void>;
    visitEntityClass(entity: EntityClass): Promise<void>;
    visitEnumeration(enumeration: Enumeration): Promise<void>;
    visitFormat(format: Format): Promise<void>;
    visitFullSchema(schema: Schema): Promise<void>;
    visitInvertedUnit(invertedUnit: InvertedUnit): Promise<void>;
    visitKindOfQuantity(koq: KindOfQuantity): Promise<void>;
    visitMixin(mixin: Mixin): Promise<void>;
    visitPhenomenon(phenomenon: Phenomenon): Promise<void>;
    visitProperty(property: AnyProperty): Promise<void>;
    visitPropertyCategory(category: PropertyCategory): Promise<void>;
    visitRelationshipClass(relationship: RelationshipClass): Promise<void>;
    visitRelationshipConstraint(constraint: RelationshipConstraint): Promise<void>;
    visitSchemaItem(schemaItem: SchemaItem): Promise<void>;
    visitStructClass(struct: StructClass): Promise<void>;
    visitUnit(unit: Unit): Promise<void>;
    visitUnitSystem(unitSystem: UnitSystem): Promise<void>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
    }

// @internal
export class SchemaXmlFileLocater extends SchemaFileLocater implements ISchemaLocater {
    addSchemaReferences(schema: Schema, context?: SchemaContext): Promise<void>;
    addSchemaReferencesSync(schema: Schema, context?: SchemaContext): void;
    getSchema<T extends Schema>(key: SchemaKey, matchType: SchemaMatchType, context: SchemaContext): Promise<T | undefined>;
    getSchemaKey(data: string): SchemaKey;
    getSchemaReferenceKeys(schemaKey: FileSchemaKey): SchemaKey[];
    getSchemaSync<T extends Schema>(key: SchemaKey, matchType: SchemaMatchType, context: SchemaContext): T | undefined;
    loadSchema<T extends Schema>(schemaPath: string, context: SchemaContext): Promise<T | undefined>;
}

// @internal
export const enum ScientificType {
    // (undocumented)
    Normalized = 0,
    // (undocumented)
    ZeroNormalized = 1
}

// @internal
export function scientificTypeToString(scientificType: ScientificType): string;

// @internal
export const enum ShowSignOption {
    // (undocumented)
    NegativeParentheses = 3,
    // (undocumented)
    NoSign = 0,
    // (undocumented)
    OnlyNegative = 1,
    // (undocumented)
    SignAlways = 2
}

// @internal
export function showSignOptionToString(showSign: ShowSignOption): string;

// @beta (undocumented)
export const enum StrengthDirection {
    // (undocumented)
    Backward = 2,
    // (undocumented)
    Forward = 1
}

// @beta (undocumented)
export function strengthDirectionToString(direction: StrengthDirection): string;

// @beta (undocumented)
export function strengthToString(strength: StrengthType): string;

// @beta (undocumented)
export const enum StrengthType {
    // (undocumented)
    Embedding = 2,
    // (undocumented)
    Holding = 1,
    // (undocumented)
    Referencing = 0
}

// Warning: (ae-forgotten-export) The symbol "StructArrayProperty_base" needs to be exported by the entry point ecschema-metadata.d.ts
// 
// @beta (undocumented)
export class StructArrayProperty extends StructArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: StructClass);
}

// @beta
export class StructClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.StructClass;
}

// @beta (undocumented)
export class StructProperty extends Property {
    constructor(ecClass: ECClass, name: string, type: StructClass);
    // (undocumented)
    deserialize(structPropertyProps: StructPropertyProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "StructPropertyProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(structPropertyProps: StructPropertyProps): void;
    // (undocumented)
    readonly structClass: StructClass;
    // (undocumented)
    protected _structClass: StructClass;
    // (undocumented)
    toJson(): any;
}

// @beta
export abstract class SuppressionDiagnosticReporter implements IDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>);
    report(diagnostic: AnyDiagnostic): void;
    protected abstract reportInternal(diagnostic: AnyDiagnostic): void;
    readonly suppressions: Map<string, string[]> | undefined;
    }

// @beta
export class Unit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    readonly denominator: number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    deserialize(unitProps: UnitProps): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "UnitProps" needs to be exported by the entry point ecschema-metadata.d.ts
    // 
    // (undocumented)
    deserializeSync(unitProps: UnitProps): void;
    // (undocumented)
    readonly numerator: number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    protected _offset: number;
    // (undocumented)
    readonly phenomenon: LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Unit;
    // (undocumented)
    toJson(standalone: boolean, includeSchemaVersion: boolean): {
        [value: string]: any;
    };
    // (undocumented)
    readonly unitSystem: LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta (undocumented)
export class UnitSystem extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.UnitSystem;
}


// (No @packageDocumentation comment for this package)

```
