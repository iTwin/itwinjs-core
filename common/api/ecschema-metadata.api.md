## API Report File for "@itwin/ecschema-metadata"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BaseFormat } from '@itwin/core-quantity';
import { BentleyError } from '@itwin/core-bentley';
import { DecimalPrecision } from '@itwin/core-quantity';
import { FormatProps } from '@itwin/core-quantity';
import { FormatTraits } from '@itwin/core-quantity';
import { FormatType } from '@itwin/core-quantity';
import { FractionalPrecision } from '@itwin/core-quantity';
import { ScientificType } from '@itwin/core-quantity';
import { ShowSignOption } from '@itwin/core-quantity';
import { UnitConversionProps } from '@itwin/core-quantity';
import { UnitExtraData } from '@itwin/core-quantity';
import { UnitProps } from '@itwin/core-quantity';
import { UnitsProvider } from '@itwin/core-quantity';

// @beta (undocumented)
export type AnyArrayProperty = PrimitiveArrayProperty | EnumerationArrayProperty | StructArrayProperty;

// @beta (undocumented)
export type AnyClass = EntityClass | Mixin | StructClass | CustomAttributeClass | RelationshipClass;

// @beta (undocumented)
export type AnyClassProps = EntityClassProps | MixinProps | CustomAttributeClassProps | RelationshipClassProps;

// @beta (undocumented)
export type AnyECType = Schema | SchemaItem | AnyProperty | RelationshipConstraint | CustomAttributeContainerProps | CustomAttribute | OverrideFormat | AnyEnumerator;

// @beta (undocumented)
export type AnyEnumerationProperty = EnumerationProperty | EnumerationArrayProperty;

// @beta (undocumented)
export type AnyEnumerator = Enumerator_2<string | number>;

// @beta (undocumented)
export type AnyPrimitiveProperty = PrimitiveProperty | PrimitiveArrayProperty;

// @beta (undocumented)
export type AnyProperty = AnyPrimitiveProperty | AnyEnumerationProperty | AnyStructProperty | NavigationProperty;

// @beta (undocumented)
export type AnyPropertyProps = PrimitivePropertyProps | StructPropertyProps | PrimitiveArrayPropertyProps | StructArrayPropertyProps | NavigationPropertyProps;

// @beta (undocumented)
export type AnySchemaItem = AnyClass | Enumeration | KindOfQuantity | PropertyCategory | Unit | InvertedUnit | Constant | Phenomenon | UnitSystem | Format;

// @beta (undocumented)
export type AnySchemaItemProps = AnyClassProps | EnumerationProps | KindOfQuantityProps | PropertyCategoryProps | SchemaItemUnitProps | InvertedUnitProps | ConstantProps | PhenomenonProps | SchemaItemFormatProps | SchemaItemOverrideFormatProps;

// @beta (undocumented)
export type AnyStructProperty = StructProperty | StructArrayProperty;

// @beta (undocumented)
export abstract class ArrayProperty extends Property {
    // (undocumented)
    get maxOccurs(): number | undefined;
    // (undocumented)
    protected _maxOccurs?: number;
    // (undocumented)
    get minOccurs(): number;
    // (undocumented)
    protected _minOccurs: number;
    // @internal
    protected setMaxOccurs(maxOccurs: number): void;
    // @internal
    protected setMinOccurs(minOccurs: number): void;
}

// @beta (undocumented)
export interface ArrayPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly maxOccurs?: number;
    // (undocumented)
    readonly minOccurs?: number;
}

// @beta
export function classModifierToString(modifier: ECClassModifier): string;

// @beta (undocumented)
export interface ClassProps extends SchemaItemProps {
    // (undocumented)
    readonly baseClass?: string;
    // (undocumented)
    readonly modifier?: string;
    // (undocumented)
    readonly properties?: AnyPropertyProps[];
}

// @beta
export class Constant extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator?: number;
    // (undocumented)
    fromJSON(constantProps: ConstantProps): Promise<void>;
    // (undocumented)
    fromJSONSync(constantProps: ConstantProps): void;
    // (undocumented)
    get hasDenominator(): boolean;
    // (undocumented)
    get hasNumerator(): boolean;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator?: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Constant;
    // @alpha
    protected setDefinition(definition: string): void;
    // @alpha
    protected setDenominator(denominator: number): void;
    // @alpha
    protected setNumerator(numerator: number): void;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): ConstantProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface ConstantProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly phenomenon: string;
}

// @beta
export function containerTypeToString(type: CustomAttributeContainerType): string;

// @beta (undocumented)
export interface CustomAttribute {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    className: string;
}

// @beta
export class CustomAttributeClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    get appliesTo(): CustomAttributeContainerType;
    // (undocumented)
    protected _appliesTo?: CustomAttributeContainerType;
    // @deprecated (undocumented)
    get containerType(): CustomAttributeContainerType;
    // (undocumented)
    fromJSON(customAttributeProps: CustomAttributeClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(customAttributeProps: CustomAttributeClassProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.CustomAttributeClass;
    // @alpha
    protected setAppliesTo(containerType: CustomAttributeContainerType): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): CustomAttributeClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface CustomAttributeClassProps extends ClassProps {
    readonly appliesTo: string;
}

// @beta (undocumented)
export interface CustomAttributeContainerProps {
    // (undocumented)
    customAttributes?: CustomAttributeSet;
    // (undocumented)
    fullName: string;
    // (undocumented)
    schema: Schema;
}

// @beta
export enum CustomAttributeContainerType {
    // (undocumented)
    Any = 4095,
    // (undocumented)
    AnyClass = 30,
    // (undocumented)
    AnyProperty = 992,
    // (undocumented)
    AnyRelationshipConstraint = 3072,
    // (undocumented)
    CustomAttributeClass = 4,
    // (undocumented)
    EntityClass = 2,
    // (undocumented)
    NavigationProperty = 512,
    // (undocumented)
    PrimitiveArrayProperty = 128,
    // (undocumented)
    PrimitiveProperty = 32,
    // (undocumented)
    RelationshipClass = 16,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SourceRelationshipConstraint = 1024,
    // (undocumented)
    StructArrayProperty = 256,
    // (undocumented)
    StructClass = 8,
    // (undocumented)
    StructProperty = 64,
    // (undocumented)
    TargetRelationshipConstraint = 2048
}

// @beta
export class DelayedPromise<T> implements Promise<T> {
    // (undocumented)
    readonly [Symbol.toStringTag]: "Promise";
    constructor(startCallback: () => Promise<T>);
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | undefined | null): Promise<T>;
    start: () => Promise<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
}

// @beta (undocumented)
export const DelayedPromiseWithProps: DelayedPromiseWithPropsConstructor;

// @beta
export type DelayedPromiseWithProps<TProps, TPayload> = Readonly<TProps> & DelayedPromise<TPayload>;

// @beta (undocumented)
export interface DelayedPromiseWithPropsConstructor {
    new <TProps extends NoDelayedPromiseMethods, TPayload>(props: TProps, startCallback: () => Promise<TPayload>): Readonly<TProps> & DelayedPromise<TPayload>;
}

// @beta
export abstract class ECClass extends SchemaItem implements CustomAttributeContainerProps {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    protected addProperty<T extends Property>(prop: T): T;
    // (undocumented)
    get baseClass(): LazyLoadedECClass | undefined;
    set baseClass(baseClass: LazyLoadedECClass | undefined);
    // (undocumented)
    protected _baseClass?: LazyLoadedECClass;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    protected createPrimitiveArrayProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveArrayProperty>;
    // (undocumented)
    protected createPrimitiveArrayProperty(name: string, primitiveType: Enumeration): Promise<EnumerationArrayProperty>;
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: PrimitiveType): PrimitiveArrayProperty;
    // (undocumented)
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: Enumeration): EnumerationArrayProperty;
    protected createPrimitiveProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveProperty>;
    // (undocumented)
    protected createPrimitiveProperty(name: string, primitiveType: Enumeration): Promise<EnumerationProperty>;
    protected createPrimitivePropertySync(name: string, primitiveType: PrimitiveType): PrimitiveProperty;
    // (undocumented)
    protected createPrimitivePropertySync(name: string, primitiveType: Enumeration): EnumerationProperty;
    // (undocumented)
    protected createStructArrayProperty(name: string, structType: string | StructClass): Promise<StructArrayProperty>;
    // (undocumented)
    protected createStructArrayPropertySync(name: string, structType: string | StructClass): StructArrayProperty;
    // (undocumented)
    protected createStructProperty(name: string, structType: string | StructClass): Promise<StructProperty>;
    // (undocumented)
    protected createStructPropertySync(name: string, structType: string | StructClass): StructProperty;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // @alpha
    protected deleteProperty(name: string): Promise<void>;
    // @alpha
    protected deletePropertySync(name: string): void;
    // (undocumented)
    fromJSON(classProps: ClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(classProps: ClassProps): void;
    getAllBaseClasses(): AsyncIterableIterator<ECClass>;
    // (undocumented)
    getAllBaseClassesSync(): Iterable<AnyClass>;
    // (undocumented)
    getBaseClassSync(): ECClass | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    getInheritedProperty(name: string): Promise<Property | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    getProperties(resetCache?: boolean): Promise<Property[]>;
    getPropertiesSync(resetCache?: boolean): Property[];
    getProperty(name: string, includeInherited?: boolean): Promise<Property | undefined>;
    getPropertySync(name: string, includeInherited?: boolean): Property | undefined;
    is(targetClass: string, schemaName: string): Promise<boolean>;
    // (undocumented)
    is(targetClass: ECClass): Promise<boolean>;
    // @internal (undocumented)
    static isECClass(object: any): object is ECClass;
    isSync(targetClass: ECClass): boolean;
    // (undocumented)
    protected loadPrimitiveType(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): Promise<PrimitiveType | Enumeration>;
    // (undocumented)
    protected loadPrimitiveTypeSync(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): PrimitiveType | Enumeration;
    // (undocumented)
    protected loadStructType(structType: string | StructClass | undefined, schema: Schema): Promise<StructClass>;
    // (undocumented)
    protected loadStructTypeSync(structType: string | StructClass | undefined, schema: Schema): StructClass;
    // (undocumented)
    protected static mergeProperties(target: Property[], existingValues: Map<string, number>, propertiesToMerge: Property[], overwriteExisting: boolean): void;
    // (undocumented)
    get modifier(): ECClassModifier;
    // (undocumented)
    protected _modifier: ECClassModifier;
    // (undocumented)
    get properties(): IterableIterator<Property> | undefined;
    // (undocumented)
    protected _properties?: Map<string, Property>;
    // @alpha
    protected setModifier(modifier: ECClassModifier): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): ClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    traverseBaseClasses(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): Promise<boolean>;
    traverseBaseClassesSync(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): boolean;
}

// @beta (undocumented)
export enum ECClassModifier {
    // (undocumented)
    Abstract = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sealed = 2
}

// @public
export class ECName {
    constructor(name: string);
    decode(): string;
    static encode(input: string): ECName;
    get name(): string;
    static validate(name: string): boolean;
}

// @internal (undocumented)
export class ECObjectsError extends BentleyError {
    constructor(errorNumber: number, message?: string);
    // (undocumented)
    readonly errorNumber: number;
    // (undocumented)
    toDebugString(): string;
}

// @beta (undocumented)
export enum ECObjectsStatus {
    // (undocumented)
    ClassNotFound = 35074,
    // (undocumented)
    DifferentSchemaContexts = 35076,
    // (undocumented)
    DuplicateItem = 35053,
    // (undocumented)
    DuplicateProperty = 35054,
    // (undocumented)
    DuplicateSchema = 35055,
    // (undocumented)
    ECOBJECTS_ERROR_BASE = 35052,
    // (undocumented)
    ImmutableSchema = 35056,
    // (undocumented)
    InvalidContainerType = 35057,
    // (undocumented)
    InvalidECJson = 35058,
    // (undocumented)
    InvalidECName = 35059,
    // (undocumented)
    InvalidECVersion = 35060,
    // (undocumented)
    InvalidEnumValue = 35061,
    // (undocumented)
    InvalidModifier = 35062,
    // (undocumented)
    InvalidMultiplicity = 35063,
    // (undocumented)
    InvalidPrimitiveType = 35064,
    // (undocumented)
    InvalidRelationshipEnd = 35068,
    // (undocumented)
    InvalidSchemaAlias = 35078,
    // (undocumented)
    InvalidSchemaComparisonArgument = 35077,
    // (undocumented)
    InvalidSchemaItemType = 35065,
    // (undocumented)
    InvalidSchemaKey = 35079,
    // (undocumented)
    InvalidSchemaString = 35073,
    // (undocumented)
    InvalidSchemaXML = 35072,
    // (undocumented)
    InvalidStrength = 35066,
    // (undocumented)
    InvalidStrengthDirection = 35067,
    // (undocumented)
    InvalidType = 35069,
    // (undocumented)
    MissingSchemaUrl = 35070,
    // (undocumented)
    NewerECSpecVersion = 35081,
    // (undocumented)
    SchemaContextUndefined = 35075,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UnableToLoadSchema = 35080,
    // (undocumented)
    UnableToLocateSchema = 35071
}

// @internal
export interface ECSpecVersion {
    // (undocumented)
    readVersion: number;
    // (undocumented)
    writeVersion: number;
}

// @internal (undocumented)
export class ECStringConstants {
    // (undocumented)
    static readonly CONTAINERTYPE_ANY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_CUSTOMATTRIBUTECLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ENTITYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_NAVIGATIONPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_RELATIONSHIPCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SCHEMA: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SOURCERELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_TARGETRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_SOURCE: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_TARGET: string;
}

// @beta (undocumented)
export class ECVersion {
    constructor(read?: number, write?: number, minor?: number);
    compare(rhv: ECVersion): number;
    static fromString(versionString: string): ECVersion;
    // (undocumented)
    get minor(): number;
    // (undocumented)
    get read(): number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get write(): number;
}

// @beta
export class EntityClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addMixin(mixin: Mixin): void;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(entityClassProps: EntityClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(entityClassProps: EntityClassProps): void;
    getInheritedProperty(name: string): Promise<AnyProperty | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    // (undocumented)
    getMixinsSync(): Iterable<Mixin>;
    // (undocumented)
    get mixins(): LazyLoadedMixin[];
    // (undocumented)
    protected _mixins?: LazyLoadedMixin[];
    // (undocumented)
    readonly schemaItemType: SchemaItemType.EntityClass;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EntityClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EntityClassProps extends ClassProps {
    // (undocumented)
    readonly mixins?: string[];
}

// @beta
export class Enumeration extends SchemaItem {
    constructor(schema: Schema, name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String);
    protected addEnumerator(enumerator: AnyEnumerator): void;
    createEnumerator(name: string, value: string | number, label?: string, description?: string): AnyEnumerator;
    // (undocumented)
    get enumerators(): AnyEnumerator[];
    // (undocumented)
    protected _enumerators: AnyEnumerator[];
    // (undocumented)
    fromJSON(enumerationProps: EnumerationProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationProps: EnumerationProps): void;
    getEnumerator(value: string): Enumerator_2<string> | undefined;
    // (undocumented)
    getEnumerator(value: number): Enumerator_2<number> | undefined;
    getEnumeratorByName(name: string): AnyEnumerator | undefined;
    // (undocumented)
    get isInt(): boolean;
    // (undocumented)
    get isStrict(): boolean;
    // (undocumented)
    protected _isStrict: boolean;
    // (undocumented)
    get isString(): boolean;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Enumeration;
    // @alpha
    protected setIsStrict(isStrict: boolean): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EnumerationProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): PrimitiveType.Integer | PrimitiveType.String | undefined;
    // (undocumented)
    protected _type?: PrimitiveType.Integer | PrimitiveType.String;
}

// @beta (undocumented)
export class EnumerationArrayProperty extends EnumerationArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
}

// @beta (undocumented)
export class EnumerationProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
    // (undocumented)
    get enumeration(): LazyLoadedEnumeration | undefined;
    // (undocumented)
    protected _enumeration?: LazyLoadedEnumeration;
    // (undocumented)
    fromJSON(enumerationPropertyProps: EnumerationPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationPropertyProps: EnumerationPropertyProps): void;
    toJSON(): EnumerationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EnumerationPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export interface EnumerationProps extends SchemaItemProps {
    // (undocumented)
    readonly enumerators: EnumeratorProps[];
    // (undocumented)
    readonly isStrict: boolean;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
interface Enumerator_2<T> {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: T;
}
export { Enumerator_2 as Enumerator }

// @beta (undocumented)
export interface EnumeratorProps {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: string | number;
}

// @beta (undocumented)
export class Format extends SchemaItem {
    constructor(schema: Schema, name: string);
    protected addUnit(unit: Unit | InvertedUnit, label?: string): void;
    // (undocumented)
    protected _base: BaseFormat;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    fromJSON(formatProps: SchemaItemFormatProps): Promise<void>;
    // (undocumented)
    fromJSONSync(formatProps: SchemaItemFormatProps): void;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // (undocumented)
    get minWidth(): number | undefined;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Format;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // @alpha
    protected setDecimalSeparator(separator: string): void;
    // @alpha
    protected setFormatType(formatType: FormatType): void;
    // (undocumented)
    protected setPrecision(precision: number): void;
    // @alpha
    protected setRoundFactor(roundFactor: number): void;
    // @alpha
    protected setShowSignOption(signOption: ShowSignOption): void;
    // @alpha
    protected setStationSeparator(separator: string): void;
    // @alpha
    protected setThousandSeparator(separator: string): void;
    // @alpha
    protected setUomSeparator(separator: string): void;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    get thousandSeparator(): string;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): SchemaItemFormatProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    get units(): Array<[Unit | InvertedUnit, string | undefined]> | undefined;
    // (undocumented)
    protected _units?: Array<[Unit | InvertedUnit, string | undefined]>;
    // (undocumented)
    get uomSeparator(): string;
}

// @internal (undocumented)
export function getFormatProps(format: Format | OverrideFormat): FormatProps;

// @beta
export class InvertedUnit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(invertedUnitProps: InvertedUnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(invertedUnitProps: InvertedUnitProps): void;
    // (undocumented)
    get invertsUnit(): LazyLoadedUnit | undefined;
    // (undocumented)
    protected _invertsUnit?: LazyLoadedUnit;
    // @alpha (undocumented)
    static isInvertedUnit(object: any): object is InvertedUnit;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.InvertedUnit;
    // @alpha
    protected setInvertsUnit(invertsUnit: LazyLoadedUnit): void;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): InvertedUnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta (undocumented)
export interface InvertedUnitProps extends SchemaItemProps {
    // (undocumented)
    readonly invertsUnit: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta (undocumented)
export interface ISchemaItemLocater {
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
}

// @beta
export interface ISchemaLocater {
    getSchema<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType, context: SchemaContext): Promise<T | undefined>;
    getSchemaInfo(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType, context: SchemaContext): Promise<SchemaInfo | undefined>;
    getSchemaSync<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType, context: SchemaContext): T | undefined;
}

// @beta
export interface ISchemaPartVisitor {
    visitClass?: (ecClass: AnyClass) => Promise<void>;
    visitClassSync?: (ecClass: AnyClass) => void;
    visitConstant?: (constant: Constant) => Promise<void>;
    visitConstantSync?: (constant: Constant) => void;
    visitCustomAttributeClass?: (customAttributeClass: CustomAttributeClass) => Promise<void>;
    visitCustomAttributeClassSync?: (customAttributeClass: CustomAttributeClass) => void;
    visitCustomAttributeContainer?: (customAttributeContainer: CustomAttributeContainerProps) => Promise<void>;
    visitCustomAttributeContainerSync?: (customAttributeContainer: CustomAttributeContainerProps) => void;
    visitEmptySchema?: (schema: Schema) => Promise<void>;
    visitEmptySchemaSync?: (schema: Schema) => void;
    visitEntityClass?: (entityClass: EntityClass) => Promise<void>;
    visitEntityClassSync?: (entityClass: EntityClass) => void;
    visitEnumeration?: (enumeration: Enumeration) => Promise<void>;
    visitEnumerationSync?: (enumeration: Enumeration) => void;
    visitFormat?: (format: Format) => Promise<void>;
    visitFormatSync?: (format: Format) => void;
    visitFullSchema?: (schema: Schema) => Promise<void>;
    visitFullSchemaSync?: (schema: Schema) => void;
    visitInvertedUnit?: (invertedUnit: InvertedUnit) => Promise<void>;
    visitInvertedUnitSync?: (invertedUnit: InvertedUnit) => void;
    visitKindOfQuantity?: (koq: KindOfQuantity) => Promise<void>;
    visitKindOfQuantitySync?: (koq: KindOfQuantity) => void;
    visitMixin?: (mixin: Mixin) => Promise<void>;
    visitMixinSync?: (mixin: Mixin) => void;
    visitPhenomenon?: (phenomena: Phenomenon) => Promise<void>;
    visitPhenomenonSync?: (phenomena: Phenomenon) => void;
    visitProperty?: (property: AnyProperty) => Promise<void>;
    visitPropertyCategory?: (category: PropertyCategory) => Promise<void>;
    visitPropertyCategorySync?: (category: PropertyCategory) => void;
    visitPropertySync?: (property: AnyProperty) => void;
    visitRelationshipClass?: (relationshipClass: RelationshipClass) => Promise<void>;
    visitRelationshipClassSync?: (relationshipClass: RelationshipClass) => void;
    visitRelationshipConstraint?: (relationshipConstraint: RelationshipConstraint) => Promise<void>;
    visitRelationshipConstraintSync?: (relationshipConstraint: RelationshipConstraint) => void;
    visitSchemaItem?: (schemaItem: SchemaItem) => Promise<void>;
    visitSchemaItemSync?: (schemaItem: SchemaItem) => void;
    visitStructClass?: (structClass: StructClass) => Promise<void>;
    visitStructClassSync?: (structClass: StructClass) => void;
    visitUnit?: (unit: Unit) => Promise<void>;
    visitUnitSync?: (unit: Unit) => void;
    visitUnitSystem?: (unitSystem: UnitSystem) => Promise<void>;
    visitUnitSystemSync?: (unitSystem: UnitSystem) => void;
}

// @beta
export class KindOfQuantity extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    protected addPresentationFormat(format: Format | OverrideFormat, isDefault?: boolean): void;
    protected createFormatOverride(parent: Format, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): OverrideFormat;
    get defaultPresentationFormat(): Format | OverrideFormat | undefined;
    // (undocumented)
    fromJSON(kindOfQuantityProps: KindOfQuantityProps): Promise<void>;
    // (undocumented)
    fromJSONSync(kindOfQuantityProps: KindOfQuantityProps): void;
    // (undocumented)
    get persistenceUnit(): LazyLoadedUnit | LazyLoadedInvertedUnit | undefined;
    protected set persistenceUnit(value: LazyLoadedUnit | LazyLoadedInvertedUnit | undefined);
    // (undocumented)
    protected _persistenceUnit?: LazyLoadedUnit | LazyLoadedInvertedUnit;
    get presentationFormats(): Array<Format | OverrideFormat>;
    // (undocumented)
    protected _presentationFormats: Array<Format | OverrideFormat>;
    // (undocumented)
    get relativeError(): number;
    // (undocumented)
    protected _relativeError: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.KindOfQuantity;
    // @alpha
    protected setRelativeError(relativeError: number): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): KindOfQuantityProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface KindOfQuantityProps extends SchemaItemProps {
    // (undocumented)
    readonly persistenceUnit: string;
    // (undocumented)
    readonly presentationUnits?: string | string[];
    // (undocumented)
    readonly relativeError: number;
}

// @beta (undocumented)
export type LazyLoadedConstant = LazyLoadedSchemaItem<Constant>;

// @beta (undocumented)
export type LazyLoadedCustomAttributeClass = LazyLoadedSchemaItem<CustomAttributeClass>;

// @beta (undocumented)
export type LazyLoadedECClass = LazyLoadedSchemaItem<ECClass>;

// @beta (undocumented)
export type LazyLoadedEntityClass = LazyLoadedSchemaItem<EntityClass>;

// @beta (undocumented)
export type LazyLoadedEnumeration = LazyLoadedSchemaItem<Enumeration>;

// @beta (undocumented)
export type LazyLoadedFormat = LazyLoadedSchemaItem<Format>;

// @beta (undocumented)
export type LazyLoadedInvertedUnit = LazyLoadedSchemaItem<InvertedUnit>;

// @beta (undocumented)
export type LazyLoadedKindOfQuantity = LazyLoadedSchemaItem<KindOfQuantity>;

// @beta (undocumented)
export type LazyLoadedMixin = LazyLoadedSchemaItem<Mixin>;

// @beta (undocumented)
export type LazyLoadedPhenomenon = LazyLoadedSchemaItem<Phenomenon>;

// @beta (undocumented)
export type LazyLoadedPropertyCategory = LazyLoadedSchemaItem<PropertyCategory>;

// @beta (undocumented)
export type LazyLoadedRelationshipClass = LazyLoadedSchemaItem<RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedRelationshipConstraintClass = LazyLoadedSchemaItem<EntityClass | Mixin | RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedSchema = Readonly<SchemaKey> & DelayedPromise<Schema> & Promise<Schema>;

// @beta (undocumented)
export type LazyLoadedSchemaItem<T extends SchemaItem> = Readonly<SchemaItemKey> & DelayedPromise<T> & Promise<T>;

// @beta (undocumented)
export type LazyLoadedStructClass = LazyLoadedSchemaItem<StructClass>;

// @beta (undocumented)
export type LazyLoadedUnit = LazyLoadedSchemaItem<Unit>;

// @beta (undocumented)
export type LazyLoadedUnitSystem = LazyLoadedSchemaItem<UnitSystem>;

// @beta
export class Mixin extends ECClass {
    constructor(schema: Schema, name: string);
    // (undocumented)
    applicableTo(entityClass: EntityClass): Promise<boolean>;
    // (undocumented)
    get appliesTo(): LazyLoadedEntityClass | undefined;
    // (undocumented)
    protected _appliesTo?: LazyLoadedEntityClass;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(mixinProps: MixinProps): Promise<void>;
    // (undocumented)
    fromJSONSync(mixinProps: MixinProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Mixin;
    // @alpha
    protected setAppliesTo(appliesTo: LazyLoadedEntityClass): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): MixinProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface MixinProps extends ClassProps {
    // (undocumented)
    readonly appliesTo: string;
}

// @beta (undocumented)
export class NavigationProperty extends Property {
    constructor(ecClass: ECClass, name: string, relationship: LazyLoadedRelationshipClass, direction?: StrengthDirection);
    // (undocumented)
    get direction(): StrengthDirection;
    // (undocumented)
    protected _direction: StrengthDirection;
    // (undocumented)
    getRelationshipClassSync(): RelationshipClass | undefined;
    // (undocumented)
    get relationshipClass(): LazyLoadedRelationshipClass;
    // (undocumented)
    protected _relationshipClass: LazyLoadedRelationshipClass;
    toJSON(): NavigationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface NavigationPropertyProps extends PropertyProps {
    // (undocumented)
    readonly direction: string;
    // (undocumented)
    readonly relationshipName: string;
}

// @beta (undocumented)
export interface NoDelayedPromiseMethods {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    catch?: never;
    // (undocumented)
    start?: never;
    // (undocumented)
    then?: never;
}

// @beta
export class OverrideFormat {
    constructor(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>);
    static createOverrideFormatFullName(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>): string;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    get fullName(): string;
    // @alpha
    fullNameXml(koqSchema: Schema): string;
    getFormatProps(): SchemaItemOverrideFormatProps;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // @internal (undocumented)
    static isOverrideFormat(object: any): object is OverrideFormat;
    // (undocumented)
    get minWidth(): number | undefined;
    readonly name: string;
    readonly parent: Format;
    static parseFormatString(formatString: string): OverrideFormatProps;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    get units(): [Unit | InvertedUnit, string | undefined][] | undefined;
    // (undocumented)
    get uomSeparator(): string;
}

// @beta (undocumented)
export interface OverrideFormatProps {
    // (undocumented)
    name: string;
    // (undocumented)
    precision?: number;
    // (undocumented)
    unitAndLabels?: Array<[string, string | undefined]>;
}

// @beta
export function parseClassModifier(modifier: string): ECClassModifier | undefined;

// @beta
export function parseCustomAttributeContainerType(type: string): CustomAttributeContainerType | undefined;

// @beta
export function parsePrimitiveType(type: string): PrimitiveType | undefined;

// @beta (undocumented)
export function parseRelationshipEnd(end: string): RelationshipEnd | undefined;

// @beta
export function parseSchemaItemType(type: string): SchemaItemType | undefined;

// @beta
export function parseStrength(strength: string): StrengthType | undefined;

// @beta (undocumented)
export function parseStrengthDirection(direction: string): StrengthDirection | undefined;

// @beta (undocumented)
export class Phenomenon extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    fromJSON(phenomenonProps: PhenomenonProps): Promise<void>;
    // (undocumented)
    fromJSONSync(phenomenonProps: PhenomenonProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Phenomenon;
    // (undocumented)
    protected setDefinition(definition: string): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PhenomenonProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PhenomenonProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
}

// @beta (undocumented)
export class PrimitiveArrayProperty extends PrimitiveArrayProperty_base {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    toJSON(): PrimitiveArrayPropertyProps;
}

// @beta (undocumented)
export interface PrimitiveArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export abstract class PrimitiveOrEnumPropertyBase extends Property {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    get extendedTypeName(): string | undefined;
    // (undocumented)
    protected _extendedTypeName?: string;
    // (undocumented)
    fromJSON(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): void;
    // (undocumented)
    get maxLength(): number | undefined;
    // (undocumented)
    protected _maxLength?: number;
    // (undocumented)
    get maxValue(): number | undefined;
    // (undocumented)
    protected _maxValue?: number;
    // (undocumented)
    get minLength(): number | undefined;
    // (undocumented)
    protected _minLength?: number;
    // (undocumented)
    get minValue(): number | undefined;
    // (undocumented)
    protected _minValue?: number;
    // @internal
    protected setExtendedTypeName(extendedTypeName: string): void;
    // @internal
    protected setMaxLength(maxLength: number): void;
    // @internal
    protected setMaxValue(maxValue: number): void;
    // @internal
    protected setMinLength(minLength: number): void;
    // @internal
    protected setMinValue(minValue: number): void;
    toJSON(): PrimitiveOrEnumPropertyBaseProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitiveOrEnumPropertyBaseProps extends PropertyProps {
    // (undocumented)
    readonly extendedTypeName?: string;
    // (undocumented)
    readonly maxLength?: number;
    // (undocumented)
    readonly maxValue?: number;
    // (undocumented)
    readonly minLength?: number;
    // (undocumented)
    readonly minValue?: number;
}

// @beta (undocumented)
export class PrimitiveProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    // (undocumented)
    fromJSON(primitivePropertyProps: PrimitivePropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(primitivePropertyProps: PrimitivePropertyProps): void;
    // (undocumented)
    get primitiveType(): PrimitiveType;
    toJSON(): PrimitivePropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitivePropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export enum PrimitiveType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta (undocumented)
export function primitiveTypeToString(type: PrimitiveType): string;

// @beta
export abstract class Property implements CustomAttributeContainerProps {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    get category(): LazyLoadedPropertyCategory | undefined;
    // (undocumented)
    protected _category?: LazyLoadedPropertyCategory;
    // (undocumented)
    get class(): AnyClass;
    // (undocumented)
    protected _class: AnyClass;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    fromJSON(propertyProps: PropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyProps: PropertyProps): void;
    get fullName(): string;
    // (undocumented)
    getCategorySync(): PropertyCategory | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    // (undocumented)
    getKindOfQuantitySync(): KindOfQuantity | undefined;
    // (undocumented)
    isArray(): this is AnyArrayProperty;
    // (undocumented)
    isEnumeration(): this is AnyEnumerationProperty;
    // (undocumented)
    isNavigation(): this is NavigationProperty;
    // (undocumented)
    isPrimitive(): this is AnyPrimitiveProperty;
    // @internal (undocumented)
    static isProperty(object: any): object is AnyProperty;
    // (undocumented)
    get isReadOnly(): boolean;
    // (undocumented)
    protected _isReadOnly?: boolean;
    // (undocumented)
    isStruct(): this is AnyStructProperty;
    // (undocumented)
    get kindOfQuantity(): LazyLoadedKindOfQuantity | undefined;
    // (undocumented)
    protected _kindOfQuantity?: LazyLoadedKindOfQuantity;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    // (undocumented)
    protected _name: ECName;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority?: number;
    // (undocumented)
    get propertyType(): PropertyType;
    get schema(): Schema;
    // @internal
    protected setCategory(category: LazyLoadedPropertyCategory): void;
    // @internal
    protected setDescription(description: string): void;
    // @internal
    protected setIsReadOnly(isReadOnly: boolean): void;
    // @internal
    protected setKindOfQuantity(kindOfQuantity: LazyLoadedKindOfQuantity): void;
    // @internal
    protected setLabel(label: string): void;
    // (undocumented)
    protected setName(name: ECName): void;
    // @internal
    protected setPriority(priority: number): void;
    toJSON(): PropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    protected _type: PropertyType;
}

// @beta (undocumented)
export class PropertyCategory extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(propertyCategoryProps: PropertyCategoryProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyCategoryProps: PropertyCategoryProps): void;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.PropertyCategory;
    // @alpha
    protected setPriority(priority: number): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PropertyCategoryProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PropertyCategoryProps extends SchemaItemProps {
    // (undocumented)
    readonly priority: number;
}

// @beta (undocumented)
export interface PropertyProps {
    // (undocumented)
    readonly category?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly inherited?: boolean;
    // (undocumented)
    readonly isReadOnly?: boolean;
    // (undocumented)
    readonly kindOfQuantity?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly priority?: number;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
export enum PropertyType {
    // (undocumented)
    Binary = 257,// PropertyFlags.Struct
    // (undocumented)
    Binary_Array = 261,// PropertyFlags.Struct | PropertyFlags.Array
    // (undocumented)
    Boolean = 513,// PropertyFlags.Navigation
    // (undocumented)
    Boolean_Array = 517,// PrimitiveType.Binary
    // (undocumented)
    DateTime = 769,// PrimitiveType.Binary | PropertyFlags.Array
    // (undocumented)
    DateTime_Array = 773,// PrimitiveType.Boolean
    // (undocumented)
    Double = 1025,// PrimitiveType.Boolean | PropertyFlags.Array
    // (undocumented)
    Double_Array = 1029,// PrimitiveType.DateTime
    // (undocumented)
    IGeometry = 2561,// PrimitiveType.DateTime | PropertyFlags.Array
    // (undocumented)
    IGeometry_Array = 2565,// PrimitiveType.Double
    // (undocumented)
    Integer = 1281,// PrimitiveType.Double | PropertyFlags.Array
    // (undocumented)
    Integer_Array = 1285,// PrimitiveType.Integer
    // (undocumented)
    Integer_Enumeration = 1297,// PrimitiveType.Integer | PropertyFlags.Array
    // (undocumented)
    Integer_Enumeration_Array = 1301,// PrimitiveType.Integer | PropertyFlags.Enumeration
    // (undocumented)
    Long = 1537,// PrimitiveType.Integer | PropertyFlags.Enumeration | PropertyFlags.Array
    // (undocumented)
    Long_Array = 1541,// PrimitiveType.Long
    // (undocumented)
    Navigation = 8,// PrimitiveType.Long | PropertyFlags.Array
    // (undocumented)
    Point2d = 1793,// PrimitiveType.Point2d
    // (undocumented)
    Point2d_Array = 1797,// PrimitiveType.Point2d | PropertyFlags.Array
    // (undocumented)
    Point3d = 2049,// PrimitiveType.Point3d
    // (undocumented)
    Point3d_Array = 2053,// PrimitiveType.Point3d | PropertyFlags.Array
    // (undocumented)
    String = 2305,// PrimitiveType.String
    // (undocumented)
    String_Array = 2309,// PrimitiveType.String | PropertyFlags.Array
    // (undocumented)
    String_Enumeration = 2321,// PrimitiveType.String | PropertyFlags.Enumeration
    // (undocumented)
    String_Enumeration_Array = 2325,// PrimitiveType.String | PropertyFlags.Enumeration | PropertyFlags.Array
    // (undocumented)
    Struct = 2,// PrimitiveType.IGeometry
    // (undocumented)
    Struct_Array = 6
}

// @beta (undocumented)
export function propertyTypeToString(type: PropertyType): "PrimitiveProperty" | "StructProperty" | "StructArrayProperty" | "NavigationProperty" | "PrimitiveArrayProperty";

// @beta (undocumented)
export namespace PropertyTypeUtils {
    // (undocumented)
    export function asArray(t: PropertyType): PropertyType;
    // (undocumented)
    export function fromPrimitiveType(t: PrimitiveType): PropertyType;
    // (undocumented)
    export function getPrimitiveType(t: PropertyType): PrimitiveType;
    // (undocumented)
    export function isArray(t: PropertyType): boolean;
    // (undocumented)
    export function isEnumeration(t: PropertyType): boolean;
    // (undocumented)
    export function isNavigation(t: PropertyType): boolean;
    // (undocumented)
    export function isPrimitive(t: PropertyType): boolean;
    // (undocumented)
    export function isStruct(t: PropertyType): boolean;
}

// @beta
export class RelationshipClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(relationshipClassProps: RelationshipClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipClassProps: RelationshipClassProps): void;
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.RelationshipClass;
    // @alpha
    protected setSourceConstraint(source: RelationshipConstraint): void;
    // @alpha
    protected setStrength(strength: StrengthType): void;
    // @alpha
    protected setStrengthDirection(direction: StrengthDirection): void;
    // @alpha
    protected setTargetConstraint(target: RelationshipConstraint): void;
    // (undocumented)
    get source(): RelationshipConstraint;
    // (undocumented)
    protected _source: RelationshipConstraint;
    // (undocumented)
    get strength(): StrengthType;
    // (undocumented)
    protected _strength: StrengthType;
    // (undocumented)
    get strengthDirection(): StrengthDirection;
    // (undocumented)
    protected _strengthDirection: StrengthDirection;
    // (undocumented)
    get target(): RelationshipConstraint;
    // (undocumented)
    protected _target: RelationshipConstraint;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): RelationshipClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface RelationshipClassProps extends ClassProps {
    // (undocumented)
    readonly source: RelationshipConstraintProps;
    // (undocumented)
    readonly strength: string;
    // (undocumented)
    readonly strengthDirection: string;
    // (undocumented)
    readonly target: RelationshipConstraintProps;
}

// @beta
export class RelationshipConstraint implements CustomAttributeContainerProps {
    constructor(relClass: RelationshipClass, relEnd: RelationshipEnd, roleLabel?: string, polymorphic?: boolean);
    // (undocumented)
    get abstractConstraint(): LazyLoadedRelationshipConstraintClass | undefined;
    set abstractConstraint(abstractConstraint: LazyLoadedRelationshipConstraintClass | undefined);
    // (undocumented)
    protected _abstractConstraint?: LazyLoadedRelationshipConstraintClass;
    addClass(constraint: EntityClass | Mixin | RelationshipClass): void;
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    static classCompatibleWithConstraint(constraintClass: ECClass, testClass: ECClass, isPolymorphic: boolean): Promise<boolean>;
    // (undocumented)
    get constraintClasses(): LazyLoadedRelationshipConstraintClass[] | undefined;
    // (undocumented)
    protected _constraintClasses?: LazyLoadedRelationshipConstraintClass[];
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    fromJSON(relationshipConstraintProps: RelationshipConstraintProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipConstraintProps: RelationshipConstraintProps): void;
    get fullName(): string;
    // @internal (undocumented)
    static isRelationshipConstraint(object: any): object is RelationshipConstraint;
    get isSource(): boolean;
    // (undocumented)
    get multiplicity(): RelationshipMultiplicity;
    protected set multiplicity(multiplicity: RelationshipMultiplicity);
    // (undocumented)
    protected _multiplicity?: RelationshipMultiplicity;
    // (undocumented)
    get polymorphic(): boolean;
    protected set polymorphic(polymorphic: boolean);
    // (undocumented)
    protected _polymorphic?: boolean;
    // (undocumented)
    get relationshipClass(): RelationshipClass;
    // (undocumented)
    protected _relationshipClass: RelationshipClass;
    // (undocumented)
    get relationshipEnd(): RelationshipEnd;
    protected set relationshipEnd(relationshipEnd: RelationshipEnd);
    // (undocumented)
    protected _relationshipEnd: RelationshipEnd;
    protected removeClass(constraint: EntityClass | Mixin | RelationshipClass): void;
    // (undocumented)
    get roleLabel(): string | undefined;
    protected set roleLabel(roleLabel: string | undefined);
    // (undocumented)
    protected _roleLabel?: string;
    get schema(): Schema;
    supportsClass(ecClass: ECClass): Promise<boolean>;
    toJSON(): RelationshipConstraintProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface RelationshipConstraintProps {
    // (undocumented)
    readonly abstractConstraint?: string;
    // (undocumented)
    readonly constraintClasses: string[];
    // (undocumented)
    readonly multiplicity: string;
    // (undocumented)
    readonly polymorphic: boolean;
    // (undocumented)
    readonly roleLabel: string;
}

// @beta
export enum RelationshipEnd {
    // (undocumented)
    Source = 0,
    // (undocumented)
    Target = 1
}

// @beta (undocumented)
export function relationshipEndToString(end: RelationshipEnd): string;

// @beta (undocumented)
export class RelationshipMultiplicity {
    constructor(lowerLimit: number, upperLimit: number);
    // (undocumented)
    equals(rhs: RelationshipMultiplicity): boolean;
    // (undocumented)
    static fromString(str: string): RelationshipMultiplicity | undefined;
    // (undocumented)
    readonly lowerLimit: number;
    // (undocumented)
    static readonly oneMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly oneOne: RelationshipMultiplicity;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly upperLimit: number;
    // (undocumented)
    static readonly zeroMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly zeroOne: RelationshipMultiplicity;
}

// @beta (undocumented)
export class Schema implements CustomAttributeContainerProps {
    constructor(context: SchemaContext, name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number);
    constructor(context: SchemaContext, key: SchemaKey, alias: string);
    // @internal
    constructor(context: SchemaContext);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    protected addItem<T extends SchemaItem>(item: T): void;
    // (undocumented)
    protected addReference(refSchema: Schema): Promise<void>;
    // (undocumented)
    protected addReferenceSync(refSchema: Schema): void;
    // (undocumented)
    get alias(): string;
    // (undocumented)
    protected _alias?: string;
    get context(): SchemaContext;
    // @alpha (undocumented)
    protected createClass<T extends AnyClass>(type: (new (_schema: Schema, _name: string, _modifier?: ECClassModifier) => T), name: string, modifier?: ECClassModifier): T;
    protected createConstant(name: string): Promise<Constant>;
    // (undocumented)
    protected createConstantSync(name: string): Constant;
    protected createCustomAttributeClass(name: string, modifier?: ECClassModifier): Promise<CustomAttributeClass>;
    // (undocumented)
    protected createCustomAttributeClassSync(name: string, modifier?: ECClassModifier): CustomAttributeClass;
    protected createEntityClass(name: string, modifier?: ECClassModifier): Promise<EntityClass>;
    // (undocumented)
    protected createEntityClassSync(name: string, modifier?: ECClassModifier): EntityClass;
    protected createEnumeration(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Promise<Enumeration>;
    // (undocumented)
    protected createEnumerationSync(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Enumeration;
    protected createFormat(name: string): Promise<Format>;
    // (undocumented)
    protected createFormatSync(name: string): Format;
    protected createInvertedUnit(name: string): Promise<InvertedUnit>;
    // (undocumented)
    protected createInvertedUnitSync(name: string): InvertedUnit;
    // @alpha (undocumented)
    protected createItem<T extends AnySchemaItem>(type: (new (_schema: Schema, _name: string) => T), name: string): T;
    protected createKindOfQuantity(name: string): Promise<KindOfQuantity>;
    // (undocumented)
    protected createKindOfQuantitySync(name: string): KindOfQuantity;
    protected createMixinClass(name: string): Promise<Mixin>;
    // (undocumented)
    protected createMixinClassSync(name: string): Mixin;
    protected createPhenomenon(name: string): Promise<Phenomenon>;
    // (undocumented)
    protected createPhenomenonSync(name: string): Phenomenon;
    protected createPropertyCategory(name: string): Promise<PropertyCategory>;
    // (undocumented)
    protected createPropertyCategorySync(name: string): PropertyCategory;
    protected createRelationshipClass(name: string, modifier?: ECClassModifier): Promise<RelationshipClass>;
    // (undocumented)
    protected createRelationshipClassSync(name: string, modifier?: ECClassModifier): RelationshipClass;
    protected createStructClass(name: string, modifier?: ECClassModifier): Promise<StructClass>;
    // (undocumented)
    protected createStructClassSync(name: string, modifier?: ECClassModifier): StructClass;
    protected createUnit(name: string): Promise<Unit>;
    // (undocumented)
    protected createUnitSync(name: string): Unit;
    protected createUnitSystem(name: string): Promise<UnitSystem>;
    // (undocumented)
    protected createUnitSystemSync(name: string): UnitSystem;
    // (undocumented)
    static get currentECSpecMajorVersion(): number;
    // (undocumented)
    static get currentECSpecMinorVersion(): number;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // @alpha
    protected deleteClass(name: string): Promise<void>;
    // @alpha
    protected deleteClassSync(name: string): void;
    // @alpha
    protected deleteSchemaItem(name: string): Promise<void>;
    // @alpha
    protected deleteSchemaItemSync(name: string): void;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    fromJSON(schemaProps: SchemaProps): Promise<void>;
    // (undocumented)
    static fromJson(jsonObj: object | string, context: SchemaContext): Promise<Schema>;
    fromJSONSync(schemaProps: SchemaProps): void;
    static fromJsonSync(jsonObj: object | string, context: SchemaContext): Schema;
    get fullName(): string;
    // (undocumented)
    getClasses(): IterableIterator<ECClass>;
    getItem<T extends SchemaItem>(name: string): Promise<T | undefined>;
    // (undocumented)
    getItems<T extends AnySchemaItem>(): IterableIterator<T>;
    getItemSync<T extends SchemaItem>(name: string): T | undefined;
    // (undocumented)
    getReference<T extends Schema>(refSchemaName: string): Promise<T | undefined>;
    // (undocumented)
    getReferenceNameByAlias(alias: string): string | undefined;
    // (undocumented)
    getReferenceSync<T extends Schema>(refSchemaName: string): T | undefined;
    getSchemaItemKey(fullName: string): SchemaItemKey;
    // @internal (undocumented)
    static isSchema(object: any): object is Schema;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    lookupItem<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): Promise<T | undefined>;
    lookupItemSync<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): T | undefined;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get originalECSpecMajorVersion(): number | undefined;
    // (undocumented)
    get originalECSpecMinorVersion(): number | undefined;
    // (undocumented)
    get readVersion(): number;
    // (undocumented)
    readonly references: Schema[];
    get schema(): Schema;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey?: SchemaKey;
    // @alpha
    protected setAlias(alias: string): void;
    // @alpha
    protected setContext(context: SchemaContext): void;
    // @alpha
    protected setDescription(description: string): void;
    // @alpha
    protected setDisplayLabel(displayLabel: string): void;
    setVersion(readVersion?: number, writeVersion?: number, minorVersion?: number): void;
    static startLoadingFromJson(jsonObj: object | string, context: SchemaContext): Promise<SchemaInfo>;
    toJSON(): SchemaProps;
    toXml(schemaXml: Document): Promise<Document>;
    // (undocumented)
    get writeVersion(): number;
}

// @internal (undocumented)
export class SchemaCache implements ISchemaLocater {
    constructor();
    addSchema<T extends Schema>(schema: T): Promise<void>;
    addSchemaPromise(schemaInfo: SchemaInfo, schema: Schema, schemaPromise: Promise<Schema>): Promise<void>;
    addSchemaSync<T extends Schema>(schema: T): void;
    // (undocumented)
    get count(): number;
    getAllSchemas(): Schema[];
    getSchema<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): Promise<T | undefined>;
    getSchemaInfo(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): Promise<SchemaInfo | undefined>;
    getSchemaItems(): IterableIterator<SchemaItem>;
    getSchemaSync<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): T | undefined;
    schemaExists(schemaKey: Readonly<SchemaKey>): boolean;
}

// @beta
export class SchemaContext implements ISchemaItemLocater {
    constructor();
    // (undocumented)
    addLocater(locater: ISchemaLocater): void;
    addSchema(schema: Schema): Promise<void>;
    // @deprecated
    addSchemaItem(schemaItem: SchemaItem): Promise<void>;
    addSchemaPromise(schemaInfo: SchemaInfo, schema: Schema, schemaPromise: Promise<Schema>): Promise<void>;
    addSchemaSync(schema: Schema): void;
    // @internal
    getCachedSchema<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): Promise<T | undefined>;
    // @internal
    getCachedSchemaSync<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): T | undefined;
    getKnownSchemas(): Schema[];
    getSchema<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType?: SchemaMatchType): Promise<T | undefined>;
    getSchemaInfo(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType): Promise<SchemaInfo | undefined>;
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
    getSchemaItems(): IterableIterator<SchemaItem>;
    getSchemaItemSync<T extends SchemaItem>(schemaItemKey: SchemaItemKey): T | undefined;
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    schemaExists(schemaKey: Readonly<SchemaKey>): boolean;
}

// @internal
export class SchemaGraph {
    detectCycles(): ReferenceCycle[] | undefined;
    static generateGraph(schema: SchemaInfo, context: SchemaContext): Promise<SchemaGraph>;
    static generateGraphSync(schema: Schema): SchemaGraph;
    throwIfCycles(): void;
}

// @internal
export class SchemaGraphUtil {
    static buildDependencyOrderedSchemaList(insertSchema: Schema, schemas?: Schema[]): Schema[];
}

// @beta
export interface SchemaInfo {
    // (undocumented)
    references: WithSchemaKey[];
    // (undocumented)
    schemaKey: Readonly<SchemaKey>;
}

// @beta
export abstract class SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    static equalByKey(thisSchemaItem: SchemaItem, thatSchemaItemOrKey?: SchemaItem | SchemaItemKey): boolean;
    // (undocumented)
    fromJSON(schemaItemProps: SchemaItemProps): Promise<void>;
    // (undocumented)
    fromJSONSync(schemaItemProps: SchemaItemProps): void;
    // (undocumented)
    get fullName(): string;
    // @internal (undocumented)
    static isSchemaItem(object: any): object is SchemaItem;
    // (undocumented)
    get key(): SchemaItemKey;
    // (undocumented)
    protected _key: SchemaItemKey;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    static parseFullName(fullName: string): [string, string];
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // @alpha
    protected setDescription(description: string): void;
    // @alpha
    protected setDisplayLabel(displayLabel: string): void;
    // @alpha
    protected setName(name: string): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): SchemaItemProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export type SchemaItemFormatProps = SchemaItemProps & FormatProps;

// @beta
export class SchemaItemKey {
    constructor(name: string, schema: SchemaKey);
    get fullName(): string;
    matches(rhs: SchemaItemKey): boolean;
    // (undocumented)
    matchesFullName(name: string): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey: SchemaKey;
    // (undocumented)
    get schemaName(): string;
}

// @beta (undocumented)
export interface SchemaItemOverrideFormatProps extends SchemaItemFormatProps {
    // (undocumented)
    readonly parent: string;
}

// @beta (undocumented)
export interface SchemaItemProps {
    // (undocumented)
    readonly $schema?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name?: string;
    // (undocumented)
    readonly originalECSpecMajorVersion?: number;
    // (undocumented)
    readonly originalECSpecMinorVersion?: number;
    // (undocumented)
    readonly schema?: string;
    // (undocumented)
    readonly schemaItemType?: string;
    // (undocumented)
    readonly schemaVersion?: string;
}

// @beta
export enum SchemaItemType {
    // (undocumented)
    Constant = "Constant",
    // (undocumented)
    CustomAttributeClass = "CustomAttributeClass",
    // (undocumented)
    EntityClass = "EntityClass",
    // (undocumented)
    Enumeration = "Enumeration",
    // (undocumented)
    Format = "Format",
    // (undocumented)
    InvertedUnit = "InvertedUnit",
    // (undocumented)
    KindOfQuantity = "KindOfQuantity",
    // (undocumented)
    Mixin = "Mixin",
    // (undocumented)
    Phenomenon = "Phenomenon",
    // (undocumented)
    PropertyCategory = "PropertyCategory",
    // (undocumented)
    RelationshipClass = "RelationshipClass",
    // (undocumented)
    StructClass = "StructClass",
    // (undocumented)
    Unit = "Unit",
    // (undocumented)
    UnitSystem = "UnitSystem"
}

// @beta @deprecated
export function schemaItemTypeToString(value: SchemaItemType): string;

// @internal (undocumented)
export function schemaItemTypeToXmlString(value: SchemaItemType): string;

// @beta (undocumented)
export interface SchemaItemUnitProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly offset?: number;
    // (undocumented)
    readonly phenomenon: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta
export class SchemaJsonLocater implements ISchemaLocater {
    constructor(_getSchema: SchemaPropsGetter);
    getSchema<T extends Schema>(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType, context: SchemaContext): Promise<T | undefined>;
    getSchemaInfo(schemaKey: Readonly<SchemaKey>, matchType: SchemaMatchType, context: SchemaContext): Promise<SchemaInfo | undefined>;
    getSchemaSync<T extends Schema>(schemaKey: Readonly<SchemaKey>, _matchType: SchemaMatchType, context: SchemaContext): T | undefined;
}

// @beta
export class SchemaKey {
    constructor(name: string, version: ECVersion);
    constructor(name: string, readVersion?: number, writeVersion?: number, minorVersion?: number);
    compareByName(rhs: SchemaKey | string | undefined): boolean;
    compareByVersion(rhs: SchemaKey): number;
    static fromJSON(props: SchemaKeyProps): SchemaKey;
    // (undocumented)
    matches(rhs: Readonly<SchemaKey>, matchType?: SchemaMatchType): boolean;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static parseString(fullName: string): SchemaKey;
    // (undocumented)
    get readVersion(): number;
    toJSON(): SchemaKeyProps;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get version(): ECVersion;
    // (undocumented)
    protected _version: ECVersion;
    // (undocumented)
    get writeVersion(): number;
}

// @beta
export interface SchemaKeyProps {
    readonly minor: number;
    readonly name: string;
    readonly read: number;
    readonly write: number;
}

// @beta
export class SchemaLoader {
    constructor(getSchema: SchemaPropsGetter);
    get context(): SchemaContext;
    getSchema<T extends Schema>(schemaName: string): T;
    tryGetSchema<T extends Schema>(schemaName: string): T | undefined;
}

// @beta
export enum SchemaMatchType {
    // (undocumented)
    Exact = 1,
    // (undocumented)
    Identical = 0,
    // (undocumented)
    Latest = 3,
    // (undocumented)
    LatestReadCompatible = 4,
    // (undocumented)
    LatestWriteCompatible = 2
}

// @beta
export class SchemaPartVisitorDelegate {
    constructor(visitor: ISchemaPartVisitor);
    visitSchema(schema: Schema, fullSchema?: boolean): Promise<void>;
    visitSchemaPart(schemaPart: AnyECType): Promise<void>;
    visitSchemaPartSync(schemaPart: AnyECType): void;
    visitSchemaSync(schema: Schema, fullSchema?: boolean): void;
}

// @beta (undocumented)
export interface SchemaProps {
    // (undocumented)
    readonly $schema: string;
    // (undocumented)
    readonly alias: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly ecSpecMajorVersion?: number;
    // (undocumented)
    readonly ecSpecMinorVersion?: number;
    // (undocumented)
    readonly items?: {
        [name: string]: SchemaItemProps;
    };
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly references?: SchemaReferenceProps[];
    // (undocumented)
    readonly version: string;
}

// @beta
export type SchemaPropsGetter = (schemaName: string) => SchemaProps | undefined;

// @internal
export class SchemaReadHelper<T = unknown> {
    constructor(parserType: AbstractParserConstructor<T>, context?: SchemaContext, visitor?: ISchemaPartVisitor);
    // (undocumented)
    static isECSpecVersionNewer(ecSpecVersion?: ECSpecVersion): boolean;
    readSchema<U extends Schema>(schema: U, rawSchema: T): Promise<U>;
    readSchemaInfo<U extends Schema>(schema: U, rawSchema: T): Promise<SchemaInfo>;
    readSchemaSync<U extends Schema>(schema: U, rawSchema: T): U;
}

// @beta (undocumented)
export interface SchemaReferenceProps {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly version: string;
}

// @beta
export class SchemaUnitProvider implements UnitsProvider {
    constructor(contextOrLocater: ISchemaLocater, _unitExtraData?: UnitExtraData[]);
    findUnit(unitLabel: string, schemaName?: string, phenomenon?: string, unitSystem?: string): Promise<UnitProps>;
    findUnitByName(unitName: string): Promise<UnitProps>;
    getAlternateDisplayLabels(unitName: string): Array<string>;
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversionProps>;
    getUnitsByFamily(phenomenon: string): Promise<Array<UnitProps>>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
}

// @beta (undocumented)
export enum StrengthDirection {
    // (undocumented)
    Backward = 2,
    // (undocumented)
    Forward = 1
}

// @beta (undocumented)
export function strengthDirectionToString(direction: StrengthDirection): string;

// @beta (undocumented)
export function strengthToString(strength: StrengthType): string;

// @beta (undocumented)
export enum StrengthType {
    // (undocumented)
    Embedding = 2,
    // (undocumented)
    Holding = 1,
    // (undocumented)
    Referencing = 0
}

// @beta (undocumented)
export class StructArrayProperty extends StructArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: StructClass);
}

// @beta (undocumented)
export interface StructArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export class StructClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.StructClass;
}

// @beta (undocumented)
export type StructClassProps = ClassProps;

// @beta (undocumented)
export class StructProperty extends Property {
    constructor(ecClass: ECClass, name: string, type: StructClass);
    // (undocumented)
    fromJSON(structPropertyProps: StructPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(structPropertyProps: StructPropertyProps): void;
    // (undocumented)
    get structClass(): StructClass;
    // (undocumented)
    protected _structClass: StructClass;
    toJSON(): StructPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface StructPropertyProps extends PropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export class Unit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // @alpha
    static areCompatible(unitA: Unit, unitB: Unit): Promise<boolean>;
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator?: number;
    // (undocumented)
    fromJSON(unitProps: SchemaItemUnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(unitProps: SchemaItemUnitProps): void;
    // (undocumented)
    get hasDenominator(): boolean;
    // (undocumented)
    get hasNumerator(): boolean;
    // (undocumented)
    get hasOffset(): boolean;
    // @alpha (undocumented)
    static isUnit(object: any): object is Unit;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator?: number;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    protected _offset?: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Unit;
    // @alpha
    protected setDefinition(definition: string): Promise<void>;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): Promise<void>;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): SchemaItemUnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @internal
export class UnitConversion {
    constructor(factor?: number, offset?: number);
    compose(conversion: UnitConversion): UnitConversion;
    evaluate(x: number): number;
    // (undocumented)
    readonly factor: number;
    static from(unit: Unit | Constant): UnitConversion;
    // (undocumented)
    static identity: UnitConversion;
    inverse(): UnitConversion;
    multiply(conversion: UnitConversion): UnitConversion;
    // (undocumented)
    readonly offset: number;
    raise(power: number): UnitConversion;
}

// @internal
export class UnitConverter {
    constructor(_context: SchemaContext);
    calculateConversion(fromUnit: string, toUnit: string): Promise<UnitConversion>;
}

// @beta (undocumented)
export class UnitSystem extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.UnitSystem;
}

// @beta (undocumented)
export type UnitSystemProps = SchemaItemProps;

// @beta (undocumented)
export interface WithSchemaKey {
    // (undocumented)
    schemaKey: Readonly<SchemaKey>;
}

// @internal (undocumented)
export class XmlParser extends AbstractParser<Element> {
    constructor(rawSchema: Readonly<Document>);
    // (undocumented)
    findItem(itemName: string): [string, string, Element] | undefined;
    // (undocumented)
    getClassCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    get getECSpecVersion(): ECSpecVersion | undefined;
    // (undocumented)
    getItems(): Iterable<[string, string, Element]>;
    // (undocumented)
    getProperties(xmlElement: Element, itemName: string): Iterable<[string, string, Element]>;
    // (undocumented)
    getPropertyCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    getReferences(): Iterable<SchemaReferenceProps>;
    // (undocumented)
    getRelationshipConstraintCustomAttributeProviders(xmlElement: Element): [Iterable<CAProviderTuple>, Iterable<CAProviderTuple>];
    // (undocumented)
    getSchemaCustomAttributeProviders(): Iterable<CAProviderTuple>;
    // (undocumented)
    parseConstant(xmlElement: Element): ConstantProps;
    // (undocumented)
    parseCustomAttributeClass(xmlElement: Element): CustomAttributeClassProps;
    // (undocumented)
    parseEntityClass(xmlElement: Element): EntityClassProps;
    // (undocumented)
    parseEnumeration(xmlElement: Element): EnumerationProps;
    // (undocumented)
    parseFormat(xmlElement: Element): SchemaItemFormatProps;
    // (undocumented)
    parseInvertedUnit(xmlElement: Element): InvertedUnitProps;
    // (undocumented)
    parseKindOfQuantity(xmlElement: Element): KindOfQuantityProps;
    // (undocumented)
    parseMixin(xmlElement: Element): MixinProps;
    // (undocumented)
    parseNavigationProperty(xmlElement: Element): NavigationPropertyProps;
    // (undocumented)
    parsePhenomenon(xmlElement: Element): PhenomenonProps;
    // (undocumented)
    parsePrimitiveArrayProperty(xmlElement: Element): PrimitiveArrayPropertyProps;
    // (undocumented)
    parsePrimitiveProperty(xmlElement: Element): PrimitivePropertyProps;
    // (undocumented)
    parsePropertyCategory(xmlElement: Element): PropertyCategoryProps;
    // (undocumented)
    parseRelationshipClass(xmlElement: Element): RelationshipClassProps;
    // (undocumented)
    parseSchema(): SchemaProps;
    // (undocumented)
    parseStructArrayProperty(xmlElement: Element): StructArrayPropertyProps;
    // (undocumented)
    parseStructClass(xmlElement: Element): StructClassProps;
    // (undocumented)
    parseStructProperty(xmlElement: Element): StructPropertyProps;
    // (undocumented)
    parseUnit(xmlElement: Element): SchemaItemUnitProps;
    // (undocumented)
    parseUnitSystem(xmlElement: Element): UnitSystemProps;
    // (undocumented)
    static parseXmlNamespace(xmlNamespace: string): ECSpecVersion | undefined;
}

// (No @packageDocumentation comment for this package)

```
