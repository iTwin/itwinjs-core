## API Report File for "@itwin/ecschema-metadata"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BentleyError } from '@itwin/core-bentley';

// @beta (undocumented)
export type AnyArrayProperty = PrimitiveArrayProperty | EnumerationArrayProperty | StructArrayProperty;

// @beta (undocumented)
export type AnyClass = EntityClass | Mixin | StructClass | CustomAttributeClass | RelationshipClass;

// @beta (undocumented)
export type AnyClassProps = EntityClassProps | MixinProps | CustomAttributeClassProps | RelationshipClassProps;

// @beta (undocumented)
export type AnyECType = Schema | SchemaItem | AnyProperty | RelationshipConstraint | CustomAttributeContainerProps | CustomAttribute | OverrideFormat | AnyEnumerator;

// @beta (undocumented)
export type AnyEnumerationProperty = EnumerationProperty | EnumerationArrayProperty;

// @beta (undocumented)
export type AnyEnumerator = Enumerator<string | number>;

// @beta (undocumented)
export type AnyPrimitiveProperty = PrimitiveProperty | PrimitiveArrayProperty;

// @beta (undocumented)
export type AnyProperty = AnyPrimitiveProperty | AnyEnumerationProperty | AnyStructProperty | NavigationProperty;

// @beta (undocumented)
export type AnyPropertyProps = PrimitivePropertyProps | StructPropertyProps | PrimitiveArrayPropertyProps | StructArrayPropertyProps | NavigationPropertyProps;

// @beta (undocumented)
export type AnySchemaItem = AnyClass | Enumeration | KindOfQuantity | PropertyCategory | Unit | InvertedUnit | Constant | Phenomenon | UnitSystem | Format;

// @beta (undocumented)
export type AnySchemaItemProps = AnyClassProps | EnumerationProps | KindOfQuantityProps | PropertyCategoryProps | UnitProps | InvertedUnitProps | ConstantProps | PhenomenonProps | FormatProps;

// @beta (undocumented)
export type AnyStructProperty = StructProperty | StructArrayProperty;

// @beta (undocumented)
export abstract class ArrayProperty extends Property {
    // (undocumented)
    get maxOccurs(): number | undefined;
    // (undocumented)
    protected _maxOccurs?: number;
    // (undocumented)
    get minOccurs(): number;
    // (undocumented)
    protected _minOccurs: number;
}

// @beta (undocumented)
export interface ArrayPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly maxOccurs?: number;
    // (undocumented)
    readonly minOccurs?: number;
}

// @beta
export function classModifierToString(modifier: ECClassModifier): string;

// @beta (undocumented)
export interface ClassProps extends SchemaItemProps {
    // (undocumented)
    readonly baseClass?: string;
    // (undocumented)
    readonly modifier?: string;
    // (undocumented)
    readonly properties?: PropertyProps[];
}

// @beta
export class Constant extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    fromJSON(constantProps: ConstantProps): Promise<void>;
    // (undocumented)
    fromJSONSync(constantProps: ConstantProps): void;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Constant;
    // @alpha
    protected setDefinition(definition: string): void;
    // @alpha
    protected setDenominator(denominator: number): void;
    // @alpha
    protected setNumerator(numerator: number): void;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): void;
    toJSON(standalone: boolean, includeSchemaVersion: boolean): ConstantProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface ConstantProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly phenomenon: string;
}

// @beta
export function containerTypeToString(type: CustomAttributeContainerType): string;

// @beta (undocumented)
export interface CustomAttribute {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    className: string;
}

// @beta
export class CustomAttributeClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    get containerType(): CustomAttributeContainerType;
    // (undocumented)
    protected _containerType?: CustomAttributeContainerType;
    // (undocumented)
    fromJSON(customAttributeProps: CustomAttributeClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(customAttributeProps: CustomAttributeClassProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.CustomAttributeClass;
    // @alpha
    protected setContainerType(containerType: CustomAttributeContainerType): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): CustomAttributeClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface CustomAttributeClassProps extends ClassProps {
    // (undocumented)
    readonly appliesTo: string;
}

// @beta (undocumented)
export interface CustomAttributeContainerProps {
    // (undocumented)
    customAttributes?: CustomAttributeSet;
    // (undocumented)
    fullName: string;
    // (undocumented)
    schema: Schema;
}

// @beta
export enum CustomAttributeContainerType {
    // (undocumented)
    Any = 4095,
    // (undocumented)
    AnyClass = 30,
    // (undocumented)
    AnyProperty = 992,
    // (undocumented)
    AnyRelationshipConstraint = 3072,
    // (undocumented)
    CustomAttributeClass = 4,
    // (undocumented)
    EntityClass = 2,
    // (undocumented)
    NavigationProperty = 512,
    // (undocumented)
    PrimitiveArrayProperty = 128,
    // (undocumented)
    PrimitiveProperty = 32,
    // (undocumented)
    RelationshipClass = 16,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SourceRelationshipConstraint = 1024,
    // (undocumented)
    StructArrayProperty = 256,
    // (undocumented)
    StructClass = 8,
    // (undocumented)
    StructProperty = 64,
    // (undocumented)
    TargetRelationshipConstraint = 2048
}

// @beta
export enum DecimalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Eleven = 11,
    // (undocumented)
    Five = 5,
    // (undocumented)
    Four = 4,
    // (undocumented)
    Nine = 9,
    // (undocumented)
    One = 1,
    // (undocumented)
    Seven = 7,
    // (undocumented)
    Six = 6,
    // (undocumented)
    Ten = 10,
    // (undocumented)
    Three = 3,
    // (undocumented)
    Twelve = 12,
    // (undocumented)
    Two = 2,
    // (undocumented)
    Zero = 0
}

// @beta
export class DelayedPromise<T> implements Promise<T> {
    // (undocumented)
    readonly [Symbol.toStringTag]: "Promise";
    constructor(startCallback: () => Promise<T>);
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    finally(onFinally?: (() => void) | undefined | null): Promise<T>;
    start: () => Promise<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
}

// @beta (undocumented)
export const DelayedPromiseWithProps: DelayedPromiseWithPropsConstructor;

// @beta
export type DelayedPromiseWithProps<TProps, TPayload> = Readonly<TProps> & DelayedPromise<TPayload>;

// @beta (undocumented)
export interface DelayedPromiseWithPropsConstructor {
    new <TProps extends NoDelayedPromiseMethods, TPayload>(props: TProps, startCallback: () => Promise<TPayload>): Readonly<TProps> & DelayedPromise<TPayload>;
}

// @beta
export abstract class ECClass extends SchemaItem implements CustomAttributeContainerProps {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    protected addProperty<T extends Property>(prop: T): T;
    // (undocumented)
    get baseClass(): LazyLoadedECClass | undefined;
    set baseClass(baseClass: LazyLoadedECClass | undefined);
    // (undocumented)
    protected _baseClass?: LazyLoadedECClass;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    protected createPrimitiveArrayProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveArrayProperty>;
    // (undocumented)
    protected createPrimitiveArrayProperty(name: string, primitiveType: Enumeration): Promise<EnumerationArrayProperty>;
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: PrimitiveType): PrimitiveArrayProperty;
    // (undocumented)
    protected createPrimitiveArrayPropertySync(name: string, primitiveType: Enumeration): EnumerationArrayProperty;
    protected createPrimitiveProperty(name: string, primitiveType: PrimitiveType): Promise<PrimitiveProperty>;
    // (undocumented)
    protected createPrimitiveProperty(name: string, primitiveType: Enumeration): Promise<EnumerationProperty>;
    protected createPrimitivePropertySync(name: string, primitiveType: PrimitiveType): PrimitiveProperty;
    // (undocumented)
    protected createPrimitivePropertySync(name: string, primitiveType: Enumeration): EnumerationProperty;
    // (undocumented)
    protected createStructArrayProperty(name: string, structType: string | StructClass): Promise<StructArrayProperty>;
    // (undocumented)
    protected createStructArrayPropertySync(name: string, structType: string | StructClass): StructArrayProperty;
    // (undocumented)
    protected createStructProperty(name: string, structType: string | StructClass): Promise<StructProperty>;
    // (undocumented)
    protected createStructPropertySync(name: string, structType: string | StructClass): StructProperty;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // @alpha
    protected deleteProperty(name: string): Promise<void>;
    // @alpha
    protected deletePropertySync(name: string): void;
    // (undocumented)
    fromJSON(classProps: ClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(classProps: ClassProps): void;
    getAllBaseClasses(): AsyncIterableIterator<ECClass>;
    // (undocumented)
    getAllBaseClassesSync(): Iterable<AnyClass>;
    // (undocumented)
    getBaseClassSync(): ECClass | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    getInheritedProperty(name: string): Promise<Property | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    getProperties(resetCache?: boolean): Promise<Property[]>;
    getPropertiesSync(resetCache?: boolean): Property[];
    getProperty(name: string, includeInherited?: boolean): Promise<Property | undefined>;
    getPropertySync(name: string, includeInherited?: boolean): Property | undefined;
    is(targetClass: string, schemaName: string): Promise<boolean>;
    // (undocumented)
    is(targetClass: ECClass): Promise<boolean>;
    // @internal (undocumented)
    static isECClass(object: any): object is ECClass;
    isSync(targetClass: ECClass): boolean;
    // (undocumented)
    protected loadPrimitiveType(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): Promise<PrimitiveType | Enumeration>;
    // (undocumented)
    protected loadPrimitiveTypeSync(primitiveType: string | PrimitiveType | Enumeration | undefined, schema: Schema): PrimitiveType | Enumeration;
    // (undocumented)
    protected loadStructType(structType: string | StructClass | undefined, schema: Schema): Promise<StructClass>;
    // (undocumented)
    protected loadStructTypeSync(structType: string | StructClass | undefined, schema: Schema): StructClass;
    // (undocumented)
    protected static mergeProperties(target: Property[], existingValues: Map<string, number>, propertiesToMerge: Property[], overwriteExisting: boolean): void;
    // (undocumented)
    get modifier(): ECClassModifier;
    // (undocumented)
    protected _modifier: ECClassModifier;
    // (undocumented)
    get properties(): IterableIterator<Property> | undefined;
    // (undocumented)
    protected _properties?: Map<string, Property>;
    // @alpha
    protected setModifier(modifier: ECClassModifier): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): ClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    traverseBaseClasses(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): Promise<boolean>;
    traverseBaseClassesSync(callback: (ecClass: ECClass, arg?: any) => boolean, arg?: any): boolean;
}

// @beta (undocumented)
export enum ECClassModifier {
    // (undocumented)
    Abstract = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sealed = 2
}

// @public
export class ECName {
    constructor(name: string);
    decode(): string;
    static encode(input: string): ECName;
    get name(): string;
    static validate(name: string): boolean;
}

// @internal (undocumented)
export class ECObjectsError extends BentleyError {
    constructor(errorNumber: number, message?: string);
    // (undocumented)
    readonly errorNumber: number;
    // (undocumented)
    toDebugString(): string;
}

// @beta (undocumented)
export enum ECObjectsStatus {
    // (undocumented)
    ClassNotFound = 35074,
    // (undocumented)
    DifferentSchemaContexts = 35076,
    // (undocumented)
    DuplicateItem = 35053,
    // (undocumented)
    DuplicateProperty = 35054,
    // (undocumented)
    DuplicateSchema = 35055,
    // (undocumented)
    ECOBJECTS_ERROR_BASE = 35052,
    // (undocumented)
    ImmutableSchema = 35056,
    // (undocumented)
    InvalidContainerType = 35057,
    // (undocumented)
    InvalidECJson = 35058,
    // (undocumented)
    InvalidECName = 35059,
    // (undocumented)
    InvalidECVersion = 35060,
    // (undocumented)
    InvalidEnumValue = 35061,
    // (undocumented)
    InvalidModifier = 35062,
    // (undocumented)
    InvalidMultiplicity = 35063,
    // (undocumented)
    InvalidPrimitiveType = 35064,
    // (undocumented)
    InvalidRelationshipEnd = 35068,
    // (undocumented)
    InvalidSchemaAlias = 35078,
    // (undocumented)
    InvalidSchemaComparisonArgument = 35077,
    // (undocumented)
    InvalidSchemaItemType = 35065,
    // (undocumented)
    InvalidSchemaKey = 35079,
    // (undocumented)
    InvalidSchemaString = 35073,
    // (undocumented)
    InvalidSchemaXML = 35072,
    // (undocumented)
    InvalidStrength = 35066,
    // (undocumented)
    InvalidStrengthDirection = 35067,
    // (undocumented)
    InvalidType = 35069,
    // (undocumented)
    MissingSchemaUrl = 35070,
    // (undocumented)
    SchemaContextUndefined = 35075,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UnableToLocateSchema = 35071
}

// @internal (undocumented)
export class ECStringConstants {
    // (undocumented)
    static readonly CONTAINERTYPE_ANY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ANYRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_CUSTOMATTRIBUTECLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_ENTITYCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_NAVIGATIONPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_PRIMITIVEPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_RELATIONSHIPCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SCHEMA: string;
    // (undocumented)
    static readonly CONTAINERTYPE_SOURCERELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTARRAYPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTCLASS: string;
    // (undocumented)
    static readonly CONTAINERTYPE_STRUCTPROPERTY: string;
    // (undocumented)
    static readonly CONTAINERTYPE_TARGETRELATIONSHIPCONSTRAINT: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_SOURCE: string;
    // (undocumented)
    static readonly RELATIONSHIP_END_TARGET: string;
}

// @beta (undocumented)
export class ECVersion {
    constructor(read?: number, write?: number, minor?: number);
    compare(rhv: ECVersion): number;
    static fromString(versionString: string): ECVersion;
    // (undocumented)
    get minor(): number;
    // (undocumented)
    get read(): number;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get write(): number;
    }

// @beta
export class EntityClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected addMixin(mixin: Mixin): void;
    // (undocumented)
    protected buildPropertyCache(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): Promise<void>;
    // (undocumented)
    protected buildPropertyCacheSync(result: Property[], existingValues?: Map<string, number>, resetBaseCaches?: boolean): void;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(entityClassProps: EntityClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(entityClassProps: EntityClassProps): void;
    getInheritedProperty(name: string): Promise<AnyProperty | undefined>;
    getInheritedPropertySync(name: string): Property | undefined;
    // (undocumented)
    getMixinsSync(): Iterable<Mixin>;
    // (undocumented)
    get mixins(): LazyLoadedMixin[];
    // (undocumented)
    protected _mixins?: LazyLoadedMixin[];
    // (undocumented)
    readonly schemaItemType: SchemaItemType.EntityClass;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EntityClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EntityClassProps extends ClassProps {
    // (undocumented)
    readonly mixins?: string[];
}

// @beta
export class Enumeration extends SchemaItem {
    constructor(schema: Schema, name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String);
    protected addEnumerator(enumerator: AnyEnumerator): void;
    createEnumerator(name: string, value: string | number, label?: string, description?: string): AnyEnumerator;
    // (undocumented)
    get enumerators(): AnyEnumerator[];
    // (undocumented)
    protected _enumerators: AnyEnumerator[];
    // (undocumented)
    fromJSON(enumerationProps: EnumerationProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationProps: EnumerationProps): void;
    getEnumerator(value: string): Enumerator<string> | undefined;
    // (undocumented)
    getEnumerator(value: number): Enumerator<number> | undefined;
    getEnumeratorByName(name: string): AnyEnumerator | undefined;
    // (undocumented)
    get isInt(): boolean;
    // (undocumented)
    get isStrict(): boolean;
    // (undocumented)
    protected _isStrict: boolean;
    // (undocumented)
    get isString(): boolean;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Enumeration;
    // @alpha
    protected setIsStrict(isStrict: boolean): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): EnumerationProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): PrimitiveType.Integer | PrimitiveType.String | undefined;
    // (undocumented)
    protected _type?: PrimitiveType.Integer | PrimitiveType.String;
}

// @beta (undocumented)
export class EnumerationArrayProperty extends EnumerationArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
}

// @beta (undocumented)
export class EnumerationProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, type: LazyLoadedEnumeration);
    // (undocumented)
    get enumeration(): LazyLoadedEnumeration | undefined;
    // (undocumented)
    protected _enumeration?: LazyLoadedEnumeration;
    // (undocumented)
    fromJSON(enumerationPropertyProps: EnumerationPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(enumerationPropertyProps: EnumerationPropertyProps): void;
    toJSON(): EnumerationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface EnumerationPropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export interface EnumerationProps extends SchemaItemProps {
    // (undocumented)
    readonly enumerators: EnumeratorProps[];
    // (undocumented)
    readonly isStrict: boolean;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
export interface Enumerator<T> {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: T;
}

// @beta (undocumented)
export interface EnumeratorProps {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly value: string | number;
}

// @beta (undocumented)
export class Format extends SchemaItem {
    constructor(schema: Schema, name: string);
    protected addUnit(unit: Unit | InvertedUnit, label?: string): void;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    protected _decimalSeparator: string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    protected _formatTraits: FormatTraits;
    // (undocumented)
    fromJSON(formatProps: FormatProps): Promise<void>;
    // (undocumented)
    fromJSONSync(formatProps: FormatProps): void;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // (undocumented)
    protected _includeZero: boolean;
    // (undocumented)
    get minWidth(): number | undefined;
    // (undocumented)
    protected _minWidth?: number;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    protected _precision: number;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    protected _roundFactor: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Format;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    protected _scientificType?: ScientificType;
    // @alpha
    protected setDecimalSeparator(separator: string): void;
    // @alpha
    protected setFormatType(formatType: FormatType): void;
    // (undocumented)
    protected setPrecision(precision: number): void;
    // @alpha
    protected setRoundFactor(roundFactor: number): void;
    // @alpha
    protected setShowSignOption(signOption: ShowSignOption): void;
    // @alpha
    protected setStationSeparator(separator: string): void;
    // @alpha
    protected setThousandSeparator(separator: string): void;
    // @alpha
    protected setUomSeparator(separator: string): void;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    protected _showSignOption: ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    protected _spacer: string;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    protected _stationOffsetSize?: number;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    protected _stationSeparator: string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    protected _thousandSeparator: string;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): FormatProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    protected _type: FormatType;
    // (undocumented)
    get units(): Array<[Unit | InvertedUnit, string | undefined]> | undefined;
    // (undocumented)
    protected _units?: Array<[Unit | InvertedUnit, string | undefined]>;
    // (undocumented)
    get uomSeparator(): string;
    // (undocumented)
    protected _uomSeparator: string;
}

// @beta (undocumented)
export interface FormatProps extends SchemaItemProps {
    // (undocumented)
    readonly composite?: {
        readonly spacer?: string;
        readonly includeZero?: boolean;
        readonly units: Array<{
            readonly name: string;
            readonly label?: string;
        }>;
    };
    // (undocumented)
    readonly decimalSeparator?: string;
    // (undocumented)
    readonly formatTraits?: string | string[];
    // (undocumented)
    readonly minWidth?: number;
    // (undocumented)
    readonly precision?: number;
    // (undocumented)
    readonly roundFactor?: number;
    // (undocumented)
    readonly scientificType?: string;
    // (undocumented)
    readonly showSignOption?: string;
    // (undocumented)
    readonly stationOffsetSize?: number;
    // (undocumented)
    readonly stationSeparator?: string;
    // (undocumented)
    readonly thousandSeparator?: string;
    // (undocumented)
    readonly type: string;
    // (undocumented)
    readonly uomSeparator?: string;
}

// @internal
export const formatStringRgx: RegExp;

// @beta
export enum FormatTraits {
    // (undocumented)
    ApplyRounding = 16,
    // (undocumented)
    ExponentOnlyNegative = 512,
    // (undocumented)
    FractionDash = 32,
    // (undocumented)
    KeepDecimalPoint = 8,
    // (undocumented)
    KeepSingleZero = 2,
    // (undocumented)
    PrependUnitLabel = 128,
    // (undocumented)
    ShowUnitLabel = 64,
    // (undocumented)
    TrailZeroes = 1,
    // (undocumented)
    Use1000Separator = 256,
    // (undocumented)
    ZeroEmpty = 4
}

// @internal
export function formatTraitsToArray(currentFormatTrait: FormatTraits): string[];

// @beta
export enum FormatType {
    // (undocumented)
    Decimal = 0,
    // (undocumented)
    Fractional = 1,
    // (undocumented)
    Scientific = 2,
    // (undocumented)
    Station = 3
}

// @internal
export function formatTypeToString(type: FormatType): string;

// @beta
export enum FractionalPrecision {
    // (undocumented)
    Eight = 8,
    // (undocumented)
    Four = 4,
    // (undocumented)
    One = 1,
    // (undocumented)
    OneHundredTwentyEight = 128,
    // (undocumented)
    Sixteen = 16,
    // (undocumented)
    SixtyFour = 64,
    // (undocumented)
    ThirtyTwo = 32,
    // (undocumented)
    Two = 2,
    // (undocumented)
    TwoHundredFiftySix = 256
}

// @internal
export function getItemNamesFromFormatString(formatString: string): Iterable<string>;

// @beta
export class InvertedUnit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(invertedUnitProps: InvertedUnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(invertedUnitProps: InvertedUnitProps): void;
    // (undocumented)
    get invertsUnit(): LazyLoadedUnit | undefined;
    // (undocumented)
    protected _invertsUnit?: LazyLoadedUnit;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.InvertedUnit;
    // @alpha
    protected setInvertsUnit(invertsUnit: LazyLoadedUnit): void;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): InvertedUnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta (undocumented)
export interface InvertedUnitProps extends SchemaItemProps {
    // (undocumented)
    readonly invertsUnit: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta (undocumented)
export interface ISchemaItemLocater {
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
}

// @beta
export interface ISchemaLocater {
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): Promise<T | undefined>;
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType: SchemaMatchType, context?: SchemaContext): T | undefined;
}

// @beta
export interface ISchemaPartVisitor {
    visitClass?: (ecClass: AnyClass) => Promise<void>;
    visitClassSync?: (ecClass: AnyClass) => void;
    visitConstant?: (constant: Constant) => Promise<void>;
    visitConstantSync?: (constant: Constant) => void;
    visitCustomAttributeClass?: (customAttributeClass: CustomAttributeClass) => Promise<void>;
    visitCustomAttributeClassSync?: (customAttributeClass: CustomAttributeClass) => void;
    visitCustomAttributeContainer?: (customAttributeContainer: CustomAttributeContainerProps) => Promise<void>;
    visitCustomAttributeContainerSync?: (customAttributeContainer: CustomAttributeContainerProps) => void;
    visitEmptySchema?: (schema: Schema) => Promise<void>;
    visitEmptySchemaSync?: (schema: Schema) => void;
    visitEntityClass?: (entityClass: EntityClass) => Promise<void>;
    visitEntityClassSync?: (entityClass: EntityClass) => void;
    visitEnumeration?: (enumeration: Enumeration) => Promise<void>;
    visitEnumerationSync?: (enumeration: Enumeration) => void;
    visitFormat?: (format: Format) => Promise<void>;
    visitFormatSync?: (format: Format) => void;
    visitFullSchema?: (schema: Schema) => Promise<void>;
    visitFullSchemaSync?: (schema: Schema) => void;
    visitInvertedUnit?: (invertedUnit: InvertedUnit) => Promise<void>;
    visitInvertedUnitSync?: (invertedUnit: InvertedUnit) => void;
    visitKindOfQuantity?: (koq: KindOfQuantity) => Promise<void>;
    visitKindOfQuantitySync?: (koq: KindOfQuantity) => void;
    visitMixin?: (mixin: Mixin) => Promise<void>;
    visitMixinSync?: (mixin: Mixin) => void;
    visitPhenomenon?: (phenomena: Phenomenon) => Promise<void>;
    visitPhenomenonSync?: (phenomena: Phenomenon) => void;
    visitProperty?: (property: AnyProperty) => Promise<void>;
    visitPropertyCategory?: (category: PropertyCategory) => Promise<void>;
    visitPropertyCategorySync?: (category: PropertyCategory) => void;
    visitPropertySync?: (property: AnyProperty) => void;
    visitRelationshipClass?: (relationshipClass: RelationshipClass) => Promise<void>;
    visitRelationshipClassSync?: (relationshipClass: RelationshipClass) => void;
    visitRelationshipConstraint?: (relationshipConstraint: RelationshipConstraint) => Promise<void>;
    visitRelationshipConstraintSync?: (relationshipConstraint: RelationshipConstraint) => void;
    visitSchemaItem?: (schemaItem: SchemaItem) => Promise<void>;
    visitSchemaItemSync?: (schemaItem: SchemaItem) => void;
    visitStructClass?: (structClass: StructClass) => Promise<void>;
    visitStructClassSync?: (structClass: StructClass) => void;
    visitUnit?: (unit: Unit) => Promise<void>;
    visitUnitSync?: (unit: Unit) => void;
    visitUnitSystem?: (unitSystem: UnitSystem) => Promise<void>;
    visitUnitSystemSync?: (unitSystem: UnitSystem) => void;
}

// @beta
export class KindOfQuantity extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    protected addPresentationFormat(format: Format | OverrideFormat, isDefault?: boolean): void;
    protected createFormatOverride(parent: Format, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): OverrideFormat;
    get defaultPresentationFormat(): Format | OverrideFormat | undefined;
    // (undocumented)
    fromJSON(kindOfQuantityProps: KindOfQuantityProps): Promise<void>;
    // (undocumented)
    fromJSONSync(kindOfQuantityProps: KindOfQuantityProps): void;
    // (undocumented)
    get persistenceUnit(): LazyLoadedUnit | LazyLoadedInvertedUnit | undefined;
    // (undocumented)
    protected _persistenceUnit?: LazyLoadedUnit | LazyLoadedInvertedUnit;
    get presentationFormats(): Array<Format | OverrideFormat>;
    // (undocumented)
    protected _presentationFormats: Array<Format | OverrideFormat>;
    // (undocumented)
    get relativeError(): number;
    // (undocumented)
    protected _relativeError: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.KindOfQuantity;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): KindOfQuantityProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface KindOfQuantityProps extends SchemaItemProps {
    // (undocumented)
    readonly persistenceUnit: string;
    // (undocumented)
    readonly presentationUnits?: string | string[];
    // (undocumented)
    readonly relativeError: number;
}

// @beta (undocumented)
export type LazyLoadedConstant = LazyLoadedSchemaItem<Constant>;

// @beta (undocumented)
export type LazyLoadedCustomAttributeClass = LazyLoadedSchemaItem<CustomAttributeClass>;

// @beta (undocumented)
export type LazyLoadedECClass = LazyLoadedSchemaItem<ECClass>;

// @beta (undocumented)
export type LazyLoadedEntityClass = LazyLoadedSchemaItem<EntityClass>;

// @beta (undocumented)
export type LazyLoadedEnumeration = LazyLoadedSchemaItem<Enumeration>;

// @beta (undocumented)
export type LazyLoadedFormat = LazyLoadedSchemaItem<Format>;

// @beta (undocumented)
export type LazyLoadedInvertedUnit = LazyLoadedSchemaItem<InvertedUnit>;

// @beta (undocumented)
export type LazyLoadedKindOfQuantity = LazyLoadedSchemaItem<KindOfQuantity>;

// @beta (undocumented)
export type LazyLoadedMixin = LazyLoadedSchemaItem<Mixin>;

// @beta (undocumented)
export type LazyLoadedPhenomenon = LazyLoadedSchemaItem<Phenomenon>;

// @beta (undocumented)
export type LazyLoadedPropertyCategory = LazyLoadedSchemaItem<PropertyCategory>;

// @beta (undocumented)
export type LazyLoadedRelationshipClass = LazyLoadedSchemaItem<RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedRelationshipConstraintClass = LazyLoadedSchemaItem<EntityClass | Mixin | RelationshipClass>;

// @beta (undocumented)
export type LazyLoadedSchema = Readonly<SchemaKey> & DelayedPromise<Schema> & Promise<Schema>;

// @beta (undocumented)
export type LazyLoadedSchemaItem<T extends SchemaItem> = Readonly<SchemaItemKey> & DelayedPromise<T> & Promise<T>;

// @beta (undocumented)
export type LazyLoadedStructClass = LazyLoadedSchemaItem<StructClass>;

// @beta (undocumented)
export type LazyLoadedUnit = LazyLoadedSchemaItem<Unit>;

// @beta (undocumented)
export type LazyLoadedUnitSystem = LazyLoadedSchemaItem<UnitSystem>;

// @beta
export class Mixin extends ECClass {
    constructor(schema: Schema, name: string);
    // (undocumented)
    applicableTo(entityClass: EntityClass): Promise<boolean>;
    // (undocumented)
    get appliesTo(): LazyLoadedEntityClass | undefined;
    // (undocumented)
    protected _appliesTo?: LazyLoadedEntityClass;
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(mixinProps: MixinProps): Promise<void>;
    // (undocumented)
    fromJSONSync(mixinProps: MixinProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Mixin;
    // @alpha
    protected setAppliesTo(appliesTo: LazyLoadedEntityClass): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): MixinProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface MixinProps extends ClassProps {
    // (undocumented)
    readonly appliesTo: string;
}

// @beta (undocumented)
export class NavigationProperty extends Property {
    constructor(ecClass: ECClass, name: string, relationship: LazyLoadedRelationshipClass, direction?: StrengthDirection);
    // (undocumented)
    get direction(): StrengthDirection;
    // (undocumented)
    protected _direction: StrengthDirection;
    // (undocumented)
    getRelationshipClassSync(): RelationshipClass | undefined;
    // (undocumented)
    get relationshipClass(): LazyLoadedRelationshipClass;
    // (undocumented)
    protected _relationshipClass: LazyLoadedRelationshipClass;
    toJSON(): NavigationPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface NavigationPropertyProps extends PropertyProps {
    // (undocumented)
    readonly direction: string;
    // (undocumented)
    readonly relationshipName: string;
}

// @beta (undocumented)
export interface NoDelayedPromiseMethods {
    // (undocumented)
    [propName: string]: any;
    // (undocumented)
    catch?: never;
    // (undocumented)
    start?: never;
    // (undocumented)
    then?: never;
}

// @beta
export class OverrideFormat {
    constructor(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>);
    static createOverrideFormatFullName(parent: Format, precision?: DecimalPrecision | FractionalPrecision, unitAndLabels?: Array<[Unit | InvertedUnit, string | undefined]>): string;
    // (undocumented)
    get decimalSeparator(): string;
    // (undocumented)
    get formatTraits(): FormatTraits;
    // (undocumented)
    get fullName(): string;
    // @alpha
    fullNameXml(koqSchema: Schema): string;
    // (undocumented)
    hasFormatTrait(formatTrait: FormatTraits): boolean;
    // (undocumented)
    get includeZero(): boolean | undefined;
    // @internal (undocumented)
    static isOverrideFormat(object: any): object is OverrideFormat;
    // (undocumented)
    get minWidth(): number | undefined;
    readonly name: string;
    readonly parent: Format;
    // (undocumented)
    get precision(): DecimalPrecision | FractionalPrecision;
    // (undocumented)
    get roundFactor(): number;
    // (undocumented)
    get scientificType(): ScientificType | undefined;
    // (undocumented)
    get showSignOption(): ShowSignOption;
    // (undocumented)
    get spacer(): string | undefined;
    // (undocumented)
    get stationOffsetSize(): number | undefined;
    // (undocumented)
    get stationSeparator(): string;
    // (undocumented)
    get thousandSeparator(): string;
    // (undocumented)
    get type(): FormatType;
    // (undocumented)
    get units(): [Unit | InvertedUnit, string | undefined][] | undefined;
    // (undocumented)
    get uomSeparator(): string;
}

// @beta
export function parseClassModifier(modifier: string): ECClassModifier | undefined;

// @beta
export function parseCustomAttributeContainerType(type: string): CustomAttributeContainerType | undefined;

// @internal
export function parseDecimalPrecision(jsonObjPrecision: number): DecimalPrecision | undefined;

// @internal
export function parseFormatTrait(formatTraitsString: string): FormatTraits | undefined;

// @internal
export function parseFormatType(jsonObjType: string): FormatType | undefined;

// @internal
export function parseFractionalPrecision(jsonObjPrecision: number): FractionalPrecision | undefined;

// @internal
export function parsePrecision(precision: number, type: FormatType): DecimalPrecision | FractionalPrecision | undefined;

// @beta
export function parsePrimitiveType(type: string): PrimitiveType | undefined;

// @beta (undocumented)
export function parseRelationshipEnd(end: string): RelationshipEnd | undefined;

// @beta
export function parseSchemaItemType(type: string): SchemaItemType | undefined;

// @internal
export function parseScientificType(scientificType: string): ScientificType | undefined;

// @internal
export function parseShowSignOption(showSignOption: string): ShowSignOption | undefined;

// @beta
export function parseStrength(strength: string): StrengthType | undefined;

// @beta (undocumented)
export function parseStrengthDirection(direction: string): StrengthDirection | undefined;

// @beta (undocumented)
export class Phenomenon extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    fromJSON(phenomenonProps: PhenomenonProps): Promise<void>;
    // (undocumented)
    fromJSONSync(phenomenonProps: PhenomenonProps): void;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Phenomenon;
    // (undocumented)
    protected setDefinition(definition: string): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PhenomenonProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PhenomenonProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
}

// @beta (undocumented)
export class PrimitiveArrayProperty extends PrimitiveArrayProperty_base {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    toJSON(): PrimitiveArrayPropertyProps;
}

// @beta (undocumented)
export interface PrimitiveArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta (undocumented)
export abstract class PrimitiveOrEnumPropertyBase extends Property {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    get extendedTypeName(): string | undefined;
    // (undocumented)
    protected _extendedTypeName?: string;
    // (undocumented)
    fromJSON(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyBaseProps: PrimitiveOrEnumPropertyBaseProps): void;
    // (undocumented)
    get maxLength(): number | undefined;
    // (undocumented)
    protected _maxLength?: number;
    // (undocumented)
    get maxValue(): number | undefined;
    // (undocumented)
    protected _maxValue?: number;
    // (undocumented)
    get minLength(): number | undefined;
    // (undocumented)
    protected _minLength?: number;
    // (undocumented)
    get minValue(): number | undefined;
    // (undocumented)
    protected _minValue?: number;
    toJSON(): PrimitiveOrEnumPropertyBaseProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitiveOrEnumPropertyBaseProps extends PropertyProps {
    // (undocumented)
    readonly extendedTypeName?: string;
    // (undocumented)
    readonly maxLength?: number;
    // (undocumented)
    readonly maxValue?: number;
    // (undocumented)
    readonly minLength?: number;
    // (undocumented)
    readonly minValue?: number;
}

// @beta (undocumented)
export class PrimitiveProperty extends PrimitiveOrEnumPropertyBase {
    constructor(ecClass: ECClass, name: string, primitiveType?: PrimitiveType);
    // (undocumented)
    fromJSON(primitivePropertyProps: PrimitivePropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(primitivePropertyProps: PrimitivePropertyProps): void;
    // (undocumented)
    get primitiveType(): PrimitiveType;
    toJSON(): PrimitivePropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PrimitivePropertyProps extends PrimitiveOrEnumPropertyBaseProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export enum PrimitiveType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @beta (undocumented)
export function primitiveTypeToString(type: PrimitiveType): string;

// @beta
export abstract class Property implements CustomAttributeContainerProps {
    constructor(ecClass: ECClass, name: string, type: PropertyType);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    get category(): LazyLoadedPropertyCategory | undefined;
    // (undocumented)
    protected _category?: LazyLoadedPropertyCategory;
    // (undocumented)
    get class(): AnyClass;
    // (undocumented)
    protected _class: AnyClass;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    fromJSON(propertyProps: PropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyProps: PropertyProps): void;
    get fullName(): string;
    // (undocumented)
    getCategorySync(): PropertyCategory | undefined;
    getCustomAttributes(): Promise<CustomAttributeSet>;
    getCustomAttributesSync(): CustomAttributeSet;
    // (undocumented)
    getKindOfQuantitySync(): KindOfQuantity | undefined;
    // (undocumented)
    isArray(): this is AnyArrayProperty;
    // (undocumented)
    isEnumeration(): this is AnyEnumerationProperty;
    // (undocumented)
    isNavigation(): this is NavigationProperty;
    // (undocumented)
    isPrimitive(): this is AnyPrimitiveProperty;
    // @internal (undocumented)
    static isProperty(object: any): object is Property;
    // (undocumented)
    get isReadOnly(): boolean;
    // (undocumented)
    protected _isReadOnly?: boolean;
    // (undocumented)
    isStruct(): this is AnyStructProperty;
    // (undocumented)
    get kindOfQuantity(): LazyLoadedKindOfQuantity | undefined;
    // (undocumented)
    protected _kindOfQuantity?: LazyLoadedKindOfQuantity;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    // (undocumented)
    protected _name: ECName;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority?: number;
    // (undocumented)
    get propertyType(): PropertyType;
    get schema(): Schema;
    toJSON(): PropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    protected _type: PropertyType;
}

// @beta (undocumented)
export class PropertyCategory extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    fromJSON(propertyCategoryProps: PropertyCategoryProps): Promise<void>;
    // (undocumented)
    fromJSONSync(propertyCategoryProps: PropertyCategoryProps): void;
    // (undocumented)
    get priority(): number;
    // (undocumented)
    protected _priority: number;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.PropertyCategory;
    // @alpha
    protected setPriority(priority: number): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): PropertyCategoryProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface PropertyCategoryProps extends SchemaItemProps {
    // (undocumented)
    readonly priority: number;
}

// @beta (undocumented)
export interface PropertyProps {
    // (undocumented)
    readonly category?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly inherited?: boolean;
    // (undocumented)
    readonly isReadOnly?: boolean;
    // (undocumented)
    readonly kindOfQuantity?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly priority?: number;
    // (undocumented)
    readonly type: string;
}

// @beta (undocumented)
export enum PropertyType {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Binary_Array = 261,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    Boolean_Array = 517,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    DateTime_Array = 773,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Double_Array = 1029,
    // (undocumented)
    IGeometry = 2561,
    // (undocumented)
    IGeometry_Array = 2565,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Integer_Array = 1285,
    // (undocumented)
    Integer_Enumeration = 1297,
    // (undocumented)
    Integer_Enumeration_Array = 1301,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Long_Array = 1541,
    // (undocumented)
    Navigation = 8,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point2d_Array = 1797,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    Point3d_Array = 2053,
    // (undocumented)
    String = 2305,
    // (undocumented)
    String_Array = 2309,
    // (undocumented)
    String_Enumeration = 2321,
    // (undocumented)
    String_Enumeration_Array = 2325,
    // (undocumented)
    Struct = 2,
    // (undocumented)
    Struct_Array = 6
}

// @beta (undocumented)
export function propertyTypeToString(type: PropertyType): "PrimitiveProperty" | "StructProperty" | "StructArrayProperty" | "NavigationProperty" | "PrimitiveArrayProperty";

// @beta (undocumented)
export namespace PropertyTypeUtils {
    // (undocumented)
    export function asArray(t: PropertyType): PropertyType;
    // (undocumented)
    export function fromPrimitiveType(t: PrimitiveType): PropertyType;
    // (undocumented)
    export function getPrimitiveType(t: PropertyType): PrimitiveType;
    // (undocumented)
    export function isArray(t: PropertyType): boolean;
    // (undocumented)
    export function isEnumeration(t: PropertyType): boolean;
    // (undocumented)
    export function isNavigation(t: PropertyType): boolean;
    // (undocumented)
    export function isPrimitive(t: PropertyType): boolean;
    // (undocumented)
    export function isStruct(t: PropertyType): boolean;
}

// @beta
export class RelationshipClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    protected createNavigationProperty(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<NavigationProperty>;
    // (undocumented)
    protected createNavigationPropertySync(name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): NavigationProperty;
    // (undocumented)
    fromJSON(relationshipClassProps: RelationshipClassProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipClassProps: RelationshipClassProps): void;
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.RelationshipClass;
    // @alpha
    protected setStrength(strength: StrengthType): void;
    // @alpha
    protected setStrengthDirection(direction: StrengthDirection): void;
    // (undocumented)
    get source(): RelationshipConstraint;
    // (undocumented)
    protected _source: RelationshipConstraint;
    // (undocumented)
    get strength(): StrengthType;
    // (undocumented)
    protected _strength: StrengthType;
    // (undocumented)
    get strengthDirection(): StrengthDirection;
    // (undocumented)
    protected _strengthDirection: StrengthDirection;
    // (undocumented)
    get target(): RelationshipConstraint;
    // (undocumented)
    protected _target: RelationshipConstraint;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): RelationshipClassProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface RelationshipClassProps extends ClassProps {
    // (undocumented)
    readonly source: RelationshipConstraintProps;
    // (undocumented)
    readonly strength: string;
    // (undocumented)
    readonly strengthDirection: string;
    // (undocumented)
    readonly target: RelationshipConstraintProps;
}

// @beta
export class RelationshipConstraint implements CustomAttributeContainerProps {
    constructor(relClass: RelationshipClass, relEnd: RelationshipEnd, roleLabel?: string, polymorphic?: boolean);
    // (undocumented)
    get abstractConstraint(): LazyLoadedRelationshipConstraintClass | undefined;
    set abstractConstraint(abstractConstraint: LazyLoadedRelationshipConstraintClass | undefined);
    // (undocumented)
    protected _abstractConstraint?: LazyLoadedRelationshipConstraintClass;
    addClass(constraint: EntityClass | Mixin | RelationshipClass): void;
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    static classCompatibleWithConstraint(constraintClass: ECClass, testClass: ECClass, isPolymorphic: boolean): Promise<boolean>;
    // (undocumented)
    get constraintClasses(): LazyLoadedRelationshipConstraintClass[] | undefined;
    // (undocumented)
    protected _constraintClasses?: LazyLoadedRelationshipConstraintClass[];
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // (undocumented)
    fromJSON(relationshipConstraintProps: RelationshipConstraintProps): Promise<void>;
    // (undocumented)
    fromJSONSync(relationshipConstraintProps: RelationshipConstraintProps): void;
    get fullName(): string;
    // @internal (undocumented)
    static isRelationshipConstraint(object: any): object is RelationshipConstraint;
    get isSource(): boolean;
    // (undocumented)
    get multiplicity(): RelationshipMultiplicity | undefined;
    // (undocumented)
    protected _multiplicity?: RelationshipMultiplicity;
    // (undocumented)
    get polymorphic(): boolean | undefined;
    // (undocumented)
    protected _polymorphic?: boolean;
    // (undocumented)
    get relationshipClass(): RelationshipClass;
    // (undocumented)
    protected _relationshipClass: RelationshipClass;
    // (undocumented)
    get relationshipEnd(): RelationshipEnd;
    // (undocumented)
    protected _relationshipEnd: RelationshipEnd;
    // (undocumented)
    get roleLabel(): string | undefined;
    // (undocumented)
    protected _roleLabel?: string;
    get schema(): Schema;
    supportsClass(ecClass: ECClass): Promise<boolean>;
    toJSON(): RelationshipConstraintProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface RelationshipConstraintProps {
    // (undocumented)
    readonly abstractConstraint?: string;
    // (undocumented)
    readonly constraintClasses: string[];
    // (undocumented)
    readonly multiplicity: string;
    // (undocumented)
    readonly polymorphic: boolean;
    // (undocumented)
    readonly roleLabel: string;
}

// @beta
export enum RelationshipEnd {
    // (undocumented)
    Source = 0,
    // (undocumented)
    Target = 1
}

// @beta (undocumented)
export function relationshipEndToString(end: RelationshipEnd): string;

// @beta (undocumented)
export class RelationshipMultiplicity {
    constructor(lowerLimit: number, upperLimit: number);
    // (undocumented)
    equals(rhs: RelationshipMultiplicity): boolean;
    // (undocumented)
    static fromString(str: string): RelationshipMultiplicity | undefined;
    // (undocumented)
    readonly lowerLimit: number;
    // (undocumented)
    static readonly oneMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly oneOne: RelationshipMultiplicity;
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly upperLimit: number;
    // (undocumented)
    static readonly zeroMany: RelationshipMultiplicity;
    // (undocumented)
    static readonly zeroOne: RelationshipMultiplicity;
}

// @beta (undocumented)
export class Schema implements CustomAttributeContainerProps {
    constructor(context: SchemaContext, name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number);
    constructor(context: SchemaContext, key: SchemaKey, alias: string);
    // @internal
    constructor(context: SchemaContext);
    // (undocumented)
    protected addCustomAttribute(customAttribute: CustomAttribute): void;
    // (undocumented)
    protected addItem<T extends SchemaItem>(item: T): void;
    // (undocumented)
    protected addReference(refSchema: Schema): Promise<void>;
    // (undocumented)
    protected addReferenceSync(refSchema: Schema): void;
    // (undocumented)
    get alias(): string;
    // (undocumented)
    protected _alias?: string;
    get context(): SchemaContext;
    // @alpha (undocumented)
    protected createClass<T extends AnyClass>(type: (new (schema: Schema, name: string, modifier?: ECClassModifier) => T), name: string, modifier?: ECClassModifier): T;
    protected createConstant(name: string): Promise<Constant>;
    // (undocumented)
    protected createConstantSync(name: string): Constant;
    protected createCustomAttributeClass(name: string, modifier?: ECClassModifier): Promise<CustomAttributeClass>;
    // (undocumented)
    protected createCustomAttributeClassSync(name: string, modifier?: ECClassModifier): CustomAttributeClass;
    protected createEntityClass(name: string, modifier?: ECClassModifier): Promise<EntityClass>;
    // (undocumented)
    protected createEntityClassSync(name: string, modifier?: ECClassModifier): EntityClass;
    protected createEnumeration(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Promise<Enumeration>;
    // (undocumented)
    protected createEnumerationSync(name: string, primitiveType?: PrimitiveType.Integer | PrimitiveType.String): Enumeration;
    protected createFormat(name: string): Promise<Format>;
    // (undocumented)
    protected createFormatSync(name: string): Format;
    protected createInvertedUnit(name: string): Promise<InvertedUnit>;
    // (undocumented)
    protected createInvertedUnitSync(name: string): InvertedUnit;
    // @alpha (undocumented)
    protected createItem<T extends AnySchemaItem>(type: (new (schema: Schema, name: string) => T), name: string): T;
    protected createKindOfQuantity(name: string): Promise<KindOfQuantity>;
    // (undocumented)
    protected createKindOfQuantitySync(name: string): KindOfQuantity;
    protected createMixinClass(name: string): Promise<Mixin>;
    // (undocumented)
    protected createMixinClassSync(name: string): Mixin;
    protected createPhenomenon(name: string): Promise<Phenomenon>;
    // (undocumented)
    protected createPhenomenonSync(name: string): Phenomenon;
    protected createPropertyCategory(name: string): Promise<PropertyCategory>;
    // (undocumented)
    protected createPropertyCategorySync(name: string): PropertyCategory;
    protected createRelationshipClass(name: string, modifier?: ECClassModifier): Promise<RelationshipClass>;
    // (undocumented)
    protected createRelationshipClassSync(name: string, modifier?: ECClassModifier): RelationshipClass;
    protected createStructClass(name: string, modifier?: ECClassModifier): Promise<StructClass>;
    // (undocumented)
    protected createStructClassSync(name: string, modifier?: ECClassModifier): StructClass;
    protected createUnit(name: string): Promise<Unit>;
    // (undocumented)
    protected createUnitSync(name: string): Unit;
    protected createUnitSystem(name: string): Promise<UnitSystem>;
    // (undocumented)
    protected createUnitSystemSync(name: string): UnitSystem;
    // (undocumented)
    get customAttributes(): CustomAttributeSet | undefined;
    // @alpha
    protected deleteClass(name: string): Promise<void>;
    // @alpha
    protected deleteClassSync(name: string): void;
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    // (undocumented)
    fromJSON(schemaProps: SchemaProps): Promise<void>;
    // (undocumented)
    static fromJson(jsonObj: object | string, context: SchemaContext): Promise<Schema>;
    // (undocumented)
    fromJSONSync(schemaProps: SchemaProps): void;
    // (undocumented)
    static fromJsonSync(jsonObj: object | string, context: SchemaContext): Schema;
    get fullName(): string;
    // (undocumented)
    getClasses(): IterableIterator<ECClass>;
    getItem<T extends SchemaItem>(name: string): Promise<T | undefined>;
    // (undocumented)
    getItems<T extends AnySchemaItem>(): IterableIterator<T>;
    getItemSync<T extends SchemaItem>(name: string): T | undefined;
    // (undocumented)
    getReference<T extends Schema>(refSchemaName: string): Promise<T | undefined>;
    // (undocumented)
    getReferenceNameByAlias(alias: string): string | undefined;
    // (undocumented)
    getReferenceSync<T extends Schema>(refSchemaName: string): T | undefined;
    getSchemaItemKey(fullName: string): SchemaItemKey;
    // @internal (undocumented)
    static isSchema(object: any): object is Schema;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    lookupItem<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): Promise<T | undefined>;
    lookupItemSync<T extends SchemaItem>(key: Readonly<SchemaItemKey> | string): T | undefined;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get readVersion(): number;
    // (undocumented)
    readonly references: Schema[];
    get schema(): Schema;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey?: SchemaKey;
    // @alpha
    protected setContext(context: SchemaContext): void;
    setVersion(readVersion?: number, writeVersion?: number, minorVersion?: number): void;
    toJSON(): SchemaProps;
    toXml(schemaXml: Document): Promise<Document>;
    // (undocumented)
    get writeVersion(): number;
}

// @beta (undocumented)
export class SchemaCache implements ISchemaLocater {
    constructor();
    addSchema<T extends Schema>(schema: T): Promise<void>;
    addSchemaSync<T extends Schema>(schema: T): void;
    // (undocumented)
    get count(): number;
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @beta
export class SchemaContext implements ISchemaLocater, ISchemaItemLocater {
    constructor();
    // (undocumented)
    addLocater(locater: ISchemaLocater): void;
    addSchema(schema: Schema): Promise<void>;
    addSchemaItem(schemaItem: SchemaItem): Promise<void>;
    addSchemaSync(schema: Schema): void;
    // @internal
    getCachedSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // @internal
    getCachedSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Schema | undefined;
    // (undocumented)
    getSchema<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): Promise<T | undefined>;
    // (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey): Promise<T | undefined>;
    // (undocumented)
    getSchemaItemSync<T extends SchemaItem>(schemaItemKey: SchemaItemKey): T | undefined;
    // (undocumented)
    getSchemaSync<T extends Schema>(schemaKey: SchemaKey, matchType?: SchemaMatchType): T | undefined;
    }

// @beta
export class SchemaGraph {
    constructor(schema: Schema);
    detectCycles(): ReferenceCycle[] | undefined;
    }

// @internal
export class SchemaGraphUtil {
    static buildDependencyOrderedSchemaList(insertSchema: Schema, schemas?: Schema[]): Schema[];
    }

// @beta
export abstract class SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    protected _description?: string;
    static equalByKey(thisSchemaItem: SchemaItem, thatSchemaItemOrKey?: SchemaItem | SchemaItemKey): boolean;
    // (undocumented)
    fromJSON(schemaItemProps: SchemaItemProps): Promise<void>;
    // (undocumented)
    fromJSONSync(schemaItemProps: SchemaItemProps): void;
    // (undocumented)
    get fullName(): string;
    // @internal (undocumented)
    static isSchemaItem(object: any): object is SchemaItem;
    // (undocumented)
    get key(): SchemaItemKey;
    // (undocumented)
    protected _key: SchemaItemKey;
    // (undocumented)
    get label(): string | undefined;
    // (undocumented)
    protected _label?: string;
    // (undocumented)
    get name(): string;
    static parseFullName(fullName: string): [string, string];
    // (undocumented)
    readonly schema: Schema;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // @alpha
    protected setDescription(description: string): void;
    // @alpha
    protected setDisplayLabel(displayLabel: string): void;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): SchemaItemProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta
export class SchemaItemKey {
    constructor(name: string, schema: SchemaKey);
    get fullName(): string;
    matches(rhs: SchemaItemKey): boolean;
    // (undocumented)
    matchesFullName(name: string): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get schemaKey(): SchemaKey;
    // (undocumented)
    protected _schemaKey: SchemaKey;
    // (undocumented)
    get schemaName(): string;
}

// @beta (undocumented)
export interface SchemaItemProps {
    // (undocumented)
    readonly $schema?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name?: string;
    // (undocumented)
    readonly schema?: string;
    // (undocumented)
    readonly schemaItemType?: string;
    // (undocumented)
    readonly schemaVersion?: string;
}

// @beta (undocumented)
export enum SchemaItemType {
    // (undocumented)
    Constant = 10,
    // (undocumented)
    CustomAttributeClass = 3,
    // (undocumented)
    EntityClass = 0,
    // (undocumented)
    Enumeration = 5,
    // (undocumented)
    Format = 13,
    // (undocumented)
    InvertedUnit = 9,
    // (undocumented)
    KindOfQuantity = 6,
    // (undocumented)
    Mixin = 1,
    // (undocumented)
    Phenomenon = 11,
    // (undocumented)
    PropertyCategory = 7,
    // (undocumented)
    RelationshipClass = 4,
    // (undocumented)
    StructClass = 2,
    // (undocumented)
    Unit = 8,
    // (undocumented)
    UnitSystem = 12
}

// @beta
export function schemaItemTypeToString(value: SchemaItemType): string;

// @internal (undocumented)
export function schemaItemTypeToXmlString(value: SchemaItemType): string;

// @beta
export class SchemaKey {
    constructor(name: string, version: ECVersion);
    constructor(name: string, readVersion?: number, writeVersion?: number, minorVersion?: number);
    compareByName(rhs: SchemaKey | string | undefined): boolean;
    compareByVersion(rhs: SchemaKey): number;
    static fromJSON(props: SchemaKeyProps): SchemaKey;
    // (undocumented)
    matches(rhs: SchemaKey, matchType?: SchemaMatchType): boolean;
    // (undocumented)
    get minorVersion(): number;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static parseString(fullName: string): SchemaKey;
    // (undocumented)
    get readVersion(): number;
    toJSON(): SchemaKeyProps;
    toString(padZeroes?: boolean): string;
    // (undocumented)
    get version(): ECVersion;
    // (undocumented)
    protected _version: ECVersion;
    // (undocumented)
    get writeVersion(): number;
}

// @beta
export interface SchemaKeyProps {
    readonly minor: number;
    readonly name: string;
    readonly read: number;
    readonly write: number;
}

// @beta (undocumented)
export class SchemaMap extends Array<Schema> {
}

// @beta
export enum SchemaMatchType {
    // (undocumented)
    Exact = 1,
    // (undocumented)
    Identical = 0,
    // (undocumented)
    Latest = 3,
    // (undocumented)
    LatestReadCompatible = 4,
    // (undocumented)
    LatestWriteCompatible = 2
}

// @beta
export class SchemaPartVisitorDelegate {
    constructor(visitor: ISchemaPartVisitor);
    visitSchema(schema: Schema, fullSchema?: boolean): Promise<void>;
    visitSchemaPart(schemaPart: AnyECType): Promise<void>;
    visitSchemaPartSync(schemaPart: AnyECType): void;
    visitSchemaSync(schema: Schema, fullSchema?: boolean): void;
}

// @beta (undocumented)
export interface SchemaProps {
    // (undocumented)
    readonly $schema: string;
    // (undocumented)
    readonly alias: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly items?: {
        [name: string]: SchemaItemProps;
    };
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly references?: SchemaReferenceProps[];
    // (undocumented)
    readonly version: string;
}

// @internal
export class SchemaReadHelper<T = unknown> {
    constructor(parserType: AbstractParserConstructor<T>, context?: SchemaContext, visitor?: ISchemaPartVisitor);
    readSchema<U extends Schema>(schema: U, rawSchema: T): Promise<U>;
    readSchemaSync<U extends Schema>(schema: U, rawSchema: T): U;
    }

// @beta (undocumented)
export interface SchemaReferenceProps {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly version: string;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
    }

// @beta
export enum ScientificType {
    // (undocumented)
    Normalized = 0,
    // (undocumented)
    ZeroNormalized = 1
}

// @internal
export function scientificTypeToString(scientificType: ScientificType): string;

// @beta
export enum ShowSignOption {
    // (undocumented)
    NegativeParentheses = 3,
    // (undocumented)
    NoSign = 0,
    // (undocumented)
    OnlyNegative = 1,
    // (undocumented)
    SignAlways = 2
}

// @internal
export function showSignOptionToString(showSign: ShowSignOption): string;

// @beta (undocumented)
export enum StrengthDirection {
    // (undocumented)
    Backward = 2,
    // (undocumented)
    Forward = 1
}

// @beta (undocumented)
export function strengthDirectionToString(direction: StrengthDirection): string;

// @beta (undocumented)
export function strengthToString(strength: StrengthType): string;

// @beta (undocumented)
export enum StrengthType {
    // (undocumented)
    Embedding = 2,
    // (undocumented)
    Holding = 1,
    // (undocumented)
    Referencing = 0
}

// @beta (undocumented)
export class StructArrayProperty extends StructArrayProperty_base {
    constructor(ecClass: ECClass, name: string, type: StructClass);
}

// @beta (undocumented)
export interface StructArrayPropertyProps extends ArrayPropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export class StructClass extends ECClass {
    constructor(schema: Schema, name: string, modifier?: ECClassModifier);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.StructClass;
}

// @beta (undocumented)
export type StructClassProps = ClassProps;

// @beta (undocumented)
export class StructProperty extends Property {
    constructor(ecClass: ECClass, name: string, type: StructClass);
    // (undocumented)
    fromJSON(structPropertyProps: StructPropertyProps): Promise<void>;
    // (undocumented)
    fromJSONSync(structPropertyProps: StructPropertyProps): void;
    // (undocumented)
    get structClass(): StructClass;
    // (undocumented)
    protected _structClass: StructClass;
    toJSON(): StructPropertyProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
}

// @beta (undocumented)
export interface StructPropertyProps extends PropertyProps {
    // (undocumented)
    readonly typeName: string;
}

// @beta
export class Unit extends SchemaItem {
    constructor(schema: Schema, name: string);
    // @alpha
    static areCompatible(unitA: Unit, unitB: Unit): Promise<boolean>;
    // (undocumented)
    get definition(): string;
    // (undocumented)
    protected _definition: string;
    // (undocumented)
    get denominator(): number;
    // (undocumented)
    protected _denominator: number;
    // (undocumented)
    fromJSON(unitProps: UnitProps): Promise<void>;
    // (undocumented)
    fromJSONSync(unitProps: UnitProps): void;
    // (undocumented)
    get numerator(): number;
    // (undocumented)
    protected _numerator: number;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    protected _offset: number;
    // (undocumented)
    get phenomenon(): LazyLoadedPhenomenon | undefined;
    // (undocumented)
    protected _phenomenon?: LazyLoadedPhenomenon;
    // (undocumented)
    readonly schemaItemType: SchemaItemType.Unit;
    // @alpha
    protected setDefinition(definition: string): Promise<void>;
    // @alpha
    protected setPhenomenon(phenomenon: LazyLoadedPhenomenon): Promise<void>;
    // @alpha
    protected setUnitSystem(unitSystem: LazyLoadedUnitSystem): Promise<void>;
    toJSON(standalone?: boolean, includeSchemaVersion?: boolean): UnitProps;
    // @internal (undocumented)
    toXml(schemaXml: Document): Promise<Element>;
    // (undocumented)
    get unitSystem(): LazyLoadedUnitSystem | undefined;
    // (undocumented)
    protected _unitSystem?: LazyLoadedUnitSystem;
}

// @beta (undocumented)
export interface UnitProps extends SchemaItemProps {
    // (undocumented)
    readonly definition: string;
    // (undocumented)
    readonly denominator?: number;
    // (undocumented)
    readonly numerator?: number;
    // (undocumented)
    readonly offset?: number;
    // (undocumented)
    readonly phenomenon: string;
    // (undocumented)
    readonly unitSystem: string;
}

// @beta (undocumented)
export class UnitSystem extends SchemaItem {
    constructor(schema: Schema, name: string);
    // (undocumented)
    readonly schemaItemType: SchemaItemType.UnitSystem;
}

// @beta (undocumented)
export type UnitSystemProps = SchemaItemProps;

// @internal (undocumented)
export class XmlParser extends AbstractParser<Element> {
    constructor(rawSchema: Readonly<Document>);
    // (undocumented)
    findItem(itemName: string): [string, string, Element] | undefined;
    // (undocumented)
    getClassCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    getItems(): Iterable<[string, string, Element]>;
    // (undocumented)
    getProperties(xmlElement: Element): Iterable<[string, string, Element]>;
    // (undocumented)
    getPropertyCustomAttributeProviders(xmlElement: Element): Iterable<CAProviderTuple>;
    // (undocumented)
    getReferences(): Iterable<SchemaReferenceProps>;
    // (undocumented)
    getRelationshipConstraintCustomAttributeProviders(xmlElement: Element): [Iterable<CAProviderTuple>, Iterable<CAProviderTuple>];
    // (undocumented)
    getSchemaCustomAttributeProviders(): Iterable<CAProviderTuple>;
    // (undocumented)
    parseConstant(xmlElement: Element): ConstantProps;
    // (undocumented)
    parseCustomAttributeClass(xmlElement: Element): CustomAttributeClassProps;
    // (undocumented)
    parseEntityClass(xmlElement: Element): EntityClassProps;
    // (undocumented)
    parseEnumeration(xmlElement: Element): EnumerationProps;
    // (undocumented)
    parseFormat(xmlElement: Element): FormatProps;
    // (undocumented)
    parseInvertedUnit(xmlElement: Element): InvertedUnitProps;
    // (undocumented)
    parseKindOfQuantity(xmlElement: Element): KindOfQuantityProps;
    // (undocumented)
    parseMixin(xmlElement: Element): MixinProps;
    // (undocumented)
    parseNavigationProperty(xmlElement: Element): NavigationPropertyProps;
    // (undocumented)
    parsePhenomenon(xmlElement: Element): PhenomenonProps;
    // (undocumented)
    parsePrimitiveArrayProperty(xmlElement: Element): PrimitiveArrayPropertyProps;
    // (undocumented)
    parsePrimitiveProperty(xmlElement: Element): PrimitivePropertyProps;
    // (undocumented)
    parsePropertyCategory(xmlElement: Element): PropertyCategoryProps;
    // (undocumented)
    parseRelationshipClass(xmlElement: Element): RelationshipClassProps;
    // (undocumented)
    parseSchema(): SchemaProps;
    // (undocumented)
    parseStructArrayProperty(xmlElement: Element): StructArrayPropertyProps;
    // (undocumented)
    parseStructClass(xmlElement: Element): StructClassProps;
    // (undocumented)
    parseStructProperty(xmlElement: Element): StructPropertyProps;
    // (undocumented)
    parseUnit(xmlElement: Element): UnitProps;
    // (undocumented)
    parseUnitSystem(xmlElement: Element): UnitSystemProps;
    }


// (No @packageDocumentation comment for this package)

```
