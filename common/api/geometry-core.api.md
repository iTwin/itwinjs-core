## API Report File for "@bentley/geometry-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @internal
export abstract class AbstractNewtonIterator {
    protected constructor(stepSizeTolerance?: number, successiveConvergenceTarget?: number, maxIterations?: number);
    abstract applyCurrentStep(isFinalStep: boolean): boolean;
    abstract computeStep(): boolean;
    abstract currentStepSize(): number;
    protected _maxIterations: number;
    protected _numAccepted: number;
    numIterations: number;
    runIterations(): boolean;
    protected _stepSizeTolerance: number;
    protected _successiveConvergenceTarget: number;
    testConvergence(delta: number): boolean;
}

// @internal
export class AnalyticRoots {
    static appendCubicRoots(c: Float64Array | number[], results: GrowableFloat64Array): void;
    static appendImplicitLineUnitCircleIntersections(alpha: number, beta: number, gamma: number, cosValues: OptionalGrowableFloat64Array, sinValues: OptionalGrowableFloat64Array, radiansValues: OptionalGrowableFloat64Array, relTol?: number): number;
    static appendLinearRoot(c0: number, c1: number, values: GrowableFloat64Array): void;
    static appendQuadraticRoots(c: Float64Array | number[], values: GrowableFloat64Array): void;
    static appendQuarticRoots(c: Float64Array | number[], results: GrowableFloat64Array): void;
    static cbrt(x: number): number;
    static mostDistantFromMean(data: GrowableFloat64Array | undefined): number;
    }

// @public
export class Angle implements BeJSONFunctions {
    addMultipleOf2PiInPlace(multiple: number): void;
    static adjustDegrees0To360(degrees: number): number;
    static adjustDegreesSigned180(degrees: number): number;
    static adjustRadians0To2Pi(radians: number): number;
    static adjustRadiansMinusPiPlusPi(radians: number): number;
    static cleanupTrigValue(value: number, tolerance?: number): number;
    clone(): Angle;
    cloneScaled(scale: number): Angle;
    cos(): number;
    static create360(): Angle;
    static createAtan2(numerator: number, denominator: number): Angle;
    static createDegrees(degrees: number): Angle;
    static createDegreesAdjustPositive(degrees: number): Angle;
    static createDegreesAdjustSigned180(degrees: number): Angle;
    static createRadians(radians: number): Angle;
    get degrees(): number;
    static readonly degreesPerRadian: number;
    static degreesToRadians(degrees: number): number;
    static dotProductsToHalfAngleTrigValues(dotUU: number, dotVV: number, dotUV: number, favorZero?: boolean): TrigValues;
    freeze(): Readonly<this>;
    static fromJSON(json?: AngleProps, defaultValRadians?: number): Angle;
    isAlmostEqual(other: Angle): boolean;
    isAlmostEqualAllowPeriodShift(other: Angle): boolean;
    isAlmostEqualNoPeriodShift(other: Angle): boolean;
    static isAlmostEqualRadiansAllowPeriodShift(radiansA: number, radiansB: number): boolean;
    static isAlmostEqualRadiansNoPeriodShift(radiansA: number, radiansB: number): boolean;
    get isAlmostNorthOrSouthPole(): boolean;
    get isAlmostZero(): boolean;
    get isExactZero(): boolean;
    get isFullCircle(): boolean;
    static isFullCircleRadians(radians: number): boolean;
    get isHalfCircle(): boolean;
    static isHalfCircleRadians(radians: number): boolean;
    static isPerpendicularDotSet(dotUU: number, dotVV: number, dotUV: number): boolean;
    static readonly pi2Radians = 6.283185307179586;
    static readonly piOver12Radians = 0.26179938779914946;
    static readonly piOver2Radians = 1.5707963267948966;
    static readonly piOver4Radians = 0.7853981633974483;
    static readonly piRadians = 3.141592653589793;
    get radians(): number;
    static radiansBetweenVectorsXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number;
    static readonly radiansPerDegree: number;
    static radiansToDegrees(radians: number): number;
    setDegrees(degrees: number): void;
    setFrom(other: Angle): void;
    setFromJSON(json?: AngleProps, defaultValRadians?: number): void;
    setRadians(radians: number): void;
    sin(): number;
    tan(): number;
    toJSON(): AngleProps;
    toJSONRadians(): AngleProps;
    static trigValuesToHalfAngleTrigValues(rCos2A: number, rSin2A: number): TrigValues;
    static zero(): Angle;
}

// @public
export type AngleProps = {
    degrees: number;
} | {
    radians: number;
} | {
    _radians: number;
} | {
    _degrees: number;
} | number;

// @public
export class AngleSweep implements BeJSONFunctions {
    angleToPositivePeriodicFraction(theta: Angle): number;
    angleToSignedPeriodicFraction(theta: Angle): number;
    angleToUnboundedFraction(theta: Angle): number;
    capLatitudeInPlace(): void;
    clone(): AngleSweep;
    cloneComplement(reverseDirection?: boolean, result?: AngleSweep): AngleSweep;
    cloneMinusRadians(radians: number): AngleSweep;
    static create(data?: AngleSweep | Angle): AngleSweep;
    static create360(startRadians?: number): AngleSweep;
    static createFullLatitude(): AngleSweep;
    static createStartEnd(startAngle: Angle, endAngle: Angle, result?: AngleSweep): AngleSweep;
    static createStartEndDegrees(startDegrees?: number, endDegrees?: number, result?: AngleSweep): AngleSweep;
    static createStartEndRadians(startRadians?: number, endRadians?: number, result?: AngleSweep): AngleSweep;
    static createStartSweep(startAngle: Angle, sweepAngle: Angle, result?: AngleSweep): AngleSweep;
    static createStartSweepDegrees(startDegrees?: number, sweepDegrees?: number, result?: AngleSweep): AngleSweep;
    static createStartSweepRadians(startRadians?: number, sweepRadians?: number, result?: AngleSweep): AngleSweep;
    get endAngle(): Angle;
    get endDegrees(): number;
    get endRadians(): number;
    fractionPeriod(): number;
    fractionToAngle(fraction: number): Angle;
    fractionToRadians(fraction: number): number;
    static fromJSON(json?: AngleSweepProps): AngleSweep;
    interpolate(fraction: number, other: AngleSweep): AngleSweep;
    isAlmostEqual(other: AngleSweep): boolean;
    isAlmostEqualAllowPeriodShift(other: AngleSweep): boolean;
    isAlmostEqualNoPeriodShift(other: AngleSweep): boolean;
    isAngleInSweep(angle: Angle): boolean;
    get isCCW(): boolean;
    get isFullCircle(): boolean;
    get isFullLatitudeSweep(): boolean;
    static isRadiansInStartEnd(radians: number, radians0: number, radians1: number, allowPeriodShift?: boolean): boolean;
    isRadiansInSweep(radians: number, allowPeriodShift?: boolean): boolean;
    radiansArrayToPositivePeriodicFractions(data: GrowableFloat64Array): void;
    radiansToPositivePeriodicFraction(radians: number, zeroSweepDefault?: number): number;
    static radiansToPositivePeriodicFractionStartEnd(radians: number, radians0: number, radians1: number, zeroSweepDefault?: number): number;
    radiansToSignedPeriodicFraction(radians: number): number;
    reverseInPlace(): void;
    setFrom(other: AngleSweep): void;
    setFromJSON(json?: any): void;
    setStartEndDegrees(startDegrees?: number, endDegrees?: number): void;
    setStartEndRadians(startRadians?: number, endRadians?: number): void;
    get startAngle(): Angle;
    get startDegrees(): number;
    get startRadians(): number;
    get sweepDegrees(): number;
    get sweepRadians(): number;
    toJSON(): any;
}

// @public
export type AngleSweepProps = AngleSweep | {
    degrees: [number, number];
} | {
    radians: [number, number];
} | [number, number];

// @internal
export class AnnotatedLineString3d {
    curveParam?: GrowableFloat64Array;
    uvwParam?: GrowableXYZArray;
    vectorU?: GrowableXYZArray;
    vectorV?: GrowableXYZArray;
}

// @public
export type AnnounceCurvePrimitive = (cp: CurvePrimitive) => void;

// @public
export type AnnounceDrapePanel = (linestring: GrowableXYZArray, segmentIndex: number, polyface: Polyface, facetIndex: number, points: Point3d[], indexAOnFacet: number, indexBOnFacet: number) => any;

// @public
export type AnnounceNumberNumber = (a0: number, a1: number) => void;

// @public
export type AnnounceNumberNumberCurvePrimitive = (a0: number, a1: number, cp: CurvePrimitive) => void;

// @public
export type AnyCurve = CurvePrimitive | CurveCollection;

// @public
export type AnyGeometryQuery = Polyface | CurvePrimitive | CurveCollection | SolidPrimitive | CoordinateXYZ | PointString3d | BSpline2dNd;

// @public
export type AnyRegion = Loop | ParityRegion | UnionRegion;

// @public
export type AnySolidPrimitive = Box | Cone | Sphere | LinearSweep | RotationalSweep | RuledSweep | TorusPipe;

// @public
export class Arc3d extends CurvePrimitive implements BeJSONFunctions {
    allPerpendicularAngles(spacePoint: Point3d, _extend?: boolean, _endpoints?: boolean): number[];
    angleToPointAndDerivative(theta: Angle, result?: Ray3d): Ray3d;
    announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number;
    areaToChordXY(fraction0: number, fraction1: number): number;
    get center(): Point3d;
    circularRadius(): number | undefined;
    circularRadiusXY(): number | undefined;
    clone(): Arc3d;
    cloneAtZ(z?: number): Arc3d;
    cloneInRotatedBasis(theta: Angle): Arc3d;
    clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined;
    cloneTransformed(transform: Transform): CurvePrimitive;
    closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter, result?: CurveLocationDetail): CurveLocationDetail;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    static create(center: Point3d | undefined, vector0: Vector3d, vector90: Vector3d, sweep?: AngleSweep, result?: Arc3d): Arc3d;
    static createCenterNormalRadius(center: Point3d | undefined, normal: Vector3d, radius: number, result?: Arc3d): Arc3d;
    static createCircularStartMiddleEnd(pointA: XYAndZ, pointB: XYAndZ, pointC: XYAndZ, result?: Arc3d): Arc3d | LineString3d | undefined;
    static createFilletArc(point0: Point3d, point1: Point3d, point2: Point3d, radius: number): ArcBlendData;
    static createRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep, result?: Arc3d): Arc3d;
    static createScaledXYColumns(center: Point3d | undefined, matrix: Matrix3d, radius0: number, radius90: number, sweep?: AngleSweep, result?: Arc3d): Arc3d;
    static createUnitCircle(): Arc3d;
    static createXY(center: Point3d, radius: number, sweep?: AngleSweep): Arc3d;
    static createXYEllipse(center: Point3d, radiusA: number, radiusB: number, sweep?: AngleSweep): Arc3d;
    static createXYZXYZXYZ(cx: number, cy: number, cz: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, sweep?: AngleSweep, result?: Arc3d): Arc3d;
    curveLength(): number;
    curveLengthBetweenFractions(fraction0: number, fraction1: number): number;
    readonly curvePrimitiveType = "arc";
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(result?: Point3d): Point3d;
    extendRange(range: Range3d, transform?: Transform): void;
    fractionAndRadialFractionToPoint(arcFraction: number, radialFraction: number, result?: Point3d): Point3d;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    getFractionToDistanceScale(): number | undefined;
    // @internal
    getPlaneAltitudeSineCosinePolynomial(plane: PlaneAltitudeEvaluator, result?: SineCosinePolynomial): SineCosinePolynomial;
    isAlmostEqual(otherGeometry: GeometryQuery): boolean;
    get isCircular(): boolean;
    get isExtensibleFractionSpace(): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    matrixClone(): Matrix3d;
    get matrixRef(): Matrix3d;
    maxVectorLength(): number;
    moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail;
    otherArcAsLocalVectors(other: Arc3d): ArcVectors | undefined;
    get perpendicularVector(): Vector3d;
    static readonly quadratureGuassCount = 5;
    static readonly quadratureIntervalAngleDegrees = 10;
    quickEccentricity(): number;
    quickLength(): number;
    radiansToPoint(radians: number, result?: Point3d): Point3d;
    radiansToPointAndDerivative(radians: number, result?: Ray3d): Ray3d;
    radiansToRotatedBasis(radians: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    reverseInPlace(): void;
    scaleAboutCenterInPlace(scaleFactor: number): void;
    set(center: Point3d, matrix: Matrix3d, sweep: AngleSweep | undefined): void;
    setFrom(other: Arc3d): void;
    setFromJSON(json?: any): void;
    setRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep): void;
    setVector0Vector90(vector0: Vector3d, vector90: Vector3d): void;
    startPoint(result?: Point3d): Point3d;
    get sweep(): AngleSweep;
    set sweep(value: AngleSweep);
    toJSON(): any;
    toScaledMatrix3d(): {
        center: Point3d;
        axes: Matrix3d;
        r0: number;
        r90: number;
        sweep: AngleSweep;
    };
    toTransformedPoint4d(matrix: Matrix4d): {
        center: Point4d;
        vector0: Point4d;
        vector90: Point4d;
        sweep: AngleSweep;
    };
    toTransformedVectors(transform?: Transform): {
        center: Point3d;
        vector0: Vector3d;
        vector90: Vector3d;
        sweep: AngleSweep;
    };
    toVectors(): ArcVectors;
    tryTransformInPlace(transform: Transform): boolean;
    get vector0(): Vector3d;
    get vector90(): Vector3d;
    }

// @public
export interface ArcBlendData {
    arc?: Arc3d;
    fraction10: number;
    fraction12: number;
    point?: Point3d;
}

// @public
export interface ArcVectors {
    center: Point3d;
    sweep: AngleSweep;
    vector0: Vector3d;
    vector90: Vector3d;
}

// @public
export class AuxChannel {
    constructor(data: AuxChannelData[], dataType: AuxChannelDataType, name?: string, inputName?: string);
    clone(): AuxChannel;
    data: AuxChannelData[];
    dataType: AuxChannelDataType;
    get entriesPerValue(): number;
    inputName?: string;
    isAlmostEqual(other: AuxChannel, tol?: number): boolean;
    get isScalar(): boolean;
    name?: string;
    get scalarRange(): Range1d | undefined;
    get valueCount(): number;
}

// @public
export class AuxChannelData {
    constructor(input: number, values: number[] | Float64Array);
    clone(): AuxChannelData;
    copyValues(other: AuxChannelData, thisIndex: number, otherIndex: number, blockSize: number): void;
    input: number;
    isAlmostEqual(other: AuxChannelData, tol?: number): boolean;
    values: number[];
}

// @public
export enum AuxChannelDataType {
    Distance = 1,
    Normal = 3,
    Scalar = 0,
    Vector = 2
}

// @public
export enum AxisIndex {
    X = 0,
    Y = 1,
    Z = 2
}

// @public
export enum AxisOrder {
    XYZ = 0,
    XZY = 4,
    YXZ = 5,
    YZX = 1,
    ZXY = 2,
    ZYX = 6
}

// @public
export enum AxisScaleSelect {
    LongestRangeDirection = 1,
    NonUniformRangeContainment = 2,
    Unit = 0
}

// @public
export class BagOfCurves extends CurveCollection {
    constructor();
    announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent?: number): void;
    get children(): AnyCurve[];
    protected _children: AnyCurve[];
    cloneEmptyPeer(): BagOfCurves;
    cloneStroked(options?: StrokeOptions): BagOfCurves;
    static create(...data: AnyCurve[]): BagOfCurves;
    readonly curveCollectionType = "bagOfCurves";
    dgnBoundaryType(): number;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    getChild(i: number): AnyCurve | undefined;
    isSameGeometryClass(other: GeometryQuery): boolean;
    tryAddChild(child: AnyCurve | undefined): boolean;
}

// @public
export class BarycentricTriangle {
    protected constructor(point0: Point3d, point1: Point3d, point2: Point3d);
    get area(): number;
    get aspectRatio(): number;
    centroid(result?: Point3d): Point3d;
    clone(result?: BarycentricTriangle): BarycentricTriangle;
    static create(point0: Point3d, point1: Point3d, point2: Point3d, result?: BarycentricTriangle): BarycentricTriangle;
    static createXYZXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, x2: number, y2: number, z2: number, result?: BarycentricTriangle): BarycentricTriangle;
    dotProductOfCrossProductsFromOrigin(other: BarycentricTriangle): number;
    fractionToPoint(a0: number, a1: number, a2: number, result?: Point3d): Point3d;
    isAlmostEqual(other: BarycentricTriangle): boolean;
    points: Point3d[];
    set(point0: Point3d | undefined, point1: Point3d | undefined, point2: Point3d | undefined): void;
    setFrom(other: BarycentricTriangle): void;
    }

// @public
export interface BeJSONFunctions {
    setFromJSON(json: any): void;
    toJSON(): any;
}

// @public
export class BentleyGeometryFlatBuffer {
    static bytesToGeometry(justTheBytes: Uint8Array, hasVersionSignature?: boolean): GeometryQuery | GeometryQuery[] | undefined;
    static geometryToBytes(data: GeometryQuery | GeometryQuery[], addVersionSignature?: boolean): Uint8Array | undefined;
}

// @public
export class Bezier1dNd {
    constructor(blockSize: number, polygon: Float64Array);
    clonePolygon(result?: Float64Array): Float64Array;
    static create(data: Point2d[] | Point3d[] | Point4d[]): Bezier1dNd | undefined;
    evaluate(s: number, buffer?: Float64Array): Float64Array;
    evaluateDerivative(s: number, buffer?: Float64Array): Float64Array;
    fractionToParentFraction(fraction: number): number;
    getPolygonPoint(i: number, buffer?: Float64Array): Float64Array | undefined;
    interpolatePoleInPlace(poleIndexA: number, fraction: number, poleIndexB: number): void;
    interval?: Segment1d;
    isAlmostEqual(other: any): boolean;
    loadSpanPoles(data: Float64Array, spanIndex: number): void;
    loadSpanPolesWithWeight(data: Float64Array, dataDimension: number, spanIndex: number, weight: number): void;
    get order(): number;
    get packedData(): Float64Array;
    reverseInPlace(): void;
    static saturate1dInPlace(coffs: Float64Array, knots: KnotVector, spanIndex: number): boolean;
    saturateInPlace(knots: KnotVector, spanIndex: number): boolean;
    setInterval(a: number, b: number): void;
    setPolygonPoint(i: number, buffer: Float64Array): void;
    subdivideInPlaceKeepLeft(fraction: number): boolean;
    subdivideInPlaceKeepRight(fraction: number): boolean;
    subdivideToIntervalInPlace(fraction0: number, fraction1: number): boolean;
    unpackToJsonArrays(): any[];
}

// @internal
export class BezierBezierIntersectionXYRRToRRD extends NewtonEvaluatorRRtoRRD {
    constructor(curveA: BezierCurveBase, curveB: BezierCurveBase);
    // (undocumented)
    evaluate(fractionA: number, fractionB: number): boolean;
    }

// @internal
export abstract class BezierCoffs {
    constructor(data: number | Float64Array | number[]);
    addInPlace(a: number): void;
    protected allocateToOrder(order: number): void;
    abstract basisFunctions(u: number, result?: Float64Array): Float64Array;
    abstract clone(): BezierCoffs;
    coffs: Float64Array;
    copyFrom(other: BezierCoffs): void;
    createPeer(): BezierCoffs;
    abstract evaluate(u: number): number;
    filter01(roots: number[] | undefined, restrictTo01?: boolean): number[] | undefined;
    static maxAbsDiff(dataA: BezierCoffs, dataB: BezierCoffs): number | undefined;
    get order(): number;
    roots(targetValue: number, _restrictTo01: boolean): number[] | undefined;
    scaleInPlace(scale: number): void;
    subdivide(u: number, left: BezierCoffs, right: BezierCoffs): boolean;
    abstract sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    abstract sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    zero(): void;
}

// @public
export class BezierCurve3d extends BezierCurveBase {
    clone(): BezierCurve3d;
    clonePartialCurve(f0: number, f1: number): BezierCurve3d | undefined;
    cloneTransformed(transform: Transform): BezierCurve3d;
    copyPointsAsLineString(): LineString3d;
    static create(data: Point3d[] | Point2d[]): BezierCurve3d | undefined;
    static createOrder(order: number): BezierCurve3d;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    getPolePoint3d(i: number, result?: Point3d): Point3d | undefined;
    getPolePoint4d(i: number, result?: Point4d): Point4d | undefined;
    isAlmostEqual(other: any): boolean;
    isSameGeometryClass(other: any): boolean;
    loadSpanPoles(data: Float64Array, spanIndex: number): void;
    tryTransformInPlace(transform: Transform): boolean;
    }

// @public
export class BezierCurve3dH extends BezierCurveBase {
    clone(): BezierCurve3dH;
    cloneTransformed(transform: Transform): BezierCurve3dH;
    static create(data: Point3d[] | Point4d[] | Point2d[]): BezierCurve3dH | undefined;
    static createOrder(order: number): BezierCurve3dH;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPoint4d(fraction: number, result?: Point4d): Point4d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    getPolePoint3d(i: number, result?: Point3d): Point3d | undefined;
    getPolePoint4d(i: number, result?: Point4d): Point4d | undefined;
    isAlmostEqual(other: any): boolean;
    isSameGeometryClass(other: any): boolean;
    isUnitWeight(tolerance?: number): boolean;
    loadSpan3dPolesWithWeight(data: Float64Array, spanIndex: number, weight: number): void;
    loadSpan4dPoles(data: Float64Array, spanIndex: number): void;
    poleProductsXYZW(products: Float64Array, ax: number, ay: number, az: number, aw: number): void;
    tryMultiplyMatrix4dInPlace(matrix: Matrix4d): void;
    tryTransformInPlace(transform: Transform): boolean;
    updateClosestPointByTruePerpendicular(spacePoint: Point3d, detail: CurveLocationDetail): boolean;
    }

// @public
export abstract class BezierCurveBase extends CurvePrimitive {
    protected constructor(blockSize: number, data: Float64Array);
    protected allocateAndZeroBezierWorkData(primaryBezierOrder: number, orderA: number, orderB: number): void;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    copyPolesAsJsonArray(): any[];
    readonly curvePrimitiveType = "bezierCurve";
    get degree(): number;
    emitStrokableParts(handler: IStrokeHandler, _options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(): Point3d;
    abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToParentFraction(fraction: number): number;
    abstract getPolePoint3d(i: number, point?: Point3d): Point3d | undefined;
    abstract getPolePoint4d(i: number, point?: Point4d): Point4d | undefined;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    get numPoles(): number;
    get order(): number;
    protected _polygon: Bezier1dNd;
    polygonLength(): number;
    quickLength(): number;
    reverseInPlace(): void;
    saturateInPlace(knotVector: KnotVector, spanIndex: number): boolean;
    setInterval(a: number, b: number): void;
    startPoint(): Point3d;
    // @internal
    protected _workBezier?: UnivariateBezier;
    protected _workCoffsA?: Float64Array;
    protected _workCoffsB?: Float64Array;
    protected _workData0: Float64Array;
    protected _workData1: Float64Array;
    protected _workPoint0: Point3d;
    protected _workPoint1: Point3d;
}

// @internal
export class BezierPolynomialAlgebra {
    static accumulate(dataA: Float64Array, orderA: number, resultB: Float64Array): void;
    static accumulateProduct(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale?: number): void;
    static accumulateProductWithDifferences(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale?: number): void;
    static accumulateScaledShiftedComponentTimesComponentDelta(product: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, scale: number, indexA: number, constA: number, indexB: number): void;
    static componentDifference(difference: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, index: number): void;
    static scaledComponentSum(sum: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, indexA: number, constA: number, indexB: number, constB: number): void;
    static univariateDifference(data: Float64Array, difference: Float64Array): void;
}

// @internal
export class BilinearPatch implements UVSurface {
    constructor(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d);
    clone(): BilinearPatch;
    cloneTransformed(transform: Transform): BilinearPatch | undefined;
    static create(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d): BilinearPatch;
    static createXYZ(x00: number, y00: number, z00: number, x10: number, y10: number, z10: number, x01: number, y01: number, z01: number, x11: number, y11: number, z11: number): BilinearPatch;
    extendRange(range: Range3d, transform?: Transform): void;
    intersectRay(ray: Ray3d): CurveAndSurfaceLocationDetail[] | undefined;
    isAlmostEqual(other: BilinearPatch): boolean;
    maxUEdgeLength(): number;
    maxVEdgeLength(): number;
    point00: Point3d;
    point01: Point3d;
    point10: Point3d;
    point11: Point3d;
    tryTransformInPlace(transform: Transform): boolean;
    uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
}

// @internal
export class BilinearPolynomial {
    constructor(a: number, b: number, c: number, d: number);
    a: number;
    b: number;
    c: number;
    static createUnitSquareValues(f00: number, f10: number, f01: number, f11: number): BilinearPolynomial;
    d: number;
    evaluate(u: number, v: number): number;
    static solvePair(p: BilinearPolynomial, pValue: number, q: BilinearPolynomial, qValue: number): Point2d[] | undefined;
}

// @public
export type BlockComparisonFunction = (data: Float64Array, blockSize: number, index0: number, index1: number) => number;

// @public
export class BooleanClipFactory {
    static anyClipperToJSON(clipper: any): any | undefined;
    static createCaptureClipOutside(primaryClipper: Clipper): Clipper;
    static createCaptureDifference(primaryClipper: Clipper, excludedClipper: Clipper, keepInside: boolean): Clipper;
    static createCaptureIntersection(clippers: Clipper | Clipper[], keepInside: boolean): Clipper;
    static createCaptureParity(clippers: Clipper | Clipper[], keepInside: boolean): Clipper;
    static createCaptureUnion(clippers: Clipper | Clipper[], keepInside: boolean): Clipper;
    static parseToClipper(source?: object): Clipper | undefined;
    static parseToClipperArray(source: any): Clipper[] | undefined;
}

// @public
export class Box extends SolidPrimitive {
    protected constructor(map: Transform, baseX: number, baseY: number, topX: number, topY: number, capped: boolean);
    clone(): Box;
    cloneTransformed(transform: Transform): Box | undefined;
    constantVSection(zFraction: number): CurveCollection;
    static createDgnBox(baseOrigin: Point3d, vectorX: Vector3d, vectorY: Vector3d, topOrigin: Point3d, baseX: number, baseY: number, topX: number, topY: number, capped: boolean): Box | undefined;
    static createDgnBoxWithAxes(baseOrigin: Point3d, axes: Matrix3d, topOrigin: Point3d, baseX: number, baseY: number, topX: number, topY: number, capped: boolean): Box | undefined;
    static createRange(range: Range3d, capped: boolean): Box | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getBaseOrigin(): Point3d;
    getBaseX(): number;
    getBaseY(): number;
    getConstructiveFrame(): Transform | undefined;
    getCorners(): Point3d[];
    getTopOrigin(): Point3d;
    getTopX(): number;
    getTopY(): number;
    getVectorX(): Vector3d;
    getVectorY(): Vector3d;
    getVectorZ(): Vector3d;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    readonly solidPrimitiveType = "box";
    strokeConstantVSection(zFraction: number): LineString3d;
    tryTransformInPlace(transform: Transform): boolean;
}

// @internal
export class BoxTopology {
    static readonly axisEdgeVertex: number[][][];
    static readonly cornerIndexCCW: number[][];
    static readonly faceDirections: number[][][];
    static readonly faceId: number[][];
    static readonly partnerFace: number[][];
    static readonly points: Point3d[];
    static readonly primaryCapId = -1;
}

// @public
export class BSpline1dNd {
    protected constructor(numPoles: number, poleLength: number, order: number, knots: KnotVector);
    basisBuffer: Float64Array;
    basisBuffer1: Float64Array;
    basisBuffer2: Float64Array;
    static create(numPoles: number, poleLength: number, order: number, knots: KnotVector): BSpline1dNd | undefined;
    get degree(): number;
    evaluateBasisFunctionsInSpan(spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array, ddf?: Float64Array): void;
    evaluateBuffersAtKnot(u: number, numDerivative?: number): void;
    evaluateBuffersInSpan(spanIndex: number, spanFraction: number): void;
    evaluateBuffersInSpan1(spanIndex: number, spanFraction: number): void;
    getPoint3dPole(i: number, result?: Point3d): Point3d | undefined;
    knots: KnotVector;
    get numPoles(): number;
    get numSpan(): number;
    get order(): number;
    packedData: Float64Array;
    poleBuffer: Float64Array;
    poleBuffer1: Float64Array;
    poleBuffer2: Float64Array;
    poleLength: number;
    reverseInPlace(): void;
    spanFractionToKnot(span: number, localFraction: number): number;
    sumPoleBuffer1ForSpan(spanIndex: number): void;
    sumPoleBuffer2ForSpan(spanIndex: number): void;
    sumPoleBufferForSpan(spanIndex: number): void;
    testCloseablePolygon(mode?: BSplineWrapMode): boolean;
}

// @public
export abstract class BSpline2dNd extends GeometryQuery {
    protected constructor(numPolesU: number, numPolesV: number, poleLength: number, knotsU: KnotVector, knotsV: KnotVector, coffs: Float64Array);
    protected _basisBuffer1UV: Float64Array[];
    protected _basisBufferUV: Float64Array[];
    coffs: Float64Array;
    degreeUV(select: UVSelect): number;
    evaluateBuffersAtKnot(u: number, v: number, numDerivative?: number): void;
    extendRangeXYZ(rangeToExtend: Range3d, transform?: Transform): void;
    extendRangeXYZH(rangeToExtend: Range3d, transform?: Transform): void;
    abstract fractionToPointAndDerivatives(_fractionU: number, _fractionV: number, _result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;
    fractionToRigidFrame(fractionU: number, fractionV: number, result?: Transform): Transform | undefined;
    readonly geometryCategory = "bsurf";
    getPoint3dPole(i: number, j: number, result?: Point3d): Point3d | undefined;
    getPoint3dPoleXYZW(i: number, j: number, result?: Point3d): Point3d | undefined;
    isClosable(select: UVSelect): boolean;
    knots: KnotVector[];
    numberToUVSelect(value: number): UVSelect;
    numPolesTotal(): number;
    numPolesUV(select: UVSelect): number;
    numSpanUV(select: UVSelect): number;
    orderUV(select: UVSelect): number;
    protected _poleBuffer: Float64Array;
    protected _poleBuffer1UV: Float64Array[];
    poleDimension: number;
    poleStepUV(select: UVSelect): number;
    reverseInPlace(select: UVSelect): void;
    setWrappable(select: UVSelect, value: BSplineWrapMode): void;
    spanFractionsToBasisFunctions(select: UVSelect, spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array): void;
    spanFractionToKnot(select: UVSelect, span: number, localFraction: number): number;
    sumpoleBufferDerivativesForSpan(spanIndexU: number, spanIndexV: number): void;
    sumPoleBufferForSpan(spanIndexU: number, spanIndexV: number): void;
    static validOrderAndPoleCounts(orderU: number, numPolesU: number, orderV: number, numPolesV: number, numUV: number): boolean;
}

// @public
export class BSplineCurve3d extends BSplineCurve3dBase {
    clone(): BSplineCurve3d;
    cloneTransformed(transform: Transform): BSplineCurve3d;
    // @alpha
    computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap): void;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    copyKnots(includeExtraEndKnot: boolean): number[];
    copyPoints(): any[];
    copyPointsFloat64Array(): Float64Array;
    static create(poleArray: Float64Array | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3d | undefined;
    // (undocumented)
    static createThroughPoints(points: IndexedXYZCollection, order: number): BSplineCurve3d | undefined;
    static createUniformKnots(poles: Point3d[] | Float64Array | GrowableXYZArray, order: number): BSplineCurve3d | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number): Ray3d;
    evaluatePointInSpan(spanIndex: number, spanFraction: number): Point3d;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined;
    getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined;
    getSaturatedBezierSpan3d(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined;
    getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurve3dH | undefined;
    getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined;
    isAlmostEqual(other: any): boolean;
    get isClosable(): BSplineWrapMode;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    knotToPoint(u: number, result?: Point3d): Point3d;
    knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d;
    quickLength(): number;
    setWrappable(value: BSplineWrapMode): void;
    spanFractionToKnot(span: number, localFraction: number): number;
    tryTransformInPlace(transform: Transform): boolean;
    }

// @public
export abstract class BSplineCurve3dBase extends CurvePrimitive {
    protected constructor(poleDimension: number, numPoles: number, order: number, knots: KnotVector);
    appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number;
    protected _bcurve: BSpline1dNd;
    closestPoint(spacePoint: Point3d, _extend: boolean): CurveLocationDetail | undefined;
    collectBezierSpans(prefer3dH: boolean): BezierCurveBase[];
    copyKnots(includeExtraEndKnot: boolean): number[];
    readonly curvePrimitiveType = "bsplineCurve";
    get degree(): number;
    endPoint(): Point3d;
    abstract evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d;
    abstract evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    abstract getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined;
    abstract getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined;
    abstract getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined;
    abstract knotToPoint(knot: number, result?: Point3d): Point3d;
    abstract knotToPointAnd2Derivatives(knot: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    abstract knotToPointAndDerivative(knot: number, result?: Ray3d): Ray3d;
    get numPoles(): number;
    get numSpan(): number;
    get order(): number;
    poleIndexToDataIndex(poleIndex: number): number | undefined;
    reverseInPlace(): void;
    setWrappable(value: BSplineWrapMode): void;
    startPoint(): Point3d;
}

// @public
export class BSplineCurve3dH extends BSplineCurve3dBase {
    static assemblePackedXYZW(controlPoints: Float64Array | Point4d[] | {
        xyz: Float64Array;
        weights: Float64Array;
    } | Point3d[]): Float64Array | undefined;
    clone(): BSplineCurve3dH;
    cloneTransformed(transform: Transform): BSplineCurve3dH;
    computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap): void;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    copyPoints(): any[];
    copyPointsFloat64Array(): Float64Array;
    // (undocumented)
    copyWeightsFloat64Array(): Float64Array;
    copyXYZFloat64Array(deweighted: boolean): Float64Array;
    static create(controlPointData: Float64Array | Point4d[] | {
        xyz: Float64Array;
        weights: Float64Array;
    } | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3dH | undefined;
    static createUniformKnots(controlPoints: Point3d[] | Point4d[] | Float64Array, order: number): BSplineCurve3dH | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d;
    evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined;
    getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined;
    getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined;
    getSaturatedBezierSpan3dOr3dH(spanIndex: number, _prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined;
    isAlmostEqual(other: any): boolean;
    get isClosable(): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    knotToPoint(u: number, result?: Point3d): Point3d;
    knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d;
    quickLength(): number;
    spanFractionToKnot(span: number, localFraction: number): number;
    tryTransformInPlace(transform: Transform): boolean;
    }

// @public
export class BSplineSurface3d extends BSpline2dNd implements BSplineSurface3dQuery {
    clone(): BSplineSurface3d;
    cloneTransformed(transform: Transform): BSplineSurface3d;
    copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[];
    copyPointsFloat64Array(): Float64Array;
    static create(controlPointArray: Point3d[] | Float64Array, numPolesU: number, orderU: number, knotArrayU: number[] | Float64Array | undefined, numPolesV: number, orderV: number, knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined;
    static createGrid(points: number[][][], orderU: number, knotArrayU: number[] | Float64Array | undefined, orderV: number, knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fractionU: number, fractionV: number): Point3d;
    fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    getPointArray(flatArray?: boolean): any[];
    getPointGridJSON(): PackedPointGrid;
    getPole(i: number, j: number, result?: Point3d): Point3d | undefined;
    isAlmostEqual(other: any): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    knotToPoint(u: number, v: number): Point3d;
    knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export class BSplineSurface3dH extends BSpline2dNd implements BSplineSurface3dQuery {
    clone(): BSplineSurface3dH;
    cloneTransformed(transform: Transform): BSplineSurface3dH;
    copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[];
    copyPoints4d(): Point4d[];
    copyPointsAndWeights(points: Point3d[], weights: number[], formatter?: (x: number, y: number, z: number) => any): void;
    copyWeightsToFloat64Array(): Float64Array;
    copyXYZToFloat64Array(unweight: boolean): Float64Array;
    static create(controlPointArray: Point3d[] | Float64Array, weightArray: number[] | Float64Array, numPolesU: number, orderU: number, knotArrayU: number[] | Float64Array | undefined, numPolesV: number, orderV: number, knotArrayV: number[] | Float64Array | undefined): BSplineSurface3dH | undefined;
    static createGrid(xyzwGrid: number[][][], weightStyle: WeightStyle, orderU: number, knotArrayU: number[], orderV: number, knotArrayV: number[]): BSplineSurface3dH | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fractionU: number, fractionV: number, result?: Point3d): Point3d;
    fractionToPoint4d(fractionU: number, fractionV: number): Point4d;
    fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    getPointGridJSON(): PackedPointGrid;
    getPole(i: number, j: number, result?: Point3d): Point3d | undefined;
    isAlmostEqual(other: any): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    knotToPoint(knotU: number, knotV: number, result?: Point3d): Point3d;
    knotToPoint4d(u: number, v: number): Point4d;
    knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export interface BSplineSurface3dQuery {
    clone(): BSplineSurface3dQuery;
    cloneTransformed(transform: Transform): BSplineSurface3dQuery;
    degreeUV(select: UVSelect): number;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(uFraction: number, vFraction: number): Point3d;
    fractionToRigidFrame(uFraction: number, vFraction: number): Transform | undefined;
    getPointGridJSON(): PackedPointGrid;
    isAlmostEqual(other: any): boolean;
    isClosable(select: UVSelect): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    knotToPoint(uKnot: number, vKnot: number): Point3d;
    numberToUVSelect(value: number): UVSelect;
    numPolesTotal(): number;
    numPolesUV(select: UVSelect): number;
    numSpanUV(select: UVSelect): number;
    orderUV(select: UVSelect): number;
    poleStepUV(select: UVSelect): number;
    reverseInPlace(select: UVSelect): void;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export enum BSplineWrapMode {
    None = 0,
    OpenByAddingControlPoints = 1,
    OpenByRemovingKnots = 2
}

// @public
export type ChainTypes = CurvePrimitive | Path | BagOfCurves | Loop | undefined;

// @public
export enum ClipMaskXYZRangePlanes {
    All = 63,
    None = 0,
    XAndY = 15,
    XHigh = 2,
    XLow = 1,
    YHigh = 8,
    YLow = 4,
    ZHigh = 32,
    ZLow = 16
}

// @public
export class ClippedPolyfaceBuilders {
    buildClosureFaces?: boolean;
    builderA?: PolyfaceBuilder;
    builderB?: PolyfaceBuilder;
    // (undocumented)
    claimPolyface(selector: 0 | 1, fixup: boolean): IndexedPolyface | undefined;
    static create(keepInside?: boolean, keepOutside?: boolean, buildSideFaces?: boolean): ClippedPolyfaceBuilders;
}

// @public
export interface Clipper {
    announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;
    isPointOnOrInside(point: Point3d, tolerance?: number): boolean;
}

// @public
export class ClipPlane implements Clipper, PlaneAltitudeEvaluator, PolygonClipper {
    altitude(point: Point3d): number;
    altitudeXYZ(x: number, y: number, z: number): number;
    announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean;
    appendIntersectionRadians(arc: Arc3d, intersectionRadians: GrowableFloat64Array): void;
    appendPolygonClip(xyz: GrowableXYZArray, insideFragments: GrowableXYZArray[], outsideFragments: GrowableXYZArray[], arrayCache: GrowableXYZArrayCache): void;
    clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, inside?: boolean, tolerance?: number): number;
    clone(): ClipPlane;
    cloneNegated(): ClipPlane;
    static createEdgeAndUpVector(point0: Point3d, point1: Point3d, upVector: Vector3d, tiltAngle?: Angle, result?: ClipPlane): ClipPlane | undefined;
    static createEdgeXY(point0: Point3d, point1: Point3d, result?: ClipPlane): ClipPlane | undefined;
    static createNormalAndDistance(normal: Vector3d, distance: number, invisible?: boolean, interior?: boolean, result?: ClipPlane): ClipPlane | undefined;
    static createNormalAndPoint(normal: Vector3d, point: Point3d, invisible?: boolean, interior?: boolean, result?: ClipPlane): ClipPlane | undefined;
    static createNormalAndPointXYZXYZ(normalX: number, normalY: number, normalZ: number, originX: number, originY: number, originZ: number, invisible?: boolean, interior?: boolean, result?: ClipPlane): ClipPlane | undefined;
    static createPlane(plane: Plane3dByOriginAndUnitNormal, invisible?: boolean, interior?: boolean, result?: ClipPlane): ClipPlane;
    get distance(): number;
    dotProductPlaneNormalPoint(point: Point3d): number;
    static fromJSON(json: any, result?: ClipPlane): ClipPlane | undefined;
    getBoundedSegmentSimpleIntersection(pointA: Point3d, pointB: Point3d): number | undefined;
    getFrame(): Transform;
    getPlane3d(): Plane3dByOriginAndUnitNormal;
    getPlane4d(): Point4d;
    get interior(): boolean;
    intersectRange(range: Range3d, addClosurePoint?: boolean): GrowableXYZArray | undefined;
    get invisible(): boolean;
    get inwardNormalRef(): Vector3d;
    isAlmostEqual(other: ClipPlane): boolean;
    isPointInside(point: Point3d, tolerance?: number): boolean;
    isPointOn(point: Point3d, tolerance?: number): boolean;
    isPointOnOrInside(spacePoint: Point3d, tolerance?: number): boolean;
    multiplyPlaneByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    negateInPlace(): void;
    offsetDistance(offset: number): void;
    setFlags(invisible: boolean, interior: boolean): void;
    setInvisible(invisible: boolean): void;
    setPlane4d(plane: Point4d): void;
    toJSON(): any;
    transformInPlace(transform: Transform): boolean;
    velocity(vector: Vector3d): number;
    velocityXYZ(x: number, y: number, z: number): number;
    weightedAltitude(point: Point4d): number;
}

// @public
export enum ClipPlaneContainment {
    Ambiguous = 2,
    StronglyInside = 1,
    StronglyOutside = 3
}

// @public
export class ClipPrimitive {
    protected constructor(planeSet?: UnionOfConvexClipPlaneSets | undefined, isInvisible?: boolean);
    arePlanesDefined(): boolean;
    classifyPointContainment(points: Point3d[], ignoreInvisibleSetting: boolean): ClipPlaneContainment;
    protected _clipPlanes?: UnionOfConvexClipPlaneSets;
    clone(): ClipPrimitive;
    containsZClip(): boolean;
    static createCapture(planes: UnionOfConvexClipPlaneSets | ConvexClipPlaneSet | undefined, isInvisible?: boolean): ClipPrimitive;
    ensurePlaneSets(): void;
    fetchClipPlanesRef(): UnionOfConvexClipPlaneSets | undefined;
    static fromJSON(json: any): ClipPrimitive | undefined;
    static fromJSONClipPrimitive(json: any): ClipPrimitive | undefined;
    get invisible(): boolean;
    protected _invisible: boolean;
    multiplyPlanesByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    pointInside(point: Point3d, onTolerance?: number): boolean;
    setInvisible(invisible: boolean): void;
    toJSON(): any;
    transformInPlace(transform: Transform): boolean;
}

// @public
export class ClipShape extends ClipPrimitive {
    protected constructor(polygon?: Point3d[], zLow?: number, zHigh?: number, transform?: Transform, isMask?: boolean, invisible?: boolean);
    clone(result?: ClipShape): ClipShape;
    static createBlock(extremities: Range3d, clipMask: ClipMaskXYZRangePlanes, isMask?: boolean, invisible?: boolean, transform?: Transform, result?: ClipShape): ClipShape;
    static createEmpty(isMask?: boolean, invisible?: boolean, transform?: Transform, result?: ClipShape): ClipShape;
    static createFrom(other: ClipShape, result?: ClipShape): ClipShape;
    static createShape(polygon?: Point3d[], zLow?: number, zHigh?: number, transform?: Transform, isMask?: boolean, invisible?: boolean, result?: ClipShape): ClipShape | undefined;
    ensurePlaneSets(): void;
    static fromClipShapeJSON(json: any, result?: ClipShape): ClipShape | undefined;
    initSecondaryProps(isMask: boolean, zLow?: number, zHigh?: number, transform?: Transform): void;
    get invisible(): boolean;
    get isMask(): boolean;
    protected _isMask: boolean;
    get isValidPolygon(): boolean;
    get isXYPolygon(): boolean;
    multiplyPlanesByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    performTransformFromClip(point: Point3d): void;
    performTransformToClip(point: Point3d): void;
    get polygon(): Point3d[];
    protected _polygon: Point3d[];
    setPolygon(polygon: Point3d[]): void;
    toJSON(): any;
    get transformFromClip(): Transform | undefined;
    protected _transformFromClip?: Transform;
    transformInPlace(transform: Transform): boolean;
    get transformIsValid(): boolean;
    get transformToClip(): Transform | undefined;
    protected _transformToClip?: Transform;
    get transformValid(): boolean;
    get zHigh(): number | undefined;
    protected _zHigh?: number;
    get zHighValid(): boolean;
    get zLow(): number | undefined;
    protected _zLow?: number;
    get zLowValid(): boolean;
}

// @public
export enum ClipStatus {
    ClipRequired = 0,
    TrivialAccept = 2,
    TrivialReject = 1
}

// @public
export class ClipUtilities {
    static announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet | ClipPlane, range: Range3d, loopFunction: (loopPoints: GrowableXYZArray) => void, includeConvexSetFaces?: boolean, includeRangeFaces?: boolean, ignoreInvisiblePlanes?: boolean): void;
    static announceNNC(intervals: Range1d[], cp: CurvePrimitive, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    static captureOrDrop(data: GrowableXYZArray, minLength: number, destination: GrowableXYZArray[], cache: GrowableXYZArrayCache): void;
    static clipPolygonToClipShape(polygon: Point3d[], clipShape: ClipPrimitive): Point3d[][];
    static clipPolygonToClipShapeReturnGrowableXYZArrays(polygon: Point3d[], clipShape: ClipPrimitive): GrowableXYZArray[];
    static collectClippedCurves(curve: CurvePrimitive, clipper: Clipper): CurvePrimitive[];
    // @alpha
    static createXYOffsetClipFromLineString(points: Point3d[] | IndexedXYZCollection, leftOffset: number, rightOffset: number, z0: number, z1: number): UnionOfConvexClipPlaneSets;
    static doesClipperIntersectRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag?: boolean): boolean;
    static doesConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet, range: Range3d, includeConvexSetFaces?: boolean, includeRangeFaces?: boolean, ignoreInvisiblePlanes?: boolean): boolean;
    static isClipper(obj: any): boolean;
    static loopsOfConvexClipPlaneIntersectionWithRange(allClippers: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPlane, range: Range3d, includeConvexSetFaces?: boolean, includeRangeFaces?: boolean, ignoreInvisiblePlanes?: boolean): GeometryQuery[];
    static pointSetSingleClipStatus(points: GrowableXYZArray, planeSet: UnionOfConvexClipPlaneSets, tolerance: number): ClipStatus;
    static rangeOfClipperIntersectionWithRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag?: boolean): Range3d;
    static rangeOfConvexClipPlaneSetIntersectionWithRange(convexSet: ConvexClipPlaneSet, range: Range3d): Range3d;
    static restoreSingletonInPlaceOfMultipleShards(fragments: GrowableXYZArray[], baseCount: number, singleton: GrowableXYZArray, arrayCache: GrowableXYZArrayCache): void;
    static selectIntervals01(curve: CurvePrimitive, unsortedFractions: GrowableFloat64Array, clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    }

// @public
export class ClipVector {
    appendClone(clip: ClipPrimitive): void;
    appendReference(clip: ClipPrimitive): void;
    appendShape(shape: Point3d[], zLow?: number, zHigh?: number, transform?: Transform, isMask?: boolean, invisible?: boolean): boolean;
    boundingRange: Range3d;
    classifyPointContainment(points: Point3d[], ignoreMasks?: boolean): ClipPlaneContainment;
    classifyRangeContainment(range: Range3d, ignoreMasks: boolean): ClipPlaneContainment;
    clear(): void;
    get clips(): ClipPrimitive[];
    clone(result?: ClipVector): ClipVector;
    static create(clips: ClipPrimitive[], result?: ClipVector): ClipVector;
    static createCapture(clips: ClipPrimitive[], result?: ClipVector): ClipVector;
    static createEmpty(result?: ClipVector): ClipVector;
    extractBoundaryLoops(loopPoints: Point3d[][], transform?: Transform): number[];
    static fromJSON(json: any, result?: ClipVector): ClipVector;
    isAnyLineStringPointInside(points: Point3d[]): boolean;
    isLineStringCompletelyContained(points: Point3d[]): boolean;
    get isValid(): boolean;
    multiplyPlanesByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    parseClipPlanes(): void;
    pointInside(point: Point3d, onTolerance?: number): boolean;
    setInvisible(invisible: boolean): void;
    sumSizes(intervals: Segment1d[], begin: number, end: number): number;
    toJSON(): any;
    transformInPlace(transform: Transform): boolean;
}

// @internal
export class ClusterableArray extends GrowableBlockedArray {
    constructor(numCoordinatePerPoint: number, numExtraDataPerPoint: number, initialBlockCapacity: number);
    addBlock(data: number[]): void;
    addDirect(x0: number, x1: number, x2?: number, x3?: number, x4?: number): void;
    addPoint2d(xy: Point2d, a?: number, b?: number, c?: number): void;
    addPoint3d(xyz: Point3d, a?: number, b?: number, c?: number): void;
    static clusterGrowablePoint2dArray(source: GrowableXYArray, tolerance?: number): PackedPoint2dsWithIndex;
    static clusterGrowablePoint3dArray(source: GrowableXYZArray, tolerance?: number): PackedPointsWithIndex;
    clusterIndicesLexical(clusterTolerance?: number): Uint32Array;
    static clusterPoint3dArray(data: Point3d[], tolerance?: number): PackedPointsWithIndex;
    static readonly clusterTerminator = 4294967295;
    countClusters(clusteredBlocks: Uint32Array): number;
    createIndexBlockToClusterIndex(clusteredBlocks: Uint32Array): Uint32Array;
    createIndexBlockToClusterStart(clusteredBlocks: Uint32Array): Uint32Array;
    createIndexClusterToClusterStart(clusteredBlocks: Uint32Array): Uint32Array;
    getData(blockIndex: number, i: number): number;
    getExtraData(blockIndex: number, i: number): number;
    getPoint2d(blockIndex: number, result?: Point2d): Point2d;
    getPoint3d(blockIndex: number, result?: Point3d): Point3d;
    static isClusterTerminator(x: number): boolean;
    setExtraData(blockIndex: number, i: number, value: number): void;
    setupPrimaryClusterSort(): void;
    sortSubsetsBySingleKey(blockedIndices: Uint32Array, dataIndex: number): void;
    static sortVectorComponent(index: number): number;
    toJSON(): any[];
    }

// @internal
export function compareRange1dLexicalLowHigh(a: Range1d, b: Range1d): number;

// @internal
export class Complex implements BeJSONFunctions {
    constructor(x?: number, y?: number);
    angle(): Angle;
    clone(): Complex;
    static create(x?: number, y?: number, result?: Complex): Complex;
    distance(other: Complex): number;
    divide(other: Complex, result?: Complex): Complex | undefined;
    static fromJSON(json?: any): Complex;
    isAlmostEqual(other: Complex): boolean;
    magnitude(): number;
    magnitudeSquared(): number;
    minus(other: Complex, result?: Complex): Complex;
    plus(other: Complex, result?: Complex): Complex;
    set(x?: number, y?: number): void;
    setFrom(other: Complex): void;
    setFromJSON(json?: any): void;
    sqrt(result?: Complex): Complex;
    times(other: Complex, result?: Complex): Complex;
    timesXY(x: number, y: number, result?: Complex): Complex;
    toJSON(): any;
    get x(): number;
    set x(value: number);
    get y(): number;
    set y(value: number);
    }

// @public
export class Cone extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {
    protected constructor(map: Transform, radiusA: number, radiusB: number, capped: boolean);
    clone(): Cone;
    cloneTransformed(transform: Transform): Cone | undefined;
    constantVSection(vFraction: number): CurveCollection | undefined;
    static createAxisPoints(centerA: Point3d, centerB: Point3d, radiusA: number, radiusB: number, capped: boolean): Cone | undefined;
    static createBaseAndTarget(centerA: Point3d, centerB: Point3d, vectorX: Vector3d, vectorY: Vector3d, radiusA: number, radiusB: number, capped: boolean): Cone;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getCenterA(): Point3d;
    getCenterB(): Point3d;
    getConstructiveFrame(): Transform | undefined;
    getMaxRadius(): number;
    getRadiusA(): number;
    getRadiusB(): number;
    getVectorX(): Vector3d;
    getVectorY(): Vector3d;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    maxIsoParametricDistance(): Vector2d;
    readonly solidPrimitiveType = "cone";
    strokeConstantVSection(v: number, fixedStrokeCount: number | undefined, options: StrokeOptions | undefined): LineString3d;
    tryTransformInPlace(transform: Transform): boolean;
    uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    vFractionToRadius(v: number): number;
}

// @public
export class ConsolidateAdjacentCurvePrimitivesOptions {
    colinearPointTolerance: number;
    consolidateCompatibleArcs: boolean;
    consolidateLinearGeometry: boolean;
    duplicatePointTolerance: number;
}

// @alpha
export class Constant {
    static readonly circumferenceOfEarth: number;
    static readonly diameterOfEarth: number;
    static readonly earthRadiusWGS84: {
        polar: number;
        equator: number;
    };
    static readonly oneCentimeter: number;
    static readonly oneKilometer: number;
    static readonly oneMeter: number;
    static readonly oneMillimeter: number;
}

// @public
export class ConstructCurveBetweenCurves extends NullGeometryHandler {
    handleArc3d(arc0: Arc3d): any;
    handleLineSegment3d(segment0: LineSegment3d): any;
    handleLineString3d(ls0: LineString3d): any;
    static interpolateBetween(geometry0: GeometryQuery, fraction: number, geometry1: GeometryQuery): GeometryQuery | undefined;
}

// @public
export class ConvexClipPlaneSet implements Clipper, PolygonClipper {
    addPlaneToConvexSet(plane: ClipPlane | undefined): void;
    addZClipPlanes(invisible: boolean, zLow?: number, zHigh?: number): void;
    announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;
    appendPolygonClip(xyz: GrowableXYZArray, insideFragments: GrowableXYZArray[], outsideFragments: GrowableXYZArray[], arrayCache: GrowableXYZArrayCache): void;
    classifyPointContainment(points: Point3d[], onIsOutside: boolean): ClipPlaneContainment;
    clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, tolerance?: number): void;
    clipInsidePushOutside(xyz: GrowableXYZArray, outsideFragments: GrowableXYZArray[] | undefined, arrayCache: GrowableXYZArrayCache): GrowableXYZArray | undefined;
    clipPointsOnOrInside(points: Point3d[], inOrOn: Point3d[], out: Point3d[]): void;
    clipUnboundedSegment(pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;
    clone(result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    computePlanePlanePlaneIntersections(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment?: boolean): number;
    static createEmpty(result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    static createPlanes(planes: ClipPlane[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    static createRange3dPlanes(range: Range3d, lowX?: boolean, highX?: boolean, lowY?: boolean, highY?: boolean, lowZ?: boolean, highZ?: boolean): ConvexClipPlaneSet;
    static createSweptPolyline(points: Point3d[], upVector: Vector3d, tiltAngle?: Angle): ConvexClipPlaneSet | undefined;
    static createXYBox(x0: number, y0: number, x1: number, y1: number, result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    static createXYPolyLine(points: Point3d[], interior: boolean[], leftIsInside: boolean, result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    static createXYPolyLineInsideLeft(points: Point3d[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    static fromJSON(json: any, result?: ConvexClipPlaneSet): ConvexClipPlaneSet;
    hasIntersectionWithRay(ray: Ray3d, result?: Range1d): boolean;
    static readonly hugeVal = 1e+37;
    isAlmostEqual(other: ConvexClipPlaneSet): boolean;
    isPointInside(point: Point3d): boolean;
    isPointOnOrInside(point: Point3d, tolerance: number): boolean;
    isSphereInside(centerPoint: Point3d, radius: number): boolean;
    multiplyPlanesByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    negateAllPlanes(): void;
    get planes(): ClipPlane[];
    polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray, work: GrowableXYZArray, planeToSkip?: ClipPlane): void;
    reloadSweptPolygon(points: Point3d[], sweepDirection: Vector3d, sideSelect: number): number;
    setInvisible(invisible: boolean): void;
    static setPlaneAndXYLoopCCW(points: GrowableXYZArray, planeOfPolygon: ClipPlane, frustum: ConvexClipPlaneSet): void;
    toJSON(): any;
    transformInPlace(transform: Transform): void;
}

// @internal
export class ConvexPolygon2d {
    constructor(points: Point2d[] | undefined);
    clipRay(ray: Ray2d): Range1d;
    static computeConvexHull(points: Point2d[]): Point2d[] | undefined;
    containsPoint(point: Point2d): boolean;
    static createHull(points: Point2d[]): ConvexPolygon2d;
    static createHullIsValidCheck(points: Point2d[]): ConvexPolygon2d;
    distanceOutside(xy: Point2d): number;
    static isValidConvexHull(points: Point2d[]): boolean;
    offsetInPlace(distance: number): boolean;
    get points(): Point2d[];
    rangeAlongRay(ray: Ray2d): Range1d;
    rangePerpendicularToRay(ray: Ray2d): Range1d;
}

// @public
export class CoordinateXYZ extends GeometryQuery {
    clone(): GeometryQuery | undefined;
    cloneTransformed(transform: Transform): GeometryQuery | undefined;
    static create(point: Point3d): CoordinateXYZ;
    static createXYZ(x?: number, y?: number, z?: number): CoordinateXYZ;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    readonly geometryCategory = "point";
    isAlmostEqual(other: GeometryQuery): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    get point(): Point3d;
    range(): Range3d;
    tryTransformInPlace(transform: Transform): boolean;
    }

// @public
export abstract class CurveChain extends CurveCollection {
    protected constructor();
    get children(): CurvePrimitive[];
    abstract cloneStroked(options?: StrokeOptions): AnyCurve;
    protected _curves: CurvePrimitive[];
    cyclicCurvePrimitive(index: number, cyclic?: boolean): CurvePrimitive | undefined;
    extendRange(range: Range3d, transform?: Transform): void;
    getChild(i: number): CurvePrimitive | undefined;
    getPackedStrokes(options?: StrokeOptions): GrowableXYZArray | undefined;
    primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(index: number, fraction: number, cyclic?: boolean, result?: CurveLocationDetail): CurveLocationDetail | undefined;
    reverseChildrenInPlace(): void;
    tryAddChild(child: AnyCurve | undefined): boolean;
}

// @internal
export class CurveChainWireOffsetContext {
    constructor();
    static applyBasePoints(cp: CurvePrimitive | undefined, startPoint: Point3d | undefined, endPoint: Point3d | undefined): CurvePrimitive | undefined;
    static constructCurveXYOffset(curves: Path | Loop, offsetDistanceOrOptions: number | JointOptions): CurveCollection | undefined;
    static createSingleOffsetPrimitiveXY(g: CurvePrimitive, distanceLeft: number): CurvePrimitive | CurvePrimitive[] | undefined;
    }

// @public
export class CurveChainWithDistanceIndex extends CurvePrimitive {
    chainDistanceToChainFraction(distance: number): number;
    protected chainDistanceToFragment(distance: number, allowExtrapolation?: boolean): PathFragment | undefined;
    clone(): CurvePrimitive | undefined;
    cloneTransformed(transform: Transform): CurvePrimitive | undefined;
    closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter): CurveLocationDetail | undefined;
    collectCurvePrimitivesGo(collectorArray: CurvePrimitive[], smallestPossiblePrimitives: boolean): void;
    computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap): void;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    static createCapture(path: CurveChain, options?: StrokeOptions): CurveChainWithDistanceIndex | undefined;
    protected curveAndChildFractionToFragment(curve: CurvePrimitive, fraction: number): PathFragment | undefined;
    curveLength(): number;
    curveLengthBetweenFractions(fraction0: number, fraction1: number): number;
    readonly curvePrimitiveType = "curveChainWithDistanceIndex";
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(result?: Point3d): Point3d;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d;
    isAlmostEqual(other: GeometryQuery): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail;
    get path(): CurveChain;
    quickLength(): number;
    reverseInPlace(): void;
    startPoint(result?: Point3d): Point3d;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export abstract class CurveCollection extends GeometryQuery {
    abstract announceToCurveProcessor(processor: RecursiveCurveProcessor): void;
    checkForNonLinearPrimitives(): boolean;
    clone(): CurveCollection | undefined;
    abstract cloneEmptyPeer(): CurveCollection;
    abstract cloneStroked(options?: StrokeOptions): AnyCurve;
    cloneTransformed(transform: Transform): CurveCollection | undefined;
    cloneWithExpandedLineStrings(): CurveCollection | undefined;
    closestPoint(spacePoint: Point3d): CurveLocationDetail | undefined;
    collectCurvePrimitives(collectorArray?: CurvePrimitive[], smallestPossiblePrimitives?: boolean, explodeLineStrings?: boolean): CurvePrimitive[];
    static createCurveLocationDetailOnAnyCurvePrimitive(source: GeometryQuery | undefined, fraction?: number): CurveLocationDetail | undefined;
    abstract readonly curveCollectionType: CurveCollectionType;
    abstract dgnBoundaryType(): number;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    readonly geometryCategory = "curveCollection";
    abstract getChild(i: number): AnyCurve | undefined;
    get isAnyRegionType(): boolean;
    get isClosedPath(): boolean;
    isInner: boolean;
    get isOpenPath(): boolean;
    maxGap(): number;
    sumLengths(): number;
    abstract tryAddChild(child: AnyCurve | undefined): boolean;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export type CurveCollectionType = "loop" | "path" | "unionRegion" | "parityRegion" | "bagOfCurves";

// @public
export class CurveCurve {
    static allIntersectionsAmongPrimitivesXY(primitives: CurvePrimitive[]): CurveLocationDetailPair[];
    static closeApproachProjectedXYPairs(geometryA: GeometryQuery, geometryB: GeometryQuery, maxDistance: number): CurveLocationDetailPair[];
    static intersectionProjectedXYPairs(worldToLocal: Matrix4d, geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailPair[];
    static intersectionXYPairs(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailPair[];
    // @beta
    static intersectionXYZ(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair;
}

// @public
export enum CurveCurveApproachType {
    CoincidentGeometry = 2,
    Intersection = 0,
    ParallelGeometry = 3,
    PerpendicularChord = 1
}

// @internal
export class CurveCurveIntersectXY extends NullGeometryHandler {
    constructor(worldToLocal: Matrix4d | undefined, _geometryA: GeometryQuery | undefined, extendA: boolean, geometryB: GeometryQuery | undefined, extendB: boolean);
    computeArcLineString(arcA: Arc3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any;
    computeSegmentLineString(lsA: LineSegment3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any;
    dispatchLineStringBSplineCurve(lsA: LineString3d, extendA: boolean, curveB: BSplineCurve3d, extendB: boolean, reversed: boolean): any;
    grabPairedResults(reinitialize?: boolean): CurveLocationDetailPair[];
    handleArc3d(arc0: Arc3d): any;
    handleBSplineCurve3d(curve: BSplineCurve3d): any;
    handleBSplineCurve3dH(_curve: BSplineCurve3dH): any;
    handleLineSegment3d(segmentA: LineSegment3d): any;
    handleLineString3d(lsA: LineString3d): any;
    recordPairs(cpA: CurvePrimitive, cpB: CurvePrimitive, pairs: CurveLocationDetailPair[] | undefined, reversed: boolean): void;
    resetGeometry(_geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): void;
    }

// @internal
export class CurveCurveIntersectXYZ extends NullGeometryHandler {
    constructor(_geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean);
    computeArcLineString(arcA: Arc3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any;
    computeSegmentLineString(lsA: LineSegment3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any;
    createPlaneWithPreferredPerpendicular(origin: Point3d, vectorA: Vector3d, cosineValue: number, vectorB: Vector3d, vectorC: Vector3d): Plane3dByOriginAndUnitNormal | undefined;
    dispatchLineStringBSplineCurve(_lsA: LineString3d, _extendA: boolean, _curveB: BSplineCurve3d, _extendB: boolean, _reversed: boolean): any;
    grabResults(reinitialize?: boolean): CurveLocationDetailArrayPair;
    handleArc3d(arc0: Arc3d): any;
    handleBSplineCurve3d(curve: BSplineCurve3d): any;
    handleBSplineCurve3dH(_curve: BSplineCurve3dH): any;
    handleLineSegment3d(segmentA: LineSegment3d): any;
    handleLineString3d(lsA: LineString3d): any;
    }

// @public
export enum CurveExtendMode {
    None = 0,
    OnCurve = 2,
    OnTangent = 1
}

// @public
export class CurveExtendOptions {
    static correctFraction(extendParam: VariantCurveExtendParameter, fraction: number): number;
    static resolveRadiansToSweepFraction(extendParam: VariantCurveExtendParameter, radians: number, sweep: AngleSweep): number;
    static resolveVariantCurveExtendParameterToCurveExtendMode(param: VariantCurveExtendParameter, endIndex: 0 | 1): CurveExtendMode;
}

// @public
export class CurveFactory {
    static appendToArcInPlace(arcA: Arc3d, arcB: Arc3d, allowReverse?: boolean): boolean;
    static assembleArcChainOnEllipsoid(ellipsoid: Ellipsoid, pathPoints: GeodesicPathPoint[], fractionForIntermediateNormal?: number): Path;
    static createArcPointTangentPoint(pointA: Point3d, tangentA: Vector3d, pointB: Point3d): Arc3d | undefined;
    static createArcPointTangentRadius(pointA: Point3d, tangentA: Vector3d, radius: number, upVector?: Vector3d, sweep?: Angle | AngleSweep): Arc3d | undefined;
    static createFilletsInLineString(points: LineString3d | IndexedXYZCollection | Point3d[], radius: number | number[], allowBackupAlongEdge?: boolean): Path | undefined;
    static createLineSpiralArcSpiralLine(spiralType: IntegratedSpiralTypeName, pointA: Point3d, pointB: Point3d, pointC: Point3d, lengthA: number, lengthB: number, arcRadius: number): GeometryQuery[] | undefined;
    static createLineSpiralSpiralLine(spiralType: IntegratedSpiralTypeName, startPoint: Point3d, shoulderPoint: Point3d, targetPoint: Point3d): GeometryQuery[] | undefined;
    static createLineSpiralSpiralLineWithSpiralLength(spiralType: IntegratedSpiralTypeName, pointA: Point3d, pointB: Point3d, pointC: Point3d, spiralLength: number): GeometryQuery[] | undefined;
    static createMiteredPipeSections(centerline: IndexedXYZCollection, radius: number): Arc3d[];
    static createPipeSegments(centerline: CurvePrimitive | CurveChain, pipeRadius: number): GeometryQuery | GeometryQuery[] | undefined;
    static createRectangleXY(x0: number, y0: number, x1: number, y1: number, z?: number, filletRadius?: number): Loop;
}

// @public
export enum CurveIntervalRole {
    intervalEnd = 12,
    intervalInterior = 11,
    intervalStart = 10,
    isolated = 0,
    isolatedAtVertex = 1
}

// @public
export class CurveLocationDetail {
    constructor();
    a: number;
    captureFraction1Point1(fraction1: number, point1: Point3d): void;
    childDetail?: CurveLocationDetail;
    static chooseSmallerA(detailA: CurveLocationDetail | undefined, detailB: CurveLocationDetail | undefined): CurveLocationDetail | undefined;
    clone(result?: CurveLocationDetail): CurveLocationDetail;
    collapseToEnd(): void;
    collapseToStart(): void;
    static create(curve?: CurvePrimitive, result?: CurveLocationDetail): CurveLocationDetail;
    static createConditionalMoveSignedDistance(allowExtension: boolean, curve: CurvePrimitive, startFraction: number, endFraction: number, requestedSignedDistance: number, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveEvaluatedFraction(curve: CurvePrimitive, fraction: number, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveEvaluatedFractionFraction(curve: CurvePrimitive, fraction0: number, fraction1: number, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveEvaluatedFractionPointAndDerivative(curve: CurvePrimitive, fraction: number, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveFractionPoint(curve: CurvePrimitive | undefined, fraction: number, point: Point3d, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveFractionPointDistance(curve: CurvePrimitive, fraction: number, point: Point3d, a: number, result?: CurveLocationDetail): CurveLocationDetail;
    static createCurveFractionPointDistanceCurveSearchStatus(curve: CurvePrimitive | undefined, fraction: number, point: Point3d, distance: number, status: CurveSearchStatus, result?: CurveLocationDetail): CurveLocationDetail;
    static createRayFractionPoint(ray: Ray3d, fraction: number, point: Point3d, result?: CurveLocationDetail): CurveLocationDetail;
    curve?: CurvePrimitive;
    curveSearchStatus?: CurveSearchStatus;
    fraction: number;
    fraction1?: number;
    get fractionDelta(): number;
    get hasFraction1(): boolean;
    intervalRole?: CurveIntervalRole;
    inverseInterpolateFraction(f: number, defaultFraction?: number): number;
    get isIsolated(): boolean;
    point: Point3d;
    point1?: Point3d;
    pointQ: Point3d;
    ray?: Ray3d;
    setCurve(curve: CurvePrimitive): void;
    setDistanceTo(point: Point3d): void;
    setFP(fraction: number, point: Point3d, vector?: Vector3d, a?: number): void;
    setFR(fraction: number, ray: Ray3d, a?: number): void;
    setIntervalRole(value: CurveIntervalRole): void;
    swapFractionsAndPoints(): void;
    updateIfCloserCurveFractionPointDistance(curve: CurvePrimitive, fraction: number, point: Point3d, a: number): boolean;
    vectorInCurveLocationDetail?: Vector3d;
}

// @public
export class CurveLocationDetailArrayPair {
    constructor();
    dataA: CurveLocationDetail[];
    dataB: CurveLocationDetail[];
}

// @public
export class CurveLocationDetailPair {
    constructor(detailA?: CurveLocationDetail, detailB?: CurveLocationDetail);
    approachType?: CurveCurveApproachType;
    clone(result?: CurveLocationDetailPair): CurveLocationDetailPair;
    static createCapture(detailA: CurveLocationDetail, detailB: CurveLocationDetail, result?: CurveLocationDetailPair): CurveLocationDetailPair;
    static createCaptureOptionalReverse(detailA: CurveLocationDetail, detailB: CurveLocationDetail, reversed: boolean, result?: CurveLocationDetailPair): CurveLocationDetailPair;
    detailA: CurveLocationDetail;
    detailB: CurveLocationDetail;
    swapDetails(): void;
}

// @public
export abstract class CurvePrimitive extends GeometryQuery {
    protected constructor();
    addMappedStrokesToLineString3D(map: StrokeCountMap, linestring: LineString3d): number;
    announceClipIntervals(_clipper: Clipper, _announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number;
    clonePartialCurve(_fractionA: number, _fractionB: number): CurvePrimitive | undefined;
    closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter): CurveLocationDetail | undefined;
    collectCurvePrimitives(collectorArray?: CurvePrimitive[], smallestPossiblePrimitives?: boolean, explodeLinestrings?: boolean): CurvePrimitive[];
    collectCurvePrimitivesGo(collectorArray: CurvePrimitive[], _smallestPossiblePrimitives: boolean, _explodeLinestrings?: boolean): void;
    computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentMap?: StrokeCountMap): void;
    abstract computeStrokeCountForOptions(options?: StrokeOptions): number;
    curveLength(): number;
    curveLengthBetweenFractions(fraction0: number, fraction1: number): number;
    curveLengthWithFixedIntervalCountQuadrature(fraction0: number, fraction1: number, numInterval: number, numGauss?: number): number;
    abstract readonly curvePrimitiveType: CurvePrimitiveType;
    abstract emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;
    abstract emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    // @internal
    endCut?: CurveLocationDetail;
    endPoint(result?: Point3d): Point3d;
    fractionAndDistanceToPointOnTangent(fraction: number, distance: number): Point3d;
    fractionToCurvature(fraction: number): number | undefined;
    fractionToFrenetFrame(fraction: number, result?: Transform): Transform | undefined;
    abstract fractionToPoint(fraction: number, result?: Point3d): Point3d;
    abstract fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;
    abstract fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d;
    readonly geometryCategory = "curvePrimitive";
    getFractionToDistanceScale(): number | undefined;
    static installStrokeCountMap(curve: CurvePrimitive, curveMap: StrokeCountMap, parentMap?: StrokeCountMap): void;
    get isExtensibleFractionSpace(): boolean;
    abstract isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail;
    protected moveSignedDistanceFromFractionGeneric(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail;
    parent?: any;
    abstract quickLength(): number;
    abstract reverseInPlace(): void;
    // @internal
    static snapAndRestrictDetails(details: CurveLocationDetail[], allowExtend?: boolean, applySnappedCoordinates?: boolean, startEndFractionTolerance?: number, startEndXYZTolerance?: number): void;
    // @internal
    startCut?: CurveLocationDetail;
    startPoint(result?: Point3d): Point3d;
    strokeData?: StrokeCountMap;
}

// @public
export type CurvePrimitiveMutator = (primitiveA: CurvePrimitive, primitiveB: CurvePrimitive) => CurvePrimitive | undefined;

// @public
export type CurvePrimitiveType = "arc" | "lineSegment" | "lineString" | "bsplineCurve" | "bezierCurve" | "transitionSpiral" | "curveChainWithDistanceIndex";

// @public
export enum CurveSearchStatus {
    error = 0,
    stoppedAtBoundary = 2,
    success = 1
}

// @internal
export class CutLoop {
    constructor(xyz: GrowableXYZArray);
    absorb(other: CutLoop): void;
    back(result?: Point3d): Point3d;
    containsSortLimits(other: CutLoop): number;
    static createCaptureWithReturnEdge(xyz: GrowableXYZArray): CutLoop;
    // (undocumented)
    edge?: Ray3d;
    front(result?: Point3d): Point3d;
    // (undocumented)
    isNotch: boolean;
    setSortCoordinates(ray: Ray3d): void;
    // (undocumented)
    sortCoordinate0: number;
    // (undocumented)
    sortCoordinate1: number;
    // (undocumented)
    sortDelta: number;
    static sortFunction(loopA: CutLoop, loopB: CutLoop): number;
    // (undocumented)
    xyz: GrowableXYZArray;
}

// @internal
export class CutLoopMergeContext {
    constructor();
    inputLoops: CutLoop[];
    outputLoops: CutLoop[];
    sortAndMergeLoops(): void;
    }

// @internal
export class DeepCompare {
    constructor(numberRelTol?: number);
    compare(a: any, b: any, tolerance?: number): boolean;
    compareNumber(_a: number, _b: number): boolean;
    errorTracker: any[];
    numberRelTol: number;
    propertyCounts: {
        [key: string]: any;
    };
    typeCounts: {
        numbers: number;
        arrays: number;
        functions: number;
        objects: number;
        strings: number;
        booleans: number;
        undefined: number;
    };
}

// @internal
export class Degree2PowerPolynomial {
    constructor(c0?: number, c1?: number, c2?: number);
    addConstant(a: number): void;
    addSquaredLinearTerm(a: number, b: number, s?: number): void;
    coffs: number[];
    evaluate(x: number): number;
    evaluateDerivative(x: number): number;
    static fromRootsAndC2(root0: number, root1: number, c2?: number): Degree2PowerPolynomial;
    realRoots(): number[] | undefined;
    static solveQuadratic(a: number, b: number, c: number): number[] | undefined;
    tryGetVertexFactorization(): {
        x0: number;
        y0: number;
        c: number;
    } | undefined;
}

// @internal
export class Degree3PowerPolynomial {
    constructor(c0?: number, c1?: number, c2?: number, c3?: number);
    addConstant(a: number): void;
    addSquaredLinearTerm(a: number, b: number, s?: number): void;
    coffs: number[];
    evaluate(x: number): number;
    evaluateDerivative(x: number): number;
    static fromRootsAndC3(root0: number, root1: number, root2: number, c3?: number): Degree3PowerPolynomial;
}

// @internal
export class Degree4PowerPolynomial {
    constructor(c0?: number, c1?: number, c2?: number, c3?: number, c4?: number);
    addConstant(a: number): void;
    coffs: number[];
    evaluate(x: number): number;
    evaluateDerivative(x: number): number;
    static fromRootsAndC4(root0: number, root1: number, root2: number, root3: number, c4?: number): Degree4PowerPolynomial;
}

// @public
export class DirectSpiral3d extends TransitionSpiral3d {
    constructor(localToWorld: Transform, spiralType: string | undefined, originalProperties: TransitionConditionalProperties | undefined, nominalL1: number, nominalR1: number, activeFractionInterval: Segment1d | undefined, evaluator: XYCurveEvaluator);
    get activeStrokes(): LineString3d;
    clone(): DirectSpiral3d;
    cloneTransformed(transform: Transform): DirectSpiral3d;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    static createArema(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    static createAustralianRail(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    static createChineseCubic(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    static createCzechCubic(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    // (undocumented)
    static createDirectHalfCosine(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    static createFromLengthAndRadius(spiralType: string, radius0: number | undefined, radius1: number | undefined, bearing0: Angle | undefined, _bearing1: Angle | undefined, arcLength: number | undefined, activeInterval: undefined | Segment1d, localToWorld: Transform): TransitionSpiral3d | undefined;
    static createJapaneseCubic(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    static createTruncatedClothoid(spiralType: string, localToWorld: Transform, numXTerm: number, numYTerm: number, originalProperties: TransitionConditionalProperties | undefined, nominalL1: number, nominalR1: number, activeInterval: Segment1d | undefined): DirectSpiral3d | undefined;
    static createWesternAustralian(localToWorld: Transform, nominalL1: number, nominalR1: number, activeInterval?: Segment1d): DirectSpiral3d | undefined;
    curveLength(): number;
    readonly curvePrimitiveType = "transitionSpiral";
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(): Point3d;
    // @internal
    get evaluator(): XYCurveEvaluator;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToPoint(activeFraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(activeFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;
    fractionToPointAndDerivative(activeFraction: number, result?: Ray3d): Ray3d;
    isAlmostEqual(other: any): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    get nominalL1(): number;
    get nominalR1(): number;
    quickLength(): number;
    refreshComputedProperties(): void;
    reverseInPlace(): void;
    startPoint(): Point3d;
    tryTransformInPlace(transformA: Transform): boolean;
}

// @public
export type DirectSpiralTypeName = "Arema" | "JapaneseCubic" | "Arema" | "ChineseCubic" | "HalfCosine" | "AustralianRailCorp" | "WesterAustralian" | "Czech";

// @public
export enum DuplicateFacetClusterSelector {
    SelectAll = 2,
    SelectAny = 1,
    SelectNone = 0,
    SelectOneByParity = 3
}

// @public
export class Ellipsoid implements Clipper {
    anglePairToGreatArc(angleA: LongitudeLatitudeNumber, angleB: LongitudeLatitudeNumber, result?: Arc3d): Arc3d | undefined;
    announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;
    clone(): Ellipsoid;
    cloneTransformed(transform: Transform): Ellipsoid | undefined;
    constantLatitudeArc(longitudeSweep: AngleSweep, latitude: Angle, result?: Arc3d): Arc3d | undefined;
    constantLongitudeArc(longitude: Angle, latitudeSweep: AngleSweep, result?: Arc3d): Arc3d | undefined;
    static create(matrixOrTransform?: Transform | Matrix3d): Ellipsoid;
    static createCenterMatrixRadii(center: Point3d, axes: Matrix3d | undefined, radiusX: number, radiusY: number, radiusZ: number): Ellipsoid;
    createPlaneSection(plane: Plane3dByOriginAndUnitNormal): Arc3d | undefined;
    createSectionArcPointPointVectorInPlane(pointAnglesA: LongitudeLatitudeNumber, pointAnglesB: LongitudeLatitudeNumber, inPlaneVector: Vector3d, result?: Arc3d): Arc3d | undefined;
    intersectRay(ray: Ray3d, rayFractions: number[] | undefined, xyz: Point3d[] | undefined, thetaPhiRadians: LongitudeLatitudeNumber[] | undefined): number;
    isAlmostEqual(other: Ellipsoid): boolean;
    isPointOnOrInside(point: Point3d): boolean;
    localToWorld(localPoint: XYAndZ, result?: Point3d): Point3d;
    otherEllipsoidAnglesToThisEllipsoidAngles(otherEllipsoid: Ellipsoid | undefined, otherAngles: LongitudeLatitudeNumber, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber | undefined;
    patchRangeStartEndRadians(theta0Radians: number, theta1Radians: number, phi0Radians: number, phi1Radians: number, result?: Range3d): Range3d;
    projectPointToSurface(spacePoint: Point3d): LongitudeLatitudeNumber | undefined;
    radiansPairToEquatorialEllipsoid(thetaARadians: number, phiARadians: number, thetaBRadians: number, phiBRadians: number, result?: Ellipsoid): Ellipsoid | undefined;
    radiansPairToGreatArc(thetaARadians: number, phiARadians: number, thetaBRadians: number, phiBRadians: number, result?: Arc3d): Arc3d | undefined;
    radiansToFrenetFrame(thetaRadians: number, phiRadians: number, result?: Transform): Transform | undefined;
    radiansToPoint(thetaRadians: number, phiRadians: number, result?: Point3d): Point3d;
    radiansToPointAnd2Derivatives(thetaRadians: number, phiRadians: number, point: Point3d, d1Theta: Vector3d, d1Phi: Vector3d, d2ThetaTheta: Vector3d, d2PhiPhi: Vector3d, d2ThetaPhi: Vector3d): void;
    radiansToPointAndDerivatives(thetaRadians: number, phiRadians: number, applyCosPhiFactor?: boolean, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    radiansToUnitNormalRay(thetaRadians: number, phiRadians: number, result?: Ray3d): Ray3d | undefined;
    static radiansToUnitNormalRay(ellipsoid: Ellipsoid | undefined, thetaRadians: number, phiRadians: number, result?: Ray3d): Ray3d | undefined;
    sectionArcWithIntermediateNormal(angleA: LongitudeLatitudeNumber, intermediateNormalFraction: number, angleB: LongitudeLatitudeNumber): Arc3d;
    silhouetteArc(eyePoint: Point4d): Arc3d | undefined;
    surfaceNormalToAngles(normal: Vector3d, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber;
    get transformRef(): Transform;
    tryTransformInPlace(transform: Transform): boolean;
    worldToLocal(worldPoint: XYAndZ, result?: Point3d): Point3d | undefined;
}

// @public
export class EllipsoidPatch implements UVSurface {
    anglesToUnitNormalRay(position: LongitudeLatitudeNumber, result?: Ray3d): Ray3d | undefined;
    containsAngles(position: LongitudeLatitudeNumber, allowPeriodicLongitude?: boolean): boolean;
    static createCapture(ellipsoid: Ellipsoid, longitudeSweep: AngleSweep, latitudeSweep: AngleSweep): EllipsoidPatch;
    // (undocumented)
    ellipsoid: Ellipsoid;
    intersectRay(ray: Ray3d, restrictToPatch: boolean, convertIntersectionRadiansToFractions?: boolean): CurveAndSurfaceLocationDetail[];
    // (undocumented)
    latitudeSweep: AngleSweep;
    // (undocumented)
    longitudeSweep: AngleSweep;
    projectPointToSurface(spacePoint: Point3d): LongitudeLatitudeNumber | undefined;
    range(result?: Range3d): Range3d;
    uvFractionToAngles(longitudeFraction: number, phiFraction: number, h?: number, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber;
    uvFractionToPoint(longitudeFraction: number, latitudeFraction: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(longitudeFraction: number, latitudeFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
}

// @public
export class FacetFaceData {
    clone(result?: FacetFaceData): FacetFaceData;
    convertParamToDistance(param: Point2d, result?: Point2d): Point2d;
    convertParamToNormalized(param: Point2d, result?: Point2d): Point2d;
    convertParamXYToDistance(x: number, y: number, result?: Point2d): Point2d;
    convertParamXYToNormalized(x: number, y: number, result?: Point2d): Point2d;
    static createNull(): FacetFaceData;
    get paramDistanceRange(): Range2d;
    get paramRange(): Range2d;
    scaleDistances(distanceScale: number): void;
    setNull(): void;
    setParamDistanceRangeFromNewFaceData(polyface: IndexedPolyface, facetStart: number, facetEnd: number): boolean;
}

// @public
export interface FacetProjectedVolumeSums {
    negativeProjectedFacetAreaMoments?: MomentData;
    positiveProjectedFacetAreaMoments?: MomentData;
    volume: number;
}

// @public
export class FrameBuilder {
    constructor();
    announce(data: any): void;
    announcePoint(point: Point3d): number;
    announceVector(vector: Vector3d): number;
    applyDefaultUpVector(vector?: Vector3d): void;
    clear(): void;
    static createFrameToDistantPoints(points: Point3d[]): Transform | undefined;
    static createFrameWithCCWPolygon(points: Point3d[]): Transform | undefined;
    static createLocalToWorldTransformInRange(range: Range3d, scaleSelect?: AxisScaleSelect, fractionX?: number, fractionY?: number, fractionZ?: number, defaultAxisLength?: number): Transform;
    static createRightHandedFrame(defaultUpVector: Vector3d | undefined, ...params: any[]): Transform | undefined;
    static createRightHandedLocalToWorld(...params: any[]): Transform | undefined;
    getValidatedFrame(allowLeftHanded?: boolean): Transform | undefined;
    get hasOrigin(): boolean;
    savedVectorCount(): number;
    }

// @internal
export class GaussMapper {
    constructor(numGaussPoints: number);
    gaussW: Float64Array;
    gaussX: Float64Array;
    mapXAndW(xA: number, xB: number): number;
    mapXAndWFunction: (xA: number, xB: number, xx: Float64Array, ww: Float64Array) => number;
}

// @public
export class GeodesicPathPoint {
    constructor();
    // (undocumented)
    d1Cross: Vector3d;
    // (undocumented)
    d2Phi: Vector3d;
    // (undocumented)
    d2Theta: Vector3d;
    // (undocumented)
    d2ThetaPhi: Vector3d;
    // (undocumented)
    dPhi: Vector3d;
    // (undocumented)
    dTheta: Vector3d;
    evaluateDerivativesAtCurrentAngles(ellipsoid: Ellipsoid): void;
    static evaluateNewtonFunction(pointA: GeodesicPathPoint, pointB: GeodesicPathPoint, pointC: GeodesicPathPoint, values: Float64Array): void;
    phiRadians: number;
    // (undocumented)
    point: Point3d;
    thetaRadians: number;
    toAngles(): LongitudeLatitudeNumber;
    }

// @public
export class GeodesicPathSolver {
    static approximateMinimumLengthSectionArc(ellipsoid: Ellipsoid, angleA: LongitudeLatitudeNumber, angleB: LongitudeLatitudeNumber, numSample: number, normalInterpolationFraction0: number, normalInterpolationFraction1: number): {
        minLengthArc: Arc3d;
        minLengthNormalInterpolationFraction: number;
    } | undefined;
    // (undocumented)
    static createGeodesicPath(originalEllipsoid: Ellipsoid, startAngles: LongitudeLatitudeNumber, endAngles: LongitudeLatitudeNumber, density: number | Angle): GeodesicPathPoint[] | undefined;
    }

// @public
export class Geometry {
    static axisIndexToRightHandedAxisOrder(axisIndex: AxisIndex): AxisOrder;
    static axisOrderToAxis(order: AxisOrder, index: number): number;
    static clamp(value: number, min: number, max: number): number;
    static clampToStartEnd(x: number, a: number, b: number): number;
    static conditionalDivideCoordinate(numerator: number, denominator: number, largestResult?: number): number | undefined;
    static conditionalDivideFraction(numerator: number, denominator: number): number | undefined;
    static correctSmallMetricDistance(distance: number, replacement?: number): number;
    static crossProductMagnitude(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number;
    static crossProductXYXY(ux: number, uy: number, vx: number, vy: number): number;
    static crossProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d;
    static curvatureMagnitude(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number;
    static cyclic3dAxis(axis: number): number;
    static defined01(value: any): number;
    static determinant4x4(xx: number, xy: number, xz: number, xw: number, yx: number, yy: number, yz: number, yw: number, zx: number, zy: number, zz: number, zw: number, wx: number, wy: number, wz: number, ww: number): number;
    static distanceXYXY(x0: number, y0: number, x1: number, y1: number): number;
    static distanceXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): number;
    static dotProductXYXY(ux: number, uy: number, vx: number, vy: number): number;
    static dotProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number;
    static equalStringNoCase(string1: string, string2: string): boolean;
    static readonly fullCircleRadiansMinusSmallAngle: number;
    static readonly hugeCoordinate = 1000000000000;
    static hypotenuseSquaredXY(x: number, y: number): number;
    static hypotenuseSquaredXYZ(x: number, y: number, z: number): number;
    static hypotenuseSquaredXYZW(x: number, y: number, z: number, w: number): number;
    static hypotenuseXY(x: number, y: number): number;
    static hypotenuseXYZ(x: number, y: number, z: number): number;
    static hypotenuseXYZW(x: number, y: number, z: number, w: number): number;
    static interpolate(a: number, f: number, b: number): number;
    static inverseInterpolate(x0: number, f0: number, x1: number, f1: number, targetF?: number, defaultResult?: number): number | undefined;
    static inverseInterpolate01(f0: number, f1: number, targetF?: number): number | undefined;
    static inverseMetricDistance(a: number): number | undefined;
    static inverseMetricDistanceSquared(a: number): number | undefined;
    static isAlmostEqualNumber(a: number, b: number): boolean;
    static isAlmostEqualXAndY(a: XAndY, b: XAndY): boolean;
    static isArrayOfNumberArray(json: any, numNumberArray: number, minEntries?: number): boolean;
    static isDistanceWithinTol(distance: number, tol: number): boolean;
    static isHugeCoordinate(x: number): boolean;
    static isIn01(x: number, apply01?: boolean): boolean;
    static isIn01WithTolerance(x: number, tolerance: number): boolean;
    static isNumberArray(json: any, minEntries?: number): boolean;
    static isOdd(x: number): boolean;
    static isSameCoordinate(x: number, y: number, tol?: number): boolean;
    static isSameCoordinateSquared(x: number, y: number): boolean;
    static isSameCoordinateWithToleranceFactor(x: number, y: number, toleranceFactor: number): boolean;
    static isSameCoordinateXY(x0: number, y0: number, x1: number, y1: number, tol?: number): boolean;
    static isSamePoint2d(dataA: Point2d, dataB: Point2d): boolean;
    static isSamePoint3d(dataA: Point3d, dataB: Point3d): boolean;
    static isSamePoint3dXY(dataA: Point3d, dataB: Point3d): boolean;
    static isSameVector2d(dataA: Vector2d, dataB: Vector2d): boolean;
    static isSameVector3d(dataA: Vector3d, dataB: Vector3d): boolean;
    static isSameXYZ(dataA: XYZ, dataB: XYZ): boolean;
    static isSmallAngleRadians(value: number): boolean;
    static isSmallMetricDistance(distance: number): boolean;
    static isSmallMetricDistanceSquared(distanceSquared: number): boolean;
    static isSmallRelative(value: number): boolean;
    static readonly largeCoordinateResult = 10000000000000;
    static readonly largeFractionResult = 10000000000;
    static lexicalXYLessThan(a: XY | XYZ, b: XY | XYZ): -1 | 0 | 1;
    static lexicalXYZLessThan(a: XYZ, b: XYZ): -1 | 0 | 1;
    static lexicalYXLessThan(a: XY | XYZ, b: XY | XYZ): -1 | 0 | 1;
    static maxAbsDiff(a: number, b0: number, b1: number): number;
    static maxAbsXY(x: number, y: number): number;
    static maxAbsXYZ(x: number, y: number, z: number): number;
    static maxXY(a: number, b: number): number;
    static maxXYZ(a: number, b: number, c: number): number;
    static meanCurvatureOfRadii(r0: number, r1: number): number;
    static minXY(a: number, b: number): number;
    static modulo(a: number, period: number): number;
    static resolveNumber(value: number | undefined, defaultValue?: number): number;
    static restrictToInterval(x: number, a: number, b: number): number;
    static safeDivideFraction(numerator: number, denominator: number, defaultResult: number): number;
    static readonly smallAngleRadians = 1e-12;
    static readonly smallAngleRadiansSquared = 1e-24;
    static readonly smallFraction = 1e-10;
    static readonly smallMetricDistance = 0.000001;
    static readonly smallMetricDistanceSquared = 1e-12;
    static solveTrigForm(constCoff: number, cosCoff: number, sinCoff: number): Vector2d[] | undefined;
    static split3WaySign(x: number, outNegative: number, outZero: number, outPositive: number): number;
    static square(x: number): number;
    static stepCount(stepSize: number, total: number, minCount?: number, maxCount?: number): number;
    static tripleProduct(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, wx: number, wy: number, wz: number): number;
    static tripleProductPoint4dXYW(columnA: Point4d, columnB: Point4d, columnC: Point4d): number;
    static tripleProductXYW(columnA: XAndY, weightA: number, columnB: XAndY, weightB: number, columnC: XAndY, weightC: number): number;
}

// @public
export abstract class GeometryHandler {
    abstract handleArc3d(g: Arc3d): any;
    handleBagOfCurves(g: BagOfCurves): any;
    abstract handleBezierCurve3d(g: BezierCurve3d): any;
    abstract handleBezierCurve3dH(g: BezierCurve3dH): any;
    abstract handleBox(g: Box): any;
    abstract handleBSplineCurve3d(g: BSplineCurve3d): any;
    abstract handleBSplineCurve3dH(g: BSplineCurve3dH): any;
    abstract handleBSplineSurface3d(g: BSplineSurface3d): any;
    abstract handleBSplineSurface3dH(g: BSplineSurface3dH): any;
    abstract handleCone(g: Cone): any;
    abstract handleCoordinateXYZ(g: CoordinateXYZ): any;
    handleCurveCollection(_g: CurveCollection): any;
    abstract handleIndexedPolyface(g: IndexedPolyface): any;
    abstract handleLinearSweep(g: LinearSweep): any;
    abstract handleLineSegment3d(g: LineSegment3d): any;
    abstract handleLineString3d(g: LineString3d): any;
    handleLoop(g: Loop): any;
    handleParityRegion(g: ParityRegion): any;
    handlePath(g: Path): any;
    abstract handlePointString3d(g: PointString3d): any;
    abstract handleRotationalSweep(g: RotationalSweep): any;
    abstract handleRuledSweep(g: RuledSweep): any;
    abstract handleSphere(g: Sphere): any;
    abstract handleTorusPipe(g: TorusPipe): any;
    // @alpha
    abstract handleTransitionSpiral(g: TransitionSpiral3d): any;
    handleUnionRegion(g: UnionRegion): any;
}

// @public
export abstract class GeometryQuery {
    get children(): GeometryQuery[] | undefined;
    abstract clone(): GeometryQuery | undefined;
    abstract cloneTransformed(transform: Transform): GeometryQuery | undefined;
    abstract dispatchToGeometryHandler(handler: GeometryHandler): any;
    abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    abstract readonly geometryCategory: GeometryQueryCategory;
    isAlmostEqual(other: GeometryQuery): boolean;
    abstract isSameGeometryClass(other: GeometryQuery): boolean;
    range(transform?: Transform, result?: Range3d): Range3d;
    abstract tryTransformInPlace(transform: Transform): boolean;
    tryTranslateInPlace(dx: number, dy?: number, dz?: number): boolean;
}

// @public
export type GeometryQueryCategory = "polyface" | "curvePrimitive" | "curveCollection" | "solid" | "point" | "pointCollection" | "bsurf";

// @internal
export type GraphCheckPointFunction = (name: string, graph: HalfEdgeGraph, properties: string, extraData?: any) => any;

// @internal
export type GraphNodeFunction = (graph: HalfEdgeGraph, node: HalfEdge) => boolean;

// @public
export class GrowableBlockedArray {
    constructor(blockSize: number, initialBlocks?: number);
    addBlock(newData: number[]): void;
    blockCapacity(): number;
    protected blockIndexToDoubleIndex(blockIndex: number): number;
    protected _blockSize: number;
    checkedComponent(blockIndex: number, componentIndex: number): number | undefined;
    clear(): void;
    static compareLexicalBlock(data: Float64Array, blockSize: number, ia: number, ib: number): number;
    component(blockIndex: number, componentIndex: number): number;
    protected _data: Float64Array;
    distanceBetweenBlocks(blockIndexA: number, blockIndexB: number): number;
    distanceBetweenSubBlocks(blockIndexA: number, blockIndexB: number, iBegin: number, iEnd: number): number;
    ensureBlockCapacity(blockCapacity: number): void;
    getWithinBlock(blockIndex: number, indexWithinBlock: number): number;
    protected _inUse: number;
    protected newBlockIndex(): number;
    get numBlocks(): number;
    get numPerBlock(): number;
    popBlock(): void;
    sortIndicesLexical(compareBlocks?: BlockComparisonFunction): Uint32Array;
}

// @public
export class GrowableFloat64Array {
    constructor(initialCapacity?: number);
    atUncheckedIndex(index: number): number;
    back(): number;
    capacity(): number;
    clear(): void;
    clone(maintainExcessCapacity?: boolean): GrowableFloat64Array;
    static compare(a: any, b: any): number;
    compressAdjacentDuplicates(tolerance?: number): void;
    static create(contents: Float64Array | number[]): GrowableFloat64Array;
    ensureCapacity(newCapacity: number): void;
    front(): number;
    get length(): number;
    move(i: number, j: number): void;
    pop(): void;
    push(toPush: number): void;
    pushArray(data: Float64Array | number[]): void;
    pushBlockCopy(copyFromIndex: number, numToCopy: number): void;
    reassign(index: number, value: number): void;
    resize(newLength: number, padValue?: number): void;
    restrictToInterval(a: number, b: number): void;
    setAtUncheckedIndex(index: number, value: number): void;
    sort(compareMethod?: (a: any, b: any) => number): void;
    swap(i: number, j: number): void;
}

// @public
export class GrowableXYArray extends IndexedXYCollection {
    constructor(numPoints?: number);
    areaXY(): number;
    back(result?: Point2d): Point2d | undefined;
    clear(): void;
    clone(): GrowableXYArray;
    compareLexicalBlock(ia: number, ib: number): number;
    component(pointIndex: number, componentIndex: number): number;
    static create(data: XAndY[] | GrowableXYZArray): GrowableXYArray;
    static createArrayOfGrowableXYZArray(data: MultiLineStringDataVariant): GrowableXYZArray[] | undefined;
    static createFromGrowableXYZArray(source: GrowableXYZArray, transform?: Transform, dest?: GrowableXYArray): GrowableXYArray;
    crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number): number | undefined;
    crossProductXAndYIndexIndex(origin: XAndY, targetAIndex: number, targetBIndex: number): number | undefined;
    distance(i: number, j: number): number | undefined;
    distanceIndexToPoint(i: number, spacePoint: Point2d): number | undefined;
    ensureCapacity(pointCapacity: number): void;
    extendRange(rangeToExtend: Range2d, transform?: Transform): void;
    float64Data(): Float64Array;
    get float64Length(): number;
    front(result?: Point2d): Point2d | undefined;
    getPoint2dArray(): Point2d[];
    getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined;
    getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d;
    getPoint3dArray(z?: number): Point3d[];
    getVector2dAtCheckedVectorIndex(vectorIndex: number, result?: Vector2d): Vector2d | undefined;
    getXAtUncheckedPointIndex(pointIndex: number): number;
    getYAtUncheckedPointIndex(pointIndex: number): number;
    interpolate(i: number, fraction: number, j: number, result?: Point2d): Point2d | undefined;
    static isAlmostEqual(dataA: GrowableXYArray | undefined, dataB: GrowableXYArray | undefined): boolean;
    isAlmostEqual(other: GrowableXYArray, tolerance?: number): boolean;
    isIndexValid(index: number): boolean;
    get length(): number;
    set length(newLength: number);
    multiplyMatrix3dInPlace(matrix: Matrix3d): void;
    multiplyTransformInPlace(transform: Transform): void;
    pop(): void;
    push(toPush: XAndY): void;
    pushAll(points: XAndY[]): void;
    pushAllXYAndZ(points: XYAndZ[] | GrowableXYZArray): void;
    pushFromGrowableXYArray(source: GrowableXYArray, sourceIndex?: number): number;
    pushInterpolatedFromGrowableXYArray(source: GrowableXYArray, i: number, fraction: number, j: number): void;
    pushWrap(numWrap: number): void;
    pushXY(x: number, y: number): void;
    resize(pointCount: number): void;
    reverseInPlace(): void;
    scaleInPlace(factor: number): void;
    setAtCheckedPointIndex(pointIndex: number, value: XAndY): boolean;
    setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number): boolean;
    sortIndicesLexical(): Uint32Array;
    sumLengths(): number;
    transferFromGrowableXYArray(destIndex: number, source: GrowableXYArray, sourceIndex: number): boolean;
    tryTransformInverseInPlace(transform: Transform): boolean;
    vectorIndexIndex(i: number, j: number, result?: Vector2d): Vector2d | undefined;
    vectorXAndYIndex(origin: XAndY, j: number, result?: Vector2d): Vector2d | undefined;
    }

// @public
export class GrowableXYZArray extends IndexedReadWriteXYZCollection {
    constructor(numPoints?: number);
    accumulateCrossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result: Vector3d): void;
    accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void;
    addSteppedPoints(other: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number): void;
    areaXY(): number;
    back(result?: Point3d): Point3d | undefined;
    clear(): void;
    clone(result?: GrowableXYZArray): GrowableXYZArray;
    compareLexicalBlock(ia: number, ib: number): number;
    component(pointIndex: number, componentIndex: number): number;
    static create(data: any, result?: GrowableXYZArray): GrowableXYZArray;
    crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined;
    crossProductXYAndZIndexIndex(origin: XYAndZ, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined;
    static distanceBetweenPointsIn2Arrays(arrayA: GrowableXYZArray, i: number, arrayB: GrowableXYZArray, j: number): number | undefined;
    distanceIndexIndex(i: number, j: number): number | undefined;
    distanceIndexToPoint(i: number, spacePoint: XYAndZ): number | undefined;
    static distanceRangeBetweenCorrespondingPoints(arrayA: GrowableXYZArray, arrayB: GrowableXYZArray): Range1d;
    distanceSquaredIndexIndex(i: number, j: number): number | undefined;
    ensureCapacity(pointCapacity: number): void;
    evaluateUncheckedIndexDotProductXYZ(pointIndex: number, x: number, y: number, z: number): number;
    evaluateUncheckedIndexPlaneAltitude(pointIndex: number, plane: PlaneAltitudeEvaluator): number;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fillLocalXYTriangleFrame(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Transform): Transform | undefined;
    float64Data(): Float64Array;
    get float64Length(): number;
    front(result?: Point3d): Point3d | undefined;
    getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined;
    getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d;
    getPoint3dArray(): Point3d[];
    getPoint3dAtCheckedPointIndex(pointIndex: number, result?: Point3d): Point3d | undefined;
    getPoint3dAtUncheckedPointIndex(pointIndex: number, result?: Point3d): Point3d;
    getRange(transform?: Transform): Range3d;
    getVector3dAtCheckedVectorIndex(vectorIndex: number, result?: Vector3d): Vector3d | undefined;
    getXAtUncheckedPointIndex(pointIndex: number): number;
    getYAtUncheckedPointIndex(pointIndex: number): number;
    getZAtUncheckedPointIndex(pointIndex: number): number;
    interpolate(i: number, fraction: number, j: number, result?: Point3d): Point3d | undefined;
    static isAlmostEqual(dataA: GrowableXYZArray | undefined, dataB: GrowableXYZArray | undefined): boolean;
    isCloseToPlane(plane: Plane3dByOriginAndUnitNormal, tolerance?: number): boolean;
    isIndexValid(index: number): boolean;
    get length(): number;
    set length(newLength: number);
    mapComponent(componentIndex: 0 | 1 | 2, func: (x: number, y: number, z: number) => number): void;
    moveIndexToIndex(fromIndex: number, toIndex: number): void;
    multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(matrix: Matrix3d): boolean;
    multiplyMatrix3dInPlace(matrix: Matrix3d): void;
    multiplyTransformInPlace(transform: Transform): void;
    pop(): void;
    push(toPush: XYAndZ): void;
    pushAll(points: Point3d[]): void;
    pushFrom(p: any): void;
    pushFromGrowableXYZArray(source: GrowableXYZArray, sourceIndex?: number): number;
    pushFront(toPush: XYAndZ): void;
    pushFrontXYZ(x: number, y: number, z: number): void;
    pushInterpolatedFromGrowableXYZArray(source: GrowableXYZArray, i: number, fraction: number, j: number): void;
    pushWrap(numWrap: number): void;
    pushXYZ(x: number, y: number, z: number): void;
    static removeClosure(points: IndexedReadWriteXYZCollection, tolerance?: number): void;
    resize(pointCount: number): void;
    reverseInPlace(): void;
    scaleInPlace(factor: number): void;
    setAtCheckedPointIndex(pointIndex: number, value: XYAndZ): boolean;
    setRange(range: Range3d, transform?: Transform): void;
    setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number, z: number): boolean;
    sortIndicesLexical(): Uint32Array;
    sumLengths(): number;
    transferFromGrowableXYZArray(destIndex: number, source: GrowableXYZArray, sourceIndex: number): boolean;
    tryTransformInverseInPlace(transform: Transform): boolean;
    vectorIndexIndex(i: number, j: number, result?: Vector3d): Vector3d | undefined;
    vectorXYAndZIndex(origin: XYAndZ, j: number, result?: Vector3d): Vector3d | undefined;
    }

// @internal
export class HalfEdge {
    constructor(x?: number, y?: number, z?: number, i?: number);
    belowYX(other: HalfEdge): boolean;
    clearMask(mask: HalfEdgeMask): void;
    clearMaskAroundEdge(mask: HalfEdgeMask): void;
    clearMaskAroundFace(mask: HalfEdgeMask): void;
    clearMaskAroundVertex(mask: HalfEdgeMask): void;
    collectAroundFace(f?: NodeFunction): any[];
    collectAroundVertex(f?: NodeFunction): any[];
    countEdgesAroundFace(): number;
    countEdgesAroundVertex(): number;
    countMaskAroundFace(mask: HalfEdgeMask, value?: boolean): number;
    countMaskAroundVertex(mask: HalfEdgeMask, value?: boolean): number;
    static createEdgeXYXY(id0: any, x0: number, y0: number, id1: any, x1: number, y1: number): HalfEdge;
    static createHalfEdgePair(heArray: HalfEdge[] | undefined): HalfEdge;
    static createHalfEdgePairWithCoordinates(xA: number | undefined, yA: number | undefined, zA: number | undefined, iA: number | undefined, xB: number | undefined, yB: number | undefined, zB: number | undefined, iB: number | undefined, heArray: HalfEdge[] | undefined): HalfEdge;
    static crossProductXYAlongChain(nodeA: HalfEdge, nodeB: HalfEdge, nodeC: HalfEdge): number;
    static crossProductXYToTargets(base: HalfEdge, targetA: HalfEdge, targetB: HalfEdge): number;
    decommission(): void;
    distanceXY(other: HalfEdge): number;
    distanceXYZ(other: HalfEdge): number;
    static dotProductNodeToNodeVectorsXY(baseA: HalfEdge, targetA: HalfEdge, baseB: HalfEdge, targetB: HalfEdge): number;
    get edgeMate(): HalfEdge;
    edgeTag?: any;
    get facePredecessor(): HalfEdge;
    faceStepY(numStep: number): number;
    get faceSuccessor(): HalfEdge;
    static filterIsMaskOff(node: HalfEdge, mask: HalfEdgeMask): boolean;
    static filterIsMaskOn(node: HalfEdge, mask: HalfEdgeMask): boolean;
    fractionAlongAndPerpendicularToPoint2d(fractionAlong: number, fractionPerpendicular: number, result?: Point2d): Point2d;
    fractionToPoint2d(fraction: number, result?: Point2d): Point2d;
    fractionToPoint3d(fraction: number, result?: Point3d): Point3d;
    fractionToX(fraction: number): number;
    fractionToY(fraction: number): number;
    fractionToZ(fraction: number): number;
    getMask(mask: HalfEdgeMask): number;
    getPoint2d(result?: Point2d): Point2d;
    getPoint3d(result?: Point3d): Point3d;
    getVector2dAlongEdge(result?: Vector2d): Vector2d;
    getVector3dAlongEdge(result?: Vector3d): Vector3d;
    static horizontalScanFraction(node0: HalfEdge, y: number): number | undefined | HalfEdge;
    static horizontalScanFraction01(node0: HalfEdge, y: number): number | undefined;
    i: number;
    get id(): any;
    isEqualXY(other: XAndY): boolean;
    isMaskSet(mask: HalfEdgeMask): boolean;
    static isNodeVisibleInSector(spaceNode: HalfEdge, sectorNode: HalfEdge): boolean;
    maskBits: number;
    static nodeToId(node: HalfEdge): any;
    static nodeToIdMaskXY(node: HalfEdge): {
        id: any;
        mask: any;
        xy: number[];
    };
    static nodeToIdString(node: HalfEdge): any;
    static nodeToIdXYString(node: HalfEdge): string;
    static nodeToMaskString(node: HalfEdge): string;
    static nodeToSelf(node: HalfEdge): any;
    static nodeToXY(node: HalfEdge): number[];
    static pinch(nodeA: HalfEdge, nodeB: HalfEdge): void;
    setMask(mask: HalfEdgeMask): void;
    setMaskAndEdgeTagAroundFace(mask: HalfEdgeMask, tag: any, applyToMate?: boolean): void;
    setMaskAroundEdge(mask: HalfEdgeMask): void;
    setMaskAroundFace(mask: HalfEdgeMask): void;
    setMaskAroundVertex(mask: HalfEdgeMask): void;
    setXYZAroundVertex(x: number, y: number, z: number): void;
    setXYZFrom(node: HalfEdge): void;
    signedFaceArea(): number;
    sortAngle?: number;
    sortData?: number;
    static splitEdge(baseA: undefined | HalfEdge, xA: number | undefined, yA: number | undefined, zA: number | undefined, iA: number | undefined, heArray: HalfEdge[] | undefined): HalfEdge;
    sumAroundFace(f: NodeToNumberFunction): number;
    sumAroundVertex(f: NodeToNumberFunction): number;
    testAndSetMask(mask: HalfEdgeMask): number;
    static testFacePositiveAreaXY(node: HalfEdge): boolean;
    static testMateMaskExterior(node: HalfEdge): boolean;
    static testNodeMaskNotExterior(node: HalfEdge): boolean;
    static transferEdgeProperties(fromNode: HalfEdge, toNode: HalfEdge): void;
    static transverseIntersectionFractions(nodeA0: HalfEdge, nodeB0: HalfEdge, result?: Vector2d): Vector2d | undefined;
    vectorToFaceSuccessor(result?: Vector3d): Vector3d;
    vectorToFaceSuccessorXY(result?: Vector2d): Vector2d;
    get vertexPredecessor(): HalfEdge;
    get vertexSuccessor(): HalfEdge;
    x: number;
    y: number;
    yankFromVertexLoop(): HalfEdge | undefined;
    z: number;
}

// @internal
export type HalfEdgeAndMaskToBooleanFunction = (node: HalfEdge, mask: HalfEdgeMask) => boolean;

// @internal
export class HalfEdgeGraph {
    constructor();
    addEdgeXY(x0: number, y0: number, x1: number, y1: number): HalfEdge;
    allHalfEdges: HalfEdge[];
    announceFaceLoops(announceFace: GraphNodeFunction): void;
    announceNodes(announceNode: GraphNodeFunction): void;
    announceVertexLoops(announceVertex: GraphNodeFunction): void;
    clearMask(mask: HalfEdgeMask): void;
    collectFaceLoops(): HalfEdge[];
    collectSegments(): LineSegment3d[];
    collectVertexLoops(): HalfEdge[];
    countFaceLoops(): number;
    countFaceLoopsWithMaskFilter(filter: HalfEdgeAndMaskToBooleanFunction, mask: HalfEdgeMask): number;
    countMask(mask: HalfEdgeMask): number;
    countNodes(): number;
    countVertexLoops(): number;
    createEdgeHalfEdgeHalfEdge(nodeA: HalfEdge, idA: number, nodeB: HalfEdge, idB?: number): HalfEdge;
    createEdgeXYAndZ(xyz0: XYAndZ, id0: number, xyz1: XYAndZ, id1: number): HalfEdge;
    createEdgeXYZHalfEdge(xA: number | undefined, yA: number | undefined, zA: number | undefined, iA: number | undefined, node: HalfEdge, iB?: number): HalfEdge;
    createEdgeXYZXYZ(xA?: number, yA?: number, zA?: number, iA?: number, xB?: number, yB?: number, zB?: number, iB?: number): HalfEdge;
    decommission(): void;
    dropMask(mask: HalfEdgeMask): void;
    grabMask(clearInAllHalfEdges?: boolean): HalfEdgeMask;
    reverseMask(mask: HalfEdgeMask): void;
    setMask(mask: HalfEdgeMask): void;
    splitEdge(base: undefined | HalfEdge, xA?: number, yA?: number, zA?: number, iA?: number): HalfEdge;
    splitEdgeAtFraction(base: HalfEdge, fraction: number): HalfEdge;
    transformInPlace(transform: Transform): void;
    yankAndDeleteEdges(deleteThisNode: NodeFunction): number;
}

// @internal
export enum HalfEdgeMask {
    ALL_GRAB_DROP_MASKS = 4293918720,
    ALL_MASK = 4294967295,
    BOUNDARY_EDGE = 2,
    EXTERIOR = 1,
    NULL_FACE = 512,
    NULL_MASK = 0,
    PRIMARY_EDGE = 4,
    TRIANGULATED_FACE = 256,
    VISITED = 16
}

// @internal
export type HalfEdgeToBooleanFunction = (node: HalfEdge) => boolean;

// @public
export type HasZ = Readonly<WriteableHasZ>;

// @public
export namespace IModelJson {
    export interface ArcByVectorProps {
        center: XYZProps;
        sweepStartEnd: AngleSweepProps;
        vectorX: XYZProps;
        vectorY: XYZProps;
    }
    export interface AxesProps {
        xyVectors?: [XYZProps, XYZProps];
        yawPitchRollAngles?: YawPitchRollProps;
        zxVectors?: [XYZProps, XYZProps];
    }
    export interface BcurveProps {
        closed?: boolean;
        knots: [number];
        order: number;
        points: [XYZProps];
    }
    export interface BoxProps extends AxesProps {
        baseX: number;
        baseY: number;
        capped?: boolean;
        height?: number;
        origin: XYZProps;
        topOrigin?: XYZProps;
        topX?: number;
        topY?: number;
    }
    export interface BSplineSurfaceProps {
        orderU: number;
        orderV: number;
        points: [[[number]]];
        uKnots: [number];
        vKnots: [number];
    }
    export interface ConeProps extends AxesProps {
        capped?: boolean;
        end: XYZProps;
        endRadius?: number;
        radius?: number;
        start: XYZProps;
        startRadius?: number;
        vectorX?: XYZProps;
        vectorY?: XYZProps;
    }
    export interface CurveCollectionProps extends PlanarRegionProps {
        bagofCurves?: [CurveCollectionProps];
        path?: [CurvePrimitiveProps];
    }
    export interface CurvePrimitiveProps {
        arc?: ArcByVectorProps | [XYZProps, XYZProps, XYZProps];
        bcurve?: BcurveProps;
        lineSegment?: [XYZProps, XYZProps];
        lineString?: XYZProps[];
        transitionSpiral?: TransitionSpiralProps;
    }
    export interface CylinderProps {
        capped?: boolean;
        end: XYZProps;
        radius: number;
        start: XYZProps;
    }
    export interface GeometryProps extends CurvePrimitiveProps, SolidPrimitiveProps, CurveCollectionProps {
        bsurf?: BSplineSurfaceProps;
        indexedMesh?: IndexedMeshProps;
        point?: XYZProps;
    }
    export interface IndexedMeshProps {
        color?: [number];
        colorIndex?: [number];
        normal?: [XYZProps];
        normalIndex?: [number];
        param?: [XYProps];
        paramIndex?: [number];
        point: [XYZProps];
        pointIndex: [number];
    }
    export interface LinearSweepProps {
        capped?: boolean;
        contour: CurveCollectionProps;
        vector: XYZProps;
    }
    export interface PlanarRegionProps {
        loop?: [CurvePrimitiveProps];
        parityRegion?: [{
            loop: [CurvePrimitiveProps];
        }];
        unionRegion?: [PlanarRegionProps];
    }
    export interface PointProps {
        point?: XYZProps;
    }
    export class Reader {
        constructor();
        static parse(json?: any): AnyGeometryQuery | any[] | undefined;
        static parseArray(data?: any): any[] | undefined;
        static parseBcurve(data?: any): BSplineCurve3d | BSplineCurve3dH | undefined;
        static parseBox(json?: BoxProps): Box | undefined;
        static parseBsurf(data?: any): BSplineSurface3d | BSplineSurface3dH | undefined;
        static parseConeProps(json?: ConeProps): Cone | undefined;
        static parseCoordinate(data?: any): CoordinateXYZ | undefined;
        static parseCurveCollectionMembers(result: CurveCollection, data?: any): CurveCollection | undefined;
        static parseCylinderProps(json?: CylinderProps): Cone | undefined;
        static parseIndexedMesh(data?: any): IndexedPolyface | undefined;
        static parseLinearSweep(json?: any): LinearSweep | undefined;
        static parsePointArray(json?: any[]): Point3d[];
        static parsePolyfaceAuxData(data?: any): PolyfaceAuxData | undefined;
        static parseRotationalSweep(json?: RotationalSweepProps): RotationalSweep | undefined;
        static parseRuledSweep(json?: RuledSweepProps): RuledSweep | undefined;
        static parseSphere(json?: SphereProps): Sphere | undefined;
        static parseTorusPipe(json?: TorusPipeProps): TorusPipe | undefined;
        // @alpha
        static parseTransitionSpiral(data?: TransitionSpiralProps): TransitionSpiral3d | undefined;
        }
    export interface RotationalSweepProps {
        axis: XYZProps;
        capped?: boolean;
        center: XYZProps;
        contour: CurveCollectionProps;
        sweepAngle: AngleProps;
    }
    export interface RuledSweepProps {
        capped?: boolean;
        contour: [CurveCollectionProps];
    }
    export interface RuledSweepProps {
        capped?: boolean;
        contour: [CurveCollectionProps];
    }
    export interface SolidPrimitiveProps {
        box?: BoxProps;
        cone?: ConeProps;
        cylinder?: CylinderProps;
        linearSweep?: LinearSweepProps;
        rotationalSweep?: RotationalSweepProps;
        ruledSweep?: RuledSweepProps;
        sphere?: SphereProps;
        torusPipe?: TorusPipeProps;
    }
    export interface SphereProps extends AxesProps {
        capped?: boolean;
        center: XYZProps;
        latitudeStartEnd?: AngleSweepProps;
        radius?: number;
        radiusX?: number;
        radiusY?: number;
        radiusZ?: number;
    }
    export interface TorusPipeProps extends AxesProps {
        capped?: boolean;
        center: XYZProps;
        majorRadius: number;
        minorRadius?: number;
        sweepAngle?: AngleProps;
    }
    export interface TransitionSpiralProps extends AxesProps {
        activeFractionInterval?: number[];
        // @deprecated
        curveLength?: number;
        endBearing?: AngleProps;
        endRadius?: number;
        // @deprecated
        fractionInterval?: number[];
        // @deprecated
        intervalFractions?: [number, number];
        length?: number;
        origin: XYZProps;
        startBearing?: AngleProps;
        startRadius?: number;
        type?: string;
    }
    export class Writer extends GeometryHandler {
        emit(data: any): any;
        emitArray(data: object[]): any;
        handleArc3d(data: Arc3d): any;
        handleBagOfCurves(data: BagOfCurves): any;
        handleBezierCurve3d(curve: BezierCurve3d): any;
        handleBezierCurve3dH(curve: BezierCurve3dH): any;
        handleBox(box: Box): any;
        handleBSplineCurve3d(curve: BSplineCurve3d): any;
        handleBSplineCurve3dH(curve: BSplineCurve3dH): any;
        handleBSplineSurface3d(surface: BSplineSurface3d): any;
        handleBSplineSurface3dH(surface: BSplineSurface3dH): any;
        handleCone(data: Cone): any;
        handleCoordinateXYZ(data: CoordinateXYZ): any;
        handleIndexedPolyface(pf: IndexedPolyface): any;
        handleLinearSweep(data: LinearSweep): any;
        handleLineSegment3d(data: LineSegment3d): any;
        handleLineString3d(data: LineString3d): any;
        handleLoop(data: Loop): any;
        handleParityRegion(data: ParityRegion): any;
        handlePath(data: Path): any;
        handlePointString3d(data: PointString3d): any;
        handleRotationalSweep(data: RotationalSweep): any;
        handleRuledSweep(data: RuledSweep): any;
        handleSphere(data: Sphere): any;
        handleTorusPipe(data: TorusPipe): any;
        // @alpha
        handleTransitionSpiral(data: TransitionSpiral3d): any;
        handleUnionRegion(data: UnionRegion): any;
        static toIModelJson(data: any): any;
    }
}

// @public
export class IndexedCollectionInterval<T extends CollectionWithLength> {
    protected constructor(points: T, base: number, limit: number);
    advanceBegin(): boolean;
    advanceEnd(): boolean;
    advanceToHead(other: IndexedCollectionInterval<T>): boolean;
    advanceToTail(other: IndexedCollectionInterval<T>): boolean;
    begin: number;
    static createBeginEnd<T extends CollectionWithLength>(points: T, begin: number, end: number): IndexedCollectionInterval<T>;
    static createBeginLength<T extends CollectionWithLength>(points: T, begin: number, length: number): IndexedCollectionInterval<T>;
    static createComplete<T extends CollectionWithLength>(points: T): IndexedCollectionInterval<T>;
    end: number;
    get isNonEmpty(): boolean;
    get isSingleton(): boolean;
    get isValidSubset(): boolean;
    get length(): number;
    localIndexToParentIndex(localIndex: number): number | undefined;
    points: T;
    restrictEnd(): void;
    setFrom(other: IndexedCollectionInterval<T>, base?: number, limit?: number): void;
}

// @public
export class IndexedPolyface extends Polyface {
    protected constructor(data: PolyfaceData, facetStart?: number[], facetToFaceData?: number[]);
    addColor(color: number): number;
    addColorIndex(index: number): void;
    addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform: Transform | undefined): void;
    addNormal(normal: Vector3d, priorIndexA?: number, priorIndexB?: number): number;
    addNormalIndex(index: number): void;
    addNormalXYZ(x: number, y: number, z: number): number;
    addParam(param: Point2d): number;
    addParamIndex(index: number): void;
    addParamUV(u: number, v: number, priorIndexA?: number, priorIndexB?: number): number;
    addPoint(point: Point3d, priorIndex?: number): number;
    addPointIndex(index: number, visible?: boolean): void;
    addPointXYZ(x: number, y: number, z: number): number;
    cleanupOpenFacet(): void;
    clone(): IndexedPolyface;
    cloneTransformed(transform: Transform): IndexedPolyface;
    get colorCount(): number;
    static create(needNormals?: boolean, needParams?: boolean, needColors?: boolean, twoSided?: boolean): IndexedPolyface;
    createVisitor(numWrap?: number): PolyfaceVisitor;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(range: Range3d, transform?: Transform): void;
    get faceCount(): number;
    get facetCount(): number;
    facetIndex0(index: number): number;
    facetIndex1(index: number): number;
    protected _facetStart: number[];
    protected _facetToFaceData: number[];
    getFaceDataByFacetIndex(facetIndex: number): FacetFaceData;
    isAlmostEqual(other: any): boolean;
    get isEmpty(): boolean;
    isSameGeometryClass(other: any): boolean;
    isValidFacetIndex(index: number): boolean;
    get normalCount(): number;
    numEdgeInFacet(facetIndex: number): number;
    get paramCount(): number;
    get pointCount(): number;
    range(transform?: Transform, result?: Range3d): Range3d;
    reverseIndices(): void;
    reverseNormals(): void;
    reverseSingleFacet(facetId: number): void;
    setNewFaceData(endFacetIndex?: number): boolean;
    terminateFacet(validateAllIndices?: boolean): any;
    tryGetFaceData(i: number): FacetFaceData | undefined;
    tryTransformInPlace(transform: Transform): boolean;
    get zeroTerminatedIndexCount(): number;
}

// @public
export class IndexedPolyfaceSubsetVisitor extends IndexedPolyfaceVisitor {
    static createSubsetVisitor(polyface: IndexedPolyface, activeFacetIndices: number[], numWrap: number): IndexedPolyfaceSubsetVisitor;
    moveToNextFacet(): boolean;
    moveToReadIndex(activeIndex: number): boolean;
    parentFacetIndex(activeIndex: number): number | undefined;
    reset(): void;
}

// @public
export class IndexedPolyfaceVisitor extends PolyfaceData implements PolyfaceVisitor {
    protected constructor(facets: IndexedPolyface, numWrap: number);
    clearArrays(): void;
    clientAuxIndex(i: number): number;
    clientColorIndex(i: number): number;
    clientNormalIndex(i: number): number;
    clientParamIndex(i: number): number;
    clientPointIndex(i: number): number;
    clientPolyface(): Polyface;
    static create(polyface: IndexedPolyface, numWrap: number): IndexedPolyfaceVisitor;
    currentReadIndex(): number;
    moveToNextFacet(): boolean;
    moveToReadIndex(facetIndex: number): boolean;
    get numEdgesThisFacet(): number;
    pushDataFrom(other: PolyfaceVisitor, index: number): void;
    pushInterpolatedDataFrom(other: PolyfaceVisitor, index0: number, fraction: number, index1: number): void;
    reset(): void;
    setNumWrap(numWrap: number): void;
    tryGetDistanceParameter(index: number, result?: Point2d): Point2d | undefined;
    tryGetNormalizedParameter(index: number, result?: Point2d): Point2d | undefined;
}

// @public
export abstract class IndexedReadWriteXYZCollection extends IndexedXYZCollection {
    abstract back(result?: Point3d): Point3d | undefined;
    abstract clear(): void;
    abstract front(result?: Point3d): Point3d | undefined;
    abstract pop(): void;
    abstract push(data: XYAndZ): void;
    abstract pushXYZ(x?: number, y?: number, z?: number): void;
    abstract reverseInPlace(): void;
}

// @public
export abstract class IndexedXYCollection {
    abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number): number | undefined;
    abstract crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined;
    abstract getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined;
    abstract getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined;
    abstract get length(): number;
    abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined;
    abstract vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined;
}

// @public
export abstract class IndexedXYZCollection {
    abstract accumulateCrossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result: Vector3d): void;
    abstract accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void;
    abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    abstract crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    cyclicIndex(i: number): number;
    abstract distanceIndexIndex(index0: number, index1: number): number | undefined;
    abstract distanceSquaredIndexIndex(index0: number, index1: number): number | undefined;
    abstract getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined;
    abstract getPoint3dAtUncheckedPointIndex(index: number, result?: Point3d): Point3d;
    getRange(): Range3d;
    abstract getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined;
    abstract getXAtUncheckedPointIndex(pointIndex: number): number;
    abstract getYAtUncheckedPointIndex(pointIndex: number): number;
    abstract getZAtUncheckedPointIndex(pointIndex: number): number;
    abstract get length(): number;
    get points(): Iterable<Point3d>;
    abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    abstract vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined;
}

// @public
export class IndexedXYZCollectionInterval extends IndexedCollectionInterval<IndexedXYZCollection> {
}

// @public
export class IndexedXYZCollectionPolygonOps {
    static clipConvexPolygonInPlace(plane: PlaneAltitudeEvaluator, xyz: GrowableXYZArray, work: GrowableXYZArray, keepPositive?: boolean, tolerance?: number): number;
    // @internal
    static gatherCutLoopsFromPlaneClip(plane: PlaneAltitudeEvaluator, xyz: GrowableXYZArray, minChainLength?: number, tolerance?: number): CutLoopMergeContext;
    static intersectRangeConvexPolygonInPlace(range: Range3d, xyz: GrowableXYZArray): GrowableXYZArray | undefined;
    // @internal
    static reorderCutLoops(loops: CutLoopMergeContext): void;
    static splitConvexPolygonInsideOutsidePlane(plane: PlaneAltitudeEvaluator, xyz: IndexedReadWriteXYZCollection, xyzPositive: IndexedReadWriteXYZCollection, xyzNegative: IndexedReadWriteXYZCollection, altitudeRange: Range1d): void;
    }

// @public
export class IntegratedSpiral3d extends TransitionSpiral3d {
    get activeStrokes(): LineString3d;
    bearing01: AngleSweep;
    clone(): IntegratedSpiral3d;
    cloneTransformed(transform: Transform): TransitionSpiral3d;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    static createFrom4OutOf5(spiralType: string | undefined, radius0: number | undefined, radius1: number | undefined, bearing0: Angle | undefined, bearing1: Angle | undefined, arcLength: number | undefined, fractionInterval: undefined | Segment1d, localToWorld: Transform): IntegratedSpiral3d | undefined;
    static createRadiusRadiusBearingBearing(radius01: Segment1d, bearing01: AngleSweep, activeFractionInterval: Segment1d, localToWorld: Transform, typeName?: string): IntegratedSpiral3d | undefined;
    curveLength(): number;
    readonly curvePrimitiveType = "transitionSpiral";
    static readonly defaultSpiralType = "clothoid";
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(): Point3d;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    fractionToBearingRadians(activeFraction: number): number;
    fractionToCurvature(activeFraction: number): number | undefined;
    fractionToFrenetFrame(activeFraction: number, result?: Transform): Transform;
    fractionToPoint(activeFraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(activeFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;
    fractionToPointAndDerivative(activeFraction: number, result?: Ray3d): Ray3d;
    globalFractionToBearingRadians(fraction: number): number;
    globalFractionToCurvature(fraction: number): number;
    static initWorkSpace(): void;
    isAlmostEqual(other?: GeometryQuery): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: any): boolean;
    quickLength(): number;
    radius01: Segment1d;
    refreshComputedProperties(): void;
    reverseInPlace(): void;
    setFrom(other: IntegratedSpiral3d): IntegratedSpiral3d;
    startPoint(): Point3d;
    tryTransformInPlace(transformA: Transform): boolean;
}

// @public
export type IntegratedSpiralTypeName = "clothoid" | "bloss" | "biquadratic" | "cosine" | "sine";

// @internal
export function interpolateColor(color0: number, fraction: number, color1: number): number;

// @public
export enum InverseMatrixState {
    inverseStored = 1,
    singular = 2,
    unknown = 0
}

// @public
export interface IStrokeHandler {
    announceBezierCurve?(bezier: BezierCurveBase, numStrokes: number, parent: CurvePrimitive, spandex: number, fraction0: number, fraction1: number): void;
    announceIntervalForUniformStepStrokes(cp: CurvePrimitive, numStrokes: number, fraction0: number, fraction1: number): void;
    announcePointTangent(xyz: Point3d, fraction: number, tangent: Vector3d): void;
    announceSegmentInterval(cp: CurvePrimitive, point0: Point3d, point1: Point3d, numStrokes: number, fraction0: number, fraction1: number): void;
    endCurvePrimitive(cp: CurvePrimitive): void;
    endParentCurvePrimitive(cp: CurvePrimitive): void;
    startCurvePrimitive(cp: CurvePrimitive): void;
    startParentCurvePrimitive(cp: CurvePrimitive): void;
}

// @public
export class JointOptions {
    constructor(leftOffsetDistance: number, minArcDegrees?: number, maxChamferDegrees?: number);
    static create(leftOffsetDistanceOrOptions: number | JointOptions): JointOptions;
    // (undocumented)
    leftOffsetDistance: number;
    // (undocumented)
    maxChamferTurnDegrees: number;
    minArcDegrees: number;
    needArc(theta: Angle): boolean;
    numChamferPoints(theta: Angle): number;
}

// @public
export class KnotVector {
    baseKnotFractionToKnot(knotIndex0: number, localFraction: number): number;
    clone(): KnotVector;
    copyKnots(includeExtraEndKnot: boolean): number[];
    static create(knotArray: number[] | Float64Array, degree: number, skipFirstAndLast?: boolean): KnotVector;
    createBasisArray(): Float64Array;
    static createUniformClamped(numPoles: number, degree: number, a0: number, a1: number): KnotVector;
    static createUniformWrapped(numInterval: number, degree: number, a0: number, a1: number): KnotVector;
    degree: number;
    evaluateBasisFunctions(knotIndex0: number, u: number, f: Float64Array): void;
    evaluateBasisFunctions1(knotIndex0: number, u: number, f: Float64Array, df: Float64Array, ddf?: Float64Array): void;
    fractionToKnot(fraction: number): number;
    grevilleKnot(spanIndex: number): number;
    isAlmostEqual(other: KnotVector): boolean;
    isIndexOfRealSpan(spanIndex: number): boolean;
    get knotLength01(): number;
    knots: Float64Array;
    knotToLeftKnotIndex(u: number): number;
    static readonly knotTolerance = 1e-9;
    get leftKnot(): number;
    get leftKnotIndex(): number;
    get numSpans(): number;
    reflectKnots(): void;
    get rightKnot(): number;
    get rightKnotIndex(): number;
    setKnots(knots: number[] | Float64Array, skipFirstAndLast?: boolean): void;
    spanFractionToFraction(spanIndex: number, localFraction: number): number;
    spanFractionToKnot(spanIndex: number, localFraction: number): number;
    spanIndexToLeftKnotIndex(spanIndex: number): number;
    spanIndexToSpanLength(spanIndex: number): number;
    testClosable(mode?: BSplineWrapMode): boolean;
    get wrappable(): BSplineWrapMode;
    set wrappable(value: BSplineWrapMode);
}

// @public
export class LinearSweep extends SolidPrimitive {
    clone(): LinearSweep;
    cloneSweepVector(): Vector3d;
    cloneTransformed(transform: Transform): LinearSweep;
    constantVSection(vFraction: number): CurveCollection | undefined;
    static create(contour: CurveCollection, direction: Vector3d, capped: boolean): LinearSweep | undefined;
    static createZSweep(xyPoints: XAndY[], z: number, zSweep: number, capped: boolean): LinearSweep | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getConstructiveFrame(): Transform | undefined;
    getCurvesRef(): CurveCollection;
    getSweepContourRef(): SweepContour;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    readonly solidPrimitiveType = "linearSweep";
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export class LineSegment3d extends CurvePrimitive implements BeJSONFunctions {
    announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number;
    clone(): LineSegment3d;
    clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined;
    cloneTransformed(transform: Transform): CurvePrimitive;
    closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter, result?: CurveLocationDetail): CurveLocationDetail;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    static create(point0: Point3d, point1: Point3d, result?: LineSegment3d): LineSegment3d;
    static createCapture(point0: Point3d, point1: Point3d): LineSegment3d;
    static createXYXY(x0: number, y0: number, x1: number, y1: number, z?: number, result?: LineSegment3d): LineSegment3d;
    static createXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: LineSegment3d): LineSegment3d;
    curveLength(): number;
    curveLengthBetweenFractions(fraction0: number, fraction1: number): number;
    readonly curvePrimitiveType = "lineSegment";
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(result?: Point3d): Point3d;
    extendRange(range: Range3d, transform?: Transform): void;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    static fromJSON(json?: any): LineSegment3d;
    getFractionToDistanceScale(): number | undefined;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isExtensibleFractionSpace(): boolean;
    isInPlane(plane: PlaneAltitudeEvaluator): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    get point0Ref(): Point3d;
    get point1Ref(): Point3d;
    quickLength(): number;
    reverseInPlace(): void;
    set(point0: Point3d, point1: Point3d): void;
    setFrom(other: LineSegment3d): void;
    setFromJSON(json?: any): void;
    setRefs(point0: Point3d, point1: Point3d): void;
    startPoint(result?: Point3d): Point3d;
    toJSON(): any;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export class LineString3d extends CurvePrimitive implements BeJSONFunctions {
    addClosurePoint(): void;
    addDerivative(vector: Vector3d): void;
    addFraction(fraction: number): void;
    addMappedStrokesToLineString3D(map: StrokeCountMap, destLinestring: LineString3d): number;
    addPoint(point: Point3d): void;
    addPoints(...points: any[]): void;
    addPointXYZ(x: number, y: number, z?: number): void;
    addSteppedPoints(source: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number): void;
    addSurfaceNormal(vector: Vector3d): void;
    addUVParam(uvParam: XAndY): void;
    addUVParamAsUV(u: number, v: number): void;
    announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    appendFractionalStrokePoints(curve: CurvePrimitive, numStrokes: number, fraction0?: number, fraction1?: number, include01?: boolean): void;
    appendFractionToPoint(curve: CurvePrimitive, fraction: number): void;
    appendInterpolatedStrokePoints(numStrokes: number, point0: Point3d, point1: Point3d, include01: boolean): void;
    appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number;
    appendStrokePoint(point: Point3d, fraction?: number): void;
    clear(): void;
    clone(): LineString3d;
    clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined;
    cloneTransformed(transform: Transform): CurvePrimitive;
    closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter, result?: CurveLocationDetail): CurveLocationDetail;
    collectCurvePrimitivesGo(collectorArray: CurvePrimitive[], _smallestPossiblePrimitives: boolean, explodeLinestrings?: boolean): void;
    computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap): void;
    computeStrokeCountForOptions(options?: StrokeOptions): number;
    computeUVFromXYZTransform(transform: Transform): void;
    static create(...points: any[]): LineString3d;
    static createArrayOfLineString3d(data: MultiLineStringDataVariant): LineString3d[];
    static createCapture(points: GrowableXYZArray): LineString3d;
    static createFloat64Array(xyzData: Float64Array): LineString3d;
    static createForStrokes(capacity: number | undefined, options: StrokeOptions | undefined): LineString3d;
    static createIndexedPoints(points: Point3d[], index: number[], addClosure?: boolean): LineString3d;
    static createPoints(points: Point3d[]): LineString3d;
    static createRectangleXY(point0: Point3d, ax: number, ay: number, closed?: boolean): LineString3d;
    static createRegularPolygonXY(center: Point3d, edgeCount: number, radius: number, radiusToVertices?: boolean): LineString3d;
    static createXY(points: XAndY[], z: number, enforceClosure?: boolean): LineString3d;
    curveLength(): number;
    curveLengthBetweenFractions(fraction0: number, fraction1: number): number;
    readonly curvePrimitiveType = "lineString";
    derivativeAt(i: number, result?: Vector3d): Vector3d | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void;
    emitStrokes(dest: LineString3d, options?: StrokeOptions): void;
    endPoint(): Point3d;
    ensureEmptyDerivatives(): GrowableXYZArray;
    ensureEmptyFractions(): GrowableFloat64Array;
    ensureEmptyNormalIndices(): GrowableFloat64Array;
    ensureEmptyPointIndices(): GrowableFloat64Array;
    ensureEmptySurfaceNormals(): GrowableXYZArray;
    ensureEmptyUVIndices(): GrowableFloat64Array;
    ensureEmptyUVParams(): GrowableXYArray;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    get fractions(): GrowableFloat64Array | undefined;
    fractionToFrenetFrame(fraction: number, result?: Transform): Transform;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;
    static fromJSON(json?: any): LineString3d;
    getIndexedSegment(index: number): LineSegment3d | undefined;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isExtensibleFractionSpace(): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    get isPhysicallyClosed(): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail;
    get normalIndices(): GrowableFloat64Array | undefined;
    numPoints(): number;
    get packedDerivatives(): GrowableXYZArray | undefined;
    get packedPoints(): GrowableXYZArray;
    get packedSurfaceNormals(): GrowableXYZArray | undefined;
    get packedUVParams(): GrowableXYArray | undefined;
    get paramIndices(): GrowableFloat64Array | undefined;
    pointAt(i: number, result?: Point3d): Point3d | undefined;
    get pointIndices(): GrowableFloat64Array | undefined;
    get points(): Point3d[];
    popPoint(): void;
    quickLength(): number;
    quickUnitNormal(result?: Vector3d): Vector3d | undefined;
    reverseInPlace(): void;
    segmentIndexAndLocalFractionToGlobalFraction(index: number, localFraction: number): number;
    setFrom(other: LineString3d): void;
    setFromJSON(json?: any): void;
    startPoint(): Point3d;
    surfaceNormalAt(i: number, result?: Vector3d): Vector3d | undefined;
    toJSON(): any;
    tryTransformInPlace(transform: Transform): boolean;
    vectorBetween(i: number, j: number, result?: Vector3d): Vector3d | undefined;
    }

// @public
export type LineStringDataVariant = IndexedXYZCollection | XYAndZ[] | XAndY[] | number[][];

// @public
export class LongitudeLatitudeNumber implements BeJSONFunctions {
    get altitude(): number;
    set altitude(value: number);
    clone(): LongitudeLatitudeNumber;
    static create(longitude: Angle, latitude: Angle, h?: number, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber;
    static createDegrees(longitudeDegrees: number, latitudeDegrees: number, h?: number, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber;
    static createRadians(longitudeRadians: number, latitudeRadians: number, h?: number, result?: LongitudeLatitudeNumber): LongitudeLatitudeNumber;
    static createZero(): LongitudeLatitudeNumber;
    isAlmostEqual(other: LongitudeLatitudeNumber): boolean;
    get latitude(): Angle;
    get latitudeDegrees(): number;
    get latitudeRadians(): number;
    get latitudeRef(): Angle;
    get longitude(): Angle;
    get longitudeDegrees(): number;
    get longitudeRadians(): number;
    get longitudeRef(): Angle;
    setFromJSON(json: any): void;
    toJSON(): any;
}

// @public
export class Loop extends CurveChain {
    constructor();
    announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent?: number): void;
    cloneEmptyPeer(): Loop;
    cloneStroked(options?: StrokeOptions): AnyCurve;
    static create(...curves: CurvePrimitive[]): Loop;
    static createArray(curves: CurvePrimitive[]): Loop;
    static createPolygon(points: IndexedXYZCollection | Point3d[]): Loop;
    readonly curveCollectionType = "loop";
    dgnBoundaryType(): number;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    isInner: boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
}

// @public
export type LowAndHighXY = Readonly<WritableLowAndHighXY>;

// @public
export type LowAndHighXYZ = Readonly<WritableLowAndHighXYZ>;

// @public
export class Map4d implements BeJSONFunctions {
    clone(): Map4d;
    static createBoxMap(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Map4d): Map4d | undefined;
    static createIdentity(): Map4d;
    static createRefs(matrix0: Matrix4d, matrix1: Matrix4d): Map4d;
    static createTransform(transform0: Transform, transform1?: Transform): Map4d | undefined;
    static createVectorFrustum(origin: Point3d, uVector: Vector3d, vVector: Vector3d, wVector: Vector3d, fraction: number): Map4d | undefined;
    static fromJSON(json?: any): Map4d;
    isAlmostEqual(other: Map4d): boolean;
    multiplyMapMap(other: Map4d): Map4d;
    reverseInPlace(): void;
    sandwich0This1(other: Map4d): Map4d;
    sandwich1This0(other: Map4d): Map4d;
    setFrom(other: Map4d): void;
    setFromJSON(json: any): void;
    setIdentity(): void;
    toJSON(): any;
    get transform0(): Matrix4d;
    get transform1(): Matrix4d;
}

// @public
export class Matrix3d implements BeJSONFunctions {
    constructor(coffs?: Float64Array);
    addScaledInPlace(other: Matrix3d, scale: number): void;
    addScaledOuterProductInPlace(vectorU: Vector3d, vectorV: Vector3d, scale: number): void;
    applyGivensColumnOp(i: number, j: number, c: number, s: number): void;
    at(row: number, column: number): number;
    axisOrderCrossProductsInPlace(axisOrder: AxisOrder): void;
    clone(result?: Matrix3d): Matrix3d;
    coffs: Float64Array;
    columnDotXYZ(columnIndex: AxisIndex, x: number, y: number, z: number): number;
    columnX(result?: Vector3d): Vector3d;
    columnXDotColumnY(): number;
    columnXMagnitude(): number;
    columnXMagnitudeSquared(): number;
    columnXYCrossProductMagnitude(): number;
    columnY(result?: Vector3d): Vector3d;
    columnYMagnitude(): number;
    columnYMagnitudeSquared(): number;
    columnZ(result?: Vector3d): Vector3d;
    columnZCrossVector(vector: XYZ, result?: Vector3d): Vector3d;
    columnZMagnitude(): number;
    columnZMagnitudeSquared(): number;
    computeCachedInverse(useCacheIfAvailable: boolean): boolean;
    conditionNumber(): number;
    static create90DegreeRotationAroundAxis(axisIndex: number): Matrix3d;
    static createCapture(coffs: Float64Array, inverseCoffs?: Float64Array): Matrix3d;
    static createColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d;
    static createColumnsInAxisOrder(axisOrder: AxisOrder, columnA: Vector3d, columnB: Vector3d, columnC: Vector3d | undefined, result?: Matrix3d): Matrix3d;
    static createColumnsXYW(vectorU: XAndY, u: number, vectorV: XAndY, v: number, vectorW: XAndY, w: number, result?: Matrix3d): Matrix3d;
    static createDirectionalScale(direction: Vector3d, scale: number, result?: Matrix3d): Matrix3d;
    static createFromQuaternion(quat: Point4d): Matrix3d;
    static createIdentity(result?: Matrix3d): Matrix3d;
    static createPartialRotationVectorToVector(vectorA: Vector3d, fraction: number, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined;
    static createPerpendicularVectorFavorPlaneContainingZ(vector: Vector3d, result?: Vector3d): Vector3d;
    static createPerpendicularVectorFavorXYPlane(vector: Vector3d, result?: Vector3d): Vector3d;
    static createRigidFromColumns(vectorA: Vector3d, vectorB: Vector3d, axisOrder: AxisOrder, result?: Matrix3d): Matrix3d | undefined;
    static createRigidFromMatrix3d(source: Matrix3d, axisOrder?: AxisOrder, result?: Matrix3d): Matrix3d | undefined;
    static createRigidHeadsUp(vectorA: Vector3d, axisOrder?: AxisOrder, result?: Matrix3d): Matrix3d;
    static createRigidViewAxesZTowardsEye(x: number, y: number, z: number, result?: Matrix3d): Matrix3d;
    static createRotationAroundAxisIndex(axisIndex: AxisIndex, angle: Angle, result?: Matrix3d): Matrix3d;
    static createRotationAroundVector(axis: Vector3d, angle: Angle, result?: Matrix3d): Matrix3d | undefined;
    static createRotationVectorToVector(vectorA: Vector3d, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined;
    static createRows(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d;
    static createRowValues(axx: number, axy: number, axz: number, ayx: number, ayy: number, ayz: number, azx: number, azy: number, azz: number, result?: Matrix3d): Matrix3d;
    static createScale(scaleFactorX: number, scaleFactorY: number, scaleFactorZ: number, result?: Matrix3d): Matrix3d;
    static createShuffledColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, axisOrder: AxisOrder, result?: Matrix3d): Matrix3d;
    static createStandardWorldToView(index: StandardViewIndex, invert?: boolean, result?: Matrix3d): Matrix3d;
    static createUniformScale(scaleFactor: number): Matrix3d;
    static createViewedAxes(rightVector: Vector3d, upVector: Vector3d, leftNoneRight?: number, topNoneBottom?: number): Matrix3d | undefined;
    static createZero(): Matrix3d;
    determinant(): number;
    dotColumnX(vector: XYZ): number;
    dotColumnY(vector: XYZ): number;
    dotColumnZ(vector: XYZ): number;
    dotRowX(vector: XYZ): number;
    dotRowXXYZ(x: number, y: number, z: number): number;
    dotRowY(vector: XYZ): number;
    dotRowYXYZ(x: number, y: number, z: number): number;
    dotRowZ(vector: XYZ): number;
    dotRowZXYZ(x: number, y: number, z: number): number;
    factorPerpendicularColumns(matrixC: Matrix3d, matrixU: Matrix3d): boolean;
    factorRigidWithSignedScale(): {
        rigidAxes: Matrix3d;
        scale: number;
    } | undefined;
    fastSymmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean;
    static flatIndexOf(row: number, column: number): number;
    freeze(): Readonly<this>;
    static fromJSON(json?: Matrix3dProps): Matrix3d;
    getAxisAndAngleOfRotation(): {
        axis: Vector3d;
        angle: Angle;
        ok: boolean;
    };
    getColumn(columnIndex: number, result?: Vector3d): Vector3d;
    getRow(columnIndex: number, result?: Vector3d): Vector3d;
    get hasCachedInverse(): boolean;
    static get identity(): Matrix3d;
    indexedColumnWithWeight(index: number, weight: number, result?: Point4d): Point4d;
    inverse(result?: Matrix3d): Matrix3d | undefined;
    inverseCoffs: Float64Array | undefined;
    inverseState: InverseMatrixState;
    isAlmostEqual(other: Matrix3d, tol?: number): boolean;
    get isDiagonal(): boolean;
    isExactEqual(other: Matrix3d): boolean;
    get isIdentity(): boolean;
    isRigid(allowMirror?: boolean): boolean;
    get isSignedPermutation(): boolean;
    isSingular(): boolean;
    get isUpperTriangular(): boolean;
    get isXY(): boolean;
    markSingular(): void;
    maxAbs(): number;
    maxDiff(other: Matrix3d): number;
    multiplyInverse(vector: Vector3d, result?: Vector3d): Vector3d | undefined;
    multiplyInverseTranspose(vector: Vector3d, result?: Vector3d): Vector3d | undefined;
    multiplyInverseXYZAsPoint3d(x: number, y: number, z: number, result?: Point3d): Point3d | undefined;
    multiplyInverseXYZAsVector3d(x: number, y: number, z: number, result?: Vector3d): Vector3d | undefined;
    multiplyInverseXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d | undefined;
    multiplyMatrixInverseMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d | undefined;
    multiplyMatrixMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d;
    multiplyMatrixMatrixInverse(other: Matrix3d, result?: Matrix3d): Matrix3d | undefined;
    multiplyMatrixMatrixTranspose(matrixB: Matrix3d, result?: Matrix3d): Matrix3d;
    multiplyMatrixTransform(other: Transform, result?: Transform): Transform;
    multiplyMatrixTransposeMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d;
    multiplyTransposeVector(vector: Vector3d, result?: Vector3d): Vector3d;
    multiplyTransposeVectorInPlace(vectorU: XYZ): void;
    multiplyTransposeXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d;
    multiplyVector(vectorU: XYAndZ, result?: Vector3d): Vector3d;
    multiplyVectorArrayInPlace(data: XYZ[]): void;
    multiplyVectorInPlace(xyzData: XYZ): void;
    multiplyXY(x: number, y: number, result?: Vector3d): Vector3d;
    multiplyXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d;
    multiplyXYZtoXYZ(xyz: XYZ, result: XYZ): XYZ;
    normalizeColumnsInPlace(originalMagnitudes?: Vector3d): boolean;
    normalizeRowsInPlace(originalMagnitudes?: Vector3d): boolean;
    static numComputeCache: number;
    static numUseCache: number;
    originPlusMatrixTimesXY(origin: XYZ, x: number, y: number, result?: Point3d): Point3d;
    rowX(result?: Vector3d): Vector3d;
    rowXMagnitude(): number;
    rowY(result?: Vector3d): Vector3d;
    rowYMagnitude(): number;
    rowZ(result?: Vector3d): Vector3d;
    rowZMagnitude(): number;
    sameDiagonalScale(): number | undefined;
    scale(scale: number, result?: Matrix3d): Matrix3d;
    scaleColumns(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d;
    scaleColumnsInPlace(scaleX: number, scaleY: number, scaleZ: number): void;
    scaleRows(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d;
    setAt(row: number, column: number, value: number): void;
    setColumn(columnIndex: number, value: Vector3d | undefined): void;
    setColumns(vectorX: Vector3d | undefined, vectorY: Vector3d | undefined, vectorZ?: Vector3d | undefined): void;
    setColumnsPoint4dXYZ(vectorU: Point4d, vectorV: Point4d, vectorW: Point4d): void;
    setFrom(other: Matrix3d | undefined): void;
    setFromJSON(json?: Matrix3dProps | Matrix3d): void;
    setIdentity(): void;
    setRow(rowIndex: number, value: Vector3d): void;
    setRowValues(axx: number, axy: number, axz: number, ayx: number, ayy: number, ayz: number, azx: number, azy: number, azz: number): void;
    setZero(): void;
    sumDiagonal(): number;
    sumDiagonalSquares(): number;
    sumSkewSquares(): number;
    sumSquares(): number;
    symmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean;
    testPerpendicularUnitRowsAndColumns(): boolean;
    toJSON(): Matrix3dProps;
    toQuaternion(): Point4d;
    transpose(result?: Matrix3d): Matrix3d;
    transposeInPlace(): void;
    static useCachedInverse: boolean;
    static xyPlusMatrixTimesXY(origin: XAndY, matrix: Matrix3d, vector: XAndY, result?: Point2d): Point2d;
    static xyzMinusMatrixTimesXYZ(origin: XYAndZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d;
    static xyzPlusMatrixTimesCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Point3d): Point3d;
    static xyzPlusMatrixTimesCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Float64Array): Float64Array;
    static xyzPlusMatrixTimesWeightedCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Point4d): Point4d;
    static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array;
    static xyzPlusMatrixTimesXYZ(origin: XYZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d;
    static xyzPlusMatrixTimesXYZInPlace(origin: XYZ, matrix: Matrix3d, vector: WritableXYAndZ): void;
}

// @public
export type Matrix3dProps = number[][] | number[];

// @public
export class Matrix4d implements BeJSONFunctions {
    addMomentsInPlace(x: number, y: number, z: number, w: number): void;
    addScaledInPlace(other: Matrix4d, scale?: number): void;
    addScaledOuterProductInPlace(vectorU: Point4d, vectorV: Point4d, scale: number): void;
    addTranslationSandwichInPlace(matrixB: Matrix4d, ax: number, ay: number, az: number, scale: number): void;
    get asTransform(): Transform | undefined;
    atIJ(rowIndex: number, columnIndex: number): number;
    clone(result?: Matrix4d): Matrix4d;
    cloneTransposed(result?: Matrix4d): Matrix4d;
    columnDotColumn(columnIndexThis: number, other: Matrix4d, columnIndexOther: number): number;
    columnDotRow(columnIndexThis: number, other: Matrix4d, rowIndexOther: number): number;
    columnW(): Point4d;
    columnX(): Point4d;
    columnY(): Point4d;
    columnZ(): Point4d;
    static createBoxToBox(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Matrix4d): Matrix4d | undefined;
    static createIdentity(result?: Matrix4d): Matrix4d;
    createInverse(result?: Matrix4d): Matrix4d | undefined;
    static createRows(rowX: Point4d, rowY: Point4d, rowZ: Point4d, rowW: Point4d, result?: Matrix4d): Matrix4d;
    static createRowValues(cxx: number, cxy: number, cxz: number, cxw: number, cyx: number, cyy: number, cyz: number, cyw: number, czx: number, czy: number, czz: number, czw: number, cwx: number, cwy: number, cwz: number, cww: number, result?: Matrix4d): Matrix4d;
    static createTransform(source: Transform, result?: Matrix4d): Matrix4d;
    static createTranslationAndScaleXYZ(tx: number, ty: number, tz: number, scaleX: number, scaleY: number, scaleZ: number, result?: Matrix4d): Matrix4d;
    static createTranslationXYZ(x: number, y: number, z: number, result?: Matrix4d): Matrix4d;
    static createZero(result?: Matrix4d): Matrix4d;
    determinant(): number;
    diagonal(): Point4d;
    static fromJSON(json?: Matrix4dProps): Matrix4d;
    getSteppedPoint(i0: number, step: number, result?: Point4d): Point4d;
    get hasPerspective(): boolean;
    isAlmostEqual(other: Matrix4d): boolean;
    isExactEqual(other: Matrix4d): boolean;
    isIdentity(tol?: number): boolean;
    matrixPart(): Matrix3d;
    maxAbs(): number;
    maxDiff(other: Matrix4d): number;
    multiplyBlockedFloat64ArrayInPlace(data: Float64Array): void;
    multiplyMatrixMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d;
    multiplyMatrixMatrixTranspose(other: Matrix4d, result?: Matrix4d): Matrix4d;
    multiplyMatrixTransposeMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d;
    multiplyPoint3d(pt: XYAndZ, w: number, result?: Point4d): Point4d;
    multiplyPoint3dArray(pts: XYAndZ[], results: Point4d[], w?: number): void;
    multiplyPoint3dArrayQuietNormalize(points: Point3d[]): void;
    multiplyPoint3dQuietNormalize(point: XYAndZ, result?: Point3d): Point3d;
    multiplyPoint4d(point: Point4d, result?: Point4d): Point4d;
    multiplyPoint4dArrayQuietRenormalize(pts: Point4d[], results: Point3d[]): void;
    multiplyTranslationSandwichInPlace(ax: number, ay: number, az: number): void;
    multiplyTransposePoint4d(point: Point4d, result?: Point4d): Point4d;
    multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d;
    multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d;
    multiplyXYZWQuietRenormalize(x: number, y: number, z: number, w: number, result?: Point3d): Point3d;
    plusScaled(matrixB: Matrix4d, scale: number, result?: Matrix4d): Matrix4d;
    rowArrays(f?: (value: number) => any): any;
    rowDotColumn(rowIndex: number, other: Matrix4d, columnIndex: number): number;
    rowDotRow(rowIndexThis: number, other: Matrix4d, rowIndexOther: number): number;
    rowOperation(rowIndexA: number, rowIndexB: number, firstColumnIndex: number, scale: number): void;
    rowW(): Point4d;
    rowX(): Point4d;
    rowY(): Point4d;
    rowZ(): Point4d;
    scaleRowsInPlace(ax: number, ay: number, az: number, aw: number): void;
    setAtIJ(rowIndex: number, columnIndex: number, value: number): void;
    setFrom(other: Matrix4d): void;
    setFromJSON(json?: Matrix4dProps): void;
    setIdentity(): void;
    setOriginAndVectors(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d): void;
    setZero(): void;
    toJSON(): Matrix4dProps;
    weight(): number;
}

// @public
export type Matrix4dProps = Point4dProps[];

// @public
export class MomentData {
    absoluteQuantity?: number;
    accumulateLineMomentsXYZ(pointA: Point3d, pointB: Point3d): void;
    accumulatePointMomentsFromOrigin(points: Point3d[]): void;
    accumulateProducts(other: MomentData, scale: number): void;
    accumulateProductsFromOrigin(origin: Point3d, products: Matrix4d, scale: number): void;
    accumulateScaledOuterProduct(point: XYAndZ, scaleFactor: number): void;
    accumulateTriangleMomentsXY(pointA: XAndY | undefined, pointB: XAndY, pointC: XAndY): void;
    accumulateTriangleToLineStringMomentsXY(sweepBase: XAndY | undefined, points: GrowableXYZArray): void;
    accumulateXYProductsInCentroidalFrame(productXX: number, productXY: number, productYY: number, area: number, origin: XAndY, vectorU: XAndY, vectorV: XAndY): void;
    static areEquivalentPrincipalAxes(dataA: MomentData | undefined, dataB: MomentData | undefined): boolean;
    clearSums(origin?: Point3d): void;
    static create(origin?: Point3d | undefined, needOrigin?: boolean): MomentData;
    static inertiaProductsToPrincipalAxes(origin: XYZ, inertiaProducts: Matrix4d): MomentData | undefined;
    localToWorldMap: Transform;
    static momentTensorFromInertiaProducts(products: Matrix3d): Matrix3d;
    needOrigin: boolean;
    origin: Point3d;
    static pointsToPrincipalAxes(points: Point3d[]): MomentData | undefined;
    get quantitySum(): number;
    radiusOfGyration: Vector3d;
    setOriginFromGrowableXYZArrayIfNeeded(points: GrowableXYZArray): void;
    setOriginIfNeeded(origin: Point3d): void;
    setOriginXYZIfNeeded(x: number, y: number, z: number): void;
    shiftOriginAndSumsByXYZ(ax: number, ay: number, az: number): void;
    shiftOriginAndSumsToCentroidOfSums(): boolean;
    shiftOriginAndSumsToNewOrigin(newOrigin: XYAndZ): void;
    signFactor(targetSign: number): number;
    static sortColumnsForIncreasingMoments(axes: Matrix3d, moments: Vector3d): void;
    sums: Matrix4d;
    toJSON(): any;
    }

// @public
export type MultiLineStringDataVariant = LineStringDataVariant | LineStringDataVariant[];

// @internal
export class Newton1dUnbounded extends AbstractNewtonIterator {
    constructor(func: NewtonEvaluatorRtoRD);
    applyCurrentStep(): boolean;
    computeStep(): boolean;
    currentStepSize(): number;
    getX(): number;
    setTarget(y: number): void;
    setX(x: number): boolean;
    }

// @internal
export class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {
    constructor(func: NewtonEvaluatorRtoR);
    applyCurrentStep(): boolean;
    computeStep(): boolean;
    currentStepSize(): number;
    derivativeH: number;
    getX(): number;
    setX(x: number): boolean;
}

// @internal
export class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {
    constructor(func: NewtonEvaluatorRRtoRRD);
    applyCurrentStep(): boolean;
    computeStep(): boolean;
    currentStepSize(): number;
    getU(): number;
    getV(): number;
    setUV(x: number, y: number): boolean;
}

// @internal
export abstract class NewtonEvaluatorRRtoRRD {
    constructor();
    currentF: Plane3dByOriginAndVectors;
    abstract evaluate(x: number, y: number): boolean;
}

// @internal
export abstract class NewtonEvaluatorRtoR {
    currentF: number;
    abstract evaluate(x: number): boolean;
}

// @internal
export abstract class NewtonEvaluatorRtoRD {
    currentdFdX: number;
    currentF: number;
    abstract evaluate(x: number): boolean;
}

// @internal
export type NodeFunction = (node: HalfEdge) => any;

// @internal
export type NodeToNumberFunction = (node: HalfEdge) => number;

// @public
export class NullGeometryHandler extends GeometryHandler {
    handleArc3d(_g: Arc3d): any;
    handleBagOfCurves(_g: BagOfCurves): any;
    handleBezierCurve3d(_g: BezierCurve3d): any;
    handleBezierCurve3dH(_g: BezierCurve3dH): any;
    handleBox(_g: Box): any;
    handleBSplineCurve3d(_g: BSplineCurve3d): any;
    handleBSplineCurve3dH(_g: BSplineCurve3dH): any;
    handleBSplineSurface3d(_g: BSplineSurface3d): any;
    handleBSplineSurface3dH(_g: BSplineSurface3dH): any;
    handleCone(_g: Cone): any;
    handleCoordinateXYZ(_g: CoordinateXYZ): any;
    handleCurveCollection(_g: CurveCollection): any;
    handleIndexedPolyface(_g: IndexedPolyface): any;
    handleLinearSweep(_g: LinearSweep): any;
    handleLineSegment3d(_g: LineSegment3d): any;
    handleLineString3d(_g: LineString3d): any;
    handleLoop(_g: Loop): any;
    handleParityRegion(_g: ParityRegion): any;
    handlePath(_g: Path): any;
    handlePointString3d(_g: PointString3d): any;
    handleRotationalSweep(_g: RotationalSweep): any;
    handleRuledSweep(_g: RuledSweep): any;
    handleSphere(_g: Sphere): any;
    handleTorusPipe(_g: TorusPipe): any;
    // @alpha
    handleTransitionSpiral(_g: TransitionSpiral3d): any;
    handleUnionRegion(_g: UnionRegion): any;
}

// @public
export class NumberArray {
    static createArrayWithMaxStepSize(low: number, high: number, step: number): number[];
    static isAlmostEqual(dataA: number[] | Float64Array | undefined, dataB: number[] | Float64Array | undefined, tolerance: number): boolean;
    static isCoordinateInArray(x: number, data: number[] | undefined): boolean;
    static isExactEqual(dataA: any[] | Float64Array | undefined, dataB: any[] | Float64Array | undefined): boolean;
    static maxAbsArray(values: number[]): number;
    static maxAbsDiff(dataA: number[] | Float64Array, dataB: number[] | Float64Array): number;
    static maxAbsDiffFloat64(dataA: Float64Array, dataB: Float64Array): number;
    static maxAbsTwo(a1: number, a2: number): number;
    static preciseSum(data: number[]): number;
    static sum(data: number[] | Float64Array): number;
}

// @public
export type OptionalGrowableFloat64Array = GrowableFloat64Array | undefined;

// @internal
export class Order2Bezier extends BezierCoffs {
    constructor(f0?: number, f1?: number);
    basisFunctions(u: number, result?: Float64Array): Float64Array;
    clone(): Order2Bezier;
    evaluate(u: number): number;
    roots(targetValue: number, restrictTo01: boolean): number[] | undefined;
    solve(rightHandSide: number): number | undefined;
    static solveCoffs(a0: number, a1: number): number | undefined;
    sumBasisFunctionDerivatives(_u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
}

// @internal
export class Order3Bezier extends BezierCoffs {
    constructor(f0?: number, f1?: number, f2?: number);
    addSquareLinear(f0: number, f1: number, a: number): void;
    basisFunctions(u: number, result?: Float64Array): Float64Array;
    clone(): Order3Bezier;
    evaluate(u: number): number;
    roots(targetValue: number, restrictTo01: boolean): number[] | undefined;
    sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
}

// @internal
export class Order4Bezier extends BezierCoffs {
    constructor(f0?: number, f1?: number, f2?: number, f3?: number);
    basisFunctions(u: number, result?: Float64Array): Float64Array;
    clone(): Order4Bezier;
    static createFromDegree3PowerPolynomial(source: Degree3PowerPolynomial): Order4Bezier;
    static createProductOrder3Order2(factorA: Order3Bezier, factorB: Order2Bezier): Order4Bezier;
    evaluate(u: number): number;
    realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array): undefined;
    sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
}

// @internal
export class Order5Bezier extends BezierCoffs {
    constructor(f0?: number, f1?: number, f2?: number, f3?: number, f4?: number);
    addConstant(a: number): void;
    addProductOrder3BezierOrder3Bezier(f: Order3Bezier, g: Order3Bezier, a: number): void;
    basisFunctions(u: number, result?: Float64Array): Float64Array;
    clone(): Order5Bezier;
    static createFromDegree4PowerPolynomial(source: Degree4PowerPolynomial): Order5Bezier;
    evaluate(u: number): number;
    realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array): void;
    sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
    sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;
}

// @alpha
export class OrderedRotationAngles {
    static createAngles(xRotation: Angle, yRotation: Angle, zRotation: Angle, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles;
    static createDegrees(xDegrees: number, yDegrees: number, zDegrees: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles;
    static createFromMatrix3d(matrix: Matrix3d, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles;
    static createRadians(xRadians: number, yRadians: number, zRadians: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles;
    get order(): AxisOrder;
    toMatrix3d(result?: Matrix3d): Matrix3d;
    static get treatVectorsAsColumns(): boolean;
    static set treatVectorsAsColumns(value: boolean);
    get xAngle(): Angle;
    get xDegrees(): number;
    get xRadians(): number;
    get yAngle(): Angle;
    get yDegrees(): number;
    get yRadians(): number;
    get zAngle(): Angle;
    get zDegrees(): number;
    get zRadians(): number;
}

// @internal
export class PackedMatrix3dOps {
    static copy(a: Float64Array, dest: Float64Array): Float64Array;
    static copyTransposed(a: Float64Array, dest?: Float64Array): Float64Array;
    static loadMatrix(dest: Float64Array, a00: number, a01: number, a02: number, a10: number, a11: number, a12: number, a20: number, a21: number, a22: number): void;
    static multiplyMatrixMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array;
    static multiplyMatrixMatrixTranspose(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array;
    static multiplyMatrixTransposeMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array;
    static transposeInPlace(a: Float64Array): void;
}

// @public
export interface PackedPointGrid {
    numCartesianDimensions: number;
    points: number[][][];
    weightStyle?: WeightStyle;
}

// @public
export class ParityRegion extends CurveCollection {
    constructor();
    addLoops(data?: Loop | Loop[] | Loop[][]): void;
    announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent?: number): void;
    get children(): Loop[];
    protected _children: Loop[];
    clone(): ParityRegion;
    cloneEmptyPeer(): ParityRegion;
    cloneStroked(options?: StrokeOptions): ParityRegion;
    static create(...data: Loop[]): ParityRegion;
    static createLoops(data?: Loop | Loop[] | Loop[][]): Loop | ParityRegion;
    readonly curveCollectionType = "parityRegion";
    dgnBoundaryType(): number;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    getChild(i: number): Loop | undefined;
    isSameGeometryClass(other: GeometryQuery): boolean;
    tryAddChild(child: AnyCurve | undefined): boolean;
}

// @internal
export class PascalCoefficients {
    static getBezierBasisDerivatives(order: number, u: number, result?: Float64Array): Float64Array;
    static getBezierBasisValues(order: number, u: number, result?: Float64Array): Float64Array;
    static getRow(row: number): Float64Array;
}

// @public
export class Path extends CurveChain {
    constructor();
    announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent?: number): void;
    cloneEmptyPeer(): Path;
    cloneStroked(options?: StrokeOptions): AnyCurve;
    static create(...curves: Array<CurvePrimitive | Point3d[]>): Path;
    static createArray(curves: CurvePrimitive[]): Path;
    readonly curveCollectionType = "path";
    dgnBoundaryType(): number;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    isSameGeometryClass(other: GeometryQuery): boolean;
}

// @public
export class PathFragment {
    constructor(childFraction0: number, childFraction1: number, distance0: number, distance1: number, childCurve: CurvePrimitive);
    chainDistance0: number;
    chainDistance1: number;
    chainDistanceToAccurateChildFraction(chainDistance: number): number;
    chainDistanceToInterpolatedChildFraction(distance: number): number;
    childCurve: CurvePrimitive;
    childFraction0: number;
    childFraction1: number;
    childFractionTChainDistance(fraction: number): number;
    containsChainDistance(distance: number): boolean;
    containsChildCurveAndChildFraction(curve: CurvePrimitive, fraction: number): boolean;
    fractionScaleFactor(globalDistance: number): number;
    reverseFractionsAndDistances(totalDistance: number): void;
}

// @public
export class Plane3dByOriginAndUnitNormal implements BeJSONFunctions, PlaneAltitudeEvaluator {
    altitude(spacePoint: Point3d): number;
    altitudeToPoint(altitude: number, result?: Point3d): Point3d;
    altitudeXYZ(x: number, y: number, z: number): number;
    altitudeXYZW(x: number, y: number, z: number, w: number): number;
    clone(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal;
    cloneTransformed(transform: Transform, inverse?: boolean): Plane3dByOriginAndUnitNormal | undefined;
    static create(origin: Point3d, normal: Vector3d, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined;
    static createPointPointVectorInPlane(pointA: Point3d, pointB: Point3d, vector: Vector3d): Plane3dByOriginAndUnitNormal | undefined;
    static createXYAngle(x: number, y: number, normalAngleFromX: Angle, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal;
    static createXYPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal;
    static createXYZUVW(ax: number, ay: number, az: number, ux: number, uy: number, uz: number, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined;
    static createYZPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal;
    static createZXPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal;
    static fromJSON(json?: any): Plane3dByOriginAndUnitNormal;
    getLocalToWorld(): Transform;
    getNormalRef(): Vector3d;
    getOriginRef(): Point3d;
    getProjectionToPlane(): Transform;
    isAlmostEqual(other: Plane3dByOriginAndUnitNormal): boolean;
    isPointInPlane(spacePoint: Point3d): boolean;
    projectPointToPlane(spacePoint: Point3d, result?: Point3d): Point3d;
    set(origin: Point3d, normal: Vector3d): void;
    setFrom(source: Plane3dByOriginAndUnitNormal): void;
    setFromJSON(json?: any): void;
    toJSON(): any;
    velocity(spaceVector: Vector3d): number;
    velocityXYZ(x: number, y: number, z: number): number;
    weightedAltitude(spacePoint: Point4d): number;
}

// @public
export class Plane3dByOriginAndVectors implements BeJSONFunctions {
    clone(): Plane3dByOriginAndVectors;
    static createCapture(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createFromTransformColumnsXYAndLengths(transform: Transform, xLength: number | undefined, yLength: number | undefined, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createOriginAndTargets(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createOriginAndVectorsArrays(origin: Float64Array, vectorU: Float64Array, vectorV: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createOriginAndVectorsWeightedArrays(originW: Float64Array, vectorUw: Float64Array, vectorVw: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createXYPlane(result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    fractionToPoint(u: number, v: number, result?: Point3d): Point3d;
    fractionToVector(u: number, v: number, result?: Vector3d): Vector3d;
    static fromJSON(json?: any): Plane3dByOriginAndVectors;
    isAlmostEqual(other: Plane3dByOriginAndVectors): boolean;
    normalizeInPlace(): boolean;
    origin: Point3d;
    setFromJSON(json?: any): void;
    setOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d): Plane3dByOriginAndVectors;
    setOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): Plane3dByOriginAndVectors;
    toJSON(): any;
    toRigidFrame(result?: Transform): Transform | undefined;
    transformInPlace(transform: Transform): void;
    unitNormal(result?: Vector3d): Vector3d | undefined;
    unitNormalRay(result?: Ray3d): Ray3d | undefined;
    vectorU: Vector3d;
    vectorV: Vector3d;
    }

// @public
export interface PlaneAltitudeEvaluator {
    altitude(point: Point3d): number;
    altitudeXYZ(x: number, y: number, z: number): number;
    velocity(vector: Vector3d): number;
    velocityXYZ(x: number, y: number, z: number): number;
    weightedAltitude(point: Point4d): number;
}

// @public
export class PlaneByOriginAndVectors4d {
    clone(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d;
    static createOriginAndTargets3d(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d;
    static createOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d;
    static createOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d;
    static createXYPlane(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d;
    fractionToPoint(u: number, v: number, result?: Point4d): Point4d;
    isAlmostEqual(other: PlaneByOriginAndVectors4d): boolean;
    origin: Point4d;
    setFrom(other: PlaneByOriginAndVectors4d): void;
    setOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d): PlaneByOriginAndVectors4d;
    setOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number): PlaneByOriginAndVectors4d;
    vectorU: Point4d;
    vectorV: Point4d;
}

// @public
export class Point2d extends XY implements BeJSONFunctions {
    constructor(x?: number, y?: number);
    addForwardLeft(tangentFraction: number, leftFraction: number, vector: Vector2d): Point2d;
    clone(): Point2d;
    static create(x?: number, y?: number, result?: Point2d): Point2d;
    static createFrom(xy: XAndY | undefined, result?: Point2d): Point2d;
    static createZero(result?: Point2d): Point2d;
    crossProductToPoints(target1: XAndY, target2: XAndY): number;
    dotVectorsToTargets(targetA: XAndY, targetB: XAndY): number;
    forwardLeftInterpolate(tangentFraction: number, leftFraction: number, point: XAndY): Point2d;
    fractionOfProjectionToLine(startPoint: Point2d, endPoint: Point2d, defaultFraction?: number): number;
    static fromJSON(json?: XYProps): Point2d;
    interpolate(fraction: number, other: XAndY, result?: Point2d): Point2d;
    interpolateXY(fractionX: number, fractionY: number, other: XAndY, result?: Point2d): Point2d;
    minus(vector: XAndY, result?: Point2d): Point2d;
    plus(vector: XAndY, result?: Point2d): Point2d;
    plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Point2d): Point2d;
    plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Point2d): Point2d;
    plusScaled(vector: XAndY, scaleFactor: number, result?: Point2d): Point2d;
    plusXY(dx?: number, dy?: number, result?: Point2d): Point2d;
}

// @public
export class Point2dArray {
    static clonePoint2dArray(data: Point2d[]): Point2d[];
    static isAlmostEqual(dataA: undefined | Point2d[], dataB: undefined | Point2d[]): boolean;
    static pointCountExcludingTrailingWraparound(data: XAndY[]): number;
}

// @public
export class Point2dArrayCarrier extends IndexedXYCollection {
    constructor(data: Point2d[]);
    crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number): number | undefined;
    crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined;
    data: Point2d[];
    getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined;
    getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined;
    isValidIndex(index: number): boolean;
    get length(): number;
    vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined;
    vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined;
}

// @public
export class Point3d extends XYZ {
    constructor(x?: number, y?: number, z?: number);
    clone(result?: Point3d): Point3d;
    static create(x?: number, y?: number, z?: number, result?: Point3d): Point3d;
    static createAdd2Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, result?: Point3d): Point3d;
    static createAdd3Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, pointC: XYAndZ, scaleC: number, result?: Point3d): Point3d;
    static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Point3d): Point3d;
    static createFromPacked(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined;
    static createFromPackedXYZW(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined;
    static createScale(source: XYAndZ, scale: number, result?: Point3d): Point3d;
    static createZero(result?: Point3d): Point3d;
    crossProductToPoints(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d;
    crossProductToPointsMagnitude(pointA: Point3d, pointB: Point3d): number;
    crossProductToPointsXY(pointA: Point3d, pointB: Point3d): number;
    dotVectorsToTargets(targetA: Point3d, targetB: Point3d): number;
    fractionOfProjectionToLine(startPoint: Point3d, endPoint: Point3d, defaultFraction?: number): number;
    static fromJSON(json?: XYZProps): Point3d;
    interpolate(fraction: number, other: XYAndZ, result?: Point3d): Point3d;
    interpolatePerpendicularXY(fraction: number, pointB: Point3d, fractionXYPerp: number, result?: Point3d): Point3d;
    interpolatePointAndTangent(fraction: number, other: Point3d, tangentScale: number, result?: Ray3d): Ray3d;
    interpolateXYZ(fractionX: number, fractionY: number, fractionZ: number, other: Point3d, result?: Point3d): Point3d;
    minus(vector: XYAndZ, result?: Point3d): Point3d;
    plus(vector: XYAndZ, result?: Point3d): Point3d;
    plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYZ, scalarB: number, result?: Point3d): Point3d;
    plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Point3d): Point3d;
    plusScaled(vector: XYAndZ, scaleFactor: number, result?: Point3d): Point3d;
    plusXYZ(dx?: number, dy?: number, dz?: number, result?: Point3d): Point3d;
    tripleProductToPoints(pointA: Point3d, pointB: Point3d, pointC: Point3d): number;
}

// @public
export class Point3dArray {
    static centroid(points: IndexedXYZCollection, result?: Point3d): Point3d;
    static cloneDeepJSONNumberArrays(data: MultiLineStringDataVariant): any[];
    static cloneDeepXYZPoint3dArrays(data: MultiLineStringDataVariant): any[];
    static clonePoint2dArray(data: XYAndZ[]): Point2d[];
    static clonePoint3dArray(data: XYAndZ[]): Point3d[];
    static cloneWithMaxEdgeLength(points: Point3d[], maxEdgeLength: number): Point3d[];
    static closestPointIndex(data: XYAndZ[], spacePoint: XYAndZ): number;
    static computeConvexHullXY(points: Point3d[], hullPoints: Point3d[], insidePoints: Point3d[], addClosurePoint?: boolean): void;
    // @deprecated
    static createRange(data: MultiLineStringDataVariant): Range3d;
    static evaluateTrilinearDerivativeTransform(points: Point3d[], u: number, v: number, w: number, result?: Transform): Transform;
    static evaluateTrilinearPoint(points: Point3d[], u: number, v: number, w: number, result?: Point3d): Point3d;
    static evaluateTrilinearWeights(weights: Float64Array, u0: number, u1: number, v0: number, v1: number, w0: number, w1: number): void;
    static indexOfMostDistantPoint(points: Point3d[], spacePoint: XYZ, farVector: Vector3d): number | undefined;
    static indexOfPointWithMaxCrossProductMagnitude(points: Point3d[], spacePoint: Point3d, vector: Vector3d, farVector: Vector3d): number | undefined;
    static isAlmostEqual(dataA: Point3d[] | Float64Array | undefined, dataB: Point3d[] | Float64Array | undefined): boolean;
    static isCloseToPlane(data: Point3d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance?: number): boolean;
    static minMaxPoints(data: Point3d[]): {
        minXPoint: Point3d;
        maxXPoint: Point3d;
        minYPoint: Point3d;
        maxYPoint: Point3d;
    } | undefined;
    static multiplyInPlace(transform: Transform, xyz: Float64Array): void;
    static packToFloat64Array(data: Point3d[]): Float64Array;
    static sumEdgeLengths(data: Point3d[] | Float64Array, addClosureEdge?: boolean): number;
    static sumWeightedX(weights: Float64Array, points: Point3d[]): number;
    static sumWeightedY(weights: Float64Array, points: Point3d[]): number;
    static sumWeightedZ(weights: Float64Array, points: Point3d[]): number;
    static unpackNumbersToNestedArrays(data: Float64Array, numPerBlock: number): any[];
    static unpackNumbersToNestedArraysIJK(data: Float64Array, numPerBlock: number, numPerRow: number): any[];
    static unpackNumbersToPoint3dArray(data: Float64Array | number[]): Point3d[];
    }

// @public
export class Point3dArrayCarrier extends IndexedReadWriteXYZCollection {
    constructor(data: Point3d[]);
    accumulateCrossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result: Vector3d): void;
    accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void;
    back(result?: Point3d): Point3d | undefined;
    clear(): void;
    crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    cyclicIndex(i: number): number;
    data: Point3d[];
    distanceIndexIndex(index0: number, index1: number): number | undefined;
    distanceSquaredIndexIndex(index0: number, index1: number): number | undefined;
    front(result?: Point3d): Point3d | undefined;
    getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined;
    getPoint3dAtUncheckedPointIndex(index: number, result?: Point3d): Point3d;
    getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined;
    getXAtUncheckedPointIndex(pointIndex: number): number;
    getYAtUncheckedPointIndex(pointIndex: number): number;
    getZAtUncheckedPointIndex(pointIndex: number): number;
    isValidIndex(index: number): boolean;
    get length(): number;
    pop(): void;
    push(data: Point3d): void;
    pushXYZ(x?: number, y?: number, z?: number): void;
    reverseInPlace(): void;
    vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;
    vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined;
}

// @public
export class Point3dArrayPolygonOps {
    static convexPolygonClipInPlace(plane: PlaneAltitudeEvaluator, xyz: Point3d[], work: Point3d[] | undefined, tolerance?: number): void;
    static convexPolygonSplitInsideOutsidePlane(plane: PlaneAltitudeEvaluator, xyz: Point3d[], xyzIn: Point3d[], xyzOut: Point3d[], altitudeRange: Range1d): void;
    static polygonPlaneCrossings(plane: PlaneAltitudeEvaluator, xyz: Point3d[], crossings: Point3d[]): void;
    }

// @public
export class Point4d implements BeJSONFunctions {
    protected constructor(x?: number, y?: number, z?: number, w?: number);
    altitude(point: Point3d): number;
    altitudeXYZ(x: number, y: number, z: number): number;
    clone(result?: Point4d): Point4d;
    static create(x?: number, y?: number, z?: number, w?: number, result?: Point4d): Point4d;
    static createAdd2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d;
    static createAdd3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d;
    static createFromPackedXYZW(data: Float64Array, xIndex?: number, result?: Point4d): Point4d;
    static createFromPointAndWeight(xyz: XYAndZ, w: number): Point4d;
    static createPlanePointPointZ(pointA: Point4d, pointB: Point4d, result?: Point4d): Point4d;
    static createRealDerivativePlane3dByOriginAndVectorsDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, ddx: number, ddy: number, ddz: number, ddw: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    static createRealDerivativeRay3dDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, result?: Ray3d): Ray3d;
    static createRealPoint3dDefault000(x: number, y: number, z: number, w: number, result?: Point3d): Point3d;
    static createZero(): Point4d;
    crossWeightedMinus(other: Point4d, result?: Vector3d): Vector3d;
    crossWeightedMinusPoint3d(other: Point3d, result?: Vector3d): Vector3d;
    static determinantIndexed3X3(pointA: Point4d, pointB: Point4d, pointC: Point4d, i: number, j: number, k: number): number;
    distanceSquaredXYZW(other: Point4d): number;
    distanceXYZW(other: Point4d): number;
    dotProduct(other: Point4d): number;
    dotProductXYZW(x: number, y: number, z: number, w: number): number;
    dotVectorsToTargets(targetA: Point4d, targetB: Point4d): number;
    static fromJSON(json?: Point4dProps): Point4d;
    interpolate(fraction: number, pointB: Point4d, result?: Point4d): Point4d;
    static interpolateQuaternions(quaternion0: Point4d, fractionParameter: number, quaternion1: Point4d, result?: Point4d): Point4d;
    isAlmostEqual(other: Point4d): boolean;
    isAlmostEqualXYZW(x: number, y: number, z: number, w: number): boolean;
    get isAlmostZero(): boolean;
    magnitudeSquaredXYZ(): number;
    magnitudeXYZW(): number;
    maxAbs(): number;
    maxDiff(other: Point4d): number;
    minus(other: Point4d, result?: Point4d): Point4d;
    negate(result?: Point4d): Point4d;
    normalizeQuaternion(): number;
    normalizeWeight(result?: Point4d): Point4d | undefined;
    normalizeXYZW(result?: Point4d): Point4d | undefined;
    static perpendicularPoint4dPlane(pointA: Point4d, pointB: Point4d, pointC: Point4d): Point4d;
    plus(other: Point4d, result?: Point4d): Point4d;
    plus2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d;
    plus3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d;
    plusScaled(vector: Point4d, scaleFactor: number, result?: Point4d): Point4d;
    radiansToPoint4dXYZW(other: Point4d): number | undefined;
    realDistanceXY(other: Point4d): number | undefined;
    realPoint(result?: Point3d): Point3d | undefined;
    realPointDefault000(result?: Point3d): Point3d;
    realPointOrVector(): Point3d | Vector3d;
    safeDivideOrNull(denominator: number, result?: Point4d): Point4d | undefined;
    scale(scale: number, result?: Point4d): Point4d;
    set(x?: number, y?: number, z?: number, w?: number): Point4d;
    setComponent(index: number, value: number): void;
    setFrom(other: Point4d): Point4d;
    setFromJSON(json?: Point4dProps): void;
    toJSON(): Point4dProps;
    toPlane3dByOriginAndUnitNormal(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined;
    static unitW(): Point4d;
    static unitX(): Point4d;
    static unitY(): Point4d;
    static unitZ(): Point4d;
    velocity(vector: Vector3d): number;
    velocityXYZ(x: number, y: number, z: number): number;
    get w(): number;
    set w(val: number);
    weightedAltitude(point: Point4d): number;
    get x(): number;
    set x(val: number);
    xyzw: Float64Array;
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
}

// @public
export class Point4dArray {
    static isAlmostEqual(dataA: Point4d[] | Float64Array | undefined, dataB: Point4d[] | Float64Array | undefined): boolean;
    static isCloseToPlane(data: Point4d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance?: number): boolean;
    static multiplyInPlace(transform: Transform, xyzw: Float64Array): void;
    static packPointsAndWeightsToFloat64Array(data: Point3d[] | Float64Array | number[], weights: number[] | Float64Array, result?: Float64Array): Float64Array | undefined;
    static packToFloat64Array(data: Point4d[], result?: Float64Array): Float64Array;
    static unpackFloat64ArrayToPointsAndWeights(data: Float64Array, points: Point3d[], weights: number[], pointFormatter?: (x: number, y: number, z: number) => any): void;
    static unpackToPoint4dArray(data: Float64Array): Point4d[];
    }

// @public
export type Point4dProps = number[];

// @public
export class PointString3d extends GeometryQuery implements BeJSONFunctions {
    addPoint(point: Point3d): void;
    addPoints(...points: any[]): void;
    clear(): void;
    clone(): PointString3d;
    cloneTransformed(transform: Transform): PointString3d;
    closestPoint(spacePoint: Point3d): {
        index: number;
        xyz: Point3d;
    };
    static create(...points: any[]): PointString3d;
    static createFloat64Array(xyzData: Float64Array): PointString3d;
    static createPoints(points: Point3d[]): PointString3d;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    static fromJSON(json?: any): PointString3d;
    readonly geometryCategory = "pointCollection";
    isAlmostEqual(other: GeometryQuery): boolean;
    isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;
    isSameGeometryClass(other: GeometryQuery): boolean;
    numPoints(): number;
    pointAt(i: number, result?: Point3d): Point3d | undefined;
    get points(): Point3d[];
    popPoint(): void;
    reverseInPlace(): void;
    setFrom(other: PointString3d): void;
    setFromJSON(json?: any): void;
    toJSON(): any;
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export abstract class Polyface extends GeometryQuery {
    protected constructor(data: PolyfaceData);
    static areIndicesValid(indices: number[] | undefined, indexPositionA: number, indexPositionB: number, data: any | undefined, dataLength: number): boolean;
    abstract createVisitor(_numWrap: number): PolyfaceVisitor;
    data: PolyfaceData;
    readonly geometryCategory = "polyface";
    abstract get isEmpty(): boolean;
    get twoSided(): boolean;
    set twoSided(value: boolean);
}

// @public
export class PolyfaceAuxData {
    constructor(channels: AuxChannel[], indices: number[]);
    channels: AuxChannel[];
    clone(): PolyfaceAuxData;
    createForVisitor(): PolyfaceAuxData;
    indices: number[];
    isAlmostEqual(other: PolyfaceAuxData, tol?: number): boolean;
    static isAlmostEqual(left: PolyfaceAuxData | undefined, right: PolyfaceAuxData | undefined, tol?: number): boolean;
}

// @public
export class PolyfaceBuilder extends NullGeometryHandler {
    addBetweenLineStringsWithRuleEdgeNormals(lineStringA: LineString3d, vA: number, lineStringB: LineString3d, vB: number, addClosure?: boolean): void;
    addBetweenLineStringsWithStoredIndices(lineStringA: LineString3d, lineStringB: LineString3d): void;
    addBetweenTransformedLineStrings(curves: AnyCurve, transformA: Transform, transformB: Transform, addClosure?: boolean): void;
    addBox(box: Box): void;
    addCone(cone: Cone): void;
    addCoordinateFacets(pointArray: Point3d[][], paramArray?: Point2d[][], normalArray?: Vector3d[][], endFace?: boolean): void;
    addFacetFromGrowableArrays(points: GrowableXYZArray, normals: GrowableXYZArray | undefined, params: GrowableXYArray | undefined, colors: number[] | undefined): void;
    addFacetFromVisitor(visitor: PolyfaceVisitor): void;
    addGeometryQuery(g: GeometryQuery): void;
    // @internal
    addGraph(graph: HalfEdgeGraph, needParams: boolean, acceptFaceFunction?: HalfEdgeToBooleanFunction, isEdgeVisibleFunction?: HalfEdgeToBooleanFunction | undefined): void;
    // @internal
    addGraphFaces(_graph: HalfEdgeGraph, faces: HalfEdge[]): void;
    addGreedyTriangulationBetweenLineStrings(pointsA: Point3d[] | LineString3d | IndexedXYZCollection, pointsB: Point3d[] | LineString3d | IndexedXYZCollection): void;
    addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform?: Transform): void;
    addLinearSweep(surface: LinearSweep): void;
    addLinearSweepLineStringsXYZOnly(contour: AnyCurve, vector: Vector3d): void;
    // (undocumented)
    addMiteredPipes(centerline: IndexedXYZCollection | Point3d[] | CurvePrimitive, radius: number, numFacetAround?: number): void;
    addPolygon(points: Point3d[], numPointsToUse?: number): void;
    addPolygonGrowableXYZArray(points: GrowableXYZArray): void;
    addQuadFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]): void;
    addRotationalSweep(surface: RotationalSweep): void;
    addRuledSweep(surface: RuledSweep): boolean;
    addSphere(sphere: Sphere, strokeCount?: number): void;
    addTorusPipe(surface: TorusPipe, phiStrokeCount?: number, thetaStrokeCount?: number): void;
    addTransformedUnitBox(transform: Transform): void;
    addTriangleFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]): void;
    addTriangleFan(conePoint: Point3d, ls: LineString3d, toggle: boolean): void;
    addTrianglesInUncheckedConvexPolygon(ls: LineString3d, toggle: boolean): void;
    addTriangulatedRegion(region: AnyRegion): void;
    addUVGridBody(surface: UVSurface, numU: number, numV: number, uMap?: Segment1d, vMap?: Segment1d): void;
    applyStrokeCountsToCurvePrimitives(data: AnyCurve | GeometryQuery): void;
    claimPolyface(compress?: boolean): IndexedPolyface;
    static create(options?: StrokeOptions): PolyfaceBuilder;
    endFace(): boolean;
    findOrAddNormalInGrowableXYZArray(xyz: GrowableXYZArray, index: number, transform?: Transform, priorIndex?: number): number | undefined;
    findOrAddNormalInLineString(ls: LineString3d, index: number, transform?: Transform, priorIndexA?: number, priorIndexB?: number): number | undefined;
    findOrAddParamInGrowableXYArray(data: GrowableXYArray, index: number): number | undefined;
    findOrAddParamInLineString(ls: LineString3d, index: number, v: number, priorIndexA?: number, priorIndexB?: number): number | undefined;
    findOrAddParamXY(x: number, y: number): number;
    findOrAddPoint(xyz: Point3d): number;
    findOrAddPointInGrowableXYZArray(xyz: GrowableXYZArray, index: number, transform?: Transform, priorIndex?: number): number | undefined;
    findOrAddPointInLineString(ls: LineString3d, index: number, transform?: Transform, priorIndex?: number): number | undefined;
    findOrAddPointXYZ(x: number, y: number, z: number): number;
    // @internal
    static graphFacesToPolyface(graph: HalfEdgeGraph, faces: HalfEdge[]): IndexedPolyface;
    // @internal
    static graphToPolyface(graph: HalfEdgeGraph, options?: StrokeOptions, acceptFaceFunction?: HalfEdgeToBooleanFunction): IndexedPolyface;
    handleBox(g: Box): any;
    handleCone(g: Cone): any;
    handleLinearSweep(g: LinearSweep): any;
    handleRotationalSweep(g: RotationalSweep): any;
    handleRuledSweep(g: RuledSweep): any;
    handleSphere(g: Sphere): any;
    handleTorusPipe(g: TorusPipe): any;
    get options(): StrokeOptions;
    static pointsToTriangulatedPolyface(points: Point3d[]): IndexedPolyface | undefined;
    static polygonToTriangulatedPolyface(points: Point3d[], localToWorld?: Transform): IndexedPolyface | undefined;
    get reversedFlag(): boolean;
    toggleReversedFacetFlag(): void;
    }

// @public
export class PolyfaceClip {
    static clipPolyface(polyface: Polyface, clipper: ClipPlane | ConvexClipPlaneSet): Polyface | undefined;
    static clipPolyfaceClipPlane(polyface: Polyface, clipper: ClipPlane, insideClip?: boolean, buildClosureFaces?: boolean): Polyface;
    // @internal
    static clipPolyfaceClipPlaneToBuilders(polyface: Polyface, clipper: PlaneAltitudeEvaluator, destination: ClippedPolyfaceBuilders): void;
    static clipPolyfaceClipPlaneWithClosureFace(polyface: Polyface, clipper: ClipPlane, insideClip?: boolean, buildClosureFaces?: boolean): Polyface;
    static clipPolyfaceConvexClipPlaneSet(polyface: Polyface, clipper: ConvexClipPlaneSet): Polyface;
    // @internal
    static clipPolyfaceConvexClipPlaneSetToBuilders(polyface: Polyface, clipper: ConvexClipPlaneSet, destination: ClippedPolyfaceBuilders): void;
    static clipPolyfaceInsideOutside(polyface: Polyface, clipper: ClipPlane | ConvexClipPlaneSet | UnionOfConvexClipPlaneSets, destination: ClippedPolyfaceBuilders): void;
    static clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA: PolyfaceVisitor, visitorB: PolyfaceVisitor, builderAUnderB: PolyfaceBuilder | undefined, builderAOverB: PolyfaceBuilder | undefined): void;
    // @internal
    static clipPolyfaceUnionOfConvexClipPlaneSetsToBuilders(polyface: Polyface, allClippers: UnionOfConvexClipPlaneSets, destination: ClippedPolyfaceBuilders): void;
    static computeCutFill(meshA: IndexedPolyface, meshB: IndexedPolyface): {
        meshAUnderB: IndexedPolyface;
        meshAOverB: IndexedPolyface;
    };
    static sectionPolyfaceClipPlane(polyface: Polyface, clipper: ClipPlane): LineString3d[];
}

// @public
export class PolyfaceData {
    constructor(needNormals?: boolean, needParams?: boolean, needColors?: boolean, twoSided?: boolean);
    auxData: PolyfaceAuxData | undefined;
    clone(): PolyfaceData;
    color: number[] | undefined;
    get colorCount(): number;
    colorIndex: number[] | undefined;
    compress(): void;
    copyNormalTo(i: number, dest: Vector3d): void;
    copyParamTo(i: number, dest: Point2d): void;
    copyPointTo(i: number, dest: Point3d): void;
    edgeVisible: boolean[];
    face: FacetFaceData[];
    get faceCount(): number;
    gatherIndexedData(other: PolyfaceData, index0: number, index1: number, numWrap: number): void;
    getColor(i: number): number;
    getEdgeVisible(i: number): boolean;
    getNormal(i: number): Vector3d | undefined;
    getParam(i: number): Point2d | undefined;
    getPoint(i: number): Point3d | undefined;
    get indexCount(): number;
    isAlmostEqual(other: PolyfaceData): boolean;
    isAlmostEqualParamIndexUV(index: number, u: number, v: number): boolean;
    static isValidFacetStartIndexArray(facetStartIndex: number[]): boolean;
    normal: GrowableXYZArray | undefined;
    get normalCount(): number;
    normalIndex: number[] | undefined;
    param?: GrowableXYArray;
    get paramCount(): number;
    paramIndex: number[] | undefined;
    // @internal
    static readonly planarityLocalRelTol = 1e-13;
    point: GrowableXYZArray;
    get pointCount(): number;
    pointIndex: number[];
    range(result?: Range3d, transform?: Transform): Range3d;
    get requireNormals(): boolean;
    resizeAllDataArrays(length: number): void;
    reverseIndices(facetStartIndex?: number[]): void;
    static reverseIndices<T>(facetStartIndex: number[], indices: T[] | undefined, preserveStart: boolean): boolean;
    reverseIndicesSingleFacet(facetId: number, facetStartIndex: number[]): void;
    static reverseIndicesSingleFacet<T>(facetId: number, facetStartIndex: number[], indices: T[] | undefined, preserveStart: boolean): boolean;
    reverseNormals(): void;
    trimAllIndexArrays(length: number): void;
    tryTransformInPlace(transform: Transform): boolean;
    get twoSided(): boolean;
    set twoSided(value: boolean);
    }

// @public
export class PolyfaceQuery {
    static announceDuplicateFacetIndices(polyface: Polyface, announceCluster: (clusterFacetIndices: number[]) => void): void;
    static announceSweepLinestringToConvexPolyfaceXY(linestringPoints: GrowableXYZArray, polyface: Polyface, announce: AnnounceDrapePanel): any;
    static boundaryEdges(source: Polyface | PolyfaceVisitor | undefined, includeDanglers?: boolean, includeMismatch?: boolean, includeNull?: boolean): CurveCollection | undefined;
    static boundaryOfVisibleSubset(polyface: IndexedPolyface, visibilitySelect: 0 | 1 | 2, vectorToEye: Vector3d, sideAngleTolerance?: Angle): CurveCollection | undefined;
    static buildAverageNormals(polyface: IndexedPolyface, toleranceAngle?: Angle): void;
    static buildPerFaceNormals(polyface: IndexedPolyface): void;
    static cloneByFacetDuplication(source: Polyface, includeSingletons: boolean, clusterSelector: DuplicateFacetClusterSelector): Polyface;
    static clonePartitions(polyface: Polyface | PolyfaceVisitor, partitions: number[][]): Polyface[];
    static cloneWithColinearEdgeFixup(polyface: Polyface): Polyface;
    static cloneWithTVertexFixup(polyface: Polyface): IndexedPolyface;
    static collectDuplicateFacetIndices(polyface: Polyface, includeSingletons?: boolean): number[][];
    static collectRangeLengthData(polyface: Polyface | PolyfaceVisitor): RangeLengthData;
    static computeFacetUnitNormal(visitor: PolyfaceVisitor, facetIndex: number, result?: Vector3d): Vector3d | undefined;
    static computePrincipalAreaMoments(source: Polyface): MomentData | undefined;
    static computePrincipalVolumeMoments(source: Polyface): MomentData | undefined;
    static createIndexedEdges(visitor: PolyfaceVisitor): IndexedEdgeMatcher;
    static indexedPolyfaceToLoops(polyface: Polyface): BagOfCurves;
    static isPolyfaceClosedByEdgePairing(source: Polyface): boolean;
    static isPolyfaceManifold(source: Polyface, allowSimpleBoundaries?: boolean): boolean;
    static markAllEdgeVisibility(mesh: IndexedPolyface, value: boolean): void;
    static markPairedEdgesInvisible(mesh: IndexedPolyface, sharpEdgeAngle?: Angle): void;
    static partitionFacetIndicesByEdgeConnectedComponent(polyface: Polyface | PolyfaceVisitor): number[][];
    static partitionFacetIndicesByVertexConnectedComponent(polyface: Polyface | PolyfaceVisitor): number[][];
    static partitionFacetIndicesByVisibilityVector(polyface: Polyface | PolyfaceVisitor, vectorToEye: Vector3d, sideAngleTolerance: Angle): number[][];
    static reorientVertexOrderAroundFacetsForConsistentOrientation(mesh: IndexedPolyface): boolean;
    static setSingleEdgeVisibility(polyface: IndexedPolyface, facetIndex: number, vertexIndex: number, value: boolean): void;
    static sumFacetAreas(source: Polyface | PolyfaceVisitor | undefined): number;
    static sumFacetSecondAreaMomentProducts(source: Polyface | PolyfaceVisitor, origin: Point3d): Matrix4d;
    static sumFacetSecondVolumeMomentProducts(source: Polyface | PolyfaceVisitor, origin: Point3d): Matrix4d;
    static sumTetrahedralVolumes(source: Polyface | PolyfaceVisitor, origin?: Point3d): number;
    static sumVolumeBetweenFacetsAndPlane(source: Polyface | PolyfaceVisitor, plane: Plane3dByOriginAndUnitNormal): FacetProjectedVolumeSums;
    static sweepLinestringToFacetsXYReturnChains(linestringPoints: GrowableXYZArray, polyface: Polyface): LineString3d[];
    static sweepLinestringToFacetsXYReturnLines(linestringPoints: GrowableXYZArray, polyface: Polyface): LineSegment3d[];
    static sweepLinestringToFacetsXYreturnSweptFacets(linestringPoints: GrowableXYZArray, polyface: Polyface): Polyface;
    static visitorToLoop(visitor: PolyfaceVisitor): Loop;
}

// @public
export interface PolyfaceVisitor extends PolyfaceData {
    clearArrays(): void;
    clientAuxIndex(i: number): number;
    clientColorIndex(i: number): number;
    clientNormalIndex(i: number): number;
    clientParamIndex(i: number): number;
    clientPointIndex(i: number): number;
    clientPolyface(): Polyface | undefined;
    currentReadIndex(): number;
    moveToNextFacet(): boolean;
    moveToReadIndex(index: number): boolean;
    pushDataFrom(other: PolyfaceVisitor, index: number): void;
    pushInterpolatedDataFrom(other: PolyfaceVisitor, index0: number, fraction: number, index1: number): void;
    reset(): void;
    setNumWrap(numWrap: number): void;
}

// @public
export interface PolygonClipper {
    // (undocumented)
    appendPolygonClip(xyz: GrowableXYZArray, insideFragments: GrowableXYZArray[], outsideFragments: GrowableXYZArray[], arrayCache: GrowableXYZArrayCache): void;
}

// @public
export class PolygonOps {
    static addSecondMomentAreaProducts(points: IndexedXYZCollection, origin: Point3d, moments: Matrix4d): void;
    static addSecondMomentVolumeProducts(points: IndexedXYZCollection, origin: Point3d, moments: Matrix4d): void;
    static area(points: Point3d[]): number;
    static areaNormal(points: Point3d[], result?: Vector3d): Vector3d;
    static areaNormalGo(points: IndexedXYZCollection, result?: Vector3d): Vector3d | undefined;
    static areaXY(points: Point3d[] | IndexedXYZCollection): number;
    static centroidAndAreaXY(points: Point2d[], centroid: Point2d): number | undefined;
    static centroidAreaNormal(points: IndexedXYZCollection | Point3d[]): Ray3d | undefined;
    static classifyPointInPolygon(x: number, y: number, points: XAndY[]): number | undefined;
    static classifyPointInPolygonXY(x: number, y: number, points: IndexedXYZCollection): number | undefined;
    static orientLoopsCCWForOutwardNormalInPlace(loops: IndexedReadWriteXYZCollection | IndexedReadWriteXYZCollection[], outwardNormal: Vector3d): number;
    static sortOuterAndHoleLoopsXY(loops: IndexedReadWriteXYZCollection[]): IndexedReadWriteXYZCollection[][];
    static sumTriangleAreas(points: Point3d[] | GrowableXYZArray): number;
    static sumTriangleAreasXY(points: Point3d[]): number;
    static testXYPolygonTurningDirections(pPointArray: Point2d[] | Point3d[]): number;
    static unitNormal(points: IndexedXYZCollection, result: Vector3d): boolean;
    }

// @internal
export class PolygonWireOffsetContext {
    constructor();
    constructPolygonWireXYOffset(points: Point3d[], wrap: boolean, leftOffsetDistanceOrOptions: number | JointOptions): CurveCollection | undefined;
    }

// @public
export class PolylineOps {
    static compressByChordError(source: Point3d[], chordTolerance: number): Point3d[];
    static compressByPerpendicularDistance(source: Point3d[], maxDistance: number, numPass?: number): Point3d[];
    static compressShortEdges(source: Point3d[], maxEdgeLength: number): Point3d[];
    static compressSmallTriangles(source: Point3d[], maxTriangleArea: number): Point3d[];
    static edgeLengthRange(points: Point3d[]): Range1d;
}

// @internal
export class PowerPolynomial {
    static accumulate(coffP: Float64Array, coffQ: Float64Array, scaleQ: number): number;
    static degreeKnownEvaluate(coff: Float64Array, degree: number, x: number): number;
    static evaluate(coff: Float64Array, x: number): number;
    static zero(coff: Float64Array): void;
}

// @internal
export class Quadrature {
    static doGaussIntegral(x0: number, x1: number, f: (x: number) => number, numInterval: number, numGauss?: number): number;
    static readonly gaussW1Interval01: Float64Array;
    static readonly gaussW2Interval01: Float64Array;
    static readonly gaussW3Interval01: Float64Array;
    static readonly gaussW4Interval01: Float64Array;
    static readonly gaussW5Interval01: Float64Array;
    static readonly gaussX1Interval01: Float64Array;
    static readonly gaussX2Interval01: Float64Array;
    static readonly gaussX3Interval01: Float64Array;
    static readonly gaussX4Interval01: Float64Array;
    static readonly gaussX5Interval01: Float64Array;
    static mapWeights(xA: number, h: number, xRef: Float64Array, wRef: Float64Array, xMapped: Float64Array, wMapped: Float64Array): number;
    static setupGauss1(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number;
    static setupGauss2(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number;
    static setupGauss3(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number;
    static setupGauss4(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number;
    static setupGauss5(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number;
    static sum1(xx: Float64Array, ww: Float64Array, n: number, f: (x: number) => number): number;
}

// @public
export class Range1d extends RangeBase {
    clipLinearMapToInterval(a: number, u: number, limitA: number, limitB: number): boolean;
    clone(result?: this): this;
    cloneTranslated(delta: number, result?: Range1d): Range1d;
    containsRange(other: Range1d): boolean;
    containsX(x: number): boolean;
    static createArray<T extends Range1d>(values: Float64Array | number[], result?: T): T;
    static createFrom<T extends Range1d>(other: T, result?: T): T;
    static createNull<T extends Range1d>(result?: T): T;
    static createX<T extends Range1d>(x: number, result?: T): T;
    static createXX<T extends Range1d>(xA: number, xB: number, result?: T): T;
    static createXXOrCorrectToNull<T extends Range1d>(xA: number, xB: number, result?: T): T;
    distanceToRange(other: Range1d): number;
    distanceToX(x: number): number;
    expandInPlace(delta: number): void;
    extendArray(values: Float64Array | number[]): void;
    extendArraySubset(values: Float64Array | number[], beginIndex: number, numValue: number): void;
    extendHigh(x: number): boolean;
    extendLow(x: number): boolean;
    extendRange(other: Range1d): void;
    extendX(x: number): void;
    fractionToPoint(fraction: number): number;
    static fromJSON<T extends Range1d>(json?: Range1dProps): T;
    high: number;
    intersect(other: Range1d, result?: Range1d): Range1d;
    intersectsRange(other: Range1d): boolean;
    isAlmostEqual(other: Range1d): boolean;
    get isAlmostZeroLength(): boolean;
    get isNull(): boolean;
    get isSinglePoint(): boolean;
    length(): number;
    low: number;
    maxAbs(): number;
    scaleAboutCenterInPlace(scaleFactor: number): void;
    setFrom(other: Range1d): void;
    setFromJSON(json: Range1dProps): void;
    setNull(): void;
    setX(x: number): void;
    toJSON(): Range1dProps;
    union(other: Range1d, result?: Range1d): Range1d;
}

// @internal
export class Range1dArray {
    static appendFractionalPoints(data: Range1d[], initialRangeFraction: number | undefined, rangeFraction: number | undefined, includeDegenerateRange: boolean, gapFraction: number | undefined, includeDegenerateGap: boolean, finalRangeFraction: number | undefined, result: GrowableFloat64Array | number[]): GrowableFloat64Array | number[];
    static countContainingRanges(data: Range1d[], value: number): number;
    static differenceSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[];
    static firstLowToLastHigh(data: Range1d[]): Range1d;
    static getBreaks(data: Range1d[], result?: GrowableFloat64Array, sort?: boolean, compress?: boolean, clear?: boolean): GrowableFloat64Array;
    static intersectSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[];
    static isSorted(data: Range1d[], strict?: boolean): boolean;
    static paritySorted(dataA: Range1d[], dataB: Range1d[]): Range1d[];
    static simplifySortParity(data: Range1d[], removeZeroLengthRanges?: boolean): void;
    static simplifySortUnion(data: Range1d[], removeZeroLengthRanges?: boolean): void;
    static sort(data: Range1d[]): void;
    static sumLengths(data: Range1d[]): number;
    static testParity(data: Range1d[], value: number): boolean;
    static testUnion(data: Range1d[], value: number): boolean;
    static unionSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[];
}

// @public
export type Range1dProps = {
    low: number;
    high: number;
} | number[];

// @public
export class Range2d extends RangeBase implements LowAndHighXY {
    constructor(lowX?: number, lowY?: number, highX?: number, highY?: number);
    get center(): Point2d;
    clone(result?: this): this;
    containsPoint(point: XAndY): boolean;
    containsRange(other: LowAndHighXY): boolean;
    containsXY(x: number, y: number): boolean;
    corners3d(asLoop?: boolean, z?: number): Point3d[];
    static createArray<T extends Range2d>(points: Point2d[], result?: T): T;
    static createFrom<T extends Range2d>(other: LowAndHighXY, result?: T): T;
    static createNull<T extends Range2d>(result?: T): T;
    static createXY<T extends Range2d>(x: number, y: number, result?: T): T;
    static createXYXY<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T;
    static createXYXYOrCorrectToNull<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T;
    diagonal(result?: Vector2d): Vector2d;
    diagonalFractionToPoint(fraction: number, result?: Point2d): Point2d;
    distanceToPoint(point: XAndY): number;
    distanceToRange(other: LowAndHighXY): number;
    expandInPlace(delta: number): void;
    extendPoint(point: XAndY): void;
    extendRange(other: LowAndHighXY): void;
    extendTransformedXY(transform: Transform, x: number, y: number): void;
    extendXY(x: number, y: number): void;
    fractionToPoint(fractionX: number, fractionY: number, result?: Point2d): Point2d;
    freeze(): Readonly<this>;
    static fromArrayBuffer<T extends Range2d>(buffer: ArrayBuffer): T;
    static fromFloat64Array<T extends Range2d>(f64: Float64Array): T;
    static fromJSON<T extends Range2d>(json?: Range2dProps): T;
    high: Point2d;
    intersect(other: LowAndHighXY, result?: Range2d): Range2d;
    intersectsRange(other: LowAndHighXY): boolean;
    isAlmostEqual(other: Range2d): boolean;
    get isAlmostZeroX(): boolean;
    get isAlmostZeroY(): boolean;
    get isNull(): boolean;
    static isNull(range: LowAndHighXY): boolean;
    get isSinglePoint(): boolean;
    low: Point2d;
    maxAbs(): number;
    scaleAboutCenterInPlace(scaleFactor: number): void;
    setFrom(other: LowAndHighXY): void;
    setFromJSON(json: Range2dProps): void;
    setNull(): void;
    setXY(x: number, y: number): void;
    static toFloat64Array(val: LowAndHighXY): Float64Array;
    toFloat64Array(): Float64Array;
    toJSON(): Range2dProps;
    union(other: LowAndHighXY, result?: Range2d): Range2d;
    worldToLocal(point: Point2d, result?: Point2d): Point2d | undefined;
    get xHigh(): number;
    xLength(): number;
    get xLow(): number;
    get yHigh(): number;
    yLength(): number;
    get yLow(): number;
}

// @public
export type Range2dProps = {
    low: XYProps;
    high: XYProps;
} | XYProps[];

// @public
export class Range3d extends RangeBase implements LowAndHighXYZ, BeJSONFunctions {
    constructor(lowX?: number, lowY?: number, lowZ?: number, highX?: number, highY?: number, highZ?: number);
    get center(): Point3d;
    clone(result?: this): this;
    cloneTranslated(shift: XYAndZ, result?: this): this;
    containsPoint(point: Point3d): boolean;
    containsPointXY(point: Point3d): boolean;
    containsRange(other: Range3d): boolean;
    containsXY(x: number, y: number): boolean;
    containsXYZ(x: number, y: number, z: number): boolean;
    corners(result?: Point3d[]): Point3d[];
    static create(...point: Point3d[]): Range3d;
    static createArray<T extends Range3d>(points: Point3d[], result?: T): T;
    static createFrom<T extends Range3d>(other: Range3d, result?: T): T;
    static createFromVariantData(data: MultiLineStringDataVariant): Range3d;
    static createInverseTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[] | GrowableXYZArray): T;
    static createNull<T extends Range3d>(result?: T): T;
    static createRange2d<T extends Range3d>(range: Range2d, z?: number, result?: T): T;
    static createTransformed<T extends Range3d>(transform: Transform, ...point: Point3d[]): T;
    static createTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[] | GrowableXYZArray): T;
    static createXYZ<T extends Range3d>(x: number, y: number, z: number, result?: T): T;
    static createXYZXYZ<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T;
    static createXYZXYZOrCorrectToNull<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T;
    diagonal(result?: Vector3d): Vector3d;
    diagonalFractionToPoint(fraction: number, result?: Point3d): Point3d;
    distanceToPoint(point: XYAndZ): number;
    distanceToRange(other: Range3d): number;
    ensureMinLengths(min?: number): void;
    expandInPlace(delta: number): void;
    extend(...point: Point3d[]): void;
    extendArray(points: Point3d[] | GrowableXYZArray, transform?: Transform): void;
    extendInverseTransformedArray(points: Point3d[] | GrowableXYZArray, transform: Transform): void;
    extendInverseTransformedXYZ(transform: Transform, x: number, y: number, z: number): boolean;
    extendPoint(point: Point3d, transform?: Transform): void;
    extendRange(other: LowAndHighXYZ): void;
    extendSingleAxis(a: number, axisIndex: AxisIndex): void;
    extendTransformedPoint(transform: Transform, point: Point3d): void;
    extendTransformedXYZ(transform: Transform, x: number, y: number, z: number): void;
    extendTransformedXYZW(transform: Transform, x: number, y: number, z: number, w: number): void;
    extendTransformTransformedXYZ(transformA: Transform, transformB: Transform, x: number, y: number, z: number): void;
    extendXOnly(x: number): void;
    extendXYZ(x: number, y: number, z: number): void;
    extendXYZW(x: number, y: number, z: number, w: number): void;
    extendYOnly(y: number): void;
    extendZOnly(z: number): void;
    static faceCornerIndices(index: number): number[];
    fractionToPoint(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d;
    freeze(): Readonly<this>;
    static fromArrayBuffer<T extends Range3d>(buffer: ArrayBuffer): T;
    static fromFloat64Array<T extends Range3d>(f64: Float64Array): T;
    static fromJSON<T extends Range3d>(json?: Range3dProps): T;
    getLocalToWorldTransform(result?: Transform): Transform;
    getNpcToWorldRangeTransform(result?: Transform): Transform;
    high: Point3d;
    intersect(other: Range3d, result?: Range3d): Range3d;
    intersectsRange(other: Range3d): boolean;
    intersectsRangeXY(other: Range3d): boolean;
    isAlmostEqual(other: Range3d, tol?: number): boolean;
    get isAlmostZeroX(): boolean;
    get isAlmostZeroY(): boolean;
    get isAlmostZeroZ(): boolean;
    get isNull(): boolean;
    static isNull(data: LowAndHighXYZ): boolean;
    get isSinglePoint(): boolean;
    localToWorld(xyz: XYAndZ, result?: Point3d): Point3d | undefined;
    localToWorldArrayInPlace(points: Point3d[]): boolean;
    localXYZToWorld(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d | undefined;
    low: Point3d;
    maxAbs(): number;
    maxLength(): number;
    scaleAboutCenterInPlace(scaleFactor: number): void;
    setFrom(other: Range3d): void;
    setFromJSON(json?: Range3dProps): void;
    setNull(): void;
    setXYZ(x: number, y: number, z: number): void;
    static toFloat64Array(val: LowAndHighXYZ): Float64Array;
    toFloat64Array(): Float64Array;
    toJSON(): Range3dProps;
    union(other: Range3d, result?: Range3d): Range3d;
    worldToLocal(point: Point3d, result?: Point3d): Point3d | undefined;
    worldToLocalArrayInPlace(point: Point3d[]): boolean;
    get xHigh(): number;
    xLength(): number;
    get xLow(): number;
    get yHigh(): number;
    yLength(): number;
    get yLow(): number;
    get zHigh(): number;
    zLength(): number;
    get zLow(): number;
}

// @public
export type Range3dProps = {
    low: XYZProps;
    high: XYZProps;
} | XYZProps[];

// @public
export abstract class RangeBase {
    static coordinateToRangeAbsoluteDistance(x: number, low: number, high: number): number;
    protected static readonly _EXTREME_NEGATIVE: number;
    protected static readonly _EXTREME_POSITIVE: number;
    static isExtremePoint2d(xy: Point2d): boolean;
    static isExtremePoint3d(xyz: Point3d): boolean;
    static isExtremeValue(x: number): boolean;
    protected static npcScaleFactor(low: number, high: number): number;
    static rangeToRangeAbsoluteDistance(lowA: number, highA: number, lowB: number, highB: number): number;
}

// @internal
export class Ray2d {
    ccwPerpendicularRay(): Ray2d;
    static createOriginAndDirection(origin: Point2d, direction: Vector2d): Ray2d;
    static createOriginAndDirectionCapture(origin: Point2d, direction: Vector2d): Ray2d;
    static createOriginAndTarget(origin: Point2d, target: Point2d): Ray2d;
    cwPerpendicularRay(): Ray2d;
    get direction(): Vector2d;
    fractionToPoint(f: number): Point2d;
    intersectUnboundedLine(linePointA: Point2d, linePointB: Point2d, fraction: number[], dHds: number[]): boolean;
    normalizeDirectionInPlace(defaultX?: number, defaultY?: number): boolean;
    get origin(): Point2d;
    parallelRay(leftFraction: number): Ray2d;
    perpendicularProjectionFraction(point: Point2d): number;
    projectionFraction(point: Point2d): number;
}

// @public
export class Ray3d implements BeJSONFunctions {
    a?: number;
    clone(result?: Ray3d): Ray3d;
    cloneInverseTransformed(transform: Transform): Ray3d | undefined;
    cloneTransformed(transform: Transform): Ray3d;
    static closestApproachRay3dRay3d(rayA: Ray3d, rayB: Ray3d): CurveLocationDetailPair;
    static create(origin: Point3d, direction: Vector3d, result?: Ray3d): Ray3d;
    static createCapture(origin: Point3d, direction: Vector3d): Ray3d;
    static createPointVectorNumber(origin: Point3d, direction: Vector3d, a: number, result?: Ray3d): Ray3d;
    static createStartEnd(origin: Point3d, target: Point3d, result?: Ray3d): Ray3d;
    static createWeightedDerivative(weightedPoint: Float64Array, weightedDerivative: Float64Array, result?: Ray3d): Ray3d | undefined;
    static createXAxis(): Ray3d;
    static createXYZUVW(originX: number, originY: number, originZ: number, directionX: number, directionY: number, directionZ: number, result?: Ray3d): Ray3d;
    static createYAxis(): Ray3d;
    static createZAxis(): Ray3d;
    static createZero(result?: Ray3d): Ray3d;
    direction: Vector3d;
    distance(spacePoint: Point3d): number;
    dotProductToPoint(spacePoint: Point3d): number;
    fractionToPoint(fraction: number, result?: Point3d): Point3d;
    static fromJSON(json?: any): Ray3d;
    getDirectionRef(): Vector3d;
    getOriginRef(): Point3d;
    intersectionWithPlane(plane: Plane3dByOriginAndUnitNormal, result?: Point3d): number | undefined;
    intersectionWithRange3d(range: Range3d, result?: Range1d): Range1d;
    isAlmostEqual(other: Ray3d): boolean;
    origin: Point3d;
    perpendicularPartOfVectorToTarget(targetPoint: XYAndZ, result?: Vector3d): Vector3d;
    pointToFraction(spacePoint: Point3d): number;
    projectPointToRay(spacePoint: Point3d): Point3d;
    set(origin: Point3d, direction: Vector3d): void;
    setFrom(source: Ray3d): void;
    setFromJSON(json?: any): void;
    toJSON(): any;
    toRigidZFrame(): Transform | undefined;
    transformInPlace(transform: Transform): void;
    tryNormalizeInPlaceWithAreaWeight(a: number): boolean;
    trySetDirectionMagnitudeInPlace(magnitude?: number): boolean;
}

// @public
export class RecurseToCurvesGeometryHandler extends GeometryHandler {
    handleArc3d(_g: Arc3d): any;
    handleBagOfCurves(g: BagOfCurves): any;
    handleBezierCurve3d(_g: BezierCurve3d): any;
    handleBezierCurve3dH(_g: BezierCurve3dH): any;
    handleBox(_g: Box): any;
    handleBSplineCurve3d(_g: BSplineCurve3d): any;
    handleBSplineCurve3dH(_g: BSplineCurve3dH): any;
    handleBSplineSurface3d(_g: BSplineSurface3d): any;
    handleBSplineSurface3dH(_g: BSplineSurface3dH): any;
    handleChildren(g: GeometryQuery): any;
    handleCone(_g: Cone): any;
    handleCoordinateXYZ(_g: CoordinateXYZ): any;
    handleCurveCollection(g: CurveCollection): any;
    handleIndexedPolyface(_g: IndexedPolyface): any;
    handleLinearSweep(_g: LinearSweep): any;
    handleLineSegment3d(_g: LineSegment3d): any;
    handleLineString3d(_g: LineString3d): any;
    handleLoop(g: Loop): any;
    handleParityRegion(g: ParityRegion): any;
    handlePath(g: Path): any;
    handlePointString3d(_g: PointString3d): any;
    handleRotationalSweep(_g: RotationalSweep): any;
    handleRuledSweep(_g: RuledSweep): any;
    handleSphere(_g: Sphere): any;
    handleTorusPipe(_g: TorusPipe): any;
    // @alpha
    handleTransitionSpiral(_g: TransitionSpiral3d): any;
    handleUnionRegion(g: UnionRegion): any;
}

// @public
export abstract class RecursiveCurveProcessor {
    protected constructor();
    announceBagOfCurves(data: BagOfCurves, _indexInParent?: number): void;
    announceCurvePrimitive(_data: CurvePrimitive, _indexInParent?: number): void;
    announceLoop(data: Loop, _indexInParent?: number): void;
    announceParityRegion(data: ParityRegion, _indexInParent?: number): void;
    announcePath(data: Path, _indexInParent?: number): void;
    announceUnexpected(_data: AnyCurve, _indexInParent: number): void;
    announceUnionRegion(data: UnionRegion, _indexInParent?: number): void;
}

// @public
export abstract class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {
    protected constructor();
    announceBagOfCurves(data: BagOfCurves, _indexInParent?: number): void;
    announceCurvePrimitive(_data: CurvePrimitive, _indexInParent?: number): void;
    announceLoop(data: Loop, indexInParent?: number): void;
    announceParityRegion(data: ParityRegion, _indexInParent?: number): void;
    announcePath(data: Path, indexInParent?: number): void;
    announceUnexpected(_data: AnyCurve, _indexInParent: number): void;
    announceUnionRegion(data: UnionRegion, indexInParent?: number): void;
    enter(data: CurveCollection): void;
    leave(): CurveCollection | undefined;
    protected _stack: CurveCollection[];
}

// @public
export enum RegionBinaryOpType {
    // (undocumented)
    AMinusB = 3,
    // (undocumented)
    BMinusA = 4,
    // (undocumented)
    Intersection = 2,
    // (undocumented)
    Parity = 1,
    // (undocumented)
    Union = 0
}

// @internal
export class RegionMomentsXY extends NullGeometryHandler {
    handleArc3d(arc: Arc3d): void;
    handleBSplineCurve3d(g: BSplineCurve3d): void;
    handleBSplineCurve3dH(g: BSplineCurve3dH): void;
    handleCurvePrimitive(cp: CurvePrimitive): void;
    handleLineSegment3d(segment: LineSegment3d): void;
    handleLineString3d(ls: LineString3d): void;
    handleLoop(loop: Loop): MomentData | undefined;
    handleParityRegion(region: ParityRegion): MomentData | undefined;
    handleTransitionSpiral(g: TransitionSpiral3d): void;
    handleUnionRegion(region: UnionRegion): MomentData | undefined;
    }

// @beta
export class RegionOps {
    // @internal
    static addLoopsToGraph(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, announceIsolatedLoop: (graph: HalfEdgeGraph, seed: HalfEdge) => void): void;
    // @internal
    static addLoopsWithEdgeTagToGraph(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, mask: HalfEdgeMask, edgeTag: any): HalfEdge[] | undefined;
    static cloneCurvesWithXYSplitFlags(curvesToCut: CurvePrimitive | CurveCollection | undefined, cutterCurves: CurveCollection): CurveCollection | CurvePrimitive | undefined;
    static collectChains(fragments: GeometryQuery[], gapTolerance?: number): ChainTypes;
    static collectCurvePrimitives(candidates: AnyCurve | AnyCurve[], collectorArray?: CurvePrimitive[], smallestPossiblePrimitives?: boolean, explodeLinestrings?: boolean): CurvePrimitive[];
    static collectInsideAndOutsideOffsets(fragments: GeometryQuery[], offsetDistance: number, gapTolerance: number): {
        insideOffsets: GeometryQuery[];
        outsideOffsets: GeometryQuery[];
        chains: ChainTypes;
    };
    static computeXYArea(root: AnyRegion): number | undefined;
    static computeXYAreaMoments(root: AnyRegion): MomentData | undefined;
    static computeXYZWireMomentSums(root: AnyCurve): MomentData | undefined;
    static consolidateAdjacentPrimitives(curves: CurveCollection, options?: ConsolidateAdjacentCurvePrimitivesOptions): void;
    // @alpha
    static constructAllXYRegionLoops(curvesAndRegions: AnyCurve | AnyCurve[]): SignedLoops[];
    static constructCurveXYOffset(curves: Path | Loop, offsetDistanceOrOptions: number | JointOptions): CurveCollection | undefined;
    static constructPolygonWireXYOffset(points: Point3d[], wrap: boolean, offsetDistance: number): CurveCollection | undefined;
    static createLoopPathOrBagOfCurves(curves: CurvePrimitive[], wrap?: boolean, consolidateAdjacentPrimitives?: boolean): CurveCollection | undefined;
    static curveArrayRange(data: any, worldToLocal?: Transform): Range3d;
    static expandLineStrings(candidates: CurvePrimitive[]): CurvePrimitive[];
    static polygonBooleanXYToLoops(inputA: MultiLineStringDataVariant[], operation: RegionBinaryOpType, inputB: MultiLineStringDataVariant[]): AnyRegion | undefined;
    static polygonBooleanXYToPolyface(inputA: MultiLineStringDataVariant[], operation: RegionBinaryOpType, inputB: MultiLineStringDataVariant[], triangulate?: boolean): Polyface | undefined;
    static polygonXYAreaDifferenceLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant, triangulate?: boolean): Polyface | undefined;
    static polygonXYAreaIntersectLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant, triangulate?: boolean): Polyface | undefined;
    static polygonXYAreaUnionLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant, triangulate?: boolean): Polyface | undefined;
    static rectangleEdgeTransform(data: AnyCurve | Point3d[] | IndexedXYZCollection, requireClosurePoint?: boolean): Transform | undefined;
    // @alpha
    static regionBooleanXY(loopsA: AnyRegion | AnyRegion[] | undefined, loopsB: AnyRegion | AnyRegion[] | undefined, operation: RegionBinaryOpType): AnyRegion | undefined;
    // @internal
    static setCheckPointFunction(f?: GraphCheckPointFunction): void;
    static sortOuterAndHoleLoopsXY(loops: Array<Loop | IndexedXYZCollection>): AnyRegion;
    static splitPathsByRegionInOnOutXY(curvesToCut: CurveCollection | CurvePrimitive | undefined, region: AnyRegion): {
        insideParts: AnyCurve[];
        outsideParts: AnyCurve[];
        coincidentParts: AnyCurve[];
    };
    static splitToPathsBetweenFlagBreaks(source: CurveCollection | CurvePrimitive | undefined, makeClones: boolean): BagOfCurves | Path | CurvePrimitive | Loop | undefined;
    static testPointInOnOutRegionXY(curves: AnyRegion, x: number, y: number): number;
}

// @public
export class RotationalSweep extends SolidPrimitive {
    clone(): RotationalSweep;
    cloneAxisRay(): Ray3d;
    cloneTransformed(transform: Transform): RotationalSweep;
    constantVSection(vFraction: number): CurveCollection | undefined;
    static create(contour: CurveCollection, axis: Ray3d, sweepAngle: Angle, capped: boolean): RotationalSweep | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(range: Range3d, transform?: Transform): void;
    getConstructiveFrame(): Transform | undefined;
    getCurves(): CurveCollection;
    getFractionalRotationTransform(vFraction: number, result?: Transform): Transform;
    getSweep(): Angle;
    getSweepContourRef(): SweepContour;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    readonly solidPrimitiveType = "rotationalSweep";
    tryTransformInPlace(transform: Transform): boolean;
}

// @public
export class RuledSweep extends SolidPrimitive {
    clone(): RuledSweep;
    cloneContours(): CurveCollection[];
    cloneSweepContours(): SweepContour[];
    cloneTransformed(transform: Transform): RuledSweep;
    constantVSection(vFraction: number): CurveCollection | undefined;
    static create(contours: CurveCollection[], capped: boolean): RuledSweep | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getConstructiveFrame(): Transform | undefined;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    static mutatePartners(collectionA: CurveCollection, collectionB: CurveCollection, primitiveMutator: CurvePrimitiveMutator): CurveCollection | undefined;
    readonly solidPrimitiveType = "ruledSweep";
    sweepContoursRef(): SweepContour[];
    tryTransformInPlace(transform: Transform): boolean;
}

// @alpha
export class Sample {
    static addAuxDataScalarChannel(data: PolyfaceData, channelIndex: number, name: string | undefined, inputName: string | undefined, input0: number, inputStep: number, numInput: number, dataType: AuxChannelDataType, scalarFunction: (input: number, xyz: Point3d) => number): void;
    static readonly angle: Angle[];
    static readonly angleSweep: AngleSweep[];
    static appendPhases(linestring: LineString3d, numPhase: number, ...vectors: Vector3d[]): void;
    static appendSawTooth(points: Point3d[], dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhase: number): Point3d[];
    static appendSplits(points: Point3d[], target: Point3d, numSplit: number, includeTarget: boolean): void;
    static appendVariableSawTooth(points: Point3d[], dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhase: number, xFactor: number): Point3d[];
    static convertPointsToSegments(points: Point3d[], forceClosure?: boolean): LineSegment3d[];
    static createAllGeometryQueryTypes(): GeometryQuery[];
    static createArcRegions(): Loop[];
    static createArcs(radiusRatio?: number, sweep?: AngleSweep): Arc3d[];
    static createBagOfCurves(): BagOfCurves[];
    static createBidirectionalSawtooth(origin: Point3d, dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhaseOutbound: number, dyFinal: number, dxLowReturn: number, riseXReturn: number, riseYReturn: number, dxHighReturn: number): Point3d[];
    static createBoxes(capped?: boolean): Box[];
    static createBspline3dHArcs(): BSplineCurve3dH[];
    static createBspline3dHCurves(): BSplineCurve3dH[];
    static createBsplineArc90SectionToXYZWArrays(center: Point3d, axes: Matrix3d, radius0: number, radius90: number, applyWeightsToXYZ: boolean): number[][];
    static createBsplineCurves(includeMultipleKnots?: boolean): BSplineCurve3d[];
    static createCappedArcLoop(radius: number, startDegrees: number, endDegrees: number): Loop;
    static createCappedArcPath(radius: number, startDegrees: number, endDegrees: number): Path;
    static createCappedArcPrimitives(radius: number, startDegrees: number, endDegrees: number): CurvePrimitive[];
    static createCenteredBoxEdges(ax?: number, ay?: number, az?: number, cx?: number, cy?: number, cz?: number, geometry?: GeometryQuery[]): GeometryQuery[];
    static createClipPlanes(): ClipPlane[];
    static createClipPlaneSets(): UnionOfConvexClipPlaneSets[];
    static createClosedSolidSampler(capped: boolean): SolidPrimitive[];
    static createConeBsplineSurface(centerA: Point3d, centerB: Point3d, radiusA: number, radiusB: number, numSection: number): BSplineSurface3dH | undefined;
    static createCones(): Cone[];
    static createCurveChainWithDistanceIndex(): CurveChainWithDistanceIndex[];
    static createCutPie(x0: number, y0: number, radius: number, sweep: AngleSweep, numRadialEdges: number, numArcEdges: number, addClosure?: boolean): Point3d[];
    static createEllipsoids(): Sphere[];
    static createFractalDiamondConvexPattern(numRecursion: number, perpendicularFactor: number): Point3d[];
    static createFractalHatReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[];
    static createFractalLMildConcavePatter(numRecursion: number, perpendicularFactor: number): Point3d[];
    static createFractalLReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[];
    static createFractalSquareReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[];
    static createGrowableArrayCirclePoints(radius: number, numEdge: number, closed?: boolean, centerX?: number, centerY?: number, data?: GrowableXYZArray): GrowableXYZArray;
    static createGrowableArrayCountedSteps(a0: number, delta: number, n: number): GrowableFloat64Array;
    static createInterpolatedPoints(point0: Point3d, point1: Point3d, numPoints: number, result?: Point3d[], index0?: number, index1?: number): Point3d[];
    static createInvertibleTransforms(): Transform[];
    static createLineArcPaths(): Path[];
    static createLineStrings(): LineString3d[];
    static createLShapedPolygon(x0: number, y0: number, ax: number, ay: number, bx: number, by: number, z?: number): Point3d[];
    static createManyArcs(skewFactors?: number[]): Arc3d[];
    static createMap4ds(): Map4d[];
    static createMatrix3dArray(): Matrix3d[];
    static createMatrix4ds(includeIrregular?: boolean): Matrix4d[];
    static createMessyRigidTransform(fixedPoint?: Point3d): Transform;
    static createMixedBsplineCurves(): BSplineCurve3dBase[];
    static createNonZeroVectors(): Vector3d[];
    static createPlane(x: number, y: number, z: number, u: number, v: number, w: number): Plane3dByOriginAndUnitNormal;
    static createPoint2dLattice(low: number, step: number, high: number): Point2d[];
    static createPoint3dLattice(low: number, step: number, high: number): Point3d[];
    static createPointsByIndexFunctions(numInterval: number, fx: SteppedIndexFunction, fy: SteppedIndexFunction, fz?: SteppedIndexFunction): Point3d[];
    static createPointSineWave(origin: XYAndZ | undefined, numInterval?: number, xStep?: number, a?: number, thetaSweep?: AngleSweep, b?: number, betaSweep?: AngleSweep): Point3d[];
    static createPseudoTorusBsplineSurface(radiusU: number, radiusV: number, numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined;
    static createRange3ds(): Range3d[];
    static createRangeEdges(range: Range3d): BagOfCurves | undefined;
    static createRay(x: number, y: number, z: number, u: number, v: number, w: number): Ray3d;
    static createRectangle(x0: number, y0: number, x1: number, y1: number, z?: number, closed?: boolean): Point3d[];
    static createRectangleInRange2d(range: Range2d, z?: number, closed?: boolean): Point3d[];
    static createRectangleXY(x0: number, y0: number, ax: number, ay: number, z?: number): Point3d[];
    static createRecursiveFractalPolygon(poles: Point3d[], pattern: Point2d[], numRecursion: number, perpendicularFactor: number): Point3d[];
    static createRegularPolygon(cx: number, cy: number, cz: number, angle0: Angle, r: number, numPoint: number, close: boolean): Point3d[];
    static createRigidAxes(): Matrix3d[];
    static createRigidTransforms(distanceScale?: number): Transform[];
    static createRuledSweeps(includeParityRegion?: boolean, includeBagOfCurves?: boolean): RuledSweep[];
    static createScaleSkewMatrix3d(): Matrix3d[];
    static createSimpleIndexedPolyfaces(gridMultiplier: number): IndexedPolyface[];
    static createSimpleLinearSweeps(): LinearSweep[];
    static createSimpleLoops(): Loop[];
    static createSimpleParityRegions(includeBCurves?: boolean): ParityRegion[];
    static createSimplePaths(withGaps?: boolean): Path[];
    static createSimplePointStrings(): PointString3d[];
    static createSimpleRotationalSweeps(): RotationalSweep[];
    static createSimpleTransitionSpirals(): TransitionSpiral3d[];
    static createSimpleUnions(): UnionRegion[];
    static createSimpleXYPointLoops(): Point3d[][];
    static createSingularMatrix3d(): Matrix3d[];
    static createSmoothCurvePrimitives(size?: number): CurvePrimitive[];
    static createSpheres(includeEllipsoidal?: boolean): Sphere[];
    static createSquareWave(origin: Point3d, dx0: number, dy: number, dx1: number, numPhase: number, dyReturn: number): Point3d[];
    static createSquareWavePath(numTooth: number, dxA: number, dxB: number, yA: number, yB: number, structure: number): Path;
    static createStar(cx: number, cy: number, cz: number, r0: number, r1: number | undefined, numPoint: number, close: boolean, theta0?: Angle): Point3d[];
    static createStarsInStars(rA0: number, rA1: number, numAPoint: number, rB0: number, rB1: number, numBPoint: number, rC: number, numC: number, close: boolean): Point3d[][];
    static createTorusPipes(): TorusPipe[];
    static createTriangleWithSplitEdges(numSplitAB: number, numSplitBC: number, numSplitCA: number, wrap?: boolean, xyzA?: Point3d, xyzB?: Point3d, xyzC?: Point3d): Point3d[];
    static createTriangularUnitGridPolyface(origin: Point3d, vectorX: Vector3d, vectorY: Vector3d, numXVertices: number, numYVertices: number, createParams?: boolean, createNormals?: boolean, createColors?: boolean, triangulate?: boolean): IndexedPolyface;
    static createTwistingBezier(order: number, x0: number, y0: number, r: number, thetaStepper: AngleSweep, phiStepper: AngleSweep, weightInterval?: Segment1d): CurvePrimitive | undefined;
    static createUnitCircle(numPoints: number): Point3d[];
    static createWeightedXYGridBsplineSurface(numU: number, numV: number, orderU: number, orderV: number, weight00?: number, weight10?: number, weight01?: number, weight11?: number): BSplineSurface3dH | undefined;
    static createXYGrid(numU: number, numV: number, dX?: number, dY?: number): Point3d[];
    static createXYGridBsplineSurface(numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined;
    static creatVerticalStaggerPolygon(dy1: number, dy2: number, dy3: number, dy4: number, ax: number, ay: number, dx1: number, dx4: number): Point3d[];
    static readonly lineSegment3d: LineSegment3d[];
    static nonConvexQuadSimpleFractal(numRecursion: number, perpendicularFactor: number): Point3d[];
    static readonly plane3dByOriginAndUnitNormal: Plane3dByOriginAndUnitNormal[];
    static readonly point2d: Point2d[];
    static readonly point3d: Point3d[];
    static readonly point4d: Point4d[];
    static pushMove(data: Point3d[], dx: number, dy: number, dz?: number): void;
    static readonly range1d: Range1d[];
    static readonly range2d: Range2d[];
    static readonly range3d: Range3d[];
    static readonly ray3d: Ray3d[];
    static readonly vector2d: Vector2d[];
}

// @public
export class Segment1d {
    absoluteDelta(): number;
    clampDirectedTo01(): boolean;
    clipBy01FunctionValuesPositive(f0: number, f1: number): boolean;
    clone(): Segment1d;
    static create(x0?: number, x1?: number, result?: Segment1d): Segment1d;
    fractionToPoint(fraction: number): number;
    isAlmostEqual(other: Segment1d): boolean;
    get isExact01(): boolean;
    get isExact01Reversed(): boolean;
    get isIn01(): boolean;
    reverseIfNeededForDeltaSign(sign?: number): void;
    reverseInPlace(): void;
    set(x0: number, x1: number): void;
    setFrom(other: Segment1d): void;
    shift(dx: number): void;
    signedDelta(): number;
    x0: number;
    x1: number;
}

// @public
export interface SignedLoops {
    negativeAreaLoops: Loop[];
    positiveAreaLoops: Loop[];
    slivers: Loop[];
}

// @internal
export class SimpleNewton {
    static runNewton1D(x: number, func: (x: number) => number | undefined, derivative: (x: number) => number | undefined, absoluteTolerance?: number): number | undefined;
}

// @internal
export class SineCosinePolynomial {
    constructor(a: number, cosCoff: number, sinCoff: number);
    a: number;
    cosineCoff: number;
    evaluateRadians(theta: number): number;
    range(result?: Range1d): Range1d;
    rangeInStartEndRadians(radians0: number, radians1: number, result?: Range1d): Range1d;
    rangeInSweep(sweep: AngleSweep, result?: Range1d): Range1d;
    referenceMinMaxRadians(): number;
    set(a: number, cosCoff: number, sinCoff: number): void;
    sineCoff: number;
}

// @public
export class SmallSystem {
    static eliminateFromPivot(rowA: Float64Array, pivotIndex: number, rowB: Float64Array, a: number): boolean;
    static linearSystem2d(ux: number, vx: number, // first row of matrix
    uy: number, vy: number, // second row of matrix
    cx: number, cy: number, // right side
    result: Vector2d): boolean;
    static linearSystem3d(axx: number, axy: number, axz: number, // first row of matrix
    ayx: number, ayy: number, ayz: number, // second row of matrix
    azx: number, azy: number, azz: number, // second row of matrix
    cx: number, cy: number, cz: number, // right side
    result?: Vector3d): Vector3d | undefined;
    static lineSegment2dXYTransverseIntersectionUnbounded(a0: Point2d, a1: Point2d, b0: Point2d, b1: Point2d, result: Vector2d): boolean;
    static lineSegment3dClosestApproachUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d, result: Vector2d): boolean;
    static lineSegment3dClosestPointUnbounded(pointA0: Point3d, pointA1: Point3d, spacePoint: Point3d): number | undefined;
    static lineSegment3dHXYClosestPointUnbounded(hA0: Point4d, hA1: Point4d, spacePoint: Point4d): number | undefined;
    static lineSegment3dHXYTransverseIntersectionUnbounded(hA0: Point4d, hA1: Point4d, hB0: Point4d, hB1: Point4d, result?: Vector2d): Vector2d | undefined;
    static lineSegment3dXYClosestPointUnbounded(pointA0: XAndY, pointA1: XAndY, spacePoint: XAndY): number | undefined;
    static lineSegment3dXYTransverseIntersectionUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d, result: Vector2d): boolean;
    static lineSegmentXYUVTransverseIntersectionUnbounded(ax0: number, ay0: number, ux: number, uy: number, bx0: number, by0: number, vx: number, vy: number, result: Vector2d): boolean;
    static ray3dXYZUVWClosestApproachUnbounded(ax: number, ay: number, az: number, au: number, av: number, aw: number, bx: number, by: number, bz: number, bu: number, bv: number, bw: number, result: Vector2d): boolean;
    static solveBilinearPair(a0: number, b0: number, c0: number, d0: number, a1: number, b1: number, c1: number, d1: number): Point2d[] | undefined;
}

// @public
export class SmoothTransformBetweenFrusta {
    static create(cornerA: Point3d[], cornerB: Point3d[], preferSimpleRotation?: boolean): SmoothTransformBetweenFrusta | undefined;
    fractionToWorldCorners(fraction: number, result?: Point3d[]): Point3d[];
    interpolateLocalCorners(fraction: number, result?: Point3d[]): Point3d[];
    get localToWorldA(): Transform;
    get localToWorldB(): Transform;
    }

// @public
export abstract class SolidPrimitive extends GeometryQuery {
    protected constructor(capped: boolean);
    get capped(): boolean;
    set capped(capped: boolean);
    protected _capped: boolean;
    abstract constantVSection(_vFraction: number): CurveCollection | undefined;
    readonly geometryCategory = "solid";
    abstract getConstructiveFrame(): Transform | undefined;
    abstract get isClosedVolume(): boolean;
    abstract readonly solidPrimitiveType: SolidPrimitiveType;
}

// @public
export type SolidPrimitiveType = "box" | "cone" | "sphere" | "linearSweep" | "rotationalSweep" | "ruledSweep" | "torusPipe";

// @public
export class Sphere extends SolidPrimitive implements UVSurface {
    clone(): Sphere;
    cloneCenter(): Point3d;
    cloneLatitudeSweep(): AngleSweep;
    cloneLocalToWorld(): Transform;
    cloneTransformed(transform: Transform): Sphere | undefined;
    cloneVectorX(): Vector3d;
    cloneVectorY(): Vector3d;
    cloneVectorZ(): Vector3d;
    constantVSection(vFraction: number): CurveCollection | undefined;
    static createCenterRadius(center: Point3d, radius: number, latitudeSweep?: AngleSweep): Sphere;
    static createDgnSphere(center: Point3d, vectorX: Vector3d, vectorZ: Vector3d, radiusXY: number, radiusZ: number, latitudeSweep: AngleSweep, capped: boolean): Sphere | undefined;
    static createEllipsoid(localToWorld: Transform, latitudeSweep: AngleSweep, capped: boolean): Sphere | undefined;
    static createFromAxesAndScales(center: Point3d, axes: undefined | Matrix3d, radiusX: number, radiusY: number, radiusZ: number, latitudeSweep: AngleSweep | undefined, capped: boolean): Sphere | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(range: Range3d, transform?: Transform): void;
    getConstructiveFrame(): Transform | undefined;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    get latitudeSweepFraction(): number;
    maxAxisRadius(): number;
    maxIsoParametricDistance(): Vector2d;
    readonly solidPrimitiveType = "sphere";
    strokeConstantVSection(v: number, fixedStrokeCount: number | undefined, options?: StrokeOptions): LineString3d;
    trueSphereRadius(): number | undefined;
    tryTransformInPlace(transform: Transform): boolean;
    uFractionToRadians(u: number): number;
    uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    vFractionToRadians(v: number): number;
}

// @internal
export class SphereImplicit {
    constructor(r: number);
    evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d): void;
    evaluateImplicitFunction(x: number, y: number, z: number): number;
    evaluateImplicitFunctionXYZW(wx: number, wy: number, wz: number, w: number): number;
    evaluateThetaPhi(thetaRadians: number, phiRadians: number, result?: Point3d): Point3d;
    static intersectSphereRay(center: Point3d, radius: number, ray: Ray3d, rayFractions: number[] | undefined, xyz: Point3d[] | undefined, thetaPhiRadians: LongitudeLatitudeNumber[] | undefined): number;
    static patchRangeStartEndRadians(center: Point3d, radius: number, theta0Radians: number, theta1Radians: number, phi0Radians: number, phi1Radians: number, result?: Range3d): Range3d;
    static radiansToUnitSphereXYZ(thetaRadians: number, phiRadians: number, xyz: XYZ): void;
    radius: number;
    xyzToThetaPhiR(xyz: Point3d): {
        thetaRadians: number;
        phiRadians: number;
        r: number;
        valid: boolean;
    };
}

// @public
export enum StandardViewIndex {
    Back = 6,
    Bottom = 2,
    Front = 5,
    Iso = 7,
    Left = 3,
    Right = 4,
    RightIso = 8,
    Top = 1
}

// @alpha
export type SteppedIndexFunction = (i: number, n: number) => number;

// @alpha
export class SteppedIndexFunctionFactory {
    static createConstant(value?: number): SteppedIndexFunction;
    static createCosine(amplitude: number, sweep?: AngleSweep, f0?: number): SteppedIndexFunction;
    static createLinear(a: number, f0?: number): SteppedIndexFunction;
    static createSine(amplitude: number, sweep?: AngleSweep, f0?: number): SteppedIndexFunction;
}

// @public
export class StrokeCountMap {
    a0: number;
    a1: number;
    addToCountAndLength(numStroke: number, curveLength: number): void;
    clone(): StrokeCountMap;
    componentData?: StrokeCountMap[];
    componentIndex?: number;
    static createWithComponentIndex(componentIndex?: number, numStroke?: number, curveLength?: number, a0?: number, a1?: number): StrokeCountMap;
    static createWithCurvePrimitive(primitive: CurvePrimitive, numStroke: number, curveLength: number, a0: number, a1: number, componentData?: StrokeCountMap[]): StrokeCountMap;
    static createWithCurvePrimitiveAndOptionalParent(curvePrimitive: CurvePrimitive, parentMap?: StrokeCountMap, componentData?: StrokeCountMap[]): StrokeCountMap;
    curveLength: number;
    fractionToA(fraction: number): number;
    isCompatibleComponentStructure(other: StrokeCountMap, enforceCounts: boolean): boolean;
    numStroke: number;
    primitive?: CurvePrimitive;
}

// @public
export class StrokeOptions {
    angleTol?: Angle;
    applyAngleTol(minCount: number, sweepRadians: number, defaultStepRadians: number): number;
    static applyAngleTol(options: StrokeOptions | undefined, minCount: number, sweepRadians: number, defaultStepRadians?: number): number;
    applyChordTol(minCount: number, radius: number, sweepRadians: number): number;
    applyChordTolToLengthAndRadians(minCount: number, length: number, sweepRadians: number): number;
    applyMaxEdgeLength(minCount: number, totalLength: number): number;
    static applyMaxEdgeLength(options: StrokeOptions | undefined, minCount: number, edgeLength: number): number;
    applyMinStrokesPerPrimitive(minCount: number): number;
    applyTolerancesToArc(radius: number, sweepRadians?: number): number;
    chordTol?: number;
    static createForCurves(): StrokeOptions;
    static createForFacets(): StrokeOptions;
    defaultCircleStrokes: number;
    get hasMaxEdgeLength(): boolean;
    maxEdgeLength?: number;
    minStrokesPerPrimitive?: number;
    needColors?: boolean;
    needConvexFacets?: boolean;
    get needNormals(): boolean;
    set needNormals(value: boolean);
    get needParams(): boolean;
    set needParams(value: boolean);
    get needTwoSided(): boolean;
    set needTwoSided(value: boolean);
    shouldTriangulate: boolean;
}

// @public
export class SweepContour {
    announceFacets(announce: (facets: IndexedPolyface) => void, options: StrokeOptions | undefined): void;
    axis: Ray3d | undefined;
    buildFacets(options: StrokeOptions | undefined): void;
    clone(): SweepContour;
    cloneTransformed(transform: Transform): SweepContour | undefined;
    static createForLinearSweep(contour: CurveCollection, defaultNormal?: Vector3d): SweepContour | undefined;
    static createForPolygon(points: MultiLineStringDataVariant, defaultNormal?: Vector3d): SweepContour | undefined;
    static createForRotation(contour: CurveCollection, axis: Ray3d): SweepContour | undefined;
    curves: CurveCollection;
    emitFacets(builder: PolyfaceBuilder, reverse: boolean, transform?: Transform): void;
    getCurves(): CurveCollection;
    isAlmostEqual(other: any): boolean;
    localToWorld: Transform;
    purgeFacets(): void;
    sweepToUnionOfConvexClipPlaneSets(sweepVector?: Vector3d, cap0?: boolean, cap1?: boolean): UnionOfConvexClipPlaneSets | undefined;
    tryTransformInPlace(transform: Transform): boolean;
    }

// @internal
export class TorusImplicit {
    constructor(majorRadius: number, minorRadius: number);
    boxSize(): number;
    evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d): void;
    evaluateImplicitFunctionPoint(xyz: Point3d): number;
    evaluateImplicitFunctionXYZ(x: number, y: number, z: number): number;
    evaluateImplicitFunctionXYZW(x: number, y: number, z: number, w: number): number;
    evaluateThetaPhi(thetaRadians: number, phiRadians: number): Point3d;
    evaluateThetaPhiDistance(thetaRadians: number, phiRadians: number, distance: number): Point3d;
    implicitFunctionScale(): number;
    majorRadius: number;
    minorRadius: number;
    xyzToThetaPhiDistance(xyz: Point3d): {
        theta: number;
        phi: number;
        distance: number;
        rho: number;
        safePhi: boolean;
    };
}

// @public
export class TorusPipe extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {
    protected constructor(map: Transform, radiusA: number, radiusB: number, sweep: Angle, capped: boolean);
    clone(): TorusPipe;
    cloneCenter(): Point3d;
    cloneTransformed(transform: Transform): TorusPipe | undefined;
    cloneVectorX(): Vector3d;
    cloneVectorY(): Vector3d;
    constantUSection(uFraction: number): CurveCollection | undefined;
    constantVSection(v: number): CurveCollection | undefined;
    static createAlongArc(arc: Arc3d, minorRadius: number, capped: boolean): TorusPipe | undefined;
    static createDgnTorusPipe(center: Point3d, vectorX: Vector3d, vectorY: Vector3d, majorRadius: number, minorRadius: number, sweep: Angle, capped: boolean): TorusPipe | undefined;
    static createInFrame(frame: Transform, majorRadius: number, minorRadius: number, sweep: Angle, capped: boolean): TorusPipe | undefined;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    extendRange(rangeToExtend: Range3d, transform?: Transform): void;
    getConstructiveFrame(): Transform | undefined;
    getIsReversed(): boolean;
    getMajorRadius(): number;
    getMinorRadius(): number;
    getSweepAngle(): Angle;
    getThetaFraction(): number;
    isAlmostEqual(other: GeometryQuery): boolean;
    get isClosedVolume(): boolean;
    isSameGeometryClass(other: any): boolean;
    maxIsoParametricDistance(): Vector2d;
    readonly solidPrimitiveType = "torusPipe";
    tryTransformInPlace(transform: Transform): boolean;
    uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
    vFractionToRadians(v: number): number;
}

// @public
export class Transform implements BeJSONFunctions {
    clone(result?: Transform): Transform;
    cloneRigid(axisOrder?: AxisOrder): Transform | undefined;
    computeCachedInverse(useCached?: boolean): boolean;
    static createFixedPointAndMatrix(fixedPoint: XYAndZ | undefined, matrix: Matrix3d, result?: Transform): Transform;
    static createIdentity(result?: Transform): Transform;
    static createMatrixPickupPutdown(matrix: Matrix3d, pointA: Point3d, pointB: Point3d, result?: Transform): Transform;
    static createOriginAndMatrix(origin: XYZ | undefined, matrix: Matrix3d | undefined, result?: Transform): Transform;
    static createOriginAndMatrixColumns(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d, result?: Transform): Transform;
    static createRefs(origin: XYZ | undefined, matrix: Matrix3d, result?: Transform): Transform;
    static createRigidFromOriginAndColumns(origin: XYZ | undefined, vectorX: Vector3d, vectorY: Vector3d, axisOrder: AxisOrder, result?: Transform): Transform | undefined;
    static createRowValues(qxx: number, qxy: number, qxz: number, ax: number, qyx: number, qyy: number, qyz: number, ay: number, qzx: number, qzy: number, qzz: number, az: number, result?: Transform): Transform;
    static createScaleAboutPoint(fixedPoint: Point3d, scale: number, result?: Transform): Transform;
    static createTranslation(translation: XYZ, result?: Transform): Transform;
    static createTranslationXYZ(x?: number, y?: number, z?: number, result?: Transform): Transform;
    static createZero(result?: Transform): Transform;
    freeze(): Readonly<this>;
    static fromJSON(json?: TransformProps): Transform;
    getOrigin(): Point3d;
    getTranslation(): Vector3d;
    static get identity(): Transform;
    static initFromRange(min: Point3d, max: Point3d, npcToGlobal?: Transform, globalToNpc?: Transform): void;
    inverse(): Transform | undefined;
    isAlmostEqual(other: Transform): boolean;
    get isIdentity(): boolean;
    static matchArrayLengths(source: any[], dest: any[], constructionFunction: () => any): number;
    get matrix(): Matrix3d;
    multiplyComponentXYZ(componentIndex: number, x: number, y: number, z?: number): number;
    multiplyComponentXYZW(componentIndex: number, x: number, y: number, z: number, w: number): number;
    multiplyInversePoint3d(point: XYAndZ, result?: Point3d): Point3d | undefined;
    multiplyInversePoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[] | undefined;
    multiplyInversePoint3dArrayInPlace(source: Point3d[]): boolean;
    multiplyInversePoint4d(weightedPoint: Point4d, result?: Point4d): Point4d | undefined;
    multiplyInverseXYZ(x: number, y: number, z: number, result?: Point3d): Point3d | undefined;
    multiplyPoint2d(source: XAndY, result?: Point2d): Point2d;
    multiplyPoint2dArray(source: Point2d[], result?: Point2d[]): Point2d[];
    multiplyPoint3d(point: XYAndZ, result?: Point3d): Point3d;
    multiplyPoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[];
    multiplyPoint3dArrayArrayInPlace(chains: Point3d[][]): void;
    multiplyPoint3dArrayInPlace(points: Point3d[]): void;
    multiplyRange(range: Range3d, result?: Range3d): Range3d;
    multiplyTransformMatrix3d(other: Matrix3d, result?: Transform): Transform;
    multiplyTransformTransform(other: Transform, result?: Transform): Transform;
    multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d;
    multiplyVector(vector: Vector3d, result?: Vector3d): Vector3d;
    multiplyVectorXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d;
    multiplyXYAndZInPlace(point: XYAndZ): void;
    multiplyXYZ(x: number, y: number, z?: number, result?: Point3d): Point3d;
    multiplyXYZToFloat64Array(x: number, y: number, z: number, result?: Float64Array): Float64Array;
    multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d;
    multiplyXYZWToFloat64Array(x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array;
    get origin(): XYZ;
    setFrom(other: Transform): void;
    setFromJSON(json?: TransformProps | Transform): void;
    setIdentity(): void;
    setMultiplyTransformTransform(transformA: Transform, transformB: Transform): void;
    setOriginAndMatrixColumns(origin: XYZ | undefined, vectorX: Vector3d | undefined, vectorY: Vector3d | undefined, vectorZ: Vector3d | undefined): void;
    toJSON(): TransformProps;
}

// @public
export type TransformProps = number[][] | number[] | {
    origin: XYZProps;
    matrix: Matrix3dProps;
};

// @public
export abstract class TransitionSpiral3d extends CurvePrimitive {
    protected constructor(spiralType: string | undefined, localToWorld: Transform, activeFractionInterval: Segment1d | undefined, designProperties: TransitionConditionalProperties | undefined);
    get activeFractionInterval(): Segment1d;
    protected _activeFractionInterval: Segment1d;
    abstract get activeStrokes(): LineString3d;
    protected applyRigidPartOfTransform(transformA: Transform): {
        rigidAxes: Matrix3d;
        scale: number;
    } | undefined;
    static averageCurvature(radiusLimits: Segment1d): number;
    static averageCurvatureR0R1(r0: number, r1: number): number;
    static curvatureToRadius(curvature: number): number;
    get designProperties(): TransitionConditionalProperties | undefined;
    protected _designProperties: TransitionConditionalProperties | undefined;
    static interpolateCurvatureR0R1(r0: number, fraction: number, r1: number): number;
    get localToWorld(): Transform;
    protected _localToWorld: Transform;
    static radius0LengthSweepRadiansToRadius1(radius0: number, arcLength: number, sweepRadians: number): number;
    static radius1LengthSweepRadiansToRadius0(radius1: number, arcLength: number, sweepRadians: number): number;
    static radiusRadiusLengthToSweepRadians(radius0: number, radius1: number, arcLength: number): number;
    static radiusRadiusSweepRadiansToArcLength(radius0: number, radius1: number, sweepRadians: number): number;
    static radiusToCurvature(radius: number): number;
    // (undocumented)
    get spiralType(): string;
    protected _spiralType: string;
}

// @internal
export class Triangulator {
    static computeInCircleDeterminantIsStrongPositive(nodeA: HalfEdge): boolean;
    static createFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: LineStringDataVariant, returnPositiveAreaLoop: boolean, markExterior: boolean): HalfEdge | undefined;
    static createFaceLoopFromCoordinatesAndMasks(graph: HalfEdgeGraph, data: LineStringDataVariant, returnPositiveAreaLoop: boolean, maskForBothSides: HalfEdgeMask, maskForOtherSide: HalfEdgeMask): HalfEdge | undefined;
    static createTriangulatedGraphFromLoops(loops: GrowableXYZArray[] | XAndY[][]): HalfEdgeGraph | undefined;
    static createTriangulatedGraphFromPoints(points: Point3d[]): HalfEdgeGraph | undefined;
    static createTriangulatedGraphFromSingleLoop(data: XAndY[] | GrowableXYZArray): HalfEdgeGraph;
    static directCreateChainsFromCoordinates(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, id?: number): HalfEdge[];
    static directCreateFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: LineStringDataVariant): HalfEdge | undefined;
    static flipTriangles(graph: HalfEdgeGraph): number;
    static flipTrianglesInEdgeSet(graph: HalfEdgeGraph, edgeSet: MarkedEdgeSet): number;
    static triangulateAllPositiveAreaFaces(graph: HalfEdgeGraph): boolean;
    static triangulateSingleMonotoneFace(graph: HalfEdgeGraph, start: HalfEdge): boolean;
}

// @internal
export class TriDiagonalSystem {
    constructor(n: number);
    addToB(row: number, bb: number): void;
    addToRow(row: number, left: number, diag: number, right: number): void;
    copy(): TriDiagonalSystem;
    defactor(): boolean;
    factor(): boolean;
    factorAndBackSubstitute(): boolean;
    factorAndBackSubstitutePointArrays(vectorB: Point3d[], vectorX: Point3d[]): boolean;
    flatten(): any;
    flattenWithPoints(xyzB: Point3d[]): any;
    getB(row: number): number;
    getX(row: number): number;
    multiplyAX(): boolean;
    multiplyAXPoints(pointX: Point3d[], pointB: Point3d[]): boolean;
    order(): number;
    reset(): void;
    setB(row: number, bb: number): void;
    setRow(row: number, left: number, diag: number, right: number): void;
    setX(row: number, xx: number): void;
    }

// @internal
export class TrigPolynomial {
    static readonly C: Float64Array;
    static readonly CC: Float64Array;
    static readonly CCminusSS: Float64Array;
    static readonly CW: Float64Array;
    static readonly S: Float64Array;
    static readonly SC: Float64Array;
    static solveAngles(coff: Float64Array, nominalDegree: number, referenceCoefficient: number, radians: number[]): boolean;
    static solveUnitCircleEllipseIntersection(cx: number, cy: number, ux: number, uy: number, vx: number, vy: number, ellipseRadians: number[], circleRadians: number[]): boolean;
    static solveUnitCircleHomogeneousEllipseIntersection(cx: number, cy: number, cw: number, ux: number, uy: number, uw: number, vx: number, vy: number, vw: number, ellipseRadians: number[], circleRadians: number[]): boolean;
    static solveUnitCircleImplicitQuadricIntersection(axx: number, axy: number, ayy: number, ax: number, ay: number, a1: number, radians: number[]): boolean;
    static readonly SS: Float64Array;
    static readonly SW: Float64Array;
    static readonly W: Float64Array;
    static readonly WW: Float64Array;
}

// @public
export interface TrigValues {
    c: number;
    radians: number;
    s: number;
}

// @public
export class UnionOfConvexClipPlaneSets implements Clipper, PolygonClipper {
    addConvexSet(toAdd: ConvexClipPlaneSet): void;
    addOutsideZClipSets(invisible: boolean, zLow?: number, zHigh?: number): void;
    announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;
    announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean;
    appendIntervalsFromSegment(segment: LineSegment3d, intervals: Segment1d[]): void;
    // (undocumented)
    appendPolygonClip(xyz: GrowableXYZArray, insideFragments: GrowableXYZArray[], outsideFragments: GrowableXYZArray[], arrayCache: GrowableXYZArrayCache): void;
    classifyPointContainment(points: Point3d[], onIsOutside: boolean): number;
    clone(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets;
    computePlanePlanePlaneIntersectionsInAllConvexSets(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment?: boolean): number;
    get convexSets(): ConvexClipPlaneSet[];
    static createConvexSets(convexSets: ConvexClipPlaneSet[], result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets;
    static createEmpty(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets;
    static fromJSON(json: any, result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets;
    hasIntersectionWithRay(ray: Ray3d, maximalRange?: Range1d): boolean;
    isAlmostEqual(other: UnionOfConvexClipPlaneSets): boolean;
    isAnyPointInOrOnFromSegment(segment: LineSegment3d): boolean;
    isPointInside(point: Point3d): boolean;
    isPointOnOrInside(point: Point3d, tolerance?: number): boolean;
    isSphereInside(point: Point3d, radius: number): boolean;
    multiplyPlanesByMatrix4d(matrix: Matrix4d, invert?: boolean, transpose?: boolean): boolean;
    polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray[]): void;
    setInvisible(invisible: boolean): void;
    toJSON(): any;
    transformInPlace(transform: Transform): void;
}

// @public
export class UnionRegion extends CurveCollection {
    constructor();
    announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent?: number): void;
    get children(): Array<ParityRegion | Loop>;
    protected _children: Array<ParityRegion | Loop>;
    cloneEmptyPeer(): UnionRegion;
    cloneStroked(options?: StrokeOptions): UnionRegion;
    static create(...data: Array<ParityRegion | Loop>): UnionRegion;
    readonly curveCollectionType = "unionRegion";
    dgnBoundaryType(): number;
    dispatchToGeometryHandler(handler: GeometryHandler): any;
    getChild(i: number): Loop | ParityRegion | undefined;
    isSameGeometryClass(other: GeometryQuery): boolean;
    tryAddChild(child: AnyCurve): boolean;
}

// @internal
export class UnivariateBezier extends BezierCoffs {
    constructor(data: number | Float64Array | number[]);
    addConstant(a: number): void;
    addSquaredSquaredBezier(coffA: Float64Array, scale: number): boolean;
    allocateOrder(order: number): void;
    basisFunctions(u: number, result?: Float64Array): Float64Array;
    clone(compressToMinimalAllocation?: boolean): UnivariateBezier;
    static create(other: BezierCoffs): UnivariateBezier;
    static createArraySubset(coffs: number[] | Float64Array, index0: number, order: number, result?: UnivariateBezier): UnivariateBezier;
    static createCoffs(data: number | number[] | Float64Array): UnivariateBezier;
    static createProduct(bezierA: BezierCoffs, bezierB: BezierCoffs): UnivariateBezier;
    deflateLeft(): void;
    deflateRight(): void;
    deflateRoot(root: number): number;
    static deflateRoots01(bezier: UnivariateBezier): number[] | undefined;
    evaluate(u: number): number;
    get order(): number;
    runNewton(startFraction: number, tolerance?: number): number | undefined;
    sumBasisFunctionDerivatives(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array;
    sumBasisFunctions(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array;
    }

// @public
export enum UVSelect {
    uDirection = 0,
    VDirection = 1
}

// @public
export interface UVSurface {
    uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d;
    uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;
}

// @public
export interface UVSurfaceIsoParametricDistance {
    maxIsoParametricDistance(): Vector2d;
}

// @public
export class UVSurfaceOps {
    static createLinestringOnUVLine(surface: UVSurface, u0: number, v0: number, u1: number, v1: number, numEdge: number, saveUV?: boolean, saveFraction?: boolean): LineString3d;
    static sampledRangeOfOffsetEllipsoidPatch(patch: EllipsoidPatch, offsetDistance: number | undefined, options?: StrokeOptions): Range3d;
    static sampledRangeOfOffsetPatch(patch: UVSurface, offsetDistance: number | undefined, numU: number, numV: number): Range3d;
}

// @public
export type VariantCurveExtendParameter = boolean | CurveExtendMode | CurveExtendMode[];

// @public
export class Vector2d extends XY implements BeJSONFunctions {
    constructor(x?: number, y?: number);
    angleTo(vectorB: XAndY): Angle;
    clone(): Vector2d;
    static create(x?: number, y?: number, result?: Vector2d): Vector2d;
    static createFrom(data: XAndY | Float64Array, result?: Vector2d): Vector2d;
    static createOffsetBisector(unitPerpA: Vector2d, unitPerpB: Vector2d, offset: number): Vector2d | undefined;
    static createPolar(r: number, theta: Angle): Vector2d;
    static createStartEnd(point0: XAndY, point1: XAndY, result?: Vector2d): Vector2d;
    static createZero(result?: Vector2d): Vector2d;
    crossProduct(vectorB: XAndY): number;
    dotProduct(vectorB: XAndY): number;
    dotProductStartEnd(pointA: XAndY, pointB: XAndY): number;
    fractionOfProjectionToVector(target: Vector2d, defaultFraction?: number): number;
    static fromJSON(json?: XYProps): Vector2d;
    interpolate(fraction: number, right: Vector2d, result?: Vector2d): Vector2d;
    isParallelTo(other: Vector2d, oppositeIsParallel?: boolean): boolean;
    isPerpendicularTo(other: Vector2d): boolean;
    minus(vector: XAndY, result?: Vector2d): Vector2d;
    negate(result?: Vector2d): Vector2d;
    normalize(result?: Vector2d): Vector2d | undefined;
    plus(vector: XAndY, result?: Vector2d): Vector2d;
    plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Vector2d): Vector2d;
    plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Vector2d): Vector2d;
    plusScaled(vector: XAndY, scaleFactor: number, result?: Vector2d): Vector2d;
    rotate90CCWXY(result?: Vector2d): Vector2d;
    rotate90CWXY(result?: Vector2d): Vector2d;
    rotateXY(angle: Angle, result?: Vector2d): Vector2d;
    safeDivideOrNull(denominator: number, result?: Vector2d): Vector2d | undefined;
    scale(scale: number, result?: Vector2d): Vector2d;
    scaleToLength(length: number, result?: Vector2d): Vector2d | undefined;
    unitPerpendicularXY(result?: Vector2d): Vector2d;
    static unitX(scale?: number): Vector2d;
    static unitY(scale?: number): Vector2d;
}

// @public
export class Vector3d extends XYZ {
    constructor(x?: number, y?: number, z?: number);
    addCrossProductToTargetsInPlace(ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number): void;
    angleFromPerpendicular(vectorB: Vector3d): Angle;
    angleTo(vectorB: Vector3d): Angle;
    angleToXY(vectorB: Vector3d): Angle;
    clone(result?: Vector3d): Vector3d;
    static create(x?: number, y?: number, z?: number, result?: Vector3d): Vector3d;
    static createAdd2Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, result?: Vector3d): Vector3d;
    static createAdd2ScaledXYZ(ax: number, ay: number, az: number, scaleA: number, bx: number, by: number, bz: number, scaleB: number, result?: Vector3d): Vector3d;
    static createAdd3Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, vectorC: XYAndZ, scaleC: number, result?: Vector3d): Vector3d;
    static createCrossProduct(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d;
    static createCrossProductToPoints(origin: XYAndZ, pointA: XYAndZ, pointB: XYAndZ, result?: Vector3d): Vector3d;
    static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Vector3d): Vector3d;
    static createPolar(r: number, theta: Angle, z?: number): Vector3d;
    static createRotateVectorAroundVector(vector: Vector3d, axis: Vector3d, angle?: Angle): Vector3d | undefined;
    static createSpherical(r: number, theta: Angle, phi: Angle): Vector3d;
    static createStartEnd(start: XYAndZ, end: XYAndZ, result?: Vector3d): Vector3d;
    static createStartEndXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: Vector3d): Vector3d;
    static createZero(result?: Vector3d): Vector3d;
    crossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d;
    crossProductMagnitude(vectorB: XYAndZ): number;
    crossProductMagnitudeSquared(vectorB: XYAndZ): number;
    crossProductStartEnd(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d;
    crossProductStartEndXY(pointA: Point3d, pointB: Point3d): number;
    crossProductXY(vectorB: Vector3d): number;
    crossProductXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d;
    dotProduct(vectorB: XYAndZ): number;
    static dotProductAsXYAndZ(dataA: XYAndZ, dataB: XYAndZ): number;
    dotProductStart3dEnd4d(pointA: Point3d, pointB: Point4d): number;
    dotProductStartEnd(pointA: XYAndZ, pointB: XYAndZ): number;
    dotProductStartEndXY(pointA: Point3d, pointB: Point3d): number;
    dotProductStartEndXYZ(pointA: Point3d, x: number, y: number, z: number): number;
    dotProductStartEndXYZW(pointA: Point3d, x: number, y: number, z: number, w: number): number;
    dotProductXY(vectorB: Vector3d): number;
    dotProductXYZ(x: number, y: number, z?: number): number;
    fractionOfProjectionToVector(target: Vector3d, defaultFraction?: number): number;
    static fromJSON(json?: XYZProps): Vector3d;
    interpolate(fraction: number, vectorB: Vector3d, result?: Vector3d): Vector3d;
    isParallelTo(other: Vector3d, oppositeIsParallel?: boolean, returnValueIfAnInputIsZeroLength?: boolean): boolean;
    isPerpendicularTo(other: Vector3d, returnValueIfAnInputIsZeroLength?: boolean): boolean;
    minus(vector: XYAndZ, result?: Vector3d): Vector3d;
    negate(result?: Vector3d): Vector3d;
    normalize(result?: Vector3d): Vector3d | undefined;
    normalizeInPlace(): boolean;
    normalizeWithDefault(x: number, y: number, z: number, result?: Vector3d): Vector3d;
    normalizeWithLength(result?: Vector3d): {
        v: Vector3d | undefined;
        mag: number;
    };
    planarAngleTo(vector: Vector3d, planeNormal: Vector3d): Angle;
    planarRadiansTo(vector: Vector3d, planeNormal: Vector3d): number;
    plus(vector: XYAndZ, result?: Vector3d): Vector3d;
    plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, result?: Vector3d): Vector3d;
    plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Vector3d): Vector3d;
    plusScaled(vector: XYAndZ, scaleFactor: number, result?: Vector3d): Vector3d;
    rotate90Around(axis: Vector3d, result?: Vector3d): Vector3d | undefined;
    rotate90CCWXY(result?: Vector3d): Vector3d;
    rotate90Towards(target: Vector3d, result?: Vector3d): Vector3d | undefined;
    rotateXY(angle: Angle, result?: Vector3d): Vector3d;
    safeDivideOrNull(denominator: number, result?: Vector3d): Vector3d | undefined;
    scale(scale: number, result?: Vector3d): Vector3d;
    scaleToLength(length: number, result?: Vector3d): Vector3d | undefined;
    setStartEnd(point0: XYAndZ, point1: XYAndZ): void;
    signedAngleTo(vector1: Vector3d, vectorW: Vector3d): Angle;
    signedRadiansTo(vector1: Vector3d, vectorW: Vector3d): number;
    sizedCrossProduct(vectorB: Vector3d, productLength: number, result?: Vector3d): Vector3d | undefined;
    smallerUnorientedAngleTo(vectorB: Vector3d): Angle;
    smallerUnorientedRadiansTo(vectorB: Vector3d): number;
    tripleProduct(vectorB: Vector3d, vectorC: Vector3d): number;
    tryNormalizeInPlace(smallestMagnitude?: number): boolean;
    unitCrossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d | undefined;
    unitCrossProductWithDefault(vectorB: Vector3d, x: number, y: number, z: number, result?: Vector3d): Vector3d;
    unitPerpendicularXY(result?: Vector3d): Vector3d;
    static unitX(scale?: number): Vector3d;
    static unitY(scale?: number): Vector3d;
    static unitZ(scale?: number): Vector3d;
}

// @public
export class Vector3dArray {
    static cloneVector3dArray(data: XYAndZ[]): Vector3d[];
    static isAlmostEqual(dataA: undefined | Vector3d[], dataB: undefined | Vector3d[]): boolean;
}

// @public
export enum WeightStyle {
    UnWeighted = 0,
    WeightsAlreadyAppliedToCoordinates = 1,
    WeightsSeparateFromCoordinates = 2
}

// @public
export interface WritableLowAndHighXY {
    high: WritableXAndY;
    low: WritableXAndY;
}

// @public
export interface WritableLowAndHighXYZ {
    high: WritableXYAndZ;
    low: WritableXYAndZ;
}

// @public
export interface WritableXAndY {
    x: number;
    y: number;
}

// @public
export interface WritableXYAndZ extends WritableXAndY, WriteableHasZ {
}

// @public
export interface WriteableHasZ {
    z: number;
}

// @public
export type XAndY = Readonly<WritableXAndY>;

// @public
export class XY implements XAndY {
    protected constructor(x?: number, y?: number);
    static crossProductToPoints(origin: XAndY, targetA: XAndY, targetB: XAndY): number;
    distance(other: XAndY): number;
    distanceSquared(other: XAndY): number;
    freeze(): Readonly<this>;
    isAlmostEqual(other: XAndY, tol?: number): boolean;
    isAlmostEqualMetric(other: XAndY): boolean;
    isAlmostEqualXY(x: number, y: number, tol?: number): boolean;
    get isAlmostZero(): boolean;
    isExactEqual(other: XAndY): boolean;
    magnitude(): number;
    magnitudeSquared(): number;
    maxAbs(): number;
    maxDiff(other: XAndY): number;
    set(x?: number, y?: number): void;
    setFrom(other?: XAndY): void;
    setFromJSON(json?: XYProps): void;
    setZero(): void;
    toJSON(): XYProps;
    toJSONXY(): XYProps;
    unitVectorTo(target: XAndY, result?: Vector2d): Vector2d | undefined;
    vectorTo(other: XAndY, result?: Vector2d): Vector2d;
    x: number;
    y: number;
}

// @public
export type XYAndZ = Readonly<WritableXYAndZ>;

// @public
export type XYProps = {
    x?: number;
    y?: number;
} | number[];

// @public
export class XYZ implements XYAndZ {
    protected constructor(x?: number, y?: number, z?: number);
    static accessX(arg: any, defaultValue?: number): number | undefined;
    static accessY(arg: any, defaultValue?: number): number | undefined;
    static accessZ(arg: any, defaultValue?: number): number | undefined;
    addInPlace(other: XYAndZ): void;
    addScaledInPlace(other: XYAndZ, scale: number): void;
    addXYZInPlace(dx?: number, dy?: number, dz?: number): void;
    at(index: number): number;
    cloneAsPoint3d(): Point3d;
    distance(other: XYAndZ): number;
    distanceSquared(other: XYAndZ): number;
    distanceSquaredXY(other: XAndY): number;
    distanceXY(other: XAndY): number;
    freeze(): Readonly<this>;
    static hasZ(arg: any): arg is HasZ;
    indexOfMaxAbs(): number;
    isAlmostEqual(other: XYAndZ, tol?: number): boolean;
    isAlmostEqualMetric(other: XYAndZ): boolean;
    isAlmostEqualXY(other: XAndY, tol?: number): boolean;
    isAlmostEqualXYZ(x: number, y: number, z: number, tol?: number): boolean;
    get isAlmostZero(): boolean;
    static isAnyImmediatePointType(arg: any): boolean;
    isExactEqual(other: XYAndZ): boolean;
    static isXAndY(arg: any): arg is XAndY;
    static isXYAndZ(arg: any): arg is XYAndZ;
    magnitude(): number;
    magnitudeSquared(): number;
    magnitudeSquaredXY(): number;
    magnitudeXY(): number;
    maxAbs(): number;
    maxDiff(other: XYAndZ): number;
    scaledVectorTo(other: XYAndZ, scale: number, result?: Vector3d): Vector3d;
    scaleInPlace(scale: number): void;
    set(x?: number, y?: number, z?: number): void;
    setAt(index: number, value: number): void;
    setFrom(other: Float64Array | XAndY | XYAndZ | undefined): void;
    setFromJSON(json?: XYZProps): void;
    setFromPoint3d(other?: XYAndZ): void;
    setFromVector3d(other: Vector3d): void;
    setZero(): void;
    subtractInPlace(other: XYAndZ): void;
    toFloat64Array(): Float64Array;
    toJSON(): XYZProps;
    toJSONXYZ(): XYZProps;
    unitVectorTo(target: XYAndZ, result?: Vector3d): Vector3d | undefined;
    vectorTo(other: XYAndZ, result?: Vector3d): Vector3d;
    x: number;
    y: number;
    z: number;
}

// @public
export type XYZProps = {
    x?: number;
    y?: number;
    z?: number;
} | number[];

// @public
export class YawPitchRollAngles {
    constructor(yaw?: Angle, pitch?: Angle, roll?: Angle);
    clone(): YawPitchRollAngles;
    static createDegrees(yawDegrees: number, pitchDegrees: number, rollDegrees: number): YawPitchRollAngles;
    static createFromMatrix3d(matrix: Matrix3d, result?: YawPitchRollAngles): YawPitchRollAngles | undefined;
    static createRadians(yawRadians: number, pitchRadians: number, rollRadians: number): YawPitchRollAngles;
    freeze(): Readonly<this>;
    static fromJSON(json?: YawPitchRollProps): YawPitchRollAngles;
    isAlmostEqual(other: YawPitchRollAngles): boolean;
    isIdentity(allowPeriodShift?: boolean): boolean;
    maxAbsDegrees(): number;
    maxAbsRadians(): number;
    maxDiffRadians(other: YawPitchRollAngles): number;
    pitch: Angle;
    roll: Angle;
    setFrom(other: YawPitchRollAngles): void;
    setFromJSON(json?: YawPitchRollProps): void;
    sumSquaredDegrees(): number;
    sumSquaredRadians(): number;
    toJSON(): YawPitchRollProps;
    toMatrix3d(result?: Matrix3d): Matrix3d;
    static tryFromTransform(transform: Transform): {
        origin: Point3d;
        angles: YawPitchRollAngles | undefined;
    };
    yaw: Angle;
}

// @public
export interface YawPitchRollProps {
    pitch?: AngleProps;
    roll?: AngleProps;
    yaw?: AngleProps;
}


```
