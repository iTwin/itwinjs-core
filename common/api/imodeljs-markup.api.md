## API Report File for "@bentley/imodeljs-markup"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BeButtonEvent } from '@bentley/imodeljs-frontend';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BeModifierKeys } from '@bentley/imodeljs-frontend';
import { BeTouchEvent } from '@bentley/imodeljs-frontend';
import { Box } from '@svgdotjs/svg.js';
import { Element } from '@svgdotjs/svg.js';
import { EventHandled } from '@bentley/imodeljs-frontend';
import { G } from '@svgdotjs/svg.js';
import { I18NNamespace } from '@bentley/imodeljs-i18n';
import { Marker } from '@svgdotjs/svg.js';
import { Matrix } from '@svgdotjs/svg.js';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { PrimitiveTool } from '@bentley/imodeljs-frontend';
import { ScreenViewport } from '@bentley/imodeljs-frontend';
import { Svg } from '@svgdotjs/svg.js';
import { Text } from '@svgdotjs/svg.js';
import { Transform } from '@bentley/geometry-core';
import { Viewport } from '@bentley/imodeljs-frontend';
import { XAndY } from '@bentley/geometry-core';

// @beta (undocumented)
export class ArrowTool extends RedlineTool {
    constructor(_arrowPos?: string | undefined);
    // (undocumented)
    protected _arrowPos?: string | undefined;
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected getOrCreateArrowMarker(color: string): Marker;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class CircleTool extends RedlineTool {
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class CloudTool extends RedlineTool {
    // (undocumented)
    protected clearDynamicsMarkup(isDynamics: boolean): void;
    // (undocumented)
    protected _cloud?: Element;
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class DistanceTool extends ArrowTool {
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected getFormattedDistance(distance: number): string | undefined;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected readonly _startPointWorld: Point3d;
    // (undocumented)
    static toolId: string;
}

// @beta
export class EditTextTool extends MarkupTool {
    constructor(text?: G | Text | undefined, _fromPlaceTool?: boolean);
    // (undocumented)
    boxed?: G;
    // (undocumented)
    editDiv?: HTMLDivElement;
    // (undocumented)
    editor?: HTMLTextAreaElement;
    onCleanup(): void;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    startEditor(): void;
    // (undocumented)
    text?: G | Text | undefined;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class EllipseTool extends RedlineTool {
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class Handles {
    constructor(ss: SelectionSet, el: Element);
    // (undocumented)
    active?: ModifyHandle;
    cancelDrag(): void;
    // (undocumented)
    drag(ev: BeButtonEvent): void;
    // (undocumented)
    dragging: boolean;
    // (undocumented)
    draw(): void;
    // (undocumented)
    el: Element;
    endDrag(undo: UndoManager): EventHandled;
    // (undocumented)
    group: G;
    // (undocumented)
    readonly handles: ModifyHandle[];
    // (undocumented)
    npcToBox(p: XAndY): Point2d;
    // (undocumented)
    npcToVb(p: XAndY, result?: Point2d): Point2d;
    // (undocumented)
    npcToVbArray(pts: Point2d[]): Point2d[];
    // (undocumented)
    npcToVbTrn: Transform;
    // (undocumented)
    remove(): void;
    // (undocumented)
    ss: SelectionSet;
    // (undocumented)
    startDrag(ev: BeButtonEvent): EventHandled;
    // (undocumented)
    vbToBox(p: XAndY, result?: Point2d): Point2d;
    // (undocumented)
    vbToBoxTrn: Transform;
}

// @beta (undocumented)
export class LineTool extends RedlineTool {
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class Markup {
    constructor(vp: ScreenViewport, markupData?: MarkupSvgData);
    bringToFront(): void;
    deleteSelected(): void;
    destroy(): void;
    disablePick(): void;
    enablePick(): void;
    groupSelected(): void;
    // (undocumented)
    readonly markupDiv: HTMLDivElement;
    // (undocumented)
    readonly selected: SelectionSet;
    sendToBack(): void;
    setCursor(cursor: string): void;
    // (undocumented)
    readonly svgContainer?: Svg;
    // (undocumented)
    readonly svgDecorations?: G;
    // (undocumented)
    readonly svgDynamics?: G;
    // (undocumented)
    readonly svgMarkup?: G;
    // (undocumented)
    readonly undo: UndoManager;
    ungroupSelected(): void;
    // (undocumented)
    vp: ScreenViewport;
}

// @beta
export class MarkupApp {
    // (undocumented)
    static readonly boxedTextClass: string;
    // (undocumented)
    static readonly containerClass: string;
    // (undocumented)
    static convertVpToVb(pt: XAndY): Point3d;
    // (undocumented)
    static readonly cornerId: string;
    // (undocumented)
    protected static createMarkup(view: ScreenViewport, markupData?: MarkupSvgData): Markup;
    // (undocumented)
    static readonly decorationsClass: string;
    // (undocumented)
    static readonly dropShadowId: string;
    // (undocumented)
    static readonly dynamicsClass: string;
    // (undocumented)
    static getVpToScreenMtx(): Matrix;
    // (undocumented)
    static getVpToVbMtx(): Matrix;
    // (undocumented)
    protected static init(): Promise<void>;
    static readonly isActive: boolean;
    // (undocumented)
    protected static lockViewportSize(view: ScreenViewport, markupData?: MarkupSvgData): void;
    static markup?: Markup;
    static markupNamespace: I18NNamespace;
    // (undocumented)
    static markupPrefix: string;
    // (undocumented)
    static markupSelectToolId: string;
    // (undocumented)
    static readonly markupSvgClass: string;
    // (undocumented)
    static readonly moveHandleClass: string;
    static props: {
        handles: {
            size: number;
            stretch: {
                "fill-opacity": number;
                "stroke": string;
                "fill": string;
            };
            rotateLine: {
                "stroke": string;
                "fill-opacity": number;
            };
            rotate: {
                "cursor": string;
                "fill-opacity": number;
                "stroke": string;
                "fill": string;
            };
            moveOutline: {
                "cursor": string;
                "stroke-dasharray": string;
                "fill": string;
                "stroke-opacity": number;
                "stroke": string;
            };
            move: {
                "cursor": string;
                "opacity": number;
                "stroke-width": number;
                "stroke": string;
            };
            vertex: {
                "cursor": string;
                "fill-opacity": number;
                "stroke": string;
                "fill": string;
            };
        };
        hilite: {
            color: string;
            flash: string;
        };
        dropShadow: {
            enable: boolean;
            attr: {
                "stdDeviation": number;
                "dx": number;
                "dy": number;
                "flood-color": string;
            };
        };
        active: {
            text: {
                "font-family": string;
                "font-size": string;
                "stroke": string;
                "fill": string;
            };
            element: {
                "stroke": string;
                "stroke-opacity": number;
                "stroke-width": number;
                "fill-opacity": number;
                "fill": string;
                "stroke-linecap": string;
                "stroke-linejoin": string;
            };
            arrow: {
                length: number;
                width: number;
            };
            cloud: {
                path: string;
            };
        };
        text: {
            startValue: string;
            edit: {
                background: string;
                size: {
                    width: string;
                    height: string;
                };
                fontSize: string;
                textBox: {
                    "fill": string;
                    "fill-opacity": number;
                    "stroke-opacity": number;
                    "stroke": string;
                };
            };
        };
        borderOutline: {
            "stroke": string;
            "stroke-width": number;
            "stroke-opacity": number;
            "fill": string;
        };
        borderCorners: {
            "stroke": string;
            "stroke-width": number;
            "stroke-opacity": number;
            "fill": string;
            "fill-opacity": number;
        };
        result: {
            imageFormat: string;
            imprintSvgOnImage: boolean;
            maxWidth: number;
        };
    };
    // (undocumented)
    protected static readMarkup(): Promise<MarkupData>;
    protected static readMarkupSvg(): string | undefined;
    // (undocumented)
    static readonly rotateHandleClass: string;
    // (undocumented)
    static readonly rotateLineClass: string;
    // (undocumented)
    static screenToVbMtx: Matrix;
    static start(view: ScreenViewport, markupData?: MarkupSvgData): Promise<void>;
    static stop(): Promise<MarkupData>;
    // (undocumented)
    static readonly stretchHandleClass: string;
    // (undocumented)
    static readonly textClass: string;
    static readonly textEditorClass: string;
    static readonly textOutlineClass: string;
    // (undocumented)
    static readonly vertexHandleClass: string;
}

// @beta (undocumented)
export interface MarkupColor {
    // (undocumented)
    fill: any;
    // (undocumented)
    stroke: any;
}

// @beta
export interface MarkupData extends MarkupSvgData {
    image?: string;
}

// @beta (undocumented)
export interface MarkupSvgData {
    rect: WidthAndHeight;
    svg?: string;
}

// @beta
export abstract class MarkupTool extends PrimitiveTool {
    // (undocumented)
    createBoxedText(g: G, text: Text): G;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    markup: Markup;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected outputMarkupPrompt(msg: string): void;
    pickElement(pt: XAndY): Element | undefined;
    // (undocumented)
    redoPreviousStep(): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setCurrentStyle(element: Element, canBeFilled: boolean): void;
    // (undocumented)
    protected setCurrentTextStyle(element: Element): void;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolKey: string;
    // (undocumented)
    undoPreviousStep(): Promise<boolean>;
}

// @beta
export abstract class ModifyHandle {
    constructor(handles: Handles);
    // (undocumented)
    handles: Handles;
    abstract modify(ev: BeButtonEvent): void;
    // (undocumented)
    onClick(_ev: BeButtonEvent): void;
    // (undocumented)
    setMouseHandler(target: Element): void;
    abstract setPosition(): void;
    startDrag(_ev: BeButtonEvent, makeCopy?: boolean): void;
    // (undocumented)
    startModify(makeCopy: boolean): void;
    // (undocumented)
    vbToStartTrn: Transform;
}

// @beta
export class PlaceTextTool extends RedlineTool {
    // (undocumented)
    protected createMarkup(svg: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected _minPoints: number;
    // (undocumented)
    protected _nRequiredPoints: number;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _value: string;
}

// @beta (undocumented)
export class PolygonTool extends RedlineTool {
    constructor(_numSides?: number | undefined);
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected getPoints(points: number[], center: Point3d, edge: Point3d, numSides: number, inscribe: boolean): boolean;
    // (undocumented)
    protected _numSides?: number | undefined;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class RectangleTool extends RedlineTool {
    constructor(_cornerRadius?: number | undefined);
    // (undocumented)
    protected _cornerRadius?: number | undefined;
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class RedlineTool extends MarkupTool {
    // (undocumented)
    protected clearDynamicsMarkup(_isDynamics: boolean): void;
    // (undocumented)
    protected createMarkup(_svgMarkup: G, _ev: BeButtonEvent, _isDynamics: boolean): void;
    // (undocumented)
    protected isComplete(_ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _minPoints: number;
    // (undocumented)
    protected _nRequiredPoints: number;
    // (undocumented)
    protected onAdded(el: Element): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
}

// @beta
export class SelectionSet {
    constructor(svg: G);
    add(el: Element): void;
    // (undocumented)
    clearEditors(): void;
    // (undocumented)
    deleteAll(undo: UndoManager): void;
    drop(el: Element): boolean;
    // (undocumented)
    readonly elements: Set<Element>;
    // (undocumented)
    emptyAll(): void;
    // (undocumented)
    groupAll(undo: UndoManager): void;
    // (undocumented)
    handles?: Handles;
    // (undocumented)
    has(el: Element): boolean;
    // (undocumented)
    readonly isEmpty: boolean;
    readonly onChanged: BeEvent<(selected: SelectionSet) => void>;
    replace(oldEl: Element, newEl: Element): void;
    reposition(undo: UndoManager, fn: (el: Element) => void): void;
    // (undocumented)
    restart(el?: Element): void;
    // (undocumented)
    readonly size: number;
    // (undocumented)
    sizeChanged(): void;
    // (undocumented)
    svg: G;
    // (undocumented)
    ungroupAll(undo: UndoManager): void;
}

// @beta
export class SelectTool extends MarkupTool {
    // (undocumented)
    flashedElement: Element | undefined;
    // (undocumented)
    onCleanup(): void;
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    onKeyTransition(wentDown: boolean, key: KeyboardEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class SketchTool extends RedlineTool {
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    protected _minDistSquared: number;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @beta (undocumented)
export class SymbolTool extends RedlineTool {
    constructor(_symbolData?: string | undefined, _applyCurrentStyle?: boolean | undefined);
    // (undocumented)
    protected _applyCurrentStyle?: boolean | undefined;
    // (undocumented)
    protected clearDynamicsMarkup(isDynamics: boolean): void;
    // (undocumented)
    protected createMarkup(svgMarkup: G, ev: BeButtonEvent, isDynamics: boolean): void;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _symbol?: Element;
    // (undocumented)
    protected _symbolData?: string | undefined;
    // (undocumented)
    static toolId: string;
}

// @internal
export class Title extends Element {
    constructor(node: any);
    // (undocumented)
    bbox(): Box;
    // (undocumented)
    dmove(): this;
    // (undocumented)
    move(): this;
    // (undocumented)
    scale(): this;
    // (undocumented)
    screenCTM(): Matrix;
    // (undocumented)
    size(): this;
}

// @beta
export class UndoManager {
    doGroup(fn: VoidFunction): void;
    doRedo(): void;
    doUndo(): void;
    onAdded(elem: Element): void;
    onDelete(elem: Element): void;
    onModified(newElem: Element, oldElem: Element): void;
    onRepositioned(elem: Element, oldIndex: number, oldParent: Element): void;
    // (undocumented)
    readonly size: number;
    }

// @beta (undocumented)
export interface WidthAndHeight {
    // (undocumented)
    height: number;
    // (undocumented)
    width: number;
}


// (No @packageDocumentation comment for this package)

```
