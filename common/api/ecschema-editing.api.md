## API Report File for "@bentley/ecschema-editing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnyClass } from '@bentley/ecschema-metadata';
import { AnyECType } from '@bentley/ecschema-metadata';
import { AnyEnumerator } from '@bentley/ecschema-metadata';
import { AnyProperty } from '@bentley/ecschema-metadata';
import { Constant } from '@bentley/ecschema-metadata';
import { ConstantProps } from '@bentley/ecschema-metadata';
import { CustomAttribute } from '@bentley/ecschema-metadata';
import { CustomAttributeClass } from '@bentley/ecschema-metadata';
import { CustomAttributeClassProps } from '@bentley/ecschema-metadata';
import { CustomAttributeContainerProps } from '@bentley/ecschema-metadata';
import { CustomAttributeContainerType } from '@bentley/ecschema-metadata';
import { ECClassModifier } from '@bentley/ecschema-metadata';
import { EntityClass } from '@bentley/ecschema-metadata';
import { EntityClassProps } from '@bentley/ecschema-metadata';
import { Enumeration } from '@bentley/ecschema-metadata';
import { EnumerationPropertyProps } from '@bentley/ecschema-metadata';
import { EnumerationProps } from '@bentley/ecschema-metadata';
import { Format } from '@bentley/ecschema-metadata';
import { FormatProps } from '@bentley/ecschema-metadata';
import { FormatType } from '@bentley/ecschema-metadata';
import { I18N } from '@bentley/imodeljs-i18n';
import { InvertedUnit } from '@bentley/ecschema-metadata';
import { InvertedUnitProps } from '@bentley/ecschema-metadata';
import { ISchemaPartVisitor } from '@bentley/ecschema-metadata';
import { KindOfQuantity } from '@bentley/ecschema-metadata';
import { KindOfQuantityProps } from '@bentley/ecschema-metadata';
import { Mixin } from '@bentley/ecschema-metadata';
import { MixinProps } from '@bentley/ecschema-metadata';
import { OverrideFormat } from '@bentley/ecschema-metadata';
import { Phenomenon } from '@bentley/ecschema-metadata';
import { PhenomenonProps } from '@bentley/ecschema-metadata';
import { PrimitiveArrayPropertyProps } from '@bentley/ecschema-metadata';
import { PrimitivePropertyProps } from '@bentley/ecschema-metadata';
import { PrimitiveType } from '@bentley/ecschema-metadata';
import { PropertyCategory } from '@bentley/ecschema-metadata';
import { PropertyCategoryProps } from '@bentley/ecschema-metadata';
import { RelationshipClass } from '@bentley/ecschema-metadata';
import { RelationshipClassProps } from '@bentley/ecschema-metadata';
import { RelationshipConstraint } from '@bentley/ecschema-metadata';
import { Schema } from '@bentley/ecschema-metadata';
import { SchemaContext } from '@bentley/ecschema-metadata';
import { SchemaItem } from '@bentley/ecschema-metadata';
import { SchemaItemKey } from '@bentley/ecschema-metadata';
import { SchemaKey } from '@bentley/ecschema-metadata';
import { StrengthDirection } from '@bentley/ecschema-metadata';
import { StructArrayPropertyProps } from '@bentley/ecschema-metadata';
import { StructClass } from '@bentley/ecschema-metadata';
import { StructClassProps } from '@bentley/ecschema-metadata';
import { StructPropertyProps } from '@bentley/ecschema-metadata';
import { Unit } from '@bentley/ecschema-metadata';
import { UnitProps } from '@bentley/ecschema-metadata';
import { UnitSystem } from '@bentley/ecschema-metadata';
import { UnitSystemProps } from '@bentley/ecschema-metadata';

// @beta
export type AnyDiagnostic = IDiagnostic<AnyECType, any[]>;

// @beta
export abstract class BaseDiagnostic<TYPE extends AnyECType, ARGS extends any[]> implements IDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: TYPE, messageArgs?: ARGS, category?: DiagnosticCategory);
    category: DiagnosticCategory;
    abstract get code(): string;
    abstract get diagnosticType(): DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    abstract get messageText(): string;
    abstract get schema(): Schema;
}

// @beta (undocumented)
export type BaseRule<T extends AnyECType, U extends AnyECType> = IRule<T, U>;

// @beta
export abstract class ClassDiagnostic<ARGS extends any[]> extends SchemaItemDiagnostic<AnyClass, ARGS> {
    constructor(ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory);
    get schema(): Schema;
}

// @beta
export function createClassDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyClass;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createCustomAttributeContainerDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: CustomAttributeContainerProps;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createPropertyDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (property: AnyProperty, messageArgs?: ARGS | undefined, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyProperty;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
};

// @beta
export function createRelationshipConstraintDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: RelationshipConstraint;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createSchemaDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: Schema;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
    diagnosticType: DiagnosticType;
};

// @beta
export function createSchemaItemDiagnosticClass<ITEM extends SchemaItem, ARGS extends any[]>(code: string, messageText: string): {
    new (ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: ITEM;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export abstract class CustomAttributeContainerDiagnostic<ARGS extends any[]> extends BaseDiagnostic<CustomAttributeContainerProps, ARGS> {
    constructor(container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @beta
export enum DiagnosticCategory {
    // (undocumented)
    Error = 1,
    // (undocumented)
    Message = 3,
    // (undocumented)
    Suggestion = 2,
    // (undocumented)
    Warning = 0
}

// @beta (undocumented)
export function diagnosticCategoryToString(category: DiagnosticCategory): "Error" | "Warning" | "Message" | "Suggestion";

// @beta
export const DiagnosticCodes: {
    BaseClassIsSealed: string;
    BaseClassOfDifferentType: string;
    AbstractClassWithNonAbstractBase: string;
    CustomAttributeNotOfConcreteClass: string;
    CustomAttributeSchemaMustBeReferenced: string;
    CustomAttributeClassNotFound: string;
    EnumerationTypeUnsupported: string;
    MixinAppliedToClassMustDeriveFromConstraint: string;
    IncompatibleValueTypePropertyOverride: string;
    IncompatibleTypePropertyOverride: string;
    IncompatibleUnitPropertyOverride: string;
    AbstractConstraintMustNarrowBaseConstraints: string;
    DerivedConstraintsMustNarrowBaseConstraints: string;
    ConstraintClassesDeriveFromAbstractContraint: string;
    AtLeastOneConstraintClassDefined: string;
    AbstractConstraintMustExistWithMultipleConstraints: string;
};

// @beta
export const Diagnostics: {
    SupplementalSchemasCannotBeReferenced: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaRefAliasMustBeUnique: {
        new (schema: Schema, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ReferenceCyclesNotAllowed: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsSealed: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsOfDifferentType: {
        new (ecClass: AnyClass, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AbstractClassWithNonAbstractBase: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeNotOfConcreteClass: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeSchemaMustBeReferenced: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeClassNotFound: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    EnumerationTypeUnsupported: {
        new (ecDefinition: import("@bentley/ecschema-metadata").SchemaItem, messageArgs: [string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinAppliedToClassMustDeriveFromConstraint: {
        new (ecDefinition: import("@bentley/ecschema-metadata").SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    IncompatibleValueTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleUnitPropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipMustBeRoot: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationTargetMustHaveSingularMultiplicity: {
        new (property: AnyProperty, messageArgs?: [string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipAbstractConstraintEntityOrMixin: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationClassMustBeAConstraintClassOfRelationship: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    AbstractConstraintMustNarrowBaseConstraints: {
        new (ecDefinition: import("@bentley/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    DerivedConstraintsMustNarrowBaseConstraints: {
        new (ecDefinition: import("@bentley/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstraintClassesDeriveFromAbstractContraint: {
        new (ecDefinition: import("@bentley/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AtLeastOneConstraintClassDefined: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    AbstractConstraintMustExistWithMultipleConstraints: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
};

// @beta
export enum DiagnosticType {
    // (undocumented)
    CustomAttributeContainer = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Property = 3,
    // (undocumented)
    RelationshipConstraint = 5,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SchemaItem = 2
}

// @beta (undocumented)
export function diagnosticTypeToString(type: DiagnosticType): "CustomAttributeContainer" | "None" | "Property" | "RelationshipConstraint" | "Schema" | "SchemaItem";

// @beta
export const ECRuleSet: IRuleSet;

// @alpha (undocumented)
export namespace Editors {
    export class Constants {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, phenomenon: SchemaItemKey, definition: string, displayLabel?: string, numerator?: number, denominator?: number): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, constantProps: ConstantProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class CustomAttributes extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, containerType: CustomAttributeContainerType, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, caProps: CustomAttributeClassProps): Promise<SchemaItemEditResults>;
    }
    export class ECClasses {
        protected constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        createEnumerationProperty(classKey: SchemaItemKey, name: string, type: Enumeration): Promise<PropertyEditResults>;
        // (undocumented)
        createEnumerationPropertyFromProps(classKey: SchemaItemKey, name: string, type: Enumeration, enumProps: EnumerationPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitiveArrayProperty(classKey: SchemaItemKey, name: string, type: PrimitiveType): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitiveArrayPropertyFromProps(classKey: SchemaItemKey, name: string, type: PrimitiveType, primitiveProps: PrimitiveArrayPropertyProps): Promise<PropertyEditResults>;
        createPrimitiveProperty(classKey: SchemaItemKey, name: string, type: PrimitiveType): Promise<PropertyEditResults>;
        // (undocumented)
        createPrimitivePropertyFromProps(classKey: SchemaItemKey, name: string, type: PrimitiveType, primitiveProps: PrimitivePropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createStructArrayProperty(classKey: SchemaItemKey, name: string, type: StructClass): Promise<PropertyEditResults>;
        // (undocumented)
        createStructArrayPropertyFromProps(classKey: SchemaItemKey, name: string, type: StructClass, structProps: StructArrayPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        createStructProperty(classKey: SchemaItemKey, name: string, type: StructClass): Promise<PropertyEditResults>;
        // (undocumented)
        createStructPropertyFromProps(classKey: SchemaItemKey, name: string, type: StructClass, structProps: StructPropertyProps): Promise<PropertyEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Entities extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addMixin(entityKey: SchemaItemKey, mixinKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, modifier: ECClassModifier, displayLabel?: string, baseClass?: SchemaItemKey, mixins?: Mixin[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, entityProps: EntityClassProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(entityKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Enumerations {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addEnumerator(enumerationKey: SchemaItemKey, enumerator: AnyEnumerator): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, type: PrimitiveType.Integer | PrimitiveType.String, displayLabel?: string, isStrict?: boolean, enumerators?: AnyEnumerator[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, enumProps: EnumerationProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Formats {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, formatType: FormatType, displayLabel?: string, units?: SchemaItemKey[]): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, formatProps: FormatProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class InvertedUnits {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, invertsUnitKey: SchemaItemKey, unitSystemKey: SchemaItemKey, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, invertedUnitProps: InvertedUnitProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
        // (undocumented)
        setInvertsUnit(invertedUnitKey: SchemaItemKey, invertsUnitKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        setUnitSystem(invertedUnitKey: SchemaItemKey, unitSystemKey: SchemaItemKey): Promise<void>;
    }
    export class KindOfQuantities {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addPresentationFormat(koqKey: SchemaItemKey, format: SchemaItemKey, isDefault?: boolean): Promise<void>;
        // (undocumented)
        addPresentationOverrideFormat(koqKey: SchemaItemKey, overrideFormat: OverrideFormat, isDefault?: boolean): Promise<void>;
        // (undocumented)
        createFormatOverride(koqKey: SchemaItemKey, parent: SchemaItemKey, precision?: number, unitLabelOverrides?: Array<[Unit | InvertedUnit, string | undefined]>): Promise<OverrideFormat>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, koqProps: KindOfQuantityProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class Mixins extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        addMixin(entityKey: SchemaItemKey, mixinKey: SchemaItemKey): Promise<void>;
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, appliesTo: SchemaItemKey, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, mixinProps: MixinProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(mixinKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Phenomenons {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, definition: string, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, phenomenonProps: PhenomenonProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class PropertyCategories {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, priority: number, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, propertyCategoryProps: PropertyCategoryProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
        // (undocumented)
        setPriority(propCategoryKey: SchemaItemKey, priority: number): Promise<void>;
    }
    export class RelationshipClasses extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        createFromProps(schemaKey: SchemaKey, relationshipProps: RelationshipClassProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        createNavigationProperty(relationshipKey: SchemaItemKey, name: string, relationship: string | RelationshipClass, direction: string | StrengthDirection): Promise<PropertyEditResults>;
    }
    export class Structs extends ECClasses {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, displayLabel?: string, baseClass?: SchemaItemKey): Promise<SchemaItemEditResults>;
        createFromProps(schemaKey: SchemaKey, structProps: StructClassProps): Promise<SchemaItemEditResults>;
    }
    export class Units {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, definition: string, phenomenon: SchemaItemKey, unitSystem: SchemaItemKey, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, unitProps: UnitProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
    export class UnitSystems {
        constructor(_schemaEditor: SchemaContextEditor);
        // (undocumented)
        create(schemaKey: SchemaKey, name: string, displayLabel?: string): Promise<SchemaItemEditResults>;
        // (undocumented)
        createFromProps(schemaKey: SchemaKey, unitSystemProps: UnitSystemProps): Promise<SchemaItemEditResults>;
        // (undocumented)
        protected _schemaEditor: SchemaContextEditor;
    }
}

// @beta
export abstract class FormatDiagnosticReporter extends SuppressionDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>, i18n?: I18N);
    protected formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string;
    i18N?: I18N;
    protected abstract reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
    reportInternal(diagnostic: AnyDiagnostic): void;
    }

// @beta
export interface IDiagnostic<TYPE extends AnyECType, ARGS extends any[]> {
    category: DiagnosticCategory;
    code: string;
    diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    messageText: string;
    schema: Schema;
}

// @beta
export interface IDiagnosticReporter {
    i18N?: I18N;
    report(diagnostic: AnyDiagnostic): void;
    suppressions?: Map<string, string[]>;
}

// @beta
export type IRule<T extends AnyECType, U = {}> = (ecDefinition: T, ...args: U[]) => AsyncIterable<BaseDiagnostic<T, any[]>>;

// @beta
export interface IRuleSet {
    classRules?: Array<IRule<AnyClass>>;
    constantRules?: Array<IRule<Constant>>;
    customAttributeClassRules?: Array<IRule<CustomAttributeClass>>;
    customAttributeContainerRules?: Array<IRule<CustomAttributeContainerProps>>;
    customAttributeInstanceRules?: Array<BaseRule<CustomAttributeContainerProps, CustomAttribute>>;
    entityClassRules?: Array<IRule<EntityClass>>;
    enumerationRules?: Array<IRule<Enumeration>>;
    formatRules?: Array<IRule<Format>>;
    invertedUnitRules?: Array<IRule<InvertedUnit>>;
    kindOfQuantityRules?: Array<IRule<KindOfQuantity>>;
    mixinRules?: Array<IRule<Mixin>>;
    name: string;
    phenomenonRules?: Array<IRule<Phenomenon>>;
    propertyCategoryRules?: Array<IRule<PropertyCategory>>;
    propertyRules?: Array<IRule<AnyProperty>>;
    relationshipConstraintRules?: Array<IRule<RelationshipConstraint>>;
    relationshipRules?: Array<IRule<RelationshipClass>>;
    schemaExclusionSet?: string[];
    schemaItemRules?: Array<IRule<SchemaItem>>;
    schemaRules?: Array<IRule<Schema>>;
    structClassRules?: Array<IRule<StructClass>>;
    unitRules?: Array<IRule<Unit>>;
    unitSystemRules?: Array<IRule<UnitSystem>>;
}

// @beta
export interface IRuleSuppressionMap<T extends AnyECType, U = {}> {
    // (undocumented)
    rule: ISuppressionRule<T, U>;
    // (undocumented)
    ruleCode: string;
}

// @beta
export interface IRuleSuppressionSet {
    // (undocumented)
    classRuleSuppressions?: Array<IRuleSuppressionMap<AnyClass>>;
    // (undocumented)
    constantRuleSuppressions?: Array<IRuleSuppressionMap<Constant>>;
    // (undocumented)
    customAttributeContainerSuppressions?: Array<IRuleSuppressionMap<CustomAttributeContainerProps>>;
    // (undocumented)
    customAttributeInstanceSuppressions?: Array<BaseRuleSuppressionMap<CustomAttributeContainerProps, CustomAttribute>>;
    // (undocumented)
    customAttributeRuleSuppressions?: Array<IRuleSuppressionMap<CustomAttributeClass>>;
    // (undocumented)
    entityRuleSuppressions?: Array<IRuleSuppressionMap<EntityClass>>;
    // (undocumented)
    enumerationRuleSuppressions?: Array<IRuleSuppressionMap<Enumeration>>;
    // (undocumented)
    formatRuleSuppressions?: Array<IRuleSuppressionMap<Format>>;
    // (undocumented)
    invertedUnitRuleSuppressions?: Array<IRuleSuppressionMap<InvertedUnit>>;
    // (undocumented)
    koqRuleSuppressions?: Array<IRuleSuppressionMap<KindOfQuantity>>;
    // (undocumented)
    mixinRuleSuppressions?: Array<IRuleSuppressionMap<Mixin>>;
    // (undocumented)
    name: string;
    // (undocumented)
    phenomenonRuleSuppressions?: Array<IRuleSuppressionMap<Phenomenon>>;
    // (undocumented)
    propertyCategoryRuleSuppressions?: Array<IRuleSuppressionMap<PropertyCategory>>;
    // (undocumented)
    propertyRuleSuppressions?: Array<IRuleSuppressionMap<AnyProperty>>;
    // (undocumented)
    relationshipConstraintRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipConstraint>>;
    // (undocumented)
    relationshipRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipClass>>;
    // (undocumented)
    schemaItemRuleSuppressions?: Array<IRuleSuppressionMap<SchemaItem>>;
    // (undocumented)
    schemaRuleSuppressions?: Array<IRuleSuppressionMap<Schema>>;
    // (undocumented)
    structRuleSuppressions?: Array<IRuleSuppressionMap<StructClass>>;
    // (undocumented)
    unitRuleSuppressions?: Array<IRuleSuppressionMap<Unit>>;
    // (undocumented)
    unitSystemRuleSuppressions?: Array<IRuleSuppressionMap<UnitSystem>>;
}

// @beta
export type ISuppressionRule<T extends AnyECType, U = {}> = (diagnostic: AnyDiagnostic, ecDefinition: T, ...args: U[]) => Promise<boolean>;

// @beta
export class LoggingDiagnosticReporter extends FormatDiagnosticReporter {
    // (undocumented)
    reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
}

// @beta
export abstract class PropertyDiagnostic<ARGS extends any[]> extends BaseDiagnostic<AnyProperty, ARGS> {
    constructor(property: AnyProperty, messageArgs?: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface PropertyEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
    // (undocumented)
    propertyName?: string;
}

// @beta
export abstract class RelationshipConstraintDiagnostic<ARGS extends any[]> extends BaseDiagnostic<RelationshipConstraint, ARGS> {
    constructor(constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @beta
export const SchemaCompareCodes: {
    SchemaDelta: string;
    SchemaReferenceMissing: string;
    SchemaItemDelta: string;
    SchemaItemMissing: string;
    ClassDelta: string;
    BaseClassDelta: string;
    PropertyDelta: string;
    PropertyMissing: string;
    EntityMixinMissing: string;
    MixinDelta: string;
    RelationshipDelta: string;
    RelationshipConstraintDelta: string;
    RelationshipConstraintClassMissing: string;
    CustomAttributeClassDelta: string;
    CustomAttributeInstanceClassMissing: string;
    EnumerationDelta: string;
    EnumeratorMissing: string;
    EnumeratorDelta: string;
    KoqDelta: string;
    PresentationUnitMissing: string;
    PropertyCategoryDelta: string;
    FormatDelta: string;
    FormatUnitMissing: string;
    UnitLabelOverrideDelta: string;
    UnitDelta: string;
    InvertedUnitDelta: string;
    PhenomenonDelta: string;
    ConstantDelta: string;
    SchemaReferenceDelta: string;
};

// @beta
export const SchemaCompareDiagnostics: {
    SchemaDelta: {
        new (schema: Schema, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceMissing: {
        new (schema: Schema, messageArgs: [Schema], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceDelta: {
        new (schema: Schema, messageArgs: [Schema, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ClassDelta: {
        new (ecClass: AnyClass, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassDelta: {
        new (ecClass: AnyClass, messageArgs: [AnyClass | undefined, AnyClass | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [AnyClass | undefined, AnyClass | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyDelta: {
        new (property: import("@bentley/ecschema-metadata").AnyProperty, messageArgs?: [string, any, any] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@bentley/ecschema-metadata").AnyProperty;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    PropertyMissing: {
        new (property: import("@bentley/ecschema-metadata").AnyProperty, messageArgs?: [] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@bentley/ecschema-metadata").AnyProperty;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    EntityMixinMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Mixin], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [Mixin] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Mixin;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipConstraintDelta: {
        new (constraint: import("@bentley/ecschema-metadata").RelationshipConstraint, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@bentley/ecschema-metadata").RelationshipConstraint;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    RelationshipConstraintClassMissing: {
        new (constraint: import("@bentley/ecschema-metadata").RelationshipConstraint, messageArgs: [AnyClass], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@bentley/ecschema-metadata").RelationshipConstraint;
            messageArgs?: [AnyClass] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeClassDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeInstanceClassMissing: {
        new (container: import("@bentley/ecschema-metadata").CustomAttributeContainerProps, messageArgs: [CustomAttribute], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@bentley/ecschema-metadata").CustomAttributeContainerProps;
            messageArgs?: [CustomAttribute] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    EnumerationDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator, string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator, string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    KoqDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PresentationUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [OverrideFormat | Format], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [OverrideFormat | Format] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyCategoryDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: PropertyCategory;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitLabelOverrideDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit, string | undefined, string | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit, string | undefined, string | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    InvertedUnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PhenomenonDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstantDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Constant;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
};

// @alpha
export class SchemaContextEditor {
    constructor(schemaContext: SchemaContext);
    addCustomAttribute(schemaKey: SchemaKey, customAttribute: CustomAttribute): Promise<SchemaEditResults>;
    addSchemaReference(schemaKey: SchemaKey, refSchema: Schema): Promise<SchemaEditResults>;
    // (undocumented)
    readonly constants: Editors.Constants;
    createSchema(name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number): Promise<SchemaEditResults>;
    // (undocumented)
    readonly customAttributes: Editors.CustomAttributes;
    // (undocumented)
    readonly entities: Editors.Entities;
    // (undocumented)
    readonly enumerations: Editors.Enumerations;
    // (undocumented)
    finish(): Promise<SchemaContext>;
    // (undocumented)
    readonly formats: Editors.Formats;
    incrementMinorVersion(schemaKey: SchemaKey): Promise<SchemaEditResults>;
    // (undocumented)
    readonly invertedUnits: Editors.InvertedUnits;
    // (undocumented)
    readonly kindOfQuantities: Editors.KindOfQuantities;
    // (undocumented)
    readonly mixins: Editors.Mixins;
    // (undocumented)
    readonly phenomenons: Editors.Phenomenons;
    // (undocumented)
    readonly propertyCategories: Editors.PropertyCategories;
    // (undocumented)
    readonly relationships: Editors.RelationshipClasses;
    get schemaContext(): SchemaContext;
    // (undocumented)
    readonly structs: Editors.Structs;
    // (undocumented)
    readonly units: Editors.Units;
    // (undocumented)
    readonly unitSystems: Editors.UnitSystems;
}

// @beta
export abstract class SchemaDiagnostic<ARGS extends any[]> extends BaseDiagnostic<Schema, ARGS> {
    constructor(schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    schemaKey?: SchemaKey;
}

// @beta
export abstract class SchemaItemDiagnostic<TYPE extends SchemaItem, ARGS extends any[]> extends BaseDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaItemEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
}

// @beta
export class SchemaValidater {
    static validateSchema(schema: Schema, validaterRuleSet?: IRuleSet): Promise<AnyDiagnostic[]>;
}

// @beta
export class SchemaValidationVisitor implements ISchemaPartVisitor {
    // (undocumented)
    applyClassRules(ecClass: AnyClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyConstantRules(constant: Constant, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeContainerRules(container: CustomAttributeContainerProps, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeInstanceRules(container: CustomAttributeContainerProps, customAttribute: CustomAttribute, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeRules(customAttribute: CustomAttributeClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEntityRules(entityClass: EntityClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEnumerationRules(enumeration: Enumeration, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyFormatRules(format: Format, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyInvertedUnitRules(invertedUnit: InvertedUnit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyKindOfQuantityRules(kindOfQuantity: KindOfQuantity, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyMixinRules(mixin: Mixin, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPhenomenonRules(phenomenon: Phenomenon, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyCategoryRules(propertyCategory: PropertyCategory, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyRules(property: AnyProperty, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipConstraintRules(constraint: RelationshipConstraint, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipRules(relationship: RelationshipClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaItemRules(schemaItem: SchemaItem, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaRules(schema: Schema, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyStructRules(structClass: StructClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitRules(unit: Unit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitSystemRules(unitSystem: UnitSystem, ruleSet: IRuleSet): Promise<void>;
    get diagnosticReporters(): IDiagnosticReporter[];
    registerReporter(...reporters: IDiagnosticReporter[]): void;
    registerRuleSet(ruleSet: IRuleSet): void;
    registerRuleSuppressionSet(suppressionSet: IRuleSuppressionSet): void;
    get ruleSets(): RuleSetArray;
    // (undocumented)
    get suppressionSet(): IRuleSuppressionSet | undefined;
    visitClass(ecClass: AnyClass): Promise<void>;
    visitConstant(constant: Constant): Promise<void>;
    visitCustomAttributeClass(customAttribute: CustomAttributeClass): Promise<void>;
    visitCustomAttributeContainer(container: CustomAttributeContainerProps): Promise<void>;
    visitEntityClass(entity: EntityClass): Promise<void>;
    visitEnumeration(enumeration: Enumeration): Promise<void>;
    visitFormat(format: Format): Promise<void>;
    visitFullSchema(schema: Schema): Promise<void>;
    visitInvertedUnit(invertedUnit: InvertedUnit): Promise<void>;
    visitKindOfQuantity(koq: KindOfQuantity): Promise<void>;
    visitMixin(mixin: Mixin): Promise<void>;
    visitPhenomenon(phenomenon: Phenomenon): Promise<void>;
    visitProperty(property: AnyProperty): Promise<void>;
    visitPropertyCategory(category: PropertyCategory): Promise<void>;
    visitRelationshipClass(relationship: RelationshipClass): Promise<void>;
    visitRelationshipConstraint(constraint: RelationshipConstraint): Promise<void>;
    visitSchemaItem(schemaItem: SchemaItem): Promise<void>;
    visitStructClass(struct: StructClass): Promise<void>;
    visitUnit(unit: Unit): Promise<void>;
    visitUnitSystem(unitSystem: UnitSystem): Promise<void>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
    }

// @beta
export abstract class SuppressionDiagnosticReporter implements IDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>);
    report(diagnostic: AnyDiagnostic): void;
    protected abstract reportInternal(diagnostic: AnyDiagnostic): void;
    get suppressions(): Map<string, string[]> | undefined;
    }


// (No @packageDocumentation comment for this package)

```
