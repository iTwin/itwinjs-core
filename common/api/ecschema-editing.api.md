## API Report File for "@itwin/ecschema-editing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnyClass } from '@itwin/ecschema-metadata';
import { AnyECType } from '@itwin/ecschema-metadata';
import { AnyEnumerator } from '@itwin/ecschema-metadata';
import { AnyProperty } from '@itwin/ecschema-metadata';
import { AnyPropertyProps } from '@itwin/ecschema-metadata';
import { ArrayProperty } from '@itwin/ecschema-metadata';
import { Constant } from '@itwin/ecschema-metadata';
import { ConstantProps } from '@itwin/ecschema-metadata';
import { CustomAttribute } from '@itwin/ecschema-metadata';
import { CustomAttributeClass } from '@itwin/ecschema-metadata';
import { CustomAttributeClassProps } from '@itwin/ecschema-metadata';
import { CustomAttributeContainerProps } from '@itwin/ecschema-metadata';
import { CustomAttributeContainerType } from '@itwin/ecschema-metadata';
import { ECClass } from '@itwin/ecschema-metadata';
import { ECClassModifier } from '@itwin/ecschema-metadata';
import { ECName } from '@itwin/ecschema-metadata';
import { EntityClass } from '@itwin/ecschema-metadata';
import { EntityClassProps } from '@itwin/ecschema-metadata';
import { Enumeration } from '@itwin/ecschema-metadata';
import { EnumerationPropertyProps } from '@itwin/ecschema-metadata';
import { EnumerationProps } from '@itwin/ecschema-metadata';
import { Format } from '@itwin/ecschema-metadata';
import { FormatType } from '@itwin/core-quantity';
import { InvertedUnit } from '@itwin/ecschema-metadata';
import { InvertedUnitProps } from '@itwin/ecschema-metadata';
import { ISchemaPartVisitor } from '@itwin/ecschema-metadata';
import { KindOfQuantity } from '@itwin/ecschema-metadata';
import { KindOfQuantityProps } from '@itwin/ecschema-metadata';
import { LazyLoadedKindOfQuantity } from '@itwin/ecschema-metadata';
import { LazyLoadedPropertyCategory } from '@itwin/ecschema-metadata';
import { Localization } from '@itwin/core-common';
import { Mixin } from '@itwin/ecschema-metadata';
import { MixinProps } from '@itwin/ecschema-metadata';
import { NavigationProperty } from '@itwin/ecschema-metadata';
import { NavigationPropertyProps } from '@itwin/ecschema-metadata';
import { OverrideFormat } from '@itwin/ecschema-metadata';
import { Phenomenon } from '@itwin/ecschema-metadata';
import { PhenomenonProps } from '@itwin/ecschema-metadata';
import { PrimitiveArrayPropertyProps } from '@itwin/ecschema-metadata';
import { PrimitiveOrEnumPropertyBase } from '@itwin/ecschema-metadata';
import { PrimitivePropertyProps } from '@itwin/ecschema-metadata';
import { PrimitiveType } from '@itwin/ecschema-metadata';
import { Property } from '@itwin/ecschema-metadata';
import { PropertyCategory } from '@itwin/ecschema-metadata';
import { PropertyCategoryProps } from '@itwin/ecschema-metadata';
import { RelationshipClass } from '@itwin/ecschema-metadata';
import { RelationshipClassProps } from '@itwin/ecschema-metadata';
import { RelationshipConstraint } from '@itwin/ecschema-metadata';
import { RelationshipConstraintProps } from '@itwin/ecschema-metadata';
import { RelationshipEnd } from '@itwin/ecschema-metadata';
import { RelationshipMultiplicity } from '@itwin/ecschema-metadata';
import { Schema } from '@itwin/ecschema-metadata';
import { SchemaContext } from '@itwin/ecschema-metadata';
import { SchemaItem } from '@itwin/ecschema-metadata';
import { SchemaItemFormatProps } from '@itwin/ecschema-metadata';
import { SchemaItemKey } from '@itwin/ecschema-metadata';
import { SchemaItemProps } from '@itwin/ecschema-metadata';
import { SchemaItemType } from '@itwin/ecschema-metadata';
import { SchemaItemUnitProps } from '@itwin/ecschema-metadata';
import { SchemaKey } from '@itwin/ecschema-metadata';
import { SchemaReferenceProps } from '@itwin/ecschema-metadata';
import { StrengthDirection } from '@itwin/ecschema-metadata';
import { StrengthType } from '@itwin/ecschema-metadata';
import { StructArrayPropertyProps } from '@itwin/ecschema-metadata';
import { StructClass } from '@itwin/ecschema-metadata';
import { StructClassProps } from '@itwin/ecschema-metadata';
import { StructProperty } from '@itwin/ecschema-metadata';
import { StructPropertyProps } from '@itwin/ecschema-metadata';
import { Unit } from '@itwin/ecschema-metadata';
import { UnitSystem } from '@itwin/ecschema-metadata';
import { UnitSystemProps } from '@itwin/ecschema-metadata';

// @beta
export type AnyDiagnostic = IDiagnostic<AnyECType, any[]>;

// @alpha
export type AnyEditingError = SchemaEditingError | Error;

// @alpha
export type AnyIdentifier = ISchemaIdentifier | ISchemaItemIdentifier | IClassIdentifier | IPropertyIdentifier | ICustomAttributeIdentifier | IRelationshipConstraintIdentifier | IEnumeratorIdentifier;

// @alpha
export type AnySchemaDifference = SchemaDifference | SchemaReferenceDifference | AnySchemaItemDifference | AnySchemaItemPathDifference | CustomAttributeDifference;

// @alpha
export type AnySchemaEdits = SkipEdit | RenameSchemaItemEdit | RenamePropertyEdit;

// @alpha
export type AnySchemaItemDifference = ClassItemDifference | ConstantDifference | EnumerationDifference | EntityClassMixinDifference | FormatDifference | KindOfQuantityDifference | InvertedUnitDifference | PhenomenonDifference | PropertyCategoryDifference | UnitDifference | UnitSystemDifference;

// @alpha
export type AnySchemaItemPathDifference = RelationshipConstraintDifference | RelationshipConstraintClassDifference | CustomAttributePropertyDifference | EnumeratorDifference | ClassPropertyDifference;

// @alpha
export type AnySchemaItemTypeIdentifier = SchemaTypeIdentifiers.SchemaItemIdentifier | SchemaTypeIdentifiers.ClassIdentifier;

// @alpha
export class BaseClassDelta extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @beta
export abstract class BaseDiagnostic<TYPE extends AnyECType, ARGS extends any[]> implements IDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: TYPE, messageArgs?: ARGS, category?: DiagnosticCategory);
    category: DiagnosticCategory;
    abstract get code(): string;
    abstract get diagnosticType(): DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    abstract get messageText(): string;
    abstract get schema(): Schema;
}

// @beta (undocumented)
export type BaseRule<T extends AnyECType, U extends AnyECType> = IRule<T, U>;

// @alpha
export abstract class BaseSchemaChange implements ISchemaChange {
    constructor(diagnostic: AnyDiagnostic);
    get changeType(): ChangeType;
    set changeType(changeType: ChangeType);
    abstract get defaultChangeType(): ChangeType;
    get diagnostic(): AnyDiagnostic;
    protected getNameFromArgument(index: number, allowUndefined?: boolean, fullName?: boolean): string;
    protected getStringFromArgument(index: number): string;
    protected getValueFromArgument(index: number): any;
    abstract get topLevelSchemaItem(): SchemaItem | Schema;
    abstract toString(): string;
}

// @alpha
export abstract class BaseSchemaChanges implements ISchemaChanges {
    constructor(schema: Schema, anyECTypeName: string);
    abstract addChange(change: ISchemaChange): void;
    protected addChangeToMap<V extends ISchemaChanges>(changes: Map<string, V>, changesType: SchemaChangesConstructor, change: ISchemaChange, changeKey: string): void;
    get ecTypeName(): string;
    protected isCAContainerChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string | undefined): boolean;
    protected isPropertyValueChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string): boolean;
    get propertyValueChanges(): PropertyValueChange[];
    get schema(): Schema;
}

// @alpha
export enum ChangeType {
    // (undocumented)
    Delta = 0,
    // (undocumented)
    Missing = 1
}

// @alpha
export class ClassChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get baseClassDelta(): BaseClassDelta | undefined;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get propertyChanges(): Map<string, PropertyChanges>;
}

// @beta
export abstract class ClassDiagnostic<ARGS extends any[]> extends SchemaItemDiagnostic<AnyClass, ARGS> {
    constructor(ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory);
    get schema(): Schema;
}

// @alpha
export class ClassId extends SchemaItemId implements IClassIdentifier {
    constructor(schemaItemType: ECClassSchemaItems, schemaItemKeyOrName: SchemaItemKey | string, schemaKey?: SchemaKey);
    // (undocumented)
    readonly schemaItemType: ECClassSchemaItems;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.ClassIdentifier;
}

// @alpha
export type ClassItemDifference = EntityClassDifference | MixinClassDifference | StructClassDifference | CustomAttributeClassDifference | RelationshipClassDifference;

// @alpha
export interface ClassPropertyDifference {
    // (undocumented)
    readonly changeType: "add" | "modify";
    // (undocumented)
    readonly difference: PartialEditable<AnyPropertyProps>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.Property;
}

// @alpha
export enum ConflictCode {
    // (undocumented)
    AbstractConstraintMustNarrowBaseConstraints = "C-1500",
    // (undocumented)
    ConflictingBaseClass = "C-100",
    // (undocumented)
    ConflictingEnumerationType = "C-700",
    // (undocumented)
    ConflictingEnumeratorValue = "C-701",
    // (undocumented)
    ConflictingItemName = "C-001",
    // (undocumented)
    ConflictingPersistenceUnit = "C-1010",
    // (undocumented)
    ConflictingPropertyName = "C-1300",
    // (undocumented)
    ConflictingReferenceAlias = "C-002",
    // (undocumented)
    ConstraintClassesDeriveFromAbstractConstraint = "C-1502",
    // (undocumented)
    DerivedConstraintsMustNarrowBaseConstraints = "C-1501",
    // (undocumented)
    MixinAppliedMustDeriveFromConstraint = "C-1100",
    // (undocumented)
    RemovingBaseClass = "C-101",
    // (undocumented)
    SealedBaseClass = "C-102"
}

// @alpha
export interface ConstantDifference extends SchemaItemDifference<ConstantProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Constant;
}

// @beta
export function createClassDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyClass;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createCustomAttributeContainerDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: CustomAttributeContainerProps;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createPropertyDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (property: AnyProperty, messageArgs?: ARGS | undefined, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyProperty;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
};

// @beta
export function createRelationshipConstraintDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: RelationshipConstraint;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createSchemaDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: Schema;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
    diagnosticType: DiagnosticType;
};

// @beta
export function createSchemaItemDiagnosticClass<ITEM extends SchemaItem, ARGS extends any[]>(code: string, messageText: string): {
    new (ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: ITEM;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @alpha
export interface CustomAttributeClassDifference extends SchemaItemDifference<CustomAttributeClassProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.CustomAttributeClass;
}

// @alpha
export class CustomAttributeContainerChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class CustomAttributeContainerChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): CustomAttributeContainerChange[];
}

// @beta
export abstract class CustomAttributeContainerDiagnostic<ARGS extends any[]> extends BaseDiagnostic<CustomAttributeContainerProps, ARGS> {
    constructor(container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export type CustomAttributeDifference = CustomAttributeSchemaDifference | CustomAttributeSchemaItemDifference | CustomAttributePropertyDifference | CustomAttributeRelationshipConstraintDifference;

// @alpha
export class CustomAttributeId implements ICustomAttributeIdentifier {
    constructor(name: string, container: CustomAttributeContainerProps);
    // (undocumented)
    readonly containerFullName: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.CustomAttributeIdentifier;
}

// @alpha
export interface CustomAttributePropertyDifference {
    // (undocumented)
    readonly appliedTo: "Property";
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: PartialEditable<CustomAttribute>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.CustomAttributeInstance;
}

// @alpha
export interface CustomAttributeRelationshipConstraintDifference {
    // (undocumented)
    readonly appliedTo: "RelationshipConstraint";
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: PartialEditable<CustomAttribute>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: "$source" | "$target";
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.CustomAttributeInstance;
}

// @alpha
export interface CustomAttributeSchemaDifference {
    // (undocumented)
    readonly appliedTo: "Schema";
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: PartialEditable<CustomAttribute>;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.CustomAttributeInstance;
}

// @alpha
export interface CustomAttributeSchemaItemDifference {
    // (undocumented)
    readonly appliedTo: "SchemaItem";
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: PartialEditable<CustomAttribute>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.CustomAttributeInstance;
}

// @beta
export enum DiagnosticCategory {
    // (undocumented)
    Error = 1,
    // (undocumented)
    Message = 3,
    // (undocumented)
    Suggestion = 2,
    // (undocumented)
    Warning = 0
}

// @beta (undocumented)
export function diagnosticCategoryToString(category: DiagnosticCategory): "Error" | "Warning" | "Message" | "Suggestion";

// @beta
export const DiagnosticCodes: {
    BaseClassIsSealed: string;
    BaseClassOfDifferentType: string;
    AbstractClassWithNonAbstractBase: string;
    CustomAttributeNotOfConcreteClass: string;
    CustomAttributeSchemaMustBeReferenced: string;
    CustomAttributeClassNotFound: string;
    EnumerationTypeUnsupported: string;
    MixinAppliedToClassMustDeriveFromConstraint: string;
    IncompatibleValueTypePropertyOverride: string;
    IncompatibleTypePropertyOverride: string;
    IncompatibleUnitPropertyOverride: string;
    AbstractConstraintMustNarrowBaseConstraints: string;
    DerivedConstraintsMustNarrowBaseConstraints: string;
    ConstraintClassesDeriveFromAbstractConstraint: string;
    AtLeastOneConstraintClassDefined: string;
    AbstractConstraintMustExistWithMultipleConstraints: string;
};

// @beta
export const Diagnostics: {
    SupplementalSchemasCannotBeReferenced: {
        new (schema: Schema, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    SchemaRefAliasMustBeUnique: {
        new (schema: Schema, messageArgs: [string, string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    ReferenceCyclesNotAllowed: {
        new (schema: Schema, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    BaseClassIsSealed: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    BaseClassIsOfDifferentType: {
        new (ecClass: AnyClass, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    AbstractClassWithNonAbstractBase: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    CustomAttributeNotOfConcreteClass: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
    };
    CustomAttributeSchemaMustBeReferenced: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
    };
    CustomAttributeClassNotFound: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
    };
    EnumerationTypeUnsupported: {
        new (ecDefinition: SchemaItem, messageArgs: [string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    MixinAppliedToClassMustDeriveFromConstraint: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    IncompatibleValueTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleUnitPropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string, string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipMustBeRoot: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    NavigationTargetMustHaveSingularMultiplicity: {
        new (property: AnyProperty, messageArgs?: [string, string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipAbstractConstraintEntityOrMixin: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    NavigationClassMustBeAConstraintClassOfRelationship: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    AbstractConstraintMustNarrowBaseConstraints: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    DerivedConstraintsMustNarrowBaseConstraints: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    ConstraintClassesDeriveFromAbstractConstraint: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    AtLeastOneConstraintClassDefined: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
    };
    AbstractConstraintMustExistWithMultipleConstraints: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: DiagnosticCategory;
        };
    };
};

// @beta
export enum DiagnosticType {
    // (undocumented)
    CustomAttributeContainer = 4,
    // (undocumented)
    None = 0,// eslint-disable-line @typescript-eslint/no-shadow
    // (undocumented)
    Property = 3,// eslint-disable-line @typescript-eslint/no-shadow
    // (undocumented)
    RelationshipConstraint = 5,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SchemaItem = 2
}

// @beta (undocumented)
export function diagnosticTypeToString(type: DiagnosticType): "CustomAttributeContainer" | "None" | "Property" | "RelationshipConstraint" | "Schema" | "SchemaItem";

// @alpha
export type DifferenceType = "add" | "modify";

// @alpha
export type ECClassSchemaItems = SchemaItemType.EntityClass | SchemaItemType.StructClass | SchemaItemType.RelationshipClass | SchemaItemType.Mixin | SchemaItemType.CustomAttributeClass;

// @alpha (undocumented)
export enum ECEditingStatus {
    // (undocumented)
    AddConstraintClass = 196637,
    // (undocumented)
    AddCustomAttributeToClass = 196642,
    // (undocumented)
    AddCustomAttributeToConstraint = 196640,
    // (undocumented)
    AddCustomAttributeToProperty = 196641,
    // (undocumented)
    AddEnumerator = 196660,
    // (undocumented)
    AddMixin = 196659,
    // (undocumented)
    AddPresentationOverride = 196664,
    // (undocumented)
    AddPresentationUnit = 196663,
    // (undocumented)
    AddSchemaReference = 196682,
    // (undocumented)
    BaseClassIsNotElement = 196616,
    // (undocumented)
    BaseClassIsNotElementMultiAspect = 196618,
    // (undocumented)
    BaseClassIsNotElementUniqueAspect = 196617,
    // (undocumented)
    CreateElement = 196631,
    // (undocumented)
    CreateElementMultiAspect = 196633,
    // (undocumented)
    CreateElementUniqueAspect = 196632,
    // (undocumented)
    CreateEnumerationArrayProperty = 196673,
    // (undocumented)
    CreateEnumerationArrayPropertyFromProps = 196674,
    // (undocumented)
    CreateEnumerationProperty = 196669,
    // (undocumented)
    CreateEnumerationPropertyFromProps = 196670,
    // (undocumented)
    CreateFormatOverride = 196665,
    // (undocumented)
    CreateNavigationProperty = 196643,
    // (undocumented)
    CreateNavigationPropertyFromProps = 196644,
    // (undocumented)
    CreatePrimitiveArrayProperty = 196671,
    // (undocumented)
    CreatePrimitiveArrayPropertyFromProps = 196672,
    // (undocumented)
    CreatePrimitiveProperty = 196667,
    // (undocumented)
    CreatePrimitivePropertyFromProps = 196668,
    // (undocumented)
    CreateSchemaItemFailed = 196629,
    // (undocumented)
    CreateSchemaItemFromProps = 196630,
    // (undocumented)
    CreateStructArrayProperty = 196677,
    // (undocumented)
    CreateStructArrayPropertyFromProps = 196678,
    // (undocumented)
    CreateStructProperty = 196675,
    // (undocumented)
    CreateStructPropertyFromProps = 196676,
    // (undocumented)
    DeleteClass = 196680,
    // (undocumented)
    DeleteProperty = 196679,
    // (undocumented)
    EC_EDITING_ERROR_BASE = 196608,
    // (undocumented)
    EnumeratorDoesNotExist = 196624,
    // (undocumented)
    IncrementSchemaMinorVersion = 196684,
    // (undocumented)
    InvalidBaseClass = 196623,
    // (undocumented)
    InvalidECName = 196625,
    // (undocumented)
    InvalidEnumeratorType = 196622,
    // (undocumented)
    InvalidFormatUnitsSpecified = 196627,
    // (undocumented)
    InvalidPropertyType = 196615,
    // (undocumented)
    InvalidSchemaAlias = 196626,
    // (undocumented)
    InvalidSchemaItemType = 196620,
    // (undocumented)
    PropertyAlreadyExists = 196613,
    // (undocumented)
    PropertyNotFound = 196614,
    // (undocumented)
    RemoveConstraintClass = 196638,
    // (undocumented)
    RuleViolation = 196609,
    // (undocumented)
    SchemaAliasAlreadyExists = 196628,
    // (undocumented)
    SchemaItemNameAlreadyExists = 196621,
    // (undocumented)
    SchemaItemNameNotSpecified = 196619,
    // (undocumented)
    SchemaItemNotFound = 196611,
    // (undocumented)
    SchemaItemNotFoundInContext = 196612,
    // (undocumented)
    SchemaNotFound = 196610,
    // (undocumented)
    SetAbstractConstraint = 196639,
    // (undocumented)
    SetBaseClass = 196634,
    // (undocumented)
    SetCategory = 196651,
    // (undocumented)
    SetClassName = 196681,
    // (undocumented)
    SetDescription = 196647,
    // (undocumented)
    SetEnumeratorDescription = 196662,
    // (undocumented)
    SetEnumeratorLabel = 196661,
    // (undocumented)
    SetExtendedTypeName = 196653,
    // (undocumented)
    SetInvertsUnit = 196645,
    // (undocumented)
    SetIsReadOnly = 196649,
    // (undocumented)
    SetKindOfQuantity = 196650,
    // (undocumented)
    SetLabel = 196646,
    // (undocumented)
    SetMaxLength = 196655,
    // (undocumented)
    SetMaxOccurs = 196652,
    // (undocumented)
    SetMaxValue = 196657,
    // (undocumented)
    SetMinLength = 196654,
    // (undocumented)
    SetMinOccurs = 196651,
    // (undocumented)
    SetMinValue = 196656,
    // (undocumented)
    SetPriority = 196650,
    // (undocumented)
    SetPropertyCategoryPriority = 196666,
    // (undocumented)
    SetPropertyName = 196658,
    // (undocumented)
    SetSchemaVersion = 196683,
    // (undocumented)
    SetSchemaVersion = 196684,
    // (undocumented)
    SetSourceConstraint = 196635,
    // (undocumented)
    SetTargetConstraint = 196636,
    // (undocumented)
    SetUnitSystem = 196646,
    // (undocumented)
    Unknown = 0
}

// @beta
export const ECRuleSet: IRuleSet;

// @alpha
export class EntityClassChanges extends ClassChanges {
    addChange(change: ISchemaChange): void;
    get entityMixinChanges(): Map<string, EntityMixinChanges>;
}

// @alpha
export interface EntityClassDifference extends SchemaItemDifference<EntityClassProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.EntityClass;
}

// @alpha
export interface EntityClassMixinDifference {
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: string[];
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.EntityClassMixin;
}

// @alpha
export class EntityMixinChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class EntityMixinChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get entityMixinChange(): EntityMixinChange[];
}

// @alpha
export class EnumerationChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorChanges(): Map<string, EnumeratorChanges>;
}

// @alpha
export interface EnumerationDifference extends SchemaItemDifference<EnumerationProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Enumeration;
}

// @alpha
export class EnumeratorChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorDeltas(): EnumeratorDelta[];
    get enumeratorMissing(): EnumeratorMissing | undefined;
}

// @alpha
export class EnumeratorDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export interface EnumeratorDifference {
    // (undocumented)
    readonly changeType: "add" | "modify";
    // (undocumented)
    readonly difference: PartialEditable<AnyEnumerator>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.Enumerator;
}

// @alpha
export class EnumeratorId implements IEnumeratorIdentifier {
    constructor(enumerator: AnyEnumerator | string, enumeration: Enumeration);
    // (undocumented)
    readonly enumeration: SchemaItemKey;
    // (undocumented)
    readonly enumerationType: string;
    // (undocumented)
    readonly enumeratorType: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.EnumeratorIdentifier;
}

// @alpha
export class EnumeratorMissing extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class FormatChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): Map<string, FormatUnitChanges>;
}

// @beta
export abstract class FormatDiagnosticReporter extends SuppressionDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>, localization?: Localization);
    protected formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string;
    localization?: Localization;
    protected abstract reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
    reportInternal(diagnostic: AnyDiagnostic): void;
}

// @alpha
export interface FormatDifference extends SchemaItemDifference<SchemaItemFormatProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Format;
}

// @alpha
export class FormatUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class FormatUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): FormatUnitChange[];
    get unitLabelOverrideDeltas(): UnitLabelOverrideDelta[];
}

// @alpha
export function getSchemaDifferences(targetSchema: Schema, sourceSchema: Schema): Promise<SchemaDifferenceResult>;

// @alpha
export interface IClassIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly schemaItemKey: SchemaItemKey;
    // (undocumented)
    readonly schemaItemType: ECClassSchemaItems;
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers.ClassIdentifier;
}

// @alpha
export interface ICustomAttributeIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly containerFullName: string;
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers.CustomAttributeIdentifier;
}

// @beta
export interface IDiagnostic<TYPE extends AnyECType, ARGS extends any[]> {
    category: DiagnosticCategory;
    code: string;
    diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    messageText: string;
    schema: Schema;
}

// @beta
export interface IDiagnosticReporter {
    localization?: Localization;
    report(diagnostic: AnyDiagnostic): void;
    suppressions?: Map<string, string[]>;
}

// @alpha
export interface InvertedUnitDifference extends SchemaItemDifference<InvertedUnitProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.InvertedUnit;
}

// @alpha
export interface IPropertyIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly ecClass: ClassId;
    // (undocumented)
    readonly fullName: string;
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers.PropertyIdentifier;
    // (undocumented)
    readonly typeName?: PropertyTypeName;
}

// @alpha
export interface IRelationshipConstraintIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly relationshipKey: SchemaItemKey;
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers.RelationshipConstraintIdentifier;
}

// @beta
export type IRule<T extends AnyECType, U = {}> = (ecDefinition: T, ...args: U[]) => AsyncIterable<BaseDiagnostic<T, any[]>>;

// @beta
export interface IRuleSet {
    classRules?: Array<IRule<AnyClass>>;
    constantRules?: Array<IRule<Constant>>;
    customAttributeClassRules?: Array<IRule<CustomAttributeClass>>;
    customAttributeContainerRules?: Array<IRule<CustomAttributeContainerProps>>;
    customAttributeInstanceRules?: Array<BaseRule<CustomAttributeContainerProps, CustomAttribute>>;
    entityClassRules?: Array<IRule<EntityClass>>;
    enumerationRules?: Array<IRule<Enumeration>>;
    formatRules?: Array<IRule<Format>>;
    invertedUnitRules?: Array<IRule<InvertedUnit>>;
    kindOfQuantityRules?: Array<IRule<KindOfQuantity>>;
    mixinRules?: Array<IRule<Mixin>>;
    name: string;
    phenomenonRules?: Array<IRule<Phenomenon>>;
    propertyCategoryRules?: Array<IRule<PropertyCategory>>;
    propertyRules?: Array<IRule<AnyProperty>>;
    relationshipConstraintRules?: Array<IRule<RelationshipConstraint>>;
    relationshipRules?: Array<IRule<RelationshipClass>>;
    schemaExclusionSet?: string[];
    schemaItemRules?: Array<IRule<SchemaItem>>;
    schemaRules?: Array<IRule<Schema>>;
    structClassRules?: Array<IRule<StructClass>>;
    unitRules?: Array<IRule<Unit>>;
    unitSystemRules?: Array<IRule<UnitSystem>>;
}

// @beta
export interface IRuleSuppressionMap<T extends AnyECType, U = {}> {
    // (undocumented)
    rule: ISuppressionRule<T, U>;
    // (undocumented)
    ruleCode: string;
}

// @beta
export interface IRuleSuppressionSet {
    // (undocumented)
    classRuleSuppressions?: Array<IRuleSuppressionMap<AnyClass>>;
    // (undocumented)
    constantRuleSuppressions?: Array<IRuleSuppressionMap<Constant>>;
    // (undocumented)
    customAttributeContainerSuppressions?: Array<IRuleSuppressionMap<CustomAttributeContainerProps>>;
    // (undocumented)
    customAttributeInstanceSuppressions?: Array<BaseRuleSuppressionMap<CustomAttributeContainerProps, CustomAttribute>>;
    // (undocumented)
    customAttributeRuleSuppressions?: Array<IRuleSuppressionMap<CustomAttributeClass>>;
    // (undocumented)
    entityRuleSuppressions?: Array<IRuleSuppressionMap<EntityClass>>;
    // (undocumented)
    enumerationRuleSuppressions?: Array<IRuleSuppressionMap<Enumeration>>;
    // (undocumented)
    formatRuleSuppressions?: Array<IRuleSuppressionMap<Format>>;
    // (undocumented)
    invertedUnitRuleSuppressions?: Array<IRuleSuppressionMap<InvertedUnit>>;
    // (undocumented)
    koqRuleSuppressions?: Array<IRuleSuppressionMap<KindOfQuantity>>;
    // (undocumented)
    mixinRuleSuppressions?: Array<IRuleSuppressionMap<Mixin>>;
    // (undocumented)
    name: string;
    // (undocumented)
    phenomenonRuleSuppressions?: Array<IRuleSuppressionMap<Phenomenon>>;
    // (undocumented)
    propertyCategoryRuleSuppressions?: Array<IRuleSuppressionMap<PropertyCategory>>;
    // (undocumented)
    propertyRuleSuppressions?: Array<IRuleSuppressionMap<AnyProperty>>;
    // (undocumented)
    relationshipConstraintRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipConstraint>>;
    // (undocumented)
    relationshipRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipClass>>;
    // (undocumented)
    schemaItemRuleSuppressions?: Array<IRuleSuppressionMap<SchemaItem>>;
    // (undocumented)
    schemaRuleSuppressions?: Array<IRuleSuppressionMap<Schema>>;
    // (undocumented)
    structRuleSuppressions?: Array<IRuleSuppressionMap<StructClass>>;
    // (undocumented)
    unitRuleSuppressions?: Array<IRuleSuppressionMap<Unit>>;
    // (undocumented)
    unitSystemRuleSuppressions?: Array<IRuleSuppressionMap<UnitSystem>>;
}

// @alpha
export interface ISchemaChange {
    changeType: ChangeType;
    diagnostic: AnyDiagnostic;
    topLevelSchemaItem: SchemaItem | Schema;
    toString(): string;
}

// @alpha
export interface ISchemaChanges {
    // (undocumented)
    addChange(change: ISchemaChange): void;
    // (undocumented)
    ecTypeName: string;
    // (undocumented)
    schema: Schema;
}

// @alpha
export interface ISchemaComparer {
    // (undocumented)
    compareClasses(classA: AnyClass, classB: AnyClass): void;
    // (undocumented)
    compareConstants(constantA: Constant, constantB: Constant): void;
    // (undocumented)
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass): void;
    // (undocumented)
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps): void;
    // (undocumented)
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass): void;
    // (undocumented)
    compareEnumerations(enumA: Enumeration, enumB: Enumeration): void;
    // (undocumented)
    compareFormats(formatA: Format, formatB: Format): void;
    // (undocumented)
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit): void;
    // (undocumented)
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity): void;
    // (undocumented)
    compareMixins(mixinA: Mixin, mixinB: Mixin): void;
    // (undocumented)
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon): void;
    // (undocumented)
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): void;
    // (undocumented)
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory): void;
    // (undocumented)
    compareRelationshipClasses(relationshipClassA: RelationshipClass, relationshipClassB: RelationshipClass): void;
    // (undocumented)
    compareRelationshipConstraints(relationshipConstraintA: RelationshipConstraint, relationshipConstraintB: RelationshipConstraint): void;
    // (undocumented)
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): void;
    // (undocumented)
    compareSchemaProps(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareSchemas(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareUnits(unitA: Unit, unitB: Unit): void;
}

// @alpha
export interface ISchemaCompareReporter {
    // (undocumented)
    report(schemaChanges: ISchemaChanges): void;
}

// @alpha
export interface ISchemaIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers.SchemaIdentifier;
}

// @alpha
export interface ISchemaItemIdentifier extends ISchemaTypeIdentifier {
    // (undocumented)
    readonly schemaItemKey: SchemaItemKey;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // (undocumented)
    readonly typeIdentifier: AnySchemaItemTypeIdentifier;
}

// @alpha
export interface ISchemaTypeIdentifier {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier: SchemaTypeIdentifiers;
}

// @alpha
export function isClassDifference(difference: AnySchemaDifference): difference is ClassItemDifference;

// @alpha
export function isClassPropertyDifference(difference: AnySchemaDifference): difference is ClassPropertyDifference;

// @alpha
export function isConstantDifference(difference: AnySchemaDifference): difference is ConstantDifference;

// @alpha
export function isCustomAttributeClassDifference(difference: AnySchemaDifference): difference is CustomAttributeClassDifference;

// @alpha
export function isCustomAttributeDifference(difference: AnySchemaDifference): difference is CustomAttributeDifference;

// @alpha
export function isEntityClassDifference(difference: AnySchemaDifference): difference is EntityClassDifference;

// @alpha
export function isEntityClassMixinDifference(difference: AnySchemaDifference): difference is EntityClassMixinDifference;

// @alpha
export function isEnumerationDifference(difference: AnySchemaDifference): difference is EnumerationDifference;

// @alpha
export function isEnumeratorDifference(difference: AnySchemaDifference): difference is EnumeratorDifference;

// @alpha
export function isKindOfQuantityDifference(difference: AnySchemaDifference): difference is KindOfQuantityDifference;

// @alpha
export function isMixinClassDifference(difference: AnySchemaDifference): difference is MixinClassDifference;

// @alpha
export function isPhenomenonDifference(difference: AnySchemaDifference): difference is PhenomenonDifference;

// @alpha
export function isPropertyCategoryDifference(difference: AnySchemaDifference): difference is PropertyCategoryDifference;

// @alpha
export function isRelationshipClassDifference(difference: AnySchemaDifference): difference is RelationshipClassDifference;

// @alpha
export function isRelationshipConstraintClassDifference(difference: AnySchemaDifference): difference is RelationshipConstraintClassDifference;

// @alpha
export function isRelationshipConstraintDifference(difference: AnySchemaDifference): difference is RelationshipConstraintDifference;

// @alpha
export function isSchemaDifference(difference: AnySchemaDifference): difference is SchemaDifference;

// @alpha
export function isSchemaItemDifference(difference: AnySchemaDifference): difference is AnySchemaItemDifference;

// @alpha
export function isSchemaReferenceDifference(difference: AnySchemaDifference): difference is SchemaReferenceDifference;

// @alpha
export function isStructClassDifference(difference: AnySchemaDifference): difference is StructClassDifference;

// @alpha
export function isUnitSystemDifference(difference: AnySchemaDifference): difference is UnitSystemDifference;

// @beta
export type ISuppressionRule<T extends AnyECType, U = {}> = (diagnostic: AnyDiagnostic, ecDefinition: T, ...args: U[]) => Promise<boolean>;

// @alpha
export class KindOfQuantityChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChanges(): Map<string, PresentationUnitChanges>;
}

// @alpha
export interface KindOfQuantityDifference extends SchemaItemDifference<KindOfQuantityProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.KindOfQuantity;
}

// @beta
export class LoggingDiagnosticReporter extends FormatDiagnosticReporter {
    // (undocumented)
    reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
}

// @alpha
export interface MixinClassDifference extends SchemaItemDifference<MixinProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Mixin;
}

// @alpha
export interface PhenomenonDifference extends SchemaItemDifference<PhenomenonProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Phenomenon;
}

// @alpha
export class PresentationUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class PresentationUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChange(): PresentationUnitChange[];
}

// @alpha
export interface PropertyCategoryDifference extends SchemaItemDifference<PropertyCategoryProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.PropertyCategory;
}

// @alpha
export class PropertyChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get propertyMissing(): PropertyMissing | undefined;
}

// @beta
export abstract class PropertyDiagnostic<ARGS extends any[]> extends BaseDiagnostic<AnyProperty, ARGS> {
    constructor(property: AnyProperty, messageArgs?: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export class PropertyId implements IPropertyIdentifier {
    constructor(schemaItemType: ECClassSchemaItems, classKey: SchemaItemKey, property: Property | string, typeName?: PropertyTypeName);
    // (undocumented)
    readonly ecClass: ClassId;
    // (undocumented)
    readonly fullName: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.PropertyIdentifier;
    // (undocumented)
    readonly typeName?: PropertyTypeName;
}

// @alpha
export class PropertyMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export enum PropertyTypeName {
    // (undocumented)
    ArrayProperty = "ArrayProperty",
    // (undocumented)
    EnumerationProperty = "EnumerationProperty",
    // (undocumented)
    NavigationProperty = "NavigationProperty",
    // (undocumented)
    PrimitiveProperty = "PrimitiveProperty",
    // (undocumented)
    StructProperty = "StructProperty"
}

// @alpha
export class PropertyValueChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class RelationshipClassChanges extends ClassChanges {
    addChange(change: ISchemaChange): void;
    get sourceConstraintChanges(): Map<string, RelationshipConstraintChanges>;
    get targetConstraintChanges(): Map<string, RelationshipConstraintChanges>;
}

// @alpha
export interface RelationshipClassDifference extends SchemaItemDifference<RelationshipClassProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.RelationshipClass;
}

// @alpha
export class RelationshipConstraintChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get constraintClassChanges(): RelationshipConstraintClassChange[];
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
}

// @alpha
export class RelationshipConstraintClassChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export interface RelationshipConstraintClassDifference {
    // (undocumented)
    readonly changeType: "add";
    // (undocumented)
    readonly difference: string[];
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: "$source" | "$target";
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.RelationshipConstraintClass;
}

// @beta
export abstract class RelationshipConstraintDiagnostic<ARGS extends any[]> extends BaseDiagnostic<RelationshipConstraint, ARGS> {
    constructor(constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export interface RelationshipConstraintDifference {
    // (undocumented)
    readonly changeType: "modify";
    // (undocumented)
    readonly difference: PartialEditable<Omit<RelationshipConstraintProps, "constraintClasses">>;
    // (undocumented)
    readonly itemName: string;
    // (undocumented)
    readonly path: "$source" | "$target";
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.RelationshipConstraint;
}

// @alpha
export class RelationshipConstraintId implements IRelationshipConstraintIdentifier {
    constructor(constraint: RelationshipConstraint);
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly relationshipKey: SchemaItemKey;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.RelationshipConstraintIdentifier;
}

// @alpha
export interface RenamePropertyEdit {
    // (undocumented)
    key: string;
    // (undocumented)
    type: SchemaEditType.RenameProperty;
    // (undocumented)
    value: string;
}

// @alpha
export interface RenameSchemaItemEdit {
    // (undocumented)
    key: string;
    // (undocumented)
    type: SchemaEditType.RenameSchemaItem;
    // (undocumented)
    value: string;
}

// @alpha
export class SchemaChanges extends BaseSchemaChanges {
    constructor(schema: Schema);
    addChange(change: ISchemaChange): void;
    addDiagnostic(diagnostic: AnyDiagnostic): void;
    get allDiagnostics(): AnyDiagnostic[];
    get classChanges(): Map<string, ClassChanges>;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get entityClassChanges(): Map<string, EntityClassChanges>;
    get enumerationChanges(): Map<string, EnumerationChanges>;
    get formatChanges(): Map<string, FormatChanges>;
    get kindOfQuantityChanges(): Map<string, KindOfQuantityChanges>;
    get missingSchemaReferences(): SchemaReferenceMissing[];
    get relationshipClassChanges(): Map<string, RelationshipClassChanges>;
    get schemaItemChanges(): Map<string, SchemaItemChanges>;
    get schemaReferenceDeltas(): SchemaReferenceDelta[];
}

// @beta
export const SchemaCompareCodes: {
    SchemaDelta: string;
    SchemaReferenceMissing: string;
    SchemaItemDelta: string;
    SchemaItemMissing: string;
    ClassDelta: string;
    BaseClassDelta: string;
    PropertyDelta: string;
    PropertyMissing: string;
    EntityMixinMissing: string;
    MixinDelta: string;
    RelationshipDelta: string;
    RelationshipConstraintDelta: string;
    RelationshipConstraintClassMissing: string;
    CustomAttributeClassDelta: string;
    CustomAttributeInstanceClassMissing: string;
    EnumerationDelta: string;
    EnumeratorMissing: string;
    EnumeratorDelta: string;
    KoqDelta: string;
    PresentationUnitMissing: string;
    PropertyCategoryDelta: string;
    FormatDelta: string;
    FormatUnitMissing: string;
    UnitLabelOverrideDelta: string;
    UnitDelta: string;
    InvertedUnitDelta: string;
    PhenomenonDelta: string;
    ConstantDelta: string;
    SchemaReferenceDelta: string;
};

// @beta
export const SchemaCompareDiagnostics: {
    SchemaDelta: {
        new (schema: Schema, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    SchemaReferenceMissing: {
        new (schema: Schema, messageArgs: [Schema], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    SchemaReferenceDelta: {
        new (schema: Schema, messageArgs: [Schema, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema, string, string] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
        diagnosticType: DiagnosticType;
    };
    SchemaItemDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    SchemaItemMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    ClassDelta: {
        new (ecClass: AnyClass, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    BaseClassDelta: {
        new (ecClass: AnyClass, messageArgs: [AnyClass | undefined, AnyClass | undefined], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [AnyClass | undefined, AnyClass | undefined] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    PropertyDelta: {
        new (property: AnyProperty, messageArgs?: [string, any, any] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    PropertyMissing: {
        new (property: AnyProperty, messageArgs?: [] | undefined, category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [] | undefined;
            category: DiagnosticCategory;
        };
        code: string;
    };
    EntityMixinMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Mixin], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [Mixin] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    MixinDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Mixin;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    RelationshipDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    RelationshipConstraintDelta: {
        new (constraint: RelationshipConstraint, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
    };
    RelationshipConstraintClassMissing: {
        new (constraint: RelationshipConstraint, messageArgs: [AnyClass], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [AnyClass] | undefined;
            category: DiagnosticCategory;
        };
    };
    CustomAttributeClassDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: CustomAttributeClass;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    CustomAttributeInstanceClassMissing: {
        new (container: CustomAttributeContainerProps, messageArgs: [CustomAttribute], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [CustomAttribute] | undefined;
            category: DiagnosticCategory;
        };
    };
    EnumerationDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    EnumeratorMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    EnumeratorDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator, string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator, string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    KoqDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    PresentationUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [OverrideFormat | Format], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [OverrideFormat | Format] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    PropertyCategoryDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: PropertyCategory;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    FormatDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, any, any] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    FormatUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    UnitLabelOverrideDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit, string | undefined, string | undefined], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit, string | undefined, string | undefined] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    UnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    InvertedUnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    PhenomenonDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
    ConstantDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: DiagnosticType;
            ecDefinition: Constant;
            messageArgs?: [string, string, string] | undefined;
            category: DiagnosticCategory;
        };
        diagnosticType: DiagnosticType;
    };
};

// @alpha
export enum SchemaCompareDirection {
    // (undocumented)
    Backward = 1,
    // (undocumented)
    Forward = 0
}

// @alpha
export class SchemaComparer {
    constructor(...reporters: ISchemaCompareReporter[]);
    compareClasses(classA: AnyClass, classB: AnyClass): Promise<void>;
    compareConstants(constantA: Constant, constantB: Constant): Promise<void>;
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass): Promise<void>;
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps): Promise<void>;
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass): Promise<void>;
    compareEnumerations(enumA: Enumeration, enumB: Enumeration): Promise<void>;
    compareFormats(formatA: Format, formatB: Format): Promise<void>;
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit): Promise<void>;
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity): Promise<void>;
    compareMixins(mixinA: Mixin, mixinB: Mixin): Promise<void>;
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon): Promise<void>;
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): Promise<void>;
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory): Promise<void>;
    compareRelationshipClasses(relationshipA: RelationshipClass, relationshipB: RelationshipClass): Promise<void>;
    compareRelationshipConstraints(constraintA: RelationshipConstraint, constraintB: RelationshipConstraint): Promise<void>;
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): Promise<void>;
    compareSchemaProps(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareSchemas(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareUnits(unitA: Unit, unitB: Unit): Promise<void>;
}

// @alpha
export class SchemaConflictsError extends Error {
    constructor(message: string, conflicts: SchemaDifferenceConflict[], sourceSchema: SchemaKey, targetSchema: SchemaKey);
    readonly conflicts: ReadonlyArray<SchemaDifferenceConflict>;
    readonly sourceSchema: SchemaKey;
    readonly targetSchema: SchemaKey;
}

// @alpha
export class SchemaContextEditor {
    constructor(schemaContext: SchemaContext);
    addCustomAttribute(schemaKey: SchemaKey, customAttribute: CustomAttribute): Promise<void>;
    addSchemaReference(schemaKey: SchemaKey, refSchema: Schema): Promise<void>;
    // (undocumented)
    readonly constants: Constants;
    createSchema(name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number): Promise<SchemaKey>;
    // (undocumented)
    readonly customAttributes: CustomAttributes;
    // (undocumented)
    readonly entities: Entities;
    // (undocumented)
    readonly enumerations: Enumerations;
    // (undocumented)
    finish(): Promise<SchemaContext>;
    // (undocumented)
    readonly formats: Formats;
    // @internal
    getSchema(schemaKey: SchemaKey): Promise<MutableSchema>;
    // @internal (undocumented)
    getSchemaItem<T extends SchemaItem>(schemaItemKey: SchemaItemKey, schemaItemType: SchemaItemType): Promise<T>;
    incrementMinorVersion(schemaKey: SchemaKey): Promise<SchemaKey>;
    // (undocumented)
    readonly invertedUnits: InvertedUnits;
    // (undocumented)
    readonly kindOfQuantities: KindOfQuantities;
    // @internal (undocumented)
    lookupSchemaItem<T extends SchemaItem>(schemaOrKey: Schema | SchemaKey, schemaItemKey: SchemaItemKey, schemaItemType: SchemaItemType): Promise<T>;
    // (undocumented)
    readonly mixins: Mixins;
    // (undocumented)
    readonly phenomenons: Phenomena;
    // (undocumented)
    readonly propertyCategories: PropertyCategories;
    // (undocumented)
    readonly relationships: RelationshipClasses;
    get schemaContext(): SchemaContext;
    setAlias(schemaKey: SchemaKey, alias: string): Promise<void>;
    setDescription(schemaKey: SchemaKey, description: string): Promise<void>;
    setDisplayLabel(schemaKey: SchemaKey, label: string): Promise<void>;
    setVersion(schemaKey: SchemaKey, readVersion?: number, writeVersion?: number, minorVersion?: number): Promise<SchemaKey>;
    // (undocumented)
    readonly structs: Structs;
    // (undocumented)
    readonly units: Units;
    // (undocumented)
    readonly unitSystems: UnitSystems;
}

// @beta
export abstract class SchemaDiagnostic<ARGS extends any[]> extends BaseDiagnostic<Schema, ARGS> {
    constructor(schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export interface SchemaDifference {
    // (undocumented)
    readonly changeType: "modify";
    // (undocumented)
    readonly difference: {
        label?: string;
        description?: string;
    };
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.Schema;
}

// @alpha
export interface SchemaDifferenceConflict {
    readonly code: ConflictCode;
    readonly description: string;
    readonly difference?: unknown;
    readonly itemName?: string;
    readonly path?: string;
    readonly schemaType: SchemaType;
    readonly source: unknown;
    readonly target: unknown;
}

// @alpha
export interface SchemaDifferenceResult {
    readonly conflicts?: SchemaDifferenceConflict[];
    readonly differences: AnySchemaDifference[];
    readonly sourceSchemaName: string;
    readonly targetSchemaName: string;
}

// @alpha
export class SchemaEditingError extends Error {
    constructor(errorNumber: ECEditingStatus, identifier: AnyIdentifier, innerError?: AnyEditingError | undefined, ruleViolations?: AnyDiagnostic[], message?: string);
    // (undocumented)
    readonly errorNumber: ECEditingStatus;
    // (undocumented)
    readonly identifier: AnyIdentifier;
    // (undocumented)
    readonly innerError?: AnyEditingError | undefined;
    get ruleViolations(): AnyDiagnostic[] | undefined;
    toDebugString(): string;
}

// @alpha
export class SchemaEdits {
    constructor(initialize?: ReadonlyArray<AnySchemaEdits>);
    // @internal (undocumented)
    applyTo(differenceResult: SchemaDifferenceResult): Promise<void>;
    // (undocumented)
    readonly items: ItemEditor;
    // (undocumented)
    readonly properties: PropertyEditor;
    // (undocumented)
    toJSON(): ReadonlyArray<AnySchemaEdits>;
}

// @alpha
export enum SchemaEditType {
    // (undocumented)
    RenameProperty = "RenameProperty",
    // (undocumented)
    RenameSchemaItem = "RenameSchemaItem",
    // (undocumented)
    Skip = "Skip"
}

// @alpha
export class SchemaId implements ISchemaIdentifier {
    constructor(schemaKey: SchemaKey);
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier = SchemaTypeIdentifiers.SchemaIdentifier;
}

// @alpha
export abstract class SchemaItemChange extends BaseSchemaChange {
    // (undocumented)
    get topLevelSchemaItem(): Schema | SchemaItem;
}

// @alpha
export class SchemaItemChanges extends BaseSchemaChanges {
    constructor(schema: Schema, schemaItemName: string, schemaItemType: SchemaItemType);
    addChange(change: ISchemaChange): void;
    // (undocumented)
    protected getSchemaItemNameFromChange(change: ISchemaChange): string | undefined;
    get schemaItemMissing(): SchemaItemMissing | undefined;
    get schemaItemType(): SchemaItemType;
}

// @beta
export abstract class SchemaItemDiagnostic<TYPE extends SchemaItem, ARGS extends any[]> extends BaseDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export class SchemaItemId implements ISchemaItemIdentifier {
    constructor(schemaItemType: SchemaItemType, schemaItemKeyOrName: SchemaItemKey | string, schemaKey?: SchemaKey);
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly schemaItemKey: SchemaItemKey;
    // (undocumented)
    readonly schemaItemType: SchemaItemType;
    // (undocumented)
    readonly schemaKey: SchemaKey;
    // (undocumented)
    readonly typeIdentifier: AnySchemaItemTypeIdentifier;
}

// @alpha
export class SchemaItemMissing extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @beta
export class SchemaMerger {
    constructor(editingContext: SchemaContext);
    // @alpha
    merge(differenceResult: SchemaDifferenceResult, edits?: SchemaEdits): Promise<Schema>;
    // @alpha
    mergeSchemas(targetSchema: Schema, sourceSchema: Schema, edits?: SchemaEdits): Promise<Schema>;
}

// @alpha
export enum SchemaOtherTypes {
    // (undocumented)
    CustomAttributeInstance = "CustomAttributeInstance",
    // (undocumented)
    EntityClassMixin = "EntityClassMixin",
    // (undocumented)
    Enumerator = "Enumerator",
    // (undocumented)
    Property = "Property",
    // (undocumented)
    RelationshipConstraint = "RelationshipConstraint",
    // (undocumented)
    RelationshipConstraintClass = "RelationshipConstraintClass",
    // (undocumented)
    Schema = "Schema",
    // (undocumented)
    SchemaReference = "SchemaReference"
}

// @alpha
export class SchemaReferenceDelta extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export interface SchemaReferenceDifference {
    // (undocumented)
    readonly changeType: "add" | "modify";
    // (undocumented)
    readonly difference: SchemaReferenceProps;
    // (undocumented)
    readonly schemaType: SchemaOtherTypes.SchemaReference;
}

// @alpha
export class SchemaReferenceMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export type SchemaType = SchemaOtherTypes | SchemaItemType;

// @alpha
export enum SchemaTypeIdentifiers {
    // (undocumented)
    ClassIdentifier = "Class",
    // (undocumented)
    CustomAttributeIdentifier = "CustomAttribute",
    // (undocumented)
    EnumeratorIdentifier = "Enumerator",
    // (undocumented)
    PropertyIdentifier = "Property",
    // (undocumented)
    RelationshipConstraintIdentifier = "RelationshipConstraint",
    // (undocumented)
    SchemaIdentifier = "Schema",
    // (undocumented)
    SchemaItemIdentifier = "SchemaItem"
}

// @beta
export class SchemaValidater {
    static validateSchema(schema: Schema, validaterRuleSet?: IRuleSet): Promise<AnyDiagnostic[]>;
}

// @beta
export class SchemaValidationVisitor implements ISchemaPartVisitor {
    // (undocumented)
    applyClassRules(ecClass: AnyClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyConstantRules(constant: Constant, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeContainerRules(container: CustomAttributeContainerProps, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeInstanceRules(container: CustomAttributeContainerProps, customAttribute: CustomAttribute, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeRules(customAttribute: CustomAttributeClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEntityRules(entityClass: EntityClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEnumerationRules(enumeration: Enumeration, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyFormatRules(format: Format, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyInvertedUnitRules(invertedUnit: InvertedUnit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyKindOfQuantityRules(kindOfQuantity: KindOfQuantity, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyMixinRules(mixin: Mixin, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPhenomenonRules(phenomenon: Phenomenon, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyCategoryRules(propertyCategory: PropertyCategory, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyRules(property: AnyProperty, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipConstraintRules(constraint: RelationshipConstraint, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipRules(relationship: RelationshipClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaItemRules(schemaItem: SchemaItem, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaRules(schema: Schema, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyStructRules(structClass: StructClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitRules(unit: Unit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitSystemRules(unitSystem: UnitSystem, ruleSet: IRuleSet): Promise<void>;
    get diagnosticReporters(): IDiagnosticReporter[];
    registerReporter(...reporters: IDiagnosticReporter[]): void;
    registerRuleSet(ruleSet: IRuleSet): void;
    registerRuleSuppressionSet(suppressionSet: IRuleSuppressionSet): void;
    get ruleSets(): RuleSetArray;
    // (undocumented)
    get suppressionSet(): IRuleSuppressionSet | undefined;
    visitClass(ecClass: AnyClass): Promise<void>;
    visitConstant(constant: Constant): Promise<void>;
    visitCustomAttributeClass(customAttribute: CustomAttributeClass): Promise<void>;
    visitCustomAttributeContainer(container: CustomAttributeContainerProps): Promise<void>;
    visitEntityClass(entity: EntityClass): Promise<void>;
    visitEnumeration(enumeration: Enumeration): Promise<void>;
    visitFormat(format: Format): Promise<void>;
    visitFullSchema(schema: Schema): Promise<void>;
    visitInvertedUnit(invertedUnit: InvertedUnit): Promise<void>;
    visitKindOfQuantity(koq: KindOfQuantity): Promise<void>;
    visitMixin(mixin: Mixin): Promise<void>;
    visitPhenomenon(phenomenon: Phenomenon): Promise<void>;
    visitProperty(property: AnyProperty): Promise<void>;
    visitPropertyCategory(category: PropertyCategory): Promise<void>;
    visitRelationshipClass(relationship: RelationshipClass): Promise<void>;
    visitRelationshipConstraint(constraint: RelationshipConstraint): Promise<void>;
    visitSchemaItem(schemaItem: SchemaItem): Promise<void>;
    visitStructClass(struct: StructClass): Promise<void>;
    visitUnit(unit: Unit): Promise<void>;
    visitUnitSystem(unitSystem: UnitSystem): Promise<void>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
}

// @alpha
export interface SkipEdit {
    // (undocumented)
    key: string;
    // (undocumented)
    type: SchemaEditType.Skip;
}

// @alpha
export interface StructClassDifference extends SchemaItemDifference<StructClassProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.StructClass;
}

// @beta
export abstract class SuppressionDiagnosticReporter implements IDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>);
    report(diagnostic: AnyDiagnostic): void;
    protected abstract reportInternal(diagnostic: AnyDiagnostic): void;
    get suppressions(): Map<string, string[]> | undefined;
}

// @alpha
export interface UnitDifference extends SchemaItemDifference<SchemaItemUnitProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.Unit;
}

// @alpha
export class UnitLabelOverrideDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export interface UnitSystemDifference extends SchemaItemDifference<UnitSystemProps> {
    // (undocumented)
    readonly schemaType: SchemaItemType.UnitSystem;
}

// (No @packageDocumentation comment for this package)

```
