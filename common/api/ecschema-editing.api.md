## API Report File for "@itwin/ecschema-editing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnyClass } from '@itwin/ecschema-metadata';
import { AnyECType } from '@itwin/ecschema-metadata';
import { AnyEnumerator } from '@itwin/ecschema-metadata';
import { AnyProperty } from '@itwin/ecschema-metadata';
import { Constant } from '@itwin/ecschema-metadata';
import { ConstantProps } from '@itwin/ecschema-metadata';
import { CustomAttribute } from '@itwin/ecschema-metadata';
import { CustomAttributeClass } from '@itwin/ecschema-metadata';
import { CustomAttributeClassProps } from '@itwin/ecschema-metadata';
import { CustomAttributeContainerProps } from '@itwin/ecschema-metadata';
import { CustomAttributeContainerType } from '@itwin/ecschema-metadata';
import { ECClassModifier } from '@itwin/ecschema-metadata';
import { EntityClass } from '@itwin/ecschema-metadata';
import { EntityClassProps } from '@itwin/ecschema-metadata';
import { Enumeration } from '@itwin/ecschema-metadata';
import { EnumerationPropertyProps } from '@itwin/ecschema-metadata';
import { EnumerationProps } from '@itwin/ecschema-metadata';
import { Format } from '@itwin/ecschema-metadata';
import { FormatProps } from '@itwin/ecschema-metadata';
import { FormatType } from '@itwin/ecschema-metadata';
import { InvertedUnit } from '@itwin/ecschema-metadata';
import { InvertedUnitProps } from '@itwin/ecschema-metadata';
import { ISchemaPartVisitor } from '@itwin/ecschema-metadata';
import { KindOfQuantity } from '@itwin/ecschema-metadata';
import { KindOfQuantityProps } from '@itwin/ecschema-metadata';
import { Localization } from '@itwin/core-common';
import { Mixin } from '@itwin/ecschema-metadata';
import { MixinProps } from '@itwin/ecschema-metadata';
import { OverrideFormat } from '@itwin/ecschema-metadata';
import { Phenomenon } from '@itwin/ecschema-metadata';
import { PhenomenonProps } from '@itwin/ecschema-metadata';
import { PrimitiveArrayPropertyProps } from '@itwin/ecschema-metadata';
import { PrimitivePropertyProps } from '@itwin/ecschema-metadata';
import { PrimitiveType } from '@itwin/ecschema-metadata';
import { PropertyCategory } from '@itwin/ecschema-metadata';
import { PropertyCategoryProps } from '@itwin/ecschema-metadata';
import { RelationshipClass } from '@itwin/ecschema-metadata';
import { RelationshipClassProps } from '@itwin/ecschema-metadata';
import { RelationshipConstraint } from '@itwin/ecschema-metadata';
import { Schema } from '@itwin/ecschema-metadata';
import { SchemaContext } from '@itwin/ecschema-metadata';
import { SchemaItem } from '@itwin/ecschema-metadata';
import { SchemaItemKey } from '@itwin/ecschema-metadata';
import { SchemaItemType } from '@itwin/ecschema-metadata';
import { SchemaKey } from '@itwin/ecschema-metadata';
import { StrengthDirection } from '@itwin/ecschema-metadata';
import { StructArrayPropertyProps } from '@itwin/ecschema-metadata';
import { StructClass } from '@itwin/ecschema-metadata';
import { StructClassProps } from '@itwin/ecschema-metadata';
import { StructPropertyProps } from '@itwin/ecschema-metadata';
import { Unit } from '@itwin/ecschema-metadata';
import { UnitProps } from '@itwin/ecschema-metadata';
import { UnitSystem } from '@itwin/ecschema-metadata';
import { UnitSystemProps } from '@itwin/ecschema-metadata';

// @beta
export type AnyDiagnostic = IDiagnostic<AnyECType, any[]>;

// @alpha
export class BaseClassDelta extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @beta
export abstract class BaseDiagnostic<TYPE extends AnyECType, ARGS extends any[]> implements IDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: TYPE, messageArgs?: ARGS, category?: DiagnosticCategory);
    category: DiagnosticCategory;
    abstract get code(): string;
    abstract get diagnosticType(): DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    abstract get messageText(): string;
    abstract get schema(): Schema;
}

// @beta (undocumented)
export type BaseRule<T extends AnyECType, U extends AnyECType> = IRule<T, U>;

// @alpha
export abstract class BaseSchemaChange implements ISchemaChange {
    constructor(diagnostic: AnyDiagnostic);
    get changeType(): ChangeType;
    set changeType(changeType: ChangeType);
    abstract get defaultChangeType(): ChangeType;
    get diagnostic(): AnyDiagnostic;
    protected getNameFromArgument(index: number, allowUndefined?: boolean, fullName?: boolean): string;
    protected getStringFromArgument(index: number): string;
    protected getValueFromArgument(index: number): any;
    abstract get topLevelSchemaItem(): SchemaItem | Schema;
    abstract toString(): string;
}

// @alpha
export abstract class BaseSchemaChanges implements ISchemaChanges {
    constructor(schema: Schema, anyECTypeName: string);
    abstract addChange(change: ISchemaChange): void;
    protected addChangeToMap<V extends ISchemaChanges>(changes: Map<string, V>, changesType: SchemaChangesConstructor, change: ISchemaChange, changeKey: string): void;
    get ecTypeName(): string;
    protected isCAContainerChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string | undefined): boolean;
    protected isPropertyValueChangeForThis(diagnostic: AnyDiagnostic, ecTypeName: string): boolean;
    get propertyValueChanges(): PropertyValueChange[];
    get schema(): Schema;
    }

// @alpha
export enum ChangeType {
    // (undocumented)
    Delta = 0,
    // (undocumented)
    Missing = 1
}

// @alpha
export class ClassChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get baseClassDelta(): BaseClassDelta | undefined;
    get entityMixinChanges(): Map<string, EntityMixinChanges>;
    get propertyChanges(): Map<string, PropertyChanges>;
    get sourceConstraintChanges(): Map<string, RelationshipConstraintChanges>;
    get targetConstraintChanges(): Map<string, RelationshipConstraintChanges>;
    }

// @beta
export abstract class ClassDiagnostic<ARGS extends any[]> extends SchemaItemDiagnostic<AnyClass, ARGS> {
    constructor(ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory);
    get schema(): Schema;
}

// @beta
export function createClassDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (ecClass: AnyClass, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyClass;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @beta
export function createCustomAttributeContainerDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: CustomAttributeContainerProps;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createPropertyDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (property: AnyProperty, messageArgs?: ARGS | undefined, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: AnyProperty;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
};

// @beta
export function createRelationshipConstraintDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: RelationshipConstraint;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
};

// @beta
export function createSchemaDiagnosticClass<ARGS extends any[]>(code: string, messageText: string): {
    new (schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: Schema;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    code: string;
    diagnosticType: DiagnosticType;
};

// @beta
export function createSchemaItemDiagnosticClass<ITEM extends SchemaItem, ARGS extends any[]>(code: string, messageText: string): {
    new (ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory): {
        readonly code: string;
        readonly messageText: string;
        readonly schema: Schema;
        readonly diagnosticType: DiagnosticType;
        ecDefinition: ITEM;
        messageArgs?: ARGS | undefined;
        category: DiagnosticCategory;
    };
    diagnosticType: DiagnosticType;
};

// @alpha
export class CustomAttributeContainerChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class CustomAttributeContainerChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): CustomAttributeContainerChange[];
    }

// @beta
export abstract class CustomAttributeContainerDiagnostic<ARGS extends any[]> extends BaseDiagnostic<CustomAttributeContainerProps, ARGS> {
    constructor(container: CustomAttributeContainerProps, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @beta
export enum DiagnosticCategory {
    // (undocumented)
    Error = 1,
    // (undocumented)
    Message = 3,
    // (undocumented)
    Suggestion = 2,
    // (undocumented)
    Warning = 0
}

// @beta (undocumented)
export function diagnosticCategoryToString(category: DiagnosticCategory): "Error" | "Warning" | "Message" | "Suggestion";

// @beta
export const DiagnosticCodes: {
    BaseClassIsSealed: string;
    BaseClassOfDifferentType: string;
    AbstractClassWithNonAbstractBase: string;
    CustomAttributeNotOfConcreteClass: string;
    CustomAttributeSchemaMustBeReferenced: string;
    CustomAttributeClassNotFound: string;
    EnumerationTypeUnsupported: string;
    MixinAppliedToClassMustDeriveFromConstraint: string;
    IncompatibleValueTypePropertyOverride: string;
    IncompatibleTypePropertyOverride: string;
    IncompatibleUnitPropertyOverride: string;
    AbstractConstraintMustNarrowBaseConstraints: string;
    DerivedConstraintsMustNarrowBaseConstraints: string;
    ConstraintClassesDeriveFromAbstractContraint: string;
    AtLeastOneConstraintClassDefined: string;
    AbstractConstraintMustExistWithMultipleConstraints: string;
};

// @beta
export const Diagnostics: {
    SupplementalSchemasCannotBeReferenced: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaRefAliasMustBeUnique: {
        new (schema: Schema, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ReferenceCyclesNotAllowed: {
        new (schema: Schema, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsSealed: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassIsOfDifferentType: {
        new (ecClass: AnyClass, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AbstractClassWithNonAbstractBase: {
        new (ecClass: AnyClass, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeNotOfConcreteClass: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeSchemaMustBeReferenced: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeClassNotFound: {
        new (container: CustomAttributeContainerProps, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeContainerProps;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    EnumerationTypeUnsupported: {
        new (ecDefinition: import("@itwin/ecschema-metadata").SchemaItem, messageArgs: [string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinAppliedToClassMustDeriveFromConstraint: {
        new (ecDefinition: import("@itwin/ecschema-metadata").SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    IncompatibleValueTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleTypePropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    IncompatibleUnitPropertyOverride: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipMustBeRoot: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationTargetMustHaveSingularMultiplicity: {
        new (property: AnyProperty, messageArgs?: [string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationRelationshipAbstractConstraintEntityOrMixin: {
        new (property: AnyProperty, messageArgs?: [string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    NavigationClassMustBeAConstraintClassOfRelationship: {
        new (property: AnyProperty, messageArgs?: [string, string, string, string] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyProperty;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    AbstractConstraintMustNarrowBaseConstraints: {
        new (ecDefinition: import("@itwin/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    DerivedConstraintsMustNarrowBaseConstraints: {
        new (ecDefinition: import("@itwin/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstraintClassesDeriveFromAbstractContraint: {
        new (ecDefinition: import("@itwin/ecschema-metadata").SchemaItem, messageArgs: [string, string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    AtLeastOneConstraintClassDefined: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    AbstractConstraintMustExistWithMultipleConstraints: {
        new (constraint: RelationshipConstraint, messageArgs: [string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipConstraint;
            messageArgs?: [string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
};

// @beta
export enum DiagnosticType {
    // (undocumented)
    CustomAttributeContainer = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Property = 3,
    // (undocumented)
    RelationshipConstraint = 5,
    // (undocumented)
    Schema = 1,
    // (undocumented)
    SchemaItem = 2
}

// @beta (undocumented)
export function diagnosticTypeToString(type: DiagnosticType): "CustomAttributeContainer" | "None" | "Property" | "RelationshipConstraint" | "Schema" | "SchemaItem";

// @beta
export const ECRuleSet: IRuleSet;

// @alpha
export class EntityMixinChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class EntityMixinChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get entityMixinChange(): EntityMixinChange[];
    }

// @alpha
export class EnumerationChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorChanges(): Map<string, EnumeratorChanges>;
    }

// @alpha
export class EnumeratorChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get enumeratorDeltas(): EnumeratorDelta[];
    get enumeratorMissing(): EnumeratorMissing | undefined;
    }

// @alpha
export class EnumeratorDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class EnumeratorMissing extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class FormatChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): Map<string, FormatUnitChanges>;
    }

// @beta
export abstract class FormatDiagnosticReporter extends SuppressionDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>, localization?: Localization);
    protected formatStringFromArgs(text: string, args: ArrayLike<string>, baseIndex?: number): string;
    localization?: Localization;
    protected abstract reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
    reportInternal(diagnostic: AnyDiagnostic): void;
    }

// @alpha
export class FormatUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class FormatUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get formatUnitChanges(): FormatUnitChange[];
    get unitLabelOverrideDeltas(): UnitLabelOverrideDelta[];
    }

// @beta
export interface IDiagnostic<TYPE extends AnyECType, ARGS extends any[]> {
    category: DiagnosticCategory;
    code: string;
    diagnosticType: DiagnosticType;
    ecDefinition: TYPE;
    messageArgs?: ARGS;
    messageText: string;
    schema: Schema;
}

// @beta
export interface IDiagnosticReporter {
    localization?: Localization;
    report(diagnostic: AnyDiagnostic): void;
    suppressions?: Map<string, string[]>;
}

// @beta
export type IRule<T extends AnyECType, U = {}> = (ecDefinition: T, ...args: U[]) => AsyncIterable<BaseDiagnostic<T, any[]>>;

// @beta
export interface IRuleSet {
    classRules?: Array<IRule<AnyClass>>;
    constantRules?: Array<IRule<Constant>>;
    customAttributeClassRules?: Array<IRule<CustomAttributeClass>>;
    customAttributeContainerRules?: Array<IRule<CustomAttributeContainerProps>>;
    customAttributeInstanceRules?: Array<BaseRule<CustomAttributeContainerProps, CustomAttribute>>;
    entityClassRules?: Array<IRule<EntityClass>>;
    enumerationRules?: Array<IRule<Enumeration>>;
    formatRules?: Array<IRule<Format>>;
    invertedUnitRules?: Array<IRule<InvertedUnit>>;
    kindOfQuantityRules?: Array<IRule<KindOfQuantity>>;
    mixinRules?: Array<IRule<Mixin>>;
    name: string;
    phenomenonRules?: Array<IRule<Phenomenon>>;
    propertyCategoryRules?: Array<IRule<PropertyCategory>>;
    propertyRules?: Array<IRule<AnyProperty>>;
    relationshipConstraintRules?: Array<IRule<RelationshipConstraint>>;
    relationshipRules?: Array<IRule<RelationshipClass>>;
    schemaExclusionSet?: string[];
    schemaItemRules?: Array<IRule<SchemaItem>>;
    schemaRules?: Array<IRule<Schema>>;
    structClassRules?: Array<IRule<StructClass>>;
    unitRules?: Array<IRule<Unit>>;
    unitSystemRules?: Array<IRule<UnitSystem>>;
}

// @beta
export interface IRuleSuppressionMap<T extends AnyECType, U = {}> {
    // (undocumented)
    rule: ISuppressionRule<T, U>;
    // (undocumented)
    ruleCode: string;
}

// @beta
export interface IRuleSuppressionSet {
    // (undocumented)
    classRuleSuppressions?: Array<IRuleSuppressionMap<AnyClass>>;
    // (undocumented)
    constantRuleSuppressions?: Array<IRuleSuppressionMap<Constant>>;
    // (undocumented)
    customAttributeContainerSuppressions?: Array<IRuleSuppressionMap<CustomAttributeContainerProps>>;
    // (undocumented)
    customAttributeInstanceSuppressions?: Array<BaseRuleSuppressionMap<CustomAttributeContainerProps, CustomAttribute>>;
    // (undocumented)
    customAttributeRuleSuppressions?: Array<IRuleSuppressionMap<CustomAttributeClass>>;
    // (undocumented)
    entityRuleSuppressions?: Array<IRuleSuppressionMap<EntityClass>>;
    // (undocumented)
    enumerationRuleSuppressions?: Array<IRuleSuppressionMap<Enumeration>>;
    // (undocumented)
    formatRuleSuppressions?: Array<IRuleSuppressionMap<Format>>;
    // (undocumented)
    invertedUnitRuleSuppressions?: Array<IRuleSuppressionMap<InvertedUnit>>;
    // (undocumented)
    koqRuleSuppressions?: Array<IRuleSuppressionMap<KindOfQuantity>>;
    // (undocumented)
    mixinRuleSuppressions?: Array<IRuleSuppressionMap<Mixin>>;
    // (undocumented)
    name: string;
    // (undocumented)
    phenomenonRuleSuppressions?: Array<IRuleSuppressionMap<Phenomenon>>;
    // (undocumented)
    propertyCategoryRuleSuppressions?: Array<IRuleSuppressionMap<PropertyCategory>>;
    // (undocumented)
    propertyRuleSuppressions?: Array<IRuleSuppressionMap<AnyProperty>>;
    // (undocumented)
    relationshipConstraintRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipConstraint>>;
    // (undocumented)
    relationshipRuleSuppressions?: Array<IRuleSuppressionMap<RelationshipClass>>;
    // (undocumented)
    schemaItemRuleSuppressions?: Array<IRuleSuppressionMap<SchemaItem>>;
    // (undocumented)
    schemaRuleSuppressions?: Array<IRuleSuppressionMap<Schema>>;
    // (undocumented)
    structRuleSuppressions?: Array<IRuleSuppressionMap<StructClass>>;
    // (undocumented)
    unitRuleSuppressions?: Array<IRuleSuppressionMap<Unit>>;
    // (undocumented)
    unitSystemRuleSuppressions?: Array<IRuleSuppressionMap<UnitSystem>>;
}

// @alpha
export interface ISchemaChange {
    changeType: ChangeType;
    diagnostic: AnyDiagnostic;
    topLevelSchemaItem: SchemaItem | Schema;
    toString(): string;
}

// @alpha
export interface ISchemaChanges {
    // (undocumented)
    addChange(change: ISchemaChange): void;
    // (undocumented)
    ecTypeName: string;
    // (undocumented)
    schema: Schema;
}

// @alpha
export interface ISchemaComparer {
    // (undocumented)
    compareClasses(classA: AnyClass, classB: AnyClass | undefined): void;
    // (undocumented)
    compareConstants(constantA: Constant, constantB: Constant | undefined): void;
    // (undocumented)
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass | undefined): void;
    // (undocumented)
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps | undefined): void;
    // (undocumented)
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass | undefined): void;
    // (undocumented)
    compareEnumerations(enumA: Enumeration, enumB: Enumeration | undefined): void;
    // (undocumented)
    compareFormats(formatA: Format, formatB: Format | undefined): void;
    // (undocumented)
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit | undefined): void;
    // (undocumented)
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity | undefined): void;
    // (undocumented)
    compareMixins(mixinA: Mixin, mixinB: Mixin | undefined): void;
    // (undocumented)
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon | undefined): void;
    // (undocumented)
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): void;
    // (undocumented)
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory | undefined): void;
    // (undocumented)
    compareRelationshipClasses(relationshipClassA: RelationshipClass, relationshipClassB: RelationshipClass | undefined): void;
    // (undocumented)
    compareRelationshipConstraints(relationshipConstraintA: RelationshipConstraint, relationshipConstraintB: RelationshipConstraint | undefined): void;
    // (undocumented)
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): void;
    // (undocumented)
    compareSchemaProps(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareSchemas(schemaA: Schema, schemaB: Schema): void;
    // (undocumented)
    compareUnits(unitA: Unit, unitB: Unit | undefined): void;
}

// @alpha
export interface ISchemaCompareReporter {
    // (undocumented)
    report(schemaChanges: ISchemaChanges): void;
}

// @beta
export type ISuppressionRule<T extends AnyECType, U = {}> = (diagnostic: AnyDiagnostic, ecDefinition: T, ...args: U[]) => Promise<boolean>;

// @alpha
export class KindOfQuantityChanges extends SchemaItemChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChanges(): Map<string, PresentationUnitChanges>;
    }

// @beta
export class LoggingDiagnosticReporter extends FormatDiagnosticReporter {
    // (undocumented)
    reportDiagnostic(diagnostic: AnyDiagnostic, messageText: string): void;
}

// @alpha
export class PresentationUnitChange extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class PresentationUnitChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get presentationUnitChange(): PresentationUnitChange[];
    }

// @alpha
export class PropertyChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get propertyMissing(): PropertyMissing | undefined;
    }

// @beta
export abstract class PropertyDiagnostic<ARGS extends any[]> extends BaseDiagnostic<AnyProperty, ARGS> {
    constructor(property: AnyProperty, messageArgs?: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface PropertyEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
    // (undocumented)
    propertyName?: string;
}

// @alpha
export class PropertyMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class PropertyValueChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class RelationshipConstraintChanges extends BaseSchemaChanges {
    addChange(change: ISchemaChange): void;
    get constraintClassChanges(): RelationshipConstraintClassChange[];
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    }

// @alpha
export class RelationshipConstraintClassChange extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta
export abstract class RelationshipConstraintDiagnostic<ARGS extends any[]> extends BaseDiagnostic<RelationshipConstraint, ARGS> {
    constructor(constraint: RelationshipConstraint, messageArgs: ARGS, category?: DiagnosticCategory);
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha
export class SchemaChanges extends BaseSchemaChanges {
    constructor(schema: Schema);
    addChange(change: ISchemaChange): void;
    addDiagnostic(diagnostic: AnyDiagnostic): void;
    get allDiagnostics(): AnyDiagnostic[];
    get classChanges(): Map<string, ClassChanges>;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    get enumerationChanges(): Map<string, EnumerationChanges>;
    get formatChanges(): Map<string, FormatChanges>;
    get kindOfQuantityChanges(): Map<string, KindOfQuantityChanges>;
    get missingSchemaReferences(): SchemaReferenceMissing[];
    get schemaItemChanges(): Map<string, SchemaItemChanges>;
    get schemaReferenceDeltas(): SchemaReferenceDelta[];
    }

// @beta
export const SchemaCompareCodes: {
    SchemaDelta: string;
    SchemaReferenceMissing: string;
    SchemaItemDelta: string;
    SchemaItemMissing: string;
    ClassDelta: string;
    BaseClassDelta: string;
    PropertyDelta: string;
    PropertyMissing: string;
    EntityMixinMissing: string;
    MixinDelta: string;
    RelationshipDelta: string;
    RelationshipConstraintDelta: string;
    RelationshipConstraintClassMissing: string;
    CustomAttributeClassDelta: string;
    CustomAttributeInstanceClassMissing: string;
    EnumerationDelta: string;
    EnumeratorMissing: string;
    EnumeratorDelta: string;
    KoqDelta: string;
    PresentationUnitMissing: string;
    PropertyCategoryDelta: string;
    FormatDelta: string;
    FormatUnitMissing: string;
    UnitLabelOverrideDelta: string;
    UnitDelta: string;
    InvertedUnitDelta: string;
    PhenomenonDelta: string;
    ConstantDelta: string;
    SchemaReferenceDelta: string;
};

// @beta
export const SchemaCompareDiagnostics: {
    SchemaDelta: {
        new (schema: Schema, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceMissing: {
        new (schema: Schema, messageArgs: [Schema], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaReferenceDelta: {
        new (schema: Schema, messageArgs: [Schema, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Schema;
            messageArgs?: [Schema, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    SchemaItemMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: SchemaItem;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ClassDelta: {
        new (ecClass: AnyClass, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    BaseClassDelta: {
        new (ecClass: AnyClass, messageArgs: [AnyClass | undefined, AnyClass | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: AnyClass;
            messageArgs?: [AnyClass | undefined, AnyClass | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyDelta: {
        new (property: import("@itwin/ecschema-metadata").AnyProperty, messageArgs?: [string, any, any] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@itwin/ecschema-metadata").AnyProperty;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    PropertyMissing: {
        new (property: import("@itwin/ecschema-metadata").AnyProperty, messageArgs?: [] | undefined, category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@itwin/ecschema-metadata").AnyProperty;
            messageArgs?: [] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        code: string;
    };
    EntityMixinMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Mixin], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: EntityClass;
            messageArgs?: [Mixin] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    MixinDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Mixin;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: RelationshipClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    RelationshipConstraintDelta: {
        new (constraint: import("@itwin/ecschema-metadata").RelationshipConstraint, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@itwin/ecschema-metadata").RelationshipConstraint;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    RelationshipConstraintClassMissing: {
        new (constraint: import("@itwin/ecschema-metadata").RelationshipConstraint, messageArgs: [AnyClass], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@itwin/ecschema-metadata").RelationshipConstraint;
            messageArgs?: [AnyClass] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    CustomAttributeClassDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: CustomAttributeClass;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    CustomAttributeInstanceClassMissing: {
        new (container: import("@itwin/ecschema-metadata").CustomAttributeContainerProps, messageArgs: [CustomAttribute], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: import("@itwin/ecschema-metadata").CustomAttributeContainerProps;
            messageArgs?: [CustomAttribute] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
    };
    EnumerationDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    EnumeratorDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [AnyEnumerator, string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Enumeration;
            messageArgs?: [AnyEnumerator, string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    KoqDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PresentationUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [OverrideFormat | Format], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: KindOfQuantity;
            messageArgs?: [OverrideFormat | Format] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PropertyCategoryDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: PropertyCategory;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, any, any], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, any, any] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    FormatUnitMissing: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitLabelOverrideDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [Unit | InvertedUnit, string | undefined, string | undefined], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [Unit | InvertedUnit, string | undefined, string | undefined] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    UnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Format;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    InvertedUnitDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    PhenomenonDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: InvertedUnit;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
    ConstantDelta: {
        new (ecDefinition: SchemaItem, messageArgs: [string, string, string], category?: import("./Diagnostic").DiagnosticCategory): {
            readonly code: string;
            readonly messageText: string;
            readonly schema: Schema;
            readonly diagnosticType: import("./Diagnostic").DiagnosticType;
            ecDefinition: Constant;
            messageArgs?: [string, string, string] | undefined;
            category: import("./Diagnostic").DiagnosticCategory;
        };
        diagnosticType: import("./Diagnostic").DiagnosticType;
    };
};

// @alpha
export enum SchemaCompareDirection {
    // (undocumented)
    Backward = 1,
    // (undocumented)
    Forward = 0
}

// @alpha
export class SchemaComparer {
    constructor(...reporters: ISchemaCompareReporter[]);
    compareClasses(classA: AnyClass, classB: AnyClass | undefined): Promise<void>;
    compareConstants(constantA: Constant, constantB: Constant | undefined): Promise<void>;
    compareCustomAttributeClasses(customAttributeClassA: CustomAttributeClass, customAttributeClassB: CustomAttributeClass | undefined): Promise<void>;
    compareCustomAttributeContainers(containerA: CustomAttributeContainerProps, containerB: CustomAttributeContainerProps | undefined): Promise<void>;
    compareEntityClasses(entityA: EntityClass, entityB: EntityClass | undefined): Promise<void>;
    compareEnumerations(enumA: Enumeration, enumB: Enumeration | undefined): Promise<void>;
    compareFormats(formatA: Format, formatB: Format | undefined): Promise<void>;
    compareInvertedUnits(invertedUnitA: InvertedUnit, invertedUnitB: InvertedUnit | undefined): Promise<void>;
    compareKindOfQuantities(koqA: KindOfQuantity, koqB: KindOfQuantity | undefined): Promise<void>;
    compareMixins(mixinA: Mixin, mixinB: Mixin | undefined): Promise<void>;
    comparePhenomenons(phenomenonA: Phenomenon, phenomenonB: Phenomenon | undefined): Promise<void>;
    compareProperties(propertyA: AnyProperty, propertyB: AnyProperty | undefined): Promise<void>;
    comparePropertyCategories(categoryA: PropertyCategory, categoryB: PropertyCategory | undefined): Promise<void>;
    compareRelationshipClasses(relationshipA: RelationshipClass, relationshipB: RelationshipClass | undefined): Promise<void>;
    compareRelationshipConstraints(constraintA: RelationshipConstraint, constraintB: RelationshipConstraint | undefined): Promise<void>;
    compareSchemaItems(schemaItemA: SchemaItem, schemaItemB: SchemaItem | undefined): Promise<void>;
    compareSchemaProps(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareSchemas(schemaA: Schema, schemaB: Schema): Promise<void>;
    compareUnits(unitA: Unit, unitB: Unit | undefined): Promise<void>;
    }

// @alpha
export class SchemaContextEditor {
    constructor(schemaContext: SchemaContext);
    addCustomAttribute(schemaKey: SchemaKey, customAttribute: CustomAttribute): Promise<SchemaEditResults>;
    addSchemaReference(schemaKey: SchemaKey, refSchema: Schema): Promise<SchemaEditResults>;
    // (undocumented)
    readonly constants: Constants;
    createSchema(name: string, alias: string, readVersion: number, writeVersion: number, minorVersion: number): Promise<SchemaEditResults>;
    // (undocumented)
    readonly customAttributes: CustomAttributes;
    // (undocumented)
    readonly entities: Entities;
    // (undocumented)
    readonly enumerations: Enumerations;
    // (undocumented)
    finish(): Promise<SchemaContext>;
    // (undocumented)
    readonly formats: Formats;
    getSchema(schemaKey: SchemaKey): Promise<MutableSchema>;
    incrementMinorVersion(schemaKey: SchemaKey): Promise<SchemaEditResults>;
    // (undocumented)
    readonly invertedUnits: InvertedUnits;
    // (undocumented)
    readonly kindOfQuantities: KindOfQuantities;
    // (undocumented)
    readonly mixins: Mixins;
    // (undocumented)
    readonly phenomenons: Phenomena;
    // (undocumented)
    readonly propertyCategories: PropertyCategories;
    // (undocumented)
    readonly relationships: RelationshipClasses;
    get schemaContext(): SchemaContext;
    // (undocumented)
    readonly structs: Structs;
    // (undocumented)
    readonly units: Units;
    // (undocumented)
    readonly unitSystems: UnitSystems;
}

// @beta
export abstract class SchemaDiagnostic<ARGS extends any[]> extends BaseDiagnostic<Schema, ARGS> {
    constructor(schema: Schema, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    schemaKey?: SchemaKey;
}

// @alpha
export abstract class SchemaItemChange extends BaseSchemaChange {
    // (undocumented)
    get topLevelSchemaItem(): Schema | SchemaItem;
}

// @alpha
export class SchemaItemChanges extends BaseSchemaChanges {
    constructor(schema: Schema, schemaItemName: string, schemaItemType: SchemaItemType);
    addChange(change: ISchemaChange): void;
    get customAttributeChanges(): Map<string, CustomAttributeContainerChanges>;
    // (undocumented)
    protected getSchemaItemNameFromChange(change: ISchemaChange): string | undefined;
    get schemaItemMissing(): SchemaItemMissing | undefined;
    get schemaItemType(): SchemaItemType;
    }

// @beta
export abstract class SchemaItemDiagnostic<TYPE extends SchemaItem, ARGS extends any[]> extends BaseDiagnostic<TYPE, ARGS> {
    constructor(ecDefinition: SchemaItem, messageArgs: ARGS, category?: DiagnosticCategory);
    // (undocumented)
    static diagnosticType: DiagnosticType;
    get diagnosticType(): DiagnosticType;
    get schema(): Schema;
}

// @alpha (undocumented)
export interface SchemaItemEditResults {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    itemKey?: SchemaItemKey;
}

// @alpha
export class SchemaItemMissing extends SchemaItemChange {
    get defaultChangeType(): ChangeType;
    toString(): string;
}

// @alpha
export class SchemaReferenceDelta extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @alpha
export class SchemaReferenceMissing extends BaseSchemaChange {
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}

// @beta
export class SchemaValidater {
    static validateSchema(schema: Schema, validaterRuleSet?: IRuleSet): Promise<AnyDiagnostic[]>;
}

// @beta
export class SchemaValidationVisitor implements ISchemaPartVisitor {
    // (undocumented)
    applyClassRules(ecClass: AnyClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyConstantRules(constant: Constant, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeContainerRules(container: CustomAttributeContainerProps, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeInstanceRules(container: CustomAttributeContainerProps, customAttribute: CustomAttribute, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyCustomAttributeRules(customAttribute: CustomAttributeClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEntityRules(entityClass: EntityClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyEnumerationRules(enumeration: Enumeration, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyFormatRules(format: Format, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyInvertedUnitRules(invertedUnit: InvertedUnit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyKindOfQuantityRules(kindOfQuantity: KindOfQuantity, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyMixinRules(mixin: Mixin, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPhenomenonRules(phenomenon: Phenomenon, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyCategoryRules(propertyCategory: PropertyCategory, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyPropertyRules(property: AnyProperty, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipConstraintRules(constraint: RelationshipConstraint, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyRelationshipRules(relationship: RelationshipClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaItemRules(schemaItem: SchemaItem, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applySchemaRules(schema: Schema, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyStructRules(structClass: StructClass, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitRules(unit: Unit, ruleSet: IRuleSet): Promise<void>;
    // (undocumented)
    applyUnitSystemRules(unitSystem: UnitSystem, ruleSet: IRuleSet): Promise<void>;
    get diagnosticReporters(): IDiagnosticReporter[];
    registerReporter(...reporters: IDiagnosticReporter[]): void;
    registerRuleSet(ruleSet: IRuleSet): void;
    registerRuleSuppressionSet(suppressionSet: IRuleSuppressionSet): void;
    get ruleSets(): RuleSetArray;
    // (undocumented)
    get suppressionSet(): IRuleSuppressionSet | undefined;
    visitClass(ecClass: AnyClass): Promise<void>;
    visitConstant(constant: Constant): Promise<void>;
    visitCustomAttributeClass(customAttribute: CustomAttributeClass): Promise<void>;
    visitCustomAttributeContainer(container: CustomAttributeContainerProps): Promise<void>;
    visitEntityClass(entity: EntityClass): Promise<void>;
    visitEnumeration(enumeration: Enumeration): Promise<void>;
    visitFormat(format: Format): Promise<void>;
    visitFullSchema(schema: Schema): Promise<void>;
    visitInvertedUnit(invertedUnit: InvertedUnit): Promise<void>;
    visitKindOfQuantity(koq: KindOfQuantity): Promise<void>;
    visitMixin(mixin: Mixin): Promise<void>;
    visitPhenomenon(phenomenon: Phenomenon): Promise<void>;
    visitProperty(property: AnyProperty): Promise<void>;
    visitPropertyCategory(category: PropertyCategory): Promise<void>;
    visitRelationshipClass(relationship: RelationshipClass): Promise<void>;
    visitRelationshipConstraint(constraint: RelationshipConstraint): Promise<void>;
    visitSchemaItem(schemaItem: SchemaItem): Promise<void>;
    visitStructClass(struct: StructClass): Promise<void>;
    visitUnit(unit: Unit): Promise<void>;
    visitUnitSystem(unitSystem: UnitSystem): Promise<void>;
}

// @internal
export class SchemaWalker {
    constructor(visitor: ISchemaPartVisitor);
    traverseSchema<T extends Schema>(schema: T): Promise<T>;
    }

// @beta
export abstract class SuppressionDiagnosticReporter implements IDiagnosticReporter {
    constructor(suppressions?: Map<string, string[]>);
    report(diagnostic: AnyDiagnostic): void;
    protected abstract reportInternal(diagnostic: AnyDiagnostic): void;
    get suppressions(): Map<string, string[]> | undefined;
    }

// @alpha
export class UnitLabelOverrideDelta extends BaseSchemaChange {
    get changeKey(): string;
    get defaultChangeType(): ChangeType;
    get topLevelSchemaItem(): Schema | SchemaItem;
    toString(): string;
}


// (No @packageDocumentation comment for this package)

```
