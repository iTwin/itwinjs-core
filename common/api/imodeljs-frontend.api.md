## API Report File for "@bentley/imodeljs-frontend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AccessToken } from '@bentley/itwin-client';
import { AmbientOcclusion } from '@bentley/imodeljs-common';
import { AnalysisStyle } from '@bentley/imodeljs-common';
import { Angle } from '@bentley/geometry-core';
import { AngleSweep } from '@bentley/geometry-core';
import { Arc3d } from '@bentley/geometry-core';
import { AuthorizedClientRequestContext } from '@bentley/itwin-client';
import { AuxCoordSystem2dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystem3dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystemProps } from '@bentley/imodeljs-common';
import { AxisAlignedBox3d } from '@bentley/imodeljs-common';
import { BackgroundMapProps } from '@bentley/imodeljs-common';
import { BackgroundMapSettings } from '@bentley/imodeljs-common';
import { BaseLayerSettings } from '@bentley/imodeljs-common';
import { BaseQuantityDescription } from '@bentley/ui-abstract';
import { BatchType } from '@bentley/imodeljs-common';
import { BeDuration } from '@bentley/bentleyjs-core';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyCloudRpcParams } from '@bentley/imodeljs-common';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { BeTimePoint } from '@bentley/bentleyjs-core';
import { BeUiEvent } from '@bentley/bentleyjs-core';
import { BriefcaseDownloader } from '@bentley/imodeljs-common';
import { BriefcaseProps } from '@bentley/imodeljs-common';
import { ByteStream } from '@bentley/bentleyjs-core';
import { Camera } from '@bentley/imodeljs-common';
import { Capabilities } from '@bentley/webgl-compatibility';
import { Cartographic } from '@bentley/imodeljs-common';
import { CartographicRange } from '@bentley/imodeljs-common';
import { CategorySelectorProps } from '@bentley/imodeljs-common';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClipPlane } from '@bentley/geometry-core';
import { ClipShape } from '@bentley/geometry-core';
import { ClipStyle } from '@bentley/imodeljs-common';
import { ClipVector } from '@bentley/geometry-core';
import { Code } from '@bentley/imodeljs-common';
import { CodeProps } from '@bentley/imodeljs-common';
import { CodeSpec } from '@bentley/imodeljs-common';
import { ColorDef } from '@bentley/imodeljs-common';
import { ColorDefProps } from '@bentley/imodeljs-common';
import { ColorIndex } from '@bentley/imodeljs-common';
import { CompressedId64Set } from '@bentley/bentleyjs-core';
import { Constructor } from '@bentley/bentleyjs-core';
import { ContentIdProvider } from '@bentley/imodeljs-common';
import { ContextRealityModelProps } from '@bentley/imodeljs-common';
import { ConvexClipPlaneSet } from '@bentley/geometry-core';
import { CurvePrimitive } from '@bentley/geometry-core';
import { DesktopAuthorizationClientConfiguration } from '@bentley/imodeljs-common';
import { DevToolsStatsOptions } from '@bentley/imodeljs-common';
import { DialogItem } from '@bentley/ui-abstract';
import { DialogItemValue } from '@bentley/ui-abstract';
import { DialogPropertyItem } from '@bentley/ui-abstract';
import { DialogPropertySyncItem } from '@bentley/ui-abstract';
import { Dictionary } from '@bentley/bentleyjs-core';
import { DisplayStyle3dSettings } from '@bentley/imodeljs-common';
import { DisplayStyleProps } from '@bentley/imodeljs-common';
import { DisplayStyleSettings } from '@bentley/imodeljs-common';
import { DisplayStyleSettingsProps } from '@bentley/imodeljs-common';
import { EasingFunction } from '@bentley/imodeljs-common';
import { EcefLocation } from '@bentley/imodeljs-common';
import { EcefLocationProps } from '@bentley/imodeljs-common';
import { EdgeArgs } from '@bentley/imodeljs-common';
import { Editor3dRpcInterfaceWriteOptions } from '@bentley/imodeljs-common';
import { ElementAlignedBox3d } from '@bentley/imodeljs-common';
import { ElementGeometryChange } from '@bentley/imodeljs-common';
import { ElementGraphicsRequestProps } from '@bentley/imodeljs-common';
import { ElementProps } from '@bentley/imodeljs-common';
import { ElementsChanged } from '@bentley/imodeljs-common';
import { Ellipsoid } from '@bentley/geometry-core';
import { EllipsoidPatch } from '@bentley/geometry-core';
import { EntityProps } from '@bentley/imodeljs-common';
import { EntityQueryParams } from '@bentley/imodeljs-common';
import { EnvironmentProps } from '@bentley/imodeljs-common';
import { ExtensionProps } from '@bentley/extension-client';
import { Feature } from '@bentley/imodeljs-common';
import { FeatureAppearance } from '@bentley/imodeljs-common';
import { FeatureAppearanceProps } from '@bentley/imodeljs-common';
import { FeatureAppearanceProvider } from '@bentley/imodeljs-common';
import { FeatureIndex } from '@bentley/imodeljs-common';
import { FeatureIndexType } from '@bentley/imodeljs-common';
import { FeatureLogEntry } from '@bentley/usage-logging-client';
import { FeatureOverrides } from '@bentley/imodeljs-common';
import { FeatureTable } from '@bentley/imodeljs-common';
import { FillFlags } from '@bentley/imodeljs-common';
import { FontMap } from '@bentley/imodeljs-common';
import { FormatProps } from '@bentley/imodeljs-quantity';
import { FormatterSpec } from '@bentley/imodeljs-quantity';
import { FrontendAuthorizationClient } from '@bentley/frontend-authorization-client';
import { Frustum } from '@bentley/imodeljs-common';
import { FrustumPlanes } from '@bentley/imodeljs-common';
import * as Fuse from 'fuse.js';
import { GeoCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { GeometricElement3dProps } from '@bentley/imodeljs-common';
import { GeometricModel2dProps } from '@bentley/imodeljs-common';
import { GeometricModel3dProps } from '@bentley/imodeljs-common';
import { GeometricModelProps } from '@bentley/imodeljs-common';
import { GeometryClass } from '@bentley/imodeljs-common';
import { GeometryContainmentRequestProps } from '@bentley/imodeljs-common';
import { GeometryContainmentResponseProps } from '@bentley/imodeljs-common';
import { GeometryQuery } from '@bentley/geometry-core';
import { GeometryStreamProps } from '@bentley/imodeljs-common';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GlobeMode } from '@bentley/imodeljs-common';
import { GltfBufferData } from '@bentley/imodeljs-common';
import { GltfBufferView } from '@bentley/imodeljs-common';
import { GltfDataType } from '@bentley/imodeljs-common';
import { Gradient } from '@bentley/imodeljs-common';
import { GraphicParams } from '@bentley/imodeljs-common';
import { GridOrientationType } from '@bentley/imodeljs-common';
import { GroundPlane } from '@bentley/imodeljs-common';
import { GuidString } from '@bentley/bentleyjs-core';
import { HiddenLine } from '@bentley/imodeljs-common';
import { Hilite } from '@bentley/imodeljs-common';
import { I18N } from '@bentley/imodeljs-i18n';
import { I18NNamespace } from '@bentley/imodeljs-i18n';
import { I18NOptions } from '@bentley/imodeljs-i18n';
import { Id64 } from '@bentley/bentleyjs-core';
import { Id64Arg } from '@bentley/bentleyjs-core';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64Set } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { ImageBuffer } from '@bentley/imodeljs-common';
import { ImageBufferFormat } from '@bentley/imodeljs-common';
import { ImageSource } from '@bentley/imodeljs-common';
import { ImageSourceFormat } from '@bentley/imodeljs-common';
import { IModel } from '@bentley/imodeljs-common';
import { IModelChangeNotifications } from '@bentley/imodeljs-common';
import { IModelClient } from '@bentley/imodelhub-client';
import { IModelConnectionProps } from '@bentley/imodeljs-common';
import { IModelCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { IModelRpcProps } from '@bentley/imodeljs-common';
import { IModelTileTreeProps } from '@bentley/imodeljs-common';
import { IModelVersion } from '@bentley/imodeljs-common';
import { ImsAuthorizationClient } from '@bentley/itwin-client';
import { IndexedPolyface } from '@bentley/geometry-core';
import { IndexMap } from '@bentley/bentleyjs-core';
import { InternetConnectivityStatus } from '@bentley/imodeljs-common';
import { IpcAppChannel } from '@bentley/imodeljs-common';
import { IpcAppFunctions } from '@bentley/imodeljs-common';
import { IpcListener } from '@bentley/imodeljs-common';
import { IpcSocketFrontend } from '@bentley/imodeljs-common';
import { LDClient } from 'ldclient-js';
import { LDFlagValue } from 'ldclient-js';
import { LightSettings } from '@bentley/imodeljs-common';
import { LinePixels } from '@bentley/imodeljs-common';
import { LocalBriefcaseProps } from '@bentley/imodeljs-common';
import { LockLevel } from '@bentley/imodelhub-client';
import { LogLevel } from '@bentley/bentleyjs-core';
import { Loop } from '@bentley/geometry-core';
import { LowAndHighXY } from '@bentley/geometry-core';
import { LowAndHighXYZ } from '@bentley/geometry-core';
import { Map4d } from '@bentley/geometry-core';
import { MapLayerKey } from '@bentley/imodeljs-common';
import { MapLayerProps } from '@bentley/imodeljs-common';
import { MapLayerSettings } from '@bentley/imodeljs-common';
import { MapSubLayerProps } from '@bentley/imodeljs-common';
import { MassPropertiesOperation } from '@bentley/imodeljs-common';
import { MassPropertiesRequestProps } from '@bentley/imodeljs-common';
import { MassPropertiesResponseProps } from '@bentley/imodeljs-common';
import { Matrix3d } from '@bentley/geometry-core';
import { Matrix4d } from '@bentley/geometry-core';
import { MeshEdges } from '@bentley/imodeljs-common';
import { MeshPolyline } from '@bentley/imodeljs-common';
import { MeshPolylineList } from '@bentley/imodeljs-common';
import { ModelGeometryChanges } from '@bentley/imodeljs-common';
import { ModelGeometryChangesProps } from '@bentley/imodeljs-common';
import { ModelProps } from '@bentley/imodeljs-common';
import { ModelQueryParams } from '@bentley/imodeljs-common';
import { ModelSelectorProps } from '@bentley/imodeljs-common';
import { MonochromeMode } from '@bentley/imodeljs-common';
import { NativeAppFunctions } from '@bentley/imodeljs-common';
import { ObservableSet } from '@bentley/bentleyjs-core';
import { OctEncodedNormal } from '@bentley/imodeljs-common';
import { OpenBriefcaseProps } from '@bentley/imodeljs-common';
import { OpenMode } from '@bentley/bentleyjs-core';
import { OrbitGtBlobProps } from '@bentley/imodeljs-common';
import { OrbitGtDataManager } from '@bentley/orbitgt-core';
import { OrderedComparator } from '@bentley/bentleyjs-core';
import { OrderedId64Array } from '@bentley/bentleyjs-core';
import { PackedFeatureTable } from '@bentley/imodeljs-common';
import { ParseResults } from '@bentley/ui-abstract';
import { ParserSpec } from '@bentley/imodeljs-quantity';
import { Path } from '@bentley/geometry-core';
import { PlacementProps } from '@bentley/imodeljs-common';
import { PlanarClipMaskProps } from '@bentley/imodeljs-common';
import { PlanarClipMaskSettings } from '@bentley/imodeljs-common';
import { Plane3dByOriginAndUnitNormal } from '@bentley/geometry-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { Point4d } from '@bentley/geometry-core';
import { PointWithStatus } from '@bentley/imodeljs-common';
import { Polyface } from '@bentley/geometry-core';
import { PolyfaceVisitor } from '@bentley/geometry-core';
import { PolylineData } from '@bentley/imodeljs-common';
import { PolylineEdgeArgs } from '@bentley/imodeljs-common';
import { PolylineFlags } from '@bentley/imodeljs-common';
import { PolylineTypeFlags } from '@bentley/imodeljs-common';
import { PrimaryTileTreeId } from '@bentley/imodeljs-common';
import { ProgressCallback } from '@bentley/itwin-client';
import { PropertyDescription } from '@bentley/ui-abstract';
import { QParams2d } from '@bentley/imodeljs-common';
import { QParams3d } from '@bentley/imodeljs-common';
import { QPoint2d } from '@bentley/imodeljs-common';
import { QPoint2dList } from '@bentley/imodeljs-common';
import { QPoint3d } from '@bentley/imodeljs-common';
import { QPoint3dList } from '@bentley/imodeljs-common';
import { QuantityParseResult } from '@bentley/imodeljs-quantity';
import { QueryLimit } from '@bentley/imodeljs-common';
import { QueryPriority } from '@bentley/imodeljs-common';
import { QueryQuota } from '@bentley/imodeljs-common';
import { QueryResponse } from '@bentley/imodeljs-common';
import { Range1d } from '@bentley/geometry-core';
import { Range1dProps } from '@bentley/geometry-core';
import { Range2d } from '@bentley/geometry-core';
import { Range3d } from '@bentley/geometry-core';
import { Range3dProps } from '@bentley/geometry-core';
import { Ray3d } from '@bentley/geometry-core';
import { ReadonlySortedArray } from '@bentley/bentleyjs-core';
import { RelatedElement } from '@bentley/imodeljs-common';
import { RelativePosition } from '@bentley/ui-abstract';
import { RemoveFunction } from '@bentley/imodeljs-common';
import { RenderMaterial } from '@bentley/imodeljs-common';
import { RenderSchedule } from '@bentley/imodeljs-common';
import { RenderTexture } from '@bentley/imodeljs-common';
import { RequestBasicCredentials } from '@bentley/itwin-client';
import { RequestOptions } from '@bentley/itwin-client';
import { Response } from '@bentley/itwin-client';
import { RgbColor } from '@bentley/imodeljs-common';
import { RpcInterfaceDefinition } from '@bentley/imodeljs-common';
import { RpcRoutingToken } from '@bentley/imodeljs-common';
import { SectionDrawingViewProps } from '@bentley/imodeljs-common';
import { SettingsAdmin } from '@bentley/product-settings-client';
import { SheetProps } from '@bentley/imodeljs-common';
import { SilhouetteEdgeArgs } from '@bentley/imodeljs-common';
import { SkyBoxProps } from '@bentley/imodeljs-common';
import { SkyCubeProps } from '@bentley/imodeljs-common';
import { SmoothTransformBetweenFrusta } from '@bentley/geometry-core';
import { SnapRequestProps } from '@bentley/imodeljs-common';
import { SnapResponseProps } from '@bentley/imodeljs-common';
import { SolarShadowSettings } from '@bentley/imodeljs-common';
import { SortedArray } from '@bentley/bentleyjs-core';
import { SpatialClassificationProps } from '@bentley/imodeljs-common';
import { SpatialViewDefinitionProps } from '@bentley/imodeljs-common';
import { StandaloneOpenOptions } from '@bentley/imodeljs-common';
import { StopWatch } from '@bentley/bentleyjs-core';
import { StorageValue } from '@bentley/imodeljs-common';
import { StringifiedClipVector } from '@bentley/geometry-core';
import { StrokeOptions } from '@bentley/geometry-core';
import { SubCategoryAppearance } from '@bentley/imodeljs-common';
import { SubCategoryOverride } from '@bentley/imodeljs-common';
import { SubLayerId } from '@bentley/imodeljs-common';
import { SyncMode } from '@bentley/imodeljs-common';
import { TelemetryManager } from '@bentley/telemetry-client';
import { TerrainProviderName } from '@bentley/imodeljs-common';
import { TextureLoadProps } from '@bentley/imodeljs-common';
import { TextureMapping } from '@bentley/imodeljs-common';
import { ThematicDisplay } from '@bentley/imodeljs-common';
import { ThematicDisplaySensor } from '@bentley/imodeljs-common';
import { ThematicDisplaySensorSettings } from '@bentley/imodeljs-common';
import { ThumbnailProps } from '@bentley/imodeljs-common';
import { TileProps } from '@bentley/imodeljs-common';
import { TileReadStatus } from '@bentley/imodeljs-common';
import { Transform } from '@bentley/geometry-core';
import { TransformProps } from '@bentley/geometry-core';
import { TransientIdSequence } from '@bentley/bentleyjs-core';
import { Tweens } from '@bentley/imodeljs-common';
import { UiAdmin } from '@bentley/ui-abstract';
import { UnitConversion } from '@bentley/imodeljs-quantity';
import { UnitProps } from '@bentley/imodeljs-quantity';
import { UnitsProvider } from '@bentley/imodeljs-quantity';
import { UsageLoggingClient } from '@bentley/usage-logging-client';
import { UsageType } from '@bentley/usage-logging-client';
import { User } from 'oidc-client';
import { UserManagerSettings } from 'oidc-client';
import { Vector2d } from '@bentley/geometry-core';
import { Vector3d } from '@bentley/geometry-core';
import { ViewAttachmentProps } from '@bentley/imodeljs-common';
import { ViewDefinition2dProps } from '@bentley/imodeljs-common';
import { ViewDefinition3dProps } from '@bentley/imodeljs-common';
import { ViewDefinitionProps } from '@bentley/imodeljs-common';
import { ViewDetails } from '@bentley/imodeljs-common';
import { ViewDetails3d } from '@bentley/imodeljs-common';
import { ViewFlagOverrides } from '@bentley/imodeljs-common';
import { ViewFlags } from '@bentley/imodeljs-common';
import { ViewQueryParams } from '@bentley/imodeljs-common';
import { ViewStateProps } from '@bentley/imodeljs-common';
import { WebGLContext } from '@bentley/webgl-compatibility';
import { WebGLExtensionName } from '@bentley/webgl-compatibility';
import { WebGLRenderCompatibilityInfo } from '@bentley/webgl-compatibility';
import { XAndY } from '@bentley/geometry-core';
import { XYAndZ } from '@bentley/geometry-core';
import { XYZ } from '@bentley/geometry-core';
import { XYZProps } from '@bentley/geometry-core';
import { YawPitchRollAngles } from '@bentley/geometry-core';

// @internal
export class AccuDraw {
    // (undocumented)
    accountForAuxRotationPlane(rot: ThreeAxes, plane: RotationMode): void;
    // (undocumented)
    protected _acsPickId?: string;
    // (undocumented)
    activate(): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, fromSnap: boolean): boolean;
    // (undocumented)
    alwaysShowCompass: boolean;
    // (undocumented)
    angleLock(): void;
    // (undocumented)
    protected _animationFrames: number;
    // (undocumented)
    autoFocusFields: boolean;
    // (undocumented)
    autoPointPlacement: boolean;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    axisIndexing: boolean;
    // (undocumented)
    readonly baseAxes: ThreeAxes;
    // (undocumented)
    changeBaseRotationMode(mode: RotationMode): void;
    // (undocumented)
    changeCompassMode(animate?: boolean): void;
    // (undocumented)
    clearTentative(): boolean;
    // (undocumented)
    compassMode: CompassMode;
    // (undocumented)
    protected _compassSizeInches: number;
    // (undocumented)
    contextSensitive: boolean;
    // (undocumented)
    currentState: CurrentState;
    // (undocumented)
    currentView?: ScreenViewport;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    readonly delta: Vector3d;
    // (undocumented)
    disableForSession(): void;
    // (undocumented)
    distanceIndexing: boolean;
    // (undocumented)
    distanceLock(synchText: boolean, saveInHistory: boolean): void;
    // (undocumented)
    doAutoPoint(index: ItemField, mode: CompassMode): Promise<void>;
    // (undocumented)
    doLockAngle(isSnapped: boolean): void;
    // (undocumented)
    dontMoveFocus: boolean;
    // (undocumented)
    downgradeInactiveState(): boolean;
    // (undocumented)
    enableForSession(): void;
    // (undocumented)
    protected readonly _fillColor: ColorDef;
    // (undocumented)
    protected readonly _fillColorNoFocus: ColorDef;
    // (undocumented)
    fixPointPolar(vp: Viewport): void;
    // (undocumented)
    fixPointRectangular(vp: Viewport): void;
    // (undocumented)
    readonly flags: Flags;
    // (undocumented)
    floatingOrigin: boolean;
    // (undocumented)
    protected readonly _frameColor: ColorDef;
    // (undocumented)
    protected readonly _frameColorNoFocus: ColorDef;
    // (undocumented)
    static getCurrentOrientation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, rMatrix?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    getFieldLock(index: ItemField): boolean;
    // (undocumented)
    getKeyinStatus(index: ItemField): KeyinStatus;
    // (undocumented)
    getRotation(rMatrix?: Matrix3d): Matrix3d;
    // (undocumented)
    static getSnapRotation(snap: SnapDetail, currentVp: Viewport | undefined, out?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    static getStandardRotation(nStandard: StandardViewId, vp: Viewport | undefined, useACS: boolean, out?: Matrix3d): Matrix3d;
    // (undocumented)
    getValueByIndex(index: ItemField): number;
    grabInputFocus(): void;
    // (undocumented)
    hardConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    get hasInputFocus(): boolean;
    // (undocumented)
    protected readonly _indexColor: ColorDef;
    // (undocumented)
    indexed: LockedStates;
    // (undocumented)
    protected _indexToleranceInches: number;
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    get isDeactivated(): boolean;
    // (undocumented)
    get isEnabled(): boolean;
    // (undocumented)
    get isInactive(): boolean;
    // (undocumented)
    isZLocked(vp: Viewport): boolean;
    // (undocumented)
    readonly lastAxes: ThreeAxes;
    // (undocumented)
    locked: LockedStates;
    // (undocumented)
    newFocus: ItemField;
    // (undocumented)
    onBeginDynamics(): boolean;
    // (undocumented)
    onCompassModeChange(): void;
    // (undocumented)
    onEndDynamics(): boolean;
    // (undocumented)
    onFieldLockChange(_index: ItemField): void;
    // (undocumented)
    onFieldValueChange(_index: ItemField): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    onInputCollectorExit(): boolean;
    // (undocumented)
    onInputCollectorInstall(): boolean;
    onMotion(_ev: BeButtonEvent): void;
    // (undocumented)
    onPostButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPrimitiveToolInstall(): boolean;
    // (undocumented)
    onRotationModeChange(): void;
    // (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // (undocumented)
    onSnap(snap: SnapDetail): boolean;
    // (undocumented)
    onTentative(): boolean;
    // (undocumented)
    onViewToolExit(): boolean;
    // (undocumented)
    onViewToolInstall(): boolean;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly planePt: Point3d;
    // (undocumented)
    readonly point: Point3d;
    // (undocumented)
    processFieldInput(index: ItemField, input: string, synchText: boolean): Promise<void>;
    // (undocumented)
    processHints(): void;
    // (undocumented)
    readonly published: AccudrawData;
    // (undocumented)
    refreshDecorationsAndDynamics(): void;
    // (undocumented)
    restoreState(stateBuffer: SavedState): void;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    saveCoordinate(index: ItemField, value: number): void;
    // (undocumented)
    readonly savedStateInputCollector: SavedState;
    // (undocumented)
    readonly savedStateViewTool: SavedState;
    // (undocumented)
    saveState(stateBuffer: SavedState): void;
    // (undocumented)
    sendDataPoint(pt: Point3d, viewport: ScreenViewport): Promise<void>;
    // (undocumented)
    setCompassMode(mode: CompassMode): void;
    // (undocumented)
    setContext(flags: AccuDrawFlags, originP?: Point3d, orientationP?: Matrix3d | Vector3d, deltaP?: Vector3d, distanceP?: number, angleP?: number, transP?: Transform): BentleyStatus;
    // (undocumented)
    setContextRotation(rMatrix: Matrix3d, locked: boolean, animate: boolean): void;
    // (undocumented)
    setFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    setFocusItem(_index: ItemField): void;
    // (undocumented)
    setKeyinStatus(index: ItemField, status: KeyinStatus): void;
    // (undocumented)
    setLastPoint(pt: Point3d): void;
    // (undocumented)
    protected setNewFocus(index: ItemField): void;
    // (undocumented)
    setRotationMode(mode: RotationMode): void;
    // (undocumented)
    setValueByIndex(index: ItemField, value: number): void;
    // (undocumented)
    smartKeyin: boolean;
    // (undocumented)
    softConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    stickyZLock: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    unlockAllFields(): void;
    // (undocumented)
    static updateAuxCoordinateSystem(acs: AuxCoordSystemState, vp: Viewport, allViews?: boolean): void;
    // (undocumented)
    updateFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    updateRotation(animate?: boolean, newRotationIn?: Matrix3d): void;
    // (undocumented)
    upgradeToActiveState(): boolean;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    protected readonly _xColor: ColorDef;
    // (undocumented)
    protected readonly _yColor: ColorDef;
    }

// @internal (undocumented)
export class AccuDrawChangeModeTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccudrawData {
    // (undocumented)
    angle: number;
    // (undocumented)
    readonly delta: Point3d;
    // (undocumented)
    distance: number;
    // (undocumented)
    flags: number;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rMatrix: Matrix3d;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    zero(): void;
}

// @internal (undocumented)
export enum AccuDrawFlags {
    // (undocumented)
    AlwaysSetOrigin = 2097156,
    // (undocumented)
    Disable = 4096,
    // (undocumented)
    FixedOrigin = 8,
    // (undocumented)
    Lock_X = 512,
    // (undocumented)
    Lock_Y = 1024,
    // (undocumented)
    Lock_Z = 2048,
    // (undocumented)
    LockAngle = 524288,
    // (undocumented)
    LockDistance = 256,
    // (undocumented)
    OrientACS = 131072,
    // (undocumented)
    OrientDefault = 16384,
    // (undocumented)
    RedrawCompass = 4194304,
    // (undocumented)
    SetDistance = 128,
    // (undocumented)
    SetFocus = 32768,
    // (undocumented)
    SetModePolar = 1,
    // (undocumented)
    SetModeRect = 2,
    // (undocumented)
    SetNormal = 64,
    // (undocumented)
    SetOrigin = 4,
    // (undocumented)
    SetRMatrix = 16,
    // (undocumented)
    SetXAxis = 32,
    // (undocumented)
    SetXAxis2 = 262144,
    // (undocumented)
    SmartRotation = 16777216,
    // (undocumented)
    UpdateRotation = 8388608
}

// @beta
export class AccuDrawHintBuilder {
    // (undocumented)
    static activate(): void;
    // (undocumented)
    static deactivate(): void;
    // (undocumented)
    enableSmartRotation: boolean;
    sendHints(activate?: boolean): boolean;
    // (undocumented)
    setAngle(angle: number): void;
    // (undocumented)
    setDistance(distance: number): void;
    // (undocumented)
    setLockAngle: boolean;
    // (undocumented)
    setLockDistance: boolean;
    // (undocumented)
    setLockX: boolean;
    // (undocumented)
    setLockY: boolean;
    // (undocumented)
    setLockZ: boolean;
    // (undocumented)
    setModePolar(): void;
    // (undocumented)
    setModeRectangular(): void;
    // (undocumented)
    setNormal(normal: Vector3d): void;
    // (undocumented)
    setOrigin(origin: Point3d): void;
    // (undocumented)
    setOriginAlways: boolean;
    // (undocumented)
    setOriginFixed: boolean;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    setXAxis(xAxis: Vector3d): void;
    // (undocumented)
    setXAxis2(xAxis: Vector3d): void;
}

// @internal (undocumented)
export class AccuDrawRotateAxesTool extends AccuDrawShortcutsTool {
    constructor(aboutCurrentZ?: boolean);
    // (undocumented)
    aboutCurrentZ: boolean;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    protected _immediateMode: boolean;
    // (undocumented)
    static get maxArgs(): number;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    parseAndRun(...args: any[]): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateCycleTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    moveOrigin: boolean;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class AccuDrawRotateFrontTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateSideTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateTopTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawRotateViewTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockAngleTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockDistanceTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockSmartTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockXTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockYTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetLockZTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class AccuDrawSetOriginTool extends Tool {
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class AccuDrawShortcuts {
    // (undocumented)
    static alignView(): void;
    // (undocumented)
    static changeCompassMode(): void;
    // (undocumented)
    static defineACSByElement(): void;
    // (undocumented)
    static defineACSByPoints(): void;
    // (undocumented)
    static getACS(acsName: string | undefined, useOrigin: boolean, useRotation: boolean): BentleyStatus;
    // (undocumented)
    static itemFieldAcceptInput(index: ItemField, str: string): Promise<void>;
    // (undocumented)
    static itemFieldLockToggle(index: ItemField): void;
    // (undocumented)
    static itemFieldNavigate(index: ItemField, str: string, forward: boolean): Promise<void>;
    // (undocumented)
    static itemFieldNewInput(index: ItemField): void;
    // (undocumented)
    static itemFieldUnlockAll(): void;
    // (undocumented)
    static itemRotationModeChange(rotation: RotationMode): void;
    // (undocumented)
    static lockAngle(): void;
    // (undocumented)
    static lockDistance(): void;
    // (undocumented)
    lockIndex(): void;
    // (undocumented)
    static lockSmart(): void;
    // (undocumented)
    static lockX(): void;
    // (undocumented)
    static lockY(): void;
    // (undocumented)
    static lockZ(): void;
    // (undocumented)
    static processPendingHints(): void;
    // @internal
    static processShortcutKey(keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    static requestInputFocus(): void;
    // (undocumented)
    static rotate90(axis: number): void;
    // (undocumented)
    static rotateAxes(aboutCurrentZ: boolean): void;
    // (undocumented)
    static rotateAxesByPoint(isSnapped: boolean, aboutCurrentZ: boolean): boolean;
    // (undocumented)
    static rotateCycle(): void;
    // (undocumented)
    static rotateToACS(): void;
    // (undocumented)
    static rotateToBase(): void;
    // (undocumented)
    static rotateToElement(): void;
    // (undocumented)
    static setOrigin(explicitOrigin?: Point3d): void;
    // (undocumented)
    static setStandardRotation(rotation: RotationMode): void;
    // (undocumented)
    static updateACSByPoints(acs: AuxCoordSystemState, vp: Viewport, points: Point3d[], isDynamics: boolean): boolean;
    // (undocumented)
    static writeACS(_acsName: string): BentleyStatus;
}

// @public
export class AccuSnap implements Decorator {
    // @internal (undocumented)
    adjustPointIfHot(pt: Point3d, view: Viewport): void;
    readonly areFlashed: Set<Viewport>;
    aSnapHits?: HitList<HitDetail>;
    clear(): void;
    // @internal (undocumented)
    clearIfElement(sourceId: string): void;
    // @internal (undocumented)
    clearToolTip(ev?: BeButtonEvent): void;
    readonly cross: SpriteLocation;
    currHit?: HitDetail;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    destroy(): void;
    // @internal (undocumented)
    displayToolTip(viewPt: XAndY, vp: ScreenViewport, uorPt?: Point3d): void;
    enableLocate(yesNo: boolean): void;
    enableSnap(yesNo: boolean): void;
    // @internal (undocumented)
    erase(): void;
    readonly errorIcon: SpriteLocation;
    errorKey?: string;
    explanation?: string;
    getActiveSnapModes(): SnapMode[];
    // @internal (undocumented)
    getCurrSnapDetail(): SnapDetail | undefined;
    // @internal (undocumented)
    getHitAndList(holder: HitListHolder): HitDetail | undefined;
    readonly icon: SpriteLocation;
    // @internal (undocumented)
    intersectXY(tpSnap: SnapDetail, second: SnapDetail): IntersectDetail | undefined;
    get isActive(): boolean;
    get isHot(): boolean;
    get isLocateEnabled(): boolean;
    get isSnapEnabled(): boolean;
    get isSnapEnabledByUser(): boolean;
    get keypointDivisor(): number;
    readonly needFlash: Set<Viewport>;
    // @internal
    onEnabledStateChange(_isEnabled: boolean, _wasEnabled: boolean): void;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    onMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // @internal
    onStartTool(): void;
    // @internal (undocumented)
    onTouchCancel(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchEnd(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchMove(ev: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchStart(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // @internal
    reEvaluate(): Promise<void>;
    // @internal (undocumented)
    static requestSnap(thisHit: HitDetail, snapModes: SnapMode[], hotDistanceInches: number, keypointDivisor: number, hitList?: HitList<HitDetail>, out?: LocateResponse): Promise<SnapDetail | undefined>;
    // @internal
    resetButton(): Promise<SnapStatus>;
    // @internal (undocumented)
    setCurrHit(newHit?: HitDetail): void;
    // @internal (undocumented)
    protected _settings: AccuSnap.Settings;
    // @internal (undocumented)
    suppress(doSuppress: boolean): number;
    // @internal (undocumented)
    suspend(doSuspend: boolean): void;
    // @internal
    synchSnapMode(): void;
    // @internal (undocumented)
    readonly toolState: AccuSnap.ToolState;
    // @internal (undocumented)
    touchCursor?: TouchCursor;
    }

// @public (undocumented)
export namespace AccuSnap {
    // (undocumented)
    export class Settings {
        // (undocumented)
        enableFlag: boolean;
        // (undocumented)
        hiliteColdHits: boolean;
        // (undocumented)
        hotDistanceFactor: number;
        // (undocumented)
        searchDistance: number;
        // (undocumented)
        stickyFactor: number;
        // (undocumented)
        toolTip: boolean;
        // (undocumented)
        toolTipDelay: BeDuration;
    }
    // (undocumented)
    export class ToolState {
        // (undocumented)
        clone(): ToolState;
        // (undocumented)
        enabled: boolean;
        // (undocumented)
        locate: boolean;
        // (undocumented)
        setFrom(other: ToolState): void;
        // (undocumented)
        suspended: number;
    }
}

// @public (undocumented)
export enum ACSDisplayOptions {
    // (undocumented)
    Active = 1,
    // (undocumented)
    CheckVisible = 8,
    // (undocumented)
    Deemphasized = 2,
    // (undocumented)
    Dynamics = 16,
    // (undocumented)
    Hilite = 4,
    // (undocumented)
    None = 0
}

// @public (undocumented)
export enum ACSType {
    // (undocumented)
    Cylindrical = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Rectangular = 1,
    // (undocumented)
    Spherical = 3
}

// @public
export class ActivityMessageDetails {
    constructor(showProgressBar: boolean, showPercentInMessage: boolean, supportsCancellation: boolean, showDialogInitially?: boolean);
    onActivityCancelled(): void;
    onActivityCompleted(): void;
    // (undocumented)
    showDialogInitially: boolean;
    // (undocumented)
    showPercentInMessage: boolean;
    // (undocumented)
    showProgressBar: boolean;
    // (undocumented)
    supportsCancellation: boolean;
    // (undocumented)
    wasCancelled: boolean;
}

// @public
export enum ActivityMessageEndReason {
    // (undocumented)
    Cancelled = 1,
    // (undocumented)
    Completed = 0
}

// @internal (undocumented)
export function addRangeGraphic(builder: GraphicBuilder, range: Range3d, is2d: boolean): void;

// @beta
export class AngleDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export class AnimatedTreeReference extends PrimaryTreeReference {
    // (undocumented)
    protected computeBaseTransform(tree: TileTree): Transform;
}

// @internal
export class AnimationBranchState {
    constructor(transform?: Transform, clip?: RenderClipVolume, omit?: boolean);
    // (undocumented)
    readonly clip?: RenderClipVolume;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly omit?: boolean;
    // (undocumented)
    readonly transform?: Transform;
}

// @internal
export type AnimationBranchStates = Map<string, AnimationBranchState>;

// @beta
export interface Animator {
    animate(): boolean;
    interrupt(): void;
}

// @public
export interface AppearanceOverrideProps {
    // (undocumented)
    color?: ColorDefProps;
    // (undocumented)
    ids?: Id64Array;
    // (undocumented)
    overrideType?: FeatureOverrideType;
}

// @internal (undocumented)
export enum ArcGisErrorCode {
    // (undocumented)
    InvalidCredentials = 401,
    // (undocumented)
    InvalidToken = 498,
    // (undocumented)
    NoTokenService = 1001,
    // (undocumented)
    TokenRequired = 499,
    // (undocumented)
    UnknownError = 1000
}

// @internal (undocumented)
export interface ArcGisGenerateTokenOptions {
    // (undocumented)
    client: ArcGisTokenClientType;
    // (undocumented)
    expiration?: number;
    // (undocumented)
    ip?: string;
    // (undocumented)
    referer?: string;
}

// @internal (undocumented)
export class ArcGISMapLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    protected get _filterByCartoRange(): boolean;
    // (undocumented)
    protected getLayerString(prefix?: string): string;
    // (undocumented)
    getLogo(_vp: ScreenViewport): HTMLTableRowElement;
    // (undocumented)
    getToolTip(strings: string[], quadId: QuadId, carto: Cartographic, tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    serviceJson: any;
    // (undocumented)
    protected _testChildAvailability(tile: ImageryMapTile, resolveChildren: () => void): void;
    // (undocumented)
    uintToString(uintArray: any): {
        type: "Buffer";
        data: any[];
    };
}

// @internal (undocumented)
export interface ArcGisToken {
    // (undocumented)
    expires: number;
    // (undocumented)
    ssl: boolean;
    // (undocumented)
    token: string;
}

// @internal (undocumented)
export enum ArcGisTokenClientType {
    // (undocumented)
    ip = 0,
    // (undocumented)
    referer = 1,
    // (undocumented)
    requestIp = 2
}

// @internal (undocumented)
export class ArcGisTokenGenerator {
    // (undocumented)
    static fetchTokenServiceUrl(esriRestServiceUrl: string): Promise<string | undefined>;
    // (undocumented)
    static formEncode(str: string): string;
    // (undocumented)
    generate(esriRestServiceUrl: string, userName: string, password: string, options: ArcGisGenerateTokenOptions): Promise<any>;
    // (undocumented)
    static getTokenServiceFromInfoJson(json: any): string | undefined;
    // (undocumented)
    getTokenServiceUrl(baseUrl: string): Promise<string | undefined>;
    // (undocumented)
    static rfc1738Encode(str: string): string;
    }

// @internal (undocumented)
export class ArcGisTokenManager {
    // (undocumented)
    static getToken(esriRestServiceUrl: string, userName: string, password: string, options: ArcGisGenerateTokenOptions): Promise<any>;
    // (undocumented)
    static invalidateToken(esriRestServiceUrl: string, userName: string): boolean;
    }

// @internal (undocumented)
export class ArcGisUtilities {
    // (undocumented)
    static getEndpoint(url: string): Promise<any | undefined>;
    // (undocumented)
    static getFootprintJson(url: string, credentials?: RequestBasicCredentials): Promise<any>;
    // (undocumented)
    static getNationalMapSources(): Promise<MapLayerSource[]>;
    // (undocumented)
    static getServiceDirectorySources(url: string, baseUrl?: string): Promise<MapLayerSource[]>;
    // (undocumented)
    static getServiceJson(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<any>;
    // (undocumented)
    static getSourcesFromQuery(range?: MapCartoRectangle, url?: string): Promise<MapLayerSource[]>;
    // (undocumented)
    static hasTokenError(response: Response): boolean;
    // (undocumented)
    static validateSource(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal
export function areaToEyeHeight(view3d: ViewState3d, area: GlobalLocationArea, offset?: number): number;

// @internal
export function areaToEyeHeightFromGcs(view3d: ViewState3d, area: GlobalLocationArea, offset?: number): Promise<number>;

// @beta
export type AsyncFunction = (...args: any) => Promise<any>;

// @beta
export type AsyncMethodsOf<T> = {
    [P in keyof T]: T[P] extends AsyncFunction ? P : never;
}[keyof T];

// @public
export class AuthorizedFrontendRequestContext extends AuthorizedClientRequestContext {
    constructor(accessToken: AccessToken, activityId?: string);
    static create(activityId?: string): Promise<AuthorizedFrontendRequestContext>;
}

// @public
export class AuxCoordSystem2dState extends AuxCoordSystemState implements AuxCoordSystem2dProps {
    constructor(props: AuxCoordSystem2dProps, iModel: IModelConnection);
    // (undocumented)
    angle: number;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem2dProps;
}

// @public
export class AuxCoordSystem3dState extends AuxCoordSystemState implements AuxCoordSystem3dProps {
    constructor(props: AuxCoordSystem3dProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    pitch: number;
    // (undocumented)
    roll: number;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem3dProps;
    // (undocumented)
    yaw: number;
}

// @public
export class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export abstract class AuxCoordSystemState extends ElementState implements AuxCoordSystemProps {
    constructor(props: AuxCoordSystemProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    static createNew(acsName: string, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    description?: string;
    // (undocumented)
    display(context: DecorateContext, options: ACSDisplayOptions): void;
    // (undocumented)
    drawGrid(context: DecorateContext): void;
    // (undocumented)
    static fromProps(props: AuxCoordSystemProps, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    abstract getOrigin(result?: Point3d): Point3d;
    abstract getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    get is3d(): boolean;
    static isOriginInView(drawOrigin: Point3d, viewport: Viewport, adjustOrigin: boolean): boolean;
    // (undocumented)
    isValidForView(view: ViewState): boolean;
    // (undocumented)
    abstract setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    abstract setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystemProps;
    // (undocumented)
    type: number;
}

// @internal (undocumented)
export class AzureMapsLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(y: number, x: number, zoom: number): Promise<string>;
    // (undocumented)
    getLogo(_vp: ScreenViewport): HTMLTableRowElement;
}

// @internal
export class B3dmReader extends GltfReader {
    // (undocumented)
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, tileCenter: Point3d, transformToRoot?: Transform, isCanceled?: ShouldAbortReadGltf, idMap?: BatchedTileIdMap): B3dmReader | undefined;
    // (undocumented)
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readBatchTable(mesh: Mesh, json: any): void;
    }

// @internal
export class BackgroundMapGeometry {
    constructor(_bimElevationBias: number, globeMode: GlobeMode, _iModel: IModelConnection);
    // (undocumented)
    addFrustumDecorations(builder: GraphicBuilder, frustum: Frustum): void;
    // (undocumented)
    readonly cartesianChordHeight: number;
    // (undocumented)
    readonly cartesianDiagonal: number;
    // (undocumented)
    readonly cartesianPlane: Plane3dByOriginAndUnitNormal;
    // (undocumented)
    readonly cartesianRange: Range3d;
    // (undocumented)
    readonly cartesianTransitionRange: Range3d;
    // (undocumented)
    cartographicToDb(cartographic: Cartographic, result?: Point3d): Point3d;
    // (undocumented)
    cartographicToDbFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    // (undocumented)
    dbToCartographic(db: XYAndZ, result?: Cartographic): Cartographic;
    // (undocumented)
    dbToCartographicFromGcs(db: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // (undocumented)
    readonly geometry: Plane3dByOriginAndUnitNormal | Ellipsoid;
    // (undocumented)
    static getCartesianRange(iModel: IModelConnection, result?: Range3d): Range3d;
    // (undocumented)
    static getCartesianTransitionDistance(iModel: IModelConnection): number;
    // (undocumented)
    getEarthEllipsoid(radiusOffset?: number): Ellipsoid;
    // (undocumented)
    getFrustumIntersectionDepthRange(frustum: Frustum, bimRange: Range3d, heightRange?: Range1d, doGlobalScope?: boolean): Range1d;
    // (undocumented)
    getPlane(offset?: number): Plane3dByOriginAndUnitNormal;
    // (undocumented)
    getPointHeight(point: Point3d): number | undefined;
    // (undocumented)
    getRayIntersection(ray: Ray3d, positiveOnly: boolean): Ray3d | undefined;
    // (undocumented)
    readonly globeMatrix: Matrix3d;
    // (undocumented)
    readonly globeMode: GlobeMode;
    // (undocumented)
    readonly globeOrigin: Point3d;
    // (undocumented)
    static maxCartesianDistance: number;
    // (undocumented)
    readonly maxGeometryChordHeight: number;
    }

// @internal (undocumented)
export class BackgroundMapLocation {
    // (undocumented)
    getMapEcefToDb(bimElevationBias: number): Transform;
    // (undocumented)
    initialize(iModel: IModelConnection): Promise<void>;
    // (undocumented)
    onEcefChanged(ecefLocation: EcefLocation): void;
}

// @internal
export class BatchedTileIdMap {
    constructor(iModel: IModelConnection);
    getBatchId(properties: any): Id64String;
    getBatchProperties(id: Id64String): any;
    }

// @public (undocumented)
export enum BeButton {
    // (undocumented)
    Data = 0,
    // (undocumented)
    Middle = 2,
    // (undocumented)
    Reset = 1
}

// @public
export class BeButtonEvent implements BeButtonEventProps {
    constructor(props?: BeButtonEventProps);
    button: BeButton;
    clone(): this;
    coordsFrom: CoordSource;
    init(props: BeButtonEventProps): void;
    inputSource: InputSource;
    invalidate(): void;
    get isAltKey(): boolean;
    get isControlKey(): boolean;
    isDoubleClick: boolean;
    isDown: boolean;
    isDragging: boolean;
    get isShiftKey(): boolean;
    get isValid(): boolean;
    keyModifiers: BeModifierKeys;
    // @internal
    get movement(): XAndY | undefined;
    set movement(mov: XAndY | undefined);
    get point(): Point3d;
    set point(pt: Point3d);
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    setFrom(src: BeButtonEvent): this;
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    viewport?: ScreenViewport;
}

// @public
export interface BeButtonEventProps {
    button?: BeButton;
    coordsFrom?: CoordSource;
    inputSource?: InputSource;
    isDoubleClick?: boolean;
    isDown?: boolean;
    isDragging?: boolean;
    // (undocumented)
    keyModifiers?: BeModifierKeys;
    point?: Point3d;
    rawPoint?: Point3d;
    viewPoint?: Point3d;
    viewport?: ScreenViewport;
}

// @public (undocumented)
export class BeButtonState {
    // (undocumented)
    get downRawPt(): Point3d;
    set downRawPt(pt: Point3d);
    // (undocumented)
    downTime: number;
    // (undocumented)
    get downUorPt(): Point3d;
    set downUorPt(pt: Point3d);
    // (undocumented)
    init(downUorPt: Point3d, downRawPt: Point3d, downTime: number, isDown: boolean, isDoubleClick: boolean, isDragging: boolean, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    isDoubleClick: boolean;
    // (undocumented)
    isDown: boolean;
    // (undocumented)
    isDragging: boolean;
}

// @public
export enum BeModifierKeys {
    // (undocumented)
    Alt = 4,
    // (undocumented)
    Control = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Shift = 2
}

// @public
export class BeTouchEvent extends BeButtonEvent implements BeTouchEventProps {
    constructor(props: BeTouchEventProps);
    // (undocumented)
    static findTouchById(list: TouchList, id: number): Touch | undefined;
    // (undocumented)
    static getTouchListCentroid(list: TouchList, vp: ScreenViewport): Point2d | undefined;
    // (undocumented)
    static getTouchPosition(touch: Touch, vp: ScreenViewport): Point2d;
    // (undocumented)
    get isDoubleTap(): boolean;
    // (undocumented)
    get isSingleTap(): boolean;
    // (undocumented)
    get isSingleTouch(): boolean;
    // (undocumented)
    get isTwoFingerTap(): boolean;
    // (undocumented)
    get isTwoFingerTouch(): boolean;
    // (undocumented)
    setFrom(src: BeTouchEvent): this;
    // (undocumented)
    tapCount: number;
    // (undocumented)
    get touchCount(): number;
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export interface BeTouchEventProps extends BeButtonEventProps {
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export class BeWheelEvent extends BeButtonEvent implements BeWheelEventProps {
    constructor(props?: BeWheelEventProps);
    // (undocumented)
    setFrom(src: BeWheelEvent): this;
    // (undocumented)
    time: number;
    // (undocumented)
    wheelDelta: number;
}

// @public
export interface BeWheelEventProps extends BeButtonEventProps {
    // (undocumented)
    time?: number;
    // (undocumented)
    wheelDelta?: number;
}

// @internal (undocumented)
export class BingElevationProvider {
    constructor();
    // (undocumented)
    getGeodeticToSeaLevelOffset(point: Point3d, iModel: IModelConnection): Promise<number>;
    // (undocumented)
    getGraphic(latLongRange: Range2d, corners: Point3d[], groundBias: number, texture: RenderTexture, system: RenderSystem): Promise<RenderGraphic | undefined>;
    // (undocumented)
    getHeight(carto: Cartographic, geodetic?: boolean): Promise<any>;
    // (undocumented)
    getHeightAverage(iModel: IModelConnection): Promise<number>;
    // (undocumented)
    getHeightRange(iModel: IModelConnection): Promise<Range1d>;
    // (undocumented)
    getHeights(range: Range2d): Promise<any>;
    // (undocumented)
    getHeightValue(point: Point3d, iModel: IModelConnection, geodetic?: boolean): Promise<number>;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
    }

// @internal (undocumented)
export class BingLocationProvider {
    constructor();
    // (undocumented)
    doLocalSearchByRadius(_center: Cartographic, _radius: number): Promise<{} | undefined>;
    // (undocumented)
    getLocation(query: string): Promise<GlobalLocation | undefined>;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
}

// @internal (undocumented)
export class BingMapsImageryLayerProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    getLogo(vp: ScreenViewport): HTMLTableRowElement | undefined;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get tileHeight(): number;
    // (undocumented)
    get tileWidth(): number;
    }

// @public
export class BlankConnection extends IModelConnection {
    close(): Promise<void>;
    get contextId(): GuidString | undefined;
    set contextId(contextId: GuidString | undefined);
    static create(props: BlankConnectionProps): BlankConnection;
    get iModelId(): undefined;
    // (undocumented)
    isBlankConnection(): this is BlankConnection;
    get isClosed(): boolean;
}

// @public
export interface BlankConnectionProps {
    contextId?: GuidString;
    extents: Range3dProps;
    globalOrigin?: XYZProps;
    location: Cartographic | EcefLocationProps;
    name: string;
}

// @public
export class BriefcaseConnection extends IModelConnection {
    close(): Promise<void>;
    get contextId(): GuidString;
    // @beta (undocumented)
    hasPendingTxns(): Promise<boolean>;
    get iModelId(): GuidString;
    // (undocumented)
    isBriefcaseConnection(): this is BriefcaseConnection;
    get isClosed(): boolean;
    // (undocumented)
    protected _isClosed?: boolean;
    static openFile(briefcaseProps: OpenBriefcaseProps): Promise<BriefcaseConnection>;
    // @internal
    static openStandalone(filePath: string, openMode?: OpenMode, opts?: StandaloneOpenOptions): Promise<BriefcaseConnection>;
    // @beta (undocumented)
    pullAndMergeChanges(): Promise<IModelConnectionProps>;
    // @beta (undocumented)
    pushChanges(description: string): Promise<IModelConnectionProps>;
    // @beta (undocumented)
    saveChanges(description?: string): Promise<void>;
}

// @beta
export abstract class BriefcaseNotificationHandler extends NotificationHandler {
    constructor(_key: string);
    // (undocumented)
    abstract get briefcaseChannelName(): string;
    // (undocumented)
    get channelName(): string;
    }

// @internal (undocumented)
export type CachedDecoration = {
    type: "graphic";
    graphicType: GraphicType;
    graphicOwner: RenderGraphicOwner;
} | {
    type: "canvas";
    canvasDecoration: CanvasDecoration;
    atFront: boolean;
} | {
    type: "html";
    htmlElement: HTMLElement;
};

// @internal
export interface CachedIModelCoordinatesResponseProps {
    missing?: XYZProps[];
    result: Array<PointWithStatus | undefined>;
}

// @internal (undocumented)
export function calculateEcefToDbTransformAtLocation(originIn: Point3d, iModel: IModelConnection): Promise<Transform | undefined>;

// @public
export interface CanvasDecoration {
    decorationCursor?: string;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    onMouseButton?(ev: BeButtonEvent): boolean;
    onMouseEnter?(ev: BeButtonEvent): void;
    onMouseLeave?(): void;
    onMouseMove?(ev: BeButtonEvent): void;
    onWheel?(ev: BeWheelEvent): boolean;
    pick?(pt: XAndY): boolean;
    position?: XAndY;
}

// @public
export type CanvasDecorationList = CanvasDecoration[];

// @public
export function canvasToImageBuffer(canvas: HTMLCanvasElement, format?: ImageBufferFormat): ImageBuffer | undefined;

// @public
export function canvasToResizedCanvasWithBars(canvasIn: HTMLCanvasElement, targetSize: Point2d, barSize?: Point2d, barStyle?: string): HTMLCanvasElement;

// @public
export class CategorySelectorState extends ElementState {
    constructor(props: CategorySelectorProps, iModel: IModelConnection);
    addCategories(arg: Id64Arg): void;
    // (undocumented)
    get categories(): Set<string>;
    set categories(categories: Set<string>);
    changeCategoryDisplay(arg: Id64Arg, add: boolean): void;
    // @internal (undocumented)
    static get className(): string;
    dropCategories(arg: Id64Arg): void;
    equalState(other: CategorySelectorState): boolean;
    has(id: Id64String): boolean;
    isCategoryViewed(categoryId: Id64String): boolean;
    get name(): string;
    // @internal (undocumented)
    get observableCategories(): ObservableSet<string>;
    // (undocumented)
    toJSON(): CategorySelectorProps;
}

// @beta
export enum ChangeFlag {
    // (undocumented)
    All = 268435455,
    // (undocumented)
    AlwaysDrawn = 1,
    // (undocumented)
    DisplayStyle = 16,
    // (undocumented)
    FeatureOverrideProvider = 32,
    // (undocumented)
    Initial = 28,
    // (undocumented)
    NeverDrawn = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Overrides = 268435319,
    // (undocumented)
    ViewedCategories = 4,
    // (undocumented)
    ViewedCategoriesPerModel = 64,
    // (undocumented)
    ViewedModels = 8,
    // (undocumented)
    ViewState = 128
}

// @beta
export class ChangeFlags {
    constructor(flags?: ChangeFlag);
    get alwaysDrawn(): boolean;
    areAllSet(flags: ChangeFlag): boolean;
    get areFeatureOverridesDirty(): boolean;
    clear(flags?: ChangeFlag): void;
    get displayStyle(): boolean;
    get featureOverrideProvider(): boolean;
    get hasChanges(): boolean;
    isSet(flags: ChangeFlag): boolean;
    get neverDrawn(): boolean;
    set(flags: ChangeFlag): void;
    // (undocumented)
    setAlwaysDrawn(): void;
    // (undocumented)
    setDisplayStyle(): void;
    // (undocumented)
    setFeatureOverrideProvider(): void;
    // (undocumented)
    setNeverDrawn(): void;
    // (undocumented)
    setViewedCategories(): void;
    // (undocumented)
    setViewedCategoriesPerModel(): void;
    // (undocumented)
    setViewedModels(): void;
    // (undocumented)
    setViewState(): void;
    // (undocumented)
    get value(): ChangeFlag;
    get viewedCategories(): boolean;
    get viewedCategoriesPerModel(): boolean;
    get viewedModels(): boolean;
    get viewState(): boolean;
}

// @public
export interface ChangeViewedModel2dOptions {
    doFit?: boolean;
}

// @alpha
export interface CheckboxFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "checkbox";
    // (undocumented)
    getBool: (props: FormatProps) => boolean;
    // (undocumented)
    setBool: (props: FormatProps, isChecked: boolean) => FormatProps;
}

// @public
export class CheckpointConnection extends IModelConnection {
    close(): Promise<void>;
    get contextId(): GuidString;
    get iModelId(): GuidString;
    isCheckpointConnection(): this is CheckpointConnection;
    get isClosed(): boolean;
    // (undocumented)
    protected _isClosed?: boolean;
    // @deprecated
    static open(contextId: string, iModelId: string, openMode?: OpenMode, version?: IModelVersion): Promise<CheckpointConnection>;
    static openRemote(contextId: string, iModelId: string, version?: IModelVersion): Promise<CheckpointConnection>;
    }

// @alpha
export enum ClipEventType {
    // (undocumented)
    Clear = 3,
    // (undocumented)
    Modify = 2,
    // (undocumented)
    New = 0,
    // (undocumented)
    NewPlane = 1
}

// @public
export class Cluster<T extends Marker> {
    constructor(markers: T[]);
    // (undocumented)
    clusterMarker?: Marker;
    // (undocumented)
    readonly markers: T[];
    // (undocumented)
    readonly rect: ViewRect;
}

// @internal (undocumented)
export enum CompassMode {
    // (undocumented)
    Polar = 0,
    // (undocumented)
    Rectangular = 1
}

// @internal (undocumented)
export enum ContextMode {
    // (undocumented)
    Locked = 0,
    // (undocumented)
    None = 15,
    // (undocumented)
    XAxis = 1,
    // (undocumented)
    XAxis2 = 4,
    // (undocumented)
    YAxis = 2,
    // (undocumented)
    ZAxis = 3
}

// @beta
export class ContextRealityModelState {
    constructor(props: ContextRealityModelProps, iModel: IModelConnection, displayStyle: DisplayStyleState);
    // (undocumented)
    get appearanceOverrides(): FeatureAppearance | undefined;
    set appearanceOverrides(overrides: FeatureAppearance | undefined);
    // (undocumented)
    get classifiers(): SpatialClassifiers | undefined;
    // (undocumented)
    readonly description: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    intersectsProjectExtents(): Promise<boolean>;
    get isGlobal(): boolean;
    // (undocumented)
    matches(other: ContextRealityModelState): boolean;
    // (undocumented)
    matchesNameAndUrl(name: string, url: string): boolean;
    // (undocumented)
    get modelId(): Id64String | undefined;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly orbitGtBlob?: OrbitGtBlobProps;
    // (undocumented)
    get planarClipMask(): PlanarClipMaskState | undefined;
    set planarClipMask(planarClipMask: PlanarClipMaskState | undefined);
    readonly realityDataId?: string;
    // (undocumented)
    toJSON(): ContextRealityModelProps;
    // (undocumented)
    get treeRef(): TileTreeReference;
    // (undocumented)
    readonly url: string;
}

// @public (undocumented)
export enum CoordinateLockOverrides {
    // (undocumented)
    ACS = 2,
    // (undocumented)
    All = 65535,
    // (undocumented)
    Grid = 4,
    // (undocumented)
    None = 0
}

// @public
export enum CoordSource {
    ElemSnap = 3,
    Precision = 1,
    TentativePoint = 2,
    User = 0
}

// @public
export enum CoordSystem {
    Npc = 1,
    View = 0,
    World = 2
}

// @internal (undocumented)
export class CoreTools {
    // (undocumented)
    static namespace: string;
    // (undocumented)
    static outputPromptByKey(key: string): void;
    // (undocumented)
    static tools: string;
    // (undocumented)
    static translate(prompt: string): string;
}

// @internal (undocumented)
export function createClassifierTileTreeReference(classifiers: SpatialClassifiers, classifiedTree: TileTreeReference, iModel: IModelConnection, source: ViewState | DisplayStyleState): SpatialClassifierTileTreeReference;

// @internal
export function createDefaultViewFlagOverrides(options: {
    clipVolume?: boolean;
    shadows?: boolean;
    lighting?: boolean;
    thematic?: false;
}): ViewFlagOverrides;

// @internal (undocumented)
export function createEmptyRenderPlan(): RenderPlan;

// @internal (undocumented)
export function createMaskTreeReference(model: GeometricModelState): TileTreeReference;

// @internal (undocumented)
export function createOrbitGtTileTreeReference(props: OrbitGtTileTree.ReferenceProps): RealityModelTileTree.Reference;

// @internal (undocumented)
export function createPrimaryTileTreeReference(view: ViewState, model: GeometricModelState): TileTreeReference;

// @internal (undocumented)
export function createRealityTileTreeReference(props: RealityModelTileTree.ReferenceProps): RealityModelTileTree.Reference;

// @internal (undocumented)
export function createRenderPlanFromViewport(vp: Viewport): RenderPlan;

// @internal (undocumented)
export class CurrentInputState {
    // (undocumented)
    adjustLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    button: BeButtonState[];
    // (undocumented)
    changeButtonToDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    clearKeyQualifiers(): void;
    // (undocumented)
    clearViewport(vp: Viewport): void;
    // (undocumented)
    fromButton(vp: ScreenViewport, pt: XAndY, source: InputSource, applyLocks: boolean): void;
    // (undocumented)
    fromPoint(vp: ScreenViewport, pt: XAndY, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    get isAltDown(): boolean;
    // (undocumented)
    get isControlDown(): boolean;
    // (undocumented)
    isDragging(button: BeButton): boolean;
    // (undocumented)
    get isShiftDown(): boolean;
    // (undocumented)
    isStartDrag(button: BeButton): boolean;
    // (undocumented)
    lastButton: BeButton;
    // (undocumented)
    lastMotion: Point2d;
    // (undocumented)
    lastTouchStart?: BeTouchEvent;
    // (undocumented)
    lastWheelEvent?: BeWheelEvent;
    // (undocumented)
    onButtonDown(button: BeButton): void;
    // (undocumented)
    onButtonUp(button: BeButton): void;
    // (undocumented)
    onInstallTool(): void;
    // (undocumented)
    onMotion(pt2d: XAndY): void;
    // (undocumented)
    onStartDrag(button: BeButton): void;
    // (undocumented)
    get point(): Point3d;
    set point(pt: Point3d);
    // (undocumented)
    qualifiers: BeModifierKeys;
    // (undocumented)
    get rawPoint(): Point3d;
    set rawPoint(pt: Point3d);
    // (undocumented)
    setKeyQualifiers(ev: MouseEvent | KeyboardEvent | TouchEvent): void;
    // (undocumented)
    toEvent(ev: BeButtonEvent, useSnap: boolean): void;
    // (undocumented)
    toEventFromLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    touchTapCount?: number;
    // (undocumented)
    touchTapTimer?: number;
    // (undocumented)
    updateDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    get viewPoint(): Point3d;
    set viewPoint(pt: Point3d);
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal (undocumented)
export enum CurrentState {
    // (undocumented)
    Active = 3,
    // (undocumented)
    Deactivated = 1,
    // (undocumented)
    Inactive = 2,
    // (undocumented)
    NotEnabled = 0
}

// @alpha
export interface CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "checkbox" | "text" | "select";
    // (undocumented)
    label: string;
}

// @alpha
export interface CustomQuantityTypeDefinition extends QuantityTypeDefinition {
    isCompatibleFormatProps: (formatProps: FormatProps) => boolean;
    primaryPropEditorSpecs?: CustomFormatPropEditorSpec[];
    secondaryPropEditorSpecs?: CustomFormatPropEditorSpec[];
}

// @internal (undocumented)
export class DebugShaderFile {
    constructor(filename: string, src: string, isVS: boolean, isGL: boolean, isUsed: boolean);
    // (undocumented)
    readonly filename: string;
    // (undocumented)
    isGL: boolean;
    // (undocumented)
    isUsed: boolean;
    // (undocumented)
    isVS: boolean;
    // (undocumented)
    readonly src: string;
}

// @public
export class DecorateContext extends RenderContext {
    // @internal
    constructor(vp: ScreenViewport, decorations: Decorations, cache: DecorationsCache);
    addCanvasDecoration(decoration: CanvasDecoration, atFront?: boolean): void;
    addDecoration(type: GraphicType, decoration: RenderGraphic): void;
    addDecorationFromBuilder(builder: GraphicBuilder): void;
    // @internal (undocumented)
    addFromDecorator(decorator: ViewportDecorator): void;
    addHtmlDecoration(decoration: HTMLElement): void;
    createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    // @internal (undocumented)
    drawStandardGrid(gridOrigin: Point3d, rMatrix: Matrix3d, spacing: XAndY, gridsPerRef: number, _isoGrid?: boolean, _fixedRepetitions?: Point2d): void;
    // @deprecated
    get screenViewport(): ScreenViewport;
    setSkyBox(graphic: RenderGraphic): void;
    setViewBackground(graphic: RenderGraphic): void;
    get viewport(): ScreenViewport;
}

// @public
export class Decorations implements IDisposable {
    // (undocumented)
    canvasDecorations?: CanvasDecorationList;
    // (undocumented)
    dispose(): void;
    get normal(): GraphicList | undefined;
    set normal(normal: GraphicList | undefined);
    get skyBox(): RenderGraphic | undefined;
    set skyBox(skyBox: RenderGraphic | undefined);
    get viewBackground(): RenderGraphic | undefined;
    set viewBackground(viewBackground: RenderGraphic | undefined);
    get viewOverlay(): GraphicList | undefined;
    set viewOverlay(viewOverlay: GraphicList | undefined);
    get world(): GraphicList | undefined;
    set world(world: GraphicList | undefined);
    get worldOverlay(): GraphicList | undefined;
    set worldOverlay(worldOverlay: GraphicList | undefined);
    }

// @internal
export class DecorationsCache {
    add(decorator: ViewportDecorator, decoration: CachedDecoration): void;
    clear(): void;
    delete(decorator: ViewportDecorator): void;
    get(decorator: ViewportDecorator): CachedDecoration[] | undefined;
    prohibitRemoval: boolean;
    get size(): number;
}

// @public
export interface Decorator extends ViewportDecorator {
    getDecorationGeometry?(hit: HitDetail): GeometryStreamProps | undefined;
    getDecorationToolTip?(hit: HitDetail): Promise<HTMLElement | string>;
    onDecorationButtonEvent?(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    testDecorationHit?(id: string): boolean;
}

// @internal (undocumented)
export class DefaultViewTouchTool extends ViewManip implements Animator {
    constructor(startEv: BeTouchEvent, ev: BeTouchEvent);
    animate(): boolean;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onStart(ev: BeTouchEvent): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class DefineACSByElementTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateOrientation(snap: SnapDetail, vp: Viewport): boolean;
}

// @internal (undocumented)
export class DefineACSByPointsTool extends AccuDrawShortcutsTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): boolean;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static toolId: string;
}

// @alpha
export interface DepthPointOptions {
    excludeDecorations?: boolean;
    excludeExternalIModels?: boolean;
    excludeNonLocatable?: boolean;
}

// @alpha
export enum DepthPointSource {
    ACS = 5,
    BackgroundMap = 2,
    Geometry = 0,
    Grid = 4,
    GroundPlane = 3,
    Map = 7,
    Model = 1,
    TargetPoint = 6
}

// @public
export interface DepthRangeNpc {
    maximum: number;
    minimum: number;
}

// @alpha
export class DesktopAuthorizationClient implements FrontendAuthorizationClient {
    constructor(clientConfiguration: DesktopAuthorizationClientConfiguration);
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    get hasExpired(): boolean;
    get hasSignedIn(): boolean;
    initialize(requestContext: ClientRequestContext): Promise<void>;
    get isAuthorized(): boolean;
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext): Promise<void>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
}

// @internal
export class DevTools {
    static connectToBackendInstance(tokenProps: IModelRpcProps): DevTools;
    ping(count: number): Promise<PingTestResult>;
    setLogLevel(inLoggerCategory: string, newLevel: LogLevel): Promise<LogLevel | undefined>;
    stats(options?: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(): Promise<any>;
}

// @beta
export class DisclosedTileTreeSet implements Iterable<TileTree> {
    [Symbol.iterator](): Iterator<TileTree>;
    constructor(comparator?: OrderedComparator<TileTree, TileTree>);
    add(tree: TileTree): void;
    clear(): void;
    disclose(discloser: TileTreeDiscloser): void;
    has(tree: TileTree): boolean;
    get size(): number;
    }

// @public
export class DisplayStyle2dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // (undocumented)
    get settings(): DisplayStyleSettings;
    }

// @public
export class DisplayStyle3dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    clone(iModel?: IModelConnection): this;
    get environment(): Environment;
    set environment(env: Environment);
    // (undocumented)
    get lights(): LightSettings;
    set lights(lights: LightSettings);
    // @internal
    loadSkyBoxParams(system: RenderSystem, vp?: Viewport): SkyBox.CreateParams | undefined;
    // @internal (undocumented)
    overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // @internal (undocumented)
    protected registerSettingsEventListeners(): void;
    setSunTime(time: number): void;
    // (undocumented)
    get settings(): DisplayStyle3dSettings;
    get solarShadows(): SolarShadowSettings;
    set solarShadows(settings: SolarShadowSettings);
    get sunDirection(): Readonly<Vector3d>;
}

// @public
export abstract class DisplayStyleState extends ElementState implements DisplayStyleProps {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    anyMapLayersVisible(overlay: boolean): boolean;
    // @internal (undocumented)
    attachMapLayer(props: MapLayerProps, isOverlay: boolean, insertIndex?: number): void;
    // @internal (undocumented)
    attachMapLayerSettings(settings: MapLayerSettings, isOverlay: boolean, insertIndex?: number): void;
    // @beta
    attachRealityModel(props: ContextRealityModelProps): void;
    get backgroundColor(): ColorDef;
    set backgroundColor(val: ColorDef);
    // @internal (undocumented)
    get backgroundDrapeMap(): MapTileTreeReference;
    // @internal (undocumented)
    get backgroundMap(): MapTileTreeReference;
    // @internal (undocumented)
    get backgroundMapBase(): BaseLayerSettings | undefined;
    // @internal (undocumented)
    get backgroundMapElevationBias(): number;
    // @internal (undocumented)
    get backgroundMapLayers(): MapLayerSettings[];
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    // @internal
    get baseMapTransparency(): number;
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    // @internal (undocumented)
    changeBaseMapProps(props: MapLayerProps | ColorDef): void;
    // @internal (undocumented)
    changeBaseMapTransparency(transparency: number): void;
    // (undocumented)
    changeMapLayerCredentials(index: number, isOverlay: boolean, userName?: string, password?: string): void;
    // @internal (undocumented)
    changeMapLayerProps(props: MapLayerProps, index: number, isOverlay: boolean): void;
    // (undocumented)
    changeMapSubLayerProps(props: MapSubLayerProps, subLayerId: SubLayerId, layerIndex: number, isOverlay: boolean): void;
    // @internal (undocumented)
    static get className(): string;
    // @internal
    detachMapLayerByIndex(index: number, isOverlay: boolean): void;
    // @internal (undocumented)
    detachMapLayerByNameAndUrl(name: string, url: string, isOverlay: boolean): void;
    // @beta
    detachRealityModelByIndex(index: number): void;
    // @beta
    detachRealityModelByNameAndUrl(name: string, url: string): void;
    // @internal (undocumented)
    get displayTerrain(): boolean;
    // @beta
    dropModelAppearanceOverride(modelId: Id64String): void;
    // @beta
    dropRealityModelAppearanceOverride(index: number): boolean;
    // @beta
    dropRealityModelPlanarClipMask(modelIdOrIndex: Id64String | number): boolean;
    dropSubCategoryOverride(id: Id64String): void;
    equalState(other: DisplayStyleState): boolean;
    // @internal (undocumented)
    findMapLayerIndexByNameAndUrl(name: string, url: string, isOverlay: boolean): number;
    // @beta
    findRealityModelIndex(accept: (model: ContextRealityModelState) => boolean): number;
    // @beta
    forEachRealityModel(func: (model: ContextRealityModelState) => void): void;
    // @internal (undocumented)
    forEachRealityTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined;
    // @internal (undocumented)
    getBackgroundMapGeometry(): BackgroundMapGeometry | undefined;
    // @internal (undocumented)
    getGlobalGeometryAndHeightRange(): {
        geometry: BackgroundMapGeometry;
        heightRange: Range1d;
    } | undefined;
    // @internal (undocumented)
    getIsBackgroundMapVisible(): boolean;
    // @internal (undocumented)
    getMapLayerImageryProvider(index: number, isOverlay: boolean): MapLayerImageryProvider | undefined;
    // @internal (undocumented)
    getMapLayerRange(layerIndex: number, isOverlay: boolean): Promise<MapCartoRectangle | undefined>;
    // @internal (undocumented)
    getMapLayers(isOverlay: boolean): MapLayerSettings[];
    // @beta
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    // @beta
    getOSMBuildingDisplayIndex(): number;
    // @beta
    getRealityModelAppearanceOverride(index: number): FeatureAppearance | undefined;
    // @beta
    getRealityModelIndexFromTransientId(id: Id64String): number;
    // @beta
    getRealityModelPlanarClipMask(modelIdOrIndex: Id64String | number): PlanarClipMaskState | undefined;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    get globeMode(): GlobeMode;
    // @internal (undocumented)
    hasAttachedMapLayer(name: string, url: string, isOverlay: boolean): boolean;
    // @beta
    hasAttachedRealityModel(name: string, url: string): boolean;
    // @beta
    get hasModelAppearanceOverride(): boolean;
    get hasSubCategoryOverride(): boolean;
    is3d(): this is DisplayStyle3dState;
    // @internal (undocumented)
    mapLayerAtIndex(index: number, isOverlay: boolean): MapLayerSettings | undefined;
    // @internal (undocumented)
    mapLayerFromHit(hit: HitDetail): MapLayerSettings | undefined;
    // @internal (undocumented)
    mapLayerFromIds(mapTreeId: Id64String, layerTreeId: Id64String): MapLayerSettings | undefined;
    // @beta
    get modelAppearanceOverrides(): Map<Id64String, FeatureAppearance>;
    get monochromeColor(): ColorDef;
    set monochromeColor(val: ColorDef);
    // @internal
    moveMapLayerToBottom(index: number, isOverlay: boolean): void;
    // @internal
    moveMapLayerToIndex(fromIndex: number, toIndex: number, isOverlay: boolean): void;
    // @internal
    moveMapLayerToTop(index: number, isOverlay: boolean): void;
    get name(): string;
    // @internal (undocumented)
    get overlayMap(): MapTileTreeReference;
    // @internal (undocumented)
    get overlayMapLayers(): MapLayerSettings[];
    // @beta
    overrideModelAppearance(modelId: Id64String, ovr: FeatureAppearance): void;
    // @beta
    overrideRealityModelAppearance(index: number, overrides: FeatureAppearance): boolean;
    // @beta
    overrideRealityModelPlanarClipMask(modelIdOrIndex: Id64String | number, mask: PlanarClipMaskSettings): boolean;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @internal (undocumented)
    abstract overrideTerrainDisplay(): TerrainDisplayOverrides | undefined;
    // @internal (undocumented)
    protected registerSettingsEventListeners(): void;
    // @internal (undocumented)
    get scheduleScript(): RenderScheduleState.Script | undefined;
    set scheduleScript(script: RenderScheduleState.Script | undefined);
    // @beta
    setOSMBuildingDisplay(options: OsmBuildingDisplayOptions): boolean;
    abstract get settings(): DisplayStyleSettings;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    // @internal
    viewMapLayerRange(layerIndex: number, isOverlay: boolean, vp: ScreenViewport): Promise<boolean>;
    // @internal (undocumented)
    get wantShadows(): boolean;
}

// @alpha
export interface DownloadBriefcaseOptions {
    // (undocumented)
    fileName?: string;
    syncMode: SyncMode;
}

// @alpha
export interface DrawClipOptions {
    color?: ColorDef;
    fill?: ColorDef;
    fillClipPlanes?: boolean;
    hasPrimaryPlane?: boolean;
    hiddenStyle?: LinePixels;
    hiddenWidth?: number;
    id?: string;
    visibleWidth?: number;
}

// @public
export class DrawingModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class DrawingViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, extents: AxisAlignedBox3d, sectionDrawing?: SectionDrawingViewProps);
    // @internal
    static alwaysDisplaySpatialView: boolean;
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    // @internal
    get attachment(): Object | undefined;
    // @internal
    get attachmentInfo(): Object;
    // @internal (undocumented)
    attachToViewport(): void;
    // @internal (undocumented)
    changeViewedModel(modelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): DrawingViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // (undocumented)
    get defaultExtentLimits(): ExtentLimits;
    // @internal (undocumented)
    detachFromViewport(): void;
    // @internal (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // @internal (undocumented)
    getExtents(): Vector3d;
    // @internal (undocumented)
    getOrigin(): import("@bentley/geometry-core").Point3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal
    static hideDrawingGraphics: boolean;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // @internal (undocumented)
    load(): Promise<void>;
    // @internal (undocumented)
    get secondaryViewports(): Iterable<import("./Viewport").Viewport>;
    // @internal
    get sectionDrawingInfo(): SectionDrawingInfo;
    // @internal
    get sectionDrawingProps(): SectionDrawingViewProps | undefined;
    // (undocumented)
    toProps(): ViewStateProps;
    }

// @internal
export abstract class DynamicIModelTile extends Tile {
    protected constructor(params: TileParams, tree: TileTree);
    abstract get appearanceProvider(): FeatureAppearanceProvider;
    // (undocumented)
    static create(root: RootIModelTile, elements: Iterable<ElementGeometryChange>): DynamicIModelTile;
    abstract handleGeometryChanges(changes: Iterable<ElementGeometryChange>): void;
    abstract get hiddenElements(): Id64Array;
    abstract pruneChildren(olderThan: BeTimePoint): void;
    abstract selectTiles(selected: Tile[], args: TileDrawArgs): void;
}

// @public
export class DynamicsContext extends RenderContext {
    addGraphic(graphic: RenderGraphic): void;
    // @internal (undocumented)
    changeDynamics(): void;
    }

// @alpha (undocumented)
export type EditableConnection = BriefcaseConnection | RemoteBriefcaseConnection;

// @alpha @deprecated
export class EditingFunctions {
    constructor(connection: IModelConnection);
    get categories(): EditingFunctions.CategoryEditor;
    get codes(): EditingFunctions.Codes;
    get concurrencyControl(): EditingFunctions.ConcurrencyControl;
    deleteElements(ids: Id64Array): Promise<void>;
    hasPendingTxns(): Promise<boolean>;
    hasUnsavedChanges(): Promise<boolean>;
    get models(): EditingFunctions.ModelEditor;
    saveChanges(description?: string): Promise<void>;
    updateProjectExtents(newExtents: AxisAlignedBox3d): Promise<void>;
}

// @alpha @deprecated (undocumented)
export namespace EditingFunctions {
    // @deprecated
    export class CategoryEditor {
        constructor(c: IModelConnection);
        createAndInsertSpatialCategory(scopeModelId: Id64String, categoryName: string, appearance: SubCategoryAppearance.Props): Promise<Id64String>;
        }
    export class Codes {
        constructor(c: IModelConnection);
        makeCode(specName: string, scope: Id64String, value: string): Promise<CodeProps>;
        makeModelCode(scope: Id64String, value: string): Promise<CodeProps>;
    }
    // @deprecated
    export class ConcurrencyControl {
        constructor(c: IModelConnection);
        lockModel(modelId: Id64String, level?: LockLevel): Promise<void>;
        request(): Promise<void>;
        }
    // @deprecated
    export class ModelEditor {
        constructor(c: IModelConnection);
        createAndInsertPhysicalModel(newModelCode: CodeProps, privateModel?: boolean): Promise<Id64String>;
        }
}

// @alpha
export namespace EditManipulator {
    // (undocumented)
    export enum EventType {
        // (undocumented)
        Accept = 2,
        // (undocumented)
        Cancel = 1,
        // (undocumented)
        Synch = 0
    }
    // (undocumented)
    export abstract class HandleProvider {
        constructor(iModel: IModelConnection);
        // (undocumented)
        protected clearControls(): void;
        protected abstract createControls(): Promise<boolean>;
        // (undocumented)
        decorate(_context: DecorateContext): void;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        protected _isActive: boolean;
        protected abstract modifyControls(_hit: HitDetail, _ev: BeButtonEvent): boolean;
        // (undocumented)
        onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected onDoubleClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onManipulatorEvent(_eventType: EventType): void;
        // (undocumented)
        onManipulatorToolEvent(_tool: Tool, event: ManipulatorToolEvent): void;
        // (undocumented)
        protected onRightClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onSelectionChanged(ev: SelectionSetEvent): void;
        // (undocumented)
        protected onTouchTap(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected _removeDecorationListener?: () => void;
        // (undocumented)
        protected _removeManipulatorToolListener?: () => void;
        // (undocumented)
        protected _removeSelectionListener?: () => void;
        // (undocumented)
        protected stop(): void;
        // (undocumented)
        protected updateControls(): Promise<void>;
        // (undocumented)
        protected updateDecorationListener(add: boolean): void;
    }
    // (undocumented)
    export abstract class HandleTool extends InputCollector {
        constructor(manipulator: HandleProvider);
        // (undocumented)
        protected abstract accept(_ev: BeButtonEvent): boolean;
        // (undocumented)
        protected cancel(_ev: BeButtonEvent): boolean;
        // (undocumented)
        static hidden: boolean;
        protected init(): void;
        // (undocumented)
        manipulator: HandleProvider;
        // (undocumented)
        onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onPostInstall(): void;
        // (undocumented)
        onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onTouchCancel(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchComplete(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchMove(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        static toolId: string;
    }
    // (undocumented)
    export class HandleUtils {
        // @internal
        static adjustForBackgroundColor(color: ColorDef, vp: Viewport): ColorDef;
        static getArrowShape(baseStart?: number, baseWidth?: number, tipStart?: number, tipEnd?: number, tipWidth?: number, flangeStart?: number, flangeWidth?: number): Point3d[];
        static getArrowTransform(vp: Viewport, base: Point3d, direction: Vector3d, sizeInches: number): Transform | undefined;
        // (undocumented)
        static getBoresite(origin: Point3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Ray3d;
        // (undocumented)
        static getRotation(rotation: RotationType, viewport: Viewport): Matrix3d | undefined;
        // (undocumented)
        static isPointVisible(testPt: Point3d, vp: Viewport, borderPaddingFactor?: number): boolean;
        // (undocumented)
        static projectPointToLineInView(spacePt: Point3d, linePt: Point3d, lineDirection: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
        // (undocumented)
        static projectPointToPlaneInView(spacePt: Point3d, planePt: Point3d, planeNormal: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
    }
    // (undocumented)
    export enum RotationType {
        // (undocumented)
        Back = 4,
        // (undocumented)
        Bottom = 3,
        // (undocumented)
        Face = 7,
        // (undocumented)
        Front = 1,
        // (undocumented)
        Left = 2,
        // (undocumented)
        Right = 5,
        // (undocumented)
        Top = 0,
        // (undocumented)
        View = 6
    }
}

// @internal (undocumented)
export const ELEMENT_MARKED_FOR_REMOVAL: unique symbol;

// @alpha
export class ElementAgenda {
    constructor(iModel: IModelConnection);
    add(arg: Id64Arg): boolean;
    clear(): void;
    compressIds(): CompressedId64Set;
    // (undocumented)
    get count(): number;
    readonly elements: Id64Array;
    find(id: Id64String): boolean;
    getSource(): ModifyElementSource.Unknown | ModifyElementSource;
    readonly groupMarks: GroupMark[];
    has(id: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(arg: Id64Arg): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get length(): number;
    // (undocumented)
    manageHiliteState: boolean;
    orderIds(): OrderedId64Array;
    popGroup(): void;
    // (undocumented)
    remove(arg: Id64Arg): boolean;
    setSource(val: ModifyElementSource): void;
}

// @alpha
export class ElementEditor3d {
    applyTransform(tprops: TransformProps): Promise<any>;
    createElement(props: GeometricElement3dProps, origin?: Point3d, angles?: YawPitchRollAngles, geometry?: any): Promise<void>;
    end(): Promise<void>;
    // (undocumented)
    readonly iModelConnection: IModelConnection;
    popState(): Promise<void>;
    pushState(): Promise<void>;
    restart(): Promise<void>;
    static start(iModelConnection: IModelConnection): Promise<ElementEditor3d>;
    startModifyingElements(elementIds: Id64Array): Promise<void>;
    write(opts?: Editor3dRpcInterfaceWriteOptions): Promise<GeometricElement3dProps[] | Id64Array | void>;
    writeReturningIds(): Promise<Id64Array>;
    writeReturningProps(wantGeom?: boolean): Promise<GeometricElement3dProps[]>;
}

// @public (undocumented)
export class ElementLocateManager {
    // (undocumented)
    get apertureInches(): number;
    // (undocumented)
    clear(): void;
    // (undocumented)
    currHit?: HitDetail;
    // (undocumented)
    doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, view: ScreenViewport | undefined, source: InputSource, filterHits?: boolean): Promise<HitDetail | undefined>;
    // (undocumented)
    filterHit(hit: HitDetail, _action: LocateAction, out: LocateResponse): Promise<LocateFilterStatus>;
    static getFailureMessageKey(key: string): string;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    getPreLocatedHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    initLocateOptions(): void;
    // (undocumented)
    initToolLocate(): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    readonly options: LocateOptions;
    // (undocumented)
    readonly picker: ElementPicker;
    // (undocumented)
    setCurrHit(hit?: HitDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    get touchApertureInches(): number;
}

// @public (undocumented)
export class ElementPicker {
    doPick(vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): number;
    // (undocumented)
    empty(): void;
    getHit(i: number): HitDetail | undefined;
    getHitList(takeOwnership: boolean): HitList<HitDetail>;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    readonly pickPointWorld: Point3d;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    testHit(hit: HitDetail, vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): boolean;
    // (undocumented)
    viewport?: Viewport;
}

// @alpha
export abstract class ElementSetTool extends PrimitiveTool {
    protected get agenda(): ElementAgenda;
    protected get allowDragSelect(): boolean;
    protected get allowGroups(): boolean;
    protected get allowSelectionSet(): boolean;
    protected anchorPoint?: Point3d;
    protected buildDragSelectAgenda(vp: Viewport, origin: Point3d, corner: Point3d, method: SelectionMethod, overlap: boolean): Promise<boolean>;
    protected buildLocateAgenda(hit: HitDetail): Promise<boolean>;
    protected buildSelectionSetAgenda(ss: SelectionSet): Promise<boolean>;
    protected chooseNextHit(ev: BeButtonEvent): Promise<EventHandled>;
    protected get clearSelectionSet(): boolean;
    protected get controlKeyContinuesSelection(): boolean;
    protected get controlKeyInvertsSelection(): boolean;
    protected get currentElementCount(): number;
    decorate(context: DecorateContext): void;
    protected doLocate(ev: BeButtonEvent, newSearch: boolean): Promise<boolean>;
    protected doProcessSelectionSetImmediate(): Promise<void>;
    protected dragStartPoint?: Point3d;
    filterHit(hit: HitDetail, out?: LocateResponse): Promise<LocateFilterStatus>;
    protected gatherElements(ev: BeButtonEvent): Promise<EventHandled | undefined>;
    protected gatherInput(ev: BeButtonEvent): Promise<EventHandled | undefined>;
    protected getDragSelectCandidates(vp: Viewport, origin: Point3d, corner: Point3d, method: SelectionMethod, overlap: boolean): Promise<Id64Arg>;
    protected getGroupIds(id: Id64String): Promise<Id64Arg>;
    protected getLocateCandidates(hit: HitDetail): Promise<Id64Arg>;
    protected getSelectionSetCandidates(ss: SelectionSet): Promise<Id64Arg>;
    // (undocumented)
    protected initAgendaDynamics(): Promise<boolean>;
    protected get isControlDown(): boolean;
    protected isElementIdValid(id: Id64String, source: ModifyElementSource): boolean;
    protected isElementValidForOperation(hit: HitDetail, _out?: LocateResponse): Promise<boolean>;
    protected get isSelectByPoints(): boolean;
    protected get isSelectionSetModify(): boolean;
    protected onAgendaModified(): Promise<void>;
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onPostInstall(): void;
    protected onProcessComplete(): Promise<void>;
    onReinitialize(): void;
    // (undocumented)
    onResetButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    onUnsuspend(): void;
    protected processAgenda(_ev: BeButtonEvent): Promise<void>;
    protected processAgendaImmediate(): Promise<void>;
    protected processDataButton(ev: BeButtonEvent): Promise<EventHandled>;
    protected processResetButton(ev: BeButtonEvent): Promise<EventHandled>;
    protected provideToolAssistance(mainInstrText?: string, additionalInstr?: ToolAssistanceInstruction[]): void;
    protected get requireAcceptForSelectionSetDynamics(): boolean;
    protected get requireAcceptForSelectionSetOperation(): boolean;
    protected get requiredElementCount(): number;
    protected selectByPointsDecorate(context: DecorateContext): void;
    protected selectByPointsEnd(ev: BeButtonEvent): Promise<boolean>;
    protected selectByPointsStart(ev: BeButtonEvent): Promise<boolean>;
    protected setPreferredElementSource(): void;
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected get shouldEnableLocate(): boolean;
    // (undocumented)
    protected get shouldEnableSnap(): boolean;
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    protected get wantAccuSnap(): boolean;
    protected get wantAdditionalElements(): boolean;
    protected get wantAdditionalInput(): boolean;
    protected get wantDynamics(): boolean;
    protected wantProcessAgenda(_ev: BeButtonEvent): boolean;
}

// @public
export class ElementState extends EntityState implements ElementProps {
    constructor(props: ElementProps, iModel: IModelConnection);
    // @internal (undocumented)
    static get className(): string;
    readonly code: Code;
    readonly federationGuid?: GuidString;
    readonly model: Id64String;
    readonly parent?: RelatedElement;
    // @internal (undocumented)
    toJSON(): ElementProps;
    readonly userLabel?: string;
}

// @internal
export class EllipsoidTerrainProvider extends TerrainMeshProvider {
    constructor(iModel: IModelConnection, modelId: Id64String, _wantSkirts: boolean);
    // (undocumented)
    constructUrl(_row: number, _column: number, _zoomLevel: number): string;
    // (undocumented)
    getChildHeightRange(_quadId: QuadId, _rectangle: MapCartoRectangle, _parent: MapTile): Range1d | undefined;
    // (undocumented)
    getMesh(tile: MapTile, _data: Uint8Array): Promise<TerrainMeshPrimitive | undefined>;
    // (undocumented)
    isTileAvailable(_quadId: QuadId): boolean;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    get requiresLoadedContent(): boolean;
    // (undocumented)
    get tilingScheme(): MapTilingScheme;
    }

// @public
export class EmphasizeElements implements FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, vp: Viewport): void;
    static clear(vp: Viewport, inactiveOnly?: boolean): void;
    clearAlwaysDrawnElements(vp: Viewport): boolean;
    clearEmphasizedElements(vp: Viewport): boolean;
    clearEmphasizedIsolatedElements(vp: Viewport, setToAlwaysDrawn: boolean): boolean;
    clearHiddenElements(vp: Viewport): boolean;
    clearIsolatedElements(vp: Viewport): boolean;
    clearNeverDrawnElements(vp: Viewport): boolean;
    clearOverriddenElements(vp: Viewport, keyOrIds?: number | Id64Arg): boolean;
    // @internal (undocumented)
    protected createAppearanceFromKey(key: number): FeatureAppearance;
    createDefaultAppearance(): FeatureAppearance;
    createOverrideKey(color: ColorDef, override: FeatureOverrideType): number | undefined;
    get defaultAppearance(): FeatureAppearance | undefined;
    set defaultAppearance(appearance: FeatureAppearance | undefined);
    emphasizeElements(ids: Id64Arg, vp: Viewport, defaultAppearance?: FeatureAppearance, replace?: boolean): boolean;
    emphasizeSelectedElements(vp: Viewport, defaultAppearance?: FeatureAppearance, replace?: boolean, clearSelection?: boolean): boolean;
    fromJSON(props: EmphasizeElementsProps, vp: Viewport): boolean;
    static get(vp: Viewport): EmphasizeElements | undefined;
    getAlwaysDrawnElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedIsolatedElements(): Id64Set | undefined;
    getHiddenElements(vp: Viewport): Id64Set | undefined;
    getIsolatedElements(vp: Viewport): Id64Set | undefined;
    getNeverDrawnElements(vp: Viewport): Id64Set | undefined;
    static getOrCreate(vp: Viewport): EmphasizeElements;
    getOverriddenElements(): Map<number, Id64Set> | undefined;
    getOverriddenElementsByKey(key: number): Id64Set | undefined;
    getOverrideFromKey(key: number): {
        overrideType: FeatureOverrideType;
        color: ColorDef;
    };
    hideElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    hideSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    isActive(vp: Viewport): boolean;
    isolateElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    isolateSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    overrideElements(ids: Id64Arg, vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean): boolean;
    overrideSelectedElements(vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean, clearSelection?: boolean): boolean;
    // @internal
    setAlwaysDrawnElements(ids: Id64Arg, vp: Viewport, exclusive?: boolean, replace?: boolean): boolean;
    // @internal
    setNeverDrawnElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    toJSON(vp: Viewport): EmphasizeElementsProps;
    // @internal (undocumented)
    protected updateIdSet(ids: Id64Arg, replace: boolean, existingIds?: Id64Set): Id64Set | undefined;
    wantEmphasis: boolean;
}

// @public
export interface EmphasizeElementsProps {
    // (undocumented)
    alwaysDrawn?: Id64Array;
    // (undocumented)
    alwaysDrawnExclusiveEmphasized?: Id64Array;
    // (undocumented)
    appearanceOverride?: AppearanceOverrideProps[];
    // (undocumented)
    defaultAppearance?: FeatureAppearanceProps;
    // (undocumented)
    isAlwaysDrawnExclusive?: boolean;
    // (undocumented)
    neverDrawn?: Id64Array;
    // (undocumented)
    wantEmphasis?: boolean;
}

// @beta
export class EngineeringLengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @public
export class EntityState implements EntityProps {
    constructor(props: EntityProps, iModel: IModelConnection, _state?: EntityState);
    readonly classFullName: string;
    static get classFullName(): string;
    static get className(): string;
    get className(): string;
    clone(iModel?: IModelConnection): this;
    equals(other: this): boolean;
    readonly id: Id64String;
    readonly iModel: IModelConnection;
    readonly jsonProperties: {
        [key: string]: any;
    };
    static get schemaName(): string;
    // @internal (undocumented)
    toJSON(): EntityProps;
}

// @public
export class Environment {
    constructor(json?: EnvironmentProps);
    // (undocumented)
    readonly ground: GroundPlane;
    // (undocumented)
    readonly sky: SkyBox;
    // (undocumented)
    toJSON(): EnvironmentProps;
}

// @public
export class EventController {
    constructor(vp: ScreenViewport);
    // (undocumented)
    destroy(): void;
    // (undocumented)
    vp: ScreenViewport;
}

// @public (undocumented)
export enum EventHandled {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @beta
export abstract class Extension {
    constructor(name: string);
    protected _defaultNs: string;
    get i18n(): I18N;
    // @internal (undocumented)
    get loader(): ExtensionLoader | undefined;
    set loader(loader: ExtensionLoader | undefined);
    // (undocumented)
    name: string;
    abstract onExecute(_args: string[]): Promise<void>;
    onLoad(_args: string[]): Promise<void>;
    resolveResourceUrl(relativeUrl: string): string;
    // @deprecated
    setI18n(defaultNamespace?: string, options?: I18NOptions): void;
}

// @beta
export class ExtensionAdmin {
    constructor(props?: ExtensionAdminProps);
    addExtensionLoader(extensionLoader: ExtensionLoader): void;
    addExtensionLoaderFront(extensionLoader: ExtensionLoader): void;
    // @internal (undocumented)
    addPendingExtension(extensionRootName: string, pendingExtension: PendingExtension): void;
    loadExtension(extensionRoot: string, extensionVersion?: string, args?: string[]): Promise<Extension | undefined>;
    readonly onExtensionLoaded: BeEvent<(extensionName: string) => void>;
    onInitialized(): void;
    register(extension: Extension): void;
    }

// @beta
export interface ExtensionAdminProps {
    configureExtensionServiceLoader?: boolean;
}

// @beta
export interface ExtensionLoader {
    // (undocumented)
    getExtensionName(extensionRoot: string): string;
    // (undocumented)
    loadExtension(extensionName: string, extensionVersion?: string, args?: string[]): Promise<PendingExtension | undefined>;
    // (undocumented)
    resolveResourceUrl(extensionName: string, relativeFileName: string): string;
}

// @beta
export class ExtensionServiceExtensionLoader implements ExtensionLoader {
    constructor(_contextId: string);
    // (undocumented)
    getExtensionName(extensionRoot: string): string;
    // (undocumented)
    loadExtension(extensionName: string, extensionVersion?: string, args?: string[] | undefined): Promise<PendingExtension | undefined>;
    // (undocumented)
    resolveResourceUrl(extensionName: string, relativeFileName: string): string;
    }

// @public
export interface ExtentLimits {
    max: number;
    min: number;
}

// @beta
export class ExternalServerExtensionLoader implements ExtensionLoader {
    constructor(serverName: string);
    // (undocumented)
    getExtensionName(extensionRoot: string): string;
    // (undocumented)
    loadExtension(extensionName: string, extensionVersion?: string, args?: string[]): Promise<PendingExtension | undefined>;
    // (undocumented)
    resolveResourceUrl(extensionName: string, relativeUrl: string): string;
    // (undocumented)
    serverName: string;
}

// @alpha
export interface ExternalTileStatistics {
    // (undocumented)
    ready: number;
    // (undocumented)
    requested: number;
    // (undocumented)
    selected: number;
}

// @public
export function extractImageSourceDimensions(source: ImageSource): Promise<Point2d>;

// @internal
export function eyeToCartographicOnGlobe(viewport: ScreenViewport, preserveHeight?: boolean): Cartographic | undefined;

// @internal
export function eyeToCartographicOnGlobeFromGcs(viewport: ScreenViewport, preserveHeight?: boolean): Promise<Cartographic | undefined>;

// @alpha
export class FeatureLogBatchClient {
    constructor(_getRequestContext: () => Promise<AuthorizedClientRequestContext>, options?: Partial<FeatureLogBatchOptions>, _client?: UsageLoggingClient);
    clearAutomaticBatchSubmission(reset?: boolean): void;
    queueLog(...entries: FeatureLogEntry[]): Promise<void>;
    setupAutomaticBatchSubmission(): void;
    }

// @alpha
export interface FeatureLogBatchOptions {
    // (undocumented)
    maxBatchInterval: number;
    // (undocumented)
    maxBatchSize: number;
}

// @public
export interface FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void;
}

// @public
export enum FeatureOverrideType {
    AlphaOnly = 1,
    ColorAndAlpha = 2,
    ColorOnly = 0
}

// @public
export namespace FeatureSymbology {
    // @deprecated (undocumented)
    export class Appearance extends FeatureAppearance {
    }
    // @deprecated (undocumented)
    export interface AppearanceProps extends FeatureAppearanceProps {
    }
    export class Overrides extends FeatureOverrides {
        constructor(view?: ViewState | Viewport);
        // @internal
        initFromView(view: ViewState): void;
        // @internal
        initFromViewport(viewport: Viewport): void;
        }
}

// @alpha
export class FeatureTrackingManager {
    constructor();
    protected _client: FeatureLogBatchClient;
    protected _hostFallbackName: string;
    protected _hostName: string;
    track(props: FeatureTrackingProps): void;
    protected trackFeature(_props: FeatureTrackingProps): FeatureLogEntry | undefined;
    protected _usageType: UsageType;
}

// @alpha
export interface FeatureTrackingProps {
    applicationData?: Map<string, any>;
    featureName: string;
    iModelConnection?: IModelConnection;
    ulasFeatureId?: string;
}

// @alpha
export function findAvailableRealityModels(contextId: GuidString, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;

// @alpha
export function findAvailableUnattachedRealityModels(contextId: GuidString, iModel?: IModelConnection, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;

// @public
export class FitViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    doFit(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isolatedOnly: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class Flags {
    // (undocumented)
    animateRotation: boolean;
    // (undocumented)
    auxRotationPlane: RotationMode;
    // (undocumented)
    baseMode: number;
    // (undocumented)
    baseRotation: RotationMode;
    // (undocumented)
    bearingFixToPlane2D: boolean;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    dialogNeedsUpdate: boolean;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    haveValidOrigin: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    inDataPoint: boolean;
    // (undocumented)
    indexLocked: boolean;
    // (undocumented)
    lockedRotation: boolean;
    // (undocumented)
    pointIsOnPlane: boolean;
    // (undocumented)
    redrawCompass: boolean;
    // (undocumented)
    rotationNeedsUpdate: boolean;
    // (undocumented)
    softAngleLock: boolean;
}

// @public
export class FlyViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export abstract class FormattedQuantityDescription extends BaseQuantityDescription {
    constructor(name: string, displayLabel: string, iconSpec?: string);
    // (undocumented)
    abstract get formatterQuantityType(): QuantityType;
    // (undocumented)
    get formatterSpec(): FormatterSpec | undefined;
    // (undocumented)
    protected formatValue(numberValue: number): string;
    // (undocumented)
    abstract get parseError(): string;
    // (undocumented)
    get parserSpec(): ParserSpec | undefined;
    // (undocumented)
    protected parseString(userInput: string): ParseResults;
}

// @alpha
export interface FormatterParserSpecsProvider {
    // (undocumented)
    createFormatterSpec: (unitSystem: UnitSystemKey) => Promise<FormatterSpec>;
    // (undocumented)
    createParserSpec: (unitSystem: UnitSystemKey) => Promise<ParserSpec>;
    // (undocumented)
    quantityType: QuantityTypeArg;
}

// @alpha
export interface FormattingUnitSystemChangedArgs {
    // (undocumented)
    readonly system: UnitSystemKey;
}

// @internal (undocumented)
export interface FrameBeforeRenderData {
    // (undocumented)
    renderSystem: System;
    // (undocumented)
    setSceneNeedRedraw: (redraw: boolean) => void;
    // (undocumented)
    viewport: Viewport;
}

// @internal (undocumented)
export interface FrameCameraFrustumData {
    // (undocumented)
    back: number;
    // (undocumented)
    bottom: number;
    // (undocumented)
    front: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
    // (undocumented)
    type: FrustumUniformType;
}

// @internal (undocumented)
export interface FrameCameraViewData {
    // (undocumented)
    cameraPosition: Point3d;
    // (undocumented)
    viewX: Vector3d;
    // (undocumented)
    viewY: Vector3d;
    // (undocumented)
    viewZ: Vector3d;
}

// @internal (undocumented)
export interface FrameRenderData {
    // (undocumented)
    commands: RenderCommands;
    // (undocumented)
    compositeFlags: CompositeFlags;
    // (undocumented)
    fbo: FrameBuffer;
    // (undocumented)
    frameBufferStack: FrameBufferStack;
    // (undocumented)
    needComposite: boolean;
}

// @public
export enum FrontendLoggerCategory {
    Authorization = "imodeljs-frontend.Authorization",
    // @alpha
    EditorConnection = "imodeljs-frontend.EditorConnection",
    EventSource = "imodeljs-frontend.EventSource",
    FeatureToggle = "imodeljs-frontend.FeatureToggles",
    // @alpha
    FeatureTracking = "imodeljs-frontend.FeatureTracking",
    FrontendRequestContext = "imodeljs-frontend.FrontendRequestContext",
    IModelConnection = "imodeljs-frontend.IModelConnection",
    MobileAuthorizationClient = "imodeljs-frontend.MobileAuthorizationClient",
    NativeApp = "imodeljs-frontend.NativeApp",
    // (undocumented)
    Package = "imodeljs-frontend"
}

// @public
export class FrontendRequestContext extends ClientRequestContext {
    constructor(activityId?: string);
}

// @public
export interface FrontendSecurityOptions {
    readonly csrfProtection?: {
        readonly enabled: boolean;
        readonly cookieName?: string;
        readonly headerName?: string;
    };
}

// @public
export namespace Frustum2d {
    const minimumZDistance = 1;
    const minimumZExtents: Readonly<Range1d>;
    export function depthFromDisplayPriority(priority: number): number;
}

// @internal
export class FrustumAnimator implements Animator {
    constructor(options: ViewAnimationOptions, viewport: ScreenViewport, begin: ViewPose, end: ViewPose);
    // (undocumented)
    animate(): boolean;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    options: ViewAnimationOptions;
    }

// @public (undocumented)
export class FuzzySearch<T> {
    onGetMultiWordSearchOptions(): Fuse.FuseOptions<T>;
    onGetSingleWordSearchOptions(): Fuse.FuseOptions<T>;
    search(searchedObjects: T[], keys: Array<keyof T>, pattern: string): FuzzySearchResults<T>;
}

// @public
export interface FuzzySearchResult<T> {
    getBoldMask(): boolean[];
    getMatchedKey(): string;
    getMatchedValue(): string;
    getResult(): T;
}

// @public
export class FuzzySearchResults<T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator](): any;
    constructor(results: any[] | undefined);
    // (undocumented)
    getResult(resultIndex: number): FuzzySearchResult<T> | undefined;
    // (undocumented)
    get length(): number;
    // (undocumented)
    results: any[];
}

// @internal
export class GeoConverter {
    constructor(iModel: IModelConnection, datum: string);
    // (undocumented)
    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps;
    // (undocumented)
    getGeoCoordinatesFromIModelCoordinates(iModelPoints: XYZProps[]): Promise<GeoCoordinatesResponseProps>;
    // (undocumented)
    getIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): Promise<IModelCoordinatesResponseProps>;
    }

// @internal (undocumented)
export class GeographicTilingScheme extends MapTilingScheme {
    constructor(numberOfLevelZeroTilesX?: number, numberOfLevelZeroTilesY?: number, rowZeroAtNorthPole?: boolean);
    // (undocumented)
    latitudeToYFraction(latitude: number): number;
    // (undocumented)
    yFractionToLatitude(yFraction: number): number;
}

// @public
export class GeometricModel2dState extends GeometricModelState implements GeometricModel2dProps {
    constructor(props: GeometricModel2dProps, iModel: IModelConnection, state?: GeometricModel2dState);
    // @internal (undocumented)
    get asGeometricModel2d(): GeometricModel2dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    readonly globalOrigin: Point2d;
    // @internal (undocumented)
    get is3d(): boolean;
    // (undocumented)
    toJSON(): GeometricModel2dProps;
}

// @public
export class GeometricModel3dState extends GeometricModelState {
    constructor(props: GeometricModel3dProps, iModel: IModelConnection, state?: GeometricModel3dState);
    // @internal (undocumented)
    get asGeometricModel3d(): GeometricModel3dState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    get is3d(): boolean;
    readonly isNotSpatiallyLocated: boolean;
    // @deprecated (undocumented)
    get iSpatiallyLocated(): boolean;
    readonly isPlanProjection: boolean;
    get isSpatiallyLocated(): boolean;
    // @internal (undocumented)
    toJSON(): GeometricModel3dProps;
}

// @public
export abstract class GeometricModelState extends ModelState implements GeometricModelProps {
    constructor(props: GeometricModelProps, iModel: IModelConnection, state?: GeometricModelState);
    // @internal (undocumented)
    get asGeometricModel(): GeometricModelState;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    createTileTreeReference(view: ViewState): TileTreeReference;
    // @internal (undocumented)
    geometryGuid?: string;
    get is2d(): boolean;
    abstract get is3d(): boolean;
    // @internal (undocumented)
    get isGeometricModel(): boolean;
    // @internal
    queryModelRange(): Promise<Range3d>;
    // @internal (undocumented)
    get treeModelId(): Id64String;
}

// @internal
export class GeoServices {
    constructor(iModel: IModelConnection);
    // (undocumented)
    getConverter(datum?: string): GeoConverter | undefined;
    }

// @beta
export function getCenteredViewRect(viewRect: ViewRect, aspectRatio?: number): ViewRect;

// @internal (undocumented)
export function getCesiumAccessTokenAndEndpointUrl(assetId?: number, requestKey?: string): Promise<{
    token?: string;
    url?: string;
}>;

// @beta (undocumented)
export function getCesiumAssetUrl(osmAssetId: number, requestKey: string): string;

// @internal (undocumented)
export function getCesiumOSMBuildingsUrl(): string;

// @internal (undocumented)
export function getCesiumTerrainProvider(iModel: IModelConnection, modelId: Id64String, wantSkirts: boolean, wantNormals: boolean, exaggeration: number): Promise<TerrainMeshProvider | undefined>;

// @beta
export function getCompressedJpegFromCanvas(canvas: HTMLCanvasElement, maxBytes?: number, minCompressionQuality?: number): string | undefined;

// @internal
export function getGcsConverterAvailable(iModel: IModelConnection): Promise<boolean>;

// @public
export function getImageSourceFormatForMimeType(mimeType: string): ImageSourceFormat | undefined;

// @public
export function getImageSourceMimeType(format: ImageSourceFormat): string;

// @beta
export function getQuantityTypeKey(type: QuantityTypeArg): QuantityTypeKey;

// @alpha
export interface GlobalLocation {
    // (undocumented)
    area?: GlobalLocationArea;
    // (undocumented)
    center: Cartographic;
}

// @alpha
export interface GlobalLocationArea {
    // (undocumented)
    northeast: Cartographic;
    // (undocumented)
    southwest: Cartographic;
}

// @internal
export class GlobeAnimator implements Animator {
    protected constructor(viewport: ScreenViewport, destination: GlobalLocation, afterLanding: Frustum);
    // (undocumented)
    protected _afterLanding: Frustum;
    // (undocumented)
    animate(): boolean;
    // (undocumented)
    protected _columbusLine: Point3d[];
    // (undocumented)
    static create(viewport: ScreenViewport, destination: GlobalLocation): Promise<GlobeAnimator | undefined>;
    // (undocumented)
    protected _ellipsoidArc?: Arc3d;
    // (undocumented)
    protected _endHeight?: number;
    // (undocumented)
    protected _endLocation: GlobalLocation;
    // (undocumented)
    protected readonly _fixLandingFraction: number;
    // (undocumented)
    protected _fixLandingInterpolator?: SmoothTransformBetweenFrusta;
    // (undocumented)
    protected _fixTakeoffFraction?: number;
    // (undocumented)
    protected _fixTakeoffInterpolator?: SmoothTransformBetweenFrusta;
    // (undocumented)
    protected _flightLength: number;
    // (undocumented)
    protected _flightTweens: Tweens;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    protected _midHeight?: number;
    // (undocumented)
    protected _moveFixToFraction(fract: number, interpolator: SmoothTransformBetweenFrusta): boolean;
    // (undocumented)
    protected _moveFlightToFraction(fraction: number): boolean;
    // (undocumented)
    protected readonly _scratchFrustum: Frustum;
    // (undocumented)
    protected _startCartographic?: Cartographic;
    // (undocumented)
    protected _startHeight?: number;
    // (undocumented)
    protected _viewport: ScreenViewport;
}

// @internal
export abstract class GltfReader {
    protected constructor(props: GltfReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type?: BatchType, isCanceled?: ShouldAbortReadGltf);
    // (undocumented)
    protected readonly _accessors: any;
    // (undocumented)
    protected readonly _batchData: any;
    // (undocumented)
    protected readonly _binaryData: Uint8Array;
    // (undocumented)
    protected readonly _buffer: ByteStream;
    // (undocumented)
    protected readonly _bufferViews: any;
    // (undocumented)
    protected createDisplayParams(materialJson: any, hasBakedLighting: boolean): DisplayParams | undefined;
    // (undocumented)
    protected readonly _extensions: any;
    // (undocumented)
    protected extractReturnToCenter(extensions: any): number[] | undefined;
    // (undocumented)
    protected findTextureMapping(textureId: string): TextureMapping | undefined;
    // (undocumented)
    getBufferView(json: any, accessorName: string): GltfBufferView | undefined;
    // (undocumented)
    protected readonly _images: any;
    // (undocumented)
    protected readonly _iModel: IModelConnection;
    // (undocumented)
    protected readonly _is3d: boolean;
    // (undocumented)
    protected get _isCanceled(): boolean;
    // (undocumented)
    protected get _isVolumeClassifier(): boolean;
    // (undocumented)
    protected loadTexture(textureId: string, isTransparent: boolean): Promise<void>;
    // (undocumented)
    protected loadTextureImage(imageJson: any, samplerJson: any, isTransparent: boolean): Promise<RenderTexture | undefined>;
    // (undocumented)
    protected loadTextures(): Promise<void>;
    // (undocumented)
    protected readonly _materialValues: any;
    // (undocumented)
    protected readonly _meshes: any;
    // (undocumented)
    protected readonly _modelId: Id64String;
    // (undocumented)
    protected readonly _namedTextures: any;
    // (undocumented)
    protected readonly _nodes: any;
    abstract read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readBatchTable(_mesh: Mesh, _json: any): void;
    // (undocumented)
    protected readBufferData(json: any, accessorName: string, type: GltfDataType): GltfBufferData | undefined;
    // (undocumented)
    readBufferData16(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData32(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferData8(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    readBufferDataFloat(json: any, accessorName: string): GltfBufferData | undefined;
    // (undocumented)
    protected readFeatureIndices(_json: any): number[] | undefined;
    // (undocumented)
    protected readGltfAndCreateGraphics(isLeaf: boolean, featureTable: FeatureTable, contentRange: ElementAlignedBox3d, transformToRoot?: Transform, pseudoRtcBias?: Vector3d, instances?: InstancedGraphicParams): GltfReaderResult;
    // (undocumented)
    protected readIndices(json: any, accessorName: string): number[] | undefined;
    // (undocumented)
    protected readMeshIndices(mesh: Mesh, json: any): boolean;
    // (undocumented)
    protected readMeshPrimitive(primitive: any, featureTable?: FeatureTable, pseudoRtcBias?: Vector3d): Mesh | undefined;
    // (undocumented)
    protected readNormals(normals: OctEncodedNormal[], json: any, accessorName: string): boolean;
    // (undocumented)
    protected readPolylines(polylines: MeshPolylineList, json: any, accessorName: string, disjoint: boolean): boolean;
    // (undocumented)
    protected readUVParams(params: Point2d[], json: any, accessorName: string): boolean;
    // (undocumented)
    protected readVertices(positions: QPoint3dList, primitive: any, pseudoRtcBias?: Vector3d): boolean;
    // (undocumented)
    protected readonly _renderMaterials: any;
    // (undocumented)
    protected readonly _returnToCenter: number[] | undefined;
    // (undocumented)
    protected readonly _samplers: any;
    // (undocumented)
    protected readonly _scene: any;
    // (undocumented)
    protected readonly _system: RenderSystem;
    // (undocumented)
    protected readonly _techniques: any;
    // (undocumented)
    protected readonly _textures: any;
    // (undocumented)
    protected readonly _type: BatchType;
    // (undocumented)
    protected readonly _yAxisUp: boolean;
}

// @internal
export class GltfReaderProps {
    // (undocumented)
    readonly accessors: any;
    // (undocumented)
    readonly binaryData: Uint8Array;
    // (undocumented)
    readonly buffer: ByteStream;
    // (undocumented)
    readonly bufferViews: any;
    static create(buffer: ByteStream, yAxisUp?: boolean): GltfReaderProps | undefined;
    // (undocumented)
    readonly extensions: any;
    // (undocumented)
    readonly materials: any;
    // (undocumented)
    readonly meshes: any;
    // (undocumented)
    readonly nodes: any;
    // (undocumented)
    readonly samplers: any;
    // (undocumented)
    readonly scene: any;
    // (undocumented)
    readonly techniques: any;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal
export interface GltfReaderResult extends TileContent {
    // (undocumented)
    readStatus: TileReadStatus;
}

// @internal (undocumented)
export interface GLTimerResult {
    children?: GLTimerResult[];
    label: string;
    nanoseconds: number;
}

// @internal (undocumented)
export type GLTimerResultCallback = (result: GLTimerResult) => void;

// @beta
export type GpuMemoryLimit = "none" | "default" | "aggressive" | "relaxed" | number;

// @beta
export interface GpuMemoryLimits {
    mobile?: GpuMemoryLimit;
    nonMobile?: GpuMemoryLimit;
}

// @public
export class GraphicBranch implements IDisposable {
    constructor(ownsEntries?: boolean);
    add(graphic: RenderGraphic): void;
    // @internal
    animationId?: string;
    clear(): void;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    readonly entries: RenderGraphic[];
    // @internal (undocumented)
    getViewFlags(flags: ViewFlags, out?: ViewFlags): ViewFlags;
    // (undocumented)
    get isEmpty(): boolean;
    readonly ownsEntries: boolean;
    // @internal (undocumented)
    setViewFlagOverrides(ovr: ViewFlagOverrides): void;
    // @internal (undocumented)
    setViewFlags(flags: ViewFlags): void;
    symbologyOverrides?: FeatureSymbology.Overrides;
    // (undocumented)
    viewFlagOverrides: ViewFlagOverrides;
}

// @internal
export interface GraphicBranchFrustum {
    // (undocumented)
    is3d: boolean;
    // (undocumented)
    scale: {
        x: number;
        y: number;
    };
}

// @internal
export interface GraphicBranchOptions {
    // (undocumented)
    appearanceProvider?: FeatureAppearanceProvider;
    // (undocumented)
    classifierOrDrape?: RenderPlanarClassifier | RenderTextureDrape;
    // (undocumented)
    clipVolume?: RenderClipVolume;
    // (undocumented)
    frustum?: GraphicBranchFrustum;
    // (undocumented)
    hline?: HiddenLine.Settings;
    // (undocumented)
    iModel?: IModelConnection;
}

// @public
export abstract class GraphicBuilder {
    // @internal
    protected constructor(placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    abstract activateGraphicParams(graphicParams: GraphicParams): void;
    abstract addArc(arc: Arc3d, isEllipse: boolean, filled: boolean): void;
    abstract addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void;
    addFrustum(frustum: Frustum): void;
    abstract addLineString(points: Point3d[]): void;
    abstract addLineString2d(points: Point2d[], zDepth: number): void;
    abstract addLoop(loop: Loop): void;
    abstract addPath(path: Path): void;
    abstract addPointString(points: Point3d[]): void;
    abstract addPointString2d(points: Point2d[], zDepth: number): void;
    abstract addPolyface(meshData: Polyface, filled: boolean): void;
    addRangeBox(range: Range3d): void;
    addRangeBoxFromCorners(p: Point3d[]): void;
    abstract addShape(points: Point3d[]): void;
    abstract addShape2d(points: Point2d[], zDepth: number): void;
    // @alpha
    applyAspectRatioSkew: boolean;
    abstract finish(): RenderGraphic;
    // @internal (undocumented)
    get iModel(): IModelConnection;
    // @internal (undocumented)
    get isOverlay(): boolean;
    // @internal (undocumented)
    get isSceneGraphic(): boolean;
    // @internal (undocumented)
    get isViewBackground(): boolean;
    // @internal (undocumented)
    get isViewCoordinates(): boolean;
    // @internal (undocumented)
    get isWorldCoordinates(): boolean;
    // (undocumented)
    pickId?: string;
    get placement(): Transform;
    set placement(tf: Transform);
    // @beta
    preserveOrder: boolean;
    setBlankingFill(fillColor: ColorDef): void;
    setSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): void;
    readonly type: GraphicType;
    readonly viewport: Viewport;
    get wantNormals(): boolean;
    set wantNormals(_wantNormals: boolean);
}

// @public
export type GraphicList = RenderGraphic[];

// @internal (undocumented)
export interface GraphicsCollector {
    // (undocumented)
    addGraphic(graphic: RenderGraphic): void;
}

// @internal (undocumented)
export class GraphicsCollectorDrawArgs extends TileDrawArgs {
    // (undocumented)
    static create(context: SceneContext, collector: GraphicsCollector, ref: TileTreeReference, planes: FrustumPlanes, worldToViewMap: Map4d): TileDrawArgs | undefined;
    // (undocumented)
    drawGraphics(): void;
    // (undocumented)
    drawGraphicsWithType(_graphicType: TileGraphicType, graphics: GraphicBranch): void;
    // (undocumented)
    get frustumPlanes(): FrustumPlanes;
    // (undocumented)
    get worldToViewMap(): Map4d;
    }

// @public
export enum GraphicType {
    Scene = 1,
    ViewBackground = 0,
    ViewOverlay = 4,
    WorldDecoration = 2,
    WorldOverlay = 3
}

// @alpha (undocumented)
export interface GroupMark {
    // (undocumented)
    source: ModifyElementSource;
    // (undocumented)
    start: number;
}

// @internal (undocumented)
export interface Hilites {
    // (undocumented)
    readonly elements: Id64.Uint32Set;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
}

// @beta
export class HiliteSet {
    constructor(iModel: IModelConnection, syncWithSelectionSet?: boolean);
    clear(): void;
    // (undocumented)
    get elements(): Id64.Uint32Set;
    // (undocumented)
    iModel: IModelConnection;
    get isEmpty(): boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    setHilite(arg: Id64Arg, onOff: boolean): void;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
    get wantSyncWithSelectionSet(): boolean;
    set wantSyncWithSelectionSet(want: boolean);
}

// @public
export class HitDetail {
    constructor(testPoint: Point3d, viewport: ScreenViewport, hitSource: HitSource, hitPoint: Point3d, sourceId: string, priority: HitPriority, distXY: number, distFraction: number, subCategoryId?: string | undefined, geometryClass?: GeometryClass | undefined, modelId?: string | undefined, iModel?: IModelConnection, tileId?: string, isClassifier?: boolean);
    clone(): HitDetail;
    // (undocumented)
    readonly distFraction: number;
    // (undocumented)
    readonly distXY: number;
    draw(_context: DecorateContext): void;
    // (undocumented)
    readonly geometryClass?: GeometryClass | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    getToolTip(): Promise<HTMLElement | string>;
    // (undocumented)
    readonly hitPoint: Point3d;
    // (undocumented)
    readonly hitSource: HitSource;
    // @alpha
    get iModel(): IModelConnection;
    // @alpha (undocumented)
    readonly isClassifier: boolean;
    get isElementHit(): boolean;
    // @alpha
    get isExternalIModelHit(): boolean;
    // (undocumented)
    get isMapHit(): boolean;
    // (undocumented)
    get isModelHit(): boolean;
    isSameHit(otherHit?: HitDetail): boolean;
    // (undocumented)
    readonly modelId?: string | undefined;
    // (undocumented)
    readonly priority: HitPriority;
    // (undocumented)
    readonly sourceId: string;
    // (undocumented)
    readonly subCategoryId?: string | undefined;
    // (undocumented)
    readonly testPoint: Point3d;
    // @alpha (undocumented)
    readonly tileId?: string;
    // (undocumented)
    readonly viewport: ScreenViewport;
}

// @public (undocumented)
export enum HitDetailType {
    // (undocumented)
    Hit = 1,
    // (undocumented)
    Intersection = 3,
    // (undocumented)
    Snap = 2
}

// @public
export enum HitGeomType {
    // (undocumented)
    Arc = 4,
    // (undocumented)
    Curve = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Point = 1,
    // (undocumented)
    Segment = 2,
    // (undocumented)
    Surface = 5
}

// @public
export class HitList<T extends HitDetail> {
    addHit(newHit: T): number;
    compare(hit1: HitDetail | undefined, hit2: HitDetail | undefined): -1 | 1 | 0;
    // (undocumented)
    currHit: number;
    // (undocumented)
    dropNulls(): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    getCurrentHit(): T | undefined;
    getHit(hitNum: number): T | undefined;
    // (undocumented)
    getNextHit(): T | undefined;
    // (undocumented)
    hits: T[];
    insertHit(i: number, hit: T): void;
    // (undocumented)
    get length(): number;
    removeCurrentHit(): void;
    removeHit(hitNum: number): void;
    removeHitsFrom(sourceId: string): boolean;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    setCurrentHit(hit: T): void;
    setHit(i: number, p: T | undefined): void;
}

// @public (undocumented)
export interface HitListHolder {
    // (undocumented)
    setHitList(list: HitList<HitDetail> | undefined): void;
}

// @public
export enum HitParentGeomType {
    // (undocumented)
    Mesh = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sheet = 2,
    // (undocumented)
    Solid = 3,
    // (undocumented)
    Text = 5,
    // (undocumented)
    Wire = 1
}

// @public (undocumented)
export enum HitPriority {
    // (undocumented)
    NonPlanarEdge = 2,
    // (undocumented)
    NonPlanarSurface = 5,
    // (undocumented)
    PlanarEdge = 1,
    // (undocumented)
    PlanarSurface = 4,
    // (undocumented)
    SilhouetteEdge = 3,
    // (undocumented)
    Unknown = 6,
    // (undocumented)
    WireEdge = 0
}

// @public
export enum HitSource {
    // (undocumented)
    AccuSnap = 3,
    // (undocumented)
    Application = 6,
    // (undocumented)
    DataPoint = 5,
    // (undocumented)
    EditAction = 7,
    // (undocumented)
    EditActionSS = 8,
    // (undocumented)
    FromUser = 1,
    // (undocumented)
    MotionLocate = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    TentativeSnap = 4
}

// @internal
export class I3dmReader extends GltfReader {
    // (undocumented)
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, isCanceled?: ShouldAbortReadGltf, idMap?: BatchedTileIdMap): I3dmReader | undefined;
    // (undocumented)
    read(): Promise<GltfReaderResult>;
    // (undocumented)
    protected readFeatures(_features: Mesh.Features, _json: any): boolean;
    }

// @public
export class IconSprites {
    static emptyAll(): void;
    static getSpriteFromUrl(spriteUrl: string): Sprite;
    }

// @public
export class IdleTool extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    onMiddleButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(ev: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @public
export function imageBufferToBase64EncodedPng(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageBufferToCanvas(buffer: ImageBuffer, preserveAlpha?: boolean): HTMLCanvasElement | undefined;

// @public
export function imageBufferToPngDataUrl(buffer: ImageBuffer, preserveAlpha?: boolean): string | undefined;

// @public
export function imageElementFromImageSource(source: ImageSource): Promise<HTMLImageElement>;

// @public
export function imageElementFromUrl(url: string): Promise<HTMLImageElement>;

// @internal
export class ImageryMapLayerFormat extends MapLayerFormat {
    // (undocumented)
    static createMapLayerTree(layerSettings: MapLayerSettings, layerIndex: number, iModel: IModelConnection): MapLayerTileTreeReference | undefined;
}

// @internal
export class ImageryMapLayerTreeReference extends MapLayerTileTreeReference {
    constructor(layerSettings: MapLayerSettings, layerIndex: number, iModel: IModelConnection);
    // (undocumented)
    get castsShadows(): boolean;
    // (undocumented)
    get imageryProvider(): MapLayerImageryProvider | undefined;
    // (undocumented)
    iModel: IModelConnection;
    // (undocumented)
    get layerName(): string;
    get treeOwner(): TileTreeOwner;
}

// @internal (undocumented)
export class ImageryMapTile extends RealityTile {
    constructor(params: TileParams, imageryTree: ImageryMapTileTree, quadId: QuadId, rectangle: MapCartoRectangle);
    // (undocumented)
    protected _collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    disposeContents(): void;
    // (undocumented)
    freeMemory(): void;
    // (undocumented)
    imageryTree: ImageryMapTileTree;
    // (undocumented)
    get isDisplayable(): boolean;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, _reject: (error: Error) => void): void;
    // (undocumented)
    markMapTileUsage(): void;
    // (undocumented)
    quadId: QuadId;
    // (undocumented)
    rectangle: MapCartoRectangle;
    // (undocumented)
    releaseMapTileUsage(): void;
    // (undocumented)
    selectCartoDrapeTiles(drapeTiles: ImageryMapTile[], rectangleToDrape: MapCartoRectangle, drapePixelSize: number, args: TileDrawArgs): TileTreeLoadStatus;
    // (undocumented)
    setContent(content: ImageryTileContent): void;
    // (undocumented)
    setLeaf(): void;
    // (undocumented)
    get texture(): RenderTexture | undefined;
    // (undocumented)
    get tilingScheme(): WebMercatorTilingScheme;
}

// @internal (undocumented)
export class ImageryMapTileTree extends RealityTileTree {
    constructor(params: RealityTileTreeParams, _imageryLoader: ImageryTileLoader);
    // (undocumented)
    cartoRectangleFromQuadId(quadId: QuadId): MapCartoRectangle;
    // (undocumented)
    draw(_args: TileDrawArgs): void;
    // (undocumented)
    getLogo(vp: ScreenViewport): HTMLTableRowElement | undefined;
    // (undocumented)
    getTileRectangle(quadId: QuadId): MapCartoRectangle;
    // (undocumented)
    get imageryLoader(): ImageryTileLoader;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    selectCartoDrapeTiles(drapeTiles: ImageryMapTile[], tileToDrape: MapTile, args: TileDrawArgs): TileTreeLoadStatus;
    // (undocumented)
    protected _selectTiles(_args: TileDrawArgs): Tile[];
    // (undocumented)
    tilingScheme: WebMercatorTilingScheme;
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
}

// @internal (undocumented)
export interface ImageryTileContent extends TileContent {
    // (undocumented)
    imageryTexture?: RenderTexture;
}

// @internal
export class ImdlReader extends GltfReader {
    // (undocumented)
    protected colorDefFromMaterialJson(json: any): ColorDef | undefined;
    static create(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type?: BatchType, loadEdges?: boolean, isCanceled?: ShouldAbortReadGltf, sizeMultiplier?: number, tileId?: string): ImdlReader | undefined;
    // (undocumented)
    protected createDisplayParams(json: any): DisplayParams | undefined;
    // (undocumented)
    protected extractReturnToCenter(_extensions: any): number[] | undefined;
    // (undocumented)
    protected materialFromJson(key: string): RenderMaterial | undefined;
    read(): Promise<ImdlReaderResult>;
    // (undocumented)
    protected readFeatureTable(startPos: number): PackedFeatureTable | undefined;
    }

// @internal (undocumented)
export interface ImdlReaderResult extends IModelTileContent {
    // (undocumented)
    readStatus: TileReadStatus;
}

// @public
export class IModelApp {
    protected constructor();
    // @internal
    static get accuDraw(): AccuDraw;
    static get accuSnap(): AccuSnap;
    // @beta
    static get animationInterval(): BeDuration | undefined;
    static set animationInterval(interval: BeDuration | undefined);
    static get applicationId(): string;
    // @beta
    static applicationLogoCard?: () => HTMLTableRowElement;
    static get applicationVersion(): string;
    static authorizationClient?: FrontendAuthorizationClient;
    // @internal (undocumented)
    static createRenderSys(opts?: RenderSystem.Options): RenderSystem;
    // @beta
    static get extensionAdmin(): ExtensionAdmin;
    // @internal
    static get featureToggles(): FeatureToggleClient;
    // @alpha
    static formatElementToolTip(msg: string[]): HTMLElement;
    // @internal (undocumented)
    static get hasRenderSystem(): boolean;
    static get i18n(): I18N;
    static get iModelClient(): IModelClient;
    // @internal (undocumented)
    static get initialized(): boolean;
    // @internal (undocumented)
    static get locateManager(): ElementLocateManager;
    // @internal (undocumented)
    static lookupEntityClass(classFullName: string): typeof EntityState | undefined;
    // @internal
    static makeHTMLElement<K extends keyof HTMLElementTagNameMap>(type: K, opt?: {
        parent?: HTMLElement;
        className?: string;
        id?: string;
        innerHTML?: string;
        innerText?: string;
    }): HTMLElementTagNameMap[K];
    // @internal
    static makeIModelJsLogoCard(): HTMLTableRowElement;
    // @beta
    static makeLogoCard(opts: {
        heading: string | HTMLElement;
        iconSrc?: string | HTMLImageElement;
        iconWidth?: number;
        notice?: string | HTMLElement;
    }): HTMLTableRowElement;
    // @internal
    static makeModalDiv(options: ModalOptions): ModalReturn;
    // @internal
    static get mapLayerFormatRegistry(): MapLayerFormatRegistry;
    static get notifications(): NotificationManager;
    // @alpha
    static get quantityFormatter(): QuantityFormatter;
    // @beta
    static queryRenderCompatibility(): WebGLRenderCompatibilityInfo;
    // @internal
    static registerEntityState(classFullName: string, classType: typeof EntityState): void;
    // @internal
    static registerModuleEntities(moduleObj: any): void;
    static get renderSystem(): RenderSystem;
    // @internal (undocumented)
    static requestNextAnimation(): void;
    static get securityOptions(): FrontendSecurityOptions;
    static sessionId: GuidString;
    static get settings(): SettingsAdmin;
    static shutdown(): Promise<void>;
    // @internal (undocumented)
    static startEventLoop(): void;
    static startup(opts?: IModelAppOptions): Promise<void>;
    // @internal
    static stopEventLoop(): void;
    // @internal
    static readonly telemetry: TelemetryManager;
    // @internal (undocumented)
    static get tentativePoint(): TentativePoint;
    // @alpha
    static get tileAdmin(): TileAdmin;
    static get toolAdmin(): ToolAdmin;
    static readonly tools: ToolRegistry;
    // @beta
    static translateStatus(status: number): string;
    static get uiAdmin(): UiAdmin;
    static get viewManager(): ViewManager;
    }

// @public
export interface IModelAppOptions {
    // @internal
    accuDraw?: AccuDraw;
    accuSnap?: AccuSnap;
    applicationId?: string;
    applicationVersion?: string;
    authorizationClient?: FrontendAuthorizationClient;
    // @beta
    extensionAdmin?: ExtensionAdmin;
    // @internal
    featureToggles?: FeatureToggleClient;
    i18n?: I18N | I18NOptions;
    imodelClient?: IModelClient;
    // @internal (undocumented)
    locateManager?: ElementLocateManager;
    // @beta
    mapLayerOptions?: MapLayerOptions;
    notifications?: NotificationManager;
    // @internal (undocumented)
    quantityFormatter?: QuantityFormatter;
    // @internal (undocumented)
    renderSys?: RenderSystem | RenderSystem.Options;
    // (undocumented)
    rpcInterfaces?: RpcInterfaceDefinition[];
    security?: FrontendSecurityOptions;
    // @internal (undocumented)
    sessionId?: GuidString;
    settings?: SettingsAdmin;
    // @internal (undocumented)
    tentativePoint?: TentativePoint;
    // @beta
    tileAdmin?: TileAdmin.Props;
    toolAdmin?: ToolAdmin;
    uiAdmin?: UiAdmin;
    viewManager?: ViewManager;
}

// @public
export abstract class IModelConnection extends IModel {
    // @internal
    protected constructor(iModelProps: IModelConnectionProps);
    // @internal
    backgroundMapLocation: BackgroundMapLocation;
    // @internal
    protected beforeClose(): void;
    cartographicToSpatial(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    cartographicToSpatialFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    abstract close(): Promise<void>;
    readonly codeSpecs: IModelConnection.CodeSpecs;
    static connectionTimeout: number;
    // @internal (undocumented)
    disableGCS(disable: boolean): void;
    // @internal
    readonly displayedExtents: AxisAlignedBox3d;
    readonly elements: IModelConnection.Elements;
    // @internal
    expandDisplayedExtents(range: Range3d): void;
    findClassFor<T extends typeof EntityState>(className: string, defaultClass: T | undefined): Promise<T | undefined>;
    fontMap?: FontMap;
    // @internal
    readonly geoServices: GeoServices;
    // @beta
    getGeometryContainment(requestProps: GeometryContainmentRequestProps): Promise<GeometryContainmentResponseProps>;
    // @beta
    getMassProperties(requestProps: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    // @alpha
    getTextureImage(textureLoadProps: TextureLoadProps): Promise<Uint8Array | undefined>;
    getToolTipMessage(id: Id64String): Promise<string[]>;
    // @beta
    readonly hilited: HiliteSet;
    get isBlank(): boolean;
    isBlankConnection(): this is BlankConnection;
    get isBriefcase(): boolean;
    isBriefcaseConnection(): this is BriefcaseConnection;
    // @beta
    isCheckpointConnection(): this is CheckpointConnection;
    abstract get isClosed(): boolean;
    get isOpen(): boolean;
    get isReadonly(): boolean;
    // @deprecated
    isRemoteBriefcaseConnection(): this is RemoteBriefcaseConnection;
    get isSnapshot(): boolean;
    isSnapshotConnection(): this is SnapshotConnection;
    loadFontMap(): Promise<FontMap>;
    readonly models: IModelConnection.Models;
    // @internal
    get noGcsDefined(): boolean | undefined;
    // @internal
    protected _noGcsDefined?: boolean;
    static readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    // @beta
    readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    static readonly onOpen: BeEvent<(_imodel: IModelConnection) => void>;
    query(ecsql: string, bindings?: any[] | object, limitRows?: number, quota?: QueryQuota, priority?: QueryPriority, abbreviateBlobs?: boolean): AsyncIterableIterator<any>;
    queryEntityIds(params: EntityQueryParams): Promise<Id64Set>;
    queryRowCount(ecsql: string, bindings?: any[] | object): Promise<number>;
    // @internal
    queryRows(ecsql: string, bindings?: any[] | object, limit?: QueryLimit, quota?: QueryQuota, priority?: QueryPriority, restartToken?: string, abbreviateBlobs?: boolean): Promise<QueryResponse>;
    requestSnap(props: SnapRequestProps): Promise<SnapResponseProps>;
    // @beta
    restartQuery(token: string, ecsql: string, bindings?: any[] | object, limitRows?: number, quota?: QueryQuota, priority?: QueryPriority): AsyncIterableIterator<any>;
    routingContext: IModelRoutingContext;
    readonly selectionSet: SelectionSet;
    // @internal (undocumented)
    setEcefLocation(ecef: EcefLocationProps): void;
    spatialToCartographic(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    spatialToCartographicFromGcs(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // @internal
    readonly subcategories: SubCategoriesCache;
    // @beta
    readonly tiles: Tiles;
    readonly transientIds: TransientIdSequence;
    readonly views: IModelConnection.Views;
}

// @public (undocumented)
export namespace IModelConnection {
    export class CodeSpecs {
        // @internal
        constructor(_iModel: IModelConnection);
        getById(codeSpecId: Id64String): Promise<CodeSpec>;
        getByName(name: string): Promise<CodeSpec>;
        }
    export class Elements {
        // @internal
        constructor(_iModel: IModelConnection);
        getProps(arg: Id64Arg): Promise<ElementProps[]>;
        queryIds(params: EntityQueryParams): Promise<Id64Set>;
        queryProps(params: EntityQueryParams): Promise<ElementProps[]>;
        get rootSubjectId(): Id64String;
    }
    export class Models {
        // @internal
        constructor(_iModel: IModelConnection);
        filterLoaded(modelIds: Id64Arg): Id64Set | undefined;
        // @internal (undocumented)
        getDictionaryModel(): Promise<Id64String>;
        getLoaded(id: string): ModelState | undefined;
        getProps(modelIds: Id64Arg): Promise<ModelProps[]>;
        load(modelIds: Id64Arg): Promise<void>;
        loaded: Map<string, ModelState>;
        query(queryParams: ModelQueryParams): AsyncIterableIterator<ModelProps>;
        queryModelRanges(modelIds: Id64Arg): Promise<Range3dProps[]>;
        queryProps(queryParams: ModelQueryParams): Promise<ModelProps[]>;
        get repositoryModelId(): string;
    }
    export class Views {
        // @internal
        constructor(_iModel: IModelConnection);
        getThumbnail(viewId: Id64String): Promise<ThumbnailProps>;
        getViewList(queryParams: ViewQueryParams): Promise<ViewSpec[]>;
        load(viewDefinitionId: Id64String): Promise<ViewState>;
        queryDefaultViewId(): Promise<Id64String>;
        queryProps(queryParams: ViewQueryParams): Promise<ViewDefinitionProps[]>;
        saveThumbnail(viewId: Id64String, thumbnail: ThumbnailProps): Promise<void>;
    }
    export interface ViewSpec {
        class: string;
        id: string;
        name: string;
    }
}

// @internal (undocumented)
export class IModelFrameLifecycle {
    // (undocumented)
    static readonly onBeforeRender: BeEvent<(data: FrameBeforeRenderData) => void>;
    // (undocumented)
    static readonly onChangeCameraFrustum: BeEvent<(data: FrameCameraFrustumData) => void>;
    // (undocumented)
    static readonly onChangeCameraView: BeEvent<(data: FrameCameraViewData) => void>;
    // (undocumented)
    static readonly onRenderOpaque: BeEvent<(data: FrameRenderData) => void>;
}

// @public
export class IModelRoutingContext {
    // (undocumented)
    get active(): boolean;
    // (undocumented)
    static get current(): IModelRoutingContext | undefined;
    // (undocumented)
    static readonly default: IModelRoutingContext;
    // (undocumented)
    static for(token: RpcRoutingToken): IModelRoutingContext;
    // (undocumented)
    route<T>(handler: () => T): T;
    // (undocumented)
    readonly token: RpcRoutingToken;
}

// @internal
export class IModelTile extends Tile {
    constructor(params: IModelTileParams, tree: IModelTileTree);
    // (undocumented)
    protected addRangeGraphic(builder: GraphicBuilder, type: TileBoundingBoxes): void;
    cacheMiss: boolean;
    // (undocumented)
    get channel(): TileRequestChannel;
    // (undocumented)
    get emptySubRangeMask(): number;
    // (undocumented)
    get hasSizeMultiplier(): boolean;
    // (undocumented)
    get iModelChildren(): IModelTile[] | undefined;
    // (undocumented)
    get iModelTree(): IModelTileTree;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[]) => void, reject: (error: Error) => void): void;
    // (undocumented)
    get maximumSize(): number;
    // (undocumented)
    pruneChildren(olderThan: BeTimePoint): void;
    // (undocumented)
    protected get rangeGraphicColor(): ColorDef;
    // (undocumented)
    readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<IModelTileContent>;
    // (undocumented)
    requestContent(): Promise<TileRequest.Response>;
    // (undocumented)
    selectTiles(selected: Tile[], args: TileDrawArgs, numSkipped: number): SelectParent;
    // (undocumented)
    setContent(content: IModelTileContent): void;
    // (undocumented)
    get sizeMultiplier(): number | undefined;
    }

// @internal (undocumented)
export interface IModelTileContent extends TileContent {
    emptySubRangeMask?: number;
    sizeMultiplier?: number;
}

// @internal
export interface IModelTileParams extends TileParams {
    // (undocumented)
    sizeMultiplier?: number;
}

// @internal (undocumented)
export function iModelTileParamsFromJSON(props: TileProps, parent: IModelTile | undefined): IModelTileParams;

// @internal
export class IModelTileTree extends TileTree {
    constructor(params: IModelTileTreeParams);
    // (undocumented)
    get batchType(): BatchType;
    // (undocumented)
    readonly contentIdProvider: ContentIdProvider;
    // (undocumented)
    readonly contentIdQualifier?: string;
    debugMaxDepth?: number;
    // (undocumented)
    draw(args: TileDrawArgs): void;
    // (undocumented)
    readonly geometryGuid?: string;
    // (undocumented)
    get hasEdges(): boolean;
    get hiddenElements(): Id64Array;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    get loadPriority(): TileLoadPriority;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    readonly maxInitialTilesToSkip: number;
    // (undocumented)
    readonly maxTilesToSkip: number;
    // (undocumented)
    prune(): void;
    // (undocumented)
    get rootTile(): Tile;
    // (undocumented)
    protected _selectTiles(args: TileDrawArgs): Tile[];
    get staticBranch(): IModelTile;
    get tileState(): "static" | "dynamic" | "interactive" | "disposed";
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
}

// @internal (undocumented)
export interface IModelTileTreeOptions {
    // (undocumented)
    readonly allowInstancing: boolean;
    // (undocumented)
    readonly batchType: BatchType;
    // (undocumented)
    readonly edgesRequired: boolean;
    // (undocumented)
    readonly is3d: boolean;
}

// @internal
export interface IModelTileTreeParams extends TileTreeParams {
    // (undocumented)
    contentIdQualifier?: string;
    // (undocumented)
    formatVersion?: number;
    // (undocumented)
    geometryGuid?: GuidString;
    // (undocumented)
    maxInitialTilesToSkip?: number;
    // (undocumented)
    options: IModelTileTreeOptions;
    // (undocumented)
    rootTile: TileProps;
}

// @internal (undocumented)
export function iModelTileTreeParamsFromJSON(props: IModelTileTreeProps, iModel: IModelConnection, modelId: Id64String, options: IModelTileTreeOptions): IModelTileTreeParams;

// @public
export abstract class InputCollector extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): boolean;
}

// @public
export enum InputSource {
    Mouse = 1,
    Touch = 2,
    Unknown = 0
}

// @internal
export interface InstancedGraphicParams {
    readonly count: number;
    readonly featureIds?: Uint8Array;
    readonly symbologyOverrides?: Uint8Array;
    readonly transformCenter: Point3d;
    readonly transforms: Float32Array;
}

// @alpha
export class InteractiveEditingSession extends BriefcaseNotificationHandler implements IModelChangeNotifications {
    static begin(imodel: EditableConnection): Promise<InteractiveEditingSession>;
    // (undocumented)
    get briefcaseChannelName(): IpcAppChannel;
    end(): Promise<void>;
    static get(imodel: IModelConnection): InteractiveEditingSession | undefined;
    getGeometryChanges(): Iterable<ModelGeometryChanges>;
    getGeometryChangesForModel(modelId: Id64String): Iterable<ElementGeometryChange> | undefined;
    readonly iModel: EditableConnection;
    static isSupported(imodel: EditableConnection): Promise<boolean>;
    // @internal (undocumented)
    notifyElementsChanged(changed: ElementsChanged): void;
    // @internal (undocumented)
    notifyGeometryChanged(props: ModelGeometryChangesProps[]): void;
    static readonly onBegin: BeEvent<(session: InteractiveEditingSession) => void>;
    readonly onElementChanges: BeEvent<(changes: ElementsChanged, iModel: EditableConnection) => void>;
    readonly onEnded: BeEvent<(session: InteractiveEditingSession) => void>;
    readonly onEnding: BeEvent<(session: InteractiveEditingSession) => void>;
    readonly onGeometryChanges: BeEvent<(changes: Iterable<ModelGeometryChanges>, session: InteractiveEditingSession) => void>;
}

// @public
export abstract class InteractiveTool extends Tool {
    // @beta
    applyToolSettingPropertyChange(_updatedValue: DialogPropertySyncItem): boolean;
    beginDynamics(): void;
    // @beta
    bumpToolSetting(_settingIndex?: number): Promise<boolean>;
    changeLocateState(enableLocate: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    decorate(_context: DecorateContext): void;
    decorateSuspended(_context: DecorateContext): void;
    endDynamics(): void;
    // (undocumented)
    abstract exitTool(): void;
    filterHit(_hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    getCurrentButtonEvent(ev: BeButtonEvent): void;
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string>;
    initLocateElements(enableLocate?: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    // (undocumented)
    isCompatibleViewport(_vp: ScreenViewport, _isSelectedViewChange: boolean): boolean;
    get isDynamicsStarted(): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    onCleanup(): void;
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onDynamicFrame(_ev: BeButtonEvent, _context: DynamicsContext): void;
    onInstall(): boolean;
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): Promise<EventHandled>;
    onMiddleButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onMiddleButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(_ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled>;
    onMouseWheel(_ev: BeWheelEvent): Promise<EventHandled>;
    onPostInstall(): void;
    onReinitialize(): void;
    onResetButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onSelectedViewportChanged(_previous: ScreenViewport | undefined, _current: ScreenViewport | undefined): void;
    onSuspend(): void;
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    onTouchEnd(_ev: BeTouchEvent): Promise<void>;
    onTouchMove(_ev: BeTouchEvent): Promise<void>;
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): Promise<EventHandled>;
    onTouchStart(_ev: BeTouchEvent): Promise<void>;
    onTouchTap(_ev: BeTouchEvent): Promise<EventHandled>;
    onUnsuspend(): void;
    receivedDownEvent: boolean;
    // @beta
    reloadToolSettingsProperties(): void;
    // @beta
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // @beta
    syncToolSettingsProperties(syncData: DialogPropertySyncItem[]): void;
    testDecorationHit(_id: string): boolean;
}

// @internal (undocumented)
export const internalMapLayerImageryFormats: (typeof WmsMapLayerFormat)[];

// @public (undocumented)
export class IntersectDetail extends SnapDetail {
    constructor(from: SnapDetail, heat: SnapHeat | undefined, snapPoint: XYZProps, otherPrimitive: CurvePrimitive, otherId: string);
    // (undocumented)
    draw(context: DecorateContext): void;
    // (undocumented)
    readonly otherId: string;
    // (undocumented)
    readonly otherPrimitive: CurvePrimitive;
}

// @beta
export class IpcApp {
    static addListener(channel: string, handler: IpcListener): RemoveFunction;
    // @internal
    static callIpcChannel(channelName: string, methodName: string, ...args: any[]): Promise<any>;
    // (undocumented)
    static callIpcHost<T extends AsyncMethodsOf<IpcAppFunctions>>(methodName: T, ...args: Parameters<IpcAppFunctions[T]>): Promise<PromiseReturnType<IpcAppFunctions[T]>>;
    static invoke(channel: string, ...args: any[]): Promise<any>;
    static get isValid(): boolean;
    static removeListener(channel: string, listener: IpcListener): void;
    static send(channel: string, ...data: any[]): void;
    // (undocumented)
    static shutdown(): Promise<void>;
    // (undocumented)
    static startup(opts?: {
        ipcApp?: IpcAppOptions;
        iModelApp?: IModelAppOptions;
    }): Promise<void>;
}

// @beta
export interface IpcAppOptions {
    ipc: IpcSocketFrontend;
}

// @alpha
export const isCheckboxFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is CheckboxFormatPropEditorSpec;

// @alpha
export function isCustomQuantityTypeDefinition(item: QuantityTypeDefinition): item is CustomQuantityTypeDefinition;

// @alpha
export const isTextInputFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is TextInputFormatPropEditorSpec;

// @alpha
export const isTextSelectFormatPropEditorSpec: (item: CustomFormatPropEditorSpec) => item is TextSelectFormatPropEditorSpec;

// @alpha (undocumented)
export enum ItemField {
    // (undocumented)
    ANGLE_Item = 1,
    // (undocumented)
    DIST_Item = 0,
    // (undocumented)
    X_Item = 2,
    // (undocumented)
    Y_Item = 3,
    // (undocumented)
    Z_Item = 4
}

// @beta
export enum KeyinParseError {
    MismatchedQuotes = 4,
    ToolNotFound = 1
}

// @internal (undocumented)
export enum KeyinStatus {
    // (undocumented)
    DontUpdate = 2,
    // (undocumented)
    Dynamic = 0,
    // (undocumented)
    Partial = 1
}

// @beta
export class LengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export function linePlaneIntersect(outP: Point3d, linePt: Point3d, lineNormal: Vector3d | undefined, planePt: Point3d, planeNormal: Vector3d, perpendicular: boolean): void;

// @internal (undocumented)
export interface LoadedExtensionProps {
    // (undocumented)
    basePath: string;
    // (undocumented)
    props: ExtensionProps;
}

// @internal
export class LocalhostIpcApp {
    // (undocumented)
    static startup(opts: {
        localhostIpcApp?: {
            socketPort?: number;
        };
        webViewerApp: WebViewerAppOptions;
        iModelApp?: IModelAppOptions;
    }): Promise<void>;
}

// @public
export enum LocateAction {
    // (undocumented)
    AutoLocate = 1,
    // (undocumented)
    Identify = 0
}

// @public
export enum LocateFilterStatus {
    // (undocumented)
    Accept = 0,
    // (undocumented)
    Reject = 1
}

// @public
export class LocateOptions {
    allowDecorations: boolean;
    // @alpha
    allowExternalIModels: boolean;
    allowNonLocatable: boolean;
    clone(): LocateOptions;
    hitSource: HitSource;
    // (undocumented)
    init(): void;
    maxHits: number;
    // (undocumented)
    setFrom(other: LocateOptions): void;
}

// @public (undocumented)
export class LocateResponse {
    // @internal (undocumented)
    clone(): LocateResponse;
    // (undocumented)
    explanation: string;
    // (undocumented)
    reason?: string;
    // @internal (undocumented)
    setFrom(other: LocateResponse): void;
    // (undocumented)
    snapStatus: SnapStatus;
}

// @internal (undocumented)
export enum LockedStates {
    // (undocumented)
    ANGLE_BM = 7,
    // (undocumented)
    DIST_BM = 8,
    // (undocumented)
    NONE_LOCKED = 0,
    // (undocumented)
    VEC_BM = 4,
    // (undocumented)
    X_BM = 1,
    // (undocumented)
    XY_BM = 3,
    // (undocumented)
    Y_BM = 2
}

// @internal (undocumented)
export const loggerCategory = "imodeljs-frontend.Extension";

// @beta
export class LookAndMoveTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class LookViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @internal
export class LRUTileList {
    constructor();
    add(tile: Tile): void;
    // (undocumented)
    protected append(tile: Tile): void;
    // (undocumented)
    protected assertList(): void;
    clearSelectedForViewport(viewportId: number): void;
    // (undocumented)
    protected computeBytesUsed(tile: Tile): number;
    // (undocumented)
    dispose(): void;
    drop(tile: Tile): void;
    freeMemory(maxBytes: number): void;
    // (undocumented)
    protected _head: LRUTileListNode;
    markSelectedForViewport(viewportId: number, tiles: Iterable<Tile>): void;
    // (undocumented)
    protected moveBeforeSentinel(tile: Tile): void;
    // (undocumented)
    protected moveToEnd(tile: Tile): void;
    get selectedTiles(): Iterable<Tile>;
    // (undocumented)
    protected readonly _sentinel: LRUTileListNode;
    // (undocumented)
    protected readonly _stats: RenderMemory.Statistics;
    // (undocumented)
    protected _tail: LRUTileListNode;
    get totalBytesUsed(): number;
    // (undocumented)
    protected _totalBytesUsed: number;
    // (undocumented)
    protected unlink(tile: Tile): void;
    get unselectedTiles(): Iterable<Tile>;
    // (undocumented)
    protected readonly _viewportIdSets: ViewportIdSets;
}

// @internal
export interface LRUTileListNode {
    bytesUsed: number;
    // (undocumented)
    next?: LRUTileListNode;
    // (undocumented)
    previous?: LRUTileListNode;
    viewportIds?: ViewportIdSet | undefined;
}

// @alpha (undocumented)
export enum ManipulatorToolEvent {
    // (undocumented)
    Start = 1,
    // (undocumented)
    Stop = 2,
    // (undocumented)
    Suspend = 3,
    // (undocumented)
    Unsuspend = 4
}

// @internal
export class MapBoxLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    getLogo(_vp: ScreenViewport): HTMLTableRowElement | undefined;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    get minimumZoomLevel(): number;
    // (undocumented)
    get tileHeight(): number;
    // (undocumented)
    get tileWidth(): number;
    }

// @internal
export class MapCartoRectangle extends Range2d {
    constructor(west?: number, south?: number, east?: number, north?: number);
    // (undocumented)
    get cartoCenter(): Cartographic;
    // (undocumented)
    containsCartographic(carto: Cartographic): boolean;
    // (undocumented)
    static create(west?: number, south?: number, east?: number, north?: number, result?: MapCartoRectangle): MapCartoRectangle;
    // (undocumented)
    static createFromDegrees(west?: number, south?: number, east?: number, north?: number, result?: MapCartoRectangle): MapCartoRectangle;
    // (undocumented)
    get east(): number;
    set east(x: number);
    // (undocumented)
    fractionFromCartographic(carto: Cartographic): Point2d | undefined;
    // (undocumented)
    getCenter(result?: Cartographic): Cartographic;
    // (undocumented)
    getTileFractionRange(tilingScheme: MapTilingScheme): Range2d;
    // (undocumented)
    get globalLocation(): GlobalLocation;
    // (undocumented)
    get globalLocationArea(): GlobalLocationArea;
    // (undocumented)
    init(west?: number, south?: number, east?: number, north?: number): void;
    // (undocumented)
    get latLongString(): string;
    // (undocumented)
    get north(): number;
    set north(y: number);
    // (undocumented)
    get south(): number;
    set south(y: number);
    // (undocumented)
    get west(): number;
    set west(x: number);
}

// @internal (undocumented)
export class MapLayerFormat {
    // (undocumented)
    static createImageryProvider(_settings: MapLayerSettings): MapLayerImageryProvider | undefined;
    // (undocumented)
    static createMapLayerTree(_layerSettings: MapLayerSettings, _layerIndex: number, _iModel: IModelConnection): MapLayerTileTreeReference | undefined;
    // (undocumented)
    static formatId: string;
    // (undocumented)
    static register(): void;
    // (undocumented)
    static validateSource(_url: string, _credentials?: RequestBasicCredentials, _ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal (undocumented)
export class MapLayerFormatRegistry {
    constructor(opts: MapLayerOptions);
    // (undocumented)
    get configOptions(): MapLayerOptions;
    // (undocumented)
    createImageryMapLayerTree(layerSettings: MapLayerSettings, layerIndex: number, iModel: IModelConnection): ImageryMapLayerTreeReference | undefined;
    // (undocumented)
    createImageryProvider(layerSettings: MapLayerSettings): MapLayerImageryProvider | undefined;
    // (undocumented)
    register(formatClass: MapLayerFormatType): void;
    // (undocumented)
    validateSource(formatId: string, url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal (undocumented)
export type MapLayerFormatType = typeof MapLayerFormat;

// @internal
export abstract class MapLayerImageryProvider {
    constructor(_settings: MapLayerSettings, _usesCachedTiles: boolean);
    // (undocumented)
    protected _areChildrenAvailable(_tile: ImageryMapTile): Promise<boolean>;
    // (undocumented)
    cartoRange?: MapCartoRectangle;
    // (undocumented)
    abstract constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    protected get _filterByCartoRange(): boolean;
    // (undocumented)
    getEPSG3857Extent(row: number, column: number, zoomLevel: number): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    // (undocumented)
    getEPSG3857ExtentString(row: number, column: number, zoomLevel: number): string;
    // (undocumented)
    getEPSG3857X(longitude: number): number;
    // (undocumented)
    getEPSG3857Y(latitude: number): number;
    // (undocumented)
    protected getImageFromTileResponse(tileResponse: Response, zoomLevel: number): ImageSource | undefined;
    // (undocumented)
    getLogo(_viewport: ScreenViewport): HTMLTableRowElement | undefined;
    // (undocumented)
    protected getRequestAuthorization(): RequestBasicCredentials | undefined;
    // (undocumented)
    getToolTip(_strings: string[], _quadId: QuadId, _carto: Cartographic, _tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    protected _hasSuccessfullyFetchedTile: boolean;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    makeTileRequest(url: string): Promise<Response>;
    // (undocumented)
    matchesMissingTile(tileData: Uint8Array): boolean;
    // (undocumented)
    get maximumScreenSize(): number;
    // (undocumented)
    get maximumZoomLevel(): number;
    // (undocumented)
    get minimumZoomLevel(): number;
    // (undocumented)
    protected _missingTileData?: Uint8Array;
    // (undocumented)
    get mutualExclusiveSubLayer(): boolean;
    // (undocumented)
    readonly onStatusChanged: BeEvent<(provider: MapLayerImageryProvider) => void>;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
    // (undocumented)
    setStatus(status: MapLayerImageryProviderStatus): void;
    // (undocumented)
    protected readonly _settings: MapLayerSettings;
    // (undocumented)
    status: MapLayerImageryProviderStatus;
    // (undocumented)
    testChildAvailability(tile: ImageryMapTile, resolveChildren: () => void): void;
    // (undocumented)
    protected _testChildAvailability(_tile: ImageryMapTile, resolveChildren: () => void): void;
    // (undocumented)
    get tileSize(): number;
    // (undocumented)
    protected toolTipFromJsonUrl(_strings: string[], url: string): Promise<void>;
    // (undocumented)
    protected toolTipFromUrl(strings: string[], url: string): Promise<void>;
    // (undocumented)
    get transparentBackgroundString(): string;
    // (undocumented)
    get usesCachedTiles(): boolean;
    // (undocumented)
    protected _usesCachedTiles: boolean;
}

// @internal (undocumented)
export enum MapLayerImageryProviderStatus {
    // (undocumented)
    RequireAuth = 1,
    // (undocumented)
    Valid = 0
}

// @beta
export interface MapLayerOptions {
    // (undocumented)
    [format: string]: MapLayerKey | undefined;
    // (undocumented)
    AzureMaps?: MapLayerKey;
    // (undocumented)
    BingMaps?: MapLayerKey;
    // (undocumented)
    MapBoxImagery?: MapLayerKey;
}

// @internal (undocumented)
export interface MapLayerSetting {
    // (undocumented)
    formatId: string;
    // (undocumented)
    maxZoom: number | undefined;
    // (undocumented)
    name: string;
    // (undocumented)
    transparentBackground: boolean | undefined;
    // (undocumented)
    url: string;
}

// @internal (undocumented)
export class MapLayerSettingsService {
    static getSourcesFromSettingsService(projectId: GuidString, iModelId: GuidString): Promise<MapLayerSource[]>;
    // (undocumented)
    static readonly onNewCustomLayerSource: BeEvent<(source: MapLayerSource) => void>;
    // (undocumented)
    static get SourceNamespace(): string;
    static storeSourceInSettingsService(source: MapLayerSource, storeOnIModel: boolean, projectId: GuidString, iModelId: GuidString): Promise<boolean>;
}

// @internal
export class MapLayerSource implements MapLayerProps {
    // (undocumented)
    baseMap: boolean;
    // (undocumented)
    formatId: string;
    // (undocumented)
    static fromBackgroundMapProps(props: BackgroundMapProps): MapLayerSource | undefined;
    // (undocumented)
    static fromJSON(json: any): MapLayerSource | undefined;
    // (undocumented)
    maxZoom?: number | undefined;
    // (undocumented)
    name: string;
    // (undocumented)
    password?: string | undefined;
    // (undocumented)
    subLayers?: MapSubLayerProps[];
    // (undocumented)
    toJSON(): {
        url: string;
        name: string;
        formatId: string;
        maxZoom: number | undefined;
        transparentBackground: boolean | undefined;
    };
    // (undocumented)
    toLayerSettings(): MapLayerSettings | undefined;
    // (undocumented)
    transparentBackground?: boolean | undefined;
    // (undocumented)
    url: string;
    // (undocumented)
    userName?: string | undefined;
    // (undocumented)
    validateSource(ignoreCache?: boolean): Promise<MapLayerSourceValidation>;
}

// @internal
export class MapLayerSources {
    // (undocumented)
    static addSourceToMapLayerSources(mapLayerSource?: MapLayerSource): Promise<MapLayerSources | undefined>;
    // (undocumented)
    get allSource(): MapLayerSource[];
    // (undocumented)
    get bases(): MapLayerSource[];
    // (undocumented)
    static create(iModel?: IModelConnection, queryForPublicSources?: boolean, addMapBoxSources?: boolean): Promise<MapLayerSources>;
    // (undocumented)
    findByName(name: string, baseMap?: boolean): MapLayerSource | undefined;
    // (undocumented)
    get layers(): MapLayerSource[];
    }

// @internal (undocumented)
export enum MapLayerSourceStatus {
    // (undocumented)
    InvalidCredentials = 1,
    // (undocumented)
    InvalidFormat = 2,
    // (undocumented)
    InvalidTileTree = 3,
    // (undocumented)
    InvalidUrl = 4,
    // (undocumented)
    RequireAuth = 5,
    // (undocumented)
    Valid = 0
}

// @internal (undocumented)
export interface MapLayerSourceValidation {
    // (undocumented)
    status: MapLayerSourceStatus;
    // (undocumented)
    subLayers?: MapSubLayerProps[];
}

// @internal (undocumented)
export abstract class MapLayerTileTreeReference extends TileTreeReference {
    constructor(_layerSettings: MapLayerSettings, _layerIndex: number);
    // (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string | undefined>;
    // (undocumented)
    protected get _imageryProvider(): MapLayerImageryProvider | undefined;
    // (undocumented)
    protected _layerIndex: number;
    set layerSettings(layerSettings: MapLayerSettings);
    // (undocumented)
    get layerSettings(): MapLayerSettings;
    // (undocumented)
    protected _layerSettings: MapLayerSettings;
    // (undocumented)
    protected get _transparency(): number | undefined;
}

// @internal (undocumented)
export class MapTile extends RealityTile {
    constructor(params: TileParams, mapTree: MapTileTree, quadId: QuadId, _patch: TilePatch, rectangle: MapCartoRectangle, heightRange: Range1d | undefined, _cornerRays: Ray3d[] | undefined);
    // (undocumented)
    addBoundingGraphic(builder: GraphicBuilder, color: ColorDef): void;
    // (undocumented)
    adjustHeights(minHeight: number, maxHeight: number): void;
    // (undocumented)
    get baseImageryIsReady(): boolean;
    // (undocumented)
    clearLayers(): void;
    // (undocumented)
    protected _collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    static computeRangeCorners(corners: Point3d[], normal: Vector3d, chordHeight: number, result: Point3d[], heightRange?: Range1d): Point3d[];
    // (undocumented)
    protected _cornerRays: Ray3d[] | undefined;
    // (undocumented)
    disposeContents(): void;
    // (undocumented)
    everLoaded: boolean;
    forceSelectRealityTile(): boolean;
    // (undocumented)
    freeMemory(): void;
    // (undocumented)
    get geometry(): RenderTerrainMeshGeometry | undefined;
    // (undocumented)
    protected _geometry?: RenderTerrainMeshGeometry;
    // (undocumented)
    getClipShape(): Point3d[];
    // (undocumented)
    getContentClip(): ClipVector | undefined;
    // (undocumented)
    getDrapeTextures(): TerrainTexture[] | undefined;
    // (undocumented)
    getGraphic(_system: RenderSystem, _texture: RenderTexture): RenderGraphic | undefined;
    // (undocumented)
    getProjection(heightRange?: Range1d): MapTileProjection;
    // (undocumented)
    getRangeCorners(result: Point3d[]): Point3d[];
    // (undocumented)
    getSizeProjectionCorners(): Point3d[] | undefined;
    // (undocumented)
    get graphicType(): TileGraphicType;
    // (undocumented)
    get hasGraphics(): boolean;
    get heightRange(): Range1d | undefined;
    // (undocumented)
    protected _heightRange: Range1d | undefined;
    // (undocumented)
    get imageryIsReady(): boolean;
    // (undocumented)
    get imageryTiles(): ImageryMapTile[] | undefined;
    // (undocumented)
    isContentCulled(args: TileDrawArgs): boolean;
    get isDisplayable(): boolean;
    // (undocumented)
    isOccluded(viewingSpace: ViewingSpace): boolean;
    // (undocumented)
    get isPlanar(): boolean;
    // (undocumented)
    get isReady(): boolean;
    // (undocumented)
    isRegionCulled(args: TileDrawArgs): boolean;
    // (undocumented)
    get isUpsampled(): boolean;
    // (undocumented)
    get loadableTerrainTile(): MapTile;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, _reject: (error: Error) => void): void;
    // (undocumented)
    get mapLoader(): MapTileLoader;
    // (undocumented)
    get mapTilingScheme(): import("./MapTilingScheme").MapTilingScheme;
    // (undocumented)
    readonly mapTree: MapTileTree;
    // (undocumented)
    markUsed(args: TileDrawArgs): void;
    // (undocumented)
    get mesh(): TerrainMeshPrimitive | undefined;
    // (undocumented)
    protected _mesh?: TerrainMeshPrimitive;
    // (undocumented)
    produceGraphics(): RenderGraphic | undefined;
    // (undocumented)
    quadId: QuadId;
    // (undocumented)
    readonly rectangle: MapCartoRectangle;
    selectSecondaryTiles(args: TileDrawArgs, context: TraversalSelectionContext): void;
    // (undocumented)
    setContent(content: TerrainTileContent): void;
    // (undocumented)
    setNotFound(): void;
    // (undocumented)
    tileFromQuadId(quadId: QuadId): MapTile | undefined;
}

// @internal
export class MapTileLoader extends RealityTileLoader {
    constructor(_iModel: IModelConnection, _modelId: Id64String, _groundBias: number, _terrainProvider: TerrainMeshProvider);
    // (undocumented)
    protected _applyLights: boolean;
    // (undocumented)
    get clipLowResolutionTiles(): boolean;
    // (undocumented)
    readonly featureTable: FeatureTable;
    // (undocumented)
    forceTileLoad(tile: Tile): boolean;
    // (undocumented)
    getChildHeightRange(quadId: QuadId, rectangle: MapCartoRectangle, parent: MapTile): Range1d | undefined;
    // (undocumented)
    getFeatureIndex(layerModelId: Id64String): number;
    // (undocumented)
    getRequestChannel(_tile: Tile): import("../TileRequestChannel").TileRequestChannel;
    // (undocumented)
    protected _groundBias: number;
    // (undocumented)
    protected readonly _heightRange: Range1d | undefined;
    // (undocumented)
    protected _iModel: IModelConnection;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    isTileAvailable(quadId: QuadId): boolean;
    // (undocumented)
    loadChildren(_tile: RealityTile): Promise<Tile[] | undefined>;
    // (undocumented)
    loadTileContent(tile: MapTile, data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TerrainTileContent>;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    protected _modelId: Id64String;
    // (undocumented)
    get priority(): TileLoadPriority;
    // (undocumented)
    requestTileContent(tile: Tile, _isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    get terrainProvider(): TerrainMeshProvider;
    }

// @internal (undocumented)
export abstract class MapTileProjection {
    // (undocumented)
    get ellipsoidPatch(): EllipsoidPatch | undefined;
    // (undocumented)
    abstract getPoint(u: number, v: number, height: number, result?: Point3d): Point3d;
    // (undocumented)
    abstract get localRange(): Range3d;
    // (undocumented)
    abstract get transformFromLocal(): Transform;
}

// @internal (undocumented)
export class MapTileTree extends RealityTileTree {
    constructor(params: RealityTileTreeParams, ecefToDb: Transform, bimElevationBias: number, geodeticOffset: number, gcsConverterAvailable: boolean, sourceTilingScheme: MapTilingScheme, id: MapTreeId);
    // (undocumented)
    addImageryLayer(tree: ImageryMapTileTree, settings: MapLayerSettings): void;
    // (undocumented)
    baseColor?: ColorDef;
    // (undocumented)
    baseTransparent: boolean;
    // (undocumented)
    bimElevationBias: number;
    // (undocumented)
    cartesianRange: Range3d;
    // (undocumented)
    cartesianTransitionDistance: number;
    // (undocumented)
    clearImageryLayers(): void;
    // (undocumented)
    clearLayers(): void;
    // (undocumented)
    createGlobeChild(params: TileParams, quadId: QuadId, _rangeCorners: Point3d[], rectangle: MapCartoRectangle, ellipsoidPatch: EllipsoidPatch, heightRange?: Range1d): MapTile;
    // (undocumented)
    createPlanarChild(params: TileParams, quadId: QuadId, corners: Point3d[], normal: Vector3d, rectangle: MapCartoRectangle, chordHeight: number, heightRange?: Range1d): MapTile;
    // (undocumented)
    doCreateGlobeChildren(tile: Tile): boolean;
    // (undocumented)
    doReprojectChildren(tile: Tile): boolean;
    // (undocumented)
    earthEllipsoid: Ellipsoid;
    // (undocumented)
    ecefToDb: Transform;
    // (undocumented)
    geodeticOffset: number;
    // (undocumented)
    getBaseRealityDepth(sceneContext: SceneContext): number;
    // (undocumented)
    getCachedReprojectedPoints(gridPoints: Point3d[]): Point3d[] | undefined;
    // (undocumented)
    getChildHeightRange(quadId: QuadId, rectangle: MapCartoRectangle, parent: MapTile): Range1d | undefined;
    // (undocumented)
    getCornerRays(rectangle: MapCartoRectangle): Ray3d[] | undefined;
    // (undocumented)
    getFractionalTileCorners(quadId: QuadId): Point3d[];
    // (undocumented)
    getLayerIndex(imageryTreeId: Id64String): number;
    // (undocumented)
    getLayerTransparency(imageryTreeId: Id64String): number;
    // (undocumented)
    getPlanarChildCorners(tile: MapTile, columnCount: number, rowCount: number, resolve: (childCorners: Point3d[][]) => void): void;
    // (undocumented)
    getTileRectangle(quadId: QuadId): MapCartoRectangle;
    // (undocumented)
    globeMode: GlobeMode;
    // (undocumented)
    globeOrigin: Point3d;
    // (undocumented)
    imageryTrees: ImageryMapTileTree[];
    // (undocumented)
    isOverlay: boolean;
    // (undocumented)
    get isTransparent(): boolean;
    // (undocumented)
    loadReprojectionCache(tile: MapTile): Promise<void>;
    // (undocumented)
    get mapLoader(): MapTileLoader;
    // (undocumented)
    mapTransparent: boolean;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    maxEarthEllipsoid: Ellipsoid;
    // (undocumented)
    static maxGlobeDisplayDepth: number;
    // (undocumented)
    static minDisplayableDepth: number;
    // (undocumented)
    minEarthEllipsoid: Ellipsoid;
    // (undocumented)
    static minReprojectionDepth: number;
    // (undocumented)
    pointAboveEllipsoid(point: Point3d): boolean;
    // (undocumented)
    sourceTilingScheme: MapTilingScheme;
    // (undocumented)
    terrainExaggeration: number;
    // (undocumented)
    tileFromQuadId(quadId: QuadId): MapTile | undefined;
    // (undocumented)
    useDepthBuffer: boolean;
}

// @internal
export class MapTileTreeReference extends TileTreeReference {
    constructor(settings: BackgroundMapSettings, _baseLayerSettings: BaseLayerSettings | undefined, _layerSettings: MapLayerSettings[], iModel: IModelConnection, isOverlay: boolean, _isDrape: boolean, _overrideTerrainDisplay?: CheckTerrainDisplayOverride | undefined);
    addLogoCards(cards: HTMLTableElement, vp: ScreenViewport): void;
    addToScene(context: SceneContext): void;
    // (undocumented)
    get baseColor(): ColorDef | undefined;
    // (undocumented)
    get castsShadows(): boolean;
    // (undocumented)
    clearLayers(): void;
    // (undocumented)
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
    // (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    getLayerImageryTreeRef(index: number): ImageryMapLayerTreeReference | undefined;
    // (undocumented)
    protected getSymbologyOverrides(_tree: TileTree): FeatureSymbology.Overrides;
    // (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string | undefined>;
    // (undocumented)
    protected getViewFlagOverrides(_tree: TileTree): import("@bentley/imodeljs-common").ViewFlagOverrides;
    // (undocumented)
    imageryTreeFromTreeModelIds(mapTreeModelId: Id64String, layerTreeModelId: Id64String): ImageryMapLayerTreeReference | undefined;
    // (undocumented)
    initializeImagery(): boolean;
    // (undocumented)
    get isGlobal(): boolean;
    // (undocumented)
    protected get _isLoadingComplete(): boolean;
    // (undocumented)
    isOverlay: boolean;
    // (undocumented)
    layerFromTreeModelIds(mapTreeModelId: Id64String, layerTreeModelId: Id64String): MapLayerSettings | undefined;
    // (undocumented)
    get planarclipMaskPriority(): number;
    // (undocumented)
    setBaseLayerSettings(baseLayerSettings: BaseLayerSettings): void;
    // (undocumented)
    setLayerSettings(layerSettings: MapLayerSettings[]): void;
    // (undocumented)
    get settings(): BackgroundMapSettings;
    set settings(settings: BackgroundMapSettings);
    // (undocumented)
    get treeOwner(): TileTreeOwner;
    unionFitRange(_range: Range3d): void;
    // (undocumented)
    get useDepthBuffer(): boolean;
}

// @internal (undocumented)
export abstract class MapTilingScheme {
    protected constructor(numberOfLevelZeroTilesX: number, numberOfLevelZeroTilesY: number, rowZeroAtNorthPole: boolean);
    // (undocumented)
    cartographicToFraction(latitudeRadians: number, longitudeRadians: number, result: Point2d): Point2d;
    cartographicToTileXY(carto: Cartographic, level: number, result?: Point2d): Point2d;
    // (undocumented)
    computeMercatorFractionToDb(ecefToDb: Transform, bimElevationOffset: number, iModel: IModelConnection, applyTerrain: boolean): Transform;
    fractionToCartographic(xFraction: number, yFraction: number, result: Cartographic, height?: number): Cartographic;
    getNumberOfXTilesAtLevel(level: number): number;
    getNumberOfYTilesAtLevel(level: number): number;
    // (undocumented)
    abstract latitudeToYFraction(latitude: number): number;
    // (undocumented)
    longitudeToXFraction(longitude: number): number;
    // (undocumented)
    readonly numberOfLevelZeroTilesX: number;
    // (undocumented)
    readonly numberOfLevelZeroTilesY: number;
    // (undocumented)
    rowZeroAtNorthPole: boolean;
    // (undocumented)
    tileBordersNorthPole(row: number, level: number): boolean;
    // (undocumented)
    tileBordersSouthPole(row: number, level: number): boolean;
    // (undocumented)
    tileXToFraction(x: number, level: number): number;
    // (undocumented)
    tileXToLongitude(x: number, level: number): number;
    tileXYToCartographic(x: number, y: number, level: number, result: Cartographic, height?: number): Cartographic;
    tileXYToFraction(x: number, y: number, level: number, result?: Point2d): Point2d;
    // (undocumented)
    tileXYToRectangle(x: number, y: number, level: number, result?: MapCartoRectangle): MapCartoRectangle;
    // (undocumented)
    tileYToFraction(y: number, level: number): number;
    // (undocumented)
    tileYToLatitude(y: number, level: number): number;
    xFractionToLongitude(xFraction: number): number;
    // (undocumented)
    xFractionToTileX(xFraction: number, level: number): number;
    // (undocumented)
    abstract yFractionToLatitude(yFraction: number): number;
    // (undocumented)
    yFractionToTileY(yFraction: number, level: number): number;
}

// @public
export class MarginPercent {
    constructor(left: number, top: number, right: number, bottom: number);
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public
export class Marker implements CanvasDecoration {
    constructor(worldLocation: XYAndZ, size: XAndY);
    addDecoration(context: DecorateContext): void;
    addMarker(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    drawFunc?(ctx: CanvasRenderingContext2D): void;
    protected drawHilited(ctx: CanvasRenderingContext2D): boolean;
    protected _hiliteColor?: ColorDef;
    htmlElement?: HTMLElement;
    image?: MarkerImage;
    imageOffset?: XAndY;
    imageSize?: XAndY;
    protected _isHilited: boolean;
    label?: string;
    labelAlign?: MarkerTextAlign;
    labelBaseline?: MarkerTextBaseline;
    labelColor?: MarkerFillStyle;
    labelFont?: string;
    labelMaxWidth?: number;
    labelOffset?: XAndY;
    static makeFrom<T extends Marker>(other: Marker, ...args: any[]): T;
    onMouseButton?(_ev: BeButtonEvent): boolean;
    onMouseEnter(ev: BeButtonEvent): void;
    onMouseLeave(): void;
    onMouseMove(ev: BeButtonEvent): void;
    pick(pt: XAndY): boolean;
    position: Point3d;
    protected positionHtml(): void;
    readonly rect: ViewRect;
    // (undocumented)
    protected _scaleFactor?: Point2d;
    // (undocumented)
    protected _scaleFactorRange?: Range1d;
    setImage(image: MarkerImage | Promise<MarkerImage>): void;
    setImageUrl(url: string): void;
    setPosition(vp: Viewport, markerSet?: MarkerSet<Marker>): boolean;
    setScaleFactor(range: Range1dProps): void;
    size: Point2d;
    title?: HTMLElement | string;
    tooltipOptions?: ToolTipOptions;
    visible: boolean;
    get wantImage(): boolean;
    worldLocation: Point3d;
}

// @public (undocumented)
export type MarkerFillStyle = string | CanvasGradient | CanvasPattern;

// @public
export type MarkerImage = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;

// @public
export abstract class MarkerSet<T extends Marker> {
    constructor(viewport?: ScreenViewport);
    addDecoration(context: DecorateContext): void;
    // @beta
    changeViewport(viewport: ScreenViewport): void;
    // @internal (undocumented)
    protected _entries: Array<T | Cluster<T>>;
    protected abstract getClusterMarker(cluster: Cluster<T>): Marker;
    getMinScaleViewW(vp: Viewport): number;
    markDirty(): void;
    get markers(): Set<T>;
    minimumClusterSize: number;
    // @internal (undocumented)
    protected _minScaleViewW?: number;
    get viewport(): ScreenViewport | undefined;
    // @internal (undocumented)
    protected readonly _worldToViewMap: Matrix4d;
}

// @public (undocumented)
export type MarkerTextAlign = "left" | "right" | "center" | "start" | "end";

// @public (undocumented)
export type MarkerTextBaseline = "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";

// @alpha (undocumented)
export class MeasureAreaByPointsTool extends PrimitiveTool {
    // (undocumented)
    protected _acceptedMeasurement?: MeasureMarker;
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): boolean;
    // (undocumented)
    protected _area: number;
    // (undocumented)
    protected _centroid: Point3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected static enumAsOrientationMessage(str: string): string;
    // (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    protected getMarkerToolTip(): Promise<HTMLElement>;
    // (undocumented)
    protected getShapePoints(cursorPt: Point3d): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    protected _isComplete: boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _lastMotionPt?: Point3d;
    // (undocumented)
    protected _marker?: MeasureLabel;
    // (undocumented)
    protected _matrix?: Matrix3d;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected static _orientationName: string;
    // (undocumented)
    protected _perimeter: number;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @alpha (undocumented)
export class MeasureAreaTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureDistanceTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedSegments: {
        distance: number;
        slope: number;
        start: Point3d;
        end: Point3d;
        delta: Vector3d;
        refAxes: Matrix3d;
        marker: MeasureMarker;
    }[];
    // (undocumented)
    protected acceptNewSegments(): Promise<void>;
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    protected createDecorations(context: DecorateContext, isSuspended: boolean): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected displayDelta(context: DecorateContext, seg: any): void;
    // (undocumented)
    protected displayDynamicDistance(context: DecorateContext, points: Point3d[]): void;
    // (undocumented)
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    protected getMarkerToolTip(distance: number, slope: number, start: Point3d, end: Point3d, delta?: Vector3d): Promise<HTMLElement>;
    // (undocumented)
    protected getReferenceAxes(vp?: Viewport): Matrix3d;
    // (undocumented)
    protected getSnapPoints(): Point3d[] | undefined;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _lastMotionPt?: Point3d;
    // (undocumented)
    protected readonly _locationData: {
        point: Point3d;
        refAxes: Matrix3d;
    }[];
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _snapGeomId?: string;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _totalDistance: number;
    // (undocumented)
    protected _totalDistanceMarker?: MeasureLabel;
    // (undocumented)
    protected updateSelectedMarkerToolTip(seg: any, ev: BeButtonEvent, reopenToolTip: boolean): Promise<void>;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @alpha (undocumented)
export abstract class MeasureElementTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedIds: Id64Array;
    // (undocumented)
    protected readonly _acceptedMeasurements: MeasureMarker[];
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    protected readonly _checkedIds: Map<string, MassPropertiesResponseProps>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    doMeasureSelectedElements(viewport: Viewport): Promise<void>;
    // (undocumented)
    filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    protected getMarkerToolTip(responseProps: MassPropertiesResponseProps): Promise<HTMLElement>;
    // (undocumented)
    protected abstract getOperation(): MassPropertiesOperation;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _totalMarker?: MeasureLabel;
    // (undocumented)
    protected _totalValue: number;
    // (undocumented)
    protected updateTotals(selectionSetResult?: MassPropertiesResponseProps): Promise<void>;
    // (undocumented)
    protected _useSelection: boolean;
}

// @alpha (undocumented)
export class MeasureLengthTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureLocationTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedLocations: MeasureMarker[];
    // (undocumented)
    protected allowView(vp: Viewport): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getMarkerToolTip(point: Point3d): Promise<HTMLElement>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export class MeasureVolumeTool extends MeasureElementTool {
    // (undocumented)
    protected getOperation(): MassPropertiesOperation;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export enum MessageBoxIconType {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Information = 1,
    // (undocumented)
    NoSymbol = 0,
    // (undocumented)
    Question = 2,
    // (undocumented)
    Warning = 3
}

// @public
export enum MessageBoxType {
    // (undocumented)
    LargeOk = 2,
    // (undocumented)
    MediumAlert = 3,
    // (undocumented)
    Ok = 1,
    // (undocumented)
    OkCancel = 0,
    // (undocumented)
    YesNo = 5,
    // (undocumented)
    YesNoCancel = 4
}

// @public
export enum MessageBoxValue {
    // (undocumented)
    Apply = 1,
    // (undocumented)
    Cancel = 4,
    // (undocumented)
    Default = 5,
    // (undocumented)
    Help = 10,
    // (undocumented)
    No = 7,
    // (undocumented)
    NoToAll = 12,
    // (undocumented)
    Ok = 3,
    // (undocumented)
    Reset = 2,
    // (undocumented)
    Retry = 8,
    // (undocumented)
    Stop = 9,
    // (undocumented)
    Yes = 6,
    // (undocumented)
    YesToAll = 11
}

// @internal
export function metersToRange(inputMeters: number, minimumOutput?: number, maximumOutput?: number, maximumInputMeters?: number): number;

// @internal
export namespace MockRender {
    export class App {
        // (undocumented)
        protected static createDefaultRenderSystem(): System;
        // (undocumented)
        static shutdown(): Promise<void>;
        // (undocumented)
        static startup(opts?: IModelAppOptions): Promise<void>;
        // (undocumented)
        static systemFactory: SystemFactory;
    }
    // (undocumented)
    export class Batch extends Graphic {
        constructor(graphic: RenderGraphic, featureTable: PackedFeatureTable, range: ElementAlignedBox3d);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        // (undocumented)
        readonly graphic: RenderGraphic;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
    }
    // (undocumented)
    export class Branch extends Graphic {
        constructor(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions | undefined);
        // (undocumented)
        readonly branch: GraphicBranch;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly options?: GraphicBranchOptions | undefined;
        // (undocumented)
        readonly transform: Transform;
    }
    // (undocumented)
    export class Builder extends PrimitiveBuilder {
        constructor(system: System, placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    }
    // (undocumented)
    export class Graphic extends RenderGraphic {
        constructor();
        // (undocumented)
        collectStatistics(_stats: RenderMemory.Statistics): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class List extends Graphic {
        constructor(graphics: RenderGraphic[]);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly graphics: RenderGraphic[];
    }
    // (undocumented)
    export class OffScreenTarget extends Target {
        constructor(system: RenderSystem, _viewRect: ViewRect);
        // (undocumented)
        setViewRect(rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
        }
    // (undocumented)
    export class OnScreenTarget extends Target {
        constructor(system: RenderSystem, _canvas: HTMLCanvasElement);
        // (undocumented)
        setViewRect(_rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        get viewRect(): ViewRect;
    }
    // (undocumented)
    export class System extends RenderSystem {
        constructor();
        // (undocumented)
        createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): Batch;
        // (undocumented)
        createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): Branch;
        // (undocumented)
        createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): Builder;
        // (undocumented)
        createGraphicList(primitives: RenderGraphic[]): List;
        // (undocumented)
        createMesh(_params: MeshParams): Graphic;
        // (undocumented)
        createOffscreenTarget(rect: ViewRect): RenderTarget;
        // (undocumented)
        createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): Graphic;
        // (undocumented)
        createPointString(_params: PointStringParams): Graphic;
        // (undocumented)
        createPolyline(_params: PolylineParams): Graphic;
        // (undocumented)
        createTarget(canvas: HTMLCanvasElement): OnScreenTarget;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        doIdleWork(): boolean;
        // (undocumented)
        get isValid(): boolean;
        // (undocumented)
        get maxTextureSize(): number;
    }
    // (undocumented)
    export type SystemFactory = () => RenderSystem;
    // (undocumented)
    export abstract class Target extends RenderTarget {
        protected constructor(_system: RenderSystem);
        // (undocumented)
        get analysisFraction(): number;
        set analysisFraction(_fraction: number);
        // (undocumented)
        changeDecorations(_decs: Decorations): void;
        // (undocumented)
        changeDynamics(_dynamics?: GraphicList): void;
        // (undocumented)
        changeRenderPlan(_plan: RenderPlan): void;
        // (undocumented)
        changeScene(_scene: Scene): void;
        // (undocumented)
        drawFrame(_sceneTime?: number): void;
        // (undocumented)
        readPixels(_rect: ViewRect, _selector: Pixel.Selector, receiver: Pixel.Receiver, _excludeNonLocatable: boolean): void;
        // (undocumented)
        get renderSystem(): RenderSystem;
        // (undocumented)
        get screenSpaceEffects(): Iterable<string>;
        set screenSpaceEffects(_effects: Iterable<string>);
        // (undocumented)
        updateViewRect(): boolean;
        // (undocumented)
        get wantInvertBlackBackground(): boolean;
    }
}

// @internal
export interface ModalOptions {
    autoClose?: boolean;
    closeBox?: boolean;
    rootDiv?: HTMLElement;
    width?: number;
}

// @internal
export interface ModalReturn {
    modal: HTMLDivElement;
    stop: (_ev: Event) => void;
}

// @alpha
export interface ModelDisplayTransformProvider {
    // (undocumented)
    getModelDisplayTransform(modelId: Id64String, baseTransform: Transform): Transform;
}

// @public
export class ModelSelectorState extends ElementState {
    constructor(props: ModelSelectorProps, iModel: IModelConnection);
    addModels(arg: Id64Arg): void;
    // @internal (undocumented)
    static get className(): string;
    containsModel(modelId: Id64String): boolean;
    dropModels(arg: Id64Arg): void;
    equalState(other: ModelSelectorState): boolean;
    has(id: string): boolean;
    load(): Promise<void>;
    get models(): Set<string>;
    set models(models: Set<string>);
    get name(): string;
    // @internal (undocumented)
    get observableModels(): ObservableSet<string>;
    // (undocumented)
    toJSON(): ModelSelectorProps;
}

// @public
export class ModelState extends EntityState implements ModelProps {
    constructor(props: ModelProps, iModel: IModelConnection, state?: ModelState);
    get asGeometricModel(): GeometricModelState | undefined;
    get asGeometricModel2d(): GeometricModel2dState | undefined;
    get asGeometricModel3d(): GeometricModel3dState | undefined;
    get asSpatialModel(): SpatialModelState | undefined;
    // @internal (undocumented)
    static get className(): string;
    // @internal
    getToolTip(_hit: HitDetail): HTMLElement | string | undefined;
    get isGeometricModel(): boolean;
    // (undocumented)
    readonly isPrivate: boolean;
    // (undocumented)
    readonly isTemplate: boolean;
    // (undocumented)
    readonly modeledElement: RelatedElement;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    parentModel: Id64String;
    toJSON(): ModelProps;
}

// @alpha (undocumented)
export enum ModifyElementSource {
    DragSelect = 3,
    Selected = 1,
    SelectionSet = 2,
    Unknown = 0
}

// @alpha
export class NativeApp {
    // (undocumented)
    static callNativeHost<T extends AsyncMethodsOf<NativeAppFunctions>>(methodName: T, ...args: Parameters<NativeAppFunctions[T]>): Promise<PromiseReturnType<NativeAppFunctions[T]>>;
    // (undocumented)
    static checkInternetConnectivity(): Promise<InternetConnectivityStatus>;
    static closeStorage(storage: Storage, deleteId: boolean): Promise<void>;
    static deleteBriefcase(fileName: string): Promise<void>;
    // (undocumented)
    static getBriefcaseFileName(props: BriefcaseProps): Promise<string>;
    static getCachedBriefcases(iModelId?: GuidString): Promise<LocalBriefcaseProps[]>;
    static getStorageNames(): Promise<string[]>;
    // (undocumented)
    static get isValid(): boolean;
    // (undocumented)
    static onInternetConnectivityChanged: BeEvent<(status: InternetConnectivityStatus) => void>;
    // (undocumented)
    static onUserStateChanged: BeEvent<(_arg: {
        accessToken: any;
        err?: string;
    }) => void>;
    static openStorage(name: string): Promise<Storage>;
    // (undocumented)
    static overrideInternetConnectivity(status: InternetConnectivityStatus): Promise<void>;
    // (undocumented)
    static requestDownloadBriefcase(contextId: string, iModelId: string, downloadOptions: DownloadBriefcaseOptions, asOf?: IModelVersion, progress?: ProgressCallback): Promise<BriefcaseDownloader>;
    // (undocumented)
    static shutdown(): Promise<void>;
    // @internal
    static startup(opts: {
        ipcApp?: IpcAppOptions;
        iModelApp?: IModelAppOptions;
    }): Promise<void>;
    }

// @internal
export class NativeAppLogger {
    // (undocumented)
    static flush(): Promise<void>;
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static logError(category: string, message: string, getMetaData?: GetMetaDataFunction): void;
    // (undocumented)
    static logInfo(category: string, message: string, getMetaData?: GetMetaDataFunction): void;
    // (undocumented)
    static logTrace(category: string, message: string, getMetaData?: GetMetaDataFunction): void;
    // (undocumented)
    static logWarning(category: string, message: string, getMetaData?: GetMetaDataFunction): void;
    }

// @internal
export class NoRenderApp {
    // (undocumented)
    static startup(opts?: IModelAppOptions): Promise<void>;
}

// @beta
export abstract class NotificationHandler {
    abstract get channelName(): string;
    static register(): RemoveFunction;
    // (undocumented)
    registerImpl(): RemoveFunction;
}

// @public
export class NotificationManager {
    clearToolTip(): void;
    closeInputFieldMessage(): void;
    closePointerMessage(): void;
    endActivityMessage(_reason: ActivityMessageEndReason): boolean;
    get isToolTipOpen(): boolean;
    get isToolTipSupported(): boolean;
    openMessageBox(_mbType: MessageBoxType, _message: HTMLElement | string, _icon: MessageBoxIconType): Promise<MessageBoxValue>;
    openToolTip(htmlElement: HTMLElement, message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    outputActivityMessage(_messageText: HTMLElement | string, _percentComplete: number): boolean;
    outputMessage(_message: NotifyMessageDetails): void;
    outputPrompt(_prompt: string): void;
    outputPromptByKey(key: string): void;
    setToolAssistance(instructions: ToolAssistanceInstructions | undefined): void;
    setupActivityMessage(_details: ActivityMessageDetails): boolean;
    protected _showToolTip(_htmlElement: HTMLElement, _message: HTMLElement | string, _location?: XAndY, _options?: ToolTipOptions): void;
    // (undocumented)
    readonly toolTipLocation: Point2d;
    updatePointerMessage(_displayPoint: XAndY, _relativePosition?: RelativePosition): void;
}

// @public
export class NotifyMessageDetails {
    constructor(priority: OutputMessagePriority, briefMessage: HTMLElement | string, detailedMessage?: string | HTMLElement | undefined, msgType?: OutputMessageType, openAlert?: OutputMessageAlert);
    // (undocumented)
    briefMessage: HTMLElement | string;
    // (undocumented)
    detailedMessage?: string | HTMLElement | undefined;
    // (undocumented)
    displayPoint?: Point2d;
    // (undocumented)
    displayTime: BeDuration;
    // (undocumented)
    inputField?: HTMLElement;
    // (undocumented)
    msgType: OutputMessageType;
    // (undocumented)
    openAlert: OutputMessageAlert;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    relativePosition: RelativePosition;
    setInputFieldTypeDetails(inputField: HTMLElement): void;
    setPointerTypeDetails(viewport: HTMLElement, displayPoint: XAndY, relativePosition?: RelativePosition): void;
    // (undocumented)
    viewport?: HTMLElement;
}

// @internal
export class NullRenderSystem extends RenderSystem {
    constructor();
    // (undocumented)
    createBatch(): any;
    // (undocumented)
    createGraphicBranch(): any;
    // (undocumented)
    createGraphicBuilder(): any;
    // (undocumented)
    createGraphicList(): any;
    // (undocumented)
    createOffscreenTarget(): NullTarget;
    // (undocumented)
    createTarget(): NullTarget;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    doIdleWork(): boolean;
    // (undocumented)
    get isValid(): boolean;
}

// @internal
export class NullTarget extends RenderTarget {
    // (undocumented)
    get analysisFraction(): number;
    set analysisFraction(_fraction: number);
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_branches: AnimationBranchStates | undefined);
    // (undocumented)
    changeDecorations(): void;
    // (undocumented)
    changeDynamics(): void;
    // (undocumented)
    changeRenderPlan(): void;
    // (undocumented)
    changeScene(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawFrame(_sceneMilSecElapsed?: number): void;
    // (undocumented)
    onDestroy(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(): void;
    // (undocumented)
    readImage(): undefined;
    // (undocumented)
    readPixels(): void;
    // (undocumented)
    get renderSystem(): any;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(_effects: Iterable<string>);
    // (undocumented)
    setFlashed(): void;
    // (undocumented)
    setHiliteSet(): void;
    // (undocumented)
    setViewRect(): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
}

// @internal (undocumented)
export class OffScreenTarget extends Target {
    constructor(rect: ViewRect);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(fbo: FrameBuffer): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setViewRect(rect: ViewRect, temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
}

// @internal
export class OffScreenViewport extends Viewport {
    // (undocumented)
    static create(view: ViewState, viewRect?: ViewRect, lockAspectRatio?: boolean, target?: RenderTarget): OffScreenViewport;
    // (undocumented)
    get isAspectRatioLocked(): boolean;
    // (undocumented)
    protected _isAspectRatioLocked: boolean;
    // (undocumented)
    setRect(rect: ViewRect, temporary?: boolean): void;
    // (undocumented)
    get viewRect(): ViewRect;
}

// @beta @deprecated
export class OidcBrowserClient extends ImsAuthorizationClient implements FrontendAuthorizationClient {
    constructor(_configuration: OidcFrontendClientConfiguration);
    // (undocumented)
    protected _accessToken?: AccessToken;
    dispose(): void;
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    // @internal
    protected getUserManagerSettings(requestContext: FrontendRequestContext): Promise<UserManagerSettings>;
    get hasExpired(): boolean;
    get hasSignedIn(): boolean;
    initialize(requestContext: FrontendRequestContext): Promise<void>;
    get isAuthorized(): boolean;
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext, successRedirectUrl?: string): Promise<void>;
    protected signInSilent(requestContext: ClientRequestContext): Promise<User>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
    }

// @internal
export class OnScreenTarget extends Target {
    constructor(canvas: HTMLCanvasElement);
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(fbo: FrameBuffer): void;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    get devicePixelRatioOverride(): number | undefined;
    set devicePixelRatioOverride(ovr: number | undefined);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    pickOverlayDecoration(pt: XAndY): CanvasDecoration | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    setRenderToScreen(toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    setViewRect(_rect: ViewRect, _temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
    }

// @beta
export function openImageDataUrlInNewWindow(url: string, title?: string): void;

// @internal (undocumented)
export class OrbitGtTileTree extends TileTree {
    constructor(treeParams: TileTreeParams, _dataManager: OrbitGtDataManager, cloudRange: Range3d, _centerOffset: Vector3d);
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(args: TileDrawArgs): void;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    get maxDepth(): number | undefined;
    // (undocumented)
    prune(): void;
    // (undocumented)
    rootTile: OrbitGtRootTile;
    // (undocumented)
    protected _selectTiles(_args: TileDrawArgs): Tile[];
    // (undocumented)
    viewFlagOverrides: ViewFlagOverrides;
}

// @internal (undocumented)
export namespace OrbitGtTileTree {
    // (undocumented)
    export function createOrbitGtTileTree(props: OrbitGtBlobProps, iModel: IModelConnection, modelId: Id64String): Promise<TileTree | undefined>;
    // (undocumented)
    export interface ReferenceProps {
        // (undocumented)
        classifiers?: SpatialClassifiers;
        // (undocumented)
        displayStyle: DisplayStyleState;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        modelId?: Id64String;
        // (undocumented)
        name?: string;
        // (undocumented)
        orbitGtBlob: OrbitGtBlobProps;
        // (undocumented)
        tilesetToDbTransform?: TransformProps;
    }
}

// @public
export class OrthographicViewState extends SpatialViewState {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    supportsCamera(): boolean;
}

// @beta
export interface OsmBuildingDisplayOptions {
    appearanceOverrides?: FeatureAppearance;
    onOff?: boolean;
}

// @public
export enum OutputMessageAlert {
    // (undocumented)
    Balloon = 2,
    // (undocumented)
    Dialog = 1,
    // (undocumented)
    None = 0
}

// @public
export enum OutputMessagePriority {
    // (undocumented)
    Debug = 13,
    // (undocumented)
    Error = 10,
    // (undocumented)
    Fatal = 17,
    // (undocumented)
    Info = 12,
    // (undocumented)
    None = 0,
    // (undocumented)
    Warning = 11
}

// @public
export enum OutputMessageType {
    Alert = 4,
    // (undocumented)
    InputField = 3,
    // (undocumented)
    Pointer = 1,
    // (undocumented)
    Sticky = 2,
    Toast = 0
}

// @alpha
export interface OverrideFormatEntry {
    // (undocumented)
    imperial?: FormatProps;
    // (undocumented)
    metric?: FormatProps;
    // (undocumented)
    usCustomary?: FormatProps;
    // (undocumented)
    usSurvey?: FormatProps;
}

// @internal
export function overrideRequestTileTreeProps(func: RequestTileTreePropsFunc | undefined): void;

// @public
export class PanViewTool extends ViewManip {
    constructor(vp: ScreenViewport | undefined, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export enum ParseAndRunResult {
    BadArgumentCount = 2,
    FailedToRun = 3,
    MismatchedQuotes = 4,
    Success = 0,
    ToolNotFound = 1
}

// @beta
export interface ParsedKeyin {
    args: string[];
    ok: true;
    tool: ToolType;
}

// @beta
export interface ParseKeyinError {
    error: KeyinParseError;
    ok: false;
}

// @beta
export type ParseKeyinResult = ParsedKeyin | ParseKeyinError;

// @beta
export interface ParticleCollectionBuilder {
    addParticle: (particle: ParticleProps) => void;
    finish: () => RenderGraphic | undefined;
    size: XAndY;
    transparency: number;
}

// @beta (undocumented)
export namespace ParticleCollectionBuilder {
    export function create(params: ParticleCollectionBuilderParams): ParticleCollectionBuilder;
}

// @beta
export interface ParticleCollectionBuilderParams {
    isViewCoords?: boolean;
    origin?: XYAndZ;
    pickableId?: Id64String;
    size: XAndY | number;
    texture: RenderTexture;
    transparency?: number;
    viewport: Viewport;
}

// @beta
export interface ParticleProps extends XYAndZ {
    size?: XAndY | number;
    transparency?: number;
}

// @beta
export class PendingExtension {
    constructor(_tarFileUrl: string, loader: ExtensionLoader, args?: string[] | undefined);
    // (undocumented)
    args?: string[] | undefined;
    // (undocumented)
    executor(resolve: ResolveFunc, reject: RejectFunc): void;
    // (undocumented)
    loader: ExtensionLoader;
    // (undocumented)
    promise: Promise<Extension>;
    // (undocumented)
    reject: RejectFunc | undefined;
    // (undocumented)
    resolve: ResolveFunc | undefined;
    }

// @internal (undocumented)
export class PerformanceMetrics {
    constructor(gatherGlFinish?: boolean, gatherCurPerformanceMetrics?: boolean, gpuResults?: GLTimerResultCallback);
    // (undocumented)
    beginFrame(sceneTime?: number): void;
    // (undocumented)
    beginOperation(operationName: string): void;
    // (undocumented)
    completeFrameTimings(fbo: FrameBuffer): void;
    // (undocumented)
    curSpfTimeIndex: number;
    // (undocumented)
    endFrame(): void;
    // (undocumented)
    endOperation(): void;
    // (undocumented)
    fpsTimer: StopWatch;
    // (undocumented)
    fpsTimerStart: number;
    // (undocumented)
    frameTimings: Map<string, number>;
    // (undocumented)
    gatherCurPerformanceMetrics: boolean;
    // (undocumented)
    gatherGlFinish: boolean;
    // (undocumented)
    spfSum: number;
    // (undocumented)
    spfTimes: number[];
    }

// @beta
export namespace PerModelCategoryVisibility {
    // (undocumented)
    export function createOverrides(viewport: Viewport): PerModelCategoryVisibility.Overrides;
    export enum Override {
        Hide = 2,
        None = 0,
        Show = 1
    }
    export interface Overrides {
        addOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
        clearOverrides(modelIds?: Id64Arg): void;
        forEachOverride(func: (modelId: Id64String, categoryId: Id64String, visible: boolean) => boolean): boolean;
        getOverride(modelId: Id64String, categoryId: Id64String): Override;
        setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: Override): void;
    }
}

// @public
export class PhysicalModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @internal
export interface PingTestResult {
    avg: number | undefined;
    max: number | undefined;
    min: number | undefined;
}

// @beta
export namespace Pixel {
    export interface Buffer {
        getPixel(x: number, y: number): Data;
    }
    export class Data {
        // @internal
        constructor(feature?: Feature, distanceFraction?: number, type?: GeometryType, planarity?: Planarity, featureTable?: PackedFeatureTable, iModel?: IModelConnection, tileId?: string);
        // (undocumented)
        readonly distanceFraction: number;
        // (undocumented)
        get elementId(): Id64String | undefined;
        // (undocumented)
        readonly feature?: Feature;
        // @internal (undocumented)
        readonly featureTable?: PackedFeatureTable;
        // (undocumented)
        get geometryClass(): GeometryClass | undefined;
        // @internal (undocumented)
        readonly iModel?: IModelConnection;
        // @internal (undocumented)
        get isClassifier(): boolean;
        // (undocumented)
        readonly planarity: Planarity;
        // (undocumented)
        get subCategoryId(): Id64String | undefined;
        // @internal (undocumented)
        readonly tileId?: string;
        // (undocumented)
        readonly type: GeometryType;
    }
    export enum GeometryType {
        Edge = 4,
        Linear = 3,
        None = 1,
        Silhouette = 5,
        Surface = 2,
        Unknown = 0
    }
    export enum Planarity {
        None = 1,
        NonPlanar = 3,
        Planar = 2,
        Unknown = 0
    }
    export type Receiver = (pixels: Buffer | undefined) => void;
    export enum Selector {
        All = 5,
        Feature = 1,
        GeometryAndDistance = 4,
        // (undocumented)
        None = 0
    }
}

// @internal (undocumented)
export type PlanarClassifierMap = Map<Id64String, RenderPlanarClassifier>;

// @internal (undocumented)
export interface PlanarClassifierTarget {
    // (undocumented)
    isPointCloud: boolean;
    // (undocumented)
    location: Transform;
    // (undocumented)
    modelId: Id64String;
    // (undocumented)
    tiles: Tile[];
}

// @beta
export class PlanarClipMaskState {
    // (undocumented)
    static create(settings: PlanarClipMaskSettings): PlanarClipMaskState;
    // (undocumented)
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    static fromJSON(props: PlanarClipMaskProps): PlanarClipMaskState;
    // (undocumented)
    getPlanarClipMaskSymbologyOverrides(): FeatureSymbology.Overrides | undefined;
    // (undocumented)
    getTileTrees(view: ViewState3d, classifiedModelId: Id64String): TileTreeReference[] | undefined;
    // (undocumented)
    readonly settings: PlanarClipMaskSettings;
    }

// @internal (undocumented)
export class PlanarTilePatch {
    constructor(corners: Point3d[], normal: Vector3d, _chordHeight: number);
    // (undocumented)
    corners: Point3d[];
    // (undocumented)
    getClipShape(): Point3d[];
    // (undocumented)
    getRangeCorners(heightRange: Range1d, result: Point3d[]): Point3d[];
    // (undocumented)
    normal: Vector3d;
}

// @public
export abstract class PrimitiveTool extends InteractiveTool {
    autoLockTarget(): void;
    // (undocumented)
    exitTool(): void;
    getPrompt(): string;
    // @internal
    get iModel(): EditableConnection;
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    onRedoPreviousStep(): Promise<boolean>;
    onReinitialize(): void;
    abstract onRestartTool(): void;
    onSelectedViewportChanged(_previous: Viewport | undefined, current: Viewport | undefined): void;
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    redoPreviousStep(): Promise<boolean>;
    requireWriteableTarget(): boolean;
    run(..._args: any[]): boolean;
    saveChanges(): Promise<void>;
    // (undocumented)
    targetIsLocked: boolean;
    // (undocumented)
    get targetModelId(): string | undefined;
    set targetModelId(v: string | undefined);
    // (undocumented)
    targetView?: Viewport;
    // @internal (undocumented)
    undoPreviousStep(): Promise<boolean>;
}

// @alpha
export enum PrimitiveVisibility {
    All = 0,
    Instanced = 1,
    Uninstanced = 2
}

// @beta
export type PromiseReturnType<T extends AsyncFunction> = T extends (...args: any) => Promise<infer R> ? R : any;

// @internal (undocumented)
export class QuadId {
    constructor(level: number, column: number, row: number);
    // (undocumented)
    bordersNorthPole(mapTilingScheme: MapTilingScheme): boolean;
    // (undocumented)
    bordersSouthPole(mapTilingScheme: MapTilingScheme): boolean;
    // (undocumented)
    column: number;
    // (undocumented)
    compare(other: QuadId): number;
    // (undocumented)
    get contentId(): string;
    // (undocumented)
    static createFromContentId(stringId: string): QuadId;
    // (undocumented)
    get debugString(): string;
    // (undocumented)
    getAngleSweep(mapTilingScheme: MapTilingScheme): {
        longitude: AngleSweep;
        latitude: AngleSweep;
    };
    // (undocumented)
    getChildIds(columnCount?: number, rowCount?: number): QuadId[];
    // (undocumented)
    getLatLongRange(mapTilingScheme: MapTilingScheme): Range2d;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    level: number;
    // (undocumented)
    row: number;
}

// @alpha
export interface QuantityFormatsChangedArgs {
    // (undocumented)
    readonly quantityType: string;
}

// @alpha
export class QuantityFormatter implements UnitsProvider {
    constructor(showMetricOrUnitSystem?: boolean | UnitSystemKey);
    // (undocumented)
    protected _activeFormatSpecsByType: Map<string, FormatterSpec>;
    // (undocumented)
    protected _activeParserSpecsByType: Map<string, ParserSpec>;
    get activeUnitSystem(): UnitSystemKey;
    // (undocumented)
    protected _activeUnitSystem: UnitSystemKey;
    // (undocumented)
    clearAllOverrideFormats(): Promise<void>;
    // (undocumented)
    clearOverrideFormats(type: QuantityTypeArg): Promise<void>;
    findFormatterSpecByQuantityType(type: QuantityTypeArg, _unused?: boolean): FormatterSpec | undefined;
    findParserSpecByQuantityType(type: QuantityTypeArg): ParserSpec | undefined;
    // (undocumented)
    findUnit(unitLabel: string, unitFamily?: string, unitSystem?: string): Promise<UnitProps>;
    // (undocumented)
    findUnitByName(unitName: string): Promise<UnitProps>;
    formatQuantity(magnitude: number, formatSpec: FormatterSpec | undefined): string;
    // (undocumented)
    generateFormatterSpecByType(type: QuantityTypeArg, formatProps: FormatProps): Promise<FormatterSpec>;
    // (undocumented)
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion>;
    // (undocumented)
    getFormatPropsByQuantityType(quantityType: QuantityTypeArg, requestedSystem?: UnitSystemKey, ignoreOverrides?: boolean): FormatProps | undefined;
    getFormatterSpecByQuantityType(type: QuantityTypeArg, isImperial?: boolean): Promise<FormatterSpec | undefined>;
    getFormatterSpecByQuantityTypeAndSystem(type: QuantityTypeArg, system?: UnitSystemKey): Promise<FormatterSpec | undefined>;
    getParserSpecByQuantityType(type: QuantityTypeArg, isImperial?: boolean): Promise<ParserSpec | undefined>;
    // (undocumented)
    getParserSpecByQuantityTypeAndSystem(type: QuantityTypeArg, system?: UnitSystemKey): Promise<ParserSpec | undefined>;
    // (undocumented)
    getQuantityDefiniton(type: QuantityTypeArg): QuantityTypeDefinition | undefined;
    getQuantityTypeKey(type: QuantityTypeArg): string;
    // (undocumented)
    getUnitsByFamily(unitFamily: string): Promise<UnitProps[]>;
    getUnitSystemFromString(inputSystem: string, fallback?: UnitSystemKey): UnitSystemKey;
    // (undocumented)
    hasActiveOverride(type: QuantityTypeArg, checkOnlyActiveUnitSystem?: boolean): boolean;
    // (undocumented)
    protected initializeQuantityTypesRegistry(): Promise<void>;
    // @internal
    protected loadFormatAndParsingMapsForSystem(systemType?: UnitSystemKey): Promise<void>;
    readonly onActiveFormattingUnitSystemChanged: BeUiEvent<FormattingUnitSystemChangedArgs>;
    // @deprecated
    readonly onActiveUnitSystemChanged: BeUiEvent<{
        useImperial: boolean;
    }>;
    // @internal
    onInitialized(): Promise<void>;
    readonly onQuantityFormatsChanged: BeUiEvent<QuantityFormatsChangedArgs>;
    readonly onUnitsProviderChanged: BeUiEvent<void>;
    // (undocumented)
    protected _overrideFormatPropsByUnitSystem: Map<UnitSystemKey, Map<string, FormatProps>>;
    parseToQuantityValue(inString: string, parserSpec: ParserSpec | undefined): QuantityParseResult;
    // (undocumented)
    protected _quantityTypeRegistry: Map<QuantityTypeKey, QuantityTypeDefinition>;
    // (undocumented)
    get quantityTypesRegistry(): Map<string, QuantityTypeDefinition>;
    // (undocumented)
    registerQuantityType(entry: CustomQuantityTypeDefinition, replace?: boolean): Promise<boolean>;
    setActiveUnitSystem(isImperialOrUnitSystem: UnitSystemKey | boolean, restartActiveTool?: boolean): Promise<void>;
    // (undocumented)
    setOverrideFormat(type: QuantityTypeArg, overrideFormat: FormatProps): Promise<void>;
    // (undocumented)
    setOverrideFormats(type: QuantityTypeArg, overrideEntry: OverrideFormatEntry): Promise<void>;
    // (undocumented)
    get unitsProvider(): UnitsProvider;
    set unitsProvider(unitsProvider: UnitsProvider);
    // @deprecated (undocumented)
    get useImperialFormats(): boolean;
    set useImperialFormats(useImperial: boolean);
}

// @beta
export enum QuantityType {
    // (undocumented)
    Angle = 2,
    // (undocumented)
    Area = 3,
    // (undocumented)
    Coordinate = 6,
    // (undocumented)
    LatLong = 5,
    // (undocumented)
    Length = 1,
    // (undocumented)
    LengthEngineering = 9,
    // (undocumented)
    LengthSurvey = 8,
    // (undocumented)
    Stationing = 7,
    // (undocumented)
    Volume = 4
}

// @beta
export type QuantityTypeArg = QuantityType | string;

// @alpha
export interface QuantityTypeDefinition {
    description: string;
    generateFormatterSpec: (formatProps: FormatProps, unitsProvider: UnitsProvider) => Promise<FormatterSpec>;
    generateParserSpec: (formatProps: FormatProps, unitsProvider: UnitsProvider) => Promise<ParserSpec>;
    // (undocumented)
    getDefaultFormatPropsBySystem: (requestedSystem: UnitSystemKey) => FormatProps;
    readonly key: QuantityTypeKey;
    label: string;
    readonly persistenceUnit: UnitProps;
    readonly type: QuantityTypeArg;
}

// @beta
export type QuantityTypeKey = string;

// @internal
export function queryTerrainElevationOffset(viewport: ScreenViewport, carto: Cartographic): Promise<number>;

// @internal
export function rangeToCartographicArea(view3d: ViewState3d, range: Range3d): GlobalLocationArea | undefined;

// @internal
export function readPointCloudTileContent(stream: ByteStream, iModel: IModelConnection, modelId: Id64String, _is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem): RenderGraphic | undefined;

// @internal (undocumented)
export type RealityModelSource = ViewState | DisplayStyleState;

// @internal
export class RealityModelTileClient {
    constructor(url: string, accessToken?: AccessToken, contextId?: string);
    // (undocumented)
    getRootDocument(url: string): Promise<any>;
    getTileContent(url: string): Promise<any>;
    getTileJson(url: string): Promise<any>;
    // (undocumented)
    readonly rdsProps?: RDSClientProps;
    }

// @internal (undocumented)
export class RealityModelTileTree extends RealityTileTree {
    constructor(params: RealityTileTreeParams);
    // (undocumented)
    get isContentUnbounded(): boolean;
    }

// @internal (undocumented)
export namespace RealityModelTileTree {
    // (undocumented)
    export function createRealityModelTileTree(url: string, iModel: IModelConnection, modelId: Id64String, tilesetToDb?: Transform): Promise<TileTree | undefined>;
    // (undocumented)
    export abstract class Reference extends TileTreeReference {
        constructor(modelId: Id64String | undefined, iModel: IModelConnection);
        // (undocumented)
        abstract get classifiers(): SpatialClassifiers | undefined;
        // (undocumented)
        get isGlobal(): boolean;
        // (undocumented)
        get modelId(): string;
        // (undocumented)
        get planarClipMask(): PlanarClipMaskState | undefined;
        set planarClipMask(planarClipMask: PlanarClipMaskState | undefined);
        // (undocumented)
        protected _planarClipMask?: PlanarClipMaskState;
        // (undocumented)
        get planarClipMaskPriority(): number;
        // (undocumented)
        unionFitRange(union: Range3d): void;
    }
    // (undocumented)
    export interface ReferenceProps {
        // (undocumented)
        classifiers?: SpatialClassifiers;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        modelId?: Id64String;
        // (undocumented)
        name?: string;
        // (undocumented)
        planarMask?: PlanarClipMaskProps;
        // (undocumented)
        requestAuthorization?: string;
        // (undocumented)
        source: RealityModelSource;
        // (undocumented)
        tilesetToDbTransform?: TransformProps;
        // (undocumented)
        url: string;
    }
}

// @internal (undocumented)
export class RealityModelTileUtils {
    // (undocumented)
    static maximumSizeFromGeometricTolerance(range: Range3d, geometricError: number): number;
    // (undocumented)
    static rangeFromBoundingVolume(boundingVolume: any): {
        range: Range3d;
        corners?: Point3d[];
    } | undefined;
    // (undocumented)
    static transformFromJson(jTrans: number[] | undefined): Transform;
}

// @internal
export class RealityTile extends Tile {
    constructor(props: RealityTileParams, tree: RealityTileTree);
    // (undocumented)
    addBoundingGraphic(builder: GraphicBuilder, color: ColorDef): void;
    // (undocumented)
    readonly additiveRefinement?: boolean;
    // (undocumented)
    allChildrenIncluded(tiles: Tile[]): boolean;
    // (undocumented)
    protected get _anyChildNotFound(): boolean;
    // (undocumented)
    get channel(): TileRequestChannel;
    // (undocumented)
    computeLoadPriority(viewports: Iterable<Viewport>): number;
    // (undocumented)
    computeVisibilityFactor(args: TileDrawArgs): number;
    // (undocumented)
    forceSelectRealityTile(): boolean;
    // (undocumented)
    getContentClip(): ClipVector | undefined;
    // (undocumented)
    protected getLoadedRealityChildren(args: TileDrawArgs): boolean;
    // (undocumented)
    getSizeProjectionCorners(): Point3d[] | undefined;
    // (undocumented)
    get graphicType(): TileGraphicType | undefined;
    // (undocumented)
    get isDisplayable(): boolean;
    // (undocumented)
    get isLoaded(): boolean;
    // (undocumented)
    isOccluded(_viewingSpace: ViewingSpace): boolean;
    // (undocumented)
    get isPointCloud(): boolean;
    // (undocumented)
    get loadableTile(): RealityTile;
    // (undocumented)
    protected _loadChildren(resolve: (children: Tile[] | undefined) => void, reject: (error: Error) => void): void;
    // (undocumented)
    markDisplayed(): void;
    // (undocumented)
    markUsed(args: TileDrawArgs): void;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    readonly noContentButTerminateOnSelection?: boolean;
    // (undocumented)
    preloadRealityTilesAtDepth(depth: number, context: TraversalSelectionContext, args: TileDrawArgs): void;
    // (undocumented)
    preloadTilesInFrustum(args: TileDrawArgs, context: TraversalSelectionContext, preloadSizeModifier: number): void;
    // (undocumented)
    purgeContents(olderThan: BeTimePoint): void;
    // (undocumented)
    readonly rangeCorners?: Point3d[];
    // (undocumented)
    readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // (undocumented)
    get realityChildren(): RealityTile[] | undefined;
    // (undocumented)
    get realityParent(): RealityTile;
    // (undocumented)
    get realityRoot(): RealityTileTree;
    // (undocumented)
    requestContent(isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    protected selectRealityChildren(context: TraversalSelectionContext, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
    // (undocumented)
    selectRealityTiles(context: TraversalSelectionContext, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
    // (undocumented)
    selectSecondaryTiles(_args: TileDrawArgs, _context: TraversalSelectionContext): void;
    // (undocumented)
    readonly transformToRoot?: Transform;
}

// @internal (undocumented)
export class RealityTileDrawArgs extends TileDrawArgs {
    constructor(args: TileDrawArgs, worldToViewMap: Map4d, frustumPlanes: FrustumPlanes, maxSelectionCount?: number | undefined);
    // (undocumented)
    maxSelectionCount?: number | undefined;
    // (undocumented)
    get worldToViewMap(): Map4d;
    }

// @internal
export abstract class RealityTileLoader {
    constructor();
    // (undocumented)
    protected get _batchType(): BatchType;
    // (undocumented)
    static computeTileClosestToEyePriority(tile: Tile, viewports: Iterable<Viewport>, location: Transform): number;
    // (undocumented)
    computeTilePriority(tile: Tile, viewports: Iterable<Viewport>): number;
    // (undocumented)
    get containsPointClouds(): boolean;
    // (undocumented)
    forceTileLoad(_tile: Tile): boolean;
    // (undocumented)
    getBatchIdMap(): BatchedTileIdMap | undefined;
    // (undocumented)
    abstract getRequestChannel(tile: Tile): TileRequestChannel;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    abstract loadChildren(tile: RealityTile): Promise<Tile[] | undefined>;
    // (undocumented)
    protected get _loadEdges(): boolean;
    // (undocumented)
    loadTileContent(tile: Tile, data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // (undocumented)
    loadTileContentFromStream(tile: RealityTile, streamBuffer: ByteStream, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // (undocumented)
    abstract get maxDepth(): number;
    // (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // (undocumented)
    readonly preloadRealityParentDepth: number;
    // (undocumented)
    readonly preloadRealityParentSkip: number;
    // (undocumented)
    abstract get priority(): TileLoadPriority;
    // (undocumented)
    processSelectedTiles(selected: Tile[], _args: TileDrawArgs): Tile[];
    // (undocumented)
    abstract requestTileContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
}

// @internal (undocumented)
export interface RealityTileParams extends TileParams {
    // (undocumented)
    readonly additiveRefinement?: boolean;
    // (undocumented)
    readonly noContentButTerminateOnSelection?: boolean;
    // (undocumented)
    readonly rangeCorners?: Point3d[];
    // (undocumented)
    readonly transformToRoot?: Transform;
}

// @internal (undocumented)
export class RealityTileTree extends TileTree {
    constructor(params: RealityTileTreeParams);
    // (undocumented)
    createTile(props: TileParams): RealityTile;
    // (undocumented)
    draw(args: TileDrawArgs): void;
    // (undocumented)
    getBaseRealityDepth(_sceneContext: SceneContext): number;
    // (undocumented)
    getTraversalChildren(depth: number): TraversalChildrenDetails;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isContentUnbounded(): boolean;
    // (undocumented)
    get isTransparent(): boolean;
    // (undocumented)
    readonly loader: RealityTileLoader;
    // (undocumented)
    protected logTiles(label: string, tiles: IterableIterator<Tile>): void;
    // (undocumented)
    get maxDepth(): number;
    // (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    // (undocumented)
    preloadTilesForScene(args: TileDrawArgs, context: TraversalSelectionContext, frustumTransform?: Transform): void;
    // (undocumented)
    prune(): void;
    // (undocumented)
    get rootTile(): RealityTile;
    // (undocumented)
    protected _rootTile: RealityTile;
    // (undocumented)
    selectRealityTiles(args: TileDrawArgs, displayedDescendants: RealityTile[][], preloadDebugBuilder?: GraphicBuilder): RealityTile[];
    // (undocumented)
    protected _selectTiles(args: TileDrawArgs): Tile[];
    // (undocumented)
    traversalChildrenByDepth: TraversalChildrenDetails[];
    // (undocumented)
    get viewFlagOverrides(): ViewFlagOverrides;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal (undocumented)
export interface RealityTileTreeParams extends TileTreeParams {
    // (undocumented)
    readonly loader: RealityTileLoader;
    // (undocumented)
    readonly rootTile: RealityTileParams;
    // (undocumented)
    readonly yAxisUp?: boolean;
}

// @public @deprecated (undocumented)
export class RemoteBriefcaseConnection extends CheckpointConnection {
    // @internal
    attachChangeCache(): Promise<void>;
    // @internal
    changeCacheAttached(): Promise<boolean>;
    // @internal
    get editing(): EditingFunctions;
    // (undocumented)
    static open(contextId: string, iModelId: string, openMode?: OpenMode, version?: IModelVersion): Promise<RemoteBriefcaseConnection>;
    pullAndMergeChanges(): Promise<void>;
    pushChanges(description: string): Promise<void>;
    saveChanges(description?: string): Promise<void>;
    updateProjectExtents(newExtents: AxisAlignedBox3d): Promise<void>;
}

// @beta
export abstract class RenderClipVolume implements IDisposable {
    protected constructor(clipVector: ClipVector);
    readonly clipVector: ClipVector;
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    abstract dispose(): void;
    // @internal
    abstract get hasOutsideClipColor(): boolean;
    // @internal (undocumented)
    abstract setClipColors(outsideColor: ColorDef | undefined, insideColor: ColorDef | undefined): void;
}

// @public
export class RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // @internal
    adjustPixelSizeForLOD(cssPixelSize: number): number;
    createBranch(branch: GraphicBranch, location: Transform): RenderGraphic;
    // @internal (undocumented)
    createGraphicBranch(branch: GraphicBranch, location: Transform, opts?: GraphicBranchOptions): RenderGraphic;
    // @internal (undocumented)
    protected _createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    createSceneGraphicBuilder(transform?: Transform): GraphicBuilder;
    readonly frustum: Frustum;
    readonly frustumPlanes: FrustumPlanes;
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // @internal (undocumented)
    get target(): RenderTarget;
    readonly viewFlags: ViewFlags;
    get viewport(): Viewport;
    }

// @internal (undocumented)
export enum RenderDiagnostics {
    All = 6,
    DebugOutput = 2,
    None = 0,
    WebGL = 4
}

// @public
export abstract class RenderGraphic implements IDisposable {
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @public
export abstract class RenderGraphicOwner extends RenderGraphic {
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    dispose(): void;
    disposeGraphic(): void;
    abstract get graphic(): RenderGraphic;
}

// @internal
export namespace RenderMemory {
    export class Buffers extends Consumers {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get instances(): Consumers;
        // (undocumented)
        get pointClouds(): Consumers;
        // (undocumented)
        get pointStrings(): Consumers;
        // (undocumented)
        get polylineEdges(): Consumers;
        // (undocumented)
        get polylines(): Consumers;
        // (undocumented)
        get silhouetteEdges(): Consumers;
        // (undocumented)
        get surfaces(): Consumers;
        // (undocumented)
        get terrain(): Consumers;
        // (undocumented)
        get visibleEdges(): Consumers;
    }
    // (undocumented)
    export enum BufferType {
        // (undocumented)
        COUNT = 9,
        // (undocumented)
        Instances = 7,
        // (undocumented)
        PointClouds = 6,
        // (undocumented)
        PointStrings = 5,
        // (undocumented)
        PolylineEdges = 3,
        // (undocumented)
        Polylines = 4,
        // (undocumented)
        SilhouetteEdges = 2,
        // (undocumented)
        Surfaces = 0,
        // (undocumented)
        Terrain = 8,
        // (undocumented)
        VisibleEdges = 1
    }
    // (undocumented)
    export interface Consumer {
        // (undocumented)
        collectStatistics(stats: Statistics): void;
    }
    export class Consumers {
        // (undocumented)
        addConsumer(numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        count: number;
        // (undocumented)
        maxBytes: number;
        // (undocumented)
        totalBytes: number;
    }
    // (undocumented)
    export enum ConsumerType {
        // (undocumented)
        ClipVolumes = 4,
        // (undocumented)
        COUNT = 9,
        // (undocumented)
        FeatureOverrides = 3,
        // (undocumented)
        FeatureTables = 2,
        // (undocumented)
        PlanarClassifiers = 5,
        // (undocumented)
        ShadowMaps = 6,
        // (undocumented)
        TextureAttachments = 7,
        // (undocumented)
        Textures = 0,
        // (undocumented)
        ThematicTextures = 8,
        // (undocumented)
        VertexTables = 1
    }
    // (undocumented)
    export class Statistics {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        addClipVolume(numBytes: number): void;
        // (undocumented)
        addConsumer(type: ConsumerType, numBytes: number): void;
        // (undocumented)
        addFeatureOverrides(numBytes: number): void;
        // (undocumented)
        addFeatureTable(numBytes: number): void;
        // (undocumented)
        addInstances(numBytes: number): void;
        // (undocumented)
        addPlanarClassifier(numBytes: number): void;
        // (undocumented)
        addPointCloud(numBytes: number): void;
        // (undocumented)
        addPointString(numBytes: number): void;
        // (undocumented)
        addPolyline(numBytes: number): void;
        // (undocumented)
        addPolylineEdges(numBytes: number): void;
        // (undocumented)
        addShadowMap(numBytes: number): void;
        // (undocumented)
        addSilhouetteEdges(numBytes: number): void;
        // (undocumented)
        addSurface(numBytes: number): void;
        // (undocumented)
        addTerrain(numBytes: number): void;
        // (undocumented)
        addTexture(numBytes: number): void;
        // (undocumented)
        addTextureAttachment(numBytes: number): void;
        // (undocumented)
        addThematicTexture(numBytes: number): void;
        // (undocumented)
        addVertexTable(numBytes: number): void;
        // (undocumented)
        addVisibleEdges(numBytes: number): void;
        // (undocumented)
        readonly buffers: Buffers;
        // (undocumented)
        clear(): void;
        // (undocumented)
        get clipVolumes(): Consumers;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        get featureOverrides(): Consumers;
        // (undocumented)
        get featureTables(): Consumers;
        // (undocumented)
        get planarClassifiers(): Consumers;
        // (undocumented)
        get shadowMaps(): Consumers;
        // (undocumented)
        get textureAttachments(): Consumers;
        // (undocumented)
        get textures(): Consumers;
        // (undocumented)
        get thematicTextures(): Consumers;
        // (undocumented)
        get totalBytes(): number;
        // (undocumented)
        get vertexTables(): Consumers;
    }
}

// @internal
export interface RenderPlan {
    // (undocumented)
    readonly activeClipSettings?: ViewClipSettings;
    // (undocumented)
    readonly analysisStyle?: AnalysisStyle;
    // (undocumented)
    readonly analysisTexture?: RenderTexture;
    // (undocumented)
    readonly ao?: AmbientOcclusion.Settings;
    // (undocumented)
    readonly backgroundMapOn: boolean;
    // (undocumented)
    readonly bgColor: ColorDef;
    // (undocumented)
    readonly emphasisSettings: Hilite.Settings;
    // (undocumented)
    readonly fraction: number;
    // (undocumented)
    readonly frustum: Frustum;
    // (undocumented)
    readonly globalViewTransition: number;
    // (undocumented)
    readonly hiliteSettings: Hilite.Settings;
    // (undocumented)
    readonly hline?: HiddenLine.Settings;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly isFadeOutActive: boolean;
    // (undocumented)
    readonly isGlobeMode3D: boolean;
    // (undocumented)
    readonly lights?: LightSettings;
    // (undocumented)
    readonly locatableTerrain: boolean;
    // (undocumented)
    readonly monochromeMode: MonochromeMode;
    // (undocumented)
    readonly monoColor: ColorDef;
    // (undocumented)
    readonly terrainTransparency: number;
    // (undocumented)
    readonly thematic?: ThematicDisplay;
    // (undocumented)
    readonly upVector: Vector3d;
    // (undocumented)
    readonly viewFlags: ViewFlags;
}

// @internal
export abstract class RenderPlanarClassifier implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext, target: PlanarClassifierTarget): void;
    // (undocumented)
    abstract dispose(): void;
    // (undocumented)
    abstract setSource(classifierTreeRef?: SpatialClassifierTileTreeReference, planarClipMask?: PlanarClipMaskState): void;
}

// @internal (undocumented)
export namespace RenderScheduleState {
    // (undocumented)
    export class ColorEntry extends TimelineEntry implements RenderSchedule.ColorEntryProps {
        constructor(props: RenderSchedule.ColorEntryProps);
        // (undocumented)
        toJSON(): RenderSchedule.ColorEntryProps;
        // (undocumented)
        value: {
            red: number;
            green: number;
            blue: number;
        };
    }
    // (undocumented)
    export class CuttingPlaneEntry extends TimelineEntry implements RenderSchedule.CuttingPlaneEntryProps {
        constructor(props: RenderSchedule.CuttingPlaneEntryProps);
        // (undocumented)
        toJSON(): RenderSchedule.CuttingPlaneEntryProps;
        // (undocumented)
        value: RenderSchedule.CuttingPlaneProps;
    }
    // (undocumented)
    export class ElementTimeline extends Timeline implements RenderSchedule.ElementTimelineProps {
        // (undocumented)
        batchId: number;
        // (undocumented)
        get containsClipping(): boolean;
        // (undocumented)
        get containsFeatureOverrides(): boolean;
        // (undocumented)
        get containsTransform(): boolean;
        // (undocumented)
        elementIds: Id64String[] | CompressedId64Set;
        // (undocumented)
        static fromJSON(json?: RenderSchedule.ElementTimelineProps): ElementTimeline;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number, interval: Interval, batchId: number): void;
        // (undocumented)
        get isValid(): boolean;
        // (undocumented)
        toJSON(): RenderSchedule.ElementTimelineProps;
    }
    // (undocumented)
    export class Interval {
        constructor(index0?: number, index1?: number, fraction?: number);
        // (undocumented)
        fraction: number;
        // (undocumented)
        index0: number;
        // (undocumented)
        index1: number;
        // (undocumented)
        init(index0: number, index1: number, fraction: number): void;
    }
    // (undocumented)
    export class ModelTimeline extends Timeline implements RenderSchedule.ModelTimelineProps {
        // (undocumented)
        computeDuration(): Range1d;
        // (undocumented)
        containsElementClipping: boolean;
        // (undocumented)
        containsFeatureOverrides: boolean;
        // (undocumented)
        containsModelClipping: boolean;
        // (undocumented)
        containsTransform: boolean;
        // (undocumented)
        elementTimelines: ElementTimeline[];
        // (undocumented)
        static fromJSON(json?: RenderSchedule.ModelTimelineProps, displayStyle?: DisplayStyleState): ModelTimeline;
        // (undocumented)
        getAnimationBranches(branches: AnimationBranchStates, scheduleTime: number): void;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number): void;
        // (undocumented)
        getTransform(nodeId: number, time: number): Transform | undefined;
        // (undocumented)
        getTransformNodeIds(): number[] | undefined;
        // (undocumented)
        modelId: Id64String;
        // (undocumented)
        realityModelUrl?: string;
        // (undocumented)
        toJSON(): RenderSchedule.ModelTimelineProps;
    }
    // (undocumented)
    export class Script {
        constructor(displayStyleId: Id64String);
        // (undocumented)
        computeDuration(): Range1d;
        // (undocumented)
        containsElementClipping: boolean;
        // (undocumented)
        get containsFeatureOverrides(): boolean;
        // (undocumented)
        containsModelClipping: boolean;
        // (undocumented)
        containsTransform: boolean;
        // (undocumented)
        displayStyleId: Id64String;
        // (undocumented)
        static fromJSON(displayStyleId: Id64String, modelTimelines: Readonly<RenderSchedule.ModelTimelineProps[]>): Script | undefined;
        // (undocumented)
        getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined;
        getCachedDuration(): Range1d;
        // (undocumented)
        getModelAnimationId(modelId: Id64String): Id64String | undefined;
        // (undocumented)
        getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number): void;
        // (undocumented)
        getTransform(modelId: Id64String, nodeId: number, time: number): Transform | undefined;
        // (undocumented)
        getTransformNodeIds(modelId: Id64String): number[] | undefined;
        // (undocumented)
        modelTimelines: ModelTimeline[];
        // (undocumented)
        toJSON(): RenderSchedule.ModelTimelineProps[];
    }
    // (undocumented)
    export class Timeline implements RenderSchedule.TimelineProps {
        // (undocumented)
        colorTimeline?: ColorEntry[];
        // (undocumented)
        computeDuration(): Range1d;
        // (undocumented)
        cuttingPlaneTimeline?: CuttingPlaneEntry[];
        // (undocumented)
        extractTimelinesFromJSON(json: RenderSchedule.TimelineProps): void;
        // (undocumented)
        static findTimelineInterval(interval: Interval, time: number, timeline?: TimelineEntry[]): boolean;
        // (undocumented)
        getAnimationClip(time: number, interval: Interval): RenderClipVolume | undefined;
        // (undocumented)
        getAnimationTransform(time: number, interval: Interval): Transform | undefined;
        // (undocumented)
        getColorOverride(time: number, interval: Interval): RgbColor | undefined;
        // (undocumented)
        getVisibilityOverride(time: number, interval: Interval): number;
        // (undocumented)
        toJSON(): RenderSchedule.TimelineProps;
        // (undocumented)
        transformTimeline?: TransformEntry[];
        // (undocumented)
        visibilityTimeline?: VisibilityEntry[];
    }
    // (undocumented)
    export class TimelineEntry implements RenderSchedule.TimelineEntryProps {
        constructor(props: RenderSchedule.TimelineEntryProps);
        // (undocumented)
        interpolation: number;
        // (undocumented)
        time: number;
        // (undocumented)
        toJSON(): RenderSchedule.TimelineEntryProps;
    }
    // (undocumented)
    export class TransformEntry extends TimelineEntry implements RenderSchedule.TransformEntryProps {
        constructor(props: RenderSchedule.TransformEntryProps);
        // (undocumented)
        toJSON(): RenderSchedule.TransformEntryProps;
        // (undocumented)
        value: RenderSchedule.TransformProps;
    }
    // (undocumented)
    export class VisibilityEntry extends TimelineEntry implements RenderSchedule.VisibilityEntryProps {
        constructor(props: RenderSchedule.VisibilityEntryProps);
        // (undocumented)
        toJSON(): RenderSchedule.VisibilityEntryProps;
        // (undocumented)
        value: number;
    }
    {};
}

// @public
export abstract class RenderSystem implements IDisposable {
    // @internal
    protected constructor(options?: RenderSystem.Options);
    // @beta
    antialiasSamples?: number;
    // @internal (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    // @beta
    static contextLossHandler(): Promise<any>;
    // @internal (undocumented)
    createBackgroundMapDrape(_drapedTree: TileTreeReference, _mapTree: MapTileTreeReference): RenderTextureDrape | undefined;
    // @internal
    abstract createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d, tileId?: string): RenderGraphic;
    createBranch(branch: GraphicBranch, transform: Transform): RenderGraphic;
    // @internal (undocumented)
    createClipVolume(_clipVector: ClipVector): RenderClipVolume | undefined;
    // @internal (undocumented)
    abstract createGraphicBranch(branch: GraphicBranch, transform: Transform, options?: GraphicBranchOptions): RenderGraphic;
    abstract createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder;
    // @internal
    createGraphicLayer(graphic: RenderGraphic, _layerId: string): RenderGraphic;
    // @internal
    createGraphicLayerContainer(graphic: RenderGraphic, _drawAsOverlay: boolean, _transparency: number, _elevation: number): RenderGraphic;
    abstract createGraphicList(primitives: RenderGraphic[]): RenderGraphic;
    createGraphicOwner(ownedGraphic: RenderGraphic): RenderGraphicOwner;
    // @internal (undocumented)
    createIndexedPolylines(args: PolylineArgs, instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    createMaterial(_params: RenderMaterial.Params, _imodel: IModelConnection): RenderMaterial | undefined;
    // @internal (undocumented)
    createMesh(_params: MeshParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createOffscreenTarget(rect: ViewRect): RenderTarget;
    // @internal (undocumented)
    createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointString(_params: PointStringParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @internal (undocumented)
    createPolyline(_params: PolylineParams, _instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @beta
    createScreenSpaceEffectBuilder(_params: ScreenSpaceEffectBuilderParams): ScreenSpaceEffectBuilder | undefined;
    createSkyBox(_params: SkyBox.CreateParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createTarget(canvas: HTMLCanvasElement): RenderTarget;
    // @internal (undocumented)
    createTerrainMeshGeometry(_terrainMesh: TerrainMeshPrimitive, _transform: Transform): RenderTerrainMeshGeometry | undefined;
    // @internal (undocumented)
    createTerrainMeshGraphic(_terrainGeometry: RenderTerrainMeshGeometry, _featureTable: PackedFeatureTable, _tileId: string, _baseColor: ColorDef | undefined, _baseTransparent: boolean, _textures?: TerrainTexture[]): RenderGraphic | undefined;
    // @internal
    createTextureFromCubeImages(_posX: HTMLImageElement, _negX: HTMLImageElement, _posY: HTMLImageElement, _negY: HTMLImageElement, _posZ: HTMLImageElement, _negZ: HTMLImageElement, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromElement(_id: Id64String, _imodel: IModelConnection, _params: RenderTexture.Params, _format: ImageSourceFormat): RenderTexture | undefined;
    createTextureFromImage(_image: HTMLImageElement, _hasAlpha: boolean, _imodel: IModelConnection | undefined, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageBuffer(_image: ImageBuffer, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageSource(source: ImageSource, imodel: IModelConnection | undefined, params: RenderTexture.Params): Promise<RenderTexture | undefined>;
    // @internal (undocumented)
    createTile(tileTexture: RenderTexture, corners: Point3d[], featureIndex?: number): RenderGraphic | undefined;
    // @internal (undocumented)
    createTriMesh(args: MeshArgs, instances?: InstancedGraphicParams | Point3d): RenderGraphic | undefined;
    // @beta
    get debugControl(): RenderSystemDebugControl | undefined;
    // @internal (undocumented)
    abstract dispose(): void;
    // @internal
    abstract doIdleWork(): boolean;
    // @internal (undocumented)
    get dpiAwareLOD(): boolean;
    // @internal (undocumented)
    enableDiagnostics(_enable: RenderDiagnostics): void;
    findMaterial(_key: string, _imodel: IModelConnection): RenderMaterial | undefined;
    findTexture(_key: string, _imodel: IModelConnection): RenderTexture | undefined;
    getGradientTexture(_symb: Gradient.Symb, _imodel: IModelConnection): RenderTexture | undefined;
    // @internal (undocumented)
    get isMobile(): boolean;
    // @internal (undocumented)
    abstract get isValid(): boolean;
    // @internal
    loadTexture(id: Id64String, iModel: IModelConnection): Promise<RenderTexture | undefined>;
    // @internal
    loadTextureImage(id: Id64String, iModel: IModelConnection): Promise<TextureImage | undefined>;
    // @internal (undocumented)
    get maxTerrainImageryLayers(): number;
    // @internal (undocumented)
    get maxTextureSize(): number;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    readonly options: RenderSystem.Options;
    // @internal (undocumented)
    get supportsInstancing(): boolean;
    // @internal (undocumented)
    get supportsLogZBuffer(): boolean;
}

// @public
export namespace RenderSystem {
    // @beta
    export interface Options {
        antialiasSamples?: number;
        // @internal
        contextAttributes?: WebGLContextAttributes;
        // @internal
        debugShaders?: boolean;
        devicePixelRatioOverride?: number;
        // @internal
        disabledExtensions?: WebGLExtensionName[];
        displaySolarShadows?: boolean;
        doIdleWork?: boolean;
        dpiAwareLOD?: boolean;
        dpiAwareViewports?: boolean;
        // @internal
        filterMapDrapeTextures?: boolean;
        // @internal
        filterMapTextures?: boolean;
        logarithmicDepthBuffer?: boolean;
        // @internal
        planProjections?: boolean;
        // @internal
        preserveShaderSourceCode?: boolean;
        // @internal
        useWebGL2?: boolean;
    }
}

// @beta
export interface RenderSystemDebugControl {
    // @internal
    compileAllShaders(): boolean;
    // @internal
    debugShaderFiles?: DebugShaderFile[];
    // @internal
    dpiAwareLOD: boolean;
    drawSurfacesAsWiremesh: boolean;
    // @internal
    readonly isGLTimerSupported: boolean;
    loseContext(): boolean;
    // @internal
    resultsCallback?: GLTimerResultCallback;
}

// @internal
export abstract class RenderTarget implements IDisposable, RenderMemory.Consumer {
    adjustPixelSizeForLOD(cssPixelSize: number): number;
    // (undocumented)
    abstract get analysisFraction(): number;
    abstract set analysisFraction(fraction: number);
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(_transforms: AnimationBranchStates | undefined);
    // (undocumented)
    get antialiasSamples(): number;
    set antialiasSamples(_numSamples: number);
    // (undocumented)
    abstract changeDecorations(decorations: Decorations): void;
    // (undocumented)
    abstract changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    abstract changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    abstract changeScene(scene: Scene): void;
    // (undocumented)
    collectStatistics(_stats: RenderMemory.Statistics): void;
    // (undocumented)
    createGraphicBuilder(type: GraphicType, viewport: Viewport, placement?: Transform, pickableId?: Id64String): import("./GraphicBuilder").GraphicBuilder;
    // (undocumented)
    createPlanarClassifier(_properties?: SpatialClassificationProps.Classifier): RenderPlanarClassifier | undefined;
    // (undocumented)
    cssPixelsToDevicePixels(cssPixels: number, floor?: boolean): number;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl | undefined;
    // (undocumented)
    get devicePixelRatio(): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    abstract drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    getPlanarClassifier(_id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrape(_id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    onBeforeRender(_viewport: Viewport, _setSceneNeedRedraw: (redraw: boolean) => void): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(_ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    pickOverlayDecoration(_pt: XAndY): CanvasDecoration | undefined;
    readImage(_rect: ViewRect, _targetSize: Point2d, _flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    readImageToCanvas(): HTMLCanvasElement;
    abstract readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    abstract get renderSystem(): RenderSystem;
    // (undocumented)
    reset(): void;
    abstract get screenSpaceEffects(): Iterable<string>;
    abstract set screenSpaceEffects(_effectNames: Iterable<string>);
    // (undocumented)
    setFlashed(_elementId: Id64String, _intensity: number): void;
    // (undocumented)
    setHiliteSet(_hilited: HiliteSet): void;
    setRenderToScreen(_toScreen: boolean): HTMLCanvasElement | undefined;
    // (undocumented)
    abstract setViewRect(_rect: ViewRect, _temporary: boolean): void;
    updateSolarShadows(_context: SceneContext | undefined): void;
    // (undocumented)
    abstract updateViewRect(): boolean;
    abstract get viewRect(): ViewRect;
    // (undocumented)
    abstract get wantInvertBlackBackground(): boolean;
}

// @beta
export interface RenderTargetDebugControl {
    // @internal
    devicePixelRatioOverride?: number;
    // @internal (undocumented)
    displayDrapeFrustum: boolean;
    // @internal (undocumented)
    displayRealityTilePreload: boolean;
    // @internal (undocumented)
    displayRealityTileRanges: boolean;
    drawForReadPixels: boolean;
    // @internal (undocumented)
    freezeRealityTiles: boolean;
    // @internal (undocumented)
    logRealityTiles: boolean;
    // @alpha (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // @internal (undocumented)
    readonly shadowFrustum: Frustum | undefined;
    // @internal (undocumented)
    vcSupportIntersectingVolumes: boolean;
}

// @internal (undocumented)
export abstract class RenderTerrainMeshGeometry implements IDisposable, RenderMemory.Consumer {
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @internal
export abstract class RenderTextureDrape implements IDisposable {
    // (undocumented)
    abstract collectGraphics(context: SceneContext): void;
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @internal (undocumented)
export type RequestTileTreePropsFunc = (iModel: IModelConnection, treeId: string) => Promise<IModelTileTreeProps>;

// @internal
export type RootIModelTile = Tile & {
    updateDynamicRange: (childTile: Tile) => void;
};

// @public
export class RotateViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum RotationMode {
    // (undocumented)
    ACS = 5,
    // (undocumented)
    Context = 6,
    // (undocumented)
    Front = 2,
    // (undocumented)
    Side = 3,
    // (undocumented)
    Top = 1,
    // (undocumented)
    View = 4
}

// @internal (undocumented)
export class RoundOff {
    // (undocumented)
    active: boolean;
    // (undocumented)
    units: Set<number>;
}

// @internal (undocumented)
export class SavedState {
    // (undocumented)
    auxRotationPlane: number;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    ignoreFlags: AccuDrawFlags;
    // (undocumented)
    mode: CompassMode;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    state: CurrentState;
}

// @beta
export class Scene {
    readonly background: RenderGraphic[];
    readonly foreground: RenderGraphic[];
    readonly overlay: RenderGraphic[];
    // @internal (undocumented)
    readonly planarClassifiers: Map<string, RenderPlanarClassifier>;
    // @internal (undocumented)
    readonly textureDrapes: Map<string, RenderTextureDrape>;
    // @internal (undocumented)
    volumeClassifier?: SceneVolumeClassifier;
}

// @beta
export class SceneContext extends RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // @internal (undocumented)
    addBackgroundDrapedModel(drapedTreeRef: TileTreeReference, _heightRange: Range1d | undefined): RenderTextureDrape | undefined;
    // @internal (undocumented)
    addPlanarClassifier(classifiedModelId: Id64String, classifierTree?: SpatialClassifierTileTreeReference, planarClipMask?: PlanarClipMaskState): RenderPlanarClassifier | undefined;
    // @internal (undocumented)
    get backgroundGraphics(): RenderGraphic[];
    // @internal (undocumented)
    getPlanarClassifierForModel(modelId: Id64String): RenderPlanarClassifier | undefined;
    // @internal (undocumented)
    getTextureDrapeForModel(modelId: Id64String): RenderTextureDrape | undefined;
    // @internal (undocumented)
    get graphics(): RenderGraphic[];
    // @internal (undocumented)
    get graphicType(): TileGraphicType;
    // @internal (undocumented)
    get hasMissingTiles(): boolean;
    insertMissingTile(tile: Tile): void;
    // @internal (undocumented)
    markChildrenLoading(): void;
    // @internal (undocumented)
    readonly missingTiles: Set<Tile>;
    // @internal (undocumented)
    outputGraphic(graphic: RenderGraphic): void;
    // @internal (undocumented)
    get overlayGraphics(): RenderGraphic[];
    // @internal (undocumented)
    get planarClassifiers(): Map<string, RenderPlanarClassifier>;
    // @internal (undocumented)
    requestMissingTiles(): void;
    readonly scene: Scene;
    // @internal (undocumented)
    setVolumeClassifier(classifier: SpatialClassificationProps.Classifier, modelId: Id64String): void;
    // @internal (undocumented)
    get textureDrapes(): Map<string, RenderTextureDrape>;
    // (undocumented)
    get viewingSpace(): ViewingSpace;
    // @internal (undocumented)
    withGraphicType(type: TileGraphicType, func: () => void): void;
}

// @internal
export interface SceneVolumeClassifier {
    // (undocumented)
    classifier: SpatialClassificationProps.Classifier;
    // (undocumented)
    modelId: Id64String;
}

// @beta
export interface ScreenSpaceEffectBuilder {
    addUniform: (params: UniformParams) => void;
    addUniformArray: (params: UniformArrayParams) => void;
    addVarying: (name: string, type: VaryingType) => void;
    finish: () => void;
    readonly isWebGL2: boolean;
    shouldApply?: (context: ScreenSpaceEffectContext) => boolean;
}

// @beta
export interface ScreenSpaceEffectBuilderParams {
    name: string;
    source: ScreenSpaceEffectSource;
    textureCoordFromPosition?: boolean;
}

// @beta
export interface ScreenSpaceEffectContext {
    viewport: Viewport;
}

// @beta
export interface ScreenSpaceEffectSource {
    fragment: string;
    sampleSourcePixel?: string;
    vertex: string;
}

// @public
export class ScreenViewport extends Viewport {
    // @internal
    protected constructor(canvas: HTMLCanvasElement, parentDiv: HTMLDivElement, target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(decorations: Decorations): void;
    // @internal (undocumented)
    protected addLogo(): void;
    // @internal (undocumented)
    addNewDiv(className: string, overflowHidden: boolean, z: number): HTMLDivElement;
    // @internal
    animateFlyoverToGlobalLocation(destination: GlobalLocation): Promise<void>;
    // @internal (undocumented)
    animateFrustumChange(options?: ViewAnimationOptions): void;
    // @internal
    animateToCurrent(_start: Frustum, options?: ViewAnimationOptions): void;
    // @beta
    static animation: {
        time: {
            fast: BeDuration;
            normal: BeDuration;
            slow: BeDuration;
            wheel: BeDuration;
        };
        easing: (k: number) => number;
        zoomOut: {
            enable: boolean;
            interpolation: (v: any, k: number) => number;
            heights: number[];
            positions: number[];
            margin: number;
            durationFactor: number;
        };
    };
    readonly canvas: HTMLCanvasElement;
    changeView(view: ViewState, opts?: ViewChangeOptions): void;
    clearViewUndo(): void;
    static create(parentDiv: HTMLDivElement, view: ViewState): ScreenViewport;
    // @deprecated
    readonly decorationDiv: HTMLDivElement;
    // @internal (undocumented)
    dispose(): void;
    doRedo(animationTime?: BeDuration): void;
    doUndo(animationTime?: BeDuration): void;
    // @internal (undocumented)
    drawLocateCursor(context: DecorateContext, viewPt: Point3d, aperture: number, isLocateCircleOn: boolean, hit?: HitDetail): void;
    getClientRect(): ClientRect;
    // @beta
    invalidateCachedDecorations(decorator: ViewportDecorator): void;
    // @internal (undocumented)
    invalidateScene(): void;
    get isRedoPossible(): boolean;
    get isUndoPossible(): boolean;
    // @beta
    get logo(): HTMLImageElement;
    // @internal (undocumented)
    static markAllChildrenForRemoval(el: HTMLDivElement): void;
    maxUndoSteps: number;
    // @internal (undocumented)
    mouseMovementFromEvent(ev: MouseEvent): XAndY;
    // @internal (undocumented)
    mousePosFromEvent(ev: MouseEvent): XAndY;
    openToolTip(message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    readonly parentDiv: HTMLDivElement;
    // @internal (undocumented)
    pickCanvasDecoration(pt: XAndY): import("./imodeljs-frontend").CanvasDecoration | undefined;
    // @alpha
    pickDepthPoint(pickPoint: Point3d, radius?: number, options?: DepthPointOptions): {
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        sourceId?: string;
    };
    pickNearestVisibleGeometry(pickPoint: Point3d, radius?: number, allowNonLocatable?: boolean, out?: Point3d): Point3d | undefined;
    // @internal
    static removeAllChildren(el: HTMLDivElement): void;
    // @internal (undocumented)
    static removeMarkedChildren(el: HTMLDivElement): void;
    // @internal
    get rendersToScreen(): boolean;
    set rendersToScreen(toScreen: boolean);
    resetUndo(): void;
    saveViewUndo(): void;
    setCursor(cursor?: string): void;
    setEventController(controller?: EventController): void;
    // @internal
    static setToParentSize(div: HTMLElement): void;
    // @internal (undocumented)
    synchWithView(options?: ViewChangeOptions | boolean): void;
    readonly toolTipDiv: HTMLDivElement;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    // @internal (undocumented)
    get viewCmdTargetCenter(): Point3d | undefined;
    set viewCmdTargetCenter(center: Point3d | undefined);
    get viewRect(): ViewRect;
    readonly vpDiv: HTMLDivElement;
    }

// @public
export class ScrollViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @internal
export interface SectionDrawingInfo {
    // (undocumented)
    readonly drawingToSpatialTransform: Transform;
    // (undocumented)
    readonly spatialView: Id64String;
}

// @public
export class SectionDrawingModelState extends DrawingModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export interface SelectAddEvent {
    added: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Add;
}

// @internal
export interface SelectedAndReadyTiles {
    // @alpha
    readonly external: ExternalTileStatistics;
    readonly ready: Set<Tile>;
    readonly selected: Set<Tile>;
}

// @public
export interface SelectedViewportChangedArgs {
    // (undocumented)
    current?: ScreenViewport;
    // (undocumented)
    previous?: ScreenViewport;
}

// @public
export enum SelectionMethod {
    Box = 2,
    Line = 1,
    Pick = 0
}

// @public
export enum SelectionMode {
    Add = 1,
    Remove = 2,
    Replace = 0
}

// @public
export enum SelectionProcessing {
    AddElementToSelection = 0,
    InvertElementInSelection = 2,
    RemoveElementFromSelection = 1,
    ReplaceSelectionWithElement = 3
}

// @public
export class SelectionSet {
    constructor(iModel: IModelConnection);
    add(elem: Id64Arg): boolean;
    addAndRemove(adds: Id64Arg, removes: Id64Arg): boolean;
    get elements(): Set<string>;
    emptyAll(): void;
    has(elemId?: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(elem: Id64Arg): boolean;
    get isActive(): boolean;
    isSelected(elemId?: Id64String): boolean;
    readonly onChanged: BeEvent<(ev: SelectionSetEvent) => void>;
    remove(elem: Id64Arg): boolean;
    replace(elem: Id64Arg): void;
    get size(): number;
}

// @public
export type SelectionSetEvent = SelectAddEvent | SelectRemoveEvent | SelectReplaceEvent;

// @public
export enum SelectionSetEventType {
    Add = 0,
    Clear = 3,
    Remove = 1,
    Replace = 2
}

// @public
export class SelectionTool extends PrimitiveTool {
    // @beta
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): boolean;
    // (undocumented)
    autoLockTarget(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    filterHit(hit: HitDetail, out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    protected initSelectTool(): void;
    // (undocumented)
    protected _isSelectByPoints: boolean;
    // (undocumented)
    protected _isSuspended: boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onSuspend(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected processMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    processSelection(elementId: Id64Arg, process: SelectionProcessing): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected selectByPointsEnd(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected selectByPointsProcess(origin: Point3d, corner: Point3d, ev: BeButtonEvent, method: SelectionMethod, overlap: boolean): void;
    // (undocumented)
    protected selectByPointsStart(ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecoration(ev: BeButtonEvent, currHit?: HitDetail): Promise<EventHandled>;
    // (undocumented)
    get selectionMethod(): SelectionMethod;
    set selectionMethod(method: SelectionMethod);
    // (undocumented)
    get selectionMode(): SelectionMode;
    set selectionMode(mode: SelectionMode);
    // (undocumented)
    protected showPrompt(mode: SelectionMode, method: SelectionMethod): void;
    // (undocumented)
    static startTool(): boolean;
    // @beta
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateSelection(elementId: Id64Arg, process: SelectionProcessing): boolean;
    // (undocumented)
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantEditManipulators(): boolean;
    // (undocumented)
    protected wantPickableDecorations(): boolean;
    // (undocumented)
    protected wantSelectionClearOnMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantToolSettings(): boolean;
}

// @internal
export enum SelectParent {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @public
export interface SelectRemoveEvent {
    removed: Id64Arg;
    set: SelectionSet;
    type: SelectionSetEventType.Remove | SelectionSetEventType.Clear;
}

// @public
export interface SelectReplaceEvent {
    added: Id64Arg;
    removed: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Replace;
}

// @alpha
export class SetupCameraTool extends PrimitiveTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): boolean;
    // (undocumented)
    get cameraHeight(): number;
    set cameraHeight(option: number);
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    static drawCameraFrustum(context: DecorateContext, vp: ScreenViewport, eyePtWorld: Point3d, targetPtWorld: Point3d, eyeSnapPtWorld?: Point3d, targetSnapPtWorld?: Point3d): void;
    // (undocumented)
    protected _eyePtWorld: Point3d;
    // (undocumented)
    protected getAdjustedEyePoint(): Point3d;
    // (undocumented)
    protected getAdjustedTargetPoint(): Point3d;
    // (undocumented)
    protected _haveEyePt: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // @beta (undocumented)
    protected provideToolAssistance(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    get targetHeight(): number;
    set targetHeight(option: number);
    // (undocumented)
    protected _targetPtWorld: Point3d;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    get useCameraHeight(): boolean;
    set useCameraHeight(option: boolean);
    // (undocumented)
    get useTargetHeight(): boolean;
    set useTargetHeight(option: boolean);
    // (undocumented)
    viewport?: ScreenViewport;
}

// @beta
export class SetupWalkCameraTool extends PrimitiveTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    static drawFigure(context: DecorateContext, vp: Viewport, groundPt: Point3d, eyeHeight: number): void;
    // (undocumented)
    protected _eyePtWorld: Point3d;
    // (undocumented)
    protected getAdjustedEyePoint(): Point3d;
    // (undocumented)
    protected getAdjustedTargetPoint(): Point3d;
    // (undocumented)
    protected _haveEyePt: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected provideToolAssistance(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected _targetPtWorld: Point3d;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @public
export class SheetModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SheetViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, sheetProps: SheetProps, attachments: Id64Array);
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    // (undocumented)
    get attachmentIds(): Id64Array;
    // @internal
    get attachments(): Object[] | undefined;
    // @internal (undocumented)
    attachToViewport(): void;
    // @internal (undocumented)
    changeViewedModel(modelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // @internal (undocumented)
    collectNonTileTreeStatistics(stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    static createFromProps(viewStateData: ViewStateProps, iModel: IModelConnection): SheetViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // @internal (undocumented)
    detachFromViewport(): void;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    // (undocumented)
    getExtents(): import("@bentley/geometry-core").Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // @internal (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // @internal
    load(): Promise<void>;
    // @internal (undocumented)
    get secondaryViewports(): Iterable<Viewport>;
    readonly sheetSize: Point2d;
    // (undocumented)
    toProps(): ViewStateProps;
    // @internal
    get viewAttachmentProps(): Array<Readonly<ViewAttachmentProps>>;
    }

// @internal
export type ShouldAbortReadGltf = (reader: GltfReader) => boolean;

// @public
export abstract class SkyBox implements SkyBoxProps {
    protected constructor(sky?: SkyBoxProps);
    static createFromJSON(json?: SkyBoxProps): SkyBox;
    display: boolean;
    // @internal (undocumented)
    abstract loadParams(_system: RenderSystem, _iModel: IModelConnection): SkyBoxParams;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @public
export namespace SkyBox {
    export class CreateParams {
        // (undocumented)
        static createForCube(cube: RenderTexture): CreateParams;
        // (undocumented)
        static createForGradient(gradient: SkyGradient, zOffset: number): CreateParams;
        // (undocumented)
        static createForSphere(sphere: SphereParams, zOffset: number): CreateParams;
        // (undocumented)
        readonly cube?: RenderTexture;
        // (undocumented)
        readonly gradient?: SkyGradient;
        // (undocumented)
        readonly sphere?: SphereParams;
        // (undocumented)
        readonly zOffset: number;
    }
    export class SphereParams {
        constructor(texture: RenderTexture, rotation: number);
        // (undocumented)
        readonly rotation: number;
        // (undocumented)
        readonly texture: RenderTexture;
    }
}

// @internal
export type SkyBoxParams = Promise<SkyBox.CreateParams | undefined> | SkyBox.CreateParams | undefined;

// @public
export class SkyCube extends SkyBox implements SkyCubeProps {
    readonly back: Id64String;
    readonly bottom: Id64String;
    static create(front: Id64String, back: Id64String, top: Id64String, bottom: Id64String, right: Id64String, left: Id64String, display?: boolean): SkyCube | undefined;
    // @internal
    static fromJSON(skyboxJson: SkyBoxProps): SkyCube | undefined;
    readonly front: Id64String;
    readonly left: Id64String;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly right: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly top: Id64String;
}

// @public
export class SkyGradient extends SkyBox {
    constructor(sky?: SkyBoxProps);
    readonly groundColor: ColorDef;
    readonly groundExponent: number;
    // @internal (undocumented)
    loadParams(_system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly nadirColor: ColorDef;
    readonly skyColor: ColorDef;
    readonly skyExponent: number;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly twoColor: boolean;
    readonly zenithColor: ColorDef;
}

// @public
export class SkySphere extends SkyBox {
    static fromJSON(json: SkyBoxProps): SkySphere | undefined;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    textureId: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @public
export class SnapDetail extends HitDetail {
    constructor(from: HitDetail, snapMode?: SnapMode, heat?: SnapHeat, snapPoint?: XYZProps);
    readonly adjustedPoint: Point3d;
    clone(): SnapDetail;
    // (undocumented)
    draw(context: DecorateContext): void;
    geomType?: HitGeomType;
    // (undocumented)
    getCurvePrimitive(singleSegment?: boolean): CurvePrimitive | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    // (undocumented)
    heat: SnapHeat;
    get isHot(): boolean;
    get isPointAdjusted(): boolean;
    normal?: Vector3d;
    parentGeomType?: HitParentGeomType;
    primitive?: CurvePrimitive;
    setCurvePrimitive(primitive?: CurvePrimitive, localToWorld?: Transform, geomType?: HitGeomType): void;
    setSnapPoint(point: Point3d, heat: SnapHeat): void;
    // (undocumented)
    snapMode: SnapMode;
    readonly snapPoint: Point3d;
    sprite?: Sprite;
}

// @public (undocumented)
export enum SnapHeat {
    // (undocumented)
    InRange = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    NotInRange = 1
}

// @public (undocumented)
export enum SnapMode {
    // (undocumented)
    Bisector = 32,
    // (undocumented)
    Center = 8,
    // (undocumented)
    Intersection = 64,
    // (undocumented)
    MidPoint = 4,
    // (undocumented)
    Nearest = 1,
    // (undocumented)
    NearestKeypoint = 2,
    // (undocumented)
    Origin = 16
}

// @public
export class SnapshotConnection extends IModelConnection {
    close(): Promise<void>;
    get iModelId(): GuidString;
    get isClosed(): boolean;
    get isRemote(): boolean;
    isSnapshotConnection(): this is SnapshotConnection;
    static openFile(filePath: string): Promise<SnapshotConnection>;
    static openRemote(fileKey: string): Promise<SnapshotConnection>;
}

// @public (undocumented)
export enum SnapStatus {
    // (undocumented)
    Aborted = 1,
    // (undocumented)
    Disabled = 100,
    // (undocumented)
    FilteredByApp = 600,
    // (undocumented)
    FilteredByAppQuietly = 700,
    // (undocumented)
    NoElements = 2,
    // (undocumented)
    NoSnapPossible = 200,
    // (undocumented)
    NotSnappable = 300,
    // (undocumented)
    Success = 0
}

// @beta
export class SpatialClassifiers {
    [Symbol.iterator](): Iterator<SpatialClassificationProps.Classifier>;
    // @internal
    constructor(jsonContainer: SpatialClassifiersContainer);
    get active(): SpatialClassificationProps.Classifier | undefined;
    set active(active: SpatialClassificationProps.Classifier | undefined);
    get length(): number;
    push(classifier: SpatialClassificationProps.Classifier): SpatialClassificationProps.Classifier | undefined;
}

// @internal (undocumented)
export interface SpatialClassifiersContainer {
    // (undocumented)
    classifiers?: SpatialClassificationProps.Properties[];
}

// @internal (undocumented)
export abstract class SpatialClassifierTileTreeReference extends TileTreeReference {
    // (undocumented)
    abstract get activeClassifier(): SpatialClassificationProps.Classifier | undefined;
    // (undocumented)
    abstract get classifiers(): SpatialClassifiers;
    // (undocumented)
    abstract get isPlanar(): boolean;
}

// @public
export class SpatialLocationModelState extends SpatialModelState {
    // @internal (undocumented)
    static get className(): string;
}

// @public
export class SpatialModelState extends GeometricModel3dState {
    constructor(props: ModelProps, iModel: IModelConnection, state?: SpatialModelState);
    // @internal (undocumented)
    get asSpatialModel(): SpatialModelState;
    // @beta
    readonly classifiers?: SpatialClassifiers;
    // @internal (undocumented)
    static get className(): string;
    // @beta
    get isRealityModel(): boolean;
}

// @internal
export interface SpatialTileTreeReferences extends Iterable<TileTreeReference> {
    readonly [Symbol.iterator]: () => Iterator<TileTreeReference>;
    readonly update: () => void;
}

// @internal
export namespace SpatialTileTreeReferences {
    export function create(view: SpatialViewState): SpatialTileTreeReferences;
}

// @public
export class SpatialViewState extends ViewState3d {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, arg3: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // (undocumented)
    addViewedModel(id: Id64String): void;
    // @internal (undocumented)
    attachToViewport(): void;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    clearViewedModels(): void;
    computeFitRange(): AxisAlignedBox3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // @beta
    static createBlank(iModel: IModelConnection, origin: XYAndZ, extents: XYAndZ, rotation?: Matrix3d): SpatialViewState;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): SpatialViewState;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // (undocumented)
    get defaultExtentLimits(): {
        min: number;
        max: number;
    };
    // @internal (undocumented)
    detachFromViewport(): void;
    // (undocumented)
    equals(other: this): boolean;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    protected getDisplayedExtents(): AxisAlignedBox3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // @internal (undocumented)
    isSpatialView(): this is SpatialViewState;
    // (undocumented)
    load(): Promise<void>;
    // @internal (undocumented)
    markModelSelectorChanged(): void;
    // (undocumented)
    get modelSelector(): ModelSelectorState;
    set modelSelector(selector: ModelSelectorState);
    // @beta
    readonly onViewedModelsChanged: BeEvent<() => void>;
    // (undocumented)
    removeViewedModel(id: Id64String): void;
    // (undocumented)
    toJSON(): SpatialViewDefinitionProps;
    // (undocumented)
    toProps(): ViewStateProps;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export class Sprite {
    constructor(src: ImageSource | string);
    image?: HTMLImageElement;
    get isLoaded(): boolean;
    loadPromise: Promise<HTMLImageElement>;
    get offset(): Point2d;
    readonly size: Point2d;
}

// @public
export class SpriteLocation implements CanvasDecoration {
    activate(sprite: Sprite, viewport: ScreenViewport, locationWorld: XYAndZ, alpha?: number): void;
    deactivate(): void;
    decorate(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    get isActive(): boolean;
    readonly position: Point3d;
    }

// @public
export class StandardView {
    static adjustToStandardRotation(matrix: Matrix3d): void;
    // (undocumented)
    static get back(): Matrix3d;
    // (undocumented)
    static get bottom(): Matrix3d;
    // (undocumented)
    static get front(): Matrix3d;
    static getStandardRotation(id: StandardViewId): Matrix3d;
    // (undocumented)
    static get iso(): Matrix3d;
    // (undocumented)
    static get left(): Matrix3d;
    // (undocumented)
    static get right(): Matrix3d;
    // (undocumented)
    static get rightIso(): Matrix3d;
    // (undocumented)
    static get top(): Matrix3d;
}

// @public
export enum StandardViewId {
    // (undocumented)
    Back = 5,
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    Front = 4,
    // (undocumented)
    Iso = 6,
    // (undocumented)
    Left = 2,
    NotStandard = -1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    RightIso = 7,
    // (undocumented)
    Top = 0
}

// @public
export class StandardViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, _standardViewId: StandardViewId);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public (undocumented)
export enum StartOrResume {
    // (undocumented)
    Resume = 2,
    // (undocumented)
    Start = 1
}

// @alpha
export class Storage {
    constructor(id: string, _isOpen?: boolean);
    close(deleteIt?: boolean): Promise<void>;
    // @internal
    getData(key: string): Promise<StorageValue | undefined>;
    getKeys(): Promise<string[]>;
    // (undocumented)
    readonly id: string;
    get isOpen(): boolean;
    removeAll(): Promise<void>;
    removeData(key: string): Promise<void>;
    // @internal
    setData(key: string, value: StorageValue): Promise<void>;
}

// @internal
export class SubCategoriesCache {
    constructor(imodel: IModelConnection);
    // (undocumented)
    clear(): void;
    getSubCategories(categoryId: string): Id64Set | undefined;
    getSubCategoryAppearance(subCategoryId: Id64String): SubCategoryAppearance | undefined;
    load(categoryIds: Id64Arg): SubCategoriesRequest | undefined;
    // (undocumented)
    onIModelConnectionClose(): void;
    }

// @internal
export namespace SubCategoriesCache {
    export class Queue {
        // (undocumented)
        protected _current?: QueueEntry;
        dispose(): void;
        // (undocumented)
        protected _disposed: boolean;
        // (undocumented)
        get isEmpty(): boolean;
        // (undocumented)
        protected _next?: QueueEntry;
        push(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void;
        // (undocumented)
        protected _request?: SubCategoriesRequest;
    }
    // (undocumented)
    export class QueueEntry {
        constructor(categoryIds: Id64Set, func: QueueFunc);
        // (undocumented)
        readonly categoryIds: Id64Set;
        // (undocumented)
        readonly funcs: QueueFunc[];
    }
    // (undocumented)
    export type QueueFunc = () => void;
    // (undocumented)
    export class Request {
        constructor(categoryIds: Set<string>, imodel: IModelConnection, maxCategoriesPerQuery?: number);
        // (undocumented)
        cancel(): void;
        // (undocumented)
        dispatch(): Promise<Result | undefined>;
        // (undocumented)
        get wasCanceled(): boolean;
    }
    // (undocumented)
    export type Result = ResultRow[];
    // (undocumented)
    export interface ResultRow {
        // (undocumented)
        appearance: SubCategoryAppearance.Props;
        // (undocumented)
        id: Id64String;
        // (undocumented)
        parentId: Id64String;
    }
}

// @internal
export interface SubCategoriesRequest {
    cancel(): void;
    readonly missingCategoryIds: Id64Set;
    readonly promise: Promise<boolean>;
}

// @beta
export class SurveyLengthDescription extends FormattedQuantityDescription {
    constructor(name?: string, displayLabel?: string, iconSpec?: string);
    // (undocumented)
    get formatterQuantityType(): QuantityType;
    // (undocumented)
    get parseError(): string;
    // (undocumented)
    get quantityType(): string;
}

// @internal (undocumented)
export class SuspendedToolState {
    constructor();
    // (undocumented)
    stop(): void;
    }

// @internal (undocumented)
export abstract class Target extends RenderTarget implements RenderTargetDebugControl, WebGLDisposable {
    protected constructor(rect?: ViewRect);
    // (undocumented)
    activeVolumeClassifierModelId?: Id64String;
    // (undocumented)
    activeVolumeClassifierProps?: SpatialClassificationProps.Classifier;
    // (undocumented)
    activeVolumeClassifierTexture?: WebGLTexture;
    // (undocumented)
    addBatch(batch: Batch): void;
    // (undocumented)
    protected allocateFbo(): FrameBuffer | undefined;
    // (undocumented)
    ambientOcclusionSettings: AmbientOcclusion.Settings;
    // (undocumented)
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    // (undocumented)
    analysisStyle?: AnalysisStyle;
    // (undocumented)
    analysisTexture?: RenderTexture;
    // (undocumented)
    get animationBranches(): AnimationBranchStates | undefined;
    set animationBranches(branches: AnimationBranchStates | undefined);
    // (undocumented)
    get antialiasSamples(): number;
    set antialiasSamples(numSamples: number);
    // (undocumented)
    protected abstract _assignDC(): boolean;
    // (undocumented)
    protected abstract _beginPaint(fbo: FrameBuffer): void;
    // (undocumented)
    beginPerfMetricFrame(sceneMilSecElapsed?: number, readPixels?: boolean): void;
    // (undocumented)
    beginPerfMetricRecord(operation: string, readPixels?: boolean): void;
    // (undocumented)
    changeDecorations(decs: Decorations): void;
    // (undocumented)
    changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    changeFrustum(newFrustum: Frustum, newFraction: number, is3d: boolean): void;
    // (undocumented)
    changePlanarClassifiers(planarClassifiers?: PlanarClassifierMap): void;
    // (undocumented)
    changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    changeScene(scene: Scene): void;
    // (undocumented)
    changeTextureDrapes(textureDrapes: TextureDrapeMap | undefined): void;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    get compositor(): SceneCompositor;
    // (undocumented)
    protected _compositor: SceneCompositor;
    // (undocumented)
    computeEdgeColor(baseColor: ColorInfo): ColorInfo;
    // (undocumented)
    computeEdgeLineCode(pass: RenderPass, baseCode: number): number;
    // (undocumented)
    computeEdgeWeight(pass: RenderPass, baseWeight: number): number;
    // (undocumented)
    copyImageToCanvas(): HTMLCanvasElement;
    // (undocumented)
    createPlanarClassifier(properties?: SpatialClassificationProps.Classifier): PlanarClassifier;
    // (undocumented)
    protected cssViewRectToDeviceViewRect(rect: ViewRect): ViewRect;
    // (undocumented)
    get currentBranch(): BranchState;
    // (undocumented)
    get currentClipVolume(): ClipVolume | undefined;
    // (undocumented)
    get currentEdgeSettings(): EdgeSettings;
    // (undocumented)
    get currentFeatureSymbologyOverrides(): FeatureSymbology.Overrides;
    // (undocumented)
    get currentlyDrawingClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifier(): PlanarClassifier | undefined;
    // (undocumented)
    get currentPlanarClassifierOrDrape(): PlanarClassifier | TextureDrape | undefined;
    // (undocumented)
    get currentTextureDrape(): TextureDrape | undefined;
    // (undocumented)
    get currentTransform(): Transform;
    // (undocumented)
    get currentTransparencyThreshold(): number;
    // (undocumented)
    get currentViewFlags(): ViewFlags;
    // (undocumented)
    get debugControl(): RenderTargetDebugControl;
    // (undocumented)
    readonly decorationsState: BranchState;
    // (undocumented)
    displayDrapeFrustum: boolean;
    // (undocumented)
    displayRealityTilePreload: boolean;
    // (undocumented)
    displayRealityTileRanges: boolean;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected disposeFbo(): void;
    // (undocumented)
    drawForReadPixels: boolean;
    // (undocumented)
    drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    drawingBackgroundForReadPixels: boolean;
    // (undocumented)
    get drawNonLocatable(): boolean;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    drawPlanarClassifiers(): void;
    // (undocumented)
    drawSolarShadowMap(): void;
    // (undocumented)
    drawTextureDrapes(): void;
    // (undocumented)
    protected abstract _endPaint(): void;
    // (undocumented)
    endPerfMetricFrame(readPixels?: boolean): void;
    // (undocumented)
    endPerfMetricRecord(readPixels?: boolean): void;
    // (undocumented)
    get flashed(): Id64.Uint32Pair | undefined;
    // (undocumented)
    get flashedId(): Id64String;
    // (undocumented)
    get flashIntensity(): number;
    // (undocumented)
    freezeRealityTiles: boolean;
    // (undocumented)
    getPlanarClassifier(id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getTextureDrape(id: Id64String): RenderTextureDrape | undefined;
    // (undocumented)
    getWorldDecorations(decs: GraphicList): Branch;
    // (undocumented)
    readonly graphics: TargetGraphics;
    // (undocumented)
    get hilites(): Hilites;
    // (undocumented)
    get hiliteSyncTarget(): SyncTarget;
    // (undocumented)
    get is2d(): boolean;
    // (undocumented)
    get is3d(): boolean;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    get isDrawingShadowMap(): boolean;
    // (undocumented)
    isFadeOutActive: boolean;
    // (undocumented)
    isGeometryOutsideActiveVolume(geom: CachedGeometry): boolean;
    // (undocumented)
    isRangeOutsideActiveVolume(range: Range3d): boolean;
    // (undocumented)
    get isReadPixelsInProgress(): boolean;
    // (undocumented)
    logRealityTiles: boolean;
    // (undocumented)
    modelToView(modelPt: XYZ, result?: Point3d): Point3d;
    // (undocumented)
    nonLocatableTerrain: boolean;
    // (undocumented)
    onBatchDisposed(batch: Batch): void;
    // (undocumented)
    onBeforeRender(viewport: Viewport, setSceneNeedRedraw: (redraw: boolean) => void): void;
    // (undocumented)
    overrideFeatureSymbology(ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    performanceMetrics?: PerformanceMetrics;
    // (undocumented)
    plan: RenderPlan;
    // (undocumented)
    get planFraction(): number;
    // (undocumented)
    get planFrustum(): Frustum;
    // (undocumented)
    popBatch(): void;
    // (undocumented)
    popBranch(): void;
    // (undocumented)
    popViewClip(): void;
    // (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // (undocumented)
    pushBatch(batch: Batch): void;
    // (undocumented)
    pushBranch(branch: Branch): void;
    // (undocumented)
    pushState(state: BranchState): void;
    // (undocumented)
    pushViewClip(): void;
    readImage(wantRectIn: ViewRect, targetSizeIn: Point2d, flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    protected readImagePixels(out: Uint8Array, x: number, y: number, w: number, h: number): boolean;
    // (undocumented)
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    get readPixelsSelector(): Pixel.Selector;
    // (undocumented)
    readonly renderRect: ViewRect;
    // (undocumented)
    get renderSystem(): System;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get screenSpaceEffectContext(): ScreenSpaceEffectContext;
    // (undocumented)
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(effects: Iterable<string>);
    // (undocumented)
    setFlashed(id: Id64String, intensity: number): void;
    // (undocumented)
    setHiliteSet(hilite: HiliteSet): void;
    // (undocumented)
    get shadowFrustum(): Frustum | undefined;
    // (undocumented)
    get solarShadowMap(): SolarShadowMap;
    // (undocumented)
    get techniques(): Techniques;
    // (undocumented)
    terrainTransparency: number;
    // (undocumented)
    readonly uniforms: TargetUniforms;
    // (undocumented)
    updateSolarShadows(context: SceneContext | undefined): void;
    // (undocumented)
    vcSupportIntersectingVolumes: boolean;
    // (undocumented)
    get viewRect(): ViewRect;
    // (undocumented)
    get wantAmbientOcclusion(): boolean;
    // (undocumented)
    get wantInvertBlackBackground(): boolean;
    // (undocumented)
    get wantThematicDisplay(): boolean;
    // (undocumented)
    get wantThematicSensors(): boolean;
    }

// @internal (undocumented)
export class TentativeOrAccuSnap {
    // (undocumented)
    static getCurrentPoint(): Point3d;
    // (undocumented)
    static getCurrentSnap(checkIsHot?: boolean): SnapDetail | undefined;
    // (undocumented)
    static getCurrentView(): ScreenViewport | undefined;
    // (undocumented)
    static get isHot(): boolean;
}

// @public (undocumented)
export class TentativePoint {
    // (undocumented)
    clear(doErase: boolean): void;
    // (undocumented)
    currSnap?: SnapDetail;
    // (undocumented)
    decorate(context: DecorateContext): void;
    getCurrSnap(): SnapDetail | undefined;
    // (undocumented)
    getHitAndList(holder: HitListHolder): SnapDetail | undefined;
    // (undocumented)
    getPoint(): Point3d;
    // (undocumented)
    isActive: boolean;
    get isSnapped(): boolean;
    // (undocumented)
    onButtonEvent(ev: BeButtonEvent): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    process(ev: BeButtonEvent): void;
    // (undocumented)
    removeTentative(): void;
    // (undocumented)
    setCurrSnap(newSnap?: SnapDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    setPoint(point: Point3d): void;
    // (undocumented)
    showTentative(): void;
    // (undocumented)
    tpHits?: HitList<HitDetail>;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal (undocumented)
export class TerrainDisplayOverrides {
    // (undocumented)
    wantNormals?: boolean;
    // (undocumented)
    wantSkirts?: boolean;
}

// @internal
export abstract class TerrainMeshProvider {
    constructor(_iModel: IModelConnection, _modelId: Id64String);
    // (undocumented)
    constructUrl(_row: number, _column: number, _zoomLevel: number): string;
    // (undocumented)
    forceTileLoad(_tile: Tile): boolean;
    // (undocumented)
    abstract getChildHeightRange(_quadId: QuadId, _rectangle: MapCartoRectangle, _parent: MapTile): Range1d | undefined;
    // (undocumented)
    getLogo(): HTMLTableRowElement | undefined;
    // (undocumented)
    getMesh(_tile: MapTile, _data: Uint8Array): Promise<TerrainMeshPrimitive | undefined>;
    // (undocumented)
    protected _iModel: IModelConnection;
    // (undocumented)
    abstract isTileAvailable(quadId: QuadId): boolean;
    // (undocumented)
    abstract get maxDepth(): number;
    // (undocumented)
    protected _modelId: Id64String;
    // (undocumented)
    get requestOptions(): RequestOptions;
    // (undocumented)
    get requiresLoadedContent(): boolean;
    // (undocumented)
    abstract get tilingScheme(): MapTilingScheme;
}

// @internal (undocumented)
export class TerrainTexture {
    constructor(texture: RenderTexture, featureId: number, scale: Vector2d, translate: Vector2d, targetRectangle: Range2d, layerIndex: number, transparency: number, clipRectangle?: Range2d | undefined);
    // (undocumented)
    readonly clipRectangle?: Range2d | undefined;
    // (undocumented)
    featureId: number;
    // (undocumented)
    readonly layerIndex: number;
    // (undocumented)
    readonly scale: Vector2d;
    // (undocumented)
    readonly targetRectangle: Range2d;
    // (undocumented)
    readonly texture: RenderTexture;
    // (undocumented)
    readonly translate: Vector2d;
    // (undocumented)
    transparency: number;
}

// @internal (undocumented)
export interface TerrainTileContent extends TileContent {
    // (undocumented)
    terrain?: {
        geometry?: RenderTerrainMeshGeometry;
        mesh?: TerrainMeshPrimitive;
    };
}

// @alpha
export interface TextInputFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "text";
    // (undocumented)
    getString: (props: FormatProps) => string;
    // (undocumented)
    setString: (props: FormatProps, value: string) => FormatProps;
}

// @alpha
export interface TextSelectFormatPropEditorSpec extends CustomFormatPropEditorSpec {
    // (undocumented)
    editorType: "select";
    // (undocumented)
    getString: (props: FormatProps) => string;
    // (undocumented)
    selectOptions: {
        label: string;
        value: string;
    }[];
    // (undocumented)
    setString: (props: FormatProps, value: string) => FormatProps;
}

// @internal (undocumented)
export type TextureDrapeMap = Map<Id64String, RenderTextureDrape>;

// @internal
export interface TextureImage {
    format: ImageSourceFormat | undefined;
    image: HTMLImageElement | undefined;
}

// @internal (undocumented)
export class ThreeAxes {
    // (undocumented)
    clone(): ThreeAxes;
    // (undocumented)
    static createFromMatrix3d(rMatrix: Matrix3d, result?: ThreeAxes): ThreeAxes;
    // (undocumented)
    equals(other: ThreeAxes): boolean;
    // (undocumented)
    fromMatrix3d(rMatrix: Matrix3d): void;
    // (undocumented)
    setFrom(other: ThreeAxes): void;
    // (undocumented)
    toMatrix3d(out?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly x: Vector3d;
    // (undocumented)
    readonly y: Vector3d;
    // (undocumented)
    readonly z: Vector3d;
}

// @beta
export abstract class Tile {
    protected constructor(params: TileParams, tree: TileTree);
    // @internal (undocumented)
    protected addRangeGraphic(builder: GraphicBuilder, type: TileBoundingBoxes): void;
    // @internal
    bytesUsed: number;
    readonly center: Point3d;
    abstract get channel(): TileRequestChannel;
    get children(): Tile[] | undefined;
    protected _childrenLoadStatus: TileTreeLoadStatus;
    // @internal
    collectStatistics(stats: RenderMemory.Statistics, includeChildren?: boolean): void;
    // @internal
    protected _collectStatistics(_stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    computeLoadPriority(_viewports: Iterable<Viewport>): number;
    computeVisibility(args: TileDrawArgs): TileVisibility;
    get contentId(): string;
    protected _contentId: string;
    get contentRange(): ElementAlignedBox3d;
    // @internal (undocumented)
    protected _contentRange?: ElementAlignedBox3d;
    // @internal (undocumented)
    countDescendants(): number;
    readonly depth: number;
    dispose(): void;
    protected disposeChildren(): void;
    disposeContents(): void;
    drawGraphics(args: TileDrawArgs): void;
    // @internal (undocumented)
    extendRangeForContent(range: Range3d, matrix: Matrix4d, treeTransform: Transform, frustumPlanes?: FrustumPlanes): void;
    // @alpha
    freeMemory(): void;
    // @internal (undocumented)
    getRangeGraphic(context: SceneContext): RenderGraphic | undefined;
    // @internal
    getSizeProjectionCorners(): Point3d[] | undefined;
    protected _graphic?: RenderGraphic;
    protected _hadGraphics: boolean;
    get hasContentRange(): boolean;
    get hasGraphics(): boolean;
    get iModel(): IModelConnection;
    protected isContentCulled(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    get isDisplayable(): boolean;
    // @internal (undocumented)
    get isEmpty(): boolean;
    get isLeaf(): boolean;
    // @internal (undocumented)
    protected _isLeaf: boolean;
    get isLoading(): boolean;
    get isNotFound(): boolean;
    // @internal (undocumented)
    get isParentDisplayable(): boolean;
    get isQueued(): boolean;
    get isReady(): boolean;
    protected isRegionCulled(args: TileDrawArgs): boolean;
    // @internal (undocumented)
    get isUndisplayableRootTile(): boolean;
    protected loadChildren(): TileTreeLoadStatus;
    protected abstract _loadChildren(resolve: (children: Tile[] | undefined) => void, reject: (error: Error) => void): void;
    get loadStatus(): TileLoadStatus;
    get maximumSize(): number;
    protected _maximumSize: number;
    // @internal
    next?: LRUTileListNode;
    readonly parent: Tile | undefined;
    // @internal
    previous?: LRUTileListNode;
    produceGraphics(): RenderGraphic | undefined;
    readonly radius: number;
    readonly range: ElementAlignedBox3d;
    // @internal (undocumented)
    protected get rangeGraphicColor(): ColorDef;
    abstract readContent(data: TileRequest.ResponseData, system: RenderSystem, isCanceled?: () => boolean): Promise<TileContent>;
    // @internal (undocumented)
    get request(): TileRequest | undefined;
    set request(request: TileRequest | undefined);
    // @internal (undocumented)
    protected _request?: TileRequest;
    abstract requestContent(isCanceled: () => boolean): Promise<TileRequest.Response>;
    setContent(content: TileContent): void;
    // (undocumented)
    protected setGraphic(graphic: RenderGraphic | undefined): void;
    // @internal (undocumented)
    setIsReady(): void;
    // @internal (undocumented)
    setLeaf(): void;
    // @internal (undocumented)
    setNotFound(): void;
    readonly tree: TileTree;
    readonly usageMarker: TileUsageMarker;
    // @internal
    viewportIds?: ViewportIdSet;
}

// @beta
export class TileAdmin {
    // @internal
    constructor(isMobile: boolean, rpcConcurrency: number | undefined, options?: TileAdmin.Props);
    // @internal
    addExternalTilesForViewport(vp: Viewport, statistics: ExternalTileStatistics): void;
    // @internal
    addLoadListener(callback: (imodel: IModelConnection) => void): () => void;
    // @internal
    addTilesForViewport(vp: Viewport, selected: Tile[], ready: Set<Tile>): void;
    // @internal (undocumented)
    readonly alwaysRequestEdges: boolean;
    // @internal (undocumented)
    readonly alwaysSubdivideIncompleteTiles: boolean;
    // (undocumented)
    readonly channels: TileRequestChannels;
    // @internal
    clearTilesForViewport(vp: Viewport): void;
    // @internal
    clearUsageForViewport(vp: Viewport): void;
    // @internal (undocumented)
    readonly contextPreloadParentDepth: number;
    // @internal (undocumented)
    readonly contextPreloadParentSkip: number;
    static create(props?: TileAdmin.Props): Promise<TileAdmin>;
    get defaultTileSizeModifier(): number;
    set defaultTileSizeModifier(modifier: number);
    // @internal (undocumented)
    readonly disableMagnification: boolean;
    // @internal (undocumented)
    get emptyViewportSet(): ReadonlyViewportSet;
    // @internal (undocumented)
    readonly enableExternalTextures: boolean;
    // @internal (undocumented)
    readonly enableImprovedElision: boolean;
    // @internal (undocumented)
    get enableInstancing(): boolean;
    // @internal (undocumented)
    forEachViewport(func: (vp: Viewport) => void): void;
    // @internal
    forgetViewport(vp: Viewport): void;
    // @internal
    freeMemory(): void;
    // @internal (undocumented)
    generateTileContent(tile: IModelTile): Promise<Uint8Array>;
    getMaximumMajorTileFormatVersion(formatVersion?: number): number;
    getNumRequestsForViewport(vp: Viewport): number;
    // @internal
    getRequestsForViewport(vp: Viewport): Set<Tile> | undefined;
    // @internal
    getTilesForViewport(vp: Viewport): SelectedAndReadyTiles | undefined;
    // @internal
    getViewportSetForRequest(vp: Viewport, vps?: ReadonlyViewportSet): ReadonlyViewportSet;
    get gpuMemoryLimit(): GpuMemoryLimit;
    set gpuMemoryLimit(limit: GpuMemoryLimit);
    // @internal (undocumented)
    readonly ignoreAreaPatterns: boolean;
    // @internal (undocumented)
    invalidateAllScenes(): void;
    // @internal
    isTileInUse(marker: TileUsageMarker): boolean;
    // @internal
    markTileUsedByViewport(marker: TileUsageMarker, vp: Viewport): void;
    // @internal (undocumented)
    readonly maximumLevelsToSkip: number;
    // @internal (undocumented)
    readonly maximumMajorTileFormatVersion: number;
    get maxTotalTileContentBytes(): number | undefined;
    // @internal (undocumented)
    readonly minimumSpatialTolerance: number;
    // @internal (undocumented)
    readonly mobileRealityTileMinToleranceRatio: number;
    // @internal (undocumented)
    onShutDown(): void;
    // @internal
    readonly onTileChildrenLoad: BeEvent<(parentTile: Tile) => void>;
    // @internal
    onTileContentDisposed(tile: Tile): void;
    // @internal
    onTileContentLoaded(tile: Tile): void;
    // @internal
    readonly onTileLoad: BeEvent<(tile: Tile) => void>;
    // @internal (undocumented)
    onTilesElided(numElided: number): void;
    // @internal
    readonly onTileTreeLoad: BeEvent<(tileTree: TileTreeOwner) => void>;
    // @internal
    process(): void;
    // @internal
    purgeTileTrees(iModel: IModelConnection, modelIds: Id64Array | undefined): Promise<void>;
    // @internal
    registerViewport(vp: Viewport): void;
    // @internal (undocumented)
    requestCachedTileContent(tile: IModelTile): Promise<Uint8Array | undefined>;
    // @internal (undocumented)
    requestElementGraphics(iModel: IModelConnection, requestProps: ElementGraphicsRequestProps): Promise<Uint8Array | undefined>;
    // @internal
    requestTiles(vp: Viewport, tiles: Set<Tile>): void;
    // @internal (undocumented)
    requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<IModelTileTreeProps>;
    resetStatistics(): void;
    // @alpha
    get selectedLoadedTiles(): Iterable<Tile>;
    get statistics(): TileAdmin.Statistics;
    // @internal (undocumented)
    terminateTileTreePropsRequest(request: TileTreePropsRequest): void;
    // @internal (undocumented)
    readonly tileExpirationTime: BeDuration;
    // @internal (undocumented)
    readonly tileTreeExpirationTime: BeDuration;
    get totalTileContentBytes(): number;
    // @alpha
    get unselectedLoadedTiles(): Iterable<Tile>;
    // @internal (undocumented)
    readonly useProjectExtents: boolean;
    }

// @beta (undocumented)
export namespace TileAdmin {
    export interface Props {
        alwaysRequestEdges?: boolean;
        // @internal
        alwaysSubdivideIncompleteTiles?: boolean;
        // @alpha
        contextPreloadParentDepth?: number;
        // @alpha
        contextPreloadParentSkip?: number;
        defaultTileSizeModifier?: number;
        // @alpha
        disableMagnification?: boolean;
        enableExternalTextures?: boolean;
        enableImprovedElision?: boolean;
        enableInstancing?: boolean;
        gpuMemoryLimits?: GpuMemoryLimit | GpuMemoryLimits;
        // @alpha
        ignoreAreaPatterns?: boolean;
        // @internal
        ignoreMinimumExpirationTimes?: boolean;
        // @alpha
        maxActiveTileTreePropsRequests?: number;
        // @alpha
        maximumLevelsToSkip?: number;
        // @internal
        maximumMajorTileFormatVersion?: number;
        // @alpha
        minimumSpatialTolerance?: number;
        // @alpha
        mobileRealityTileMinToleranceRatio?: number;
        // @alpha
        retryInterval?: number;
        tileExpirationTime?: number;
        // @alpha
        tileTreeExpirationTime?: number;
        // @internal
        useProjectExtents?: boolean;
    }
    export interface Statistics {
        numActiveRequests: number;
        numActiveTileTreePropsRequests: number;
        numCanceled: number;
        numPendingRequests: number;
        numPendingTileTreePropsRequests: number;
        totalAbortedRequests: number;
        totalCacheMisses: number;
        totalCompletedRequests: number;
        totalDispatchedRequests: number;
        totalElidedTiles: number;
        totalEmptyTiles: number;
        totalFailedRequests: number;
        totalTimedOutRequests: number;
        totalUndisplayableTiles: number;
    }
    const nonMobileGpuMemoryLimits: {
        default: number;
        aggressive: number;
        relaxed: number;
    };
    const mobileGpuMemoryLimits: {
        default: number;
        aggressive: number;
        relaxed: number;
    };
}

// @internal (undocumented)
export class TileAvailability {
    constructor(_tilingScheme: MapTilingScheme, _maximumLevel: number);
    addAvailableTileRange(level: number, startX: number, startY: number, endX: number, endY: number): void;
    // (undocumented)
    computeMaximumLevelAtPosition(position: Cartographic): number;
    // (undocumented)
    findNode(level: number, x: number, y: number, nodes: QuadTreeNode[]): boolean;
    isTileAvailable(level: number, x: number, y: number): boolean;
    // (undocumented)
    static rectangleScratch: MapCartoRectangle;
    }

// @internal
export enum TileBoundingBoxes {
    Both = 3,
    ChildVolumes = 4,
    Content = 2,
    None = 0,
    Sphere = 5,
    Volume = 1
}

// @beta
export interface TileContent {
    contentRange?: ElementAlignedBox3d;
    graphic?: RenderGraphic;
    isLeaf?: boolean;
}

// @beta
export interface TiledGraphicsProvider {
    addToScene?: (context: SceneContext) => void;
    forEachTileTreeRef(viewport: Viewport, func: (ref: TileTreeReference) => void): void;
}

// @beta
export interface TileDrawArgParams {
    // (undocumented)
    appearanceProvider?: FeatureAppearanceProvider;
    // (undocumented)
    clipVolume?: RenderClipVolume;
    // (undocumented)
    context: SceneContext;
    // (undocumented)
    hiddenLineSettings?: HiddenLine.Settings;
    // (undocumented)
    intersectionClip?: ClipVector;
    // (undocumented)
    location: Transform;
    // (undocumented)
    now: BeTimePoint;
    // (undocumented)
    parentsAndChildrenExclusive: boolean;
    // (undocumented)
    symbologyOverrides: FeatureSymbology.Overrides | undefined;
    // (undocumented)
    tree: TileTree;
    // (undocumented)
    viewFlagOverrides: ViewFlagOverrides;
}

// @beta
export class TileDrawArgs {
    constructor(params: TileDrawArgParams);
    addAppearanceProvider(provider: FeatureAppearanceProvider): void;
    // @internal (undocumented)
    get appearanceProvider(): FeatureAppearanceProvider | undefined;
    // @internal (undocumented)
    get clip(): ClipVector | undefined;
    clipVolume: RenderClipVolume | undefined;
    protected computePixelSizeInMetersAtClosestPoint(center: Point3d, radius: number): number;
    readonly context: SceneContext;
    // @internal (undocumented)
    drape?: RenderTextureDrape;
    // @internal (undocumented)
    drawGraphics(): void;
    // @internal (undocumented)
    drawGraphicsWithType(graphicType: TileGraphicType, graphics: GraphicBranch): void;
    get frustumPlanes(): FrustumPlanes;
    protected _frustumPlanes?: FrustumPlanes;
    getPixelSize(tile: Tile): number;
    getPixelSizeInMetersAtClosestPoint(tile: Tile): number;
    getRangePixelSize(range: Range3d): number;
    // @internal (undocumented)
    getTileCenter(tile: Tile): Point3d;
    // @internal (undocumented)
    getTileGraphics(tile: Tile): RenderGraphic | undefined;
    // @internal (undocumented)
    getTileRadius(tile: Tile): number;
    readonly graphics: GraphicBranch;
    hiddenLineSettings?: HiddenLine.Settings;
    insertMissing(tile: Tile): void;
    intersectionClip?: ClipVector;
    readonly location: Transform;
    // @internal (undocumented)
    markChildrenLoading(): void;
    markReady(tile: Tile): void;
    markUsed(tile: Tile): void;
    // (undocumented)
    get maxRealityTreeSelectionCount(): number | undefined;
    // @internal (undocumented)
    readonly now: BeTimePoint;
    // @internal (undocumented)
    parentsAndChildrenExclusive: boolean;
    // @internal (undocumented)
    planarClassifier?: RenderPlanarClassifier;
    // @internal
    processSelectedTiles(_tiles: Tile[]): void;
    // @internal (undocumented)
    produceGraphics(): RenderGraphic | undefined;
    readonly readyTiles: Set<Tile>;
    get symbologyOverrides(): FeatureSymbology.Overrides | undefined;
    // @alpha
    get tileSizeModifier(): number;
    readonly tree: TileTree;
    readonly viewClip?: ClipVector;
    get viewFlagOverrides(): ViewFlagOverrides;
    viewingSpace: ViewingSpace;
    // @internal (undocumented)
    get worldToViewMap(): Map4d;
}

// @beta
export enum TileGraphicType {
    BackgroundMap = 0,
    Overlay = 2,
    Scene = 1
}

// @beta
export enum TileLoadPriority {
    Classifier = 50,
    Context = 40,
    Dynamic = 5,
    Map = 15,
    Primary = 20,
    Terrain = 10
}

// @beta
export enum TileLoadStatus {
    Abandoned = 5,
    Loading = 2,
    NotFound = 4,
    NotLoaded = 0,
    Queued = 1,
    Ready = 3
}

// @beta
export interface TileParams {
    contentId: string;
    contentRange?: ElementAlignedBox3d;
    isLeaf?: boolean;
    maximumSize: number;
    parent?: Tile;
    range: ElementAlignedBox3d;
}

// @internal (undocumented)
export type TilePatch = PlanarTilePatch | EllipsoidPatch;

// @beta
export class TileRequest {
    constructor(tile: Tile, vp: Viewport);
    addViewport(vp: Viewport): void;
    cancel(): void;
    readonly channel: TileRequestChannel;
    dispatch(onHttpResponse: () => void): Promise<void>;
    get isCanceled(): boolean;
    // @internal (undocumented)
    get isQueued(): boolean;
    priority: number;
    // @internal (undocumented)
    get state(): TileRequest.State;
    readonly tile: Tile;
    // @internal (undocumented)
    get tree(): TileTree;
    viewports: ReadonlyViewportSet;
}

// @beta (undocumented)
export namespace TileRequest {
    export type Response = Uint8Array | ArrayBuffer | string | ImageSource | undefined;
    export type ResponseData = Uint8Array | ImageSource;
    // @internal
    export enum State {
        Completed = 3,
        Dispatched = 1,
        Failed = 4,
        Loading = 2,
        Queued = 0
    }
}

// @beta
export class TileRequestChannel {
    constructor(name: string, concurrency: number);
    // @internal
    protected readonly _active: Set<TileRequest>;
    // @internal
    append(request: TileRequest): void;
    // @internal
    protected cancel(request: TileRequest): void;
    // @internal
    cancelAndClearAll(): void;
    get concurrency(): number;
    set concurrency(max: number);
    // @internal
    protected dispatch(request: TileRequest): void;
    // @internal
    protected dropActiveRequest(request: TileRequest): void;
    readonly name: string;
    get numActive(): number;
    get numPending(): number;
    onActiveRequestCanceled(_request: TileRequest): void;
    onIModelClosed(_iModel: IModelConnection): void;
    onNoContent(_request: TileRequest): boolean;
    // @internal
    process(): void;
    processCancellations(): void;
    // @internal
    recordCompletion(tile: Tile): void;
    // @internal
    recordFailure(): void;
    // @internal
    recordTimeout(): void;
    requestContent(tile: Tile, isCanceled: () => boolean): Promise<TileRequest.Response>;
    resetStatistics(): void;
    get size(): number;
    get statistics(): Readonly<TileRequestChannelStatistics>;
    // (undocumented)
    protected _statistics: TileRequestChannelStatistics;
    // @internal
    swapPending(): void;
}

// @beta
export class TileRequestChannels {
    [Symbol.iterator](): Iterator<TileRequestChannel>;
    // @internal
    constructor(rpcConcurrency: number | undefined);
    add(channel: TileRequestChannel): void;
    // @internal
    get cloudStorageCache(): TileRequestChannel | undefined;
    readonly elementGraphicsRpc: TileRequestChannel;
    // @internal
    enableCloudStorageCache(): void;
    get(name: string): TileRequestChannel | undefined;
    getForHttp(name: string): TileRequestChannel;
    static getNameFromUrl(url: URL | string): string;
    has(channel: TileRequestChannel): boolean;
    readonly httpConcurrency = 6;
    // @internal (undocumented)
    readonly iModelTileRpc: TileRequestChannel;
    // @internal
    onIModelClosed(iModel: IModelConnection): void;
    // @internal
    onShutDown(): void;
    // @internal
    process(): void;
    resetStatistics(): void;
    get rpcConcurrency(): number;
    // @internal
    setRpcConcurrency(concurrency: number): void;
    get size(): number;
    get statistics(): TileRequestChannelStatistics;
    // @internal
    swapPending(): void;
}

// @beta
export class TileRequestChannelStatistics {
    // @internal (undocumented)
    addTo(stats: TileRequestChannelStatistics): void;
    numActiveRequests: number;
    numCanceled: number;
    numPendingRequests: number;
    totalAbortedRequests: number;
    totalCacheMisses: number;
    totalCompletedRequests: number;
    totalDispatchedRequests: number;
    totalEmptyTiles: number;
    totalFailedRequests: number;
    totalTimedOutRequests: number;
    totalUndisplayableTiles: number;
}

// @beta
export class Tiles {
    constructor(iModel: IModelConnection);
    // @internal (undocumented)
    dispose(): void;
    dropSupplier(supplier: TileTreeSupplier): void;
    forEachTreeOwner(func: (owner: TileTreeOwner) => void): void;
    getTileTreeOwner(id: any, supplier: TileTreeSupplier): TileTreeOwner;
    getTreeOwnersForSupplier(supplier: TileTreeSupplier): Iterable<{
        id: any;
        owner: TileTreeOwner;
    }>;
    // @internal (undocumented)
    get isDisposed(): boolean;
    // @internal (undocumented)
    onEcefChanged(): void;
    purge(olderThan: BeTimePoint, exclude?: Set<TileTree>): void;
    // @internal (undocumented)
    purgeTileTrees(modelIds: Id64Array | undefined): Promise<void>;
    // @internal
    reset(): void;
    }

// @beta
export abstract class TileTree {
    protected constructor(params: TileTreeParams);
    // @internal (undocumented)
    accumulateTransformedRange(range: Range3d, matrix: Matrix4d, location: Transform, frustumPlanes?: FrustumPlanes): void;
    // @internal (undocumented)
    get clipVolume(): RenderClipVolume | undefined;
    // @internal (undocumented)
    protected _clipVolume?: RenderClipVolume;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    readonly contentRange?: ElementAlignedBox3d;
    countTiles(): number;
    dispose(): void;
    abstract draw(args: TileDrawArgs): void;
    readonly expirationTime: BeDuration;
    readonly id: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    readonly iModelTransform: Transform;
    get is2d(): boolean;
    abstract get is3d(): boolean;
    get isContentUnbounded(): boolean;
    get isDisposed(): boolean;
    // @internal (undocumented)
    get isPointCloud(): boolean;
    // @internal (undocumented)
    protected _lastSelected: BeTimePoint;
    // @internal (undocumented)
    get lastSelectedTime(): BeTimePoint;
    // @internal (undocumented)
    get loadPriority(): TileLoadPriority;
    abstract get maxDepth(): number | undefined;
    // @internal (undocumented)
    readonly modelId: Id64String;
    // @internal (undocumented)
    get parentsAndChildrenExclusive(): boolean;
    abstract prune(): void;
    get range(): ElementAlignedBox3d;
    abstract get rootTile(): Tile;
    selectTiles(args: TileDrawArgs): Tile[];
    protected abstract _selectTiles(args: TileDrawArgs): Tile[];
    abstract get viewFlagOverrides(): ViewFlagOverrides;
}

// @beta
export interface TileTreeDiscloser {
    discloseTileTrees: (trees: DisclosedTileTreeSet) => void;
}

// @beta
export enum TileTreeLoadStatus {
    Loaded = 2,
    Loading = 1,
    NotFound = 3,
    NotLoaded = 0
}

// @beta
export interface TileTreeOwner {
    // @internal
    dispose(): void;
    readonly iModel: IModelConnection;
    load(): TileTree | undefined;
    readonly loadStatus: TileTreeLoadStatus;
    loadTree(): Promise<TileTree | undefined>;
    readonly tileTree: TileTree | undefined;
}

// @beta
export interface TileTreeParams {
    clipVolume?: RenderClipVolume;
    contentRange?: ElementAlignedBox3d;
    expirationTime?: BeDuration;
    id: string;
    iModel: IModelConnection;
    location: Transform;
    modelId: Id64String;
    priority: TileLoadPriority;
}

// @beta
export abstract class TileTreeReference {
    // (undocumented)
    accumulateTransformedRange(range: Range3d, matrix: Matrix4d, frustumPlanes?: FrustumPlanes): void;
    addLogoCards(_cards: HTMLTableElement, _vp: ScreenViewport): void;
    addToScene(context: SceneContext): void;
    get castsShadows(): boolean;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    protected computeTransform(tree: TileTree): Transform;
    computeWorldContentRange(): ElementAlignedBox3d;
    createDrawArgs(context: SceneContext): TileDrawArgs | undefined;
    decorate(_context: DecorateContext): void;
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    draw(args: TileDrawArgs): void;
    protected getAppearanceProvider(_tree: TileTree): FeatureAppearanceProvider | undefined;
    protected getClipVolume(tree: TileTree): RenderClipVolume | undefined;
    protected getHiddenLineSettings(_tree: TileTree): HiddenLine.Settings | undefined;
    getLocation(): Transform | undefined;
    protected getSymbologyOverrides(_tree: TileTree): FeatureSymbology.Overrides | undefined;
    // @internal (undocumented)
    getTerrainHeight(_terrainHeights: Range1d): void;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string | undefined>;
    protected getViewFlagOverrides(tree: TileTree): ViewFlagOverrides;
    get isGlobal(): boolean;
    // @internal
    get isLoadingComplete(): boolean;
    // @internal
    protected get _isLoadingComplete(): boolean;
    get planarclipMaskPriority(): number;
    abstract get treeOwner(): TileTreeOwner;
    unionFitRange(union: Range3d): void;
}

// @beta
export interface TileTreeSupplier {
    compareTileTreeIds(lhs: any, rhs: any): number;
    createTileTree(id: any, iModel: IModelConnection): Promise<TileTree | undefined>;
    readonly isEcefDependent?: true;
}

// @internal
export class TileUrlImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, level: number): Promise<string>;
    // (undocumented)
    static validateUrlTemplate(template: string): MapLayerSourceValidation;
}

// @beta
export class TileUsageMarker {
    constructor();
    isExpired(expirationTime: BeTimePoint): boolean;
    mark(vp: Viewport, time: BeTimePoint): void;
    }

// @beta
export enum TileVisibility {
    OutsideFrustum = 0,
    TooCoarse = 1,
    Visible = 2
}

// @public
export class Tool {
    constructor(..._args: any[]);
    // @internal (undocumented)
    get ctor(): typeof Tool;
    static get description(): string;
    get description(): string;
    static get englishKeyin(): string;
    static get flyover(): string;
    get flyover(): string;
    static hidden: boolean;
    static i18n: I18N;
    static iconSpec: string;
    get iconSpec(): string;
    static get keyin(): string;
    get keyin(): string;
    static get maxArgs(): number | undefined;
    static get minArgs(): number;
    static namespace: I18NNamespace;
    parseAndRun(..._args: string[]): boolean;
    static register(namespace?: I18NNamespace, i18n?: I18N): void;
    run(..._args: any[]): boolean;
    static toolId: string;
    get toolId(): string;
}

// @public
export class ToolAdmin {
    acsContextLock: boolean;
    acsPlaneSnapLock: boolean;
    // @alpha
    readonly activeSettings: ToolAdmin.ActiveSettings;
    get activeTool(): InteractiveTool | undefined;
    readonly activeToolChanged: BeEvent<(tool: Tool, start: StartOrResume) => void>;
    // @internal
    static addEvent(ev: Event, vp?: ScreenViewport): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, projectToACS?: boolean, applyLocks?: boolean): void;
    // (undocumented)
    adjustPointToACS(pointActive: Point3d, vp: Viewport, perpendicular: boolean): void;
    // (undocumented)
    adjustPointToGrid(pointActive: Point3d, vp: Viewport): void;
    // (undocumented)
    adjustSnapPoint(perpendicular?: boolean): void;
    assemblyLock: boolean;
    // @internal (undocumented)
    beginDynamics(): void;
    // @beta
    bumpToolSetting(settingIndex?: number): Promise<boolean>;
    // @internal (undocumented)
    callOnCleanup(): void;
    convertTouchEndToButtonUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveStartToButtonDownAndMotion(startEv: BeTouchEvent, ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveToMotion(ev: BeTouchEvent): Promise<void>;
    convertTouchStartToButtonDown(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchTapToButtonDownAndUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    // @internal (undocumented)
    readonly currentInputState: CurrentInputState;
    get currentTool(): InteractiveTool;
    get cursorView(): ScreenViewport | undefined;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal
    get defaultToolArgs(): any[] | undefined;
    set defaultToolArgs(args: any[] | undefined);
    // @internal
    get defaultToolId(): string;
    set defaultToolId(toolId: string);
    // @beta
    dispatchImmediateUiSyncEvent(specificSyncEventId?: string, toolId?: string): void;
    // @beta
    dispatchUiSyncEvent(specificSyncEventId?: string, toolId?: string): void;
    doRedoOperation(): Promise<boolean>;
    doUndoOperation(): Promise<boolean>;
    // @internal (undocumented)
    endDynamics(): void;
    // @beta
    static exceptionHandler(exception: any): Promise<any>;
    // @beta
    static exceptionOptions: {
        log: boolean;
        alertBox: boolean;
        details: boolean;
        launchDebugger: boolean;
    };
    // @internal (undocumented)
    exitInputCollector(): void;
    // @internal (undocumented)
    exitViewTool(): void;
    // @internal (undocumented)
    fillEventFromCursorLocation(ev: BeButtonEvent): void;
    // @internal (undocumented)
    fillEventFromLastDataButton(ev: BeButtonEvent): void;
    protected filterViewport(vp: ScreenViewport): boolean;
    // @internal
    forgetViewport(vp: ScreenViewport): void;
    // @internal (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    gridLock: boolean;
    get idleTool(): IdleTool;
    // (undocumented)
    get isLocateCircleOn(): boolean;
    // @alpha
    readonly manipulatorToolEvent: BeEvent<(tool: Tool, event: ManipulatorToolEvent) => void>;
    // (undocumented)
    markupView?: ScreenViewport;
    onCtrlKeyPressed(keyEvent: KeyboardEvent): Promise<{
        handled: boolean;
        result: boolean;
    }>;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onInstallTool(tool: InteractiveTool): boolean;
    // @internal (undocumented)
    onMouseLeave(vp: ScreenViewport): void;
    // @internal (undocumented)
    onPostInstallTool(tool: InteractiveTool): void;
    // @internal (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // @internal (undocumented)
    onShutDown(): void;
    // (undocumented)
    get primitiveTool(): PrimitiveTool | undefined;
    // @internal
    processEvent(): Promise<void>;
    processShortcutKey(_keyEvent: KeyboardEvent, _wentDown: boolean): boolean;
    processWheelEvent(ev: BeWheelEvent, doUpdate: boolean): Promise<EventHandled>;
    // @internal
    get reloadToolSettingsHandler(): (() => void) | undefined;
    set reloadToolSettingsHandler(handler: (() => void) | undefined);
    // @beta
    reloadToolSettingsProperties(): void;
    // @internal (undocumented)
    sendButtonEvent(ev: BeButtonEvent): Promise<any>;
    // (undocumented)
    sendEndDragEvent(ev: BeButtonEvent): Promise<any>;
    // @internal (undocumented)
    setAdjustedDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    setCursor(cursor: string | undefined): void;
    // @internal (undocumented)
    setIncompatibleViewportCursor(restore: boolean): void;
    // @internal (undocumented)
    setInputCollector(newTool?: InputCollector): void;
    // (undocumented)
    setLocateCircleOn(locateOn: boolean): void;
    // (undocumented)
    setLocateCursor(enableLocate: boolean): void;
    // @internal (undocumented)
    setPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    setViewTool(newTool?: ViewTool): void;
    // @internal
    startDefaultTool(): void;
    // @internal (undocumented)
    startInputCollector(newTool: InputCollector): void;
    // @internal (undocumented)
    startPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    startViewTool(newTool: ViewTool): void;
    // @beta
    syncToolSettingsProperties(toolId: string, syncProperties: DialogPropertySyncItem[]): void;
    // @internal (undocumented)
    testDecorationHit(id: string): boolean;
    // @internal
    get toolSettingsChangeHandler(): ((toolId: string, syncProperties: DialogPropertySyncItem[]) => void) | undefined;
    set toolSettingsChangeHandler(handler: ((toolId: string, syncProperties: DialogPropertySyncItem[]) => void) | undefined);
    // @internal (undocumented)
    readonly toolSettingsState: ToolSettingsState;
    // @internal (undocumented)
    readonly toolState: ToolState;
    // @internal
    get toolSyncUiEventDispatcher(): ((syncEventId: string, useImmediateDispatch?: boolean) => void) | undefined;
    set toolSyncUiEventDispatcher(handler: ((syncEventId: string, useImmediateDispatch?: boolean) => void) | undefined);
    // @internal (undocumented)
    updateDynamics(ev?: BeButtonEvent, useLastData?: boolean, adjustPoint?: boolean): void;
    // (undocumented)
    get viewTool(): ViewTool | undefined;
    }

// @public (undocumented)
export namespace ToolAdmin {
    // @alpha
    export class ActiveSettings {
        category?: Id64String;
        model?: Id64String;
    }
}

// @public
export class ToolAssistance {
    static get altKey(): string;
    static get altKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly altSymbol: string;
    static get altSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly arrowKeyboardInfo: ToolAssistanceKeyboardInfo;
    static createInstruction(image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod, keyboardInfo?: ToolAssistanceKeyboardInfo): ToolAssistanceInstruction;
    static createInstructions(mainInstruction: ToolAssistanceInstruction, sections?: ToolAssistanceSection[]): ToolAssistanceInstructions;
    static createKeyboardInfo(keys: string[], bottomKeys?: string[]): ToolAssistanceKeyboardInfo;
    static createKeyboardInstruction(keyboardInfo: ToolAssistanceKeyboardInfo, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createModifierKeyInstruction(modifierKey: string, image: string | ToolAssistanceImage, text: string, isNew?: boolean, inputMethod?: ToolAssistanceInputMethod): ToolAssistanceInstruction;
    static createSection(instructions: ToolAssistanceInstruction[], label?: string): ToolAssistanceSection;
    static createTouchCursorInstructions(instructions: ToolAssistanceInstruction[]): boolean;
    static get ctrlKey(): string;
    static get ctrlKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly ctrlSymbol: string;
    static get ctrlSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly downSymbol: string;
    static get inputsLabel(): string;
    static readonly leftSymbol: string;
    static readonly rightSymbol: string;
    static get shiftKey(): string;
    static get shiftKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static get shiftKeyboardInfoNoSymbol(): ToolAssistanceKeyboardInfo;
    static readonly shiftSymbol: string;
    static get shiftSymbolKeyboardInfo(): ToolAssistanceKeyboardInfo;
    static readonly upSymbol: string;
}

// @public
export enum ToolAssistanceImage {
    AcceptPoint = 1,
    CursorClick = 2,
    Keyboard = 0,
    LeftClick = 3,
    LeftClickDrag = 6,
    MouseWheel = 5,
    MouseWheelClickDrag = 8,
    OneTouchDoubleTap = 10,
    OneTouchDrag = 11,
    OneTouchTap = 9,
    RightClick = 4,
    RightClickDrag = 7,
    TouchCursorDrag = 16,
    TouchCursorTap = 15,
    TwoTouchDrag = 13,
    TwoTouchPinch = 14,
    TwoTouchTap = 12
}

// @public
export enum ToolAssistanceInputMethod {
    Both = 0,
    Mouse = 1,
    Touch = 2
}

// @public
export interface ToolAssistanceInstruction {
    image: string | ToolAssistanceImage;
    inputMethod?: ToolAssistanceInputMethod;
    isNew?: boolean;
    keyboardInfo?: ToolAssistanceKeyboardInfo;
    text: string;
}

// @public
export interface ToolAssistanceInstructions {
    mainInstruction: ToolAssistanceInstruction;
    sections?: ToolAssistanceSection[];
}

// @public
export interface ToolAssistanceKeyboardInfo {
    bottomKeys?: string[];
    keys: string[];
}

// @public
export interface ToolAssistanceSection {
    instructions: ToolAssistanceInstruction[];
    label?: string;
}

// @public (undocumented)
export type ToolList = ToolType[];

// @public
export class ToolRegistry {
    create(toolId: string, ...args: any[]): Tool | undefined;
    find(toolId: string): ToolType | undefined;
    // @internal
    findExactMatch(keyin: string): ToolType | undefined;
    // @internal
    findPartialMatches(keyin: string): FuzzySearchResults<ToolType>;
    getToolList(): ToolList;
    // @beta
    parseAndRun(keyin: string): ParseAndRunResult;
    // @beta
    parseKeyin(keyin: string): ParseKeyinResult;
    register(toolClass: ToolType, namespace?: I18NNamespace, i18n?: I18N): void;
    registerModule(moduleObj: any, namespace?: I18NNamespace, i18n?: I18N): void;
    run(toolId: string, ...args: any[]): boolean;
    // (undocumented)
    readonly tools: Map<string, typeof Tool>;
    unRegister(toolId: string): void;
}

// @public
export class ToolSettings {
    static doubleClickTimeout: BeDuration;
    static doubleClickToleranceInches: number;
    static doubleTapTimeout: BeDuration;
    static preserveWorldUp: boolean;
    static scrollSpeed: number;
    static startDragDelay: BeDuration;
    static startDragDistanceInches: number;
    static touchMoveDelay: BeDuration;
    static touchMoveDistanceInches: number;
    static touchZoomChangeThresholdInches: number;
    static viewingInertia: {
        enabled: boolean;
        damping: number;
        duration: BeDuration;
    };
    static viewToolPickRadiusInches: number;
    static walkCameraAngle: Angle;
    // @beta
    static walkCollisions: boolean;
    // @beta
    static walkDetectFloor: boolean;
    static walkEnforceZUp: boolean;
    // @beta
    static walkEyeHeight: number;
    static walkRequestPointerLock: boolean;
    // @beta
    static walkStepHeight: number;
    static walkVelocity: number;
    // @beta
    static walkVelocityChange: number;
    static wheelLineFactor: number;
    static wheelPageFactor: number;
    static wheelZoomBumpDistance: number;
    static wheelZoomRatio: number;
    static zoomSpeed: number;
}

// @internal
export class ToolSettingsState {
    getInitialToolSettingValue(toolId: string, propertyName: string): DialogItemValue | undefined;
    getInitialToolSettingValues(toolId: string, propertyNames: string[]): DialogPropertyItem[] | undefined;
    saveToolSettingProperties(toolId: string, tsProps: DialogPropertyItem[]): void;
    saveToolSettingProperty(toolId: string, item: DialogPropertyItem): void;
}

// @internal (undocumented)
export class ToolState {
    // (undocumented)
    clone(): ToolState;
    // (undocumented)
    coordLockOvr: CoordinateLockOverrides;
    // (undocumented)
    locateCircleOn: boolean;
    // (undocumented)
    setFrom(other: ToolState): void;
}

// @public
export interface ToolTipOptions {
    // (undocumented)
    duration?: BeDuration;
    // (undocumented)
    placement?: string;
}

// @internal
export interface ToolTipProvider {
    augmentToolTip(hit: HitDetail, tooltip: Promise<HTMLElement | string>): Promise<HTMLElement | string>;
}

// @public (undocumented)
export type ToolType = typeof Tool;

// @internal
export class TouchCursor implements CanvasDecoration {
    protected constructor(vp: ScreenViewport);
    // (undocumented)
    static createFromTouchTap(ev: BeTouchEvent): TouchCursor | undefined;
    // (undocumented)
    doTouchEnd(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchMove(ev: BeTouchEvent): boolean;
    // (undocumented)
    doTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // (undocumented)
    doTouchStart(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    protected drawHandle(ctx: CanvasRenderingContext2D, filled: boolean): void;
    // (undocumented)
    protected _inTouchTap: boolean;
    // (undocumented)
    isButtonHandled(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _isDragging: boolean;
    // (undocumented)
    protected isSelected(pt: XAndY): boolean;
    // (undocumented)
    protected _isSelected: boolean;
    // (undocumented)
    protected _offsetPosition: Point3d;
    // (undocumented)
    position: Point3d;
    // (undocumented)
    protected setPosition(vp: Viewport, worldLocation: Point3d): boolean;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    protected _yOffset: number;
}

// @internal (undocumented)
export class TraversalChildrenDetails {
    // (undocumented)
    combine(parentDetails: TraversalDetails): void;
    // (undocumented)
    getChildDetail(index: number): TraversalDetails;
    // (undocumented)
    initialize(): void;
}

// @internal (undocumented)
export class TraversalDetails {
    // (undocumented)
    childrenLoading: boolean;
    // (undocumented)
    childrenSelected: boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    queuedChildren: Tile[];
}

// @internal (undocumented)
export class TraversalSelectionContext {
    constructor(selected: Tile[], displayedDescendants: Tile[][], preloadDebugBuilder?: GraphicBuilder | undefined, _maxSelectionCount?: number | undefined);
    // (undocumented)
    displayedDescendants: Tile[][];
    // (undocumented)
    missing: RealityTile[];
    // (undocumented)
    preload(tile: RealityTile, args: TileDrawArgs): void;
    // (undocumented)
    preloadDebugBuilder?: GraphicBuilder | undefined;
    // (undocumented)
    preloaded: Set<RealityTile>;
    // (undocumented)
    select(tiles: RealityTile[], args: TileDrawArgs): void;
    // (undocumented)
    selected: Tile[];
    // (undocumented)
    get selectionCountExceeded(): boolean;
    // (undocumented)
    selectOrQueue(tile: RealityTile, args: TileDrawArgs, traversalDetails: TraversalDetails): void;
}

// @public
export function tryImageElementFromUrl(url: string): Promise<HTMLImageElement | undefined>;

// @beta
export class TwoWayViewportSync {
    connect(view1: Viewport, view2: Viewport): void;
    disconnect(): void;
    }

// @beta
export interface Uniform {
    setUniform1f: (value: number) => void;
    setUniform1fv: (value: Float32Array | number[]) => void;
    setUniform1i: (value: number) => void;
    setUniform1iv: (value: Int32Array | number[]) => void;
    setUniform2fv: (value: Float32Array | number[]) => void;
    setUniform3fv: (value: Float32Array | number[]) => void;
    setUniform4fv: (value: Float32Array | number[]) => void;
}

// @beta
export interface UniformArrayParams extends UniformParams {
    length: number;
}

// @beta
export interface UniformContext {
    viewport: Viewport;
}

// @beta
export interface UniformParams {
    bind: (uniform: Uniform, context: UniformContext) => void;
    name: string;
    type: UniformType;
}

// @beta
export enum UniformType {
    Bool = 0,
    Float = 2,
    Int = 1,
    Vec2 = 3,
    Vec3 = 4,
    Vec4 = 5
}

// @alpha
export type UnitSystemKey = "metric" | "imperial" | "usCustomary" | "usSurvey";

// @internal (undocumented)
export class UpsampledMapTile extends MapTile {
    // (undocumented)
    get geometry(): RenderTerrainMeshGeometry | undefined;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isLoadable(): boolean;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    get isNotFound(): boolean;
    // (undocumented)
    get isQueued(): boolean;
    // (undocumented)
    get isReady(): boolean;
    // (undocumented)
    get isUpsampled(): boolean;
    // (undocumented)
    get loadableTile(): RealityTile;
}

// @beta
export enum VaryingType {
    Float = 0,
    Vec2 = 1,
    Vec3 = 2,
    Vec4 = 3
}

// @public
export interface ViewAnimationOptions {
    animationTime?: number;
    cancelOnAbort?: boolean;
    easingFunction?: EasingFunction;
}

// @public
export interface ViewChangeOptions extends ViewAnimationOptions {
    animateFrustumChange?: boolean;
    marginPercent?: MarginPercent;
    noSaveInUndo?: boolean;
    onExtentsError?: (status: ViewStatus) => ViewStatus;
}

// @alpha
export class ViewClipByElementTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _alwaysUseRange?: boolean);
    // (undocumented)
    protected _alwaysUseRange: boolean;
    // (undocumented)
    protected doClipToElements(viewport: Viewport, ids: Id64Arg, alwaysUseRange?: boolean): Promise<boolean>;
    // (undocumented)
    doClipToSelectedElements(viewport: Viewport): Promise<boolean>;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByPlaneTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _clearExistingPlanes?: boolean);
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): boolean;
    // (undocumented)
    protected _clearExistingPlanes: boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByRangeTool extends ViewClipTool {
    // (undocumented)
    protected _corner?: Point3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipRange(range: Range3d, transform: Transform, ev: BeButtonEvent): boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByShapeTool extends ViewClipTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: DialogPropertySyncItem): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected getClipPoints(ev: BeButtonEvent): Point3d[];
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _matrix?: Matrix3d;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    get orientation(): EditManipulator.RotationType;
    set orientation(option: EditManipulator.RotationType);
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): DialogItem[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _zHigh?: number;
    // (undocumented)
    protected _zLow?: number;
}

// @alpha
export class ViewClipClearTool extends ViewClipTool {
    // (undocumented)
    protected doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipControlArrow {
    constructor(origin: Point3d, direction: Vector3d, sizeInches: number, fill?: ColorDef, outline?: ColorDef, name?: string);
    // (undocumented)
    direction: Vector3d;
    // (undocumented)
    fill?: ColorDef;
    // (undocumented)
    floatingOrigin?: Point3d;
    // (undocumented)
    name?: string;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    outline?: ColorDef;
    // (undocumented)
    sizeInches: number;
}

// @alpha
export class ViewClipDecoration extends EditManipulator.HandleProvider {
    constructor(_clipView: ScreenViewport, _clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static clear(): void;
    // (undocumented)
    protected clearControls(): void;
    // (undocumented)
    protected _clip?: ClipVector;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    get clipId(): string | undefined;
    // (undocumented)
    protected _clipId?: string;
    // (undocumented)
    protected _clipPlanes?: ConvexClipPlaneSet;
    // (undocumented)
    get clipPlaneSet(): ConvexClipPlaneSet | undefined;
    // (undocumented)
    protected _clipPlanesLoops?: GeometryQuery[];
    // (undocumented)
    protected _clipPlanesLoopsNoncontributing?: GeometryQuery[];
    // (undocumented)
    get clipShape(): ClipShape | undefined;
    // (undocumented)
    protected _clipShape?: ClipShape;
    // (undocumented)
    protected _clipShapeExtents?: Range1d;
    // (undocumented)
    protected _clipView: ScreenViewport;
    // (undocumented)
    protected _controlIds: string[];
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    static create(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected createControls(): Promise<boolean>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doClipPlaneClear(index: number): boolean;
    // (undocumented)
    doClipPlaneNegate(index: number): boolean;
    // (undocumented)
    doClipPlaneOrientView(index: number): boolean;
    // (undocumented)
    doClipShapeSetZExtents(extents: Range1d): boolean;
    // (undocumented)
    static get(vp: ScreenViewport): ViewClipDecoration | undefined;
    // (undocumented)
    getControlIndex(id: string): number;
    // (undocumented)
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // (undocumented)
    isClipShapeAlignedWithWorldUp(extents?: Range1d): boolean;
    // (undocumented)
    protected modifyControls(hit: HitDetail, _ev: BeButtonEvent): boolean;
    // (undocumented)
    onManipulatorEvent(eventType: EditManipulator.EventType): void;
    // (undocumented)
    protected onRightClick(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected onTouchTap(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onViewClose(vp: ScreenViewport): void;
    // (undocumented)
    protected _removeViewCloseListener?: () => void;
    // (undocumented)
    protected stop(): void;
    // (undocumented)
    protected _suspendDecorator: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toggle(vp: ScreenViewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected updateDecorationListener(_add: boolean): void;
}

// @alpha
export class ViewClipDecorationProvider implements ViewClipEventHandler {
    // (undocumented)
    static clear(): void;
    // (undocumented)
    clearDecorationOnDeselect: boolean;
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    static create(): ViewClipDecorationProvider;
    // (undocumented)
    hideDecoration(): void;
    readonly onActiveClipChanged: BeEvent<(viewport: Viewport, eventType: ClipEventType, provider: ViewClipDecorationProvider) => void>;
    readonly onActiveClipRightClick: BeEvent<(hit: HitDetail, ev: BeButtonEvent, provider: ViewClipDecorationProvider) => void>;
    // (undocumented)
    onClearClip(viewport: ScreenViewport): void;
    // (undocumented)
    onModifyClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClip(viewport: ScreenViewport): void;
    // (undocumented)
    onNewClipPlane(viewport: ScreenViewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecorationOnCreate: boolean;
    // (undocumented)
    selectOnCreate(): boolean;
    // (undocumented)
    showDecoration(vp: ScreenViewport): void;
    // (undocumented)
    toggleDecoration(vp: ScreenViewport): void;
}

// @alpha
export interface ViewClipEventHandler {
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    onClearClip(viewport: Viewport): void;
    // (undocumented)
    onModifyClip(viewport: Viewport): void;
    // (undocumented)
    onNewClip(viewport: Viewport): void;
    // (undocumented)
    onNewClipPlane(viewport: Viewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectOnCreate(): boolean;
}

// @alpha
export abstract class ViewClipModifyTool extends EditManipulator.HandleTool {
    constructor(manipulator: EditManipulator.HandleProvider, clip: ClipVector, vp: Viewport, hitId: string, ids: string[], controls: ViewClipControlArrow[]);
    // (undocumented)
    protected accept(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _anchorIndex: number;
    // (undocumented)
    protected _clip: ClipVector;
    // (undocumented)
    protected _clipView: Viewport;
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    protected _currentDistance: number;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected drawAnchorOffset(context: DecorateContext, color: ColorDef, weight: number, transformFromClip?: Transform): void;
    // (undocumented)
    protected abstract drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected getOffsetValue(ev: BeButtonEvent, transformFromClip?: Transform): number | undefined;
    // (undocumented)
    protected _ids: string[];
    // (undocumented)
    protected init(): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected _restoreClip: boolean;
    // (undocumented)
    protected abstract updateViewClip(ev: BeButtonEvent, isAccept: boolean): boolean;
    // (undocumented)
    protected _viewRange: Range3d;
}

// @alpha
export class ViewClipPlanesModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipShapeModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipTool extends PrimitiveTool {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static addClipPlanesLoops(builder: GraphicBuilder, loops: GeometryQuery[], outline: boolean): void;
    // (undocumented)
    static areClipsEqual(clipA: ClipVector, clipB: ClipVector): boolean;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    static doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static doClipToConvexClipPlaneSet(viewport: Viewport, planes: ConvexClipPlaneSet): boolean;
    // (undocumented)
    static doClipToPlane(viewport: Viewport, origin: Point3d, normal: Vector3d, clearExistingPlanes: boolean): boolean;
    // (undocumented)
    static doClipToRange(viewport: Viewport, range: Range3d, transform?: Transform): boolean;
    // (undocumented)
    static doClipToShape(viewport: Viewport, xyPoints: Point3d[], transform?: Transform, zLow?: number, zHigh?: number): boolean;
    // (undocumented)
    static drawClip(context: DecorateContext, clip: ClipVector, viewExtents?: Range3d, options?: DrawClipOptions): void;
    // (undocumented)
    static drawClipPlanesLoops(context: DecorateContext, loops: GeometryQuery[], color: ColorDef, weight: number, dashed?: boolean, fill?: ColorDef, id?: string): void;
    // (undocumented)
    static drawClipShape(context: DecorateContext, shape: ClipShape, extents: Range1d, color: ColorDef, weight: number, id?: string): void;
    // (undocumented)
    static enableClipVolume(viewport: Viewport): boolean;
    // (undocumented)
    protected static enumAsOrientationMessage(str: string): string;
    // (undocumented)
    static getClipRayTransformed(origin: Point3d, direction: Vector3d, transform?: Transform): Ray3d;
    // (undocumented)
    static getClipShapeExtents(shape: ClipShape, viewRange: Range3d): Range1d;
    // (undocumented)
    static getClipShapePoints(shape: ClipShape, z: number): Point3d[];
    // (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    static getOffsetValueTransformed(offset: number, transform?: Transform): number;
    // (undocumented)
    static getPlaneInwardNormal(orientation: EditManipulator.RotationType, viewport: Viewport): Vector3d | undefined;
    // (undocumented)
    static hasClip(viewport: Viewport): boolean;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    static isSingleClipPlane(clip: ClipVector): ClipPlane | undefined;
    // (undocumented)
    static isSingleClipShape(clip: ClipVector): ClipShape | undefined;
    // (undocumented)
    static isSingleConvexClipPlaneSet(clip: ClipVector): ConvexClipPlaneSet | undefined;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected static _orientationName: string;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    static setViewClip(viewport: Viewport, clip?: ClipVector): boolean;
    // (undocumented)
    protected showPrompt(): void;
}

// @beta
export class ViewCreator2d {
    constructor(_imodel: IModelConnection);
    createViewForModel(modelId: Id64String, modelType: string, options?: ViewCreator2dOptions): Promise<ViewState>;
    static isDrawingModelClass(modelType: string): boolean;
    static isSheetModelClass(modelType: string): boolean;
    }

// @beta
export interface ViewCreator2dOptions {
    bgColor?: ColorDef;
    useSeedView?: boolean;
    vpAspect?: number;
}

// @beta
export class ViewCreator3d {
    constructor(_imodel: IModelConnection);
    createDefaultView(options?: ViewCreator3dOptions, modelIds?: string[]): Promise<ViewState>;
    }

// @beta
export interface ViewCreator3dOptions {
    cameraOn?: boolean;
    skyboxOn?: boolean;
    standardViewId?: StandardViewId;
    useSeedView?: boolean;
    vpAspect?: number;
}

// @internal (undocumented)
export function viewGlobalLocation(viewport: ScreenViewport, doAnimate: boolean, eyeHeight?: number, pitchAngleRadians?: number, location?: GlobalLocation): number;

// @internal (undocumented)
export class ViewGlobalLocationConstants {
    // (undocumented)
    static readonly birdHeightAboveEarthInMeters = 713;
    // (undocumented)
    static readonly birdPitchAngleRadians = 0;
    // (undocumented)
    static readonly largestEarthArc = 20037500;
    // (undocumented)
    static readonly maximumDistanceToDrive = 96560.6;
    // (undocumented)
    static readonly satelliteHeightAboveEarthInMeters: number;
}

// @beta
export class ViewGlobeBirdTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ViewGlobeIModelTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ViewGlobeLocationTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    static get maxArgs(): undefined;
    // (undocumented)
    static get minArgs(): number;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    parseAndRun(...args: string[]): boolean;
    // (undocumented)
    static toolId: string;
}

// @beta
export class ViewGlobeSatelliteTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot?: boolean, doAnimate?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class ViewHandleArray {
    constructor(viewTool: ViewManip);
    // (undocumented)
    add(handle: ViewingToolHandle): void;
    // (undocumented)
    get count(): number;
    // (undocumented)
    drawHandles(context: DecorateContext): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    focus: number;
    // (undocumented)
    focusDrag: boolean;
    // (undocumented)
    get focusHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    focusHitHandle(): void;
    // (undocumented)
    getByIndex(index: number): ViewingToolHandle | undefined;
    // (undocumented)
    handles: ViewingToolHandle[];
    hasHandle(handleType: ViewHandleType): boolean;
    // (undocumented)
    get hitHandle(): ViewingToolHandle | undefined;
    // (undocumented)
    hitHandleIndex: number;
    // (undocumented)
    motion(ev: BeButtonEvent): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onWheel(ev: BeWheelEvent): boolean;
    // (undocumented)
    setFocus(index: number): void;
    // (undocumented)
    testHit(ptScreen: Point3d, forced?: ViewHandleType): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @internal (undocumented)
export enum ViewHandleType {
    // (undocumented)
    Fly = 64,
    // (undocumented)
    Look = 128,
    // (undocumented)
    LookAndMove = 256,
    // (undocumented)
    None = 0,
    // (undocumented)
    Pan = 4,
    // (undocumented)
    Rotate = 1,
    // (undocumented)
    Scroll = 8,
    // (undocumented)
    TargetCenter = 2,
    // (undocumented)
    Walk = 32,
    // (undocumented)
    Zoom = 16
}

// @beta
export class ViewingSpace {
    // (undocumented)
    calcNpcToView(): Map4d;
    // @internal (undocumented)
    static createFromViewport(vp: Viewport): ViewingSpace | undefined;
    readonly eyePoint: Point3d | undefined;
    // @internal (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    frustFraction: number;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @internal (undocumented)
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // @internal (undocumented)
    getPreloadFrustum(transformOrScale?: Transform | number, result?: Frustum): Frustum;
    // @internal (undocumented)
    getTerrainHeightRange(): Range1d | undefined;
    // (undocumented)
    getViewCorners(): Range3d;
    // @internal
    static nearScaleLog24: number;
    // @internal
    static nearScaleNonLog24: number;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    get view(): ViewState;
    set view(view: ViewState);
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    readonly viewDelta: Vector3d;
    readonly viewDeltaUnexpanded: Vector3d;
    readonly viewOrigin: Point3d;
    readonly viewOriginUnexpanded: Point3d;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    // @internal (undocumented)
    readonly worldToNpcMap: Map4d;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    // @internal (undocumented)
    readonly worldToViewMap: Map4d;
    // @internal (undocumented)
    readonly zClipAdjusted: boolean;
}

// @internal (undocumented)
export abstract class ViewingToolHandle {
    constructor(viewTool: ViewManip);
    // (undocumented)
    adjustDepthPoint(isValid: boolean, _vp: Viewport, _plane: Plane3dByOriginAndUnitNormal, source: DepthPointSource): boolean;
    // (undocumented)
    protected changeFocusFromDepthPoint(): void;
    // (undocumented)
    checkOneShot(): boolean;
    // (undocumented)
    protected _depthPoint?: Point3d;
    // (undocumented)
    abstract doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // (undocumented)
    drawHandle(_context: DecorateContext, _hasFocus: boolean): void;
    // (undocumented)
    abstract firstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    focusIn(): void;
    // (undocumented)
    focusOut(): void;
    // (undocumented)
    getHandleCursor(): string;
    // (undocumented)
    abstract get handleType(): ViewHandleType;
    // (undocumented)
    protected readonly _lastPtNpc: Point3d;
    // (undocumented)
    motion(_ev: BeButtonEvent): boolean;
    // (undocumented)
    needDepthPoint(_ev: BeButtonEvent, _isPreview: boolean): boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): boolean;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchEnd(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMove(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): boolean;
    // (undocumented)
    onTouchStart(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onTouchTap(_ev: BeTouchEvent): boolean;
    // (undocumented)
    onWheel(_ev: BeWheelEvent): boolean;
    // (undocumented)
    protected pickDepthPoint(ev: BeButtonEvent): void;
    // (undocumented)
    abstract testHandleForHit(ptScreen: Point3d, out: {
        distance: number;
        priority: ViewManipPriority;
    }): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @public
export class ViewManager {
    addDecorator(decorator: Decorator): () => void;
    // @internal
    addToolTipProvider(provider: ToolTipProvider): () => void;
    addViewport(newVp: ScreenViewport): BentleyStatus;
    // @internal (undocumented)
    beginDynamicsMode(): void;
    clearSelectedView(): void;
    // (undocumented)
    get crossHairCursor(): string;
    // (undocumented)
    cursor: string;
    // (undocumented)
    readonly decorators: Decorator[];
    // @internal (undocumented)
    get doesHostHaveFocus(): boolean;
    dropDecorator(decorator: Decorator): boolean;
    // @internal
    dropToolTipProvider(provider: ToolTipProvider): void;
    dropViewport(vp: ScreenViewport, disposeOfViewport?: boolean): BentleyStatus;
    // (undocumented)
    get dynamicsCursor(): string;
    // @internal (undocumented)
    endDynamicsMode(): void;
    forEachViewport(func: (vp: ScreenViewport) => void): void;
    // @internal
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // @internal
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // @beta
    getElementToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getFirstOpenView(): ScreenViewport | undefined;
    // (undocumented)
    get grabbingCursor(): string;
    // (undocumented)
    get grabCursor(): string;
    // (undocumented)
    inDynamicsMode: boolean;
    // @beta
    invalidateCachedDecorationsAllViews(decorator: ViewportDecorator): void;
    invalidateDecorationsAllViews(): void;
    // @internal (undocumented)
    invalidateScenes(): void;
    // @alpha
    invalidateSymbologyOverridesAllViews(): void;
    // @internal (undocumented)
    invalidateViewportScenes(): void;
    // (undocumented)
    get lookCursor(): string;
    // @internal (undocumented)
    notifySelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    readonly onBeginRender: BeEvent<() => void>;
    // @internal
    onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    readonly onFinishRender: BeEvent<() => void>;
    // @internal (undocumented)
    onInitialized(): void;
    readonly onSelectedViewportChanged: BeUiEvent<SelectedViewportChangedArgs>;
    // @internal (undocumented)
    onSelectionSetChanged(_iModel: IModelConnection): void;
    // @internal (undocumented)
    onShutDown(): void;
    readonly onViewClose: BeUiEvent<ScreenViewport>;
    readonly onViewOpen: BeUiEvent<ScreenViewport>;
    readonly onViewResume: BeUiEvent<ScreenViewport>;
    readonly onViewSuspend: BeUiEvent<ScreenViewport>;
    // @internal
    purgeTileTrees(olderThan: BeTimePoint): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    // @internal
    renderLoop(): void;
    // (undocumented)
    get rotateCursor(): string;
    // @internal (undocumented)
    get sceneInvalidated(): boolean;
    get selectedView(): ScreenViewport | undefined;
    // @beta
    setAntialiasingAllViews(numSamples: number): void;
    setSelectedView(vp: ScreenViewport | undefined): BentleyStatus;
    setViewCursor(cursor?: string): void;
    // @internal (undocumented)
    readonly toolTipProviders: ToolTipProvider[];
    // @internal (undocumented)
    validateViewportScenes(): void;
    // (undocumented)
    get walkCursor(): string;
    // (undocumented)
    get zoomCursor(): string;
}

// @public
export abstract class ViewManip extends ViewTool {
    constructor(viewport: ScreenViewport | undefined, handleMask: number, oneShot: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    changeViewport(vp?: ScreenViewport): void;
    // @internal (undocumented)
    clearDepthPoint(): boolean;
    // @internal (undocumented)
    static computeFitRange(viewport: ScreenViewport): Range3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    protected _depthPreview?: {
        testPoint: Point3d;
        pickRadius: number;
        plane: Plane3dByOriginAndUnitNormal;
        source: DepthPointSource;
        isDefaultDepth: boolean;
        sourceId?: string;
    };
    // (undocumented)
    enforceZUp(pivotPoint: Point3d): boolean;
    // (undocumented)
    static fitView(viewport: ScreenViewport, animateFrustumChange: boolean, options?: ViewChangeOptions): void;
    // @internal (undocumented)
    static fitViewWithGlobeAnimation(viewport: ScreenViewport, animateFrustumChange: boolean, options?: ViewChangeOptions): void;
    // @internal (undocumented)
    forcedHandle: ViewHandleType;
    // (undocumented)
    frustumValid: boolean;
    // (undocumented)
    static getDefaultTargetPointWorld(vp: Viewport): Point3d;
    // @internal (undocumented)
    getDepthPointGeometryId(): string | undefined;
    // (undocumented)
    static getFocusPlaneNpc(vp: Viewport): number;
    // (undocumented)
    handleMask: number;
    // (undocumented)
    inHandleModify: boolean;
    // (undocumented)
    isDragging: boolean;
    // (undocumented)
    isDraggingRequired: boolean;
    isPointVisible(testPt: Point3d): boolean;
    // (undocumented)
    get isZUp(): boolean;
    // (undocumented)
    lensAngleMatches(angle: Angle, tolerance: number): boolean;
    // (undocumented)
    nPts: number;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(wentDown: boolean, modifier: BeModifierKeys, event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(inputEv: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchEnd(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchStart(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @internal (undocumented)
    pickDepthPoint(ev: BeButtonEvent, isPreview?: boolean): Point3d | undefined;
    // @internal (undocumented)
    previewDepthPoint(context: DecorateContext): void;
    // (undocumented)
    processFirstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    processPoint(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string, additionalInstr?: ToolAssistanceInstruction[]): void;
    // (undocumented)
    setCameraLensAngle(lensAngle: Angle, retainEyePoint: boolean): ViewStatus;
    setTargetCenterWorld(pt: Point3d, lockTarget: boolean, saveTarget: boolean): void;
    // @internal (undocumented)
    startHandleDrag(ev: BeButtonEvent, forcedHandle?: ViewHandleType): Promise<EventHandled>;
    // @internal (undocumented)
    protected _startPose?: ViewPose;
    // (undocumented)
    targetCenterLocked: boolean;
    // (undocumented)
    targetCenterValid: boolean;
    // (undocumented)
    readonly targetCenterWorld: Point3d;
    // (undocumented)
    updateTargetCenter(): void;
    // @internal (undocumented)
    viewHandles: ViewHandleArray;
    // (undocumented)
    static zoomToAlwaysDrawnExclusive(viewport: ScreenViewport, options?: ViewChangeOptions): Promise<boolean>;
}

// @public
export abstract class Viewport implements IDisposable {
    // @internal
    protected constructor(target: RenderTarget);
    // @internal (undocumented)
    protected addDecorations(_decorations: Decorations): void;
    addFeatureOverrideProvider(provider: FeatureOverrideProvider): boolean;
    // @internal (undocumented)
    addFeatureOverrides(ovrs: FeatureSymbology.Overrides): void;
    // @internal
    addModelSubCategoryVisibilityOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
    // @beta
    addScreenSpaceEffect(effectName: string): void;
    // @beta
    addTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    addViewedModels(models: Id64Arg): Promise<void>;
    get alwaysDrawn(): Id64Set | undefined;
    // @alpha (undocumented)
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    // @internal (undocumented)
    get analysisFractionValid(): boolean;
    // @internal (undocumented)
    get analysisStyle(): AnalysisStyle | undefined;
    // @beta
    get antialiasSamples(): number;
    set antialiasSamples(numSamples: number);
    // @internal
    applyViewState(val: ViewState): void;
    // @beta
    attachRealityModel(props: ContextRealityModelProps): void;
    // (undocumented)
    get auxCoordSystem(): AuxCoordSystemState;
    // @internal (undocumented)
    get backgroundMapGeometry(): BackgroundMapGeometry | undefined;
    get backgroundMapSettings(): BackgroundMapSettings;
    set backgroundMapSettings(settings: BackgroundMapSettings);
    changeBackgroundMapProps(props: BackgroundMapProps): void;
    changeCategoryDisplay(categories: Id64Arg, display: boolean, enableAllSubCategories?: boolean): void;
    // @internal (undocumented)
    changeDynamics(dynamics: GraphicList | undefined): void;
    // @internal (undocumented)
    protected _changeFlags: ChangeFlags;
    changeModelDisplay(models: Id64Arg, display: boolean): boolean;
    changeSubCategoryDisplay(subCategoryId: Id64String, display: boolean): void;
    changeView(view: ViewState, _opts?: ViewChangeOptions): void;
    changeViewedModel2d(baseModelId: Id64String, options?: ChangeViewedModel2dOptions & ViewChangeOptions): Promise<void>;
    changeViewedModels(modelIds: Id64Arg): boolean;
    clearAlwaysDrawn(): void;
    clearNeverDrawn(): void;
    // @beta
    get clipStyle(): ClipStyle;
    set clipStyle(style: ClipStyle);
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // @internal (undocumented)
    computeViewRange(): Range3d;
    get continuousRendering(): boolean;
    set continuousRendering(contRend: boolean);
    // @internal (undocumented)
    get controllerValid(): boolean;
    // @internal (undocumented)
    protected _controllerValid: boolean;
    // @internal (undocumented)
    createSceneContext(): SceneContext;
    cssPixelsToDevicePixels(cssPixels: number): number;
    // @internal
    get debugBoundingBoxes(): TileBoundingBoxes;
    set debugBoundingBoxes(boxes: TileBoundingBoxes);
    // @internal (undocumented)
    protected _decorationsValid: boolean;
    // @beta
    detachRealityModelByIndex(index: number): void;
    determineVisibleDepthRange(rect?: ViewRect, result?: DepthRangeNpc): DepthRangeNpc | undefined;
    get devicePixelRatio(): number;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    get displayStyle(): DisplayStyleState;
    set displayStyle(style: DisplayStyleState);
    // (undocumented)
    dispose(): void;
    dropFeatureOverrideProvider(provider: FeatureOverrideProvider): boolean;
    dropModelAppearanceOverride(id: Id64String): void;
    // @beta
    dropRealityModelAppearanceOverride(index: number): void;
    dropSubCategoryOverride(id: Id64String): void;
    // @beta
    dropTiledGraphicsProvider(provider: TiledGraphicsProvider): void;
    get emphasisSettings(): Hilite.Settings;
    set emphasisSettings(settings: Hilite.Settings);
    // @deprecated
    get featureOverrideProvider(): FeatureOverrideProvider | undefined;
    set featureOverrideProvider(provider: FeatureOverrideProvider | undefined);
    findFeatureOverrideProvider(predicate: (provider: FeatureOverrideProvider) => boolean): FeatureOverrideProvider | undefined;
    findFeatureOverrideProviderOfType<T>(type: Constructor<T>): T | undefined;
    // @internal
    flashDuration: number;
    // @internal
    flashIntensity: number;
    // @internal
    flashUpdateTime?: BeTimePoint;
    // @alpha (undocumented)
    forEachTiledGraphicsProvider(func: (provider: TiledGraphicsProvider) => void): void;
    // @internal (undocumented)
    protected forEachTiledGraphicsProviderTree(func: (ref: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (ref: TileTreeReference) => void): void;
    // @internal
    get freezeScene(): boolean;
    set freezeScene(freeze: boolean);
    // @internal (undocumented)
    fromViewOrientation(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    get frustFraction(): number;
    // (undocumented)
    getAuxCoordOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getAuxCoordRotation(result?: Matrix3d): Matrix3d;
    getContrastToBackgroundColor(): ColorDef;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @beta
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    // @beta
    getPixelDataNpcPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    // @beta
    getPixelDataWorldPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    getPixelSizeAtPoint(point?: Point3d): number;
    // @beta
    getRealityModelAppearanceOverride(index: number): FeatureAppearance | undefined;
    // @beta
    getRealityModelIndexFromTransientId(id: Id64String): number;
    // @internal (undocumented)
    getSubCategories(categoryId: Id64String): Id64Set | undefined;
    getSubCategoryAppearance(id: Id64String): SubCategoryAppearance;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal (undocumented)
    getTerrainHeightRange(): Range1d;
    // @internal (undocumented)
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getWorldFrustum(box?: Frustum): Frustum;
    // @internal (undocumented)
    hasTiledGraphicsProvider(provider: TiledGraphicsProvider): boolean;
    get hilite(): Hilite.Settings;
    set hilite(hilite: Hilite.Settings);
    get iModel(): IModelConnection;
    // @beta
    get insideClipColor(): ColorDef | undefined;
    set insideClipColor(color: ColorDef | undefined);
    // @internal (undocumented)
    invalidateController(): void;
    invalidateDecorations(): void;
    // @internal (undocumented)
    invalidateRenderPlan(): void;
    // @internal (undocumented)
    invalidateScene(): void;
    // @internal (undocumented)
    protected _inViewChangedEvent: boolean;
    get isAlwaysDrawnExclusive(): boolean;
    // @internal (undocumented)
    get isAspectRatioLocked(): boolean;
    get isCameraOn(): boolean;
    // @internal (undocumented)
    get isContextRotationRequired(): boolean;
    get isDisposed(): boolean;
    get isFadeOutActive(): boolean;
    set isFadeOutActive(active: boolean);
    get isGridOn(): boolean;
    // @internal (undocumented)
    isPixelSelectable(pixel: Pixel.Data): boolean;
    // @internal (undocumented)
    get isPointAdjustmentRequired(): boolean;
    // @internal (undocumented)
    get isSnapAdjustmentRequired(): boolean;
    isSubCategoryVisible(id: Id64String): boolean;
    // @internal
    lastFlashedElem?: string;
    get lightSettings(): LightSettings | undefined;
    // @internal (undocumented)
    markSelectionSetDirty(): void;
    get neverDrawn(): Id64Set | undefined;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    get numReadyTiles(): number;
    get numRequestedTiles(): number;
    get numSelectedTiles(): number;
    readonly onAlwaysDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onChangeView: BeEvent<(vp: Viewport, previousViewState: ViewState) => void>;
    readonly onDisplayStyleChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onDisposed: BeEvent<(vp: Viewport) => void>;
    readonly onFeatureOverrideProviderChanged: BeEvent<(vp: Viewport) => void>;
    readonly onFeatureOverridesChanged: BeEvent<(vp: Viewport) => void>;
    readonly onNeverDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onRender: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onResized: BeEvent<(vp: Viewport) => void>;
    readonly onViewChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedCategoriesChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedCategoriesPerModelChanged: BeEvent<(vp: Viewport) => void>;
    readonly onViewedModelsChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewportChanged: BeEvent<(vp: Viewport, changed: ChangeFlags) => void>;
    // @beta
    readonly onViewUndoRedo: BeEvent<(vp: Viewport, event: ViewUndoEvent) => void>;
    // @beta
    get outsideClipColor(): ColorDef | undefined;
    set outsideClipColor(color: ColorDef | undefined);
    // @beta
    overrideDisplayStyle(overrides: DisplayStyleSettingsProps): void;
    overrideModelAppearance(id: Id64String, ovr: FeatureAppearance): void;
    // @beta
    overrideRealityModelAppearance(index: number, overrides: FeatureAppearance): boolean;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @beta
    get perModelCategoryVisibility(): PerModelCategoryVisibility.Overrides;
    pixelsFromInches(inches: number): number;
    // @internal (undocumented)
    get pixelsPerInch(): number;
    // @internal (undocumented)
    pointToGrid(point: Point3d): void;
    readImage(rect?: ViewRect, targetSize?: Point2d, flipVertically?: boolean): ImageBuffer | undefined;
    // @internal
    readImageToCanvas(): HTMLCanvasElement;
    // @beta
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable?: boolean): void;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): void;
    // @beta
    removeScreenSpaceEffects(): void;
    // @internal (undocumented)
    renderFrame(): void;
    // @internal (undocumented)
    get renderPlanValid(): boolean;
    // @internal (undocumented)
    protected _renderPlanValid: boolean;
    replaceViewedModels(modelIds: Id64Arg): Promise<void>;
    requestRedraw(): void;
    get rotation(): Matrix3d;
    // @internal (undocumented)
    get sceneValid(): boolean;
    // @internal (undocumented)
    protected _sceneValid: boolean;
    // @beta
    get screenSpaceEffects(): Iterable<string>;
    set screenSpaceEffects(effects: Iterable<string>);
    scroll(screenDist: XAndY, options?: ViewChangeOptions): void;
    // @internal
    setAllValid(): void;
    setAlwaysDrawn(ids: Id64Set, exclusive?: boolean): void;
    // @beta
    setAnimator(animator?: Animator): void;
    setFeatureOverrideProviderChanged(): void;
    // @internal
    setFlashed(id: string | undefined, duration: number): void;
    // (undocumented)
    setLightSettings(settings: LightSettings): void;
    // @internal
    setModelDisplayTransformProvider(provider: ModelDisplayTransformProvider): void;
    setNeverDrawn(ids: Id64Set): void;
    // @beta
    setOSMBuildingDisplay(options: OsmBuildingDisplayOptions): void;
    // @internal @deprecated (undocumented)
    setRedrawPending(): void;
    // @internal (undocumented)
    setRenderPlanValid(): void;
    // (undocumented)
    setSolarShadowSettings(settings: SolarShadowSettings): void;
    setStandardRotation(id: StandardViewId): void;
    // @alpha
    setTileSizeModifier(modifier: number | undefined): void;
    setupFromView(pose?: ViewPose): ViewStatus;
    setupViewFromFrustum(inFrustum: Frustum): boolean;
    // @internal (undocumented)
    setValidScene(): void;
    // @internal (undocumented)
    setViewedCategoriesPerModelChanged(): void;
    get solarShadowSettings(): SolarShadowSettings | undefined;
    // @internal (undocumented)
    readonly subcategories: SubCategoriesCache.Queue;
    synchWithView(_options?: ViewChangeOptions | boolean): void;
    // @internal (undocumented)
    get target(): RenderTarget;
    // @alpha
    get tileSizeModifier(): number;
    // @beta
    get timePoint(): number | undefined;
    set timePoint(time: number | undefined);
    // @internal (undocumented)
    get timePointValid(): boolean;
    // @internal (undocumented)
    toViewOrientation(from: XYZ, to?: XYZ): void;
    turnCameraOff(): void;
    turnCameraOn(lensAngle?: Angle): ViewStatus;
    static undoDelay: BeDuration;
    protected updateChangeFlags(newView: ViewState): void;
    // @internal (undocumented)
    protected validateRenderPlan(): void;
    get view(): ViewState;
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    get viewDelta(): Vector3d;
    get viewFlags(): ViewFlags;
    set viewFlags(viewFlags: ViewFlags);
    // @alpha
    get viewingGlobe(): boolean;
    // @internal (undocumented)
    get viewingSpace(): ViewingSpace;
    // @internal
    get viewportId(): number;
    // @internal (undocumented)
    protected readonly _viewRange: ViewRect;
    abstract get viewRect(): ViewRect;
    viewsModel(modelId: Id64String): boolean;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    // @internal
    get wantViewAttachmentBoundaries(): boolean;
    set wantViewAttachmentBoundaries(want: boolean);
    // @internal
    get wantViewAttachmentClipShapes(): boolean;
    set wantViewAttachmentClipShapes(want: boolean);
    // @internal
    get wantViewAttachments(): boolean;
    set wantViewAttachments(want: boolean);
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    get worldToViewMap(): Map4d;
    zoom(newCenter: Point3d | undefined, factor: number, options?: ViewChangeOptions): ViewStatus;
    zoomToElementProps(elementProps: ElementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToElements(ids: Id64Arg, options?: ViewChangeOptions & ZoomToOptions): Promise<void>;
    zoomToPlacementProps(placementProps: PlacementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToVolume(volume: LowAndHighXYZ | LowAndHighXY, options?: ViewChangeOptions): void;
}

// @public
export interface ViewportDecorator {
    decorate(context: DecorateContext): void;
    readonly useCachedDecorations?: true;
}

// @internal
export class ViewportIdSet extends ReadonlySortedArray<number> {
    constructor(viewportId?: number);
    // (undocumented)
    add(viewportId: number): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    clone(): ViewportIdSet;
    // (undocumented)
    copyFrom(src: ViewportIdSet): void;
    // (undocumented)
    drop(viewportId: number): void;
    // (undocumented)
    equals(set: ViewportIdSet): boolean;
}

// @internal
export class ViewportIdSets extends SortedArray<ViewportIdSet> {
    constructor();
    drop(viewportId: number): void;
    minus(viewportId: number, viewportIds?: ViewportIdSet): ViewportIdSet | undefined;
    plus(viewportId: number, viewportIds?: ViewportIdSet): ViewportIdSet;
    }

// @public
export abstract class ViewPose {
    constructor(cameraOn: boolean);
    // (undocumented)
    cameraOn: boolean;
    // (undocumented)
    get center(): Point3d;
    // (undocumented)
    abstract equal(other: ViewPose): boolean;
    // (undocumented)
    abstract equalState(view: ViewState): boolean;
    // (undocumented)
    abstract extents: Vector3d;
    // (undocumented)
    abstract origin: Point3d;
    // (undocumented)
    abstract rotation: Matrix3d;
    // (undocumented)
    get target(): Point3d;
    // (undocumented)
    undoTime?: BeTimePoint;
    // (undocumented)
    get zVec(): Vector3d;
}

// @internal (undocumented)
export class ViewPose2d extends ViewPose {
    constructor(view: ViewState2d);
    // (undocumented)
    readonly angle: Angle;
    // (undocumented)
    readonly delta: Point2d;
    // (undocumented)
    equal(other: ViewPose2d): boolean;
    // (undocumented)
    equalState(view: ViewState2d): boolean;
    // (undocumented)
    get extents(): Vector3d;
    // (undocumented)
    get origin(): Point3d;
    // (undocumented)
    readonly origin2: Point2d;
    // (undocumented)
    get rotation(): Matrix3d;
}

// @internal (undocumented)
export class ViewPose3d extends ViewPose {
    constructor(view: ViewState3d);
    // (undocumented)
    readonly camera: Camera;
    // (undocumented)
    equal(other: ViewPose3d): boolean;
    // (undocumented)
    equalState(view: ViewState3d): boolean;
    // (undocumented)
    readonly extents: Vector3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rotation: Matrix3d;
    // (undocumented)
    get target(): Point3d;
}

// @public
export class ViewRect {
    constructor(left?: number, top?: number, right?: number, bottom?: number);
    get area(): number;
    get aspect(): number;
    get bottom(): number;
    set bottom(val: number);
    clone(result?: ViewRect): ViewRect;
    computeOverlap(other: ViewRect, out?: ViewRect): ViewRect | undefined;
    containsPoint(point: XAndY): boolean;
    equals(other: ViewRect): boolean;
    // (undocumented)
    extend(other: ViewRect): void;
    get height(): number;
    set height(height: number);
    init(left: number, top: number, right: number, bottom: number): void;
    initFromPoints(topLeft: XAndY, bottomRight: XAndY): void;
    initFromRange(input: LowAndHighXY): void;
    inset(deltaX: number, deltaY: number): void;
    insetByPercent(percent: number): void;
    insetUniform(offset: number): void;
    isContained(other: ViewRect): boolean;
    get isNull(): boolean;
    get isValid(): boolean;
    get left(): number;
    set left(val: number);
    overlaps(other: ViewRect): boolean;
    get right(): number;
    set right(val: number);
    scaleAboutCenter(xScale: number, yScale: number): void;
    setFrom(other: ViewRect): void;
    get top(): number;
    set top(val: number);
    get width(): number;
    set width(width: number);
}

// @public
export class ViewRedoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewState extends ElementState {
    // @internal
    protected constructor(props: ViewDefinitionProps, iModel: IModelConnection, categoryOrClone: CategorySelectorState, displayStyle: DisplayStyleState);
    adjustAspectRatio(aspect: number): void;
    // @internal (undocumented)
    adjustViewDelta(delta: Vector3d, origin: XYZ, rot: Matrix3d, aspect?: number, opts?: ViewChangeOptions): ViewStatus;
    abstract allow3dManipulations(): boolean;
    get analysisStyle(): AnalysisStyle | undefined;
    // @internal (undocumented)
    abstract applyPose(props: ViewPose): this;
    // @internal (undocumented)
    get areAllTileTreesLoaded(): boolean;
    // @internal
    attachToViewport(): void;
    get auxiliaryCoordinateSystem(): AuxCoordSystemState;
    get backgroundColor(): ColorDef;
    // (undocumented)
    calculateFocusCorners(): Point3d[];
    calculateFrustum(result?: Frustum): Frustum | undefined;
    get categorySelector(): CategorySelectorState;
    set categorySelector(selector: CategorySelectorState);
    // @internal (undocumented)
    static get className(): string;
    // @internal
    collectNonTileTreeStatistics(_stats: RenderMemory.Statistics): void;
    // @internal
    collectStatistics(stats: RenderMemory.Statistics): void;
    abstract computeFitRange(): Range3d;
    // @internal (undocumented)
    computeWorldToNpc(viewRot?: Matrix3d, inOrigin?: Point3d, delta?: Vector3d, enforceFrontToBackRatio?: boolean): {
        map: Map4d | undefined;
        frustFraction: number;
    };
    // @internal (undocumented)
    abstract createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    static createFromProps(_props: ViewStateProps, _iModel: IModelConnection): ViewState | undefined;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal
    decorate(context: DecorateContext): void;
    abstract get defaultExtentLimits(): ExtentLimits;
    // (undocumented)
    description?: string;
    // @internal
    detachFromViewport(): void;
    // @beta
    abstract get details(): ViewDetails;
    // @internal
    discloseTileTrees(trees: DisclosedTileTreeSet): void;
    get displayStyle(): DisplayStyleState;
    set displayStyle(style: DisplayStyleState);
    // @internal (undocumented)
    drawGrid(context: DecorateContext): void;
    equals(other: this): boolean;
    get extentLimits(): ExtentLimits;
    set extentLimits(limits: ExtentLimits);
    // @internal
    fixAspectRatio(windowAspect: number): void;
    abstract forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal
    abstract forEachModelTreeRef(func: (treeRef: TileTreeReference) => void): void;
    // @internal (undocumented)
    forEachTileTreeRef(func: (treeRef: TileTreeReference) => void): void;
    getAspectRatio(): number;
    getAspectRatioSkew(): number;
    getAuxiliaryCoordinateSystemId(): Id64String;
    getCenter(result?: Point3d): Point3d;
    abstract getExtents(): Vector3d;
    getGridOrientation(): GridOrientationType;
    getGridSettings(vp: Viewport, origin: Point3d, rMatrix: Matrix3d, orientation: GridOrientationType): void;
    // (undocumented)
    getGridSpacing(): XAndY;
    // (undocumented)
    getGridsPerRef(): number;
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    // @internal (undocumented)
    getModelDisplayTransform(modelId: Id64String, baseTransform: Transform): Transform;
    // @internal
    getModelElevation(_modelId: Id64String): number;
    abstract getOrigin(): Point3d;
    abstract getRotation(): Matrix3d;
    // @internal (undocumented)
    static getStandardViewMatrix(id: StandardViewId): Matrix3d;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    getTargetPoint(result?: Point3d): Point3d;
    // (undocumented)
    getUpVector(point: Point3d): Vector3d;
    getViewClip(): ClipVector | undefined;
    abstract getViewedExtents(): AxisAlignedBox3d;
    getXVector(result?: Vector3d): Vector3d;
    getYVector(result?: Vector3d): Vector3d;
    getZVector(result?: Vector3d): Vector3d;
    get globalScopeFactor(): number;
    // @internal
    get globeMode(): GlobeMode;
    // @internal
    hasSameCoordinates(other: ViewState): boolean;
    is2d(): this is ViewState2d;
    abstract is3d(): this is ViewState3d;
    // @alpha
    get isAttachedToViewport(): boolean;
    isCameraEnabled(): this is ViewState3d;
    abstract isDrawingView(): this is DrawingViewState;
    // (undocumented)
    isPrivate?: boolean;
    abstract isSpatialView(): this is SpatialViewState;
    // @internal (undocumented)
    isSubCategoryVisible(id: Id64String): boolean;
    load(): Promise<void>;
    lookAtViewAlignedVolume(volume: Range3d, aspect?: number, options?: ViewChangeOptions): void;
    lookAtVolume(volume: LowAndHighXYZ | LowAndHighXY, aspect?: number, options?: ViewChangeOptions): void;
    // @alpha
    get maxGlobalScopeFactor(): number;
    // @alpha
    get modelDisplayTransformProvider(): ModelDisplayTransformProvider | undefined;
    set modelDisplayTransformProvider(provider: ModelDisplayTransformProvider | undefined);
    get name(): string;
    // @beta
    readonly onDisplayStyleChanged: BeEvent<(newStyle: DisplayStyleState) => void>;
    // @alpha
    readonly onModelDisplayTransformProviderChanged: BeEvent<(newProvider: ModelDisplayTransformProvider | undefined) => void>;
    // @beta
    readonly onViewedCategoriesChanged: BeEvent<() => void>;
    // @internal (undocumented)
    outputStatusMessage(status: ViewStatus): ViewStatus;
    // @internal
    refreshForModifiedModels(modelIds: Id64Arg | undefined): boolean;
    resetExtentLimits(): void;
    // @internal (undocumented)
    abstract savePose(): ViewPose;
    // @internal
    get scheduleScript(): RenderScheduleState.Script | undefined;
    // @internal
    get secondaryViewports(): Iterable<Viewport>;
    setAspectRatioSkew(val: number): void;
    setAuxiliaryCoordinateSystem(acs?: AuxCoordSystemState): void;
    setCategorySelector(categories: CategorySelectorState): void;
    setCenter(center: Point3d): void;
    // (undocumented)
    setDisplayStyle(style: DisplayStyleState): void;
    abstract setExtents(viewDelta: Vector3d): void;
    setGridSettings(orientation: GridOrientationType, spacing: Point2d, gridsPerRef: number): void;
    abstract setOrigin(viewOrg: XYAndZ): void;
    abstract setRotation(viewRot: Matrix3d): void;
    setRotationAboutPoint(rotation: Matrix3d, point?: Point3d): void;
    setStandardRotation(id: StandardViewId): void;
    setupFromFrustum(inFrustum: Frustum, opts?: ViewChangeOptions): ViewStatus;
    setViewClip(clip?: ClipVector): void;
    // (undocumented)
    toJSON(): ViewDefinitionProps;
    toProps(): ViewStateProps;
    // (undocumented)
    protected _updateMaxGlobalScopeFactor(): void;
    get viewFlags(): ViewFlags;
    viewsCategory(id: Id64String): boolean;
    abstract viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState2d extends ViewState {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // (undocumented)
    readonly angle: Angle;
    // @internal (undocumented)
    applyPose(val: ViewPose2d): this;
    // (undocumented)
    get baseModelId(): Id64String;
    // (undocumented)
    protected _baseModelId: Id64String;
    // @alpha
    changeViewedModel(newViewedModelId: Id64String): Promise<void>;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    readonly delta: Point2d;
    // @beta
    get details(): ViewDetails;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @internal (undocumented)
    forEachModelTreeRef(func: (ref: TileTreeReference) => void): void;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getViewedModel(): GeometricModel2dState | undefined;
    // @internal (undocumented)
    is3d(): this is ViewState3d;
    // @internal (undocumented)
    isSpatialView(): this is SpatialViewState;
    // (undocumented)
    load(): Promise<void>;
    // @deprecated
    onRenderFrame(_viewport: Viewport): void;
    // (undocumented)
    readonly origin: Point2d;
    // @internal (undocumented)
    savePose(): ViewPose;
    // (undocumented)
    setExtents(delta: XAndY): void;
    // (undocumented)
    setOrigin(origin: XAndY): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // @internal (undocumented)
    protected get _tileTreeRef(): TileTreeReference | undefined;
    // (undocumented)
    toJSON(): ViewDefinition2dProps;
    // @internal (undocumented)
    protected _treeRef?: TileTreeReference;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState3d extends ViewState {
    constructor(props: ViewDefinition3dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // @internal (undocumented)
    applyPose(val: ViewPose3d): this;
    calcLensAngle(): Angle;
    // (undocumented)
    protected static calculateMaxDepth(delta: Vector3d, zVec: Vector3d): number;
    readonly camera: Camera;
    protected _cameraOn: boolean;
    cartographicToRoot(cartographic: Cartographic, result?: Point3d): Point3d | undefined;
    cartographicToRootFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d | undefined>;
    centerEyePoint(backDistance?: number): void;
    centerFocusDistance(): void;
    // @internal
    changeFocusDistance(newDist: number): ViewStatus;
    // @internal
    changeFocusFromPoint(pt: Point3d): ViewStatus;
    // @internal (undocumented)
    static get className(): string;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @beta
    get details(): ViewDetails3d;
    get displayStyle(): DisplayStyle3dState;
    set displayStyle(style: DisplayStyle3dState);
    // @internal (undocumented)
    protected drawGroundPlane(context: DecorateContext): void;
    // @internal (undocumented)
    protected drawSkyBox(context: DecorateContext): void;
    // @internal (undocumented)
    protected enableCamera(): void;
    readonly extents: Vector3d;
    forceMinFrontDist: number;
    getBackDistance(): number;
    // (undocumented)
    getCartographicHeight(point: XYAndZ): number | undefined;
    getDisplayStyle3d(): DisplayStyle3dState;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getEyeCartographicHeight(): number | undefined;
    // @internal (undocumented)
    getEyeOrOrthographicViewPoint(): Point3d;
    getEyePoint(): Point3d;
    getFocusDistance(): number;
    getFrontDistance(): number;
    getGroundElevation(): number;
    getGroundExtents(vp?: Viewport): AxisAlignedBox3d;
    getLensAngle(): Angle;
    // @internal (undocumented)
    getModelClip(modelId: Id64String): RenderClipVolume | undefined;
    // @internal (undocumented)
    getModelElevation(modelId: Id64String): number;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getTargetPoint(result?: Point3d): Point3d;
    get globalScopeFactor(): number;
    // (undocumented)
    globalViewTransition(): number;
    // @internal (undocumented)
    is3d(): this is ViewState3d;
    // (undocumented)
    get isCameraOn(): boolean;
    get isCameraValid(): boolean;
    // @internal (undocumented)
    isDrawingView(): this is DrawingViewState;
    // (undocumented)
    isEyePointAbove(elevation: number): boolean;
    // (undocumented)
    isEyePointGlobalView(eyePoint: XYAndZ): boolean;
    // (undocumented)
    get isGlobalView(): boolean;
    lookAt(eyePoint: XYAndZ, targetPoint: XYAndZ, upVector: Vector3d, newExtents?: XAndY, frontDistance?: number, backDistance?: number, opts?: ViewChangeOptions): ViewStatus;
    // @alpha
    lookAtGlobalLocation(eyeHeight: number, pitchAngleRadians?: number, location?: GlobalLocation, eyePoint?: Point3d): number;
    // @alpha
    lookAtGlobalLocationFromGcs(eyeHeight: number, pitchAngleRadians?: number, location?: GlobalLocation, eyePoint?: Point3d): Promise<number>;
    lookAtUsingLensAngle(eyePoint: Point3d, targetPoint: Point3d, upVector: Vector3d, fov: Angle, frontDistance?: number, backDistance?: number, opts?: ViewChangeOptions): ViewStatus;
    // (undocumented)
    minimumFrontDistance(): number;
    moveCameraLocal(distance: Vector3d): ViewStatus;
    moveCameraWorld(distance: Vector3d): ViewStatus;
    // @deprecated
    onRenderFrame(_viewport: Viewport): void;
    readonly origin: Point3d;
    rootToCartographic(root: XYAndZ, result?: Cartographic): Cartographic | undefined;
    rootToCartographicFromGcs(root: XYAndZ, result?: Cartographic): Promise<Cartographic | undefined>;
    rotateCameraLocal(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    rotateCameraWorld(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    savePose(): ViewPose;
    setAllow3dManipulations(allow: boolean): void;
    // (undocumented)
    setExtents(extents: XYAndZ): void;
    setEyePoint(pt: XYAndZ): void;
    setFocusDistance(dist: number): void;
    setLensAngle(angle: Angle): void;
    // (undocumented)
    setOrigin(origin: XYAndZ): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // (undocumented)
    setupFromFrustum(frustum: Frustum, opts?: ViewChangeOptions): ViewStatus;
    // (undocumented)
    supportsCamera(): boolean;
    // (undocumented)
    toJSON(): ViewDefinition3dProps;
    turnCameraOff(): void;
    verifyFocusPlane(): void;
}

// @public
export enum ViewStatus {
    // (undocumented)
    AlreadyAttached = 2,
    // (undocumented)
    DrawFailure = 4,
    // (undocumented)
    InvalidLens = 14,
    // (undocumented)
    InvalidTargetPoint = 13,
    // (undocumented)
    InvalidUpVector = 12,
    // (undocumented)
    InvalidViewport = 15,
    // (undocumented)
    InvalidWindow = 7,
    // (undocumented)
    MaxDisplayDepth = 11,
    // (undocumented)
    MaxWindow = 9,
    // (undocumented)
    MaxZoom = 10,
    // (undocumented)
    MinWindow = 8,
    // (undocumented)
    ModelNotFound = 6,
    // (undocumented)
    NotAttached = 3,
    // (undocumented)
    NotResized = 5,
    // (undocumented)
    Success = 0,
    // (undocumented)
    ViewNotInitialized = 1
}

// @public
export class ViewToggleCameraTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewTool extends InteractiveTool {
    constructor(viewport?: ScreenViewport | undefined);
    // (undocumented)
    beginDynamicUpdate(): void;
    // (undocumented)
    endDynamicUpdate(): void;
    exitTool(): void;
    // (undocumented)
    inDynamicUpdate: boolean;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(..._args: any[]): boolean;
    // (undocumented)
    static showPrompt(prompt: string): void;
    // (undocumented)
    static translate(val: string): string;
    // (undocumented)
    viewport?: ScreenViewport | undefined;
}

// @beta
export enum ViewUndoEvent {
    // (undocumented)
    Redo = 1,
    // (undocumented)
    Undo = 0
}

// @public
export class ViewUndoTool extends ViewTool {
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class WalkViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // @beta (undocumented)
    provideToolAssistance(mainInstrKey: string): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class WebMercatorProjection {
    // (undocumented)
    static geodeticLatitudeToMercatorAngle(latitude: number): number;
    // (undocumented)
    static maximumLatitude: number;
    static mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;
}

// @internal (undocumented)
export class WebMercatorTilingScheme extends MapTilingScheme {
    constructor(numberOfLevelZeroTilesX?: number, numberOfLevelZeroTilesY?: number, rowZeroAtNorthPole?: boolean);
    // (undocumented)
    latitudeToYFraction(latitude: number): number;
    // (undocumented)
    yFractionToLatitude(yFraction: number): number;
}

// @beta
export class WebViewerApp {
    // (undocumented)
    static shutdown(): Promise<void>;
    // (undocumented)
    static startup(opts: {
        webViewerApp: WebViewerAppOptions;
        iModelApp?: IModelAppOptions;
    }): Promise<void>;
}

// @beta
export interface WebViewerAppOptions {
    // (undocumented)
    routing?: RpcRoutingToken;
    // (undocumented)
    rpcParams: BentleyCloudRpcParams;
}

// @internal
export class WheelEventProcessor {
    // (undocumented)
    static process(ev: BeWheelEvent, doUpdate: boolean): Promise<void>;
}

// @public
export class WindowAreaTool extends ViewTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // @beta (undocumented)
    provideToolAssistance(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class WmsCapabilities {
    constructor(_json: any);
    // (undocumented)
    get cartoRange(): MapCartoRectangle | undefined;
    // (undocumented)
    static create(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<WmsCapabilities | undefined>;
    // (undocumented)
    get featureInfoFormats(): string[] | undefined;
    // (undocumented)
    get featureInfoSupported(): boolean;
    // (undocumented)
    getSubLayers(visible?: boolean): undefined | MapSubLayerProps[];
    // (undocumented)
    get json(): any;
    // (undocumented)
    readonly layer?: WmsCapability.Layer;
    // (undocumented)
    get maxLevel(): number;
    // (undocumented)
    readonly service: WmsCapability.Service;
    // (undocumented)
    readonly version?: string;
}

// @internal
export namespace WmsCapability {
    // (undocumented)
    export class Layer {
        constructor(_json: any);
        // (undocumented)
        readonly cartoRange?: MapCartoRectangle;
        // (undocumented)
        getSubLayers(visible?: boolean): MapSubLayerProps[];
        // (undocumented)
        readonly queryable: boolean;
        // (undocumented)
        readonly srs?: string[];
        // (undocumented)
        readonly subLayers: SubLayer[];
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class Service {
        constructor(json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly accessConstraints?: string;
        // (undocumented)
        readonly contactInformation?: string;
        // (undocumented)
        readonly name: string;
        // (undocumented)
        readonly onlineResource?: string;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class SubLayer {
        constructor(_json: any, parent?: SubLayer | undefined);
        // (undocumented)
        readonly cartoRange?: MapCartoRectangle;
        // (undocumented)
        readonly children?: SubLayer[];
        // (undocumented)
        readonly name: string;
        // (undocumented)
        readonly parent?: SubLayer | undefined;
        // (undocumented)
        readonly queryable: boolean;
        // (undocumented)
        readonly title: string;
    }
}

// @internal (undocumented)
export class WmsMapLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    getToolTip(strings: string[], quadId: QuadId, carto: Cartographic, tree: ImageryMapTileTree): Promise<void>;
    // (undocumented)
    initialize(): Promise<void>;
    }

// @internal (undocumented)
export class WmsUtilities {
    // (undocumented)
    static getBaseUrl(url: string): string;
}

// @internal (undocumented)
export class WmtsCapabilities {
    constructor(_json: any);
    // (undocumented)
    readonly contents?: WmtsCapability.Contents;
    // (undocumented)
    static create(url: string, credentials?: RequestBasicCredentials, ignoreCache?: boolean): Promise<WmtsCapabilities | undefined>;
    // (undocumented)
    static createFromXml(xmlCapabilities: string): WmtsCapabilities | undefined;
    // (undocumented)
    get json(): any;
    // (undocumented)
    readonly operationsMetadata?: WmtsCapability.OperationMetadata;
    // (undocumented)
    readonly serviceIdentification?: WmtsCapability.ServiceIdentification;
    // (undocumented)
    readonly version?: string;
}

// @internal
export namespace WmtsCapability {
    // (undocumented)
    export class BoundingBox {
        constructor(_json: any);
        // (undocumented)
        readonly crs?: string;
        // (undocumented)
        readonly range?: Range2d;
    }
    // (undocumented)
    export abstract class Constants {
        // (undocumented)
        static readonly GOOGLEMAPS_COMPATIBLE_WELLKNOWNNAME = "googlemapscompatible";
        // (undocumented)
        static readonly GOOGLEMAPS_LEVEL0_SCALE_DENOM = 559082264.0287178;
    }
    // (undocumented)
    export class Contents {
        constructor(_json: any);
        // (undocumented)
        getGoogleMapsCompatibleTileMatrixSet(): WmtsCapability.TileMatrixSet[];
        // (undocumented)
        readonly layers: WmtsCapability.Layer[];
        // (undocumented)
        readonly tileMatrixSets: WmtsCapability.TileMatrixSet[];
    }
    // (undocumented)
    export class HttpDcp {
        constructor(json: any);
        // (undocumented)
        readonly constraintName?: string;
        // (undocumented)
        readonly encoding?: string;
        // (undocumented)
        readonly url?: string;
    }
    // (undocumented)
    export class Layer {
        constructor(_json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly boundingBox?: BoundingBox;
        // (undocumented)
        readonly format?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly styles: Style[];
        // (undocumented)
        readonly tileMatrixSetLinks: TileMatrixSetLink[];
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly wsg84BoundingBox?: MapCartoRectangle;
    }
    // (undocumented)
    export class Operation {
        constructor(json: any);
        // (undocumented)
        get getDcpHttp(): HttpDcp[] | undefined;
        // (undocumented)
        readonly name?: string;
        // (undocumented)
        get postDcpHttp(): HttpDcp[] | undefined;
        }
    // (undocumented)
    export class OperationMetadata {
        constructor(json: any);
        // (undocumented)
        get getCapabilities(): Operation | undefined;
        // (undocumented)
        get getFeatureInfo(): Operation | undefined;
        // (undocumented)
        get getTile(): Operation | undefined;
        }
    // (undocumented)
    export abstract class OwsConstants {
        // (undocumented)
        static readonly ABSTRACT_XMLTAG = "ows:Abstract";
        // (undocumented)
        static readonly ACCESSCONSTRAINTS_XMLTAG = "ows:AccessConstraints";
        // (undocumented)
        static readonly ALLOWEDVALUES_XMLTAG = "ows:AllowedValues";
        // (undocumented)
        static readonly BOUNDINGBOX_XMLTAG = "ows:BoundingBox";
        // (undocumented)
        static readonly CONSTRAINT_XMLTAG = "ows:Constraint";
        // (undocumented)
        static readonly DCP_XMLTAG = "ows:DCP";
        // (undocumented)
        static readonly FEES_XMLTAG = "ows:Fees";
        // (undocumented)
        static readonly GET_XMLTAG = "ows:Get";
        // (undocumented)
        static readonly HTTP_XMLTAG = "ows:HTTP";
        // (undocumented)
        static readonly IDENTIFIER_XMLTAG = "ows:Identifier";
        // (undocumented)
        static readonly KEYWORD_XMLTAG = "ows:Keyword";
        // (undocumented)
        static readonly KEYWORDS_XMLTAG = "ows:Keywords";
        // (undocumented)
        static readonly LOWERCORNER_XMLTAG = "ows:LowerCorner";
        // (undocumented)
        static readonly OPERATION_XMLTAG = "ows:Operation";
        // (undocumented)
        static readonly OPERATIONSMETADATA_XMLTAG = "ows:OperationsMetadata";
        // (undocumented)
        static readonly POST_XMLTAG = "ows:Post";
        // (undocumented)
        static readonly SERVICEIDENTIFICATION_XMLTAG = "ows:ServiceIdentification";
        // (undocumented)
        static readonly SERVICETYPE_XMLTAG = "ows:ServiceType";
        // (undocumented)
        static readonly SERVICETYPEVERSION_XMLTAG = "ows:ServiceTypeVersion";
        // (undocumented)
        static readonly SUPPORTEDCRS_XMLTAG = "ows:SupportedCRS";
        // (undocumented)
        static readonly TITLE_XMLTAG = "ows:Title";
        // (undocumented)
        static readonly UPPERCORNER_XMLTAG = "ows:UpperCorner";
        // (undocumented)
        static readonly VALUE_XMLTAG = "ows:Value";
        // (undocumented)
        static readonly WGS84BOUNDINGBOX_XMLTAG = "ows:WGS84BoundingBox";
    }
    // (undocumented)
    export class ServiceIdentification {
        constructor(json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly accessConstraints?: string;
        // (undocumented)
        readonly fees?: string;
        // (undocumented)
        readonly keywords?: string[];
        // (undocumented)
        readonly serviceType?: string;
        // (undocumented)
        readonly serviceTypeVersion?: string;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class Style {
        constructor(_json: any);
        // (undocumented)
        readonly identifier?: string;
        // (undocumented)
        readonly isDefault: boolean;
        // (undocumented)
        readonly title?: string;
    }
    // (undocumented)
    export class TileMatrix {
        constructor(_json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly matrixHeight: number;
        // (undocumented)
        readonly matrixWidth: number;
        // (undocumented)
        readonly scaleDenominator: number;
        // (undocumented)
        readonly tileHeight: number;
        // (undocumented)
        readonly tileWidth: number;
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly topLeftCorner: Point2d;
    }
    // (undocumented)
    export class TileMatrixSet {
        constructor(_json: any);
        // (undocumented)
        readonly abstract?: string;
        // (undocumented)
        readonly identifier: string;
        // (undocumented)
        readonly supportedCrs: string;
        // (undocumented)
        readonly tileMatrix: TileMatrix[];
        // (undocumented)
        readonly title?: string;
        // (undocumented)
        readonly wellKnownScaleSet: string;
    }
    // (undocumented)
    export class TileMatrixSetLink {
        constructor(_json: any);
        // (undocumented)
        readonly tileMatrixSet: string;
    }
    // (undocumented)
    export abstract class XmlConstants {
        // (undocumented)
        static readonly CONSTRAINT_NAME_FILTER = "Encoding";
        // (undocumented)
        static readonly GETCAPABILITIES = "GetCapabilities";
        // (undocumented)
        static readonly GETFEATUREINFO = "GetFeatureInfo";
        // (undocumented)
        static readonly GETTILE = "GetTile";
        // (undocumented)
        static readonly MATRIXHEIGHT_XMLTAG = "MatrixHeight";
        // (undocumented)
        static readonly MATRIXWIDTH_XMLTAG = "MatrixWidth";
        // (undocumented)
        static readonly SCALEDENOMINATOR_XMLTAG = "ScaleDenominator";
        // (undocumented)
        static readonly STYLE_ISDEFAULT = "IsDefault";
        // (undocumented)
        static readonly TILEHEIGHT_XMLTAG = "TileHeight";
        // (undocumented)
        static readonly TILEMATRIX_XMLTAG = "TileMatrix";
        // (undocumented)
        static readonly TILEMATRIXSETLINK_XMLTAG = "TileMatrixSetLink";
        // (undocumented)
        static readonly TILEWIDTH_XMLTAG = "TileWidth";
        // (undocumented)
        static readonly TOPLEFTCORNER_XMLTAG = "TopLeftCorner";
        // (undocumented)
        static readonly WELLKNOWNSCALESET_XMLTAG = "WellKnownScaleSet";
        // (undocumented)
        static readonly XLINK_HREF = "xlink:href";
    }
}

// @internal (undocumented)
export class WmtsMapLayerImageryProvider extends MapLayerImageryProvider {
    constructor(settings: MapLayerSettings);
    // (undocumented)
    constructUrl(row: number, column: number, zoomLevel: number): Promise<string>;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    get mutualExclusiveSubLayer(): boolean;
    }

// @public
export interface ZoomToOptions {
    placementRelativeId?: StandardViewId;
    standardViewId?: StandardViewId;
    viewRotation?: Matrix3d;
}

// @public
export class ZoomViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    static iconSpec: string;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}


// (No @packageDocumentation comment for this package)

```
