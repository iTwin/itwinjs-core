## API Report File for "@itwin/presentation-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BentleyError } from '@itwin/core-bentley';
import { CompressedId64Set } from '@itwin/core-bentley';
import { EntityProps } from '@itwin/core-common';
import { FormatProps } from '@itwin/core-quantity';
import { GetMetaDataFunction } from '@itwin/core-bentley';
import { GuidString } from '@itwin/core-bentley';
import { Id64String } from '@itwin/core-bentley';
import { IDisposable } from '@itwin/core-bentley';
import { IModelRpcProps } from '@itwin/core-common';
import { RpcInterface } from '@itwin/core-common';
import { UnitSystemKey } from '@itwin/core-quantity';

// @alpha (undocumented)
export function addFieldHierarchy(rootHierarchies: FieldHierarchy[], hierarchy: FieldHierarchy): void;

// @internal (undocumented)
export function applyOptionalPrefix(str: string, prefix?: string): string;

// @public
export interface ArrayTypeDescription extends BaseTypeDescription {
    memberType: TypeDescription;
    valueFormat: PropertyValueFormat.Array;
}

// @internal
export class AsyncTasksTracker {
    // (undocumented)
    get pendingAsyncs(): Set<string>;
    // (undocumented)
    trackAsyncTask(): IDisposable;
}

// @public
export interface BaseFieldJSON {
    // (undocumented)
    category: string;
    // (undocumented)
    editor?: EditorDescription;
    // (undocumented)
    isReadonly: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    priority: number;
    // (undocumented)
    renderer?: RendererDescription;
    // (undocumented)
    type: TypeDescription;
}

// @public
export interface BaseNodeKey {
    pathFromRoot: string[];
    type: string;
    version: number;
}

// @public
export interface BaseNodeKeyJSON {
    // (undocumented)
    pathFromRoot: string[];
    // (undocumented)
    type: string;
    // (undocumented)
    version?: number;
}

// @public
export interface BaseTypeDescription {
    typeName: string;
    valueFormat: PropertyValueFormat;
}

// @public
export interface BooleanRulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.Bool;
    // (undocumented)
    value: boolean;
}

// @public
export interface BooleanRulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.Bool;
    // (undocumented)
    value: boolean;
}

// @public
export interface CalculatedPropertiesSpecification {
    label: string;
    priority?: number;
    value: string;
}

// @public
export interface CategoryDescription {
    description: string;
    expand: boolean;
    label: string;
    name: string;
    parent?: CategoryDescription;
    priority: number;
    renderer?: RendererDescription;
}

// @public (undocumented)
export namespace CategoryDescription {
    export function fromJSON(json: CategoryDescriptionJSON): CategoryDescription;
    export function listFromJSON(json: CategoryDescriptionJSON[]): CategoryDescription[];
    export function toJSON(category: CategoryDescription): CategoryDescriptionJSON;
}

// @public
export interface CategoryDescriptionJSON {
    // (undocumented)
    description: string;
    // (undocumented)
    expand: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    parent?: string;
    // (undocumented)
    priority: number;
    // (undocumented)
    renderer?: RendererDescription;
}

// @public
export type CategoryIdentifier = ParentCategoryIdentifier | RootCategoryIdentifier | IdCategoryIdentifier;

// @public
export interface CheckBoxRule extends RuleBase, ConditionContainer {
    condition?: string;
    defaultValue?: boolean;
    isEnabled?: string | boolean;
    propertyName?: string;
    ruleType: RuleTypes.CheckBox;
    useInversedPropertyValue?: boolean;
}

// @public
export interface ChildNodeRule extends NavigationRuleBase, ConditionContainer {
    ruleType: RuleTypes.ChildNodes;
}

// @public
export type ChildNodeSpecification = CustomNodeSpecification | InstanceNodesOfSpecificClassesSpecification | RelatedInstanceNodesSpecification | CustomQueryInstanceNodesSpecification;

// @public
export interface ChildNodeSpecificationBase {
    doNotSort?: boolean;
    hasChildren?: "Always" | "Never" | "Unknown";
    hideExpression?: string;
    hideIfNoChildren?: boolean;
    hideNodesInHierarchy?: boolean;
    nestedRules?: ChildNodeRule[];
    priority?: number;
    relatedInstances?: RelatedInstanceSpecification[];
    specType: ChildNodeSpecificationTypes;
    // @beta
    suppressSimilarAncestorsCheck?: boolean;
}

// @public
export enum ChildNodeSpecificationTypes {
    // (undocumented)
    CustomNode = "CustomNode",
    // (undocumented)
    CustomQueryInstanceNodes = "CustomQueryInstanceNodes",
    // (undocumented)
    InstanceNodesOfSpecificClasses = "InstanceNodesOfSpecificClasses",
    // (undocumented)
    RelatedInstanceNodes = "RelatedInstanceNodes"
}

// @public
export interface ClassGroup extends GroupingSpecificationBase {
    baseClass?: SingleSchemaClassSpecification;
    createGroupForSingleItem?: boolean;
    specType: GroupingSpecificationTypes.Class;
}

// @public
export type ClassId = Id64String;

// @public
export interface ClassInfo {
    id: ClassId;
    label: string;
    name: string;
}

// @public (undocumented)
export namespace ClassInfo {
    export function fromJSON(json: ClassInfoJSON): ClassInfo;
    export function toJSON(info: ClassInfo): ClassInfoJSON;
}

// @public
export interface ClassInfoJSON {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
}

// @internal (undocumented)
export interface CommonIpcParams {
    // (undocumented)
    clientId: string;
}

// @public
export interface CompressedClassInfoJSON {
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
}

// @public
export type ComputeDisplayValueCallback = (type: string, value: PrimitivePropertyValue, displayValue: string) => Promise<string>;

// @public
export interface ConditionContainer {
    condition?: string;
}

// @public
export class Content {
    constructor(descriptor: Descriptor, items: Item[]);
    readonly contentSet: Item[];
    readonly descriptor: Descriptor;
    static fromJSON(json: ContentJSON | string | undefined): Content | undefined;
    // @internal
    static reviver(key: string, value: any): any;
    toJSON(): ContentJSON;
}

// @public
export interface ContentDescriptorRequestOptions<TIModel, TKeySet, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    displayType: string;
    keys: TKeySet;
    selection?: SelectionInfo;
}

// @public
export type ContentDescriptorRpcRequestOptions = PresentationRpcRequestOptions<ContentDescriptorRequestOptions<never, KeySetJSON, RulesetVariableJSON>>;

// @public
export enum ContentFlags {
    DistinctValues = 16,
    // @beta
    IncludeInputKeys = 256,
    KeysOnly = 1,
    MergeResults = 8,
    NoFields = 32,
    ShowImages = 2,
    ShowLabels = 4
}

// @public
export interface ContentInstancesOfSpecificClassesSpecification extends ContentSpecificationBase {
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    handleInstancesPolymorphically?: boolean;
    handlePropertiesPolymorphically?: boolean;
    instanceFilter?: string;
    specType: ContentSpecificationTypes.ContentInstancesOfSpecificClasses;
}

// @public
export interface ContentJSON {
    // (undocumented)
    contentSet: ItemJSON[];
    // (undocumented)
    descriptor: DescriptorJSON;
}

// @public
export interface ContentModifier extends RuleBase, ContentModifiersList {
    class?: SingleSchemaClassSpecification;
    ruleType: RuleTypes.ContentModifier;
}

// @public
export interface ContentModifiersList {
    calculatedProperties?: CalculatedPropertiesSpecification[];
    propertyCategories?: PropertyCategorySpecification[];
    propertyOverrides?: PropertySpecification[];
    relatedProperties?: RelatedPropertiesSpecification[];
}

// @public
export interface ContentRelatedInstancesSpecification extends ContentSpecificationBase {
    instanceFilter?: string;
    relationshipPaths: RepeatableRelationshipPathSpecification[];
    specType: ContentSpecificationTypes.ContentRelatedInstances;
}

// @public
export interface ContentRequestOptions<TIModel, TDescriptor, TKeySet, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    descriptor: TDescriptor;
    keys: TKeySet;
}

// @public
export type ContentRpcRequestOptions = PresentationRpcRequestOptions<ContentRequestOptions<never, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>>;

// @public
export interface ContentRule extends RuleBase, ConditionContainer {
    condition?: string;
    ruleType: RuleTypes.Content;
    specifications: ContentSpecification[];
}

// @beta
export interface ContentSourcesRequestOptions<TIModel> extends RequestOptions<TIModel> {
    classes: string[];
}

// @beta
export type ContentSourcesRpcRequestOptions = PresentationRpcRequestOptions<ContentSourcesRequestOptions<never>>;

// @beta
export interface ContentSourcesRpcResult {
    classesMap: {
        [id: string]: CompressedClassInfoJSON;
    };
    sources: SelectClassInfoJSON<Id64String>[];
}

// @public
export type ContentSpecification = ContentInstancesOfSpecificClassesSpecification | ContentRelatedInstancesSpecification | SelectedNodeInstancesSpecification;

// @public
export interface ContentSpecificationBase extends ContentModifiersList {
    priority?: number;
    relatedInstances?: RelatedInstanceSpecification[];
    showImages?: boolean;
    specType: ContentSpecificationTypes;
}

// @public
export enum ContentSpecificationTypes {
    // (undocumented)
    ContentInstancesOfSpecificClasses = "ContentInstancesOfSpecificClasses",
    // (undocumented)
    ContentRelatedInstances = "ContentRelatedInstances",
    // (undocumented)
    SelectedNodeInstances = "SelectedNodeInstances"
}

// @alpha (undocumented)
export type ContentUpdateInfo = typeof UPDATE_FULL;

// @internal
export function createFieldHierarchies(fields: Field[], ignoreCategories?: Boolean): FieldHierarchy[];

// @public
export type CustomizationRule = InstanceLabelOverride | CheckBoxRule | GroupingRule | ImageIdOverride | LabelOverride | // eslint-disable-line deprecation/deprecation
SortingRule | StyleOverride | ExtendedDataRule | NodeArtifactsRule;

// @public
export interface CustomNodeSpecification extends ChildNodeSpecificationBase {
    description?: string;
    imageId?: string;
    label: string;
    specType: ChildNodeSpecificationTypes.CustomNode;
    type: string;
}

// @public
export interface CustomQueryInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    queries?: QuerySpecification[];
    specType: ChildNodeSpecificationTypes.CustomQueryInstanceNodes;
}

// @public
export interface CustomRendererSpecification {
    rendererName: string;
}

// @public
export const DEFAULT_KEYS_BATCH_SIZE = 5000;

// @public
export enum DefaultContentDisplayTypes {
    Grid = "Grid",
    List = "List",
    PropertyPane = "PropertyPane",
    Undefined = "Undefined",
    Viewport = "Graphics"
}

// @public
export interface DefaultGroupingPropertiesContainer {
    groupByClass?: boolean;
    groupByLabel?: boolean;
}

// @public
export interface DefaultPropertyCategoryOverride extends RuleBase {
    ruleType: RuleTypes.DefaultPropertyCategoryOverride;
    specification: PropertyCategorySpecification;
}

// @public
export class Descriptor implements DescriptorSource {
    constructor(source: DescriptorSource);
    readonly categories: CategoryDescription[];
    readonly connectionId?: string;
    readonly contentFlags: number;
    readonly contentOptions: any;
    createDescriptorOverrides(): DescriptorOverrides;
    readonly displayType: string;
    readonly fields: Field[];
    filterExpression?: string;
    static fromJSON(json: DescriptorJSON | undefined): Descriptor | undefined;
    getFieldByName(name: string, recurse?: boolean): Field | undefined;
    readonly inputKeysHash?: string;
    readonly selectClasses: SelectClassInfo[];
    readonly selectionInfo?: SelectionInfo;
    sortDirection?: SortDirection;
    sortingField?: Field;
    toJSON(): DescriptorJSON;
}

// @public
export interface DescriptorJSON {
    // (undocumented)
    categories: CategoryDescriptionJSON[];
    // (undocumented)
    classesMap: {
        [id: string]: CompressedClassInfoJSON;
    };
    // (undocumented)
    connectionId: string;
    // (undocumented)
    contentFlags: number;
    // (undocumented)
    contentOptions: any;
    // (undocumented)
    displayType: string;
    // (undocumented)
    fields: FieldJSON<Id64String>[];
    // (undocumented)
    filterExpression?: string;
    // (undocumented)
    inputKeysHash: string;
    // (undocumented)
    selectClasses: SelectClassInfoJSON<Id64String>[];
    // (undocumented)
    selectionInfo?: SelectionInfo;
    // (undocumented)
    sortDirection?: SortDirection;
    // (undocumented)
    sortingFieldName?: string;
}

// @public
export interface DescriptorOverrides {
    contentFlags?: number;
    displayType?: string;
    fieldsSelector?: {
        type: "include" | "exclude";
        fields: FieldDescriptor[];
    };
    filterExpression?: string;
    sorting?: {
        field: FieldDescriptor;
        direction: SortDirection;
    };
}

// @public
export interface DescriptorSource {
    readonly categories: CategoryDescription[];
    readonly connectionId?: string;
    readonly contentFlags: number;
    readonly displayType: string;
    readonly fields: Field[];
    readonly filterExpression?: string;
    readonly inputKeysHash?: string;
    readonly selectClasses: SelectClassInfo[];
    readonly selectionInfo?: SelectionInfo;
    readonly sortDirection?: SortDirection;
    readonly sortingField?: Field;
}

// @alpha (undocumented)
export type DiagnosticsHandler = (logs: DiagnosticsScopeLogs[]) => void;

// @alpha (undocumented)
export type DiagnosticsLogEntry = DiagnosticsLogMessage | DiagnosticsScopeLogs;

// @alpha (undocumented)
export namespace DiagnosticsLogEntry {
    // (undocumented)
    export function isMessage(entry: DiagnosticsLogEntry): entry is DiagnosticsLogMessage;
    // (undocumented)
    export function isScope(entry: DiagnosticsLogEntry): entry is DiagnosticsScopeLogs;
}

// @alpha (undocumented)
export type DiagnosticsLoggerSeverity = "error" | "warning" | "info" | "debug" | "trace";

// @alpha (undocumented)
export interface DiagnosticsLogMessage {
    // (undocumented)
    category: string;
    // (undocumented)
    message: string;
    // (undocumented)
    severity: {
        dev?: DiagnosticsLoggerSeverity;
        editor?: DiagnosticsLoggerSeverity;
    };
    // (undocumented)
    timestamp: number;
}

// @alpha (undocumented)
export interface DiagnosticsOptions {
    dev?: boolean | DiagnosticsLoggerSeverity;
    editor?: boolean | DiagnosticsLoggerSeverity;
    perf?: boolean;
}

// @alpha (undocumented)
export interface DiagnosticsOptionsWithHandler extends DiagnosticsOptions {
    // (undocumented)
    handler: DiagnosticsHandler;
}

// @alpha (undocumented)
export interface DiagnosticsScopeLogs {
    // (undocumented)
    duration?: number;
    // (undocumented)
    logs?: DiagnosticsLogEntry[];
    // (undocumented)
    scope: string;
}

// @public
export interface DisabledSortingRule extends SortingRuleBase {
    ruleType: RuleTypes.DisabledSorting;
}

// @public
export interface DisplayLabelRequestOptions<TIModel, TInstanceKey> extends RequestOptions<TIModel> {
    key: TInstanceKey;
}

// @public
export type DisplayLabelRpcRequestOptions = PresentationRpcRequestOptions<DisplayLabelRequestOptions<never, InstanceKeyJSON>>;

// @public
export interface DisplayLabelsRequestOptions<TIModel, TInstanceKey> extends RequestOptions<TIModel> {
    keys: TInstanceKey[];
}

// @public
export type DisplayLabelsRpcRequestOptions = PresentationRpcRequestOptions<DisplayLabelsRequestOptions<never, InstanceKeyJSON>>;

// @public
export type DisplayValue = string | undefined | DisplayValuesMap | DisplayValuesArray;

// @public (undocumented)
export namespace DisplayValue {
    export function fromJSON(json: DisplayValueJSON): DisplayValue;
    export function isArray(value: DisplayValue): value is DisplayValuesArray;
    export function isMap(value: DisplayValue): value is DisplayValuesMap;
    export function isPrimitive(value: DisplayValue): value is string | undefined;
    export function toJSON(value: DisplayValue): DisplayValueJSON;
}

// @public
export interface DisplayValueGroup {
    displayValue: DisplayValue;
    groupedRawValues: Value[];
}

// @public (undocumented)
export namespace DisplayValueGroup {
    export function fromJSON(json: DisplayValueGroupJSON): DisplayValueGroup;
    export function toJSON(group: DisplayValueGroup): DisplayValueGroupJSON;
}

// @public
export interface DisplayValueGroupJSON {
    // (undocumented)
    displayValue: DisplayValueJSON;
    // (undocumented)
    groupedRawValues: ValueJSON[];
}

// @public
export type DisplayValueJSON = string | null | DisplayValuesMapJSON | DisplayValuesArrayJSON;

// @public
export interface DisplayValuesArray extends Array<DisplayValue> {
}

// @public
export interface DisplayValuesArrayJSON extends Array<DisplayValueJSON> {
}

// @public
export interface DisplayValuesMap extends ValuesDictionary<DisplayValue> {
}

// @public
export interface DisplayValuesMapJSON extends ValuesDictionary<DisplayValueJSON> {
}

// @public
export interface DistinctValuesRequestOptions<TIModel, TDescriptor, TKeySet, TRulesetVariable = RulesetVariable> extends Paged<RequestOptionsWithRuleset<TIModel, TRulesetVariable>> {
    descriptor: TDescriptor;
    fieldDescriptor: FieldDescriptor;
    keys: TKeySet;
}

// @public
export type DistinctValuesRpcRequestOptions = PresentationRpcRequestOptions<DistinctValuesRequestOptions<never, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>>;

// @public
export interface ECClassGroupingNodeKey extends GroupingNodeKey {
    className: string;
    // (undocumented)
    type: StandardNodeTypes.ECClassGroupingNode;
}

// @public
export interface ECClassGroupingNodeKeyJSON extends GroupingNodeKeyJSON {
    // (undocumented)
    className: string;
    // (undocumented)
    type: StandardNodeTypes.ECClassGroupingNode;
}

// @public
export interface ECInstancesNodeKey extends BaseNodeKey {
    instanceKeys: InstanceKey[];
    // (undocumented)
    type: StandardNodeTypes.ECInstancesNode;
}

// @public
export interface ECInstancesNodeKeyJSON extends BaseNodeKeyJSON {
    // (undocumented)
    instanceKeys: InstanceKeyJSON[];
    // (undocumented)
    type: StandardNodeTypes.ECInstancesNode;
}

// @public
export interface ECPropertyGroupingNodeKey extends GroupingNodeKey {
    className: string;
    groupingValues: any[];
    propertyName: string;
    // (undocumented)
    type: StandardNodeTypes.ECPropertyGroupingNode;
}

// @public
export interface ECPropertyGroupingNodeKeyJSON extends GroupingNodeKeyJSON {
    // (undocumented)
    className: string;
    // (undocumented)
    groupingValues: any[];
    // (undocumented)
    propertyName: string;
    // (undocumented)
    type: StandardNodeTypes.ECPropertyGroupingNode;
}

// @public
export interface ECPropertyValueQuerySpecification extends QuerySpecificationBase {
    parentPropertyName: string;
    specType: QuerySpecificationTypes.ECPropertyValue;
}

// @public
export interface EditorDescription {
    name: string;
    params?: any;
}

// @beta
export interface ElementProperties {
    class: string;
    id: Id64String;
    items: {
        [label: string]: ElementPropertiesItem;
    };
    label: string;
}

// @beta
export type ElementPropertiesArrayPropertyItem = ElementPropertiesPrimitiveArrayPropertyItem | ElementPropertiesStructArrayPropertyItem;

// @beta
export interface ElementPropertiesArrayPropertyItemBase extends ElementPropertiesPropertyItemBase {
    type: "array";
    valueType: "primitive" | "struct";
}

// @beta
export interface ElementPropertiesCategoryItem extends ElementPropertiesItemBase {
    items: {
        [label: string]: ElementPropertiesItem;
    };
    type: "category";
}

// @beta
export type ElementPropertiesItem = ElementPropertiesCategoryItem | ElementPropertiesPropertyItem;

// @beta
export interface ElementPropertiesItemBase {
    type: "category" | ElementPropertiesPropertyValueType;
}

// @beta
export interface ElementPropertiesPrimitiveArrayPropertyItem extends ElementPropertiesArrayPropertyItemBase {
    values: string[];
    valueType: "primitive";
}

// @beta
export interface ElementPropertiesPrimitivePropertyItem extends ElementPropertiesPropertyItemBase {
    type: "primitive";
    value: string;
}

// @beta
export type ElementPropertiesPropertyItem = ElementPropertiesPrimitivePropertyItem | ElementPropertiesArrayPropertyItem | ElementPropertiesStructPropertyItem;

// @beta
export interface ElementPropertiesPropertyItemBase extends ElementPropertiesItemBase {
    type: ElementPropertiesPropertyValueType;
}

// @beta
export type ElementPropertiesPropertyValueType = "primitive" | "array" | "struct";

// @beta
export type ElementPropertiesRequestOptions<TIModel> = SingleElementPropertiesRequestOptions<TIModel> | MultiElementPropertiesRequestOptions<TIModel>;

// @beta
export type ElementPropertiesRpcRequestOptions = PresentationRpcRequestOptions<ElementPropertiesRequestOptions<never>>;

// @beta
export type ElementPropertiesRpcResult = ElementProperties | PagedResponse<ElementProperties> | undefined;

// @beta
export interface ElementPropertiesStructArrayPropertyItem extends ElementPropertiesArrayPropertyItemBase {
    values: Array<{
        [memberLabel: string]: ElementPropertiesPropertyItem;
    }>;
    valueType: "struct";
}

// @beta
export interface ElementPropertiesStructPropertyItem extends ElementPropertiesPropertyItemBase {
    members: {
        [memberLabel: string]: ElementPropertiesPropertyItem;
    };
    type: "struct";
}

// @public
export interface EnumerationChoice {
    label: string;
    value: string | number;
}

// @public
export interface EnumerationInfo {
    choices: EnumerationChoice[];
    isStrict: boolean;
}

// @alpha (undocumented)
export interface ExpandedNodeUpdateRecord {
    // (undocumented)
    node: Node;
    // (undocumented)
    position: number;
}

// @alpha (undocumented)
export namespace ExpandedNodeUpdateRecord {
    export function fromJSON(json: ExpandedNodeUpdateRecordJSON): ExpandedNodeUpdateRecord;
    export function toJSON(obj: ExpandedNodeUpdateRecord): ExpandedNodeUpdateRecordJSON;
}

// @alpha (undocumented)
export interface ExpandedNodeUpdateRecordJSON {
    // (undocumented)
    node: NodeJSON;
    // (undocumented)
    position: number;
}

// @public
export interface ExtendedDataRule extends RuleBase, ConditionContainer {
    condition?: string;
    items: {
        [key: string]: string;
    };
    ruleType: RuleTypes.ExtendedData;
}

// @public
export class Field {
    constructor(category: CategoryDescription, name: string, label: string, type: TypeDescription, isReadonly: boolean, priority: number, editor?: EditorDescription, renderer?: RendererDescription);
    category: CategoryDescription;
    // (undocumented)
    clone(): Field;
    editor?: EditorDescription;
    static fromCompressedJSON(json: FieldJSON<string> | undefined, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }, categories: CategoryDescription[]): Field | undefined;
    static fromJSON(json: FieldJSON | undefined, categories: CategoryDescription[]): Field | undefined;
    // (undocumented)
    protected static getCategoryFromFieldJson(fieldJson: FieldJSON, categories: CategoryDescription[]): CategoryDescription;
    getFieldDescriptor(): FieldDescriptor;
    isNestedContentField(): this is NestedContentField;
    isPropertiesField(): this is PropertiesField;
    isReadonly: boolean;
    label: string;
    name: string;
    get parent(): NestedContentField | undefined;
    priority: number;
    // @internal (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    renderer?: RendererDescription;
    // @internal (undocumented)
    resetParentship(): void;
    toCompressedJSON(classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): FieldJSON<string>;
    toJSON(): FieldJSON;
    type: TypeDescription;
}

// @internal (undocumented)
export const FIELD_NAMES_SEPARATOR = "$";

// @public
export type FieldDescriptor = NamedFieldDescriptor | PropertiesFieldDescriptor;

// @public (undocumented)
export namespace FieldDescriptor {
    export function isNamed(d: FieldDescriptor): d is NamedFieldDescriptor;
    export function isProperties(d: FieldDescriptor): d is PropertiesFieldDescriptor;
}

// @public
export interface FieldDescriptorBase {
    // (undocumented)
    type: FieldDescriptorType;
}

// @public
export enum FieldDescriptorType {
    // (undocumented)
    Name = "name",
    // (undocumented)
    Properties = "properties"
}

// @alpha (undocumented)
export interface FieldHierarchy {
    // (undocumented)
    childFields: FieldHierarchy[];
    // (undocumented)
    field: Field;
}

// @public
export type FieldJSON<TClassInfoJSON = ClassInfoJSON> = BaseFieldJSON | PropertiesFieldJSON<TClassInfoJSON> | NestedContentFieldJSON<TClassInfoJSON>;

// @public
export interface FilterByInstancePathsHierarchyRequestOptions<TIModel, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    instancePaths: InstanceKey[][];
    markedIndex?: number;
}

// @public
export type FilterByInstancePathsHierarchyRpcRequestOptions = PresentationRpcRequestOptions<FilterByInstancePathsHierarchyRequestOptions<never, RulesetVariableJSON>>;

// @public
export interface FilterByTextHierarchyRequestOptions<TIModel, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    filterText: string;
}

// @public
export type FilterByTextHierarchyRpcRequestOptions = PresentationRpcRequestOptions<FilterByTextHierarchyRequestOptions<never, RulesetVariableJSON>>;

// @internal (undocumented)
export const getFieldByName: (fields: Field[], name: string | undefined, recurse?: boolean | undefined) => Field | undefined;

// @public
export const getInstancesCount: (keys: Readonly<KeySet>) => number;

// @internal (undocumented)
export const getLocalesDirectory: (assetsDirectory: string) => string;

// @public
export interface GroupingNodeKey extends BaseNodeKey {
    groupedInstancesCount: number;
}

// @public
export interface GroupingNodeKeyJSON extends BaseNodeKeyJSON {
    // (undocumented)
    groupedInstancesCount: number;
}

// @public
export interface GroupingRule extends RuleBase, ConditionContainer {
    class: SingleSchemaClassSpecification;
    condition?: string;
    groups: GroupingSpecification[];
    ruleType: RuleTypes.Grouping;
}

// @public
export type GroupingSpecification = ClassGroup | PropertyGroup | SameLabelInstanceGroup;

// @public
export interface GroupingSpecificationBase {
    specType: GroupingSpecificationTypes;
}

// @public
export enum GroupingSpecificationTypes {
    // (undocumented)
    Class = "Class",
    // (undocumented)
    Property = "Property",
    // (undocumented)
    SameLabelInstance = "SameLabelInstance"
}

// @public
export interface HierarchyCompareInfo {
    changes: PartialHierarchyModification[];
    continuationToken?: {
        prevHierarchyNode: string;
        currHierarchyNode: string;
    };
}

// @public (undocumented)
export namespace HierarchyCompareInfo {
    export function fromJSON(json: HierarchyCompareInfoJSON): HierarchyCompareInfo;
    export function toJSON(obj: HierarchyCompareInfo): HierarchyCompareInfoJSON;
}

// @public
export interface HierarchyCompareInfoJSON {
    // (undocumented)
    changes: PartialHierarchyModificationJSON[];
    // (undocumented)
    continuationToken?: {
        prevHierarchyNode: string;
        currHierarchyNode: string;
    };
}

// @public
export interface HierarchyCompareOptions<TIModel, TNodeKey, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    // (undocumented)
    continuationToken?: {
        prevHierarchyNode: string;
        currHierarchyNode: string;
    };
    // (undocumented)
    expandedNodeKeys?: TNodeKey[];
    // (undocumented)
    prev: {
        rulesetOrId?: Ruleset | string;
        rulesetVariables?: TRulesetVariable[];
    };
    // (undocumented)
    resultSetSize?: number;
}

// @public
export interface HierarchyRequestOptions<TIModel, TNodeKey, TRulesetVariable = RulesetVariable> extends RequestOptionsWithRuleset<TIModel, TRulesetVariable> {
    parentKey?: TNodeKey;
}

// @public
export type HierarchyRpcRequestOptions = PresentationRpcRequestOptions<HierarchyRequestOptions<never, NodeKeyJSON, RulesetVariableJSON>>;

// @alpha (undocumented)
export type HierarchyUpdateInfo = typeof UPDATE_FULL | HierarchyUpdateRecord[];

// @alpha (undocumented)
export namespace HierarchyUpdateInfo {
    export function fromJSON(json: HierarchyUpdateInfoJSON): HierarchyUpdateInfo;
    export function toJSON(obj: HierarchyUpdateInfo): HierarchyUpdateInfoJSON;
}

// @alpha (undocumented)
export type HierarchyUpdateInfoJSON = typeof UPDATE_FULL | HierarchyUpdateRecordJSON[];

// @alpha (undocumented)
export interface HierarchyUpdateRecord {
    // (undocumented)
    expandedNodes?: ExpandedNodeUpdateRecord[];
    // (undocumented)
    nodesCount: number;
    // (undocumented)
    parent?: NodeKey;
}

// @alpha (undocumented)
export namespace HierarchyUpdateRecord {
    export function fromJSON(json: HierarchyUpdateRecordJSON): HierarchyUpdateRecord;
    export function toJSON(obj: HierarchyUpdateRecord): HierarchyUpdateRecordJSON;
}

// @alpha (undocumented)
export interface HierarchyUpdateRecordJSON {
    // (undocumented)
    expandedNodes?: ExpandedNodeUpdateRecordJSON[];
    // (undocumented)
    nodesCount: number;
    // (undocumented)
    parent?: NodeKeyJSON;
}

// @alpha (undocumented)
export interface IContentVisitor {
    // (undocumented)
    finishArray(): void;
    // (undocumented)
    finishCategory(): void;
    // (undocumented)
    finishContent(): void;
    // (undocumented)
    finishField(): void;
    // (undocumented)
    finishItem(): void;
    // (undocumented)
    finishStruct(): void;
    // (undocumented)
    processFieldHierarchies(props: ProcessFieldHierarchiesProps): void;
    // (undocumented)
    processMergedValue(props: ProcessMergedValueProps): void;
    // (undocumented)
    processPrimitiveValue(props: ProcessPrimitiveValueProps): void;
    // (undocumented)
    startArray(props: StartArrayProps): boolean;
    // (undocumented)
    startCategory(props: StartCategoryProps): boolean;
    // (undocumented)
    startContent(props: StartContentProps): boolean;
    // (undocumented)
    startField(props: StartFieldProps): boolean;
    // (undocumented)
    startItem(props: StartItemProps): boolean;
    // (undocumented)
    startStruct(props: StartStructProps): boolean;
}

// @public
export interface Id64RulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.Id64;
    // (undocumented)
    value: Id64String;
}

// @public
export interface Id64RulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.Id64;
    // (undocumented)
    value: Id64String;
}

// @public
export interface Id64sRulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.Id64Array;
    // (undocumented)
    value: Id64String[];
}

// @public
export interface Id64sRulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.Id64Array;
    // (undocumented)
    value: Id64String[] | CompressedId64Set;
}

// @public
export interface IdCategoryIdentifier {
    categoryId: string;
    type: "Id";
}

// @public
export interface ImageIdOverride extends RuleBase, ConditionContainer {
    condition?: string;
    imageIdExpression: string;
    ruleType: RuleTypes.ImageIdOverride;
}

// @public
export type InstanceId = Id64String;

// @public
export interface InstanceKey {
    className: string;
    id: InstanceId;
}

// @public (undocumented)
export namespace InstanceKey {
    export function compare(lhs: InstanceKey, rhs: InstanceKey): number;
    export function fromJSON(json: InstanceKeyJSON): {
        id: string;
        className: string;
    };
    export function toJSON(json: InstanceKey): InstanceKeyJSON;
}

// @public
export interface InstanceKeyJSON {
    // (undocumented)
    className: string;
    // (undocumented)
    id: string;
}

// @public
export interface InstanceLabelOverride extends RuleBase {
    class: SingleSchemaClassSpecification;
    ruleType: RuleTypes.InstanceLabelOverride;
    values: InstanceLabelOverrideValueSpecification[];
}

// @public
export interface InstanceLabelOverrideBriefcaseIdSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.BriefcaseId;
}

// @public
export interface InstanceLabelOverrideClassLabelSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.ClassLabel;
}

// @public
export interface InstanceLabelOverrideClassNameSpecification extends InstanceLabelOverrideValueSpecificationBase {
    full?: boolean;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.ClassName;
}

// @public
export interface InstanceLabelOverrideCompositeValueSpecification extends InstanceLabelOverrideValueSpecificationBase {
    parts: Array<{
        spec: InstanceLabelOverrideValueSpecification;
        isRequired?: boolean;
    }>;
    separator?: string;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.Composite;
}

// @public
export interface InstanceLabelOverrideLocalIdSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.LocalId;
}

// @public
export interface InstanceLabelOverridePropertyValueSpecification extends InstanceLabelOverrideValueSpecificationBase {
    propertyName: string;
    // @beta
    propertySource?: RelationshipPathSpecification;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.Property;
}

// @public
export interface InstanceLabelOverrideRelatedInstanceLabelSpecification extends InstanceLabelOverrideValueSpecificationBase {
    pathToRelatedInstance: RelationshipPathSpecification;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.RelatedInstanceLabel;
}

// @public
export interface InstanceLabelOverrideStringValueSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.String;
    value: string;
}

// @public
export type InstanceLabelOverrideValueSpecification = InstanceLabelOverrideCompositeValueSpecification | InstanceLabelOverridePropertyValueSpecification | InstanceLabelOverrideStringValueSpecification | InstanceLabelOverrideClassNameSpecification | InstanceLabelOverrideClassLabelSpecification | InstanceLabelOverrideBriefcaseIdSpecification | InstanceLabelOverrideLocalIdSpecification | InstanceLabelOverrideRelatedInstanceLabelSpecification;

// @public
export interface InstanceLabelOverrideValueSpecificationBase {
    specType: InstanceLabelOverrideValueSpecificationType;
}

// @public
export enum InstanceLabelOverrideValueSpecificationType {
    // (undocumented)
    BriefcaseId = "BriefcaseId",
    // (undocumented)
    ClassLabel = "ClassLabel",
    // (undocumented)
    ClassName = "ClassName",
    // (undocumented)
    Composite = "Composite",
    // (undocumented)
    LocalId = "LocalId",
    // (undocumented)
    Property = "Property",
    // (undocumented)
    RelatedInstanceLabel = "RelatedInstanceLabel",
    // (undocumented)
    String = "String"
}

// @public
export interface InstanceNodesOfSpecificClassesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    arePolymorphic?: boolean;
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    instanceFilter?: string;
    specType: ChildNodeSpecificationTypes.InstanceNodesOfSpecificClasses;
}

// @public
export interface IntRulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.Int;
    // (undocumented)
    value: number;
}

// @public
export interface IntRulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.Int;
    // (undocumented)
    value: number;
}

// @public
export interface IntsRulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.IntArray;
    // (undocumented)
    value: number[];
}

// @public
export interface IntsRulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.IntArray;
    // (undocumented)
    value: number[];
}

// @beta
export function isSingleElementPropertiesRequestOptions<TIModel>(options: ElementPropertiesRequestOptions<TIModel>): options is SingleElementPropertiesRequestOptions<TIModel>;

// @public
export class Item {
    constructor(primaryKeys: InstanceKey[], label: string | LabelDefinition, imageId: string, classInfo: ClassInfo | undefined, values: ValuesDictionary<Value>, displayValues: ValuesDictionary<DisplayValue>, mergedFieldNames: string[], extendedData?: {
        [key: string]: any;
    });
    classInfo?: ClassInfo;
    displayValues: ValuesDictionary<DisplayValue>;
    extendedData?: {
        [key: string]: any;
    };
    static fromJSON(json: ItemJSON | string | undefined): Item | undefined;
    imageId: string;
    // @beta
    inputKeys?: InstanceKey[];
    isFieldMerged(fieldName: string): boolean;
    label: LabelDefinition;
    mergedFieldNames: string[];
    primaryKeys: InstanceKey[];
    // @internal
    static reviver(key: string, value: any): any;
    toJSON(): ItemJSON;
    values: ValuesDictionary<Value>;
}

// @public
export interface ItemJSON {
    // (undocumented)
    classInfo?: ClassInfoJSON;
    // (undocumented)
    displayValues: ValuesDictionary<DisplayValueJSON>;
    // (undocumented)
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    imageId: string;
    // @beta (undocumented)
    inputKeys?: InstanceKeyJSON[];
    // (undocumented)
    labelDefinition: LabelDefinitionJSON;
    // (undocumented)
    mergedFieldNames: string[];
    // (undocumented)
    primaryKeys: InstanceKeyJSON[];
    // (undocumented)
    values: ValuesDictionary<ValueJSON>;
}

// @public
export type Key = Readonly<NodeKey> | Readonly<InstanceKey> | Readonly<EntityProps>;

// @public (undocumented)
export namespace Key {
    export function isEntityProps(key: Key): key is EntityProps;
    export function isInstanceKey(key: Key): key is InstanceKey;
    export function isNodeKey(key: Key): key is NodeKey;
}

// @public
export type Keys = ReadonlyArray<Key> | Readonly<KeySet>;

// @public
export class KeySet {
    constructor(source?: Keys);
    add(value: Keys | Key, pred?: (key: Key) => boolean): KeySet;
    clear(): KeySet;
    delete(value: Keys | Key): KeySet;
    forEach(callback: (key: InstanceKey | NodeKey, index: number) => void): void;
    forEachBatch(batchSize: number, callback: (batch: KeySet, index: number) => void): void;
    static fromJSON(json: KeySetJSON): KeySet;
    get guid(): GuidString;
    has(value: Key): boolean;
    hasAll(keys: Keys): boolean;
    hasAny(keys: Keys): boolean;
    get instanceKeys(): Map<string, Set<InstanceId>>;
    get instanceKeysCount(): number;
    get isEmpty(): boolean;
    get nodeKeys(): Set<NodeKey>;
    get nodeKeysCount(): number;
    get size(): number;
    some(callback: (key: Key) => boolean): boolean;
    toJSON(): KeySetJSON;
}

// @public
export interface KeySetJSON {
    instanceKeys: Array<[string, string]>;
    nodeKeys: NodeKeyJSON[];
}

// @public
export interface KindOfQuantityInfo {
    // @alpha
    activeFormat?: FormatProps;
    label: string;
    name: string;
    // @alpha
    persistenceUnit: string;
}

// @public
export interface LabelCompositeValue {
    // (undocumented)
    separator: string;
    // (undocumented)
    values: LabelDefinition[];
}

// @public (undocumented)
export namespace LabelCompositeValue {
    export function fromJSON(json: LabelCompositeValueJSON): LabelCompositeValue;
    export function toJSON(compositeValue: LabelCompositeValue): LabelCompositeValueJSON;
}

// @public
export interface LabelCompositeValueJSON {
    // (undocumented)
    separator: string;
    // (undocumented)
    values: LabelDefinitionJSON[];
}

// @public
export interface LabelDefinition {
    displayValue: string;
    rawValue: LabelRawValue;
    typeName: string;
}

// @public (undocumented)
export namespace LabelDefinition {
    export function fromJSON(json: LabelDefinitionJSON | string): LabelDefinition;
    // @internal (undocumented)
    export function fromLabelString(label: string): LabelDefinitionJSON;
    const // @internal (undocumented)
    COMPOSITE_DEFINITION_TYPENAME = "composite";
    // @internal (undocumented)
    export function isCompositeDefinition(def: LabelDefinition): def is LabelDefinition & {
        rawValue: LabelCompositeValue;
    };
    // @internal
    export function reviver(key: string, value: any): any;
    export function toJSON(labelDefinition: LabelDefinition): LabelDefinitionJSON;
}

// @public
export interface LabelDefinitionJSON {
    // (undocumented)
    displayValue: string;
    // (undocumented)
    rawValue: LabelRawValueJSON;
    // (undocumented)
    typeName: string;
}

// @public
export interface LabelGroupingNodeKey extends GroupingNodeKey {
    label: string;
    // (undocumented)
    type: StandardNodeTypes.DisplayLabelGroupingNode;
}

// @public
export interface LabelGroupingNodeKeyJSON extends GroupingNodeKeyJSON {
    // (undocumented)
    label: string;
    // (undocumented)
    type: StandardNodeTypes.DisplayLabelGroupingNode;
}

// @public
export interface LabelOverride extends RuleBase, ConditionContainer {
    condition?: string;
    description?: string;
    label?: string;
    ruleType: RuleTypes.LabelOverride;
}

// @public
export type LabelRawValue = string | number | boolean | LabelCompositeValue;

// @public
export type LabelRawValueJSON = string | number | boolean | LabelCompositeValueJSON;

// @beta
export interface MultiElementPropertiesRequestOptions<TIModel> extends Paged<RequestOptions<TIModel>> {
    elementClasses?: string[];
}

// @beta
export type MultiElementPropertiesRpcRequestOptions = PresentationRpcRequestOptions<MultiElementPropertiesRequestOptions<never>>;

// @public
export interface MultiSchemaClassesSpecification {
    classNames: string[];
    schemaName: string;
}

// @public
export interface NamedFieldDescriptor extends FieldDescriptorBase {
    // (undocumented)
    fieldName: string;
    // (undocumented)
    type: FieldDescriptorType.Name;
}

// @public
export type NavigationRule = RootNodeRule | ChildNodeRule;

// @public
export interface NavigationRuleBase extends RuleBase {
    condition?: string;
    customizationRules?: CustomizationRule[];
    specifications?: ChildNodeSpecification[];
    stopFurtherProcessing?: boolean;
    subConditions?: SubCondition[];
}

// @public
export class NestedContentField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, contentClassInfo: ClassInfo, pathToPrimaryClass: RelationshipPath, nestedFields: Field[], editor?: EditorDescription, autoExpand?: boolean, renderer?: RendererDescription);
    // @alpha (undocumented)
    actualPrimaryClassIds: Id64String[];
    autoExpand?: boolean;
    // (undocumented)
    clone(): NestedContentField;
    contentClassInfo: ClassInfo;
    static fromCompressedJSON(json: NestedContentFieldJSON<Id64String>, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }, categories: CategoryDescription[]): any;
    static fromJSON(json: NestedContentFieldJSON | undefined, categories: CategoryDescription[]): NestedContentField | undefined;
    getFieldByName(name: string, recurse?: boolean): Field | undefined;
    nestedFields: Field[];
    pathToPrimaryClass: RelationshipPath;
    // @internal (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    // @alpha (undocumented)
    relationshipMeaning: RelationshipMeaning;
    // @internal (undocumented)
    resetParentship(): void;
    toJSON(): NestedContentFieldJSON;
}

// @public
export interface NestedContentFieldJSON<TClassInfoJSON = ClassInfoJSON> extends BaseFieldJSON {
    // @alpha (undocumented)
    actualPrimaryClassIds?: Id64String[];
    // (undocumented)
    autoExpand?: boolean;
    // (undocumented)
    contentClassInfo: TClassInfoJSON;
    // (undocumented)
    nestedFields: FieldJSON<TClassInfoJSON>[];
    // (undocumented)
    pathToPrimaryClass: RelationshipPathJSON<TClassInfoJSON>;
    // @alpha (undocumented)
    relationshipMeaning?: RelationshipMeaning;
}

// @public
export interface NestedContentValue {
    displayValues: ValuesDictionary<DisplayValue>;
    mergedFieldNames: string[];
    primaryKeys: InstanceKey[];
    values: ValuesDictionary<Value>;
}

// @public (undocumented)
export namespace NestedContentValue {
    export function fromJSON(json: NestedContentValueJSON): NestedContentValue;
    export function toJSON(json: NestedContentValue): NestedContentValueJSON;
}

// @public
export interface NestedContentValueJSON {
    // (undocumented)
    displayValues: ValuesDictionary<DisplayValueJSON>;
    // (undocumented)
    mergedFieldNames: string[];
    // (undocumented)
    primaryKeys: InstanceKeyJSON[];
    // (undocumented)
    values: ValuesDictionary<ValueJSON>;
}

// @public
export interface NoCategoryIdentifier {
    type: "None";
}

// @public
export interface Node {
    backColor?: string;
    description?: string;
    extendedData?: {
        [key: string]: any;
    };
    fontStyle?: string;
    foreColor?: string;
    hasChildren?: boolean;
    imageId?: string;
    isCheckboxEnabled?: boolean;
    isCheckboxVisible?: boolean;
    isChecked?: boolean;
    isEditable?: boolean;
    isExpanded?: boolean;
    isSelectionDisabled?: boolean;
    key: NodeKey;
    label: LabelDefinition;
}

// @public (undocumented)
export namespace Node {
    export function fromJSON(json: NodeJSON | string): Node;
    // @internal (undocumented)
    export function fromPartialJSON(json: PartialNodeJSON): PartialNode;
    // @internal
    export function listFromJSON(json: NodeJSON[] | string): Node[];
    // @internal
    export function listReviver(key: string, value: any): any;
    // @internal
    export function reviver(key: string, value: any): any;
    export function toJSON(node: Node): NodeJSON;
    // @internal (undocumented)
    export function toPartialJSON(node: PartialNode): PartialNodeJSON;
}

// @public
export interface NodeArtifactsRule extends RuleBase, ConditionContainer {
    condition?: string;
    items: {
        [key: string]: string;
    };
    ruleType: RuleTypes.NodeArtifacts;
}

// @public
export interface NodeDeletionInfo {
    parent?: NodeKey;
    position: number;
    // (undocumented)
    type: "Delete";
}

// @public
export interface NodeDeletionInfoJSON {
    parent?: NodeKeyJSON;
    position: number;
    // (undocumented)
    type: "Delete";
}

// @public
export interface NodeInsertionInfo {
    node: Node;
    parent?: NodeKey;
    position: number;
    // (undocumented)
    type: "Insert";
}

// @public
export interface NodeInsertionInfoJSON {
    // (undocumented)
    node: NodeJSON;
    // (undocumented)
    parent?: NodeKeyJSON;
    // (undocumented)
    position: number;
    // (undocumented)
    type: "Insert";
}

// @public
export interface NodeJSON {
    // (undocumented)
    backColor?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    fontStyle?: string;
    // (undocumented)
    foreColor?: string;
    // (undocumented)
    hasChildren?: boolean;
    // (undocumented)
    imageId?: string;
    // (undocumented)
    isCheckboxEnabled?: boolean;
    // (undocumented)
    isCheckboxVisible?: boolean;
    // (undocumented)
    isChecked?: boolean;
    // (undocumented)
    isEditable?: boolean;
    // (undocumented)
    isExpanded?: boolean;
    // (undocumented)
    isSelectionDisabled?: boolean;
    // (undocumented)
    key: NodeKeyJSON;
    // (undocumented)
    labelDefinition: LabelDefinitionJSON;
}

// @public
export type NodeKey = BaseNodeKey | ECInstancesNodeKey | ECClassGroupingNodeKey | ECPropertyGroupingNodeKey | LabelGroupingNodeKey;

// @public (undocumented)
export namespace NodeKey {
    export function equals(lhs: NodeKey, rhs: NodeKey): boolean;
    export function fromJSON(json: NodeKeyJSON): NodeKey;
    export function isClassGroupingNodeKey(key: NodeKey): key is ECClassGroupingNodeKey;
    export function isClassGroupingNodeKey(key: NodeKeyJSON): key is ECClassGroupingNodeKeyJSON;
    export function isGroupingNodeKey(key: NodeKey): key is GroupingNodeKey;
    export function isGroupingNodeKey(key: NodeKeyJSON): key is GroupingNodeKeyJSON;
    export function isInstancesNodeKey(key: NodeKey): key is ECInstancesNodeKey;
    export function isInstancesNodeKey(key: NodeKeyJSON): key is ECInstancesNodeKeyJSON;
    export function isLabelGroupingNodeKey(key: NodeKey): key is LabelGroupingNodeKey;
    export function isLabelGroupingNodeKey(key: NodeKeyJSON): key is LabelGroupingNodeKeyJSON;
    export function isPropertyGroupingNodeKey(key: NodeKey): key is ECPropertyGroupingNodeKey;
    export function isPropertyGroupingNodeKey(key: NodeKeyJSON): key is ECPropertyGroupingNodeKeyJSON;
    export function toJSON(key: NodeKey): NodeKeyJSON;
}

// @public
export type NodeKeyJSON = BaseNodeKeyJSON | ECInstancesNodeKeyJSON | ECClassGroupingNodeKeyJSON | ECPropertyGroupingNodeKeyJSON | LabelGroupingNodeKeyJSON;

// @public
export type NodeKeyPath = NodeKey[];

// @public
export interface NodePathElement {
    children: NodePathElement[];
    filteringData?: NodePathFilteringData;
    index: number;
    isMarked?: boolean;
    node: Node;
}

// @public (undocumented)
export namespace NodePathElement {
    export function fromJSON(json: NodePathElementJSON | string): NodePathElement;
    // @internal
    export function listFromJSON(json: NodePathElementJSON[] | string): NodePathElement[];
    // @internal
    export function listReviver(key: string, value: any): any;
    // @internal
    export function reviver(key: string, value: any): any;
    export function toJSON(npe: NodePathElement): NodePathElementJSON;
}

// @public
export interface NodePathElementJSON {
    // (undocumented)
    children: NodePathElementJSON[];
    // (undocumented)
    filteringData?: NodePathFilteringDataJSON;
    // (undocumented)
    index: number;
    // (undocumented)
    isMarked?: boolean;
    // (undocumented)
    node: NodeJSON;
}

// @public
export interface NodePathFilteringData {
    childMatchesCount: number;
    matchesCount: number;
}

// @public (undocumented)
export namespace NodePathFilteringData {
    export function fromJSON(json: NodePathFilteringDataJSON): NodePathFilteringData;
    export function toJSON(npfd: NodePathFilteringData): NodePathFilteringDataJSON;
}

// @public
export interface NodePathFilteringDataJSON {
    // (undocumented)
    childrenOccurances: number;
    // (undocumented)
    occurances: number;
}

// @public
export interface NodeUpdateInfo {
    changes: PartialNode;
    target: NodeKey;
    // (undocumented)
    type: "Update";
}

// @public
export interface NodeUpdateInfoJSON {
    // (undocumented)
    changes: PartialNodeJSON;
    // (undocumented)
    target: NodeKeyJSON;
    // (undocumented)
    type: "Update";
}

// @public
export type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;

// @public
export type Paged<TOptions extends {}> = TOptions & {
    paging?: PageOptions;
};

// @public
export interface PagedResponse<T> {
    items: T[];
    total: number;
}

// @public
export interface PageOptions {
    size?: number;
    start?: number;
}

// @public
export interface ParentCategoryIdentifier {
    type: "DefaultParent";
}

// @public
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// @public
export type PartialHierarchyModification = NodeInsertionInfo | NodeDeletionInfo | NodeUpdateInfo;

// @public (undocumented)
export namespace PartialHierarchyModification {
    export function fromJSON(json: PartialHierarchyModificationJSON): PartialHierarchyModification;
    export function toJSON(obj: PartialHierarchyModification): PartialHierarchyModificationJSON;
}

// @public
export type PartialHierarchyModificationJSON = NodeInsertionInfoJSON | NodeDeletionInfoJSON | NodeUpdateInfoJSON;

// @public
export type PartialNode = AllOrNone<Partial<Node>, "key" | "label">;

// @public
export type PartialNodeJSON = AllOrNone<Partial<NodeJSON>, "key" | "labelDefinition">;

// @internal (undocumented)
export const PRESENTATION_COMMON_ROOT: string;

// @internal (undocumented)
export const PRESENTATION_IPC_CHANNEL_NAME = "presentation-ipc-interface";

// @public
export class PresentationError extends BentleyError {
    constructor(errorNumber: PresentationStatus, message?: string, getMetaData?: GetMetaDataFunction);
    protected _initName(): string;
}

// @alpha (undocumented)
export enum PresentationIpcEvents {
    Update = "presentation.onUpdate"
}

// @internal (undocumented)
export interface PresentationIpcInterface {
    setRulesetVariable(params: SetRulesetVariableParams<RulesetVariableJSON>): Promise<void>;
    unsetRulesetVariable(params: UnsetRulesetVariableParams): Promise<void>;
    updateHierarchyState(params: UpdateHierarchyStateParams<NodeKeyJSON>): Promise<void>;
}

// @public
export class PresentationRpcInterface extends RpcInterface {
    // (undocumented)
    computeSelection(_token: IModelRpcProps, _options: SelectionScopeRpcRequestOptions, _ids: Id64String[], _scopeId: string): PresentationRpcResponse<KeySetJSON>;
    // (undocumented)
    getContentDescriptor(_token: IModelRpcProps, _options: ContentDescriptorRpcRequestOptions): PresentationRpcResponse<DescriptorJSON | undefined>;
    // (undocumented)
    getContentSetSize(_token: IModelRpcProps, _options: ContentRpcRequestOptions): PresentationRpcResponse<number>;
    // @beta (undocumented)
    getContentSources(_token: IModelRpcProps, _options: ContentSourcesRpcRequestOptions): PresentationRpcResponse<ContentSourcesRpcResult>;
    // (undocumented)
    getDisplayLabelDefinition(_token: IModelRpcProps, _options: DisplayLabelRpcRequestOptions): PresentationRpcResponse<LabelDefinitionJSON>;
    // @beta (undocumented)
    getElementProperties(_token: IModelRpcProps, _options: SingleElementPropertiesRpcRequestOptions): PresentationRpcResponse<ElementProperties | undefined>;
    // @alpha (undocumented)
    getElementProperties(_token: IModelRpcProps, _options: MultiElementPropertiesRpcRequestOptions): PresentationRpcResponse<PagedResponse<ElementProperties>>;
    // (undocumented)
    getFilteredNodePaths(_token: IModelRpcProps, _options: FilterByTextHierarchyRpcRequestOptions): PresentationRpcResponse<NodePathElementJSON[]>;
    // (undocumented)
    getNodePaths(_token: IModelRpcProps, _options: FilterByInstancePathsHierarchyRpcRequestOptions): PresentationRpcResponse<NodePathElementJSON[]>;
    // (undocumented)
    getNodesCount(_token: IModelRpcProps, _options: HierarchyRpcRequestOptions): PresentationRpcResponse<number>;
    // (undocumented)
    getPagedContent(_token: IModelRpcProps, _options: Paged<ContentRpcRequestOptions>): PresentationRpcResponse<{
        descriptor: DescriptorJSON;
        contentSet: PagedResponse<ItemJSON>;
    } | undefined>;
    // (undocumented)
    getPagedContentSet(_token: IModelRpcProps, _options: Paged<ContentRpcRequestOptions>): PresentationRpcResponse<PagedResponse<ItemJSON>>;
    // (undocumented)
    getPagedDisplayLabelDefinitions(_token: IModelRpcProps, _options: DisplayLabelsRpcRequestOptions): PresentationRpcResponse<PagedResponse<LabelDefinitionJSON>>;
    // (undocumented)
    getPagedDistinctValues(_token: IModelRpcProps, _options: DistinctValuesRpcRequestOptions): PresentationRpcResponse<PagedResponse<DisplayValueGroupJSON>>;
    // (undocumented)
    getPagedNodes(_token: IModelRpcProps, _options: Paged<HierarchyRpcRequestOptions>): PresentationRpcResponse<PagedResponse<NodeJSON>>;
    // (undocumented)
    getSelectionScopes(_token: IModelRpcProps, _options: SelectionScopeRpcRequestOptions): PresentationRpcResponse<SelectionScope[]>;
    static readonly interfaceName = "PresentationRpcInterface";
    static interfaceVersion: string;
}

// @public
export type PresentationRpcRequestOptions<TManagerRequestOptions> = Omit<TManagerRequestOptions, "imodel" | "diagnostics"> & {
    clientId?: string;
    diagnostics?: DiagnosticsOptions;
};

// @public
export type PresentationRpcResponse<TResult = undefined> = Promise<{
    statusCode: PresentationStatus;
    errorMessage?: string;
    result?: TResult;
    diagnostics?: DiagnosticsScopeLogs[];
}>;

// @public
export enum PresentationStatus {
    BackendTimeout = 65543,
    Canceled = 1,
    Error = 65536,
    InvalidArgument = 65539,
    NotInitialized = 65537,
    Success = 0
}

// @public
export type PrimitivePropertyValue = string | number | boolean | Point | InstanceKey | undefined;

// @public
export interface PrimitiveTypeDescription extends BaseTypeDescription {
    valueFormat: PropertyValueFormat.Primitive;
}

// @public
export type Prioritized<TOptions extends {}> = TOptions & {
    priority?: number;
};

// @alpha (undocumented)
export interface ProcessFieldHierarchiesProps {
    // (undocumented)
    hierarchies: FieldHierarchy[];
}

// @alpha (undocumented)
export interface ProcessMergedValueProps {
    // (undocumented)
    mergedField: Field;
    // (undocumented)
    namePrefix?: string;
    // (undocumented)
    requestedField: Field;
}

// @alpha (undocumented)
export interface ProcessPrimitiveValueProps {
    // (undocumented)
    displayValue: DisplayValue;
    // (undocumented)
    field: Field;
    // (undocumented)
    namePrefix?: string;
    // (undocumented)
    rawValue: Value;
    // (undocumented)
    valueType: TypeDescription;
}

// @public
export class PropertiesField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, properties: Property[], editor?: EditorDescription, renderer?: RendererDescription);
    // (undocumented)
    clone(): PropertiesField;
    static fromCompressedJSON(json: PropertiesFieldJSON<Id64String>, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }, categories: CategoryDescription[]): PropertiesField | undefined;
    static fromJSON(json: PropertiesFieldJSON | undefined, categories: CategoryDescription[]): PropertiesField | undefined;
    getFieldDescriptor(): FieldDescriptor;
    properties: Property[];
    toJSON(): PropertiesFieldJSON;
}

// @public
export interface PropertiesFieldDescriptor extends FieldDescriptorBase {
    // (undocumented)
    pathFromSelectToPropertyClass: StrippedRelationshipPath;
    properties: Array<{
        class: string;
        name: string;
    }>;
    // (undocumented)
    type: FieldDescriptorType.Properties;
}

// @public
export interface PropertiesFieldJSON<TClassInfoJSON = ClassInfoJSON> extends BaseFieldJSON {
    // (undocumented)
    properties: PropertyJSON<TClassInfoJSON>[];
}

// @public
export interface Property {
    property: PropertyInfo;
}

// @public (undocumented)
export namespace Property {
    export function fromJSON(json: PropertyJSON): Property;
    export function toCompressedJSON(prop: Property, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): PropertyJSON<string>;
    export function toJSON(prop: Property): PropertyJSON;
}

// @public
export interface PropertyAccessor {
    arrayIndex?: number;
    propertyName: string;
}

// @public
export type PropertyAccessorPath = PropertyAccessor[];

// @public
export interface PropertyCategorySpecification {
    autoExpand?: boolean;
    description?: string;
    id: string;
    label: string;
    parentId?: string | CategoryIdentifier | NoCategoryIdentifier;
    priority?: number;
    renderer?: CustomRendererSpecification;
}

// @public
export interface PropertyEditorJsonParameters extends PropertyEditorParametersBase {
    json: any;
    paramsType: PropertyEditorParameterTypes.Json;
}

// @public
export interface PropertyEditorMultilineParameters extends PropertyEditorParametersBase {
    height?: number;
    paramsType: PropertyEditorParameterTypes.Multiline;
}

// @public
export type PropertyEditorParameters = PropertyEditorJsonParameters | PropertyEditorMultilineParameters | PropertyEditorRangeParameters | PropertyEditorSliderParameters;

// @public
export interface PropertyEditorParametersBase {
    paramsType: PropertyEditorParameterTypes;
}

// @public
export enum PropertyEditorParameterTypes {
    // (undocumented)
    Json = "Json",
    // (undocumented)
    Multiline = "Multiline",
    // (undocumented)
    Range = "Range",
    // (undocumented)
    Slider = "Slider"
}

// @public
export interface PropertyEditorRangeParameters extends PropertyEditorParametersBase {
    max?: number;
    min?: number;
    paramsType: PropertyEditorParameterTypes.Range;
}

// @public
export interface PropertyEditorSliderParameters extends PropertyEditorParametersBase {
    intervalsCount?: number;
    isVertical?: boolean;
    max: number;
    min: number;
    paramsType: PropertyEditorParameterTypes.Slider;
}

// @public
export interface PropertyEditorSpecification {
    editorName: string;
    parameters?: PropertyEditorParameters[];
}

// @public
export interface PropertyGroup extends GroupingSpecificationBase {
    createGroupForSingleItem?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    groupingValue?: PropertyGroupingValue;
    imageId?: string;
    propertyName: string;
    ranges?: PropertyRangeGroupSpecification[];
    sortingValue?: PropertyGroupingValue;
    specType: GroupingSpecificationTypes.Property;
}

// @public
export enum PropertyGroupingValue {
    DisplayLabel = "DisplayLabel",
    PropertyValue = "PropertyValue"
}

// @public
export interface PropertyInfo {
    classInfo: ClassInfo;
    enumerationInfo?: EnumerationInfo;
    extendedType?: string;
    // @alpha
    kindOfQuantity?: KindOfQuantityInfo;
    name: string;
    type: string;
}

// @public (undocumented)
export namespace PropertyInfo {
    export function fromJSON(json: PropertyInfoJSON): PropertyInfo;
    export function toCompressedJSON(propertyInfo: PropertyInfo, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): PropertyInfoJSON<string>;
    export function toJSON(info: PropertyInfo): PropertyInfoJSON;
}

// @public
export interface PropertyInfoJSON<TClassInfoJSON = ClassInfoJSON> {
    // (undocumented)
    classInfo: TClassInfoJSON;
    // (undocumented)
    enumerationInfo?: EnumerationInfo;
    // (undocumented)
    kindOfQuantity?: KindOfQuantityInfo;
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
}

// @public
export interface PropertyJSON<TClassInfoJSON = ClassInfoJSON> {
    // (undocumented)
    property: PropertyInfoJSON<TClassInfoJSON>;
}

// @public
export interface PropertyOverrides {
    categoryId?: string | CategoryIdentifier;
    doNotHideOtherPropertiesOnDisplayOverride?: boolean;
    editor?: PropertyEditorSpecification;
    isDisplayed?: boolean;
    labelOverride?: string;
    overridesPriority?: number;
    renderer?: CustomRendererSpecification;
}

// @public
export interface PropertyRangeGroupSpecification {
    fromValue: string;
    imageId?: string;
    label?: string;
    toValue: string;
}

// @public
export interface PropertySortingRule extends SortingRuleBase {
    propertyName: string;
    ruleType: RuleTypes.PropertySorting;
    sortAscending?: boolean;
}

// @public
export interface PropertySpecification extends PropertyOverrides {
    name: string;
}

// @public
export enum PropertyValueFormat {
    Array = "Array",
    Primitive = "Primitive",
    Struct = "Struct"
}

// @public
export type QuerySpecification = StringQuerySpecification | ECPropertyValueQuerySpecification;

// @public
export interface QuerySpecificationBase {
    class: SingleSchemaClassSpecification;
    specType: QuerySpecificationTypes;
}

// @public
export enum QuerySpecificationTypes {
    // (undocumented)
    ECPropertyValue = "ECPropertyValue",
    // (undocumented)
    String = "String"
}

// @public
export class RegisteredRuleset implements IDisposable, Ruleset {
    constructor(ruleset: Ruleset, uniqueIdentifier: string, disposeFunc: (ruleset: RegisteredRuleset) => void);
    dispose(): void;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get rules(): Rule[];
    // (undocumented)
    get supplementationInfo(): SupplementationInfo | undefined;
    // (undocumented)
    toJSON(): Ruleset;
    // (undocumented)
    get uniqueIdentifier(): string;
    // (undocumented)
    get vars(): VariablesGroup[] | undefined;
}

// @public
export interface RelatedClassInfo {
    isForwardRelationship: boolean;
    isPolymorphicRelationship: boolean;
    isPolymorphicTargetClass: boolean;
    relationshipInfo: ClassInfo;
    sourceClassInfo: ClassInfo;
    targetClassInfo: ClassInfo;
}

// @public (undocumented)
export namespace RelatedClassInfo {
    export function equals(lhs: RelatedClassInfo | StrippedRelatedClassInfo, rhs: RelatedClassInfo | StrippedRelatedClassInfo): boolean;
    export function fromCompressedJSON(json: RelatedClassInfoJSON<string>, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): RelatedClassInfo;
    export function fromJSON(json: RelatedClassInfoJSON): RelatedClassInfo;
    export function strip(full: RelatedClassInfo): StrippedRelatedClassInfo;
    export function toCompressedJSON(classInfo: RelatedClassInfo, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): RelatedClassInfoJSON<string>;
    export function toJSON(info: RelatedClassInfo): RelatedClassInfoJSON;
}

// @public
export interface RelatedClassInfoJSON<TClassInfoJSON = ClassInfoJSON> {
    // (undocumented)
    isForwardRelationship: boolean;
    // (undocumented)
    isPolymorphicRelationship?: boolean;
    // (undocumented)
    isPolymorphicTargetClass?: boolean;
    // (undocumented)
    relationshipInfo: TClassInfoJSON;
    // (undocumented)
    sourceClassInfo: TClassInfoJSON;
    // (undocumented)
    targetClassInfo: TClassInfoJSON;
}

// @public
export type RelatedClassInfoWithOptionalRelationship = PartialBy<RelatedClassInfo, "relationshipInfo" | "isForwardRelationship" | "isPolymorphicRelationship">;

// @public (undocumented)
export namespace RelatedClassInfoWithOptionalRelationship {
    export function fromCompressedJSON(json: RelatedClassInfoWithOptionalRelationshipJSON<string>, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): RelatedClassInfoWithOptionalRelationship;
    export function toCompressedJSON(classInfo: RelatedClassInfoWithOptionalRelationship, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): RelatedClassInfoWithOptionalRelationshipJSON<string>;
}

// @public (undocumented)
export type RelatedClassInfoWithOptionalRelationshipJSON<TClassInfoJSON = ClassInfoJSON> = PartialBy<RelatedClassInfoJSON<TClassInfoJSON>, "relationshipInfo" | "isForwardRelationship" | "isPolymorphicRelationship">;

// @public
export interface RelatedInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    instanceFilter?: string;
    relationshipPaths: RepeatableRelationshipPathSpecification[];
    specType: ChildNodeSpecificationTypes.RelatedInstanceNodes;
}

// @public
export interface RelatedInstanceSpecification {
    alias: string;
    isRequired?: boolean;
    relationshipPath: RelationshipPathSpecification;
}

// @public
export enum RelatedPropertiesSpecialValues {
    All = "*",
    None = "_none_"
}

// @public
export interface RelatedPropertiesSpecification {
    autoExpand?: boolean;
    handleTargetClassPolymorphically?: boolean;
    nestedRelatedProperties?: RelatedPropertiesSpecification[];
    properties?: Array<string | PropertySpecification> | RelatedPropertiesSpecialValues;
    propertiesSource: RelationshipPathSpecification;
    relationshipMeaning?: RelationshipMeaning;
    // @beta
    skipIfDuplicate?: boolean;
}

// @public
export enum RelationshipDirection {
    Backward = "Backward",
    Forward = "Forward"
}

// @public
export enum RelationshipMeaning {
    RelatedInstance = "RelatedInstance",
    SameInstance = "SameInstance"
}

// @public
export type RelationshipPath = RelatedClassInfo[];

// @public (undocumented)
export namespace RelationshipPath {
    export function equals(lhs: Array<RelatedClassInfo | StrippedRelatedClassInfo>, rhs: Array<RelatedClassInfo | StrippedRelatedClassInfo>): boolean;
    export function reverse(path: RelationshipPath): RelationshipPath;
    export function strip(full: RelationshipPath): StrippedRelationshipPath;
}

// @public
export type RelationshipPathJSON<TClassInfoJSON = ClassInfoJSON> = RelatedClassInfoJSON<TClassInfoJSON>[];

// @public
export type RelationshipPathSpecification = RelationshipStepSpecification | RelationshipStepSpecification[];

// @public
export interface RelationshipStepSpecification {
    direction: RelationshipDirection.Forward | RelationshipDirection.Backward;
    relationship: SingleSchemaClassSpecification;
    targetClass?: SingleSchemaClassSpecification;
}

// @public
export interface RendererDescription {
    name: string;
}

// @public
export type RepeatableRelationshipPathSpecification = RepeatableRelationshipStepSpecification | RepeatableRelationshipStepSpecification[];

// @public
export interface RepeatableRelationshipStepSpecification extends RelationshipStepSpecification {
    count?: number | "*";
}

// @public
export interface RequestOptions<TIModel> {
    // @alpha (undocumented)
    diagnostics?: DiagnosticsOptionsWithHandler;
    imodel: TIModel;
    locale?: string;
    unitSystem?: UnitSystemKey;
}

// @public
export interface RequestOptionsWithRuleset<TIModel, TRulesetVariable = RulesetVariable> extends RequestOptions<TIModel> {
    rulesetOrId: Ruleset | string;
    rulesetVariables?: TRulesetVariable[];
}

// @beta
export interface RequiredSchemaSpecification {
    maxVersion?: string;
    minVersion?: string;
    name: string;
}

// @public
export interface RootCategoryIdentifier {
    type: "Root";
}

// @public
export interface RootNodeRule extends NavigationRuleBase {
    autoExpand?: boolean;
    ruleType: RuleTypes.RootNodes;
}

// @internal
export class RpcRequestsHandler implements IDisposable {
    constructor(props?: RpcRequestsHandlerProps);
    readonly clientId: string;
    // (undocumented)
    computeSelection(options: SelectionScopeRequestOptions<IModelRpcProps>, ids: Id64String[], scopeId: string): Promise<KeySetJSON>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getContentDescriptor(options: ContentDescriptorRequestOptions<IModelRpcProps, KeySetJSON, RulesetVariableJSON>): Promise<DescriptorJSON | undefined>;
    // (undocumented)
    getContentSetSize(options: ContentRequestOptions<IModelRpcProps, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>): Promise<number>;
    // (undocumented)
    getContentSources(options: ContentSourcesRequestOptions<IModelRpcProps>): Promise<ContentSourcesRpcResult>;
    // (undocumented)
    getDisplayLabelDefinition(options: DisplayLabelRequestOptions<IModelRpcProps, InstanceKeyJSON>): Promise<LabelDefinitionJSON>;
    // (undocumented)
    getElementProperties(options: SingleElementPropertiesRequestOptions<IModelRpcProps>): Promise<ElementProperties | undefined>;
    // (undocumented)
    getElementProperties(options: MultiElementPropertiesRequestOptions<IModelRpcProps>): Promise<PagedResponse<ElementProperties>>;
    // (undocumented)
    getFilteredNodePaths(options: FilterByTextHierarchyRequestOptions<IModelRpcProps, RulesetVariableJSON>): Promise<NodePathElementJSON[]>;
    // (undocumented)
    getNodePaths(options: FilterByInstancePathsHierarchyRequestOptions<IModelRpcProps, RulesetVariableJSON>): Promise<NodePathElementJSON[]>;
    // (undocumented)
    getNodesCount(options: HierarchyRequestOptions<IModelRpcProps, NodeKeyJSON, RulesetVariableJSON>): Promise<number>;
    // (undocumented)
    getPagedContent(options: Paged<ContentRequestOptions<IModelRpcProps, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>>): Promise<{
        descriptor: DescriptorJSON;
        contentSet: PagedResponse<ItemJSON>;
    } | undefined>;
    // (undocumented)
    getPagedContentSet(options: Paged<ContentRequestOptions<IModelRpcProps, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>>): Promise<PagedResponse<ItemJSON>>;
    // (undocumented)
    getPagedDisplayLabelDefinitions(options: DisplayLabelsRequestOptions<IModelRpcProps, InstanceKeyJSON>): Promise<PagedResponse<LabelDefinitionJSON>>;
    // (undocumented)
    getPagedDistinctValues(options: DistinctValuesRequestOptions<IModelRpcProps, DescriptorOverrides, KeySetJSON, RulesetVariableJSON>): Promise<PagedResponse<DisplayValueGroupJSON>>;
    // (undocumented)
    getPagedNodes(options: Paged<HierarchyRequestOptions<IModelRpcProps, NodeKeyJSON, RulesetVariableJSON>>): Promise<PagedResponse<NodeJSON>>;
    // (undocumented)
    getSelectionScopes(options: SelectionScopeRequestOptions<IModelRpcProps>): Promise<SelectionScope[]>;
    request<TResult, TOptions extends RequestOptions<IModelRpcProps>, TArg = any>(func: (token: IModelRpcProps, options: PresentationRpcRequestOptions<TOptions>, ...args: TArg[]) => PresentationRpcResponse<TResult>, options: TOptions, ...additionalOptions: TArg[]): Promise<TResult>;
    }

// @internal
export interface RpcRequestsHandlerProps {
    clientId?: string;
}

// @public
export type Rule = CustomizationRule | NavigationRule | ContentRule | ContentModifier | DefaultPropertyCategoryOverride;

// @public
export interface RuleBase {
    onlyIfNotHandled?: boolean;
    priority?: number;
    // @beta
    requiredSchemas?: RequiredSchemaSpecification[];
    ruleType: RuleTypes;
}

// @public
export interface Ruleset {
    id: string;
    // @beta
    requiredSchemas?: RequiredSchemaSpecification[];
    rules: Rule[];
    supplementationInfo?: SupplementationInfo;
    vars?: VariablesGroup[];
    // @beta
    version?: string;
}

// @public
export class RulesetsFactory {
    createSimilarInstancesRuleset(field: Field, record: Item, computeDisplayValue?: ComputeDisplayValueCallback): Promise<{
        ruleset: Ruleset;
        description: string;
    }>;
    }

// @public
export type RulesetVariable = BooleanRulesetVariable | StringRulesetVariable | IntRulesetVariable | IntsRulesetVariable | Id64RulesetVariable | Id64sRulesetVariable;

// @public (undocumented)
export namespace RulesetVariable {
    export function fromJSON(json: RulesetVariableJSON): RulesetVariable;
    export function toJSON(variable: RulesetVariable): RulesetVariableJSON;
}

// @public
export interface RulesetVariableBase {
    // (undocumented)
    id: string;
    // (undocumented)
    type: VariableValueTypes;
    // (undocumented)
    value: VariableValue;
}

// @public
export interface RulesetVariableBaseJSON {
    // (undocumented)
    id: string;
    // (undocumented)
    type: VariableValueTypes;
    // (undocumented)
    value: VariableValueJSON;
}

// @public
export type RulesetVariableJSON = BooleanRulesetVariableJSON | StringRulesetVariableJSON | IntRulesetVariableJSON | IntsRulesetVariableJSON | Id64RulesetVariableJSON | Id64sRulesetVariableJSON;

// @public
export enum RuleTypes {
    // (undocumented)
    CheckBox = "CheckBox",
    // (undocumented)
    ChildNodes = "ChildNodes",
    // (undocumented)
    Content = "Content",
    // (undocumented)
    ContentModifier = "ContentModifier",
    // (undocumented)
    DefaultPropertyCategoryOverride = "DefaultPropertyCategoryOverride",
    // (undocumented)
    DisabledSorting = "DisabledSorting",
    // (undocumented)
    ExtendedData = "ExtendedData",
    // (undocumented)
    Grouping = "Grouping",
    // (undocumented)
    ImageIdOverride = "ImageIdOverride",
    // (undocumented)
    InstanceLabelOverride = "InstanceLabelOverride",
    // (undocumented)
    LabelOverride = "LabelOverride",
    // (undocumented)
    NodeArtifacts = "NodeArtifacts",
    // (undocumented)
    PropertySorting = "PropertySorting",
    // (undocumented)
    RootNodes = "RootNodes",
    // (undocumented)
    StyleOverride = "StyleOverride"
}

// @public
export interface SameLabelInstanceGroup extends GroupingSpecificationBase {
    applicationStage?: SameLabelInstanceGroupApplicationStage;
    specType: GroupingSpecificationTypes.SameLabelInstance;
}

// @public
export enum SameLabelInstanceGroupApplicationStage {
    PostProcess = "PostProcess",
    Query = "Query"
}

// @public
export interface SchemasSpecification {
    isExclude?: boolean;
    schemaNames: string[];
}

// @public
export interface SelectClassInfo {
    isSelectPolymorphic: boolean;
    navigationPropertyClasses?: RelatedClassInfo[];
    pathFromInputToSelectClass?: RelatedClassInfoWithOptionalRelationship[];
    relatedInstancePaths?: RelationshipPath[];
    relatedPropertyPaths?: RelationshipPath[];
    selectClassInfo: ClassInfo;
}

// @public (undocumented)
export namespace SelectClassInfo {
    export function fromCompressedJSON(json: SelectClassInfoJSON<string>, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): SelectClassInfo;
    // @internal
    export function listFromCompressedJSON(json: SelectClassInfoJSON<Id64String>[], classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): SelectClassInfo[];
    export function toCompressedJSON(selectClass: SelectClassInfo, classesMap: {
        [id: string]: CompressedClassInfoJSON;
    }): SelectClassInfoJSON<string>;
}

// @public
export interface SelectClassInfoJSON<TClassInfoJSON = ClassInfoJSON> {
    // (undocumented)
    isSelectPolymorphic: boolean;
    // (undocumented)
    navigationPropertyClasses?: RelatedClassInfoJSON<TClassInfoJSON>[];
    // (undocumented)
    pathFromInputToSelectClass?: RelatedClassInfoWithOptionalRelationshipJSON<TClassInfoJSON>[];
    // (undocumented)
    relatedInstancePaths?: RelationshipPathJSON<TClassInfoJSON>[];
    // (undocumented)
    relatedPropertyPaths?: RelationshipPathJSON<TClassInfoJSON>[];
    // (undocumented)
    selectClassInfo: TClassInfoJSON;
}

// @public
export interface SelectedNodeInstancesSpecification extends ContentSpecificationBase {
    acceptableClassNames?: string[];
    acceptablePolymorphically?: boolean;
    acceptableSchemaName?: string;
    onlyIfNotHandled?: boolean;
    specType: ContentSpecificationTypes.SelectedNodeInstances;
}

// @public
export interface SelectionInfo {
    level?: number;
    providerName: string;
}

// @public
export interface SelectionScope {
    description?: string;
    id: string;
    label: string;
}

// @public
export interface SelectionScopeRequestOptions<TIModel> extends RequestOptions<TIModel> {
}

// @public
export type SelectionScopeRpcRequestOptions = PresentationRpcRequestOptions<SelectionScopeRequestOptions<never>>;

// @internal (undocumented)
export interface SetRulesetVariableParams<TVariable> extends CommonIpcParams {
    // (undocumented)
    rulesetId: string;
    // (undocumented)
    variable: TVariable;
}

// @beta
export interface SingleElementPropertiesRequestOptions<TIModel> extends RequestOptions<TIModel> {
    elementId: Id64String;
}

// @beta
export type SingleElementPropertiesRpcRequestOptions = PresentationRpcRequestOptions<SingleElementPropertiesRequestOptions<never>>;

// @public
export interface SingleSchemaClassSpecification {
    className: string;
    schemaName: string;
}

// @public
export enum SortDirection {
    // (undocumented)
    Ascending = 0,
    // (undocumented)
    Descending = 1
}

// @public
export type SortingRule = PropertySortingRule | DisabledSortingRule;

// @public
export interface SortingRuleBase extends RuleBase, ConditionContainer {
    class?: SingleSchemaClassSpecification;
    condition?: string;
    isPolymorphic?: boolean;
}

// @public
export enum StandardNodeTypes {
    // (undocumented)
    DisplayLabelGroupingNode = "DisplayLabelGroupingNode",
    // (undocumented)
    ECClassGroupingNode = "ECClassGroupingNode",
    // (undocumented)
    ECInstancesNode = "ECInstancesNode",
    // (undocumented)
    ECPropertyGroupingNode = "ECPropertyGroupingNode"
}

// @alpha (undocumented)
export interface StartArrayProps {
    // (undocumented)
    displayValues: DisplayValuesArray;
    // (undocumented)
    hierarchy: FieldHierarchy;
    // (undocumented)
    namePrefix?: string;
    // (undocumented)
    rawValues: ValuesArray;
    // (undocumented)
    valueType: TypeDescription;
}

// @alpha (undocumented)
export interface StartCategoryProps {
    // (undocumented)
    category: CategoryDescription;
}

// @alpha (undocumented)
export interface StartContentProps {
    // (undocumented)
    descriptor: Descriptor;
}

// @alpha (undocumented)
export interface StartFieldProps {
    // (undocumented)
    hierarchy: FieldHierarchy;
}

// @alpha (undocumented)
export interface StartItemProps {
    // (undocumented)
    item: Item;
}

// @alpha (undocumented)
export interface StartStructProps {
    // (undocumented)
    displayValues: DisplayValuesMap;
    // (undocumented)
    hierarchy: FieldHierarchy;
    // (undocumented)
    namePrefix?: string;
    // (undocumented)
    rawValues: ValuesMap;
    // (undocumented)
    valueType: TypeDescription;
}

// @public
export interface StringQuerySpecification extends QuerySpecificationBase {
    query: string;
    specType: QuerySpecificationTypes.String;
}

// @public
export interface StringRulesetVariable extends RulesetVariableBase {
    // (undocumented)
    type: VariableValueTypes.String;
    // (undocumented)
    value: string;
}

// @public
export interface StringRulesetVariableJSON extends RulesetVariableBaseJSON {
    // (undocumented)
    type: VariableValueTypes.String;
    // (undocumented)
    value: string;
}

// @public
export interface StrippedRelatedClassInfo {
    // (undocumented)
    isForwardRelationship: boolean;
    // (undocumented)
    relationshipName: string;
    // (undocumented)
    sourceClassName: string;
    // (undocumented)
    targetClassName: string;
}

// @public
export type StrippedRelationshipPath = StrippedRelatedClassInfo[];

// @public
export interface StructFieldMemberDescription {
    label: string;
    name: string;
    type: TypeDescription;
}

// @public
export interface StructTypeDescription extends BaseTypeDescription {
    members: StructFieldMemberDescription[];
    valueFormat: PropertyValueFormat.Struct;
}

// @public
export interface StyleOverride extends RuleBase, ConditionContainer {
    backColor?: string;
    condition?: string;
    fontStyle?: string;
    foreColor?: string;
    ruleType: RuleTypes.StyleOverride;
}

// @public
export interface SubCondition extends ConditionContainer {
    condition?: string;
    // @beta
    requiredSchemas?: RequiredSchemaSpecification[];
    specifications?: ChildNodeSpecification[];
    subConditions?: SubCondition[];
}

// @public
export type Subtract<T, K> = Omit<T, keyof K>;

// @public
export interface SupplementationInfo {
    supplementationPurpose: string;
}

// @alpha (undocumented)
export function traverseContent(visitor: IContentVisitor, content: Content): void;

// @alpha (undocumented)
export function traverseContentItem(visitor: IContentVisitor, descriptor: Descriptor, item: Item): void;

// @internal (undocumented)
export function traverseFieldHierarchy(hierarchy: FieldHierarchy, cb: (h: FieldHierarchy) => boolean): void;

// @public
export type TypeDescription = PrimitiveTypeDescription | ArrayTypeDescription | StructTypeDescription;

// @internal (undocumented)
export interface UnsetRulesetVariableParams extends CommonIpcParams {
    // (undocumented)
    rulesetId: string;
    // (undocumented)
    variableId: string;
}

// @alpha (undocumented)
export const UPDATE_FULL = "FULL";

// @internal (undocumented)
export interface UpdateHierarchyStateParams<TNodeKey> extends CommonIpcParams {
    // (undocumented)
    changeType: "nodesExpanded" | "nodesCollapsed";
    // (undocumented)
    imodelKey: string;
    // (undocumented)
    nodeKeys: Array<TNodeKey>;
    // (undocumented)
    rulesetId: string;
}

// @alpha (undocumented)
export interface UpdateInfo {
    // (undocumented)
    [imodel: string]: {
        [rulesetId: string]: {
            hierarchy?: HierarchyUpdateInfo;
            content?: ContentUpdateInfo;
        };
    };
}

// @alpha (undocumented)
export namespace UpdateInfo {
    export function fromJSON(json: UpdateInfoJSON): UpdateInfo;
    export function toJSON(obj: UpdateInfo): UpdateInfoJSON;
}

// @alpha (undocumented)
export interface UpdateInfoJSON {
    // (undocumented)
    [imodel: string]: {
        [rulesetId: string]: {
            hierarchy?: HierarchyUpdateInfoJSON;
            content?: ContentUpdateInfo;
        };
    };
}

// @public
export type Value = string | number | boolean | undefined | ValuesMap | ValuesArray | NestedContentValue[];

// @public (undocumented)
export namespace Value {
    export function fromJSON(json: ValueJSON): Value;
    export function isArray(value: Value): value is ValuesArray;
    export function isMap(value: Value): value is ValuesMap;
    export function isNestedContent(value: Value): value is NestedContentValue[];
    export function isPrimitive(value: Value): value is string | number | boolean | undefined;
    export function toJSON(value: Value): ValueJSON;
}

// @public
export type ValueJSON = string | number | boolean | null | ValuesMapJSON | ValuesArrayJSON | NestedContentValueJSON[];

// @public
export interface ValuesArray extends Array<Value> {
}

// @public
export interface ValuesArrayJSON extends Array<ValueJSON> {
}

// @public
export interface ValuesDictionary<T> {
    // (undocumented)
    [key: string]: T;
}

// @public
export interface ValuesMap extends ValuesDictionary<Value> {
}

// @public
export interface ValuesMapJSON extends ValuesDictionary<ValueJSON> {
}

// @public
export interface Variable {
    defaultValue?: string;
    id: string;
    label: string;
    type?: VariableValueType;
}

// @public
export interface VariablesGroup {
    label: string;
    nestedGroups?: VariablesGroup[];
    vars: Variable[];
}

// @public
export type VariableValue = boolean | string | number | number[] | Id64String | Id64String[];

// @public
export type VariableValueJSON = boolean | string | number | number[] | Id64String | Id64String[] | CompressedId64Set;

// @public
export enum VariableValueType {
    Int = "IntValue",
    ShowHide = "ShowHide",
    String = "StringValue",
    YesNo = "YesNo"
}

// @public
export enum VariableValueTypes {
    Bool = "bool",
    Id64 = "id64",
    Id64Array = "id64[]",
    Int = "int",
    IntArray = "int[]",
    String = "string"
}


// (No @packageDocumentation comment for this package)

```
