## API Report File for "@bentley/presentation-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyError } from '@bentley/bentleyjs-core';
import { EntityProps } from '@bentley/imodeljs-common';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GuidString } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelToken } from '@bentley/imodeljs-common';
import { LogFunction } from '@bentley/bentleyjs-core';
import { RpcInterface } from '@bentley/imodeljs-common';

// @public
export interface AllInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    specType: ChildNodeSpecificationTypes.AllInstanceNodes;
    supportedSchemas?: SchemasSpecification;
}

// @public
export interface AllRelatedInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: ChildNodeSpecificationTypes.AllRelatedInstanceNodes;
    supportedSchemas?: SchemasSpecification;
}

// @public
export interface ArrayTypeDescription extends BaseTypeDescription {
    memberType: TypeDescription;
    valueFormat: PropertyValueFormat.Array;
}

// @public
export interface BaseNodeKey {
    pathFromRoot: string[];
    type: string;
}

// @public
export interface BaseTypeDescription {
    typeName: string;
    valueFormat: PropertyValueFormat;
}

// @public
export interface CalculatedPropertiesSpecification {
    label: string;
    priority?: number;
    value: string;
}

// @public
export interface CategoryDescription {
    description: string;
    expand: boolean;
    label: string;
    name: string;
    priority: number;
}

// @public
export interface CheckBoxRule extends RuleBase, ConditionContainer {
    condition?: string;
    defaultValue?: boolean;
    isEnabled?: string | boolean;
    propertyName?: string;
    ruleType: RuleTypes.CheckBox;
    useInversedPropertyValue?: boolean;
}

// @public
export interface ChildNodeRule extends NavigationRuleBase, ConditionContainer {
    condition?: string;
    ruleType: RuleTypes.ChildNodes;
}

// @public
export type ChildNodeSpecification = AllInstanceNodesSpecification | AllRelatedInstanceNodesSpecification | CustomNodeSpecification | InstanceNodesOfSpecificClassesSpecification | RelatedInstanceNodesSpecification | CustomQueryInstanceNodesSpecification;

// @public
export interface ChildNodeSpecificationBase {
    doNotSort?: boolean;
    hasChildren?: "Always" | "Never" | "Unknown";
    hideIfNoChildren?: boolean;
    hideNodesInHierarchy?: boolean;
    nestedRules?: ChildNodeRule[];
    priority?: number;
    relatedInstances?: RelatedInstanceSpecification[];
    specType: ChildNodeSpecificationTypes;
}

// @public
export enum ChildNodeSpecificationTypes {
    // (undocumented)
    AllInstanceNodes = "AllInstanceNodes",
    // (undocumented)
    AllRelatedInstanceNodes = "AllRelatedInstanceNodes",
    // (undocumented)
    CustomNode = "CustomNode",
    // (undocumented)
    CustomQueryInstanceNodes = "CustomQueryInstanceNodes",
    // (undocumented)
    InstanceNodesOfSpecificClasses = "InstanceNodesOfSpecificClasses",
    // (undocumented)
    RelatedInstanceNodes = "RelatedInstanceNodes"
}

// @public
export interface ClassGroup extends GroupingSpecificationBase {
    baseClass?: SingleSchemaClassSpecification;
    createGroupForSingleItem?: boolean;
    specType: GroupingSpecificationTypes.Class;
}

// @public
export type ClassId = Id64String;

// @public
export interface ClassInfo {
    id: ClassId;
    label: string;
    name: string;
}

// @public (undocumented)
export namespace ClassInfo {
    // @internal
    export function fromJSON(json: ClassInfoJSON): ClassInfo;
    // @internal (undocumented)
    export function toJSON(info: ClassInfo): ClassInfoJSON;
}

// @internal
export type ClientStateSyncRequestOptions = PresentationRpcRequestOptions & {
    state: {
        [id: string]: unknown;
    };
};

// @public
export interface ConditionContainer {
    condition?: string;
}

// @public
export class Content {
    constructor(descriptor: Descriptor, items: Item[]);
    readonly contentSet: Item[];
    readonly descriptor: Descriptor;
    // @internal
    static fromJSON(json: ContentJSON | string | undefined): Content | undefined;
    // @internal
    static reviver(key: string, value: any): any;
    // @internal (undocumented)
    toJSON(): ContentJSON;
}

// @public
export enum ContentFlags {
    DistinctValues = 16,
    KeysOnly = 1,
    MergeResults = 8,
    NoFields = 32,
    ShowImages = 2,
    ShowLabels = 4
}

// @public
export interface ContentInstancesOfSpecificClassesSpecification extends ContentSpecificationBase {
    arePolymorphic?: boolean;
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    instanceFilter?: string;
    specType: ContentSpecificationTypes.ContentInstancesOfSpecificClasses;
}

// @public
export interface ContentModifier extends RuleBase {
    calculatedProperties?: CalculatedPropertiesSpecification[];
    class?: SingleSchemaClassSpecification;
    propertiesDisplay?: PropertiesDisplaySpecification[];
    propertyEditors?: PropertyEditorsSpecification[];
    relatedProperties?: RelatedPropertiesSpecification[];
    ruleType: RuleTypes.ContentModifier;
}

// @public
export interface ContentRelatedInstancesSpecification extends ContentSpecificationBase {
    instanceFilter?: string;
    isRecursive?: boolean;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: ContentSpecificationTypes.ContentRelatedInstances;
}

// @public
export interface ContentRequestOptions<TIModel> extends RequestOptionsWithRuleset<TIModel> {
}

// @public
export type ContentRpcRequestOptions = PresentationRpcRequestOptions & Omit<ContentRequestOptions<IModelToken>, "imodel">;

// @public
export interface ContentRule extends RuleBase, ConditionContainer {
    condition?: string;
    ruleType: RuleTypes.Content;
    specifications: ContentSpecification[];
}

// @public
export type ContentSpecification = ContentInstancesOfSpecificClassesSpecification | ContentRelatedInstancesSpecification | SelectedNodeInstancesSpecification;

// @public
export interface ContentSpecificationBase {
    calculatedProperties?: CalculatedPropertiesSpecification[];
    priority?: number;
    propertiesDisplay?: PropertiesDisplaySpecification[];
    propertyEditors?: PropertyEditorsSpecification[];
    relatedInstances?: RelatedInstanceSpecification[];
    relatedProperties?: RelatedPropertiesSpecification[];
    showImages?: boolean;
    specType: ContentSpecificationTypes;
}

// @public
export enum ContentSpecificationTypes {
    // (undocumented)
    ContentInstancesOfSpecificClasses = "ContentInstancesOfSpecificClasses",
    // (undocumented)
    ContentRelatedInstances = "ContentRelatedInstances",
    // (undocumented)
    SelectedNodeInstances = "SelectedNodeInstances"
}

// @public
export type CustomizationRule = InstanceLabelOverride | CheckBoxRule | GroupingRule | ImageIdOverride | LabelOverride | SortingRule | StyleOverride | ExtendedDataRule;

// @public
export interface CustomNodeSpecification extends ChildNodeSpecificationBase {
    description?: string;
    imageId?: string;
    label: string;
    specType: ChildNodeSpecificationTypes.CustomNode;
    type: string;
}

// @public
export interface CustomQueryInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    queries?: QuerySpecification[];
    specType: ChildNodeSpecificationTypes.CustomQueryInstanceNodes;
}

// @public
export enum DefaultContentDisplayTypes {
    Grid = "Grid",
    List = "List",
    PropertyPane = "PropertyPane",
    Undefined = "Undefined",
    Viewport = "Graphics"
}

// @public
export interface DefaultGroupingPropertiesContainer {
    groupByClass?: boolean;
    groupByLabel?: boolean;
}

// @public
export class Descriptor implements DescriptorSource {
    constructor(source: DescriptorSource);
    connectionId: string;
    contentFlags: number;
    contentOptions: any;
    // @internal (undocumented)
    createDescriptorOverrides(): DescriptorOverrides;
    // @internal (undocumented)
    createStrippedDescriptor(): Descriptor;
    displayType: string;
    fields: Field[];
    filterExpression?: string;
    // @internal
    static fromJSON(json: DescriptorJSON | string | undefined): Descriptor | undefined;
    getFieldByName(name: string, recurse?: boolean): Field | undefined;
    inputKeysHash: string;
    // @internal
    static reviver(key: string, value: any): any;
    selectClasses: SelectClassInfo[];
    selectionInfo?: SelectionInfo;
    sortDirection?: SortDirection;
    sortingField?: Field;
    // @internal (undocumented)
    toJSON(): DescriptorJSON;
}

// @public
export interface DescriptorOverrides {
    contentFlags: number;
    displayType: string;
    filterExpression?: string;
    hiddenFieldNames: string[];
    sortDirection?: SortDirection;
    sortingFieldName?: string;
}

// @public
export interface DescriptorSource {
    contentFlags: number;
    displayType: string;
    fields: Field[];
    filterExpression?: string;
    selectClasses: SelectClassInfo[];
    selectionInfo?: SelectionInfo;
    sortDirection?: SortDirection;
    sortingField?: Field;
}

// @public
export interface DisabledSortingRule extends SortingRuleBase {
    ruleType: RuleTypes.DisabledSorting;
}

// @public
export type DisplayValue = string | undefined | DisplayValuesMap | DisplayValuesArray;

// @public (undocumented)
export namespace DisplayValue {
    // @internal (undocumented)
    export function fromJSON(json: DisplayValueJSON): DisplayValue;
    export function isArray(value: DisplayValue): value is DisplayValuesArray;
    export function isMap(value: DisplayValue): value is DisplayValuesMap;
    export function isPrimitive(value: DisplayValue): value is string | undefined;
    // @internal (undocumented)
    export function toJSON(value: DisplayValue): DisplayValueJSON;
}

// @public
export interface DisplayValuesArray extends Array<DisplayValue> {
}

// @public
export interface DisplayValuesMap extends ValuesDictionary<DisplayValue> {
}

// @public
export interface ECClassGroupingNodeKey extends GroupingNodeKey {
    className: string;
    // (undocumented)
    type: StandardNodeTypes.ECClassGroupingNode;
}

// @public
export interface ECInstanceNodeKey extends BaseNodeKey {
    instanceKey: InstanceKey;
    // (undocumented)
    type: StandardNodeTypes.ECInstanceNode;
}

// @public
export interface ECPropertyGroupingNodeKey extends GroupingNodeKey {
    className: string;
    groupingValue: any;
    propertyName: string;
    // (undocumented)
    type: StandardNodeTypes.ECPropertyGroupingNode;
}

// @public
export interface ECPropertyValueQuerySpecification extends QuerySpecificationBase {
    parentPropertyName: string;
    specType: QuerySpecificationTypes.ECPropertyValue;
}

// @public
export interface EditorDescription {
    name: string;
    params: any;
}

// @public
export interface EnumerationChoice {
    label: string;
    value: string | number;
}

// @public
export interface EnumerationInfo {
    choices: EnumerationChoice[];
    isStrict: boolean;
}

// @public
export class Field {
    constructor(category: CategoryDescription, name: string, label: string, type: TypeDescription, isReadonly: boolean, priority: number, editor?: EditorDescription);
    category: CategoryDescription;
    editor?: EditorDescription;
    // @internal
    static fromJSON(json: FieldJSON | string | undefined): Field | undefined;
    isNestedContentField(): this is NestedContentField;
    isPropertiesField(): this is PropertiesField;
    isReadonly: boolean;
    label: string;
    name: string;
    readonly parent: NestedContentField | undefined;
    priority: number;
    // @internal (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    // @internal (undocumented)
    resetParentship(): void;
    // @internal
    static reviver(key: string, value: any): any;
    // @internal (undocumented)
    toJSON(): FieldJSON;
    type: TypeDescription;
}

// @public
export const getInstancesCount: (keys: Readonly<KeySet>) => number;

// @public
export interface GroupingNodeKey extends BaseNodeKey {
    groupedInstancesCount: number;
}

// @public
export interface GroupingRule extends RuleBase, ConditionContainer {
    class: SingleSchemaClassSpecification;
    condition?: string;
    groups: GroupingSpecification[];
    ruleType: RuleTypes.Grouping;
}

// @public
export type GroupingSpecification = ClassGroup | PropertyGroup | SameLabelInstanceGroup;

// @public
export interface GroupingSpecificationBase {
    specType: GroupingSpecificationTypes;
}

// @public
export enum GroupingSpecificationTypes {
    // (undocumented)
    Class = "Class",
    // (undocumented)
    Property = "Property",
    // (undocumented)
    SameLabelInstance = "SameLabelInstance"
}

// @public
export interface HierarchyRequestOptions<TIModel> extends RequestOptionsWithRuleset<TIModel> {
}

// @public
export type HierarchyRpcRequestOptions = PresentationRpcRequestOptions & Omit<HierarchyRequestOptions<IModelToken>, "imodel">;

// @internal
export interface IClientStateHolder<TState> {
    // (undocumented)
    key: string;
    // (undocumented)
    onStateChanged: BeEvent<() => void>;
    // (undocumented)
    state: TState | undefined;
}

// @public
export interface ImageIdOverride extends RuleBase, ConditionContainer {
    condition?: string;
    imageIdExpression: string;
    ruleType: RuleTypes.ImageIdOverride;
}

// @public
export type InstanceId = Id64String;

// @public
export interface InstanceKey {
    className: string;
    id: InstanceId;
}

// @public (undocumented)
export namespace InstanceKey {
    export function compare(lhs: InstanceKey, rhs: InstanceKey): number;
    // @internal
    export function fromJSON(json: InstanceKeyJSON): {
        id: string;
        className: string;
    };
    // @internal (undocumented)
    export function toJSON(json: InstanceKey): InstanceKeyJSON;
}

// @public
export interface InstanceLabelOverride extends RuleBase {
    class: SingleSchemaClassSpecification;
    ruleType: RuleTypes.InstanceLabelOverride;
    values: InstanceLabelOverrideValueSpecification[];
}

// @public
export interface InstanceLabelOverrideBriefcaseIdSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.BriefcaseId;
}

// @public
export interface InstanceLabelOverrideClassLabelSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.ClassLabel;
}

// @public
export interface InstanceLabelOverrideClassNameSpecification extends InstanceLabelOverrideValueSpecificationBase {
    full?: boolean;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.ClassName;
}

// @public
export interface InstanceLabelOverrideCompositeValueSpecification extends InstanceLabelOverrideValueSpecificationBase {
    parts: Array<{
        spec: InstanceLabelOverrideValueSpecification;
        isRequired?: boolean;
    }>;
    separator?: string;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.Composite;
}

// @public
export interface InstanceLabelOverrideLocalIdSpecification extends InstanceLabelOverrideValueSpecificationBase {
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.LocalId;
}

// @public
export interface InstanceLabelOverridePropertyValueSpecification extends InstanceLabelOverrideValueSpecificationBase {
    propertyName: string;
    // (undocumented)
    specType: InstanceLabelOverrideValueSpecificationType.Property;
}

// @public
export type InstanceLabelOverrideValueSpecification = InstanceLabelOverrideCompositeValueSpecification | InstanceLabelOverridePropertyValueSpecification | InstanceLabelOverrideClassNameSpecification | InstanceLabelOverrideClassLabelSpecification | InstanceLabelOverrideBriefcaseIdSpecification | InstanceLabelOverrideLocalIdSpecification;

// @public
export interface InstanceLabelOverrideValueSpecificationBase {
    specType: InstanceLabelOverrideValueSpecificationType;
}

// @public
export enum InstanceLabelOverrideValueSpecificationType {
    // (undocumented)
    BriefcaseId = "BriefcaseId",
    // (undocumented)
    ClassLabel = "ClassLabel",
    // (undocumented)
    ClassName = "ClassName",
    // (undocumented)
    Composite = "Composite",
    // (undocumented)
    LocalId = "LocalId",
    // (undocumented)
    Property = "Property"
}

// @public
export interface InstanceNodesOfSpecificClassesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    arePolymorphic?: boolean;
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    instanceFilter?: string;
    specType: ChildNodeSpecificationTypes.InstanceNodesOfSpecificClasses;
}

// @public
export class Item {
    constructor(primaryKeys: InstanceKey[], label: string, imageId: string, classInfo: ClassInfo | undefined, values: ValuesDictionary<Value>, displayValues: ValuesDictionary<DisplayValue>, mergedFieldNames: string[], extendedData?: {
        [key: string]: any;
    });
    classInfo?: ClassInfo;
    displayValues: ValuesDictionary<DisplayValue>;
    extendedData?: {
        [key: string]: any;
    };
    // @internal
    static fromJSON(json: ItemJSON | string | undefined): Item | undefined;
    imageId: string;
    isFieldMerged(fieldName: string): boolean;
    label: string;
    mergedFieldNames: string[];
    primaryKeys: InstanceKey[];
    // @internal
    static reviver(key: string, value: any): any;
    // @internal (undocumented)
    toJSON(): ItemJSON;
    values: ValuesDictionary<Value>;
}

// @public
export type Key = Readonly<NodeKey> | Readonly<InstanceKey> | Readonly<EntityProps>;

// @public
export type Keys = ReadonlyArray<Key> | Readonly<KeySet>;

// @public
export class KeySet {
    constructor(source?: Keys);
    add(value: Keys | Key): KeySet;
    clear(): KeySet;
    delete(value: Keys | Key): KeySet;
    // @internal
    static fromJSON(json: KeySetJSON): KeySet;
    readonly guid: GuidString;
    has(value: Key): boolean;
    hasAll(keys: Keys): boolean;
    hasAny(keys: Keys): boolean;
    readonly instanceKeys: Map<string, Set<InstanceId>>;
    readonly instanceKeysCount: number;
    readonly isEmpty: boolean;
    readonly nodeKeys: Set<NodeKey>;
    readonly nodeKeysCount: number;
    readonly size: number;
    // @internal
    toJSON(): KeySetJSON;
}

// @public
export interface KindOfQuantityInfo {
    // @alpha
    currentFormatId: string;
    label: string;
    name: string;
    // @alpha
    persistenceUnit: string;
}

// @public
export interface LabelGroupingNodeKey extends GroupingNodeKey {
    label: string;
    // (undocumented)
    type: StandardNodeTypes.DisplayLabelGroupingNode;
}

// @public
export interface LabelOverride extends RuleBase, ConditionContainer {
    condition?: string;
    description?: string;
    label?: string;
    ruleType: RuleTypes.LabelOverride;
}

// @public
export interface LabelRequestOptions<TIModel> extends RequestOptions<TIModel> {
}

// @public
export type LabelRpcRequestOptions = PresentationRpcRequestOptions & Omit<LabelRequestOptions<IModelToken>, "imodel">;

// @public
export enum LoggingNamespaces {
    // (undocumented)
    ECObjects = "ECObjects",
    // (undocumented)
    ECObjects_ECExpressions = "ECObjects.ECExpressions",
    // (undocumented)
    ECObjects_ECExpressions_Evaluate = "ECObjects.ECExpressions.Evaluate",
    // (undocumented)
    ECObjects_ECExpressions_Parse = "ECObjects.ECExpressions.Parse",
    // (undocumented)
    ECPresentation = "ECPresentation",
    // (undocumented)
    ECPresentation_Connections = "ECPresentation.Connections",
    // (undocumented)
    ECPresentation_RulesEngine = "ECPresentation.RulesEngine",
    // (undocumented)
    ECPresentation_RulesEngine_Content = "ECPresentation.RulesEngine.Content",
    // (undocumented)
    ECPresentation_RulesEngine_Localization = "ECPresentation.RulesEngine.Localization",
    // (undocumented)
    ECPresentation_RulesEngine_Navigation = "ECPresentation.RulesEngine.Navigation",
    // (undocumented)
    ECPresentation_RulesEngine_Navigation_Cache = "ECPresentation.RulesEngine.Navigation.Cache",
    // (undocumented)
    ECPresentation_RulesEngine_RulesetVariables = "ECPresentation.RulesEngine.RulesetVariables",
    // (undocumented)
    ECPresentation_RulesEngine_Threads = "ECPresentation.RulesEngine.Threads",
    // (undocumented)
    ECPresentation_RulesEngine_Update = "ECPresentation.RulesEngine.Update"
}

// @public
export interface MultiSchemaClassesSpecification {
    classNames: string[];
    schemaName: string;
}

// @public
export type NavigationRule = RootNodeRule | ChildNodeRule;

// @public
export interface NavigationRuleBase extends RuleBase {
    customizationRules?: CustomizationRule[];
    specifications?: ChildNodeSpecification[];
    stopFurtherProcessing?: boolean;
    subConditions?: SubCondition[];
}

// @public
export class NestedContentField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, contentClassInfo: ClassInfo, pathToPrimaryClass: RelationshipPath, nestedFields: Field[], editor?: EditorDescription);
    contentClassInfo: ClassInfo;
    // @internal
    static fromJSON(json: NestedContentFieldJSON | string | undefined): NestedContentField | undefined;
    nestedFields: Field[];
    pathToPrimaryClass: RelationshipPath;
    // @internal (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    // @internal (undocumented)
    resetParentship(): void;
    // @internal (undocumented)
    toJSON(): NestedContentFieldJSON;
}

// @public
export interface NestedContentValue {
    displayValues: ValuesDictionary<DisplayValue>;
    mergedFieldNames: string[];
    primaryKeys: InstanceKey[];
    values: ValuesDictionary<Value>;
}

// @public (undocumented)
export namespace NestedContentValue {
    // @internal (undocumented)
    export function fromJSON(json: NestedContentValueJSON): NestedContentValue;
    // @internal (undocumented)
    export function toJSON(json: NestedContentValue): NestedContentValueJSON;
}

// @public
export interface Node {
    backColor?: string;
    description?: string;
    extendedData?: {
        [key: string]: any;
    };
    fontStyle?: string;
    foreColor?: string;
    hasChildren?: boolean;
    imageId?: string;
    isCheckboxEnabled?: boolean;
    isCheckboxVisible?: boolean;
    isChecked?: boolean;
    isEditable?: boolean;
    isExpanded?: boolean;
    isSelectionDisabled?: boolean;
    key: NodeKey;
    label: string;
}

// @public (undocumented)
export namespace Node {
    // @internal
    export function fromJSON(json: NodeJSON | string): Node;
    // @internal
    export function listFromJSON(json: NodeJSON[] | string): Node[];
    // @internal
    export function listReviver(key: string, value: any): any;
    // @internal
    export function reviver(key: string, value: any): any;
    // @internal
    export function toJSON(node: Node): NodeJSON;
}

// @public
export type NodeKey = BaseNodeKey | ECInstanceNodeKey | ECClassGroupingNodeKey | ECPropertyGroupingNodeKey | LabelGroupingNodeKey;

// @public (undocumented)
export namespace NodeKey {
    // @internal
    export function fromJSON(json: NodeKeyJSON): NodeKey;
    export function isClassGroupingNodeKey(key: NodeKey): key is ECClassGroupingNodeKey;
    export function isGroupingNodeKey(key: NodeKey): key is GroupingNodeKey;
    export function isInstanceNodeKey(key: NodeKey): key is ECInstanceNodeKey;
    export function isLabelGroupingNodeKey(key: NodeKey): key is LabelGroupingNodeKey;
    export function isPropertyGroupingNodeKey(key: NodeKey): key is ECPropertyGroupingNodeKey;
    // @internal
    export function toJSON(key: NodeKey): NodeKeyJSON;
}

// @public
export type NodeKeyPath = NodeKey[];

// @public
export interface NodePathElement {
    children: NodePathElement[];
    filteringData?: NodePathFilteringData;
    index: number;
    isMarked?: boolean;
    node: Node;
}

// @public (undocumented)
export namespace NodePathElement {
    // @internal
    export function fromJSON(json: NodePathElementJSON | string): NodePathElement;
    // @internal
    export function listFromJSON(json: NodePathElementJSON[] | string): NodePathElement[];
    // @internal
    export function listReviver(key: string, value: any): any;
    // @internal
    export function reviver(key: string, value: any): any;
    // @internal
    export function toJSON(npe: NodePathElement): NodePathElementJSON;
}

// @public
export interface NodePathFilteringData {
    childMatchesCount: number;
    matchesCount: number;
}

// @public
export type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;

// @public
export type Paged<TOptions extends {}> = TOptions & {
    paging?: PageOptions;
};

// @public
export interface PageOptions {
    size?: number;
    start?: number;
}

// @public
export interface PersistentKeysContainer {
    elements: Id64String[];
    models: Id64String[];
    nodes: NodeKey[];
}

// @public
export class PresentationError extends BentleyError {
    constructor(errorNumber: PresentationStatus, message?: string, log?: LogFunction, getMetaData?: GetMetaDataFunction);
    protected _initName(): string;
}

// @public
export class PresentationRpcInterface extends RpcInterface {
    // (undocumented)
    computeSelection(_token: IModelToken, _options: SelectionScopeRpcRequestOptions, _ids: Id64String[], _scopeId: string): PresentationRpcResponse<KeySetJSON>;
    // (undocumented)
    getContent(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, _keys: KeySetJSON): PresentationRpcResponse<ContentJSON | undefined>;
    // (undocumented)
    getContentAndSize(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, _keys: KeySetJSON): PresentationRpcResponse<{
        content?: ContentJSON;
        size: number;
    }>;
    // (undocumented)
    getContentDescriptor(_token: IModelToken, _options: ContentRpcRequestOptions, _displayType: string, _keys: KeySetJSON, _selection: SelectionInfo | undefined): PresentationRpcResponse<DescriptorJSON | undefined>;
    // (undocumented)
    getContentSetSize(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, _keys: KeySetJSON): PresentationRpcResponse<number>;
    // (undocumented)
    getDisplayLabel(_token: IModelToken, _options: LabelRpcRequestOptions, _key: InstanceKeyJSON): PresentationRpcResponse<string>;
    // (undocumented)
    getDisplayLabels(_token: IModelToken, _options: LabelRpcRequestOptions, _keys: InstanceKeyJSON[]): PresentationRpcResponse<string[]>;
    // (undocumented)
    getDistinctValues(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptor: DescriptorJSON, _keys: KeySetJSON, _fieldName: string, _maximumValueCount: number): PresentationRpcResponse<string[]>;
    // (undocumented)
    getFilteredNodePaths(_token: IModelToken, _options: HierarchyRpcRequestOptions, _filterText: string): PresentationRpcResponse<NodePathElementJSON[]>;
    // (undocumented)
    getNodePaths(_token: IModelToken, _options: HierarchyRpcRequestOptions, _paths: InstanceKeyJSON[][], _markedIndex: number): PresentationRpcResponse<NodePathElementJSON[]>;
    // (undocumented)
    getNodes(_token: IModelToken, _options: Paged<HierarchyRpcRequestOptions>, _parentKey?: NodeKeyJSON): PresentationRpcResponse<NodeJSON[]>;
    // (undocumented)
    getNodesAndCount(_token: IModelToken, _options: Paged<HierarchyRpcRequestOptions>, _parentKey?: NodeKeyJSON): PresentationRpcResponse<{
        nodes: NodeJSON[];
        count: number;
    }>;
    // (undocumented)
    getNodesCount(_token: IModelToken, _options: HierarchyRpcRequestOptions, _parentKey?: NodeKeyJSON): PresentationRpcResponse<number>;
    // (undocumented)
    getSelectionScopes(_token: IModelToken, _options: SelectionScopeRpcRequestOptions): PresentationRpcResponse<SelectionScope[]>;
    // @internal
    syncClientState(_token: IModelToken, _options: ClientStateSyncRequestOptions): PresentationRpcResponse;
    static types: () => never[];
    static version: string;
}

// @public
export interface PresentationRpcRequestOptions {
    clientId?: string;
    clientStateId?: string;
}

// @public
export type PresentationRpcResponse<TResult = undefined> = Promise<{
    statusCode: PresentationStatus;
    errorMessage?: string;
    result?: TResult;
}>;

// @public
export enum PresentationStatus {
    BackendOutOfSync = 65542,
    BackendTimeout = 65543,
    Error = 65536,
    InvalidArgument = 65539,
    InvalidResponse = 65540,
    NoContent = 65541,
    NotInitialized = 65537,
    Success = 0,
    UseAfterDisposal = 65538
}

// @public
export interface PrimitiveTypeDescription extends BaseTypeDescription {
    valueFormat: PropertyValueFormat.Primitive;
}

// @public
export interface PropertiesDisplaySpecification {
    isDisplayed?: boolean;
    priority?: number;
    propertyNames: string[];
}

// @public
export class PropertiesField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, properties: Property[], editor?: EditorDescription);
    // @internal
    static fromJSON(json: PropertiesFieldJSON | string | undefined): PropertiesField | undefined;
    properties: Property[];
    // @internal (undocumented)
    toJSON(): PropertiesFieldJSON;
}

// @public
export interface Property {
    property: PropertyInfo;
    relatedClassPath: RelationshipPath;
}

// @public (undocumented)
export namespace Property {
    // @internal
    export function fromJSON(json: PropertyJSON): Property;
    // @internal (undocumented)
    export function toJSON(prop: Property): PropertyJSON;
}

// @public
export interface PropertyEditorJsonParameters extends PropertyEditorParametersBase {
    json: any;
    paramsType: PropertyEditorParameterTypes.Json;
}

// @public
export interface PropertyEditorMultilineParameters extends PropertyEditorParametersBase {
    height?: number;
    paramsType: PropertyEditorParameterTypes.Multiline;
}

// @public
export type PropertyEditorParameters = PropertyEditorJsonParameters | PropertyEditorMultilineParameters | PropertyEditorRangeParameters | PropertyEditorSliderParameters;

// @public
export interface PropertyEditorParametersBase {
    paramsType: PropertyEditorParameterTypes;
}

// @public
export enum PropertyEditorParameterTypes {
    // (undocumented)
    Json = "Json",
    // (undocumented)
    Multiline = "Multiline",
    // (undocumented)
    Range = "Range",
    // (undocumented)
    Slider = "Slider"
}

// @public
export interface PropertyEditorRangeParameters extends PropertyEditorParametersBase {
    max?: number;
    min?: number;
    paramsType: PropertyEditorParameterTypes.Range;
}

// @public
export interface PropertyEditorSliderParameters extends PropertyEditorParametersBase {
    intervalsCount?: number;
    isVertical?: boolean;
    max: number;
    min: number;
    paramsType: PropertyEditorParameterTypes.Slider;
}

// @public
export interface PropertyEditorsSpecification {
    editorName: string;
    parameters?: PropertyEditorParameters[];
    propertyName: string;
}

// @public
export interface PropertyGroup extends GroupingSpecificationBase {
    createGroupForSingleItem?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    groupingValue?: PropertyGroupingValue;
    imageId?: string;
    propertyName: string;
    ranges?: PropertyRangeGroupSpecification[];
    sortingValue?: PropertyGroupingValue;
    specType: GroupingSpecificationTypes.Property;
}

// @public
export enum PropertyGroupingValue {
    DisplayLabel = "DisplayLabel",
    PropertyValue = "PropertyValue"
}

// @public
export interface PropertyInfo {
    classInfo: ClassInfo;
    enumerationInfo?: EnumerationInfo;
    // @alpha
    kindOfQuantity?: KindOfQuantityInfo;
    name: string;
    type: string;
}

// @public (undocumented)
export namespace PropertyInfo {
    // @internal
    export function fromJSON(json: PropertyInfoJSON): PropertyInfo;
    // @internal (undocumented)
    export function toJSON(info: PropertyInfo): PropertyInfoJSON;
}

// @public
export interface PropertyRangeGroupSpecification {
    fromValue: string;
    imageId?: string;
    label?: string;
    toValue: string;
}

// @public
export interface PropertySortingRule extends SortingRuleBase {
    propertyName: string;
    ruleType: RuleTypes.PropertySorting;
    sortAscending?: boolean;
}

// @public
export enum PropertyValueFormat {
    Array = "Array",
    Primitive = "Primitive",
    Struct = "Struct"
}

// @public
export type QuerySpecification = StringQuerySpecification | ECPropertyValueQuerySpecification;

// @public
export interface QuerySpecificationBase {
    class: SingleSchemaClassSpecification;
    specType: QuerySpecificationTypes;
}

// @public
export enum QuerySpecificationTypes {
    // (undocumented)
    ECPropertyValue = "ECPropertyValue",
    // (undocumented)
    String = "String"
}

// @public
export class RegisteredRuleset implements IDisposable, Ruleset {
    constructor(ruleset: Ruleset, uniqueIdentifier: string, disposeFunc: (ruleset: RegisteredRuleset) => void);
    dispose(): void;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly rules: Rule[];
    // (undocumented)
    readonly supplementationInfo: SupplementationInfo | undefined;
    // (undocumented)
    readonly supportedSchemas: SchemasSpecification | undefined;
    // (undocumented)
    toJSON(): Ruleset;
    // (undocumented)
    readonly uniqueIdentifier: string;
    // (undocumented)
    readonly vars: VariablesGroup[] | undefined;
}

// @public
export interface RelatedClassInfo {
    isForwardRelationship: boolean;
    isPolymorphicRelationship: boolean;
    relationshipInfo: ClassInfo;
    sourceClassInfo: ClassInfo;
    targetClassInfo: ClassInfo;
}

// @public (undocumented)
export namespace RelatedClassInfo {
    // @internal
    export function fromJSON(json: RelatedClassInfoJSON): RelatedClassInfo;
    // @internal (undocumented)
    export function toJSON(info: RelatedClassInfo): RelatedClassInfoJSON;
}

// @public
export interface RelatedInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    instanceFilter?: string;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: ChildNodeSpecificationTypes.RelatedInstanceNodes;
    supportedSchemas?: string[];
}

// @public
export interface RelatedInstanceSpecification {
    alias: string;
    class: SingleSchemaClassSpecification;
    isRequired?: boolean;
    relationship: SingleSchemaClassSpecification;
    requiredDirection: RelationshipDirection.Forward | RelationshipDirection.Backward;
}

// @public
export enum RelatedPropertiesSpecialValues {
    None = "_none_"
}

// @public
export interface RelatedPropertiesSpecification {
    isPolymorphic?: boolean;
    nestedRelatedProperties?: RelatedPropertiesSpecification[];
    propertyNames?: string[] | RelatedPropertiesSpecialValues;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationshipMeaning?: RelationshipMeaning;
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
}

// @public
export enum RelationshipDirection {
    Backward = "Backward",
    Both = "Both",
    Forward = "Forward"
}

// @public
export enum RelationshipMeaning {
    RelatedInstance = "RelatedInstance",
    SameInstance = "SameInstance"
}

// @public
export type RelationshipPath = RelatedClassInfo[];

// @public
export interface RequestOptions<TIModel> {
    imodel: TIModel;
    locale?: string;
}

// @public
export interface RequestOptionsWithRuleset<TIModel> extends RequestOptions<TIModel> {
    rulesetId: string;
}

// @public
export interface RootNodeRule extends NavigationRuleBase {
    autoExpand?: boolean;
    ruleType: RuleTypes.RootNodes;
}

// @internal
export class RpcRequestsHandler implements IDisposable {
    constructor(props?: RpcRequestsHandlerProps);
    readonly clientId: string;
    readonly clientStateId: string | undefined;
    // (undocumented)
    computeSelection(options: SelectionScopeRequestOptions<IModelToken>, ids: Id64String[], scopeId: string): Promise<KeySetJSON>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getContent(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, keys: KeySetJSON): Promise<ContentJSON | undefined>;
    // (undocumented)
    getContentAndSize(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, keys: KeySetJSON): Promise<{
        content?: ContentJSON | undefined;
        size: number;
    }>;
    // (undocumented)
    getContentDescriptor(options: ContentRequestOptions<IModelToken>, displayType: string, keys: KeySetJSON, selection: SelectionInfo | undefined): Promise<DescriptorJSON | undefined>;
    // (undocumented)
    getContentSetSize(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: DescriptorJSON | DescriptorOverrides, keys: KeySetJSON): Promise<number>;
    // (undocumented)
    getDisplayLabel(options: LabelRequestOptions<IModelToken>, key: InstanceKeyJSON): Promise<string>;
    // (undocumented)
    getDisplayLabels(options: LabelRequestOptions<IModelToken>, keys: InstanceKeyJSON[]): Promise<string[]>;
    // (undocumented)
    getDistinctValues(options: ContentRequestOptions<IModelToken>, descriptor: DescriptorJSON, keys: KeySetJSON, fieldName: string, maximumValueCount: number): Promise<string[]>;
    // (undocumented)
    getFilteredNodePaths(options: HierarchyRequestOptions<IModelToken>, filterText: string): Promise<NodePathElementJSON[]>;
    // (undocumented)
    getNodePaths(options: HierarchyRequestOptions<IModelToken>, paths: InstanceKeyJSON[][], markedIndex: number): Promise<NodePathElementJSON[]>;
    // (undocumented)
    getNodes(options: Paged<HierarchyRequestOptions<IModelToken>>, parentKey?: NodeKeyJSON): Promise<NodeJSON[]>;
    // (undocumented)
    getNodesAndCount(options: Paged<HierarchyRequestOptions<IModelToken>>, parentKey?: NodeKeyJSON): Promise<{
        nodes: NodeJSON[];
        count: number;
    }>;
    // (undocumented)
    getNodesCount(options: HierarchyRequestOptions<IModelToken>, parentKey?: NodeKeyJSON): Promise<number>;
    // (undocumented)
    getSelectionScopes(options: SelectionScopeRequestOptions<IModelToken>): Promise<SelectionScope[]>;
    // (undocumented)
    registerClientStateHolder(holder: IClientStateHolder<any>): void;
    request<TResult, TOptions extends PresentationRpcRequestOptions & {
        imodel: IModelToken;
    }, TArg = any>(context: any, func: (token: IModelToken, options: Omit<TOptions, "imodel">, ...args: TArg[]) => PresentationRpcResponse<TResult>, options: TOptions, ...args: TArg[]): Promise<TResult>;
    sync(token: IModelToken): Promise<void>;
    // (undocumented)
    unregisterClientStateHolder(holder: IClientStateHolder<any>): void;
}

// @internal
export interface RpcRequestsHandlerProps {
    clientId?: string;
}

// @public
export type Rule = CustomizationRule | NavigationRule | ContentRule | ContentModifier;

// @public
export interface RuleBase {
    onlyIfNotHandled?: boolean;
    priority?: number;
    ruleType: RuleTypes;
}

// @public
export interface Ruleset {
    id: string;
    rules: Rule[];
    supplementationInfo?: SupplementationInfo;
    supportedSchemas?: SchemasSpecification;
    vars?: VariablesGroup[];
}

// @internal (undocumented)
export type RulesetManagerState = Ruleset[];

// @internal (undocumented)
export namespace RulesetManagerState {
    const // (undocumented)
    STATE_ID = "rulesets";
}

// @public
export class RulesetsFactory {
    createSimilarInstancesRuleset(field: Field, record: Item): {
        ruleset: Ruleset;
        description: string;
    };
}

// @internal (undocumented)
export interface RulesetVariablesState {
    // (undocumented)
    [rulesetId: string]: Array<[string, VariableValueTypes, VariableValue]>;
}

// @internal (undocumented)
export namespace RulesetVariablesState {
    const // (undocumented)
    STATE_ID = "ruleset variables";
}

// @public
export enum RuleTypes {
    // (undocumented)
    CheckBox = "CheckBox",
    // (undocumented)
    ChildNodes = "ChildNodes",
    // (undocumented)
    Content = "Content",
    // (undocumented)
    ContentModifier = "ContentModifier",
    // (undocumented)
    DisabledSorting = "DisabledSorting",
    // (undocumented)
    ExtendedData = "ExtendedData",
    // (undocumented)
    Grouping = "Grouping",
    // (undocumented)
    ImageIdOverride = "ImageIdOverride",
    // (undocumented)
    InstanceLabelOverride = "InstanceLabelOverride",
    // (undocumented)
    LabelOverride = "LabelOverride",
    // (undocumented)
    PropertySorting = "PropertySorting",
    // (undocumented)
    RootNodes = "RootNodes",
    // (undocumented)
    StyleOverride = "StyleOverride"
}

// @public
export interface SameLabelInstanceGroup extends GroupingSpecificationBase {
    specType: GroupingSpecificationTypes.SameLabelInstance;
}

// @public
export interface SchemasSpecification {
    isExclude?: boolean;
    schemaNames: string[];
}

// @public
export interface SelectClassInfo {
    isSelectPolymorphic: boolean;
    pathToPrimaryClass: RelationshipPath;
    relatedPropertyPaths: RelationshipPath[];
    selectClassInfo: ClassInfo;
}

// @public
export interface SelectedNodeInstancesSpecification extends ContentSpecificationBase {
    acceptableClassNames?: string[];
    acceptablePolymorphically?: boolean;
    acceptableSchemaName?: string;
    onlyIfNotHandled?: boolean;
    specType: ContentSpecificationTypes.SelectedNodeInstances;
}

// @public
export interface SelectionInfo {
    level?: number;
    providerName: string;
}

// @public
export interface SelectionScope {
    description?: string;
    id: string;
    label: string;
}

// @public
export interface SelectionScopeRequestOptions<TIModel> extends RequestOptions<TIModel> {
}

// @public
export type SelectionScopeRpcRequestOptions = PresentationRpcRequestOptions & Omit<SelectionScopeRequestOptions<IModelToken>, "imodel">;

// @public
export interface SingleSchemaClassSpecification {
    className: string;
    schemaName: string;
}

// @public
export enum SortDirection {
    // (undocumented)
    Ascending = 0,
    // (undocumented)
    Descending = 1
}

// @public
export type SortingRule = PropertySortingRule | DisabledSortingRule;

// @public
export interface SortingRuleBase extends RuleBase, ConditionContainer {
    class?: SingleSchemaClassSpecification;
    condition?: string;
    isPolymorphic?: boolean;
}

// @public
export enum StandardNodeTypes {
    // (undocumented)
    DisplayLabelGroupingNode = "DisplayLabelGroupingNode",
    // (undocumented)
    ECClassGroupingNode = "ECClassGroupingNode",
    // (undocumented)
    ECInstanceNode = "ECInstanceNode",
    // (undocumented)
    ECPropertyGroupingNode = "ECPropertyGroupingNode"
}

// @public
export interface StringQuerySpecification extends QuerySpecificationBase {
    query: string;
    specType: QuerySpecificationTypes.String;
}

// @public
export interface StructFieldMemberDescription {
    label: string;
    name: string;
    type: TypeDescription;
}

// @public
export interface StructTypeDescription extends BaseTypeDescription {
    members: StructFieldMemberDescription[];
    valueFormat: PropertyValueFormat.Struct;
}

// @public
export interface StyleOverride extends RuleBase, ConditionContainer {
    backColor?: string;
    condition?: string;
    fontStyle?: string;
    foreColor?: string;
    ruleType: RuleTypes.StyleOverride;
}

// @public
export interface SubCondition extends ConditionContainer {
    condition?: string;
    specifications?: ChildNodeSpecification[];
    subConditions?: SubCondition[];
}

// @public
export type Subtract<T, K> = Omit<T, keyof K>;

// @public
export interface SupplementationInfo {
    supplementationPurpose: string;
}

// @public
export type TypeDescription = PrimitiveTypeDescription | ArrayTypeDescription | StructTypeDescription;

// @public
export type Value = string | number | boolean | undefined | ValuesMap | ValuesArray | NestedContentValue[];

// @public (undocumented)
export namespace Value {
    // @internal (undocumented)
    export function fromJSON(json: ValueJSON): Value;
    export function isArray(value: Value): value is ValuesArray;
    export function isMap(value: Value): value is ValuesMap;
    export function isNestedContent(value: Value): value is NestedContentValue[];
    export function isPrimitive(value: Value): value is string | number | boolean | undefined;
    // @internal (undocumented)
    export function toJSON(value: Value): ValueJSON;
}

// @public
export interface ValuesArray extends Array<Value> {
}

// @public
export interface ValuesDictionary<T> {
    // (undocumented)
    [key: string]: T;
}

// @public
export interface ValuesMap extends ValuesDictionary<Value> {
}

// @public
export interface Variable {
    defaultValue?: string;
    id: string;
    label: string;
    type?: VariableValueType;
}

// @public
export interface VariablesGroup {
    label: string;
    nestedGroups?: VariablesGroup[];
    vars: Variable[];
}

// @internal
export type VariableValue = boolean | string | number | number[] | Id64String[];

// @public
export enum VariableValueType {
    Int = "IntValue",
    ShowHide = "ShowHide",
    String = "StringValue",
    YesNo = "YesNo"
}

// @internal
export enum VariableValueTypes {
    Bool = "bool",
    Id64 = "id64",
    Id64Array = "id64[]",
    Int = "int",
    IntArray = "int[]",
    String = "string"
}


// (No @packageDocumentation comment for this package)

```
