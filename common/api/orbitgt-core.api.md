## API Report File for "@bentley/orbitgt-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @internal (undocumented)
export class ALong {
    add(value: ALong): ALong;
    addInt(value: int32_3): ALong;
    compareTo(value: ALong): int32_3;
    decrease(): ALong;
    div(value: ALong): ALong;
    divInt(value: int32_3): ALong;
    equals(value: ALong): boolean;
    static FOUR: ALong;
    static fromBytes(b7: float64_2, b6: float64_2, b5: float64_2, b4: float64_2, b3: float64_2, b2: float64_2, b1: float64_2, b0: float64_2): ALong;
    static fromDouble(value: float64_2): ALong;
    static fromHexString(value: string): ALong;
    static fromHighLow(i1: float64_2, i0: float64_2): ALong;
    static fromInt(value: float64_2): ALong;
    static fromRadixString(svalue: string, radix: int32_3): ALong;
    static fromString(value: string): ALong;
    getByte(index: int32_3): int32_3;
    getHexString(): string;
    getHigh(): float64_2;
    getLow(): float64_2;
    getRadixString(radix: int32_3): string;
    getString(): string;
    increase(): ALong;
    isEqualTo(value: ALong): boolean;
    isLargerThan(value: ALong): boolean;
    isLargerThanOrEqualTo(value: ALong): boolean;
    isNegative(): boolean;
    isNonZero(): boolean;
    isNotEqualTo(value: ALong): boolean;
    isOne(): boolean;
    isPositive(): boolean;
    isSmallerThan(value: ALong): boolean;
    isSmallerThanOrEqualTo(value: ALong): boolean;
    isZero(): boolean;
    static max(v1: ALong, v2: ALong): ALong;
    static MAX_VALUE: ALong;
    static min(v1: ALong, v2: ALong): ALong;
    static MIN_VALUE: ALong;
    static MINUS_ONE: ALong;
    mod(value: ALong): ALong;
    modInt(value: int32_3): int32_3;
    mul(value: ALong): ALong;
    mulInt(value: int32_3): ALong;
    negate(): ALong;
    static ONE: ALong;
    same(value: ALong): boolean;
    sub(value: ALong): ALong;
    subInt(value: int32_3): ALong;
    static TEN: ALong;
    toDouble(): float64_2;
    toInt(): int32_3;
    toString(): string;
    static TWO: ALong;
    static ZERO: ALong;
}

// @internal (undocumented)
export class CRSManager {
    static createTransform(sourceCRS: string, sourcePoint: OrbitGtCoordinate, targetCRS: string): OrbitGtTransform;
    static ENGINE: CRSEngine;
    static prepareForArea(crs: string, area: OrbitGtBounds): Promise<OrbitGtBounds>;
    static transformBounds(bounds: OrbitGtBounds, sourceCRS: string, targetCRS: string): OrbitGtBounds;
    static transformPoint(point: OrbitGtCoordinate, sourceCRS: string, targetCRS: string): OrbitGtCoordinate;
}

// @internal (undocumented)
export class Downloader {
    constructor();
    // (undocumented)
    downloadBytes(method: string, requestURL: string, requestHeaders: StringMap<string>, postText: string, postData: ABuffer, responseHeaders: StringMap<string>): Promise<ABuffer>;
    // (undocumented)
    downloadText(method: string, requestURL: string, requestHeaders: StringMap<string>, postText: string, postData: ABuffer, responseHeaders: StringMap<string>): Promise<string>;
    // (undocumented)
    downloadText2(requestURL: string): Promise<string>;
    static INSTANCE: Downloader;
}

// @internal (undocumented)
export class DownloaderXhr extends Downloader {
    constructor();
    // (undocumented)
    downloadBytes(method: string, requestURL: string, requestHeaders: StringMap<string>, postText: string, postData: ABuffer, responseHeaders: StringMap<string>): Promise<ABuffer>;
    // (undocumented)
    downloadText(method: string, requestURL: string, requestHeaders: StringMap<string>, postText: string, postData: ABuffer, responseHeaders: StringMap<string>): Promise<string>;
    // (undocumented)
    downloadText2(requestURL: string): Promise<string>;
    }

// @internal (undocumented)
export class OnlineEngine extends CRSEngine {
    static create(): Promise<OnlineEngine>;
    isGeocentricCRS(crs: string): boolean;
    isGeographicCRS(crs: string): boolean;
    isProjectedCRS(crs: string): boolean;
    prepareForArea(crs: string, area: OrbitGtBounds): Promise<OrbitGtBounds>;
    transformPoint(point: OrbitGtCoordinate, sourceCRS: string, targetCRS: string): OrbitGtCoordinate;
}

// @internal (undocumented)
export class OPCReader extends PointCloudReader {
    clipToLevelRange(levelOffset: int32_35, levelCount: int32_35): PointCloudReader;
    close(): void;
    getFileBounds(): OrbitGtBounds;
    getFileCRS(): string;
    getFileName(): string;
    getFileReader(): FileReader;
    getFileStorage(): FileStorage;
    getLevelBlockGrid(level: int32_35): Grid;
    getLevelCount(): int32_35;
    getLevelPointBounds(level: int32_35): OrbitGtBounds;
    getLevelPointCount(level: int32_35): ALong;
    getLevelTileGrid(level: int32_35): Grid;
    getMaxAttributeValue(attribute: PointAttribute): AttributeValue;
    getMinAttributeValue(attribute: PointAttribute): AttributeValue;
    getPointAttributes(): Array<PointAttribute>;
    getProperty(propertyName: string): Object;
    static openFile(fileStorage: FileStorage, fileName: string, lazyLoading: boolean): Promise<OPCReader>;
    peekBlockIndexes(level: int32_35): Array<OrbitGtBlockIndex>;
    readBlockIndexes(level: int32_35, fileContents: ContentLoader): Array<OrbitGtBlockIndex>;
    readPointData(tileIndex: OrbitGtTileIndex, dataFormat: int32_35, accessTime: float64_17, fileContents: ContentLoader): OrbitGtPointData;
    readPoints(tileIndex: OrbitGtTileIndex, readRequest: ReadRequest, fileContents: ContentLoader): OrbitGtAList<CloudPoint>;
    readTileIndexes(block: OrbitGtBlockIndex, fileContents: ContentLoader): Array<OrbitGtTileIndex>;
}

// @internal (undocumented)
export class OrbitGtAList<T> {
    [Symbol.iterator](): {
        next(): IteratorResult<T>;
    };
    constructor(capacity?: number);
    // (undocumented)
    add(element: T): void;
    // (undocumented)
    addAt(index: number, element: T): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    contains(element: T): boolean;
    // (undocumented)
    get(index: int32_7): T;
    // (undocumented)
    indexOf(element: T): int32_7;
    // (undocumented)
    remove(index: int32_7): void;
    // (undocumented)
    size(): int32_7;
    // (undocumented)
    sort(comparator: OrbitGtComparator<T>): void;
    // (undocumented)
    toArray(holder: any): Array<T>;
}

// @internal (undocumented)
export class OrbitGtBlockIndex {
    constructor(level: int32, index: int32, gridIndex: GridIndex, tileIndex: int32, tileCount: int32, pointIndex: ALong, pointCount: ALong);
    accessTime: float64_3;
    getKey(): string;
    gridIndex: GridIndex;
    index: int32;
    key: string;
    level: int32;
    pointCount: ALong;
    pointIndex: ALong;
    same(other: OrbitGtBlockIndex): boolean;
    tileCount: int32;
    tileIndex: int32;
}

// @internal (undocumented)
export class OrbitGtBounds {
    constructor();
    // (undocumented)
    add(c: OrbitGtCoordinate): OrbitGtBounds;
    // (undocumented)
    addXYZ(x: float64_6, y: float64_6, z: float64_6): OrbitGtBounds;
    // (undocumented)
    clear(): void;
    // (undocumented)
    contains(c: OrbitGtCoordinate): boolean;
    // (undocumented)
    containsXYZ(x: float64_6, y: float64_6, z: float64_6): boolean;
    // (undocumented)
    getCorner(index: int32_5, point: OrbitGtCoordinate): void;
    // (undocumented)
    getIntersection(other: OrbitGtBounds): OrbitGtBounds;
    // (undocumented)
    getMaxX(): float64_6;
    // (undocumented)
    getMaxY(): float64_6;
    // (undocumented)
    getMaxZ(): float64_6;
    // (undocumented)
    getMinX(): float64_6;
    // (undocumented)
    getMinY(): float64_6;
    // (undocumented)
    getMinZ(): float64_6;
    // (undocumented)
    hasOverlapXYZ(x1: float64_6, y1: float64_6, z1: float64_6, x2: float64_6, y2: float64_6, z2: float64_6): boolean;
    // (undocumented)
    isValid(): boolean;
    // (undocumented)
    max: OrbitGtCoordinate;
    // (undocumented)
    min: OrbitGtCoordinate;
    // (undocumented)
    toString(): string;
    // (undocumented)
    valid: boolean;
}

// @internal (undocumented)
export interface OrbitGtComparator<T> {
    // (undocumented)
    compare(value1: T, value2: T): int32_8;
}

// @internal (undocumented)
export class OrbitGtCoordinate {
    constructor(x: float64_5, y: float64_5, z: float64_5);
    // (undocumented)
    add(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    add0(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    clear(): void;
    // (undocumented)
    copy(): OrbitGtCoordinate;
    // (undocumented)
    static create(): OrbitGtCoordinate;
    // (undocumented)
    crossProduct(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    crossProduct0(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    distance2D(other: OrbitGtCoordinate): float64_5;
    // (undocumented)
    distance3D(other: OrbitGtCoordinate): float64_5;
    // (undocumented)
    dotProduct(point: OrbitGtCoordinate): float64_5;
    // (undocumented)
    static fromXY(x: float64_5, y: float64_5): OrbitGtCoordinate;
    // (undocumented)
    static fromXYZ(x: float64_5, y: float64_5, z: float64_5): OrbitGtCoordinate;
    static getAngleDeg(direction1: OrbitGtCoordinate, direction2: OrbitGtCoordinate): float64_5;
    static getAngleRad(direction1: OrbitGtCoordinate, direction2: OrbitGtCoordinate): float64_5;
    // (undocumented)
    getLength(): float64_5;
    // (undocumented)
    getX(): float64_5;
    // (undocumented)
    getY(): float64_5;
    // (undocumented)
    getZ(): float64_5;
    // (undocumented)
    isNonZero(): boolean;
    // (undocumented)
    isZero(): boolean;
    // (undocumented)
    normalize(): OrbitGtCoordinate;
    // (undocumented)
    normalize0(): OrbitGtCoordinate;
    // (undocumented)
    same(other: OrbitGtCoordinate): boolean;
    // (undocumented)
    same2D(other: OrbitGtCoordinate): boolean;
    // (undocumented)
    scale(f: float64_5): OrbitGtCoordinate;
    // (undocumented)
    scale0(f: float64_5): OrbitGtCoordinate;
    // (undocumented)
    set(point: OrbitGtCoordinate): void;
    // (undocumented)
    setX(x: float64_5): void;
    // (undocumented)
    setXYZ(x: float64_5, y: float64_5, z: float64_5): void;
    // (undocumented)
    setY(y: float64_5): void;
    // (undocumented)
    setZ(z: float64_5): void;
    // (undocumented)
    subtract(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    subtract0(point: OrbitGtCoordinate): OrbitGtCoordinate;
    // (undocumented)
    toString(): string;
    // (undocumented)
    x: float64_5;
    // (undocumented)
    y: float64_5;
    // (undocumented)
    z: float64_5;
}

// @internal (undocumented)
export class OrbitGtDataManager {
    constructor(pointCloudReader: PointCloudReader, pointCloudCRS: string, dataFormat: int32_20);
    close(): void;
    doGarbageCollect(time: float64_12): void;
    filterLoadList(levelsToLoad: OrbitGtAList<OrbitGtLevel>, blocksToLoad: OrbitGtAList<OrbitGtBlockIndex>, tilesToLoad: OrbitGtAList<OrbitGtTileIndex>, levelList: OrbitGtAList<OrbitGtLevel>, blockList: OrbitGtAList<OrbitGtBlockIndex>, tileList: OrbitGtAList<OrbitGtTileIndex>): void;
    getDataLoadSize(): ALong;
    getPointCloudBounds(): OrbitGtBounds;
    getPointCloudCRS(): string;
    getPointCloudReader(): PointCloudReader;
    getViewTree(): OrbitGtViewTree;
    isLoadingData(): boolean;
    isTileLoaded(tileIndex: OrbitGtTileIndex): OrbitGtPointData;
    loadData(frameData: OrbitGtFrameData): Promise<OrbitGtFrameData>;
    }

// @internal (undocumented)
export class OrbitGtFrameData {
    constructor();
    blocksToLoad: OrbitGtAList<OrbitGtBlockIndex>;
    hasMissingData(): boolean;
    levelsToLoad: OrbitGtAList<OrbitGtLevel>;
    tilesToLoad: OrbitGtAList<OrbitGtTileIndex>;
    tilesToRender: OrbitGtAList<OrbitGtPointData>;
}

// @internal (undocumented)
export interface OrbitGtIProjectToViewForSort {
    // (undocumented)
    projectToViewForSort(point: OrbitGtCoordinate): void;
}

// @internal (undocumented)
export abstract class OrbitGtIViewRequest {
    constructor();
    abstract getFrameTime(): float64_7;
    abstract isVisibleBox(bounds: OrbitGtBounds): boolean;
    abstract shouldSplit(level: OrbitGtLevel, tile: OrbitGtTileIndex): boolean;
}

// @internal (undocumented)
export class OrbitGtLevel {
    constructor(index: int32_6, blockGrid: Grid, tileGrid: Grid, blockList: Array<Block>);
    findBlock(blockIndex: OrbitGtBlockIndex): Block;
    findBlockForTile(tileGridIndex: GridIndex): Block;
    findBlockGridIndex(blockIndex: GridIndex): Block;
    getBlockCount(): int32_6;
    getBlockGrid(): Grid;
    getBlocks(): Array<Block>;
    getIndex(): int32_6;
    getKey(): string;
    getTileGrid(): Grid;
    setBlockList(blockList: Array<Block>): void;
    }

// @internal (undocumented)
export class OrbitGtLine {
    constructor(p0: OrbitGtCoordinate, p1: OrbitGtCoordinate);
    static create(): OrbitGtLine;
    static fromPoints(p0: OrbitGtCoordinate, p1: OrbitGtCoordinate): OrbitGtLine;
    static fromXYZ(x0: float64_13, y0: float64_13, z0: float64_13, x1: float64_13, y1: float64_13, z1: float64_13): OrbitGtLine;
    getDifference(): OrbitGtCoordinate;
    getDirection(): OrbitGtCoordinate;
    getDirectionTo(direction: OrbitGtCoordinate): void;
    getDistance(point: OrbitGtCoordinate): float64_13;
    getIntersection(line: OrbitGtLine): float64_13;
    getIntersectionPoint(line: OrbitGtLine): OrbitGtCoordinate;
    getLength(): float64_13;
    getPoint(t: float64_13): OrbitGtCoordinate;
    getPoint0(): OrbitGtCoordinate;
    getPoint1(): OrbitGtCoordinate;
    getPointAtDistance(d: float64_13): OrbitGtCoordinate;
    getPointAtDistanceTo(d: float64_13, point: OrbitGtCoordinate): void;
    getPointAtX(x: float64_13): float64_13;
    getPointAtXTo(x: float64_13, point: OrbitGtCoordinate): void;
    getPointAtY(y: float64_13): float64_13;
    getPointAtYTo(y: float64_13, point: OrbitGtCoordinate): void;
    getPointAtZ(z: float64_13): float64_13;
    getPointAtZTo(z: float64_13, point: OrbitGtCoordinate): void;
    getPointTo(t: float64_13, point: OrbitGtCoordinate): void;
    getPointX(t: float64_13): float64_13;
    getPointY(t: float64_13): float64_13;
    getPointZ(t: float64_13): float64_13;
    getProjection(point: OrbitGtCoordinate): float64_13;
    getProjectionPoint(point: OrbitGtCoordinate): OrbitGtCoordinate;
    getSegmentDistance(point: OrbitGtCoordinate): float64_13;
    getSquaredLength(): float64_13;
    static interpolate(point1: OrbitGtCoordinate, point2: OrbitGtCoordinate, t: float64_13, point: OrbitGtCoordinate): void;
    isParallel(line: OrbitGtLine): boolean;
    static isZero(value: float64_13): boolean;
    p0: OrbitGtCoordinate;
    p1: OrbitGtCoordinate;
    swapDirection(): OrbitGtLine;
    toString(): string;
}

// @internal (undocumented)
export class OrbitGtPointData {
    constructor(tileIndex: OrbitGtTileIndex, bounds: OrbitGtBounds);
    // (undocumented)
    bounds: OrbitGtBounds;
    // (undocumented)
    tileIndex: OrbitGtTileIndex;
}

// @internal (undocumented)
export class OrbitGtTileIndex {
    constructor(level: int32_4, index: int32_4, gridIndex: GridIndex, pointIndex: ALong, pointCount: int32_4);
    accessTime: float64_4;
    children: Array<OrbitGtTileIndex>;
    getKey(): string;
    gridIndex: GridIndex;
    index: int32_4;
    key: string;
    level: int32_4;
    pointCount: int32_4;
    pointIndex: ALong;
    same(other: OrbitGtTileIndex): boolean;
}

// @internal
export class OrbitGtTileLoadSorter implements OrbitGtComparator<OrbitGtTileIndex> {
    constructor(tileIndex: OrbitGtViewTree, viewProjector: OrbitGtIProjectToViewForSort);
    // (undocumented)
    static readonly _CLASSNAME_: string;
    // (undocumented)
    compare(tile1: OrbitGtTileIndex, tile2: OrbitGtTileIndex): int32_22;
    }

// @internal (undocumented)
export class OrbitGtTransform {
    constructor();
    clearTranslation(): OrbitGtTransform;
    concat(transform: OrbitGtTransform): OrbitGtTransform;
    copy(): OrbitGtTransform;
    static cos(angle: float64_14): float64_14;
    static create(): OrbitGtTransform;
    static createIdentity(): OrbitGtTransform;
    createInverse(): OrbitGtTransform;
    static createRotationX(angle: float64_14): OrbitGtTransform;
    static createRotationY(angle: float64_14): OrbitGtTransform;
    static createRotationZ(angle: float64_14): OrbitGtTransform;
    static createScale(sx: float64_14, sy: float64_14, sz: float64_14): OrbitGtTransform;
    static createSwapYZ(): OrbitGtTransform;
    static createTranslation(tx: float64_14, ty: float64_14, tz: float64_14): OrbitGtTransform;
    static createTranslation2(position: OrbitGtCoordinate): OrbitGtTransform;
    static createWithColumns(col0: OrbitGtCoordinate, col1: OrbitGtCoordinate, col2: OrbitGtCoordinate, col3: OrbitGtCoordinate): OrbitGtTransform;
    static createWithElements(elements: Float64Array): OrbitGtTransform;
    static fromColumnMajor(elements: Float64Array): OrbitGtTransform;
    static fromElements(m00: float64_14, m01: float64_14, m02: float64_14, m03: float64_14, m10: float64_14, m11: float64_14, m12: float64_14, m13: float64_14, m20: float64_14, m21: float64_14, m22: float64_14, m23: float64_14): OrbitGtTransform;
    static fromQuaternion(a: float64_14, b: float64_14, c: float64_14, d: float64_14): OrbitGtTransform;
    static fromRotationElements(m00: float64_14, m01: float64_14, m02: float64_14, m10: float64_14, m11: float64_14, m12: float64_14, m20: float64_14, m21: float64_14, m22: float64_14): OrbitGtTransform;
    static fromRowMajor(elements: Float64Array): OrbitGtTransform;
    get(index: int32_23): float64_14;
    getColumnX(): OrbitGtCoordinate;
    getColumnY(): OrbitGtCoordinate;
    getColumnZ(): OrbitGtCoordinate;
    getElement(row: int32_23, col: int32_23): float64_14;
    getElements(): Float64Array;
    getTranslation(): OrbitGtCoordinate;
    invert(): void;
    multiply(transform: OrbitGtTransform): void;
    static multiply2(a: OrbitGtTransform, b: OrbitGtTransform): OrbitGtTransform;
    static rotatePointX(point: OrbitGtCoordinate, rotation: float64_14): void;
    static rotatePointY(point: OrbitGtCoordinate, rotation: float64_14): void;
    static rotatePointZ(point: OrbitGtCoordinate, rotation: float64_14): void;
    rotateX(angle: float64_14): void;
    rotateY(angle: float64_14): void;
    rotateZ(angle: float64_14): void;
    same(other: OrbitGtTransform): boolean;
    scale(sx: float64_14, sy: float64_14, sz: float64_14): void;
    scale3(s: float64_14): void;
    set(index: int32_23, value: float64_14): void;
    setElement(row: int32_23, col: int32_23, value: float64_14): void;
    setElements(elements: Float64Array): void;
    setTranslation(tx: float64_14, ty: float64_14, tz: float64_14): OrbitGtTransform;
    static sin(angle: float64_14): float64_14;
    swapColumns(col1: int32_23, col2: int32_23): void;
    swapRows(row1: int32_23, row2: int32_23): void;
    swapYZ(): void;
    toString(): string;
    transform(source: OrbitGtCoordinate): OrbitGtCoordinate;
    transformBounds(bounds: OrbitGtBounds): OrbitGtBounds;
    transformTo(source: OrbitGtCoordinate, target: OrbitGtCoordinate): OrbitGtCoordinate;
    translate(tx: float64_14, ty: float64_14, tz: float64_14): void;
    translatePoint(point: OrbitGtCoordinate): void;
}

// @internal (undocumented)
export class OrbitGtViewTree {
    constructor(dataManager: OrbitGtDataManager, levels: Array<OrbitGtLevel>, dataBounds: OrbitGtBounds);
    getDataBounds(): OrbitGtBounds;
    getLevel(index: int32_21): OrbitGtLevel;
    getLevelCount(): int32_21;
    renderView3D(viewRequest: OrbitGtIViewRequest, levelsToLoad: OrbitGtAList<OrbitGtLevel>, blocksToLoad: OrbitGtAList<OrbitGtBlockIndex>, tilesToLoad: OrbitGtAList<OrbitGtTileIndex>, tilesToRender: OrbitGtAList<OrbitGtPointData>): void;
    setBlockTiles(blockIndex: OrbitGtBlockIndex, tileIndexes: Array<OrbitGtTileIndex>): void;
    setLevelBlocks(level: OrbitGtLevel, blockIndexes: Array<OrbitGtBlockIndex>): void;
    }

// @internal (undocumented)
export class PageCachedFile extends FileStorage {
    constructor(fileStorage: FileStorage, fileName: string, fileSize: ALong, pageSize: int32_37, maxPageCount: int32_37);
    close(): void;
    getFileLength(fileName: string): Promise<ALong>;
    printStatistics(clear: boolean): void;
    readFilePart(fileName: string, offset: ALong, size: int32_37): Promise<ABuffer>;
    readFileParts(fileName: string, ranges: OrbitGtAList<FileRange>): Promise<OrbitGtAList<FileContent>>;
    }

// @internal (undocumented)
export class PointCloudReader {
    constructor();
    clipToLevelRange(levelOffset: int32_16, levelCount: int32_16): PointCloudReader;
    close(): void;
    getFileBounds(): OrbitGtBounds;
    getFileCRS(): string;
    getFileName(): string;
    getFileStorage(): FileStorage;
    getLevelBlockGrid(level: int32_16): Grid;
    getLevelCount(): int32_16;
    getLevelPointBounds(level: int32_16): OrbitGtBounds;
    getLevelPointCount(level: int32_16): ALong;
    getLevelTileGrid(level: int32_16): Grid;
    getMaxAttributeValue(attribute: PointAttribute): AttributeValue;
    getMinAttributeValue(attribute: PointAttribute): AttributeValue;
    getPointAttributes(): Array<PointAttribute>;
    getProperty(propertyName: string): Object;
    peekBlockIndexes(level: int32_16): Array<OrbitGtBlockIndex>;
    readBlockIndexes(level: int32_16, fileContents: ContentLoader): Array<OrbitGtBlockIndex>;
    readPointData(tileIndex: OrbitGtTileIndex, dataFormat: int32_16, accessTime: float64_11, fileContents: ContentLoader): OrbitGtPointData;
    readPoints(tileIndex: OrbitGtTileIndex, parameters: ReadRequest, fileContents: ContentLoader): OrbitGtAList<CloudPoint>;
    readTileIndexes(block: OrbitGtBlockIndex, fileContents: ContentLoader): Array<OrbitGtTileIndex>;
}

// @internal (undocumented)
export class PointDataRaw extends OrbitGtPointData {
    constructor(tileIndex: OrbitGtTileIndex, bounds: OrbitGtBounds, points16: Uint16Buffer, points8: Uint8Buffer, colors: Uint8Buffer);
    // (undocumented)
    colors: Uint8Buffer;
    // (undocumented)
    getBlue(pointIndex: int32_31): int32_31;
    // (undocumented)
    getGreen(pointIndex: int32_31): int32_31;
    // (undocumented)
    getRawX(pointIndex: int32_31): int32_31;
    // (undocumented)
    getRawY(pointIndex: int32_31): int32_31;
    // (undocumented)
    getRawZ(pointIndex: int32_31): int32_31;
    // (undocumented)
    getRed(pointIndex: int32_31): int32_31;
    // (undocumented)
    getX(pointIndex: int32_31): float64_16;
    // (undocumented)
    getY(pointIndex: int32_31): float64_16;
    // (undocumented)
    getZ(pointIndex: int32_31): float64_16;
    // (undocumented)
    points16: Uint16Buffer;
    // (undocumented)
    points8: Uint8Buffer;
    // (undocumented)
    static readonly TYPE: int32_31;
}

// @internal (undocumented)
export class UrlFS extends FileStorage {
    constructor();
    close(): void;
    static getAzureBlobSasUrl(accountName: string, containerName: string, blobName: string, sasToken: string): string;
    getFileLength(url: string): Promise<ALong>;
    printStatistics(clear: boolean): void;
    readFilePart(url: string, offset: ALong, size: int32_38): Promise<ABuffer>;
    readFileParts(url: string, ranges: OrbitGtAList<FileRange>): Promise<OrbitGtAList<FileContent>>;
    // (undocumented)
    requestCount: number;
    // (undocumented)
    responseSize: number;
}


// (No @packageDocumentation comment for this package)

```
