## API Report File for "@bentley/ui-components"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionButton } from '@bentley/ui-abstract';
import { AlternateDateFormats } from '@bentley/ui-abstract';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BeUiEvent } from '@bentley/bentleyjs-core';
import { Cartographic } from '@bentley/imodeljs-common';
import { CheckBoxInfo as CheckBoxInfo_2 } from '@bentley/ui-core';
import { CheckBoxState } from '@bentley/ui-core';
import { ColorDef } from '@bentley/imodeljs-common';
import { CommonProps } from '@bentley/ui-core';
import { CommonToolbarItem } from '@bentley/ui-abstract';
import { ConnectDragPreview } from 'react-dnd';
import { ConnectDragSource } from 'react-dnd';
import { ConnectDropTarget } from 'react-dnd';
import { ContextComponent } from 'react-dnd';
import * as CSS from 'csstype';
import { CSSProperties } from 'react';
import { CustomButtonDefinition } from '@bentley/ui-abstract';
import { DateFormatter } from '@bentley/ui-abstract';
import { DndComponentClass } from 'react-dnd';
import { EnumerationChoice } from '@bentley/ui-abstract';
import { Face } from '@bentley/ui-core';
import { GenericUiEventArgs } from '@bentley/ui-abstract';
import { GlobalContextMenuProps } from '@bentley/ui-core';
import { GlobalDialogProps } from '@bentley/ui-core';
import { GroupButton } from '@bentley/ui-abstract';
import { HorizontalAlignment } from '@bentley/ui-core';
import { HSVColor } from '@bentley/imodeljs-common';
import { I18N } from '@bentley/imodeljs-i18n';
import { IconDefinition } from '@bentley/ui-abstract';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { immerable } from 'immer';
import { IModelConnection } from '@bentley/imodeljs-frontend';
import * as Inspire from 'inspire-tree';
import { Matrix3d } from '@bentley/geometry-core';
import { NoChildrenProps } from '@bentley/ui-core';
import { NodeCheckboxProps as NodeCheckboxProps_2 } from '@bentley/ui-core';
import { NodeCheckboxRenderer } from '@bentley/ui-core';
import { Observable as Observable_2 } from 'rxjs/internal/Observable';
import { Omit } from '@bentley/ui-core';
import { OnItemExecutedFunc } from '@bentley/ui-abstract';
import { OptionType } from '@bentley/ui-core';
import { Orientation } from '@bentley/ui-core';
import { OutputMessageAlert } from '@bentley/imodeljs-frontend';
import { OutputMessagePriority } from '@bentley/imodeljs-frontend';
import { OutputMessageType } from '@bentley/imodeljs-frontend';
import { ParseResults } from '@bentley/ui-abstract';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { Primitives } from '@bentley/ui-abstract';
import { PropertyDescription } from '@bentley/ui-abstract';
import { PropertyRecord } from '@bentley/ui-abstract';
import { PropertyValue } from '@bentley/ui-abstract';
import * as PropTypes from 'prop-types';
import { QuantityType } from '@bentley/imodeljs-frontend';
import { RatioChangeResult } from '@bentley/ui-core';
import * as React from 'react';
import ReactDataGrid = require('react-data-grid');
import { RelativePosition } from '@bentley/ui-abstract';
import { ScreenViewport } from '@bentley/imodeljs-frontend';
import { SortDirection } from '@bentley/ui-core';
import { StandardViewId } from '@bentley/imodeljs-frontend';
import { TentativePoint } from '@bentley/imodeljs-frontend';
import { TimeDisplay } from '@bentley/ui-abstract';
import { TimeFormat } from '@bentley/ui-core';
import { UiEvent } from '@bentley/ui-core';
import { UiSettings } from '@bentley/ui-core';
import { Vector3d } from '@bentley/geometry-core';
import { ViewManager } from '@bentley/imodeljs-frontend';
import { Viewport } from '@bentley/imodeljs-frontend';
import { ViewState } from '@bentley/imodeljs-frontend';

// @beta
export abstract class AbstractTreeNodeLoader implements ITreeNodeLoader {
    protected constructor(modelSource: TreeModelSource);
    protected abstract load(parent: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<LoadedNodeHierarchy>;
    loadNode(parent: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<TreeNodeLoadResult>;
    // (undocumented)
    get modelSource(): TreeModelSource;
    protected updateModel(loadedHierarchy: LoadedNodeHierarchy): void;
}

// @beta
export abstract class AbstractTreeNodeLoaderWithProvider<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoader implements ITreeNodeLoaderWithProvider<TDataProvider> {
    protected constructor(modelSource: TreeModelSource, dataProvider: TDataProvider);
    // (undocumented)
    get dataProvider(): TDataProvider;
    }

// @beta
export class ActionButtonList extends React.PureComponent<ActionButtonListProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @beta
export interface ActionButtonListProps {
    actionButtonRenderers: ActionButtonRenderer[];
    isPropertyHovered?: boolean;
    orientation: Orientation;
    property: PropertyRecord;
}

// @beta
export type ActionButtonRenderer = (props: ActionButtonRendererProps) => React.ReactNode;

// @beta
export interface ActionButtonRendererProps {
    isPropertyHovered?: boolean;
    property: PropertyRecord;
}

// @internal (undocumented)
export function ActionItem({ item, addGroupSeparator }: {
    item: ActionButton;
    addGroupSeparator: boolean;
}): JSX.Element;

// @beta
export interface ActiveMatchInfo {
    // (undocumented)
    matchIndex: number;
    // (undocumented)
    nodeId: string;
}

// @alpha
export function adjustDateToTimezone(inDateTime: Date, utcOffset: number): Date;

// @beta
export class AlphaSlider extends React.PureComponent<AlphaSliderProps> {
    // @internal
    constructor(props: AlphaSliderProps);
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    }

// @beta
export interface AlphaSliderProps extends React.HTMLAttributes<HTMLDivElement>, CommonProps {
    alpha: number;
    isHorizontal?: boolean;
    onAlphaChange?: ((alpha: number) => void) | undefined;
}

// @alpha
export type AnimationFractionChangeHandler = (animationFraction: number) => void;

// @public
export class ArrayPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): {} | null | undefined;
}

// @beta
export interface AsyncErrorMessage {
    // (undocumented)
    alertType?: OutputMessageAlert;
    // (undocumented)
    briefMessage: string;
    // (undocumented)
    detailedMessage?: string;
    // (undocumented)
    displayTime?: number;
    // (undocumented)
    msgType?: OutputMessageType;
    // (undocumented)
    priority: OutputMessagePriority;
}

// @beta
export interface AsyncValueProcessingResult {
    // (undocumented)
    encounteredError: boolean;
    // (undocumented)
    errorMessage?: AsyncErrorMessage;
    // (undocumented)
    returnValue?: PropertyValue;
}

// @public
export abstract class BasePointTypeConverter extends TypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    componentConverterName: string;
    // (undocumented)
    protected abstract constructPoint(_values: Primitives.Point): ConvertedPrimitives.Point | undefined;
    // (undocumented)
    convertFromString(value: string): ConvertedPrimitives.Point2d | ConvertedPrimitives.Point3d | undefined;
    // (undocumented)
    convertToString(value?: Primitives.Point): string | Promise<string>;
    // (undocumented)
    protected abstract getVectorLength(point: Primitives.Point): number | undefined;
    // (undocumented)
    sortCompare(a: Primitives.Point, b: Primitives.Point, _ignoreCase?: boolean): number;
}

// @alpha
export class BaseSolarDataProvider implements SolarDataProvider {
    constructor(viewport?: ScreenViewport, longitude?: number, latitude?: number);
    // (undocumented)
    animationFraction: number;
    // (undocumented)
    protected _cartographicCenter: Cartographic;
    // (undocumented)
    get day(): Date;
    set day(dayVal: Date);
    // (undocumented)
    get dayStartMs(): number;
    // (undocumented)
    getCartographicCenter(iModel: IModelConnection): Cartographic;
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
    // (undocumented)
    onTimeChanged: (_time: Date) => void;
    // (undocumented)
    get shadowColor(): ColorDef;
    set shadowColor(color: ColorDef);
    // (undocumented)
    protected _shadowColor: ColorDef;
    // (undocumented)
    get shouldShowTimeline(): boolean;
    // (undocumented)
    get sunrise(): Date;
    // (undocumented)
    get sunset(): Date;
    // (undocumented)
    supportsTimelineAnimation: boolean;
    // (undocumented)
    timeOfDay: Date;
    // (undocumented)
    viewId: string;
    set viewport(viewport: ScreenViewport | undefined);
    // (undocumented)
    get viewport(): ScreenViewport | undefined;
    // (undocumented)
    protected _viewport: ScreenViewport | undefined;
}

// @alpha
export class BaseTimelineDataProvider implements TimelineDataProvider {
    constructor(viewport?: ScreenViewport);
    // (undocumented)
    animationFraction: number;
    get duration(): number;
    // (undocumented)
    end: Date | undefined;
    // (undocumented)
    findMilestoneById(milestoneId: string, milestones?: Milestone[]): Milestone | undefined;
    // (undocumented)
    getMilestones(parent?: Milestone): Milestone[];
    // (undocumented)
    getMilestonesCount(parent?: Milestone): number;
    // (undocumented)
    getSettings(): PlaybackSettings;
    // (undocumented)
    readonly id = "TestTimelineDataProvider";
    get initialDuration(): number;
    // (undocumented)
    loadTimelineData(): Promise<boolean>;
    // (undocumented)
    get loop(): boolean;
    // (undocumented)
    protected _milestones: Milestone[];
    // (undocumented)
    onAnimationFractionChanged: (_animationFraction: number) => void;
    // (undocumented)
    onPlaybackSettingChanged: (_settings: PlaybackSettings) => void;
    // (undocumented)
    protected _settings: PlaybackSettings;
    // (undocumented)
    start: Date | undefined;
    // (undocumented)
    supportsTimelineAnimation: boolean;
    // (undocumented)
    updateSettings(settings: PlaybackSettings): void;
    // (undocumented)
    viewId: string;
    set viewport(viewport: ScreenViewport | undefined);
    // (undocumented)
    get viewport(): ScreenViewport | undefined;
    // (undocumented)
    protected _viewport: ScreenViewport | undefined;
}

// @beta
export class BasicPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export const BeDragDropContext: typeof BeDragDropContextComponent & ContextComponent<any>;

// @beta
export class BeDragDropContextComponent extends React.PureComponent {
    // (undocumented)
    render(): React.ReactNode;
}

// @public @deprecated
export class BeInspireTree<TNodePayload> {
    constructor(props: BeInspireTreeProps<TNodePayload>);
    // @internal
    applyChanges(): void;
    collapsed(): BeInspireTreeNodes<TNodePayload>;
    // @internal (undocumented)
    createPlaceholderNode(index: number, parent?: BeInspireTreeNode<TNodePayload>): BeInspireTreeNode<TNodePayload>;
    deepest(): BeInspireTreeNodes<TNodePayload>;
    deselectAll(muteEvents?: boolean): void;
    expanded(): BeInspireTreeNodes<TNodePayload>;
    flatten(): BeInspireTreeNodes<TNodePayload>;
    getVisibleNodesBetween(node1: BeInspireTreeNode<TNodePayload>, node2: BeInspireTreeNode<TNodePayload>): Array<BeInspireTreeNode<TNodePayload>>;
    // @internal (undocumented)
    loadNodes(): Promise<void>;
    mute(events: BeInspireTreeEvent[]): EventsMuteContext;
    node(id: string): BeInspireTreeNode<TNodePayload> | undefined;
    nodes(ids?: string[]): BeInspireTreeNodes<TNodePayload>;
    on(event: BeInspireTreeEvent | BeInspireTreeEvent[], listener: (...values: any[]) => void): this;
    pauseRendering(allowedRendersBeforePause?: number): EventsMuteContext;
    // (undocumented)
    props: BeInspireTreeProps<TNodePayload>;
    // (undocumented)
    get ready(): Promise<void>;
    reload(): Promise<void>;
    removeAllListeners(event?: BeInspireTreeEvent | BeInspireTreeEvent[]): void;
    removeListener(event: BeInspireTreeEvent | BeInspireTreeEvent[], listener: (...values: any[]) => void): this;
    requestNodeLoad(parent: BeInspireTreeNode<TNodePayload> | undefined, index: number): Promise<void>;
    selectBetween(node1: BeInspireTreeNode<TNodePayload>, node2: BeInspireTreeNode<TNodePayload>, muteEvents?: boolean): Array<BeInspireTreeNode<TNodePayload>>;
    selected(): BeInspireTreeNodes<TNodePayload>;
    updateNodesCheckboxes(nodes: BeInspireTreeNodes<TNodePayload>, checkboxInfo: ((payload: TNodePayload) => CheckBoxInfo_2 | Promise<CheckBoxInfo_2>), muteEvents?: boolean): Promise<void>;
    updateNodesSelection(nodes: BeInspireTreeNodes<TNodePayload> | Inspire.TreeNodes, nodesToSelect?: string[] | ((payload: TNodePayload) => boolean), muteEvents?: boolean): void;
    updateTreeCheckboxes(checkboxInfo: ((payload: TNodePayload) => CheckBoxInfo_2 | Promise<CheckBoxInfo_2>), muteEvents?: boolean): Promise<void>;
    updateTreeSelection(nodesToSelect?: string[] | ((payload: TNodePayload) => boolean), muteEvents?: boolean): void;
    visible(): BeInspireTreeNodes<TNodePayload>;
    }

// @public @deprecated
export type BeInspireTreeDataProvider<TPayload> = BeInspireTreeDataProviderRaw<TPayload> | BeInspireTreeDataProviderPromise<TPayload> | BeInspireTreeDataProviderMethod<TPayload> | BeInspireTreeDataProviderInterface<TPayload>;

// @public @deprecated
export interface BeInspireTreeDataProviderInterface<TPayload> {
    // (undocumented)
    getNodes(parent?: TPayload, page?: PageOptions): BeInspireTreeDataProviderPromise<TPayload>;
    // (undocumented)
    getNodesCount(parent?: TPayload): Promise<number>;
}

// @public @deprecated
export type BeInspireTreeDataProviderMethod<TPayload> = (parent?: TPayload) => BeInspireTreeDataProviderPromise<TPayload>;

// @public @deprecated
export type BeInspireTreeDataProviderPromise<TPayload> = Promise<BeInspireTreeDataProviderRaw<TPayload>>;

// @public @deprecated
export type BeInspireTreeDataProviderRaw<TPayload> = TPayload[];

// @public @deprecated
export enum BeInspireTreeEvent {
    // (undocumented)
    ChangesApplied = "changes.applied",
    // (undocumented)
    ChildrenLoaded = "children.loaded",
    // (undocumented)
    DataLoaded = "data.loaded",
    // (undocumented)
    DataLoadError = "data.loaderror",
    // (undocumented)
    ModelLoaded = "model.loaded",
    // (undocumented)
    NodeAdded = "node.added",
    // (undocumented)
    NodeBlurred = "node.blurred",
    // (undocumented)
    NodeChecked = "node.checked",
    // (undocumented)
    NodeCollapsed = "node.collapsed",
    // (undocumented)
    NodeDeselected = "node.deselected",
    // (undocumented)
    NodeEdited = "node.edited",
    // (undocumented)
    NodeExpanded = "node.expanded",
    // (undocumented)
    NodeFocused = "node.focused",
    // (undocumented)
    NodeHidden = "node.hidden",
    // (undocumented)
    NodeMoved = "node.moved",
    // (undocumented)
    NodePaginated = "node.paginated",
    // (undocumented)
    NodeRemoved = "node.removed",
    // (undocumented)
    NodeSelected = "node.selected",
    // (undocumented)
    NodeShown = "node.shown",
    // (undocumented)
    NodeUnchecked = "node.unchecked"
}

// @public @deprecated
export interface BeInspireTreeNode<TPayload> extends Inspire.TreeNode, BeInspireTreeNodePayloadConfig<TPayload> {
    // (undocumented)
    isDirty(): boolean;
    // @internal (undocumented)
    resetBeInspireOverrides(): void;
    // (undocumented)
    setDirty(value: boolean): void;
}

// @public @deprecated
export interface BeInspireTreeNodeConfig {
    // (undocumented)
    children?: BeInspireTreeNodeConfig[] | true;
    // (undocumented)
    id?: string;
    // (undocumented)
    itree?: BeInspireTreeNodeITree;
    // (undocumented)
    text: string;
}

// @public @deprecated
export interface BeInspireTreeNodeITree {
    // (undocumented)
    checkboxTooltip?: string;
    // (undocumented)
    dirtyCounter?: number;
    // (undocumented)
    dirtyTimestamp?: number;
    // (undocumented)
    icon?: string;
    // (undocumented)
    state?: {
        checkboxVisible?: boolean;
        checkboxDisabled?: boolean;
        checked?: boolean;
        collapsed?: boolean;
        editable?: boolean;
        focused?: boolean;
        indeterminate?: boolean;
        loading?: boolean;
        selectable?: boolean;
        selected?: boolean;
    };
}

// @public @deprecated
export interface BeInspireTreeNodePayloadConfig<TPayload> extends BeInspireTreeNodeConfig {
    beInspireTree: BeInspireTree<TPayload>;
    payload?: TPayload;
    placeholderIndex?: number;
}

// @public @deprecated
export interface BeInspireTreeNodes<TPayload> extends Array<BeInspireTreeNode<TPayload>> {
    // (undocumented)
    collapsed(): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    deepest(): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    expanded(): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    flatten(): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    node(id: string): BeInspireTreeNode<TPayload> | undefined;
    // (undocumented)
    nodes(ids?: string[]): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    selected(): BeInspireTreeNodes<TPayload>;
    // (undocumented)
    visible(): BeInspireTreeNodes<TPayload>;
}

// @public @deprecated
export interface BeInspireTreeProps<TNodePayload> {
    // (undocumented)
    dataProvider: BeInspireTreeDataProvider<TNodePayload>;
    // (undocumented)
    disposeChildrenOnCollapse?: boolean;
    // (undocumented)
    mapPayloadToInspireNodeConfig: MapPayloadToInspireNodeCallback<TNodePayload>;
    // (undocumented)
    pageSize?: number;
}

// @public @deprecated
export type BeInspireTreeRenderer<TPayload> = (rootNodes: Array<BeInspireTreeNode<TPayload>>) => void;

// @beta
export class BooleanEditor extends React.PureComponent<PropertyEditorProps, BooleanEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<BooleanEditorState>;
    }

// @beta
export class BooleanPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class BooleanTypeConverter extends TypeConverter {
    // (undocumented)
    convertFromString(value: string): boolean;
    // (undocumented)
    convertToString(value?: Primitives.Boolean): string;
    // @internal (undocumented)
    static getLocalizedTrueFalse(): void;
    // (undocumented)
    get isBooleanType(): boolean;
    // @internal (undocumented)
    static sl10nFalse: string;
    // @internal (undocumented)
    static sl10nTrue: string;
    // (undocumented)
    sortCompare(a: Primitives.Boolean, b: Primitives.Boolean, _ignoreCase?: boolean): number;
}

// @beta
export class Breadcrumb extends React.Component<BreadcrumbProps, BreadcrumbState> {
    // @internal
    constructor(props: BreadcrumbProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: BreadcrumbProps, prevState: BreadcrumbState): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static defaultProps: Partial<BreadcrumbProps>;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: BreadcrumbProps, state: BreadcrumbState): BreadcrumbState | null;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    shouldComponentUpdate(nextProps: BreadcrumbProps, nextState: BreadcrumbState): boolean;
    // @internal (undocumented)
    readonly state: Readonly<BreadcrumbState>;
}

// @beta
export class BreadcrumbDetails extends React.Component<BreadcrumbDetailsProps, BreadcrumbDetailsState> {
    // @internal
    constructor(props: BreadcrumbDetailsProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: BreadcrumbDetailsProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    shouldComponentUpdate(nextProps: BreadcrumbDetailsProps, nextState: BreadcrumbDetailsState): boolean;
    // (undocumented)
    readonly state: BreadcrumbDetailsState;
    }

// @beta
export interface BreadcrumbDetailsDragDropProps<DragDropObject = any> {
    // (undocumented)
    dragProps?: DragSourceProps<DragDropObject>;
    // (undocumented)
    dropProps?: DropTargetProps<DragDropObject>;
}

// @beta
export type BreadcrumbDetailsDragDropType = {} | TreeNodeItem | TableDataProvider;

// @beta
export interface BreadcrumbDetailsProps extends CommonProps {
    // (undocumented)
    columns?: ColumnDescription[];
    onChildrenLoaded?: (parent: TreeNodeItem, children: TreeNodeItem[]) => void;
    // @internal (undocumented)
    onRender?: () => void;
    onRootNodesLoaded?: (nodes: TreeNodeItem[]) => void;
    path: BreadcrumbPath;
    // (undocumented)
    renderTable?: (props: TableProps, node: TreeNodeItem | undefined, children: TreeNodeItem[]) => React.ReactNode;
}

// @beta
export interface BreadcrumbDragDropProps<DragDropObject = any> {
    // (undocumented)
    dragProps?: DragSourceProps<DragDropObject>;
    // (undocumented)
    dropProps?: DropTargetProps<DragDropObject>;
}

// @internal (undocumented)
export class BreadcrumbInput extends React.Component<BreadcrumbInputProps, BreadcrumbInputState> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    readonly state: Readonly<BreadcrumbInputState>;
}

// @internal (undocumented)
export interface BreadcrumbInputProps {
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    node?: BeInspireTreeNode<TreeNodeItem>;
    // (undocumented)
    onCancel: () => void;
    // (undocumented)
    onNodeChange: (node: TreeNodeItem | undefined) => void;
    // (undocumented)
    parentsOnly?: boolean;
    // (undocumented)
    pathString: string;
    // (undocumented)
    tree: BeInspireTree<TreeNodeItem>;
    // (undocumented)
    width: number | string;
}

// @internal (undocumented)
export interface BreadcrumbInputState {
    // (undocumented)
    autocompleteList: string[];
    // (undocumented)
    autocompleting: boolean;
    // (undocumented)
    messageBoxOpened: boolean;
}

// @beta
export enum BreadcrumbMode {
    // (undocumented)
    Dropdown = "dropdown",
    // (undocumented)
    Input = "input"
}

// @beta
export class BreadcrumbNode extends React.Component<BreadcrumbNodeProps> {
    constructor(props: BreadcrumbNodeProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    render(): React.ReactNode;
}

// @beta
export interface BreadcrumbNodeProps {
    icon: string;
    label: PropertyRecord;
    // @internal (undocumented)
    onRender?: () => void;
}

// @internal (undocumented)
export type BreadcrumbNodeRenderer = (props: BreadcrumbNodeProps, node?: TreeNodeItem, parent?: TreeNodeItem) => React.ReactNode;

// @beta
export class BreadcrumbPath {
    constructor(dataProvider: TreeDataProvider);
    // (undocumented)
    get BreadcrumbUpdateEvent(): BreadcrumbUpdateEvent;
    // (undocumented)
    getCurrentNode(): TreeNodeItem | undefined;
    // (undocumented)
    getDataProvider(): TreeDataProvider;
    // (undocumented)
    setCurrentNode(currentNode: TreeNodeItem | undefined): void;
    // (undocumented)
    setDataProvider(dataProvider: TreeDataProvider): void;
}

// @beta
export interface BreadcrumbProps extends CommonProps {
    background?: boolean;
    dataProvider: TreeDataProvider;
    delimiter?: string;
    dropdownOnly?: boolean;
    // @internal (undocumented)
    expandedNodes?: boolean;
    initialBreadcrumbMode?: BreadcrumbMode;
    initialCurrent?: TreeNodeItem;
    onChildrenLoaded?: (parent: TreeNodeItem, children: TreeNodeItem[]) => void;
    // @internal (undocumented)
    onRender?: () => void;
    onRootNodesLoaded?: (nodes: TreeNodeItem[]) => void;
    parentsOnly?: boolean;
    path?: BreadcrumbPath;
    // @internal (undocumented)
    renderNode?: BreadcrumbNodeRenderer;
    showUpDir?: boolean;
    staticOnly?: boolean;
    width?: number | string;
}

// @beta
export class BreadcrumbTreeUtils {
    static aliasNodeListToTableDataProvider(nodes: TreeNodeItem[], columns: ColumnDescription[], treeDataProvider?: TreeDataProvider): TableDataProvider;
    }

// @beta
export class BreadcrumbUpdateEvent extends UiEvent<BreadcrumbUpdateEventArgs> {
}

// @beta
export interface BreadcrumbUpdateEventArgs {
    // (undocumented)
    currentNode: TreeNodeItem | undefined;
    // (undocumented)
    dataProvider: TreeDataProvider;
    // (undocumented)
    oldDataProvider: TreeDataProvider;
}

// @alpha
export interface CategorizedPropertyItem extends FlatGridItemBase {
    // (undocumented)
    readonly derivedRecord: PropertyRecord;
    // (undocumented)
    getChildren(): CategorizedPropertyItem[];
    // (undocumented)
    readonly parentCategorySelectionKey: string;
    // (undocumented)
    readonly parentSelectionKey: string;
    // (undocumented)
    readonly type: CategorizedPropertyTypes;
}

// @alpha
export type CategorizedPropertyTypes = FlatGridItemType.Array | FlatGridItemType.Primitive | FlatGridItemType.Struct;

// @alpha
export interface CategoryRecordsDict {
    // (undocumented)
    [categoryName: string]: PropertyRecord[];
}

// @beta @deprecated
export class CellEditingEngine {
    constructor(props: EditableTreeProps);
    // (undocumented)
    activateEditor: (node: BeInspireTreeNode<TreeNodeItem>) => void;
    // (undocumented)
    checkStatus: (node: BeInspireTreeNode<TreeNodeItem>, isPressedItemSelected: boolean) => void;
    // (undocumented)
    static createPropertyRecord(value: string, typename?: string, editor?: string): PropertyRecord;
    // (undocumented)
    deactivateEditor: () => void;
    // (undocumented)
    get hasSubscriptions(): boolean;
    // (undocumented)
    isEditingEnabled(node: BeInspireTreeNode<TreeNodeItem>): boolean | undefined;
    // (undocumented)
    renderEditor(node: BeInspireTreeNode<TreeNodeItem>, style?: React.CSSProperties): JSX.Element;
    // (undocumented)
    subscribe(getCurrentNode: GetCurrentlyEditedNode, setCurrentNode: SetCurrentlyEditedNode): void;
    // (undocumented)
    unsubscribe(): void;
}

// @public
export interface CellItem {
    alignment?: HorizontalAlignment;
    isDisabled?: boolean;
    key: string;
    record?: PropertyRecord;
    style?: ItemStyle;
}

// @public
export interface CellProps {
    // (undocumented)
    displayValue: string;
    // (undocumented)
    item: CellItem;
    // (undocumented)
    render: React.ComponentType<{
        isSelected: boolean;
    }>;
}

// @beta
export interface CheckBoxInfo {
    // (undocumented)
    readonly isDisabled: boolean;
    // (undocumented)
    readonly isVisible: boolean;
    // (undocumented)
    readonly state: CheckBoxState;
    // (undocumented)
    readonly tooltip?: string;
}

// @beta
export interface CheckboxStateChange {
    newState: CheckBoxState;
    nodeItem: TreeNodeItem;
}

// @beta
export class ColorEditor extends React.PureComponent<PropertyEditorProps, ColorEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ColorEditorState>;
}

// @beta
export const ColorPickerButton: React.ForwardRefExoticComponent<ColorPickerProps & React.RefAttributes<HTMLButtonElement>>;

// @beta
export function ColorPickerDialog({ dialogTitle, color, onOkResult, onCancelResult, colorPresets }: ColorPickerDialogProps): JSX.Element;

// @beta
export interface ColorPickerDialogProps {
    // (undocumented)
    color: ColorDef;
    // (undocumented)
    colorPresets?: ColorDef[];
    // (undocumented)
    dialogTitle: string;
    // (undocumented)
    onCancelResult: () => void;
    // (undocumented)
    onOkResult: (selectedColor: ColorDef) => void;
}

// @beta
export function ColorPickerPanel({ activeColor, onColorChange, colorPresets }: ColorPickerPanelProps): JSX.Element;

// @beta
export interface ColorPickerPanelProps {
    // (undocumented)
    activeColor: ColorDef;
    // (undocumented)
    colorPresets?: ColorDef[];
    // (undocumented)
    onColorChange: (selectedColor: ColorDef) => void;
}

// @beta
export const ColorPickerPopup: React.ForwardRefExoticComponent<ColorPickerPopupProps & React.RefAttributes<HTMLButtonElement>>;

// @beta
export interface ColorPickerPopupProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    colorDefs?: ColorDef[];
    disabled?: boolean;
    initialColor: ColorDef;
    onColorChange?: ((newColor: ColorDef) => void) | undefined;
    popupPosition?: RelativePosition;
    readonly?: boolean;
}

// @beta
export interface ColorPickerProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    colorDefs?: ColorDef[];
    disabled?: boolean;
    dropDownTitle?: string;
    initialColor: ColorDef;
    numColumns?: number;
    onColorPick?: ((color: ColorDef) => void) | undefined;
    readonly?: boolean;
    round?: boolean;
}

// @beta
export class ColorPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export function ColorSwatch(props: ColorSwatchProps): JSX.Element;

// @beta
export interface ColorSwatchProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    colorDef: ColorDef;
    onColorPick?: ((color: ColorDef, e: React.MouseEvent) => void) | undefined;
    round?: boolean;
}

// @public
export interface ColumnDescription {
    editable?: boolean;
    filterable?: boolean;
    // (undocumented)
    filterCaseSensitive?: boolean;
    // @beta
    filterRenderer?: FilterRenderer;
    icon?: boolean;
    key: string;
    label: string;
    propertyDescription?: PropertyDescription;
    resizable?: boolean;
    secondarySortColumn?: number;
    // (undocumented)
    showDistinctValueFilters?: boolean;
    // (undocumented)
    showFieldFilters?: boolean;
    sortable?: boolean;
    sortIgnoreCase?: boolean;
    width?: number;
}

// @beta
export interface ColumnFilterDescriptor extends FilterDescriptor {
    distinctFilter: DistinctValuesFilterDescriptor;
    fieldFilter: FieldFilterDescriptor;
}

// @public
export interface CommonPropertyGridProps extends CommonProps {
    // @beta
    actionButtonRenderers?: ActionButtonRenderer[];
    actionButtonWidth?: number;
    // @beta
    horizontalOrientationMinWidth?: number;
    // @beta
    isOrientationFixed?: boolean;
    // @beta
    isPropertyEditingEnabled?: boolean;
    isPropertyHoverEnabled?: boolean;
    isPropertySelectionEnabled?: boolean;
    isPropertySelectionOnRightClickEnabled?: boolean;
    minLabelWidth?: number;
    minValueWidth?: number;
    onPropertyContextMenu?: (args: PropertyGridContextMenuArgs) => void;
    // @beta
    onPropertyEditing?: (args: PropertyEditingArgs, category: PropertyCategory) => void;
    // @beta
    onPropertyLinkClick?: (property: PropertyRecord, text: string) => void;
    onPropertySelectionChanged?: (property: PropertyRecord) => void;
    // @beta
    onPropertyUpdated?: (args: PropertyUpdatedArgs, category: PropertyCategory) => Promise<boolean>;
    orientation?: Orientation;
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @public
export interface CompletionObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete: () => void;
    // (undocumented)
    error?: (err: any) => void;
    // (undocumented)
    next?: (value: T) => void;
}

// @beta
export interface CompositeFilterDescriptor extends FilterDescriptor {
    filterDescriptorCollection: FilterDescriptorCollection;
    logicalOperator: FilterCompositionLogicalOperator;
}

// @beta
export interface CompositeFilterDescriptorCollection {
    add(item: FilterDescriptor): void;
    clear(): void;
    count: number;
    evaluateRow(row: RowItem): boolean;
    getColumnFilterDescriptor(columnKey: string): ColumnFilterDescriptor | undefined;
    getFilterExpression(): string;
    isColumnFilterActive(columnKey: string): boolean;
    logicalOperator: FilterCompositionLogicalOperator;
}

// @alpha
export enum CompositeFilterType {
    // (undocumented)
    And = 0,
    // (undocumented)
    Or = 1
}

// @alpha
export class CompositePropertyDataFilterer extends PropertyDataFiltererBase {
    constructor(_leftFilterer: IPropertyDataFilterer, _operator: CompositeFilterType, _rightFilterer: IPropertyDataFilterer);
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    matchesFilter(node: PropertyRecord, parents: PropertyRecord[]): Promise<PropertyDataFilterResult>;
    }

// @public
export class CompositeTypeConverter extends TypeConverter {
    // (undocumented)
    convertToString(value?: Primitives.Composite): string | Promise<string>;
    // (undocumented)
    sortCompare(valueA: Primitives.Composite, valueB: Primitives.Composite, ignoreCase?: boolean | undefined): number;
}

// @internal
export class ContextMenu extends React.Component<ContextMenuProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export class ContextMenuItem extends React.Component<MenuItem> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface ContextMenuProps extends CommonProps {
    isOpened: boolean;
    items?: MenuItem[];
    onClickOutside?: () => void;
    parent: HTMLElement | null;
    position: RelativePosition;
}

// @beta
export function ControlledSelectableContent(props: ControlledSelectableContentProps): JSX.Element;

// @beta
export interface ControlledSelectableContentProps {
    // (undocumented)
    children: SelectableContentDefinition[];
    // (undocumented)
    onSelectedContentIdChanged?: (contentId: string) => void;
    // (undocumented)
    selectAriaLabel?: string;
    // (undocumented)
    selectedContentId: string;
}

// @beta
export function ControlledTree(props: ControlledTreeProps): JSX.Element;

// @beta
export interface ControlledTreeProps extends CommonProps {
    descriptionsEnabled?: boolean;
    iconsEnabled?: boolean;
    noDataRenderer?: () => React.ReactElement;
    nodeHighlightingProps?: HighlightableTreeProps;
    nodeLoader: ITreeNodeLoader;
    selectionMode: SelectionMode;
    spinnerRenderer?: () => React.ReactElement;
    treeEvents: TreeEvents;
    treeRenderer?: (props: TreeRendererProps) => React.ReactElement;
    visibleNodes: VisibleTreeNodes;
}

// @public
export namespace ConvertedPrimitives {
    export type Point = Point2d | Point3d;
    export interface Point2d {
        // (undocumented)
        x: number;
        // (undocumented)
        y: number;
    }
    export interface Point3d extends Point2d {
        // (undocumented)
        z: number;
    }
    export type Value = boolean | number | string | Date | Point | Id64String;
}

// @internal (undocumented)
export enum CubeHover {
    // (undocumented)
    Active = 2,
    // (undocumented)
    Hover = 1,
    // (undocumented)
    None = 0
}

// @beta
export class CubeNavigationAid extends React.Component<CubeNavigationAidProps, CubeNavigationAidState> {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<CubeNavigationAidState>;
}

// @beta
export interface CubeNavigationAidProps extends CommonProps {
    // @internal (undocumented)
    animationTime?: number;
    // (undocumented)
    iModelConnection: IModelConnection;
    // @internal (undocumented)
    onAnimationEnd?: () => void;
    // (undocumented)
    viewport?: Viewport;
}

// @public
export class CubeRotationChangeEvent extends UiEvent<CubeRotationChangeEventArgs> {
}

// @public
export interface CubeRotationChangeEventArgs {
    // (undocumented)
    complete?: boolean;
    // (undocumented)
    face: Face;
    // (undocumented)
    rotMatrix: Matrix3d;
}

// @internal (undocumented)
export function CustomItem({ item, addGroupSeparator }: {
    item: CustomToolbarItem;
    addGroupSeparator: boolean;
}): JSX.Element | null;

// @alpha
export class CustomNumberEditor extends React.PureComponent<PropertyEditorProps, CustomNumberEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<CustomNumberEditorState>;
    }

// @alpha
export class CustomNumberPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export interface CustomToolbarItem extends CustomButtonDefinition {
    // (undocumented)
    buttonNode?: React.ReactNode;
    // (undocumented)
    panelContentNode?: React.ReactNode;
}

// @beta
export interface DataController {
    // (undocumented)
    commitValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    validateValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @beta
export abstract class DataControllerBase implements DataController {
    // (undocumented)
    commitValue(_newValue: PropertyValue, _record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    validateValue(_newValue: PropertyValue, _record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @internal (undocumented)
export interface DataRowItem extends RowItem {
    // (undocumented)
    _node?: TreeNodeItem;
}

// @internal
export function DateField({ initialDate, onDateChange, readOnly, dateFormatter, timeDisplay, style, className }: DateFieldProps): JSX.Element;

// @internal
export interface DateFieldProps extends CommonProps {
    dateFormatter?: DateFormatter;
    initialDate: Date;
    onDateChange?: (day: Date) => void;
    readOnly?: boolean;
    timeDisplay?: TimeDisplay;
}

// @alpha
export function DatePicker(props: DatePickerProps): JSX.Element;

// @alpha
export function DatePickerPopupButton({ displayEditField, timeDisplay, selected, onDateChange, dateFormatter, buttonToolTip, fieldStyle, fieldClassName }: DatePickerPopupButtonProps): JSX.Element;

// @alpha
export interface DatePickerPopupButtonProps extends CommonProps {
    buttonToolTip?: string;
    // (undocumented)
    dateFormatter?: DateFormatter;
    displayEditField?: boolean;
    fieldClassName?: string;
    fieldStyle?: React.CSSProperties;
    onDateChange?: (day: Date) => void;
    selected: Date;
    // (undocumented)
    timeDisplay?: TimeDisplay;
}

// @alpha
export interface DatePickerProps {
    onDateChange?: (day: Date) => void;
    selected: Date;
    showFocusOutline?: boolean;
}

// @internal
export class DateTimeEditor extends React.PureComponent<DateTimeEditorProps, DateTimeEditorState> implements TypeEditor {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    processDateChange(typeConverter: TypeConverter, newValue: Date): Promise<void>;
    // (undocumented)
    render(): React.ReactNode;
    // (undocumented)
    readonly state: Readonly<DateTimeEditorState>;
}

// @internal
export class DateTimePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class DateTimeTypeConverter extends DateTimeTypeConverterBase {
    // (undocumented)
    protected getTimeFormat(): TimeFormat;
}

// @public
export abstract class DateTimeTypeConverterBase extends TypeConverter implements LessGreaterOperatorProcessor {
    // (undocumented)
    convertFromString(value: string): Date | undefined;
    convertFromStringWithOptions(value: string, options?: {
        [key: string]: any;
    }): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    // (undocumented)
    convertToString(value?: Primitives.Value): string;
    // (undocumented)
    convertToStringWithOptions(value?: Primitives.Value, options?: {
        [key: string]: any;
    }): string | Promise<string>;
    // (undocumented)
    protected abstract getTimeFormat(): TimeFormat;
    // (undocumented)
    static isAlternateDateFormats(type: AlternateDateFormats): boolean;
    // (undocumented)
    isEqualTo(valueA: Date, valueB: Date): boolean;
    // (undocumented)
    isGreaterThan(a: Date, b: Date): boolean;
    // (undocumented)
    isGreaterThanOrEqualTo(a: Date, b: Date): boolean;
    // (undocumented)
    get isLessGreaterType(): boolean;
    // (undocumented)
    isLessThan(a: Date, b: Date): boolean;
    // (undocumented)
    isLessThanOrEqualTo(a: Date, b: Date): boolean;
    // (undocumented)
    isNotEqualTo(valueA: Date, valueB: Date): boolean;
    // (undocumented)
    static isValidTimeDisplay(type: TimeDisplay): boolean;
    // (undocumented)
    sortCompare(valueA: Date, valueB: Date, _ignoreCase?: boolean): number;
}

// @public
export interface DelayLoadedTreeNodeItem extends TreeNodeItem {
    // (undocumented)
    hasChildren?: boolean;
}

// @public @deprecated
export interface DEPRECATED_FilteringInputProps extends CommonProps {
    autoFocus?: boolean;
    // @deprecated
    filteringInProgress: boolean;
    onFilterCancel: () => void;
    onFilterClear: () => void;
    onFilterStart: (searchText: string) => void;
    resultSelectorProps?: ResultSelectorProps;
}

// @public @deprecated
export class DEPRECATED_Tree extends React.Component<TreeProps, TreeState> {
    // @internal
    constructor(props: TreeProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: TreeProps, prevState: TreeState): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static readonly defaultProps: Partial<TreeProps>;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: TreeProps, state: TreeState): TreeState | null;
    getLoadedNode(id: string): TreeNodeItem | undefined;
    // @internal
    static inspireNodeFromTreeNodeItem(item: TreeNodeItem, remapper: MapPayloadToInspireNodeCallback<TreeNodeItem>, base?: BeInspireTreeNodeConfig): BeInspireTreeNodeConfig;
    // @internal (undocumented)
    render(): JSX.Element;
    // (undocumented)
    shouldComponentUpdate(nextProps: TreeProps, nextState: TreeState): boolean;
    }

// @beta @deprecated
export function DEPRECATED_withTreeDragDrop<P extends TreeProps, DragDropObject extends TreeDragDropType>(TreeComponent: React.ComponentType<P>): React.ComponentType<P & TreeDragDropProps<DragDropObject>>;

// @beta
export enum Direction {
    // (undocumented)
    Bottom = 4,
    // (undocumented)
    Left = 1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    Top = 2
}

// @internal
export class DirectionHelpers {
    static readonly BOTTOM_CLASS_NAME = "components-direction-bottom";
    // (undocumented)
    static getCssClassName(direction: Direction): string;
    // (undocumented)
    static getOrthogonalDirection(direction: Direction): OrthogonalDirection;
    static readonly LEFT_CLASS_NAME = "components-direction-left";
    static readonly RIGHT_CLASS_NAME = "components-direction-right";
    static readonly TOP_CLASS_NAME = "components-direction-top";
}

// @alpha
export class DisplayValuePropertyDataFilterer extends PropertyDataFiltererBase {
    constructor(filterText?: string);
    // (undocumented)
    get filterText(): string;
    set filterText(value: string);
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    matchesFilter(node: PropertyRecord): Promise<PropertyDataFilterResult>;
}

// @beta
export class DistinctValueCollection {
    constructor();
    // (undocumented)
    get values(): any[];
    set values(values: any[]);
    }

// @beta
export interface DistinctValuesFilterDescriptor extends FilterDescriptor {
    addDistinctValue(distinctValue: any): void;
    distinctValues: DistinctValueCollection;
    distinctValuesComparisonOperator: FilterOperator;
    filterDescriptorCollection: OperatorValueFilterDescriptorCollection;
    removeDistinctValue(distinctValue: any): boolean;
    tryFindDescriptor(distinctValue: any): FilterDescriptor | undefined;
}

// @public
export class DoublePropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @internal (undocumented)
export class DragAction<Item> {
    constructor(componentSelectionHandler: MultiSelectionHandler<Item>, itemSelectionHandlers: Array<Array<SingleSelectionHandler<Item>>>, firstItem: Item);
    // (undocumented)
    updateDragAction(latestItem: Item): {
        selections: Item[];
        deselections: Item[];
    };
}

// @beta
export interface DragDropArguments<DragDropObject = any> {
    clientOffset: {
        x: number;
        y: number;
    };
    col?: number;
    dataObject: DragDropObject;
    dragRect?: ClientRect;
    dropEffect: DropEffects;
    dropRect?: ClientRect;
    dropStatus: DropStatus;
    initialClientOffset: {
        x: number;
        y: number;
    };
    initialSourceClientOffset?: {
        x: number;
        y: number;
    };
    local?: boolean;
    row?: number;
    sourceClientOffset?: {
        x: number;
        y: number;
    };
}

// @beta
export interface DragLayerProps<DragDropObject = any> extends CommonProps {
    // (undocumented)
    args?: DragSourceArguments<DragDropObject>;
}

// @beta
export interface DragSourceArguments<DragDropObject = any> extends DragDropArguments<DragDropObject> {
    // (undocumented)
    defaultDragLayer?: React.ComponentType<DragLayerProps<DragDropObject>>;
    parentObject?: DragDropObject;
}

// @beta
export interface DragSourceProps<DragDropObject = any> {
    defaultDragLayer?: React.ComponentType<DragLayerProps<DragDropObject>>;
    objectType?: ((data?: DragDropObject) => string | symbol) | string | symbol;
    onDragSourceBegin?: (data: DragSourceArguments<DragDropObject>) => DragSourceArguments<DragDropObject>;
    onDragSourceEnd?: (data: DragSourceArguments<DragDropObject>) => void;
}

// @beta
export class DrawingNavigationAid extends React.Component<DrawingNavigationAidProps, DrawingNavigationAidState> {
    constructor(props: DrawingNavigationAidProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    static findRotatedWindowDimensions: (extents: Vector3d, rotation: Matrix3d) => Vector3d;
    // @internal (undocumented)
    static getDefaultClosedMapSize: () => Vector3d;
    // @internal (undocumented)
    static getDefaultOpenedMapSize: (paddingX?: number, paddingY?: number) => Vector3d;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<DrawingNavigationAidState>;
    }

// @beta
export interface DrawingNavigationAidProps extends CommonProps {
    // @internal (undocumented)
    animationTime?: number;
    // @internal (undocumented)
    closeSize?: Vector3d;
    // (undocumented)
    iModelConnection: IModelConnection;
    // @internal (undocumented)
    initialMapMode?: MapMode;
    // @internal (undocumented)
    initialRotateMinimapWithView?: boolean;
    // @internal (undocumented)
    initialView?: ViewState;
    // @internal (undocumented)
    onAnimationEnd?: () => void;
    // @internal (undocumented)
    openSize?: Vector3d;
    // @internal (undocumented)
    screenViewportOverride?: typeof ScreenViewport;
    // @internal (undocumented)
    viewManagerOverride?: ViewManager;
    // (undocumented)
    viewport?: Viewport;
}

// @internal (undocumented)
export class DrawingNavigationCanvas extends React.Component<DrawingNavigationCanvasProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(oldProps: DrawingNavigationCanvasProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): React.ReactNode;
    }

// @internal (undocumented)
export interface DrawingNavigationCanvasProps {
    // (undocumented)
    canvasSizeOverride?: boolean;
    // (undocumented)
    extents: Vector3d;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    rotation: Matrix3d;
    // (undocumented)
    screenViewportOverride?: typeof ScreenViewport;
    // (undocumented)
    view: ViewState | undefined;
    // (undocumented)
    viewId?: string;
    // (undocumented)
    viewManagerOverride?: ViewManager;
    // (undocumented)
    zoom: number;
}

// @public
export class DrawingViewportChangeEvent extends UiEvent<DrawingViewportChangeEventArgs> {
}

// @public
export interface DrawingViewportChangeEventArgs {
    // (undocumented)
    complete: boolean;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    rotation: Matrix3d;
}

// @beta
export enum DropEffects {
    // (undocumented)
    Copy = 1,
    // (undocumented)
    Link = 4,
    // (undocumented)
    Move = 2,
    // (undocumented)
    None = 0
}

// @beta
export enum DropStatus {
    // (undocumented)
    Cancel = 3,
    // (undocumented)
    Drop = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Ok = 1
}

// @beta
export interface DropTargetArguments<DragDropObject = any> extends DragSourceArguments<DragDropObject> {
    dropLocation?: DragDropObject;
}

// @beta
export interface DropTargetProps<DragDropObject = any> {
    canDropTargetDrop?: (args: DropTargetArguments<DragDropObject>) => boolean;
    objectTypes?: Array<string | symbol> | (() => Array<string | symbol>);
    onDropTargetDrop?: (args: DropTargetArguments<DragDropObject>) => DropTargetArguments<DragDropObject>;
    onDropTargetOver?: (args: DropTargetArguments<DragDropObject>) => void;
}

// @public
export interface EditableTreeDataProvider extends ITreeDataProvider {
    // (undocumented)
    updateLabel(nodeItem: TreeNodeItem, newLabel: string): void;
}

// @beta @deprecated
export interface EditableTreeProps {
    // @internal (undocumented)
    ignoreEditorBlur?: boolean;
    onCellEditing: (currentlyActiveNode?: BeInspireTreeNode<TreeNodeItem>) => void;
    onCellUpdated: (args: TreeCellUpdatedArgs) => Promise<boolean>;
}

// @beta
export class EditorContainer extends React.PureComponent<EditorContainerProps> {
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @beta
export interface EditorContainerProps extends CommonProps {
    // @internal (undocumented)
    ignoreEditorBlur?: boolean;
    onCancel: () => void;
    onCommit: (args: PropertyUpdatedArgs) => void;
    propertyRecord: PropertyRecord;
    setFocus?: boolean;
    title?: string;
}

// @beta
export class EnumButtonGroupEditor extends React.Component<PropertyEditorProps, EnumButtonGroupEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumButtonGroupEditorState>;
}

// @beta
export class EnumEditor extends React.PureComponent<PropertyEditorProps, EnumEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumEditorState>;
    }

// @beta
export class EnumPropertyButtonGroupEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export class EnumPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class EnumTypeConverter extends TypeConverter {
    // (undocumented)
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Enum): string | Promise<string>;
    // (undocumented)
    sortCompare(a: Primitives.Enum, b: Primitives.Enum, ignoreCase?: boolean): number;
}

// @public
export interface ErrorObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete?: () => void;
    // (undocumented)
    error: (err: any) => void;
    // (undocumented)
    next?: (value: T) => void;
}

// @public @deprecated
export class EventsMuteContext implements IDisposable {
    constructor(_events: BeInspireTreeEvent[], _mute: (events: BeInspireTreeEvent[]) => void, _unmute: (events: BeInspireTreeEvent[]) => boolean, _emit?: ((events: BeInspireTreeEvent[]) => void) | undefined, _listen?: ((events: BeInspireTreeEvent[], listener: (...values: any[]) => void) => () => void) | undefined, allowedEventTriggersBeforeMute?: number);
    // (undocumented)
    dispose(): void;
    }

// @beta
export interface ExtendedTreeNodeRendererProps extends TreeNodeRendererProps {
    checkboxRenderer?: NodeCheckboxRenderer;
    descriptionEnabled?: boolean;
    imageLoader?: ITreeImageLoader;
    nodeEditorRenderer?: TreeNodeEditorRenderer;
}

// @internal (undocumented)
export class FaceCell extends React.Component<FaceCellProps> {
    // (undocumented)
    render(): React.ReactNode;
    }

// @internal (undocumented)
export interface FaceCellProps extends React.AllHTMLAttributes<HTMLDivElement> {
    // (undocumented)
    center?: boolean;
    // (undocumented)
    face: Face;
    // (undocumented)
    hoverMap: {
        [key: string]: CubeHover;
    };
    // (undocumented)
    onFaceCellClick: (vector: Vector3d, face: Face) => void;
    // (undocumented)
    onFaceCellHoverChange: (vector: Vector3d, state: CubeHover) => void;
    // (undocumented)
    vector: Vector3d;
}

// @beta
export class FavoritePropertiesRenderer {
    // (undocumented)
    hasFavorites(propertyData: PropertyData): boolean;
    // (undocumented)
    renderFavorites(propertyData: PropertyData, orientation?: Orientation): HTMLElement | string;
}

// @alpha
export class FavoritePropertyList extends React.PureComponent<FavoritePropertyListProps> {
    // @internal (undocumented)
    render(): JSX.Element | null;
}

// @alpha
export interface FavoritePropertyListProps {
    // (undocumented)
    orientation?: Orientation;
    // (undocumented)
    propertyData: PropertyData;
    // (undocumented)
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @beta
export interface FieldFilterDescriptor extends FilterDescriptor {
    addFieldValue(fieldValue: any, operator: FilterOperator, isCaseSensitive?: boolean): void;
    filterDescriptorCollection: OperatorValueFilterDescriptorCollection;
    logicalOperator: FilterCompositionLogicalOperator;
    removeFieldValue(fieldValue: any, operator: FilterOperator): boolean;
    tryFindDescriptor(fieldValue: any, operator: FilterOperator): FilterDescriptor | undefined;
}

// @beta
export interface FilterableColumn {
    columnFilterDescriptor: ColumnFilterDescriptor;
    createSimpleFilterDescriptor(value: any, filterOperator: FilterOperator): OperatorValueFilterDescriptor;
    filterableTable: FilterableTable;
    filterMemberKey: string;
    filterMemberType: string;
    getDistinctValues(maximumValueCount?: number): Promise<DistinctValueCollection>;
    isFilterActive: boolean;
    showDistinctValueFilters: boolean;
    showFieldFilters: boolean;
}

// @beta
export interface FilterableTable {
    filterDescriptors: CompositeFilterDescriptorCollection;
    getPropertyDisplayValueExpression(property: string): string;
}

// @beta
export enum FilterCompositionLogicalOperator {
    // (undocumented)
    And = 0,
    // (undocumented)
    Or = 1
}

// @beta
export interface FilterDescriptor {
    clear(): void;
    evaluateRow(row: RowItem): boolean;
    getFilterExpression(): string;
    isActive: boolean;
    isFilterForColumn(columnKey: string): boolean;
}

// @beta
export class FilterDescriptorCollection extends FilterDescriptorCollectionBase<FilterDescriptor> {
}

// @beta
export abstract class FilterDescriptorCollectionBase<TDescriptor extends FilterDescriptor> {
    constructor();
    add(item: TDescriptor): void;
    clear(): void;
    get count(): number;
    // (undocumented)
    get descriptors(): TDescriptor[];
    get isActive(): boolean;
    remove(item: TDescriptor): boolean;
}

// @alpha
export interface FilteredPropertyData extends PropertyData {
    // (undocumented)
    getMatchByIndex?: (index: number) => PropertyRecordMatchInfo | undefined;
    // (undocumented)
    matchesCount?: number;
}

// @public
export class FilteringInput extends React.PureComponent<FilteringInputProps, FilteringInputState> {
    constructor(props: FilteringInputProps);
    // @internal (undocumented)
    componentDidUpdate(prevProps: FilteringInputProps): void;
    // (undocumented)
    static getDerivedStateFromProps(nextProps: FilteringInputProps, prevState: FilteringInputState): {
        searchStarted: boolean;
    } | null;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export type FilteringInputProps = DEPRECATED_FilteringInputProps | NEW_FilteringInputProps;

// @beta
export enum FilteringInputStatus {
    FilteringFinished = 2,
    FilteringInProgress = 1,
    ReadyToFilter = 0
}

// @alpha
export class FilteringPropertyDataProvider implements IPropertyDataProvider, IDisposable {
    constructor(_dataProvider: IPropertyDataProvider, _filterer: IPropertyDataFilterer);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getData(): Promise<FilteredPropertyData>;
    // (undocumented)
    onDataChanged: PropertyDataChangeEvent;
}

// @beta
export enum FilterOperator {
    // (undocumented)
    Contains = 9,
    // (undocumented)
    DoesNotContain = 10,
    // (undocumented)
    EndsWith = 8,
    // (undocumented)
    IsContainedIn = 11,
    // (undocumented)
    IsEmpty = 13,
    // (undocumented)
    IsEqualTo = 0,
    // (undocumented)
    IsGreaterThan = 4,
    // (undocumented)
    IsGreaterThanOrEqualTo = 5,
    // (undocumented)
    IsLessThan = 2,
    // (undocumented)
    IsLessThanOrEqualTo = 3,
    // (undocumented)
    IsNotContainedIn = 12,
    // (undocumented)
    IsNotEmpty = 14,
    // (undocumented)
    IsNotEqualTo = 1,
    // (undocumented)
    IsNotNull = 16,
    // (undocumented)
    IsNull = 15,
    // (undocumented)
    Range = 6,
    // (undocumented)
    StartsWith = 7
}

// @beta
export enum FilterRenderer {
    // (undocumented)
    MultiSelect = 2,
    // (undocumented)
    Numeric = 1,
    // (undocumented)
    SingleSelect = 3,
    // (undocumented)
    Text = 4
}

// @alpha
export type FlatGridItem = CategorizedPropertyItem | GridCategoryItem;

// @alpha
export interface FlatGridItemBase {
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    getChildren(): FlatGridItem[];
    // (undocumented)
    getDescendantsAndSelf(): FlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): FlatGridItem;
    // (undocumented)
    getVisibleDescendantsAndSelf(): FlatGridItem[];
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly label: string;
    // (undocumented)
    readonly lastInNumberOfCategories: number;
    // (undocumented)
    readonly parentCategorySelectionKey: string | undefined;
    // (undocumented)
    readonly parentSelectionKey: string | undefined;
    // (undocumented)
    readonly selectionKey: string;
    // (undocumented)
    readonly type: FlatGridItemType;
}

// @alpha
export enum FlatGridItemType {
    // (undocumented)
    Array = 2,
    // (undocumented)
    Category = 0,
    // (undocumented)
    Primitive = 1,
    // (undocumented)
    Struct = 3
}

// @public
export class FloatTypeConverter extends NumericTypeConverterBase {
    // (undocumented)
    convertFromString(value: string): number;
    // (undocumented)
    convertToString(value?: Primitives.Float): string;
}

// @internal
export function formatInputDate(inputDate: Date, timeDisplay?: TimeDisplay, customFormatter?: DateFormatter, alternateDateFormat?: AlternateDateFormats): string | undefined;

// @public
export function from<T>(iterable: Iterable<T> | PromiseLike<T>): Observable<T>;

// @beta @deprecated
export type GetCurrentlyEditedNode = () => BeInspireTreeNode<TreeNodeItem> | undefined;

// @internal (undocumented)
export const getToolbarDirection: (expandsTo: Direction) => OrthogonalDirection;

// @alpha
export interface GridCategoryItem extends FlatGridItemBase {
    // (undocumented)
    readonly derivedCategory: PropertyCategory;
    // (undocumented)
    getChildCategories(): GridCategoryItem[];
    // (undocumented)
    getDescendantCategoriesAndSelf(): GridCategoryItem[];
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly type: FlatGridItemType.Category;
}

// @internal (undocumented)
export function GroupPopupItem({ item, addGroupSeparator }: {
    item: GroupButton;
    addGroupSeparator: boolean;
}): JSX.Element;

// @internal (undocumented)
export function handleLoadedNodeHierarchy(modelSource: TreeModelSource, loadedHierarchy: LoadedNodeHierarchy): void;

// @public
export const hasChildren: (node: TreeNodeItem) => boolean;

// @public @deprecated
export const hasFlag: (selectionMode: SelectionMode, flag: SelectionModeFlags) => boolean;

// @public
export const hasSelectionModeFlag: (selectionMode: SelectionMode, flag: SelectionModeFlags) => boolean;

// @public
export class HexadecimalTypeConverter extends TypeConverter {
    // (undocumented)
    convertFromString(value: string): string | undefined;
    // (undocumented)
    convertToString(value?: Primitives.Hexadecimal): string;
    // (undocumented)
    sortCompare(a: Primitives.Hexadecimal, b: Primitives.Hexadecimal): number;
}

// @beta
export interface HighlightableTreeNodeProps {
    // (undocumented)
    activeMatchIndex?: number;
    // (undocumented)
    searchText: string;
}

// @beta
export interface HighlightableTreeProps {
    // (undocumented)
    activeMatch?: ActiveMatchInfo;
    // (undocumented)
    searchText: string;
}

// @beta
export interface HighlightedRecordProps {
    // (undocumented)
    activeMatch?: PropertyRecordMatchInfo;
    // (undocumented)
    searchText: string;
}

// @beta
export class HighlightingEngine {
    constructor(props: HighlightableTreeProps);
    // (undocumented)
    static readonly ACTIVE_CLASS_NAME = "components-activehighlight";
    // (undocumented)
    createRenderProps(node: {
        id?: string;
    }): HighlightableTreeNodeProps;
    // (undocumented)
    getActiveMatchIndex(node: {
        id?: string;
    }): number | undefined;
    // (undocumented)
    isNodeActive(node: {
        id?: string;
    }): boolean | undefined;
    // (undocumented)
    static renderNodeLabel(text: string, props: HighlightableTreeNodeProps): React.ReactNode;
    }

// @internal (undocumented)
export enum HitBoxX {
    // (undocumented)
    Left = -1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Right = 1
}

// @internal (undocumented)
export enum HitBoxY {
    // (undocumented)
    Back = 1,
    // (undocumented)
    Front = -1,
    // (undocumented)
    None = 0
}

// @internal (undocumented)
export enum HitBoxZ {
    // (undocumented)
    Bottom = -1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Top = 1
}

// @beta
export function HueSlider({ isHorizontal, onHueChange, hsv, className, style }: HueSliderProps): JSX.Element;

// @beta
export interface HueSliderProps extends React.HTMLAttributes<HTMLDivElement>, CommonProps {
    hsv: HSVColor;
    isHorizontal?: boolean;
    onHueChange?: ((hue: HSVColor) => void) | undefined;
}

// @alpha
export class IconEditor extends React.PureComponent<PropertyEditorProps, IconEditorState> implements TypeEditor {
    constructor(props: PropertyEditorProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export class IconPickerButton extends React.PureComponent<IconPickerProps, IconPickerState> {
    // @internal
    constructor(props: IconPickerProps);
    // @internal (undocumented)
    static defaultProps: Partial<IconPickerProps>;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface IconPickerProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    disabled?: boolean;
    dropDownTitle?: string;
    icon: string;
    icons: string[];
    numColumns: number;
    onIconChange?: ((icon: string) => void) | undefined;
    readonly?: boolean;
}

// @alpha
export class IconPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export interface IImageLoader {
    load: (item: any) => Image | undefined;
}

// @public
export type Image = LoadedImage | LoadedBinaryImage;

// @beta
export class ImageCheckBoxEditor extends React.PureComponent<PropertyEditorProps, ImageCheckBoxEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ImageCheckBoxEditorState>;
}

// @beta
export class ImageCheckBoxPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export type ImageFileFormat = "png" | "jpg" | "jpge";

// @public
export type ImageSourceType = "svg" | "url" | "binary" | "core-icon" | "webfont-icon";

// @public
export interface ImmediatelyLoadedTreeNodeItem extends TreeNodeItem {
    // (undocumented)
    children?: TreeNodeItem[];
}

// @alpha
export interface IMutableCategorizedPropertyItem extends IMutableFlatPropertyGridItem {
    // (undocumented)
    readonly derivedRecord: PropertyRecord;
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    readonly parentCategorySelectionKey: string;
    // (undocumented)
    readonly parentSelectionKey: string;
    // (undocumented)
    readonly type: CategorizedPropertyTypes;
}

// @alpha
export type IMutableFlatGridItem = IMutableCategorizedPropertyItem | IMutableGridCategoryItem;

// @alpha
export interface IMutableFlatPropertyGridItem {
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    getChildren(): IMutableFlatGridItem[];
    // (undocumented)
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): IMutableFlatGridItem;
    // (undocumented)
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    readonly label: string;
    // (undocumented)
    lastInNumberOfCategories: number;
    // (undocumented)
    readonly parentCategorySelectionKey: string | undefined;
    // (undocumented)
    readonly parentSelectionKey: string | undefined;
    // (undocumented)
    readonly selectionKey: string;
    // (undocumented)
    readonly type: FlatGridItemType;
}

// @alpha
export interface IMutableGridCategoryItem extends IMutableFlatPropertyGridItem {
    // (undocumented)
    derivedCategory: PropertyCategory;
    // (undocumented)
    getChildCategories(): IMutableGridCategoryItem[];
    // (undocumented)
    getDescendantCategoriesAndSelf(): IMutableGridCategoryItem[];
    // (undocumented)
    isRootCategory: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    type: FlatGridItemType.Category;
}

// @alpha
export interface IMutableGridItemFactory {
    // (undocumented)
    createCategorizedProperty: (record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string) => IMutableCategorizedPropertyItem;
    // (undocumented)
    createGridCategory: (category: PropertyCategory, recordsDict: CategoryRecordsDict, parentSelectionKey?: string, depth?: number) => IMutableGridCategoryItem;
}

// @alpha
export interface IMutablePropertyGridModel {
    // (undocumented)
    getFlatGrid: () => IMutableFlatGridItem[];
    // (undocumented)
    getItem: (selectionKey: string) => IMutableFlatGridItem;
    // (undocumented)
    getRootCategories: () => IMutableGridCategoryItem[];
    // (undocumented)
    getVisibleFlatGrid: () => IMutableFlatGridItem[];
}

// @internal
export class InlineEdit extends React.Component<InlineEditProps, InlineEditState> {
    constructor(props: InlineEditProps);
    // (undocumented)
    componentDidUpdate(prevProps: InlineEditProps, _prevState: InlineEditState): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @internal (undocumented)
export class InputSwitchComponent extends React.PureComponent<InputSwitchProps> {
    // (undocumented)
    render(): React.ReactNode;
}

// @internal (undocumented)
export interface InputSwitchProps {
    // (undocumented)
    currentMode: BreadcrumbMode;
    // (undocumented)
    delimiter: string;
    // (undocumented)
    expandedNode?: boolean;
    // (undocumented)
    node?: BeInspireTreeNode<TreeNodeItem>;
    // (undocumented)
    onInputCancel: () => void;
    // (undocumented)
    onInputStart?: () => void;
    // (undocumented)
    onNodeChange: (node?: TreeNodeItem) => void;
    // (undocumented)
    parentsOnly?: boolean;
    // (undocumented)
    pathString: string;
    // (undocumented)
    renderNode?: BreadcrumbNodeRenderer;
    // (undocumented)
    showUpDir?: boolean;
    // (undocumented)
    tree: BeInspireTree<TreeNodeItem>;
    // (undocumented)
    width: number | string;
}

// @alpha
export class IntlFormatter implements DateFormatter {
    constructor(_intlFormatter?: Intl.DateTimeFormat | undefined);
    // (undocumented)
    formateDate(day: Date): string;
    // (undocumented)
    get formatter(): Intl.DateTimeFormat;
    }

// @public
export class IntTypeConverter extends NumericTypeConverterBase {
    // (undocumented)
    convertFromString(value: string): number;
    // (undocumented)
    convertToString(value?: Primitives.Int): string;
}

// @alpha
export interface IPropertyDataFilterer {
    // (undocumented)
    readonly isActive: boolean;
    // (undocumented)
    matchesFilter: (node: PropertyRecord, parents: PropertyRecord[]) => Promise<PropertyDataFilterResult>;
    // (undocumented)
    onFilterChanged: PropertyFilterChangeEvent;
}

// @public
export interface IPropertyDataProvider {
    getData: (() => Promise<PropertyData>);
    onDataChanged: PropertyDataChangeEvent;
}

// @alpha
export interface IPropertyGridEventHandler {
    // (undocumented)
    onExpansionToggled: (selectionKey: string) => void;
}

// @alpha
export interface IPropertyGridModel {
    // (undocumented)
    getFlatGrid: () => FlatGridItem[];
    // (undocumented)
    getItem: (selectionKey: string) => FlatGridItem;
    // (undocumented)
    getRootCategories: () => GridCategoryItem[];
    // (undocumented)
    getVisibleFlatGrid: () => FlatGridItem[];
}

// @alpha (undocumented)
export interface IPropertyGridModelSource {
    // (undocumented)
    getModel(): IPropertyGridModel | undefined;
    // (undocumented)
    modifyModel(callback: (model: IMutablePropertyGridModel) => void): void;
    // (undocumented)
    onModelChanged: PropertyGridModelChangeEvent;
    // (undocumented)
    setPropertyData: (data: PropertyData) => void;
}

// @public
export interface IPropertyValueRenderer {
    canRender: (record: PropertyRecord, context?: PropertyValueRendererContext) => boolean;
    render: (record: PropertyRecord, context?: PropertyValueRendererContext) => React.ReactNode;
}

// @internal
export function isCustomToolbarItem(item: ToolbarItem): item is CustomToolbarItem;

// @public
export const isTreeDataProviderInterface: (provider: TreeDataProvider) => provider is ITreeDataProvider;

// @public
export const isTreeDataProviderMethod: (provider: TreeDataProvider) => provider is TreeDataProviderMethod;

// @public
export const isTreeDataProviderPromise: (provider: TreeDataProvider) => provider is TreeDataProviderPromise;

// @public
export const isTreeDataProviderRaw: (provider: TreeDataProvider) => provider is TreeDataProviderRaw;

// @beta
export function isTreeModelNode(obj: TreeModelNodeType | undefined): obj is TreeModelNode;

// @beta
export function isTreeModelNodePlaceholder(obj: TreeModelNodeType | undefined): obj is TreeModelNodePlaceholder;

// @beta
export function isTreeModelRootNode(obj: TreeModelNodeType | undefined): obj is TreeModelRootNode;

// @public
export interface ItemColorOverrides {
    backgroundColor?: number;
    backgroundColorSelected?: number;
    color?: number;
    colorSelected?: number;
}

// @public
export interface ItemStyle {
    colorOverrides?: ItemColorOverrides;
    isBold?: boolean;
    isItalic?: boolean;
}

// @public
export const ItemStyleProvider: {
    createStyle: ({ colorOverrides, isBold, isItalic }: ItemStyle, isSelected?: boolean | undefined) => CSSProperties;
};

// @public
export interface ITreeDataProvider {
    // (undocumented)
    getNodes(parent?: TreeNodeItem, page?: PageOptions): Promise<DelayLoadedTreeNodeItem[]>;
    // (undocumented)
    getNodesCount(parent?: TreeNodeItem): Promise<number>;
    // @deprecated (undocumented)
    onTreeNodeChanged?: BeEvent<TreeDataChangesListener>;
}

// @public
export interface ITreeImageLoader extends IImageLoader {
    // (undocumented)
    load: (item: TreeNodeItem | BeInspireTreeNodeITree) => LoadedImage | undefined;
}

// @beta
export interface ITreeNodeLoader {
    loadNode(parentId: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<TreeNodeLoadResult>;
}

// @beta
export interface ITreeNodeLoaderWithProvider<TDataProvider extends TreeDataProvider> extends ITreeNodeLoader {
    readonly dataProvider: TDataProvider;
}

// @alpha
export class LabelPropertyDataFilterer extends PropertyDataFiltererBase {
    constructor(filterText?: string);
    // (undocumented)
    get filterText(): string;
    set filterText(value: string);
    // (undocumented)
    get isActive(): boolean;
    // (undocumented)
    matchesFilter(node: PropertyRecord): Promise<PropertyDataFilterResult>;
}

// @public
export interface LessGreaterOperatorProcessor {
    isGreaterThan(a: Primitives.Value, b: Primitives.Value): boolean;
    isGreaterThanOrEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
    isLessThan(a: Primitives.Value, b: Primitives.Value): boolean;
    isLessThanOrEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
}

// @beta
export class LineWeightSwatch extends React.PureComponent<LineWeightSwatchProps> {
    // @internal
    constructor(props: LineWeightSwatchProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    render(): JSX.Element;
}

// @beta
export interface LineWeightSwatchProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    colorDef?: ColorDef;
    disabled?: boolean;
    hideLabel?: boolean;
    onClick?: () => void;
    readonly?: boolean;
    weight: number;
}

// @public
export interface LoadedBinaryImage extends LoadedImage {
    // (undocumented)
    fileFormat: ImageFileFormat;
}

// @public
export interface LoadedImage {
    // (undocumented)
    sourceType: ImageSourceType;
    // (undocumented)
    value: string;
}

// @beta
export interface LoadedNodeHierarchy {
    hierarchyItems: LoadedNodeHierarchyItem[];
    numChildren?: number;
    offset: number;
    parentId: string | undefined;
}

// @beta
export interface LoadedNodeHierarchyItem {
    children?: LoadedNodeHierarchyItem[];
    item: TreeNodeItemData;
    numChildren?: number;
}

// @internal
export enum MapMode {
    // (undocumented)
    Closed = "map-closed",
    // (undocumented)
    Opened = "map-opened"
}

// @public @deprecated
export type MapPayloadToInspireNodeCallback<TPayload> = (payload: TPayload, remapper: MapPayloadToInspireNodeCallback<TPayload>) => BeInspireTreeNodeConfig;

// @public
export const matchLinks: (text: string) => {
    index: number;
    lastIndex: number;
    schema: string;
    url: string;
}[];

// @internal
export interface MenuItem {
    checked?: boolean;
    disabled?: boolean;
    icon?: string;
    isSeparator?: boolean;
    name?: string;
    onClick?: () => void;
}

// @alpha
export interface Milestone {
    // (undocumented)
    children?: Milestone[];
    date: Date;
    description?: string;
    id: string;
    label?: string;
    // (undocumented)
    parentId?: string;
    range?: MilestoneRange;
    readonly?: boolean;
}

// @alpha
export interface MilestoneRange {
    // (undocumented)
    end: Date;
    // (undocumented)
    start: Date;
}

// @internal
export interface MultiSelectionHandler<TItem> {
    areEqual: (item1: TItem, item2: TItem) => boolean;
    deselectAll: () => void;
    selectBetween: (item1: TItem, item2: TItem) => TItem[];
    updateSelection: (selections: TItem[], deselections: TItem[]) => void;
}

// @alpha
export class MutableCategorizedArrayProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, gridItemFactory: IMutableGridItemFactory, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    get type(): FlatGridItemType.Array;
}

// @alpha
export class MutableCategorizedPrimitiveProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    get type(): FlatGridItemType.Primitive;
}

// @alpha
export abstract class MutableCategorizedProperty extends MutableFlatPropertyGridItem implements Partial<IMutableCategorizedPropertyItem> {
    constructor(type: CategorizedPropertyTypes, record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string);
    get derivedRecord(): PropertyRecord;
    // (undocumented)
    abstract getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    getSelf(): IMutableCategorizedPropertyItem;
    // (undocumented)
    get label(): string;
    // (undocumented)
    get parentCategorySelectionKey(): string;
    // (undocumented)
    get parentSelectionKey(): string;
    get selectionKey(): string;
    // (undocumented)
    abstract type: CategorizedPropertyTypes;
    }

// @alpha
export class MutableCategorizedStructProperty extends MutableCategorizedProperty implements IMutableCategorizedPropertyItem {
    constructor(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, gridItemFactory: IMutableGridItemFactory, overrideName?: string, overrideDisplayLabel?: string);
    // (undocumented)
    getChildren(): IMutableCategorizedPropertyItem[];
    // (undocumented)
    get type(): FlatGridItemType.Struct;
}

// @beta
export interface MutableCheckBoxInfo extends CheckBoxInfo {
    // (undocumented)
    isDisabled: boolean;
    // (undocumented)
    isVisible: boolean;
    // (undocumented)
    state: CheckBoxState;
    // (undocumented)
    tooltip?: string;
}

// @alpha
export abstract class MutableFlatPropertyGridItem implements IMutableFlatPropertyGridItem {
    // (undocumented)
    [immerable]: boolean;
    constructor(_depth: number, _parentSelectionKey: string | undefined, _parentCategorySelectionKey: string | undefined);
    // (undocumented)
    get depth(): number;
    // (undocumented)
    abstract getChildren(): IMutableFlatGridItem[];
    // (undocumented)
    protected getDescendants(): IMutableFlatGridItem[];
    getDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    getLastVisibleDescendantOrSelf(): IMutableFlatGridItem;
    // (undocumented)
    abstract getSelf(): IMutableFlatGridItem;
    getVisibleDescendantsAndSelf(): IMutableFlatGridItem[];
    // (undocumented)
    get isExpanded(): boolean;
    set isExpanded(value: boolean);
    // (undocumented)
    protected _isExpanded: boolean;
    // @internal
    get isLastInRootCategory(): boolean;
    set isLastInRootCategory(value: boolean);
    // (undocumented)
    protected _isLastInRootCategory: boolean;
    // (undocumented)
    readonly key: string;
    // (undocumented)
    abstract label: string;
    // @internal
    get lastInNumberOfCategories(): number;
    set lastInNumberOfCategories(value: number);
    // (undocumented)
    protected _lastInNumberOfCategories: number;
    // (undocumented)
    get parentCategorySelectionKey(): string | undefined;
    // (undocumented)
    get parentSelectionKey(): string | undefined;
    // (undocumented)
    abstract selectionKey: string;
    // (undocumented)
    abstract type: FlatGridItemType;
}

// @alpha
export class MutableGridCategory extends MutableFlatPropertyGridItem implements IMutableGridCategoryItem {
    constructor(category: PropertyCategory, recordsDict: CategoryRecordsDict, gridItemFactory: IMutableGridItemFactory, parentSelectionKey?: string, depth?: number);
    // (undocumented)
    get derivedCategory(): PropertyCategory;
    // (undocumented)
    getChildCategories(): IMutableGridCategoryItem[];
    // (undocumented)
    getChildren(): IMutableFlatGridItem[];
    getDescendantCategoriesAndSelf(): IMutableGridCategoryItem[];
    // (undocumented)
    getSelf(): this;
    get isRootCategory(): boolean;
    // (undocumented)
    get label(): string;
    // @internal
    get lastInNumberOfCategories(): number;
    set lastInNumberOfCategories(value: number);
    // (undocumented)
    get name(): string;
    // (undocumented)
    get selectionKey(): string;
    // (undocumented)
    get type(): FlatGridItemType.Category;
}

// @alpha
export class MutableGridItemFactory implements IMutableGridItemFactory {
    // (undocumented)
    protected createArrayProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedArrayProperty;
    createCategorizedProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): IMutableCategorizedPropertyItem;
    createGridCategory(category: PropertyCategory, recordsDict: CategoryRecordsDict, parentSelectionKey?: string, depth?: number): IMutableGridCategoryItem;
    // (undocumented)
    protected createPrimitiveProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedPrimitiveProperty;
    // (undocumented)
    protected createStructProperty(record: PropertyRecord, parentSelectionKey: string, parentCategorySelectionKey: string, depth: number, overrideName?: string, overrideDisplayLabel?: string): MutableCategorizedStructProperty;
}

// @alpha
export class MutablePropertyGridModel implements IPropertyGridModel, IMutablePropertyGridModel {
    // (undocumented)
    [immerable]: boolean;
    constructor(propertyData: PropertyData, _gridItemFactory: IMutableGridItemFactory);
    getFlatGrid(): IMutableFlatGridItem[];
    getItem(selectionKey: string): IMutableFlatGridItem;
    getRootCategories(): IMutableGridCategoryItem[];
    getVisibleFlatGrid(): IMutableFlatGridItem[];
    }

// @beta
export interface MutableTableDataProvider extends TableDataProvider {
    addRow(rowItem: RowItem): number;
    deleteRow(rowItem: RowItem): void;
    insertRow(rowItem: RowItem, index: number): number;
    moveRow(rowItem: RowItem, newIndex: number): number;
}

// @beta
export interface MutableTreeDataProvider extends ITreeDataProvider {
    // (undocumented)
    getNodeIndex(parent: TreeNodeItem | undefined, child: TreeNodeItem): number;
    // (undocumented)
    insertNode(parent: TreeNodeItem | undefined, child: TreeNodeItem, index?: number): void;
    // (undocumented)
    isDescendent(parent: TreeNodeItem | undefined, nodeItem: TreeNodeItem): boolean;
    // (undocumented)
    moveNode(parent: TreeNodeItem | undefined, newParent: TreeNodeItem | undefined, child: TreeNodeItem, index?: number): void;
    // (undocumented)
    removeNode(parent: TreeNodeItem | undefined, child: TreeNodeItem): void;
}

// @beta
export class MutableTreeModel implements TreeModel {
    // (undocumented)
    [immerable]: boolean;
    clearChildren(parentId: string | undefined): void;
    computeVisibleNodes(): VisibleTreeNodes;
    getChildOffset(parentId: string | undefined, childId: string): number | undefined;
    getChildren(parentId: string | undefined): SparseArray<string> | undefined;
    getNode(id: string): MutableTreeModelNode | undefined;
    // (undocumented)
    getNode(parentId: string | undefined, childIndex: number): MutableTreeModelNode | TreeModelNodePlaceholder | undefined;
    getRootNode(): TreeModelRootNode;
    insertChild(parentId: string | undefined, childNodeInput: TreeModelNodeInput, offset: number): void;
    iterateTreeModelNodes(parentId?: string): IterableIterator<MutableTreeModelNode>;
    removeChild(parentId: string | undefined, childId: string): void;
    setChildren(parentId: string | undefined, nodeInputs: TreeModelNodeInput[], offset: number): void;
    setNumChildren(parentId: string | undefined, numChildren: number): void;
    }

// @beta
export interface MutableTreeModelNode extends TreeModelNode {
    // (undocumented)
    checkbox: MutableCheckBoxInfo;
    // (undocumented)
    description: string;
    editingInfo?: TreeModelNodeEditingInfo;
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    isLoading: boolean;
    // (undocumented)
    isSelected: boolean;
    // (undocumented)
    item: TreeNodeItem;
    // (undocumented)
    label: PropertyRecord;
}

// @internal (undocumented)
export class NavCubeFace extends React.Component<NavCubeFaceProps> {
    // (undocumented)
    static faceCellToPos: (face: Face, x: number, y: number) => Vector3d;
    // (undocumented)
    render(): React.ReactNode;
}

// @internal (undocumented)
export interface NavCubeFaceProps extends React.AllHTMLAttributes<HTMLDivElement> {
    // (undocumented)
    face: Face;
    // (undocumented)
    hoverMap: {
        [key: string]: CubeHover;
    };
    // (undocumented)
    label: string;
    // (undocumented)
    onFaceCellClick: (vector: Vector3d, face: Face) => void;
    // (undocumented)
    onFaceCellHoverChange: (vector: Vector3d, state: CubeHover) => void;
}

// @public
export class NavigationPropertyTypeConverter extends TypeConverter {
    // (undocumented)
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Hexadecimal): string;
    // (undocumented)
    sortCompare(a: Primitives.Hexadecimal, b: Primitives.Hexadecimal, ignoreCase?: boolean): number;
}

// @public
export class NavigationPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): JSX.Element;
}

// @public
export interface NEW_FilteringInputProps extends CommonProps {
    autoFocus?: boolean;
    onFilterCancel: () => void;
    onFilterClear: () => void;
    onFilterStart: (searchText: string) => void;
    resultSelectorProps?: ResultSelectorProps;
    // @beta
    status: FilteringInputStatus;
}

// @public
export interface NextObserver<T> {
    // (undocumented)
    closed?: boolean;
    // (undocumented)
    complete?: () => void;
    // (undocumented)
    error?: (err: any) => void;
    // (undocumented)
    next: (value: T) => void;
}

// @internal (undocumented)
export interface Node {
    // (undocumented)
    readonly id: string;
}

// @public @deprecated
export interface NodeCheckboxProps extends Omit<NodeCheckboxProps_2, "onClick"> {
    // (undocumented)
    onClick: (node: BeInspireTreeNode<TreeNodeItem>, newState: CheckBoxState) => void;
}

// @internal @deprecated
export type NodeRenderer = (item: BeInspireTreeNode<TreeNodeItem>, props: TreeNodeProps) => React.ReactNode;

// @internal @deprecated
export type NodesDeselectedCallback = OnItemsDeselectedCallback<TreeNodeItem>;

// @internal @deprecated
export type NodesSelectedCallback = OnItemsSelectedCallback<TreeNodeItem>;

// @public
export class NonPrimitivePropertyLabelRenderer extends React.PureComponent<NonPrimitivePropertyLabelRendererProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface NonPrimitivePropertyLabelRendererProps extends PrimitivePropertyLabelRendererProps {
    // (undocumented)
    isExpanded: boolean;
    // (undocumented)
    onCollapse: () => void;
    // (undocumented)
    onExpand: () => void;
}

// @public
export class NonPrimitivePropertyRenderer extends React.Component<NonPrimitivePropertyRendererProps, NonPrimitivePropertyRendererState> {
    constructor(props: NonPrimitivePropertyRendererProps);
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: NonPrimitivePropertyRendererState;
}

// @public
export interface NonPrimitivePropertyRendererProps extends PrimitiveRendererProps {
    isCollapsible?: boolean;
}

// @public
export interface NullableOperatorProcessor {
    isNotNull(value: Primitives.Value): boolean;
    isNull(value: Primitives.Value): boolean;
}

// @beta
export class NumericInputEditor extends React.PureComponent<PropertyEditorProps, NumericInputEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<NumericInputEditorState>;
    }

// @beta
export class NumericInputPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export abstract class NumericTypeConverterBase extends TypeConverter implements LessGreaterOperatorProcessor {
    // (undocumented)
    isGreaterThan(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    isGreaterThanOrEqualTo(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    get isLessGreaterType(): boolean;
    // (undocumented)
    isLessThan(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    isLessThanOrEqualTo(a: Primitives.Numeric, b: Primitives.Numeric): boolean;
    // (undocumented)
    sortCompare(a: Primitives.Numeric, b: Primitives.Numeric, _ignoreCase?: boolean): number;
}

// @public
export interface Observable<T> extends Subscribable<T> {
}

// @public
export type Observer<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;

// @public
export type OnItemsDeselectedCallback<Item> = (items: Item[]) => void | boolean;

// @public
export type OnItemsSelectedCallback<TItem> = (items: TItem[], replace: boolean) => void | boolean;

// @public
export type OnSelectionChanged = (shiftDown?: boolean, ctrlDown?: boolean) => void;

// @public
export interface OperatorProcessor {
    isEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
    isNotEqualTo(a: Primitives.Value, b: Primitives.Value): boolean;
}

// @beta
export interface OperatorValueFilterDescriptor extends FilterDescriptor {
    isCaseSensitive: boolean;
    memberKey: string;
    memberType: string;
    operator: FilterOperator;
    value: any;
}

// @beta
export class OperatorValueFilterDescriptorCollection extends FilterDescriptorCollectionBase<OperatorValueFilterDescriptor> {
}

// @alpha
export enum OrthogonalDirection {
    // (undocumented)
    Horizontal = 1,
    // (undocumented)
    Vertical = 0
}

// @internal
export class OrthogonalDirectionHelpers {
    // (undocumented)
    static getCssClassName(direction: OrthogonalDirection): string;
    static readonly HORIZONTAL_CLASS_NAME = "components-horizontal";
    // (undocumented)
    static inverse(direction: OrthogonalDirection): OrthogonalDirection;
    static readonly VERTICAL_CLASS_NAME = "components-vertical";
}

// @beta
export class PagedTreeNodeLoader<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoaderWithProvider<TDataProvider> implements IDisposable {
    constructor(dataProvider: TDataProvider, modelSource: TreeModelSource, pageSize: number);
    dispose(): void;
    protected load(parentNode: TreeModelNode | TreeModelRootNode, childIndex: number): Observable<LoadedNodeHierarchy>;
    get pageSize(): number;
    }

// @public
export interface PageOptions {
    // (undocumented)
    size?: number;
    // (undocumented)
    start?: number;
}

// @beta
export const ParsedInput: React.ForwardRefExoticComponent<ParsedInputProps & React.RefAttributes<HTMLInputElement>>;

// @beta
export interface ParsedInputProps extends CommonProps {
    formatValue: (value: number) => string;
    initialValue: number;
    onChange?: (newValue: number) => void;
    parseString: (stringValue: string) => ParseResults;
    readonly?: boolean;
}

// @alpha
export interface PlaybackSettings {
    allowMilestoneEdits?: boolean;
    dateDisplay?: TimelineDateDisplay;
    duration?: number;
    loop?: boolean;
    minimized?: boolean;
    playbackEnd?: Date;
    playbackStart?: Date;
}

// @alpha
export type PlaybackSettingsChangeHandler = (settingsChange: PlaybackSettings) => void;

// @internal
export class PlayButton extends React.Component<PlayerButtonProps, PlayButtonState> {
    constructor(props: PlayerButtonProps, context?: any);
    // (undocumented)
    componentDidUpdate(): void;
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export class PlayerButton extends React.PureComponent<any> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface PlayerButtonProps extends CommonProps {
    // (undocumented)
    isPlaying: boolean;
    // (undocumented)
    onPause?: () => void;
    // (undocumented)
    onPlay?: () => void;
    // (undocumented)
    tooltip?: string;
}

// @public
export class Point2dTypeConverter extends BasePointTypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    protected constructPoint(values: Primitives.Point): ConvertedPrimitives.Point2d | undefined;
    // (undocumented)
    protected getVectorLength(point: Primitives.Point): number | undefined;
}

// @public
export class Point3dTypeConverter extends BasePointTypeConverter {
    constructor(componentConverterName?: string);
    // (undocumented)
    protected constructPoint(values: Primitives.Point): ConvertedPrimitives.Point3d | undefined;
    // (undocumented)
    protected getVectorLength(point: Primitives.Point): number | undefined;
}

// @beta
export function PopupItem(props: PopupItemProps): JSX.Element;

// @internal (undocumented)
export function PopupItemPopup(props: PopupItemPopupProps): JSX.Element;

// @beta
export interface PopupItemProps extends ToolbarButtonItemProps {
    hideIndicator?: boolean;
    panel?: React.ReactNode;
}

// @beta
export function PopupItemWithDrag(props: PopupItemWithDragProps): JSX.Element;

// @beta
export interface PopupItemWithDragProps extends ToolbarButtonItemProps {
    groupItem: GroupButton;
}

// @public
export class PrimitivePropertyLabelRenderer extends React.PureComponent<PrimitivePropertyLabelRendererProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface PrimitivePropertyLabelRendererProps extends PropertyLabelRendererProps {
    className?: string;
    offset?: number;
}

// @public
export class PrimitivePropertyRenderer extends React.Component<PrimitiveRendererProps> {
    constructor(props: PrimitiveRendererProps);
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export class PrimitivePropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): {} | null | undefined;
}

// @internal (undocumented)
export function PrimitivePropertyValueRendererImpl(props: PrimitivePropertyValueRendererImplProps): JSX.Element;

// @public
export interface PrimitiveRendererProps extends SharedRendererProps {
    // @beta
    highlightProps?: HighlightedRecordProps;
    indentation?: number;
    valueElement?: React.ReactNode;
    valueElementRenderer?: () => React.ReactNode;
}

// @public
export interface PropertyCategory {
    // @alpha (undocumented)
    childCategories?: PropertyCategory[];
    // (undocumented)
    expand: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // @alpha (undocumented)
    parentCategory?: PropertyCategory;
}

// @public
export class PropertyCategoryBlock extends React.Component<PropertyCategoryBlockProps> {
    constructor(props: PropertyCategoryBlockProps);
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @public
export interface PropertyCategoryBlockProps extends CommonProps {
    category: PropertyCategory;
    onExpansionToggled?: (categoryName: string) => void;
}

// @public
export enum PropertyContainerType {
    // (undocumented)
    PropertyPane = "pane",
    // (undocumented)
    Table = "table",
    // (undocumented)
    Tree = "tree"
}

// @public
export interface PropertyData {
    // (undocumented)
    categories: PropertyCategory[];
    // (undocumented)
    description?: string;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    records: {
        [categoryName: string]: PropertyRecord[];
    };
    // @alpha
    reusePropertyDataState?: boolean;
}

// @public
export class PropertyDataChangeEvent extends BeEvent<PropertyDataChangesListener> {
}

// @public
export type PropertyDataChangesListener = () => void;

// @alpha
export abstract class PropertyDataFiltererBase implements IPropertyDataFilterer {
    // (undocumented)
    abstract get isActive(): boolean;
    // (undocumented)
    abstract matchesFilter(node: PropertyRecord, parents: PropertyRecord[]): Promise<PropertyDataFilterResult>;
    // (undocumented)
    onFilterChanged: PropertyFilterChangeEvent;
}

// @alpha
export interface PropertyDataFilterResult {
    matchesCount?: {
        label?: number;
        value?: number;
    };
    matchesFilter: boolean;
    shouldExpandNodeParents?: boolean;
    shouldForceIncludeDescendants?: boolean;
}

// @public
export interface PropertyDialogState {
    // (undocumented)
    content: React.ReactNode;
    // (undocumented)
    title: string;
}

// @public
export interface PropertyEditingArgs {
    propertyKey?: string;
    propertyRecord: PropertyRecord;
}

// @beta
export abstract class PropertyEditorBase implements DataController {
    // (undocumented)
    applyEditorParams(_property: PropertyDescription, _record: PropertyRecord): void;
    // (undocumented)
    commitValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesEscape(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    customDataController: DataController | undefined;
    // (undocumented)
    abstract get reactNode(): React.ReactNode;
    // (undocumented)
    validateValue(newValue: PropertyValue, record: PropertyRecord): Promise<AsyncValueProcessingResult>;
}

// @beta
export class PropertyEditorManager {
    // (undocumented)
    static createEditor(editType: string, editorName?: string, dataControllerName?: string): PropertyEditorBase;
    // (undocumented)
    static hasCustomEditor(editType: string, editorName: string): boolean;
    // (undocumented)
    static registerDataController(controllerName: string, controller: new () => DataControllerBase): void;
    // (undocumented)
    static registerEditor(editType: string, editor: new () => PropertyEditorBase, editorName?: string): void;
}

// @beta
export interface PropertyEditorProps extends CommonProps {
    onBlur?: (event: React.FocusEvent) => void;
    onCancel?: () => void;
    onCommit?: (args: PropertyUpdatedArgs) => void;
    propertyRecord?: PropertyRecord;
    setFocus?: boolean;
}

// @alpha
export class PropertyFilterChangeEvent extends BeEvent<PropertyFilterChangesListener> {
}

// @alpha
export type PropertyFilterChangesListener = () => void;

// @public
export class PropertyGrid extends React.Component<PropertyGridProps, PropertyGridState> {
    // @internal
    constructor(props: PropertyGridProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentDidUpdate(prevProps: PropertyGridProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @public @deprecated
export interface PropertyGridCategory {
    // (undocumented)
    properties: PropertyRecord[];
    // (undocumented)
    propertyCategory: PropertyCategory;
    // (undocumented)
    propertyCount: number;
}

// @internal (undocumented)
export class PropertyGridCommons {
    // (undocumented)
    static assignRecordClickHandlers(records: PropertyRecord[], onPropertyLinkClick?: (property: PropertyRecord, text: string) => void): void;
    // (undocumented)
    static getCurrentOrientation(width: number, preferredOrientation?: Orientation, isOrientationFixed?: boolean, horizontalOrientationMinWidth?: number): Orientation;
    }

// @public
export interface PropertyGridContextMenuArgs {
    event: React_2.MouseEvent;
    propertyRecord: PropertyRecord;
}

// @alpha
export class PropertyGridEventHandler {
    constructor(_modelSource: IPropertyGridModelSource);
    onExpansionToggled: (selectionKey: string) => void;
}

// @internal (undocumented)
export type PropertyGridEventsRelatedProps = Pick<PropertyListProps, "onPropertyClicked" | "onPropertyRightClicked" | "onPropertyContextMenu" | "onEditCommit" | "onEditCancel" | "selectedPropertyKey" | "editingPropertyKey"> & Pick<CommonPropertyGridProps, "isPropertySelectionEnabled" | "isPropertySelectionOnRightClickEnabled" | "isPropertyHoverEnabled" | "isPropertyEditingEnabled">;

// @internal
export class PropertyGridEventsRelatedPropsSupplier extends React.Component<PropertyGridEventsRelatedPropsSupplierProps, PropertyGridEventsRelatedPropsSupplierState> {
    constructor(props: PropertyGridEventsRelatedPropsSupplierProps);
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface PropertyGridEventsRelatedPropsSupplierProps extends Pick<CommonPropertyGridProps, "onPropertyContextMenu" | "isPropertyHoverEnabled" | "isPropertySelectionEnabled" | "isPropertySelectionOnRightClickEnabled" | "isPropertySelectionOnRightClickEnabled" | "onPropertySelectionChanged" | "isPropertyEditingEnabled" | "onPropertyUpdated"> {
    // (undocumented)
    children: (context: PropertyGridEventsRelatedProps) => React.ReactNode;
}

// @alpha
export class PropertyGridModelChangeEvent extends BeEvent<PropertyGridModelChangeListener> {
}

// @alpha
export type PropertyGridModelChangeListener = () => void;

// @alpha
export class PropertyGridModelSource implements IPropertyGridModelSource {
    constructor(_gridFactory: IMutableGridItemFactory);
    getModel(): IPropertyGridModel | undefined;
    modifyModel(callback: (model: IMutablePropertyGridModel) => void): void;
    onModelChanged: PropertyGridModelChangeEvent;
    // (undocumented)
    setPropertyData(data: PropertyData): void;
}

// @public
export interface PropertyGridProps extends CommonPropertyGridProps {
    dataProvider: IPropertyDataProvider;
}

// @internal (undocumented)
export class PropertyLabelRenderer extends React.PureComponent<PropertyLabelRendererProps> {
    static getStyle(offset?: number): React.CSSProperties;
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface PropertyLabelRendererProps {
    children: string | JSX.Element;
    renderColon?: boolean;
    // @beta
    tooltip?: string;
}

// @public
export interface PropertyPopupState {
    // (undocumented)
    content: React.ReactNode;
    // (undocumented)
    fixedPosition: {
        top: number;
        left: number;
    };
}

// @beta
export interface PropertyRecordMatchInfo {
    // (undocumented)
    matchCounts: {
        label: number;
        value: number;
    };
    // (undocumented)
    matchIndex: number;
    // (undocumented)
    propertyName: string;
}

// @public
export class PropertyRenderer extends React.Component<PropertyRendererProps, PropertyRendererState> {
    constructor(props: PropertyRendererProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyRendererProps): void;
    // (undocumented)
    static getLabelOffset(indentation?: number, orientation?: Orientation, width?: number, columnRatio?: number, minColumnLabelWidth?: number): number;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<PropertyRendererState>;
    updateDisplayValueAsEditor(props: PropertyRendererProps): void;
}

// @public
export interface PropertyRendererProps extends SharedRendererProps {
    // @beta
    highlightProps?: HighlightedRecordProps;
    indentation?: number;
    // @beta
    isEditing?: boolean;
    // @beta
    onEditCancel?: () => void;
    // @beta
    onEditCommit?: (args: PropertyUpdatedArgs) => void;
    propertyValueRendererManager?: PropertyValueRendererManager;
}

// @beta
export interface PropertyUpdatedArgs {
    newValue: PropertyValue;
    propertyRecord: PropertyRecord;
}

// @public
export interface PropertyValueRendererContext {
    containerType?: string;
    decoratedTextElement?: React.ReactNode;
    defaultValue?: React.ReactNode;
    isExpanded?: boolean;
    onDialogOpen?: (dialogState: PropertyDialogState) => void;
    onExpansionToggled?: () => void;
    onHeightChanged?: (newHeight: number) => void;
    onPopupHide?: () => void;
    onPopupShow?: (popupState: PropertyPopupState) => void;
    orientation?: Orientation;
    style?: React.CSSProperties;
    textHighlighter?: (text: string) => React.ReactNode;
}

// @public
export class PropertyValueRendererManager {
    // (undocumented)
    protected _defaultArrayValueRenderer: IPropertyValueRenderer;
    static get defaultManager(): PropertyValueRendererManager;
    // (undocumented)
    protected _defaultMergedValueRenderer: IPropertyValueRenderer;
    // (undocumented)
    protected _defaultPrimitiveValueRenderer: IPropertyValueRenderer;
    // (undocumented)
    protected _defaultStructValueRenderer: IPropertyValueRenderer;
    getRegisteredRenderer(rendererType: string): IPropertyValueRenderer | undefined;
    // (undocumented)
    protected _propertyRenderers: Map<string, IPropertyValueRenderer>;
    registerRenderer(rendererType: string, propertyRenderer: IPropertyValueRenderer, overwrite?: boolean): void;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): React.ReactNode;
    unregisterRenderer(rendererType: string): void;
}

// @public
export class PropertyView extends React.Component<PropertyViewProps, PropertyViewState> {
    constructor(props: PropertyViewProps);
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface PropertyViewProps extends SharedRendererProps {
    labelElement: React.ReactNode;
    valueElement?: React.ReactNode;
    valueElementRenderer?: () => React.ReactNode;
}

// @beta
export const QuantityInput: React.ForwardRefExoticComponent<QuantityProps & React.RefAttributes<HTMLInputElement>>;

// @beta
export interface QuantityProps extends CommonProps {
    initialValue: number;
    onQuantityChange: (newQuantityValue: number) => void;
    quantityType: QuantityType;
    readonly?: boolean;
}

// @public
export interface ReactDataGridColumn extends ReactDataGrid.Column<any> {
    icon?: boolean;
}

// @public
export class ResultSelector extends React.PureComponent<ResultSelectorProps, ResultSelectorState> {
    // @internal
    constructor(props: ResultSelectorProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: ResultSelectorProps): void;
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface ResultSelectorProps extends CommonProps {
    onSelectedChanged: (index: number) => void;
    resultCount: number;
}

// @public
export interface RowItem {
    cells: CellItem[];
    colorOverrides?: ItemColorOverrides;
    extendedData?: {
        [key: string]: any;
    };
    getValueFromCell?: (columnKey: string) => any;
    isDisabled?: boolean;
    key: string;
}

// @public
export interface RowProps {
    // (undocumented)
    cells: {
        [key: string]: CellProps;
    };
    // (undocumented)
    index: number;
    // (undocumented)
    item: RowItem;
    // (undocumented)
    render?: () => React.ReactNode;
    // (undocumented)
    style?: React.CSSProperties;
}

// @beta
export function SaturationPicker({ onSaturationChange, hsv, className, style }: SaturationPickerProps): JSX.Element;

// @beta
export interface SaturationPickerProps extends React.HTMLAttributes<HTMLDivElement>, CommonProps {
    hsv: HSVColor;
    onSaturationChange?: ((saturation: HSVColor) => void) | undefined;
}

// @internal
export class Scrubber extends React.Component<ScrubberProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface ScrubberProps extends CommonProps {
    // (undocumented)
    currentDuration: number;
    // (undocumented)
    endDate?: Date;
    // (undocumented)
    inMiniMode: boolean;
    // (undocumented)
    isPlaying: boolean;
    // (undocumented)
    onChange?: (values: ReadonlyArray<number>) => void;
    // (undocumented)
    onSlideStart?: () => void;
    // (undocumented)
    onUpdate?: (values: ReadonlyArray<number>) => void;
    // (undocumented)
    showTime?: boolean;
    // (undocumented)
    startDate?: Date;
    // (undocumented)
    totalDuration: number;
}

// @beta
export function SelectableContent(props: SelectableContentProps): JSX.Element;

// @beta
export interface SelectableContentDefinition {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    render: () => React.ReactNode;
}

// @beta
export interface SelectableContentProps {
    // (undocumented)
    children: SelectableContentDefinition[];
    // (undocumented)
    defaultSelectedContentId: string;
    // (undocumented)
    selectAriaLabel?: string;
}

// @internal (undocumented)
export class SelectionHandler<Item> {
    constructor(selectionMode: SelectionMode, onItemsSelectedCallback?: OnItemsSelectedCallback<Item>, onItemsDeselectedCallback?: OnItemsDeselectedCallback<Item>);
    completeDragAction(): void;
    createDragAction(componentSelectionHandler: MultiSelectionHandler<Item>, items: Array<Array<SingleSelectionHandler<Item>>>, firstItem: Item): void;
    createSelectionFunction(componentHandler: MultiSelectionHandler<Item>, itemHandler: SingleSelectionHandler<Item>): OnSelectionChanged;
    // (undocumented)
    onItemsDeselectedCallback?: OnItemsDeselectedCallback<Item>;
    // (undocumented)
    onItemsSelectedCallback?: OnItemsSelectedCallback<Item>;
    get processedItem(): Item | undefined;
    selectionMode: SelectionMode;
    updateDragAction(latestItem: Item): void;
}

// @public
export enum SelectionMode {
    Extended = 12,
    Multiple = 6,
    None = 16,
    Single = 1,
    SingleAllowDeselect = 5
}

// @public
export enum SelectionModeFlags {
    // (undocumented)
    DragEnabled = 2,
    // (undocumented)
    KeysEnabled = 8,
    // (undocumented)
    None = 16,
    // (undocumented)
    SelectionLimitOne = 1,
    // (undocumented)
    ToggleEnabled = 4
}

// @beta @deprecated
export type SetCurrentlyEditedNode = (currentlyEditedNode?: BeInspireTreeNode<TreeNodeItem>) => void;

// @public
export interface SharedRendererProps {
    // @beta
    actionButtonRenderers?: ActionButtonRenderer[];
    columnInfo?: PropertyGridColumnInfo;
    columnRatio?: number;
    isHoverable?: boolean;
    isResizeHandleBeingDragged?: boolean;
    isResizeHandleHovered?: boolean;
    isSelectable?: boolean;
    isSelected?: boolean;
    onClick?: (property: PropertyRecord, key?: string) => void;
    onColumnRatioChanged?: (ratio: number) => void | RatioChangeResult;
    onContextMenu?: (property: PropertyRecord, e: React.MouseEvent) => void;
    onResizeHandleDragChanged?: (isDragStarted: boolean) => void;
    onResizeHandleHoverChanged?: (isHovered: boolean) => void;
    onRightClick?: (property: PropertyRecord, key?: string) => void;
    orientation: Orientation;
    propertyRecord: PropertyRecord;
    uniqueKey?: string;
    width?: number;
}

// @public
export interface SharedTableNonPrimitiveValueRendererProps {
    onDialogOpen?: (dialogState: PropertyDialogState) => void;
}

// @internal
export class ShortDateTimePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @public
export class ShortDateTypeConverter extends DateTimeTypeConverterBase {
    // (undocumented)
    protected getTimeFormat(): TimeFormat;
}

// @public
export class ShowHideDialog<T extends ShowHideID> extends React.PureComponent<ShowHideDialogProps<T>, ShowHideDialogState<T>> {
    constructor(props: ShowHideDialogProps<T>);
    // @internal (undocumented)
    componentDidUpdate(oldProps: ShowHideDialogProps<T>): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: ShowHideDialogState<T>;
    }

// @public
export interface ShowHideDialogProps<T extends ShowHideID> extends GlobalDialogProps {
    initialHidden?: T[];
    items: Array<ShowHideItem<T>>;
    onShowHideChange?: (cols: T[]) => boolean | undefined;
}

// @public
export type ShowHideID = string | number | symbol;

// @public
export interface ShowHideItem<T extends ShowHideID> {
    // (undocumented)
    id: T;
    // (undocumented)
    label: string;
}

// @public
export class ShowHideMenu<T extends ShowHideID> extends React.PureComponent<ShowHideMenuProps<T>, ShowHideMenuState<T>> {
    // @internal
    constructor(props: ShowHideMenuProps<T>);
    // @internal (undocumented)
    componentDidUpdate(oldProps: ShowHideMenuProps<T>): void;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: ShowHideMenuState<T>;
    }

// @public
export interface ShowHideMenuProps<T extends ShowHideID> extends GlobalContextMenuProps {
    initialHidden?: T[];
    items: Array<ShowHideItem<T>>;
    onClose?: () => void;
    onShowHideChange?: (cols: T[]) => boolean | undefined;
    opened: boolean;
    x: number;
    y: number;
}

// @public
export class SignIn extends React.PureComponent<SignInProps, SignInState> {
    constructor(props: SignInProps);
    // (undocumented)
    render(): JSX.Element;
}

// @public
export interface SignInProps extends CommonProps {
    // @internal
    disableSignInOnClick?: boolean;
    onOffline?: () => void;
    onRegister?: () => void;
    onSignIn: () => void;
    // @internal
    signingInMessage?: string;
}

// @public
export class SimplePropertyDataProvider implements IPropertyDataProvider, PropertyData {
    // (undocumented)
    addCategory(category: PropertyCategory): number;
    // (undocumented)
    addProperty(propertyRecord: PropertyRecord, categoryIdx: number): void;
    // (undocumented)
    categories: PropertyCategory[];
    // (undocumented)
    description?: string;
    // (undocumented)
    findCategoryIndex(category: PropertyCategory): number;
    // (undocumented)
    getData(): Promise<PropertyData>;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    onDataChanged: PropertyDataChangeEvent;
    // (undocumented)
    records: {
        [categoryName: string]: PropertyRecord[];
    };
    // (undocumented)
    removeProperty(propertyRecord: PropertyRecord, categoryIdx: number): boolean;
    // (undocumented)
    replaceProperty(propertyRecord: PropertyRecord, categoryIdx: number, newRecord: PropertyRecord): boolean;
}

// @beta
export class SimpleTableDataProvider implements MutableTableDataProvider {
    constructor(columns: ColumnDescription[]);
    addRow(rowItem: RowItem): number;
    applyFilterDescriptors(filterDescriptors: CompositeFilterDescriptorCollection): Promise<void>;
    deleteRow(rowItem: RowItem, raiseRowsChangedEvent?: boolean): void;
    getColumns(): Promise<ColumnDescription[]>;
    getDistinctValues(columnKey: string, maximumValueCount?: number): Promise<DistinctValueCollection>;
    getRow(rowIndex: number, unfiltered?: boolean): Promise<RowItem>;
    getRowsCount(): Promise<number>;
    insertRow(rowItem: RowItem, index: number): number;
    moveRow(rowItem: RowItem, newIndex: number): number;
    onColumnsChanged: TableDataChangeEvent;
    onRowsChanged: TableDataChangeEvent;
    setItems(items: RowItem[]): void;
    sort(columnIndex: number, sortDirection: SortDirection): Promise<void>;
    }

// @public
export class SimpleTreeDataProvider implements ITreeDataProvider {
    constructor(hierarchy: SimpleTreeDataProviderHierarchy);
    // (undocumented)
    getNodes(parent?: TreeNodeItem, pageOptions?: PageOptions): Promise<TreeNodeItem[]>;
    // (undocumented)
    getNodesCount(parent?: TreeNodeItem): Promise<number>;
    // (undocumented)
    onTreeNodeChanged: BeEvent<TreeDataChangesListener>;
}

// @public
export type SimpleTreeDataProviderHierarchy = Map<string | undefined, TreeNodeItem[]>;

// @internal
export interface SingleSelectionHandler<TItem> {
    deselect: () => void;
    isSelected: () => boolean;
    item: () => TItem;
    preselect: () => void;
    select: () => void;
}

// @beta
export class SliderEditor extends React.PureComponent<PropertyEditorProps, SliderEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<SliderEditorState>;
}

// @beta
export class SliderPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @alpha
export interface SolarDataProvider {
    day: Date;
    readonly dayStartMs: number;
    onTimeChanged?: SolarPlaybackProgressHandler;
    shadowColor: ColorDef;
    // (undocumented)
    readonly shouldShowTimeline: boolean;
    readonly sunrise: Date;
    readonly sunset: Date;
    supportsTimelineAnimation: boolean;
    timeOfDay: Date;
    // (undocumented)
    viewId: string;
    viewport?: ScreenViewport;
}

// @alpha
export type SolarPlaybackProgressHandler = (time: Date) => void;

// @alpha
export class SolarTimeline extends React.PureComponent<SolarTimelineComponentProps, SolarTimelineComponentState> {
    constructor(props: SolarTimelineComponentProps);
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export interface SortComparer {
    sortCompare(valueA: Primitives.Value, valueB: Primitives.Value, ignoreCase?: boolean): number;
}

// @public
export class SparseArray<T> implements Iterable<T | undefined> {
    // (undocumented)
    [immerable]: boolean;
    [Symbol.iterator](): IterableIterator<T | undefined>;
    get(index: number): T | undefined;
    getIndex(lookupValue: T): number | undefined;
    getLength(): number;
    insert(index: number, value: T): void;
    iterateValues(): IterableIterator<[T, number]>;
    remove(index: number): void;
    set(index: number, value: T): void;
    setLength(length: number): void;
}

// @internal
export class SparseTree<T extends Node> {
    // (undocumented)
    [immerable]: boolean;
    // (undocumented)
    deleteSubtree(parentId: string | undefined, deleteParent?: boolean): void;
    // (undocumented)
    getChildOffset(parentId: string | undefined, childId: string): number | undefined;
    // (undocumented)
    getChildren(parentId: string | undefined, createIfNotExist?: boolean): SparseArray<string> | undefined;
    // (undocumented)
    getNode(nodeId: string): T | undefined;
    // (undocumented)
    insertChild(parentId: string | undefined, child: T, offset: number): void;
    // (undocumented)
    removeChild(parentId: string | undefined, childId: string): void;
    // (undocumented)
    setChildren(parentId: string | undefined, children: T[], offset: number): void;
    // (undocumented)
    setNumChildren(parentId: string | undefined, numChildren: number): void;
}

// @beta @deprecated
export enum StandardEditorNames {
    // (undocumented)
    ColorPicker = "color-picker",
    // (undocumented)
    EnumButtonGroup = "enum-buttongroup",
    // (undocumented)
    IconPicker = "icon-picker",
    // (undocumented)
    MultiLine = "multi-line",
    // (undocumented)
    NumberCustom = "number-custom",
    // (undocumented)
    NumericInput = "numeric-input",
    // (undocumented)
    Slider = "slider",
    // (undocumented)
    Toggle = "toggle",
    // (undocumented)
    WeightPicker = "weight-picker"
}

// @public
export class StandardRotationChangeEvent extends UiEvent<StandardRotationChangeEventArgs> {
}

// @public
export interface StandardRotationChangeEventArgs {
    // (undocumented)
    standardRotation: StandardViewId;
}

// @beta @deprecated
export enum StandardTypeConverterTypeNames {
    // (undocumented)
    Bool = "bool",
    // (undocumented)
    Boolean = "boolean",
    // (undocumented)
    Composite = "composite",
    // (undocumented)
    DateTime = "dateTime",
    // (undocumented)
    Double = "double",
    // (undocumented)
    Enum = "enum",
    // (undocumented)
    Float = "float",
    // (undocumented)
    Hex = "hex",
    // (undocumented)
    Hexadecimal = "hexadecimal",
    // (undocumented)
    Int = "int",
    // (undocumented)
    Integer = "integer",
    // (undocumented)
    Navigation = "navigation",
    // (undocumented)
    Point2d = "point2d",
    // (undocumented)
    Point3d = "point3d",
    // (undocumented)
    ShortDate = "shortdate",
    // (undocumented)
    String = "string",
    // (undocumented)
    Text = "text"
}

// @beta @deprecated
export enum StandardTypeNames {
    // (undocumented)
    Array = "array",
    // (undocumented)
    Bool = "bool",
    // (undocumented)
    Boolean = "boolean",
    // (undocumented)
    Composite = "composite",
    // (undocumented)
    DateTime = "dateTime",
    // (undocumented)
    Double = "double",
    // (undocumented)
    Enum = "enum",
    // (undocumented)
    Float = "float",
    // (undocumented)
    Hex = "hex",
    // (undocumented)
    Hexadecimal = "hexadecimal",
    // (undocumented)
    Int = "int",
    // (undocumented)
    Integer = "integer",
    // (undocumented)
    Navigation = "navigation",
    // (undocumented)
    Number = "number",
    // (undocumented)
    Point2d = "point2d",
    // (undocumented)
    Point3d = "point3d",
    // (undocumented)
    ShortDate = "shortdate",
    // (undocumented)
    String = "string",
    // (undocumented)
    Struct = "struct",
    // (undocumented)
    Text = "text"
}

// @public
export interface StringOperatorProcessor {
    contains(a: string, b: string, caseSensitive: boolean): boolean;
    doesNotContain(a: string, b: string, caseSensitive: boolean): boolean;
    endsWith(a: string, b: string, caseSensitive: boolean): boolean;
    isContainedIn(a: string, b: string, caseSensitive: boolean): boolean;
    isEmpty(a: string): boolean;
    isNotContainedIn(a: string, b: string, caseSensitive: boolean): boolean;
    isNotEmpty(a: string): boolean;
    startsWith(a: string, b: string, caseSensitive: boolean): boolean;
}

// @public
export class StringTypeConverter extends TypeConverter implements StringOperatorProcessor {
    // (undocumented)
    contains(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    convertFromString(value: string): string;
    // (undocumented)
    convertToString(value?: Primitives.String): string;
    // (undocumented)
    doesNotContain(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    endsWith(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isContainedIn(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isEmpty(valueA: string): boolean;
    // (undocumented)
    isNotContainedIn(valueA: string, valueB: string, caseSensitive: boolean): boolean;
    // (undocumented)
    isNotEmpty(valueA: string): boolean;
    // (undocumented)
    get isStringType(): boolean;
    // (undocumented)
    sortCompare(valueA: Primitives.String, valueB: Primitives.String, ignoreCase?: boolean): number;
    // (undocumented)
    startsWith(valueA: string, valueB: string, caseSensitive: boolean): boolean;
}

// @public
export class StructPropertyValueRenderer implements IPropertyValueRenderer {
    canRender(record: PropertyRecord): boolean;
    render(record: PropertyRecord, context?: PropertyValueRendererContext): {} | null | undefined;
}

// @public
export interface Subscribable<T> {
    // (undocumented)
    subscribe(observer?: Observer<T>): Subscription;
    // (undocumented)
    subscribe(next: null | undefined, error: null | undefined, complete: () => void): Subscription;
    // (undocumented)
    subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Subscription;
    // (undocumented)
    subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription;
    // (undocumented)
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
}

// @public
export interface Subscription extends Unsubscribable {
    // (undocumented)
    add(tearDown: Unsubscribable | (() => void) | void): void;
    // (undocumented)
    readonly closed: boolean;
    // (undocumented)
    unsubscribe(): void;
}

// @public
export class Table extends React.Component<TableProps, TableState> {
    // @internal
    constructor(props: TableProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(previousProps: TableProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // @internal
    get filterDescriptors(): CompositeFilterDescriptorCollection;
    // @internal
    getPropertyDisplayValueExpression(property: string): string;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    shouldComponentUpdate(_props: TableProps): boolean;
    // @internal (undocumented)
    readonly state: TableState;
    // @internal (undocumented)
    update(): Promise<UpdateStatus>;
    // @internal (undocumented)
    updateSelectedCells(): void;
    // @internal (undocumented)
    updateSelectedRows(): void;
}

// @public
export class TableArrayValueRenderer extends React.PureComponent<TableSpecificValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @beta
export interface TableCellContextMenuArgs {
    cellItem?: CellItem;
    cellKey: string;
    colIndex: number;
    event: React.MouseEvent;
    rowIndex: number;
}

// @public
export interface TableCellEditorState {
    // (undocumented)
    active: boolean;
    // (undocumented)
    cellKey?: string;
    // (undocumented)
    colIndex?: number;
    // (undocumented)
    rowIndex?: number;
}

// @public
export interface TableCellUpdatedArgs {
    // (undocumented)
    cellKey: string;
    // (undocumented)
    colIndex: number;
    // (undocumented)
    rowIndex: number;
}

// @internal
export class TableColumn extends FilterableColumnBase {
    constructor(filterableTable: FilterableTable, columnDescription: ColumnDescription, reactDataGridColumn: ReactDataGridColumn);
    // (undocumented)
    dataProvider?: TableDataProvider;
    // (undocumented)
    distinctValueCollection?: DistinctValueCollection;
    getDistinctValues(maximumValueCount?: number): Promise<DistinctValueCollection>;
    // (undocumented)
    get key(): string;
    // (undocumented)
    readonly reactDataGridColumn: ReactDataGridColumn;
}

// @public
export class TableDataChangeEvent extends BeEvent<TableDataChangesListener> {
}

// @public
export type TableDataChangesListener = () => void;

// @public
export interface TableDataProvider {
    // @beta
    applyFilterDescriptors?: (filterDescriptors: CompositeFilterDescriptorCollection) => Promise<void>;
    getColumns(): Promise<ColumnDescription[]>;
    // @beta
    getDistinctValues?: (columnKey: string, maximumValueCount?: number) => Promise<DistinctValueCollection>;
    // @alpha
    getPropertyDisplayValueExpression?: (property: string) => string;
    getRow(rowIndex: number, unfiltered?: boolean): Promise<RowItem>;
    getRowsCount(): Promise<number>;
    onColumnsChanged: TableDataChangeEvent;
    onRowsChanged: TableDataChangeEvent;
    sort(columnIndex: number, sortDirection: SortDirection): Promise<void>;
}

// @beta
export interface TableDistinctValue {
    // (undocumented)
    label: string;
    // (undocumented)
    value: Primitives.Value;
}

// @beta
export interface TableDragDropProps<DragDropObject = any> {
    // (undocumented)
    dragProps?: DragSourceProps<DragDropObject>;
    // (undocumented)
    dropProps?: TableDropTargetProps<DragDropObject>;
}

// @beta
export type TableDragDropType = {} | RowItem | TableDataProvider;

// @beta
export interface TableDropTargetProps<DragDropObject = any> extends DropTargetProps<DragDropObject> {
    canDropOn?: boolean;
}

// @public
export class TableNonPrimitiveValueRenderer extends React.PureComponent<TableNonPrimitiveValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @public
export interface TableNonPrimitiveValueRendererProps extends SharedTableNonPrimitiveValueRendererProps {
    buttonLabel: string;
    dialogContents: React.ReactNode;
    dialogTitle: string;
}

// @public
export interface TableProps extends CommonProps {
    dataProvider: TableDataProvider;
    hideHeader?: boolean;
    isCellSelected?: (rowIndex: number, cell: CellItem) => boolean;
    isRowSelected?: (row: RowItem) => boolean;
    // @internal (undocumented)
    onApplyFilter?: () => void;
    // @beta
    onCellContextMenu?: (args: TableCellContextMenuArgs) => void;
    onCellsDeselected?: (cellIterator: AsyncIterableIterator<[RowItem, CellItem]>) => Promise<boolean>;
    onCellsSelected?: (cellIterator: AsyncIterableIterator<[RowItem, CellItem]>, replace: boolean) => Promise<boolean>;
    // @beta
    onPropertyEditing?: (args: TableCellEditorState) => void;
    // @beta
    onPropertyUpdated?: (propertyArgs: PropertyUpdatedArgs, cellArgs: TableCellUpdatedArgs) => Promise<boolean>;
    // @internal
    onRender?: () => void;
    onRowsDeselected?: (rowIterator: AsyncIterableIterator<RowItem>) => Promise<boolean>;
    onRowsLoaded?: (firstRowIndex: number, lastRowIndex: number) => void;
    onRowsSelected?: (rowIterator: AsyncIterableIterator<RowItem>, replace: boolean) => Promise<boolean>;
    // @internal (undocumented)
    onScrollToRow?: (rowIndex: number) => void;
    pageAmount?: number;
    propertyValueRendererManager?: PropertyValueRendererManager;
    // @internal (undocumented)
    renderRow?: (item: RowItem, props: TableRowProps) => React.ReactNode;
    reorderableColumns?: boolean;
    scrollToRow?: number;
    selectionMode?: SelectionMode;
    settingsIdentifier?: string;
    showHideColumns?: boolean;
    stripedRows?: boolean;
    tableSelectionTarget?: TableSelectionTarget;
    uiSettings?: UiSettings;
}

// @internal
export class TableRow extends React.Component<TableRowProps> {
    // (undocumented)
    render(): JSX.Element;
}

// @internal
export interface TableRowProps extends CommonProps {
    // (undocumented)
    cells: {
        [key: string]: React.ReactNode;
    };
    // (undocumented)
    isSelected?: boolean;
}

// @public
export const TableRowStyleProvider: {
    createStyle: ({ color, backgroundColor }: ItemColorOverrides) => CSSProperties;
};

// @public
export enum TableSelectionTarget {
    // (undocumented)
    Cell = 1,
    // (undocumented)
    Row = 0
}

// @public
export interface TableSpecificValueRendererProps extends SharedTableNonPrimitiveValueRendererProps {
    orientation: Orientation;
    propertyRecord: PropertyRecord;
}

// @public
export class TableStructValueRenderer extends React.PureComponent<TableSpecificValueRendererProps> {
    // @internal (undocumented)
    render(): JSX.Element;
}

// @beta
export class TextareaEditor extends React.PureComponent<PropertyEditorProps, TextareaEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<TextareaEditorState>;
    }

// @beta
export class TextareaPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export class TextEditor extends React.PureComponent<PropertyEditorProps, TextEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): React.ReactNode;
    // @internal (undocumented)
    readonly state: Readonly<TextEditorState>;
    }

// @beta
export class ThemedEnumEditor extends React.PureComponent<ThemedEnumEditorProps, EnumEditorState_2> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<EnumEditorState_2>;
    }

// @beta
export interface ThemedEnumEditorProps extends PropertyEditorProps {
    isSearchable?: boolean;
    noOptionsMessage?: (obj: {
        inputValue: string;
    }) => string | null;
    placeholder?: string;
}

// @beta
export class ThemedEnumPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get containerHandlesBlur(): boolean;
    // (undocumented)
    get containerHandlesEnter(): boolean;
    // (undocumented)
    get containerHandlesEscape(): boolean;
    // (undocumented)
    get containerHandlesTab(): boolean;
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @internal
export class Timeline extends React.Component<TimelineProps, TimelineState> {
    constructor(props: TimelineProps);
    // (undocumented)
    render(): JSX.Element;
}

// @alpha
export class TimelineComponent extends React.PureComponent<TimelineComponentProps, TimelineComponentState> {
    constructor(props: TimelineComponentProps);
    // (undocumented)
    componentDidUpdate(prevProps: TimelineComponentProps): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @alpha
export interface TimelineDataProvider {
    animationFraction?: number;
    duration: number;
    end?: Date;
    getMilestones(parent?: Milestone): Milestone[];
    getMilestonesCount(parent?: Milestone): number;
    getSettings(): PlaybackSettings;
    id: string;
    initialDuration: number;
    loadTimelineData(): Promise<boolean>;
    loop: boolean;
    onAnimationFractionChanged?: AnimationFractionChangeHandler;
    onPlaybackSettingChanged?: PlaybackSettingsChangeHandler;
    start?: Date;
    supportsTimelineAnimation: boolean;
    updateSettings(settings: PlaybackSettings): void;
    viewId: string;
    viewport?: ScreenViewport;
}

// @alpha
export enum TimelineDateDisplay {
    ActualTime = 0,
    ProjectTime = 1
}

// @beta
export enum TimelinePausePlayAction {
    // (undocumented)
    Pause = 1,
    // (undocumented)
    Play = 2,
    // (undocumented)
    Toggle = 0
}

// @beta
export interface TimelinePausePlayArgs extends GenericUiEventArgs {
    // (undocumented)
    timelineAction: TimelinePausePlayAction;
}

// @internal
export interface TimelineProps extends CommonProps {
    // (undocumented)
    endDate: Date;
    // (undocumented)
    isPlaying: boolean;
    // (undocumented)
    milestones?: Milestone[];
    // (undocumented)
    onChange?: (values: ReadonlyArray<number>) => void;
    // (undocumented)
    onSlideStart?: () => void;
    // (undocumented)
    onUpdate?: (values: ReadonlyArray<number>) => void;
    // (undocumented)
    selectedDate: Date;
    // (undocumented)
    startDate: Date;
}

// @alpha
export enum TimelineScale {
    Days = 3,
    Hours = 4,
    Months = 2,
    Quarters = 1,
    Years = 0
}

// @beta
export class ToggleEditor extends React.PureComponent<PropertyEditorProps, ToggleEditorState> implements TypeEditor {
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<ToggleEditorState>;
    }

// @beta
export class TogglePropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @internal (undocumented)
export const toNode: <TPayload>(inspireNode: Inspire.TreeNode) => BeInspireTreeNode<TPayload>;

// @internal (undocumented)
export const toNodes: <TPayload>(inspireNodes: Inspire.TreeNodes) => BeInspireTreeNodes<TPayload>;

// @beta
export function Toolbar(props: ToolbarProps): JSX.Element;

// @beta
export const ToolbarButtonItem: React.MemoExoticComponent<React.FC<ToolbarButtonItemProps>>;

// @beta
export interface ToolbarButtonItemProps extends CommonProps {
    addGroupSeparator?: boolean;
    badge?: React.ReactNode;
    icon?: React.ReactNode;
    isActive?: boolean;
    isDisabled?: boolean;
    onClick?: () => void;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    title: string;
}

// @beta
export type ToolbarItem = ActionButton | GroupButton | CustomToolbarItem;

// @internal (undocumented)
export function ToolbarItemComponent({ item, addGroupSeparator }: {
    item: ToolbarItem;
    addGroupSeparator: boolean;
}): JSX.Element | null;

// @internal
export const ToolbarItemContext: React.Context<ToolbarItemContextArgs>;

// @internal
export interface ToolbarItemContextArgs {
    // (undocumented)
    readonly hasOverflow: boolean;
    // (undocumented)
    readonly onResize: (w: number) => void;
    // (undocumented)
    readonly useHeight: boolean;
}

// @beta
export enum ToolbarOpacitySetting {
    Defaults = 0,
    Proximity = 1,
    Transparent = 2
}

// @internal (undocumented)
export interface ToolbarOverflowContextProps {
    // (undocumented)
    readonly direction: OrthogonalDirection;
    // (undocumented)
    readonly expandsTo: Direction;
    // (undocumented)
    readonly onItemExecuted: OnItemExecutedFunc;
    // (undocumented)
    readonly onKeyDown: (e: React.KeyboardEvent) => void;
    // (undocumented)
    readonly onPopupPanelOpenClose: (isOpening: boolean) => void;
    // (undocumented)
    readonly openPopupCount: number;
    // (undocumented)
    readonly overflowDirection: OrthogonalDirection;
    // (undocumented)
    readonly overflowDisplayActive: boolean;
    // (undocumented)
    readonly overflowExpandsTo: Direction;
    // (undocumented)
    readonly panelAlignment: ToolbarPanelAlignment;
    // (undocumented)
    readonly toolbarOpacitySetting: ToolbarOpacitySetting;
    // (undocumented)
    readonly useDragInteraction: boolean;
}

// @beta
export enum ToolbarPanelAlignment {
    // (undocumented)
    End = 1,
    // (undocumented)
    Start = 0
}

// @internal
export class ToolbarPanelAlignmentHelpers {
    static readonly END_CLASS_NAME = "components-panel-alignment-end";
    // (undocumented)
    static getCssClassName(panelAlignment: ToolbarPanelAlignment): string;
    static readonly START_CLASS_NAME = "components-panel-alignment-start";
}

// @internal
export const ToolbarPopupContext: React.Context<ToolbarPopupContextProps>;

// @internal (undocumented)
export interface ToolbarPopupContextProps {
    // (undocumented)
    readonly closePanel: () => void;
    // (undocumented)
    readonly setSelectedItem?: (buttonItem: ActionButton) => void;
}

// @beta
export interface ToolbarProps extends CommonProps, NoChildrenProps {
    expandsTo?: Direction;
    items: CommonToolbarItem[];
    onItemExecuted?: OnItemExecutedFunc;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    panelAlignment?: ToolbarPanelAlignment;
    toolbarOpacitySetting?: ToolbarOpacitySetting;
    useDragInteraction?: boolean;
}

// @beta
export function ToolbarWithOverflow(props: ToolbarWithOverflowProps): JSX.Element;

// @internal
export const ToolbarWithOverflowDirectionContext: React.Context<ToolbarOverflowContextProps>;

// @beta
export interface ToolbarWithOverflowProps extends CommonProps, NoChildrenProps {
    expandsTo?: Direction;
    items: CommonToolbarItem[];
    onItemExecuted?: OnItemExecutedFunc;
    onKeyDown?: (e: React.KeyboardEvent) => void;
    overflowExpandsTo?: Direction;
    panelAlignment?: ToolbarPanelAlignment;
    toolbarOpacitySetting?: ToolbarOpacitySetting;
    useDragInteraction?: boolean;
}

// @internal (undocumented)
export function toToolbarPopupRelativePosition(expandsTo: Direction, alignment: ToolbarPanelAlignment): RelativePosition;

// @beta
export interface TreeActions {
    // (undocumented)
    onNodeCheckboxClicked: (nodeId: string, newState: CheckBoxState) => void;
    // (undocumented)
    onNodeClicked: (nodeId: string, event: React_2.MouseEvent) => void;
    // (undocumented)
    onNodeCollapsed: (nodeId: string) => void;
    // (undocumented)
    onNodeEditorActivated: (nodeId: string) => void;
    // (undocumented)
    onNodeExpanded: (nodeId: string) => void;
    // (undocumented)
    onNodeMouseDown: (nodeId: string) => void;
    // (undocumented)
    onNodeMouseMove: (nodeId: string) => void;
    // (undocumented)
    onTreeKeyDown: (event: React_2.KeyboardEvent) => void;
    // (undocumented)
    onTreeKeyUp: (event: React_2.KeyboardEvent) => void;
}

// @beta @deprecated
export interface TreeCellUpdatedArgs {
    newValue: string;
    node: BeInspireTreeNode<TreeNodeItem>;
}

// @beta
export interface TreeCheckboxStateChangeEventArgs {
    stateChanges: Observable<CheckboxStateChange[]>;
}

// @public
export type TreeDataChangesListener = (nodes: Array<TreeNodeItem | undefined>) => void;

// @public
export type TreeDataProvider = TreeDataProviderRaw | TreeDataProviderPromise | TreeDataProviderMethod | ITreeDataProvider;

// @public
export type TreeDataProviderMethod = (node?: TreeNodeItem) => Promise<DelayLoadedTreeNodeItem[]>;

// @public
export type TreeDataProviderPromise = Promise<TreeDataProviderRaw>;

// @public
export type TreeDataProviderRaw = ImmediatelyLoadedTreeNodeItem[];

// @internal
export class TreeDataSource implements IDisposable {
    constructor(dataProvider: TreeDataProvider);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly onItemsChanged: BeUiEvent<TreeDataChangesListener>;
    // (undocumented)
    requestItems(parent: TreeNodeItem | undefined, firstItemIndex: number, numItems: number, requestNumChildren: boolean): Observable_2<TreeDataSourceResult>;
}

// @beta @deprecated
export interface TreeDragDropProps<DragDropObject = any> {
    // (undocumented)
    dragProps?: DragSourceProps<DragDropObject>;
    // (undocumented)
    dropProps?: DropTargetProps<DragDropObject>;
}

// @beta @deprecated
export type TreeDragDropType = {} | TreeNodeItem | TreeDataProvider;

// @beta
export interface TreeEditingParams {
    onNodeUpdated: (node: TreeModelNode, newValue: string) => void;
}

// @internal
export class TreeEventDispatcher implements TreeActions {
    constructor(treeEvents: TreeEvents, nodeLoader: ITreeNodeLoader, selectionMode: SelectionMode, getVisibleNodes?: () => VisibleTreeNodes);
    // (undocumented)
    onNodeCheckboxClicked(nodeId: string, newState: CheckBoxState): void;
    // (undocumented)
    onNodeClicked(nodeId: string, event: React_2.MouseEvent<Element, MouseEvent>): void;
    // (undocumented)
    onNodeCollapsed(nodeId: string): void;
    // (undocumented)
    onNodeEditorActivated(nodeId: string): void;
    // (undocumented)
    onNodeExpanded(nodeId: string): void;
    // (undocumented)
    onNodeMouseDown(nodeId: string): void;
    // (undocumented)
    onNodeMouseMove(nodeId: string): void;
    // (undocumented)
    onTreeKeyDown(event: React_2.KeyboardEvent): void;
    // (undocumented)
    onTreeKeyUp(event: React_2.KeyboardEvent): void;
    // (undocumented)
    setVisibleNodes(visibleNodes: () => VisibleTreeNodes): void;
    }

// @beta
export class TreeEventHandler implements TreeEvents, IDisposable {
    constructor(params: TreeEventHandlerParams);
    dispose(): void;
    // (undocumented)
    get modelSource(): TreeModelSource;
    onCheckboxStateChanged({ stateChanges }: TreeCheckboxStateChangeEventArgs): Subscription | undefined;
    onDelayedNodeClick({ nodeId }: TreeNodeEventArgs): void;
    onNodeCollapsed({ nodeId }: TreeNodeEventArgs): void;
    onNodeEditorActivated({ nodeId }: TreeNodeEventArgs): void;
    onNodeExpanded({ nodeId }: TreeNodeEventArgs): void;
    onSelectionModified({ modifications }: TreeSelectionModificationEventArgs): Subscription | undefined;
    onSelectionReplaced({ replacements }: TreeSelectionReplacementEventArgs): Subscription | undefined;
    }

// @beta
export interface TreeEventHandlerParams {
    collapsedChildrenDisposalEnabled?: boolean;
    editingParams?: TreeEditingParams;
    modelSource: TreeModelSource;
    nodeLoader: ITreeNodeLoader;
}

// @beta
export interface TreeEvents {
    onCheckboxStateChanged?(event: TreeCheckboxStateChangeEventArgs): Subscription | undefined;
    onDelayedNodeClick?(event: TreeNodeEventArgs): void;
    onNodeCollapsed?(event: TreeNodeEventArgs): void;
    onNodeEditorActivated?(event: TreeNodeEventArgs): void;
    onNodeExpanded?(event: TreeNodeEventArgs): void;
    onSelectionModified?(event: TreeSelectionModificationEventArgs): Subscription | undefined;
    onSelectionReplaced?(event: TreeSelectionReplacementEventArgs): Subscription | undefined;
}

// @public
export class TreeImageLoader implements ITreeImageLoader {
    load(item: TreeNodeItem | BeInspireTreeNodeITree): LoadedImage | undefined;
}

// @beta
export interface TreeModel {
    // (undocumented)
    getChildren(parentId: string | undefined): SparseArray<string> | undefined;
    // (undocumented)
    getNode(id: string): TreeModelNode | undefined;
    // (undocumented)
    getNode(parentId: string | undefined, childIndex: number): TreeModelNode | TreeModelNodePlaceholder | undefined;
    // (undocumented)
    getNode(nodeId: string | undefined, childIndex?: number): TreeModelNode | TreeModelNodePlaceholder | TreeModelRootNode | undefined;
    // (undocumented)
    getRootNode(): TreeModelRootNode;
    // (undocumented)
    iterateTreeModelNodes(parentId?: string): IterableIterator<TreeModelNode>;
}

// @beta
export interface TreeModelChanges {
    // (undocumented)
    addedNodeIds: string[];
    // (undocumented)
    modifiedNodeIds: string[];
    // (undocumented)
    removedNodeIds: string[];
}

// @beta
export interface TreeModelNode {
    // (undocumented)
    readonly checkbox: CheckBoxInfo;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    readonly description: string | undefined;
    readonly editingInfo?: TreeModelNodeEditingInfo;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLoading?: boolean;
    // (undocumented)
    readonly isSelected: boolean;
    // (undocumented)
    readonly item: TreeNodeItem;
    // (undocumented)
    readonly label: PropertyRecord;
    // (undocumented)
    readonly numChildren: number | undefined;
    // (undocumented)
    readonly parentId: string | undefined;
}

// @beta
export interface TreeModelNodeEditingInfo {
    // (undocumented)
    onCancel: () => void;
    // (undocumented)
    onCommit: (node: TreeModelNode, newValue: string) => void;
}

// @beta
export interface TreeModelNodeInput {
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly isExpanded: boolean;
    // (undocumented)
    readonly isLoading: boolean;
    // (undocumented)
    readonly isSelected: boolean;
    // (undocumented)
    readonly item: TreeNodeItem;
    // (undocumented)
    readonly label: PropertyRecord;
    // (undocumented)
    readonly numChildren?: number;
}

// @beta
export interface TreeModelNodePlaceholder {
    // (undocumented)
    readonly childIndex: number;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    readonly parentId?: string;
}

// @beta
export type TreeModelNodeType = TreeModelNode | TreeModelNodePlaceholder | TreeModelRootNode;

// @beta
export interface TreeModelRootNode {
    // (undocumented)
    readonly depth: -1;
    // (undocumented)
    readonly id: undefined;
    // (undocumented)
    readonly numChildren: number | undefined;
}

// @beta
export class TreeModelSource {
    constructor();
    getModel(): TreeModel;
    getVisibleNodes(): VisibleTreeNodes;
    modifyModel(callback: (model: MutableTreeModel) => void): void;
    onModelChanged: BeUiEvent<[TreeModel, TreeModelChanges]>;
    }

// @public @deprecated
export class TreeNode extends React.Component<TreeNodeProps> {
    constructor(props: TreeNodeProps);
    // (undocumented)
    componentDidUpdate(_prevProps: TreeNodeProps): void;
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    shouldComponentUpdate(nextProps: TreeNodeProps): boolean;
}

// @beta
export interface TreeNodeEventArgs {
    nodeId: string;
}

// @public @deprecated
export function TreeNodeIcon(props: TreeNodeIconProps): JSX.Element | null;

// @public @deprecated
export interface TreeNodeIconProps extends React.Attributes {
    // (undocumented)
    imageLoader: ITreeImageLoader;
    // (undocumented)
    node: BeInspireTreeNode<TreeNodeItem>;
}

// @public
export interface TreeNodeItem {
    // (undocumented)
    autoExpand?: boolean;
    // (undocumented)
    checkBoxState?: CheckBoxState;
    // (undocumented)
    description?: string;
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    icon?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    isCheckboxDisabled?: boolean;
    // (undocumented)
    isCheckboxVisible?: boolean;
    // (undocumented)
    isEditable?: boolean;
    // (undocumented)
    label: PropertyRecord;
    // (undocumented)
    parentId?: string;
    // (undocumented)
    style?: ItemStyle;
}

// @beta
export type TreeNodeItemData = ImmediatelyLoadedTreeNodeItem & DelayLoadedTreeNodeItem;

// @beta
export class TreeNodeLoader<TDataProvider extends TreeDataProvider> extends AbstractTreeNodeLoaderWithProvider<TDataProvider> implements IDisposable {
    constructor(dataProvider: TDataProvider, modelSource: TreeModelSource);
    dispose(): void;
    protected load(parentNode: TreeModelNode | TreeModelRootNode): Observable<LoadedNodeHierarchy>;
    }

// @beta
export interface TreeNodeLoadResult {
    // (undocumented)
    loadedNodes: TreeNodeItem[];
}

// @public @deprecated
export interface TreeNodeProps extends CommonProps {
    // @beta (undocumented)
    cellEditing?: CellEditingEngine;
    // (undocumented)
    checkboxProps?: NodeCheckboxProps;
    // @beta (undocumented)
    highlightProps?: HighlightableTreeNodeProps;
    imageLoader?: ITreeImageLoader;
    // (undocumented)
    node: BeInspireTreeNode<TreeNodeItem>;
    // (undocumented)
    onClick?: (e: React.MouseEvent) => void;
    onFinalRenderComplete?: (renderId: string) => void;
    // (undocumented)
    onMouseDown?: (e: React.MouseEvent) => void;
    // (undocumented)
    onMouseMove?: (e: React.MouseEvent) => void;
    // (undocumented)
    onMouseUp?: (e: React.MouseEvent) => void;
    renderId?: string;
    // (undocumented)
    renderOverrides?: {
        renderCheckbox?: NodeCheckboxRenderer;
    };
    // (undocumented)
    showDescription?: boolean;
    // (undocumented)
    valueRendererManager: PropertyValueRendererManager;
}

// @beta
export const TreeNodeRenderer: React.MemoExoticComponent<(props: ExtendedTreeNodeRendererProps) => JSX.Element>;

// @beta
export interface TreeNodeRendererProps extends CommonProps {
    // (undocumented)
    node: TreeModelNode;
    nodeHighlightProps?: HighlightableTreeNodeProps;
    // @internal
    onLabelRendered?: (node: TreeModelNode) => void;
    // (undocumented)
    treeActions: TreeActions;
}

// @public @deprecated
export interface TreeProps extends CommonProps {
    bulkCheckboxActionsDisabled?: boolean;
    // @beta
    cellEditing?: EditableTreeProps;
    checkboxInfo?: (node: TreeNodeItem) => CheckBoxInfo_2 | Promise<CheckBoxInfo_2>;
    dataProvider: TreeDataProvider;
    disposeChildrenOnCollapse?: boolean;
    imageLoader?: ITreeImageLoader;
    // @internal
    nodeHighlightingProps?: HighlightableTreeProps;
    onCheckboxClick?: (stateChanges: Array<{
        node: TreeNodeItem;
        newState: CheckBoxState;
    }>) => void;
    onChildrenLoaded?: (parent: TreeNodeItem, children: TreeNodeItem[]) => void;
    onNodeCollapsed?: (node: TreeNodeItem) => void;
    onNodeExpanded?: (node: TreeNodeItem) => void;
    // @internal
    onNodesDeselected?: NodesDeselectedCallback;
    // @internal (undocumented)
    onNodesRender?: () => void;
    // @internal
    onNodesSelected?: NodesSelectedCallback;
    // @internal (undocumented)
    onRender?: () => void;
    onRootNodesLoaded?: (nodes: TreeNodeItem[]) => void;
    onSelectionLoadCanceled?: () => void;
    onSelectionLoadFinished?: () => void;
    onSelectionLoadProgress?: (loaded: number, total: number, cancel: () => void) => void;
    pageSize?: number;
    propertyValueRendererManager?: PropertyValueRendererManager;
    renderOverrides?: {
        renderNode?: NodeRenderer;
        renderCheckbox?: NodeCheckboxRenderer;
    };
    rowHeight?: ((node?: TreeNodeItem, index?: number) => number) | number;
    selectedNodes?: string[] | ((node: TreeNodeItem) => boolean);
    selectionMode?: SelectionMode;
    showDescriptions?: boolean;
    showIcons?: boolean;
}

// @beta
export class TreeRenderer extends React.Component<TreeRendererProps> implements TreeRendererAttributes {
    // (undocumented)
    render(): JSX.Element;
    // (undocumented)
    scrollToNode(nodeId: string, alignment?: Alignment): void;
    }

// @beta
export interface TreeRendererAttributes {
    scrollToNode(nodeId: string, alignment?: Alignment): void;
}

// @beta
export interface TreeRendererContext {
    highlightingEngine?: HighlightingEngine;
    // (undocumented)
    nodeLoader: ITreeNodeLoader;
    nodeRenderer: (props: TreeNodeRendererProps) => React.ReactNode;
    // @internal
    onLabelRendered?: (node: TreeModelNode) => void;
    // @internal
    onNodeEditorClosed?: () => void;
    // @internal
    onNodeWidthMeasured?: (width: number) => void;
    // (undocumented)
    treeActions: TreeActions;
    visibleNodes: VisibleTreeNodes;
}

// @beta
export const
/**
 * Context of [[TreeRenderer]] provider.
 * @beta
 */
TreeRendererContextConsumer: React.ExoticComponent<React.ConsumerProps<TreeRendererContext>>;

// @beta
export const
/**
 * Context of [[TreeRenderer]] provider.
 * @beta
 */
TreeRendererContextProvider: React.ProviderExoticComponent<React.ProviderProps<TreeRendererContext>>;

// @beta
export interface TreeRendererProps {
    nodeHeight: (node: TreeModelNode | TreeModelNodePlaceholder, index: number) => number;
    nodeHighlightingProps?: HighlightableTreeProps;
    // (undocumented)
    nodeLoader: ITreeNodeLoader;
    nodeRenderer?: (props: TreeNodeRendererProps) => React.ReactNode;
    // @internal
    onNodeEditorClosed?: () => void;
    // (undocumented)
    treeActions: TreeActions;
    visibleNodes: VisibleTreeNodes;
}

// @beta
export interface TreeSelectionChange {
    deselectedNodeItems: TreeNodeItem[];
    selectedNodeItems: TreeNodeItem[];
}

// @beta
export interface TreeSelectionModificationEventArgs {
    modifications: Observable<TreeSelectionChange>;
}

// @beta
export interface TreeSelectionReplacementEventArgs {
    replacements: Observable<{
        selectedNodeItems: TreeNodeItem[];
    }>;
}

// @public
export abstract class TypeConverter implements SortComparer, OperatorProcessor, NullableOperatorProcessor {
    convertFromString(_value: string): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    convertFromStringToPropertyValue(value: string, propertyRecord?: PropertyRecord): Promise<PropertyValue>;
    convertFromStringWithOptions(value: string, _options?: {
        [key: string]: any;
    }): ConvertedPrimitives.Value | undefined | Promise<ConvertedPrimitives.Value | undefined>;
    convertPropertyToString(propertyDescription: PropertyDescription, value?: Primitives.Value): string | Promise<string>;
    convertToString(value?: Primitives.Value): string | Promise<string>;
    convertToStringWithOptions(value?: Primitives.Value, _options?: {
        [key: string]: any;
    }): string | Promise<string>;
    get isBooleanType(): boolean;
    isEqualTo(valueA: Primitives.Value, valueB: Primitives.Value): boolean;
    get isLessGreaterType(): boolean;
    isNotEqualTo(valueA: Primitives.Value, valueB: Primitives.Value): boolean;
    isNotNull(value: Primitives.Value): boolean;
    isNull(value: Primitives.Value): boolean;
    get isNullableType(): boolean;
    get isStringType(): boolean;
    abstract sortCompare(valueA: Primitives.Value, valueB: Primitives.Value, _ignoreCase?: boolean): number;
}

// @public
export class TypeConverterManager {
    // (undocumented)
    static getConverter(typename: string, converterName?: string): TypeConverter;
    // (undocumented)
    static registerConverter(typename: string, converter: new () => TypeConverter, converterName?: string): void;
    // (undocumented)
    static unregisterConverter(typename: string, converterName?: string): void;
}

// @beta
export interface TypeEditor {
    // (undocumented)
    getPropertyValue: () => Promise<PropertyValue | undefined>;
}

// @public
export class UiComponents {
    static get i18n(): I18N;
    static get i18nNamespace(): string;
    static initialize(i18n?: I18N): Promise<void>;
    static get initialized(): boolean;
    // @internal (undocumented)
    static loggerCategory(obj: any): string;
    // @internal (undocumented)
    static get packageName(): string;
    static terminate(): void;
    // @internal
    static translate(key: string | string[]): string;
}

// @public
export interface Unsubscribable {
    // (undocumented)
    unsubscribe(): void;
}

// @beta
export const useAsyncValue: <T extends any>(value: T | PromiseLike<T>) => T | undefined;

// @alpha
export function useDebouncedAsyncValue<TReturn>(valueToBeResolved: undefined | (() => Promise<TReturn>)): {
    value: TReturn | undefined;
    inProgress: boolean;
};

// @beta
export function usePagedTreeNodeLoader<TDataProvider extends TreeDataProvider>(dataProvider: TDataProvider, pageSize: number, modelSource: TreeModelSource): PagedTreeNodeLoader<TDataProvider>;

// @alpha
export function usePropertyData(props: {
    dataProvider: IPropertyDataProvider;
    onPropertyLinkClick?: (property: PropertyRecord, text: string) => void;
}): {
    value: import("../PropertyDataProvider").PropertyData | undefined;
    inProgress: boolean;
};

// @alpha
export function usePropertyGridEventHandler(props: {
    modelSource: IPropertyGridModelSource;
}): PropertyGridEventHandler;

// @alpha
export function usePropertyGridModel(props: {
    modelSource: IPropertyGridModelSource;
}): IPropertyGridModel | undefined;

// @alpha
export function usePropertyGridModelSource(props: {
    dataProvider: IPropertyDataProvider;
    onPropertyLinkClick?: (property: PropertyRecord, text: string) => void;
}): PropertyGridModelSource;

// @internal (undocumented)
export function useRenderedStringValue(record: PropertyRecord, stringValueCalculator: (record: PropertyRecord) => string | Promise<string>, context?: PropertyValueRendererContext): {
    stringValue?: string;
    element: React.ReactNode;
};

// @internal (undocumented)
export function useToolbarPopupContext(): ToolbarPopupContextProps;

// @internal (undocumented)
export function useToolbarWithOverflowDirectionContext(): ToolbarOverflowContextProps;

// @internal (undocumented)
export function useToolItemEntryContext(): ToolbarItemContextArgs;

// @beta
export function useTreeEventsHandler<TEventsHandler extends TreeEventHandler>(factoryOrParams: (() => TEventsHandler) | TreeEventHandlerParams): TreeEventHandler;

// @beta
export function useTreeModelSource(dataProvider: TreeDataProvider): TreeModelSource;

// @beta
export function useTreeNodeLoader<TDataProvider extends TreeDataProvider>(dataProvider: TDataProvider, modelSource: TreeModelSource): TreeNodeLoader<TDataProvider>;

// @beta
export const
/**
 * Context of [[TreeRenderer]] provider.
 * @beta
 */
useTreeRendererContext: <P>(component: React.ComponentType<P>) => TreeRendererContext;

// @internal
export const
/**
 * Context of [[VirtualizedPropertyGrid]] provider.
 * @internal
 */
useVirtualizedPropertyGridContext: <P>(component: React.ComponentType<P>) => VirtualizedPropertyGridContext;

// @beta
export function useVisibleTreeNodes(modelSource: TreeModelSource): VisibleTreeNodes;

// @public
export class ViewClassFullNameChangedEvent extends UiEvent<ViewClassFullNameChangedEventArgs> {
}

// @public
export interface ViewClassFullNameChangedEventArgs {
    // (undocumented)
    newName: string;
    // (undocumented)
    oldName: string;
    // (undocumented)
    viewport: Viewport;
}

// @public
export class ViewIdChangedEvent extends UiEvent<ViewIdChangedEventArgs> {
}

// @public
export interface ViewIdChangedEventArgs {
    // (undocumented)
    newId: string;
    // (undocumented)
    oldId: string;
    // (undocumented)
    viewport: Viewport;
}

// @public
export class ViewportComponent extends React.Component<ViewportProps, ViewportState> {
    constructor(props: ViewportProps);
    // (undocumented)
    componentDidMount(): Promise<void>;
    // (undocumented)
    componentDidUpdate(prevProps: ViewportProps): Promise<void>;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    render(): JSX.Element;
    }

// @public
export class ViewportComponentEvents {
    // (undocumented)
    static readonly extents: Vector3d;
    // (undocumented)
    static face: Face;
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static readonly onCubeRotationChangeEvent: CubeRotationChangeEvent;
    // (undocumented)
    static readonly onDrawingViewportChangeEvent: DrawingViewportChangeEvent;
    // (undocumented)
    static readonly onStandardRotationChangeEvent: StandardRotationChangeEvent;
    // (undocumented)
    static readonly onViewClassFullNameChangedEvent: ViewClassFullNameChangedEvent;
    // (undocumented)
    static readonly onViewIdChangedEvent: ViewIdChangedEvent;
    // (undocumented)
    static readonly onViewRotationChangeEvent: ViewRotationChangeEvent;
    // (undocumented)
    static readonly origin: Point3d;
    // (undocumented)
    static readonly rotationMatrix: Matrix3d;
    // (undocumented)
    static setCubeMatrix(rotMatrix: Matrix3d, face?: Face, complete?: boolean): void;
    // (undocumented)
    static setDrawingViewportState(origin: Point3d, rotation: Matrix3d, complete?: boolean): void;
    // (undocumented)
    static setStandardRotation(standardRotation: StandardViewId): void;
    // (undocumented)
    static setViewMatrix(viewport: Viewport, animationTime?: number): void;
    // @internal
    static terminate(): void;
}

// @public
export interface ViewportProps extends CommonProps {
    // @internal (undocumented)
    getViewOverlay?: (viewport: ScreenViewport) => React.ReactNode;
    imodel: IModelConnection;
    // @internal (undocumented)
    onContextMenu?: (e: React.MouseEvent) => boolean;
    // @internal
    screenViewportOverride?: typeof ScreenViewport;
    // @internal
    tentativePointOverride?: TentativePoint;
    viewDefinitionId?: Id64String;
    // @internal
    viewManagerOverride?: ViewManager;
    viewportRef?: (v: ScreenViewport) => void;
    viewState?: ViewStateProp;
}

// @public
export class ViewRotationChangeEvent extends UiEvent<ViewRotationChangeEventArgs> {
}

// @public
export interface ViewRotationChangeEventArgs {
    // (undocumented)
    animationTime?: number;
    // (undocumented)
    viewport: Viewport;
}

// @public
export type ViewStateProp = ViewState | (() => ViewState);

// @alpha
export class VirtualizedPropertyGrid extends React.Component<VirtualizedPropertyGridProps, VirtualizedPropertyGridState> {
    // @internal
    constructor(props: VirtualizedPropertyGridProps);
    // @internal (undocumented)
    componentDidUpdate(prevProps: VirtualizedPropertyGridProps): void;
    // @internal (undocumented)
    static getDerivedStateFromProps(props: VirtualizedPropertyGridProps, state: VirtualizedPropertyGridState): VirtualizedPropertyGridState | null;
    // @internal (undocumented)
    render(): JSX.Element;
    }

// @internal
export interface VirtualizedPropertyGridContext {
    // (undocumented)
    gridContext: {
        style?: React.CSSProperties;
        className?: string;
        listWidth: number;
        orientation: Orientation;
        actionButtonRenderers?: ActionButtonRenderer[];
        propertyValueRendererManager?: PropertyValueRendererManager;
        isPropertyHoverEnabled?: boolean;
        isPropertySelectionEnabled?: boolean;
        selectedPropertyKey?: string;
        onPropertyClicked?: (property: PropertyRecord, key?: string) => void;
        onPropertyRightClicked?: (property: PropertyRecord, key?: string) => void;
        onPropertyContextMenu?: (property: PropertyRecord, e: React.MouseEvent) => void;
        editingPropertyKey?: string;
        onEditCommit?: (args: PropertyUpdatedArgs, category: PropertyCategory) => void;
        onEditCancel?: () => void;
        onNodeHeightChanged: (index: number, key: string, height: number) => void;
        columnRatio?: number;
        onColumnChanged?: (ratio: number) => void | RatioChangeResult;
        isResizeHandleHovered?: boolean;
        onResizeHandleHoverChanged?: (isHovered: boolean) => void;
        isResizeHandleBeingDragged?: boolean;
        onResizeHandleDragChanged?: (isDragStarted: boolean) => void;
        columnInfo?: PropertyGridColumnInfo;
        highlightedRecordProps?: HighlightedRecordProps;
    };
    // (undocumented)
    gridEventHandler: IPropertyGridEventHandler;
    // (undocumented)
    gridItems: FlatGridItem[];
    // (undocumented)
    gridModel: IPropertyGridModel;
}

// @internal
export const
/**
 * Context of [[VirtualizedPropertyGrid]] provider.
 * @internal
 */
VirtualizedPropertyGridContextConsumer: React.ExoticComponent<React.ConsumerProps<VirtualizedPropertyGridContext>>;

// @internal
export const
/**
 * Context of [[VirtualizedPropertyGrid]] provider.
 * @internal
 */
VirtualizedPropertyGridContextProvider: React.ProviderExoticComponent<React.ProviderProps<VirtualizedPropertyGridContext>>;

// @alpha
export interface VirtualizedPropertyGridProps extends CommonPropertyGridProps {
    // (undocumented)
    eventHandler: IPropertyGridEventHandler;
    // (undocumented)
    highlightedRecordProps?: HighlightedRecordProps;
    // (undocumented)
    model: IPropertyGridModel;
}

// @alpha
export function VirtualizedPropertyGridWithDataProvider(props: VirtualizedPropertyGridWithDataProviderProps): JSX.Element;

// @alpha
export interface VirtualizedPropertyGridWithDataProviderProps extends CommonPropertyGridProps {
    // (undocumented)
    dataProvider: IPropertyDataProvider;
    // (undocumented)
    highlightedRecordProps?: HighlightedRecordProps;
}

// @beta
export interface VisibleTreeNodes extends Iterable<TreeModelNode | TreeModelNodePlaceholder> {
    // (undocumented)
    getAtIndex(index: number): TreeModelNode | TreeModelNodePlaceholder | undefined;
    // (undocumented)
    getIndexOfNode(nodeId: string): number;
    // (undocumented)
    getModel(): TreeModel;
    // (undocumented)
    getNumNodes(): number;
    // (undocumented)
    getNumRootNodes(): number | undefined;
}

// @beta
export class WeightEditor extends React.PureComponent<PropertyEditorProps, WeightEditorState> implements TypeEditor {
    constructor(props: PropertyEditorProps);
    // @internal (undocumented)
    componentDidMount(): void;
    // @internal (undocumented)
    componentDidUpdate(prevProps: PropertyEditorProps): void;
    // @internal (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    getPropertyValue(): Promise<PropertyValue | undefined>;
    // @internal (undocumented)
    render(): JSX.Element;
    // @internal (undocumented)
    readonly state: Readonly<WeightEditorState>;
}

// @beta
export class WeightPickerButton extends React.PureComponent<WeightPickerProps, WeightPickerState> {
    // @internal
    constructor(props: WeightPickerProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    static defaultProps: {
        weights: number[];
    };
    // @internal (undocumented)
    render(): JSX.Element;
    // (undocumented)
    setFocus(): void;
    }

// @beta
export interface WeightPickerProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, CommonProps {
    activeWeight: number;
    colorDef?: ColorDef;
    disabled?: boolean;
    dropDownTitle?: string;
    hideLabel?: boolean;
    onLineWeightPick?: ((weight: number) => void) | undefined;
    readonly?: boolean;
    weights: number[];
}

// @beta
export class WeightPropertyEditor extends PropertyEditorBase {
    // (undocumented)
    get reactNode(): React.ReactNode;
}

// @beta
export function withBreadcrumbDetailsDragDrop<P extends BreadcrumbDetailsProps, DragDropObject extends BreadcrumbDetailsDragDropType>(BreadcrumbComponent: React.ComponentType<P>): React.ComponentType<P & BreadcrumbDetailsDragDropProps<DragDropObject>>;

// @beta
export function withBreadcrumbDragDrop<P extends BreadcrumbProps, DragDropObject extends TreeDragDropType>(BreadcrumbComponent: React.ComponentType<P>): React.ComponentType<P & BreadcrumbDragDropProps<DragDropObject>>;

// @beta
export const withDragSource: <ComponentProps extends {}, DragDropObject = any>(Component: React.ComponentType<ComponentProps>) => DndComponentClass<ComponentProps & WithDragSourceProps<DragDropObject>>;

// @beta
export interface WithDragSourceProps<DragDropObject = any> {
    altDropEffect?: DropEffects;
    // @internal (undocumented)
    canDrag?: boolean;
    // @internal (undocumented)
    connectDragPreview?: ConnectDragPreview;
    // @internal (undocumented)
    connectDragSource?: ConnectDragSource;
    ctrlDropEffect?: DropEffects;
    defaultDropEffect?: DropEffects;
    dragProps: DragSourceProps<DragDropObject>;
    dragStyle?: React.CSSProperties;
    // @internal (undocumented)
    isDragging?: boolean;
    // @internal (undocumented)
    item?: DragDropObject;
    // @internal (undocumented)
    type?: string | symbol | null;
}

// @beta
export const withDropTarget: <ComponentProps extends {}, DragDropObject = any>(Component: React.ComponentType<ComponentProps>) => DndComponentClass<ComponentProps & WithDropTargetProps<DragDropObject>>;

// @beta
export interface WithDropTargetProps<DragDropObject = any> {
    // @internal (undocumented)
    canDrop?: boolean;
    // @internal (undocumented)
    connectDropTarget?: ConnectDropTarget;
    dropProps: DropTargetProps<DragDropObject>;
    dropStyle?: React.CSSProperties;
    // @internal (undocumented)
    isOver?: boolean;
    // @internal (undocumented)
    item?: DragDropObject;
    shallow?: boolean;
    // @internal (undocumented)
    type?: string | symbol;
}

// @beta
export function withTableDragDrop<P extends TableProps, DragDropObject extends TableDragDropType>(TableComponent: React.ComponentType<P>): React.ComponentType<P & TableDragDropProps<DragDropObject>>;


// (No @packageDocumentation comment for this package)

```
