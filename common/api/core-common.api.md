## API Report File for "@itwin/core-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AccessToken } from '@itwin/core-bentley';
import { Angle } from '@itwin/core-geometry';
import { AngleProps } from '@itwin/core-geometry';
import { AnyGeometryQuery } from '@itwin/core-geometry';
import { BeEvent } from '@itwin/core-bentley';
import { BentleyError } from '@itwin/core-bentley';
import { BentleyStatus } from '@itwin/core-bentley';
import { BriefcaseStatus } from '@itwin/core-bentley';
import { Buffer as Buffer_2 } from 'buffer';
import { ByteStream } from '@itwin/core-bentley';
import { ChangeSetStatus } from '@itwin/core-bentley';
import { ClipPlane } from '@itwin/core-geometry';
import { ClipPlaneContainment } from '@itwin/core-geometry';
import { ClipVector } from '@itwin/core-geometry';
import { ClipVectorProps } from '@itwin/core-geometry';
import { CompressedId64Set } from '@itwin/core-bentley';
import { Constructor } from '@itwin/core-bentley';
import { ConvexClipPlaneSet } from '@itwin/core-geometry';
import { DbOpcode } from '@itwin/core-bentley';
import { DbResult } from '@itwin/core-bentley';
import { GeometryQuery } from '@itwin/core-geometry';
import { GeoServiceStatus } from '@itwin/core-bentley';
import { GetMetaDataFunction } from '@itwin/core-bentley';
import { GuidString } from '@itwin/core-bentley';
import { Id64 } from '@itwin/core-bentley';
import { Id64Array } from '@itwin/core-bentley';
import { Id64Set } from '@itwin/core-bentley';
import { Id64String } from '@itwin/core-bentley';
import { IDisposable } from '@itwin/core-bentley';
import { IModelJson } from '@itwin/core-geometry';
import { IModelStatus } from '@itwin/core-bentley';
import { IndexedPolyfaceVisitor } from '@itwin/core-geometry';
import { IndexedValue } from '@itwin/core-bentley';
import { IndexMap } from '@itwin/core-bentley';
import { LogFunction } from '@itwin/core-bentley';
import { LogLevel } from '@itwin/core-bentley';
import { LowAndHighXY } from '@itwin/core-geometry';
import { LowAndHighXYZ } from '@itwin/core-geometry';
import { Map4d } from '@itwin/core-geometry';
import { Matrix3d } from '@itwin/core-geometry';
import { Matrix4dProps } from '@itwin/core-geometry';
import { Mutable } from '@itwin/core-bentley';
import { NonFunctionPropertiesOf } from '@itwin/core-bentley';
import { OpenMode } from '@itwin/core-bentley';
import { OrderedId64Iterable } from '@itwin/core-bentley';
import { Plane3dByOriginAndUnitNormal } from '@itwin/core-geometry';
import { Point2d } from '@itwin/core-geometry';
import { Point3d } from '@itwin/core-geometry';
import { Point4d } from '@itwin/core-geometry';
import { PolyfaceVisitor } from '@itwin/core-geometry';
import { Range1d } from '@itwin/core-geometry';
import { Range1dProps } from '@itwin/core-geometry';
import { Range2d } from '@itwin/core-geometry';
import { Range3d } from '@itwin/core-geometry';
import { Range3dProps } from '@itwin/core-geometry';
import { Readable } from 'stream';
import { RepositoryStatus } from '@itwin/core-bentley';
import { RpcInterfaceStatus } from '@itwin/core-bentley';
import { Transform } from '@itwin/core-geometry';
import { TransformProps } from '@itwin/core-geometry';
import { Vector2d } from '@itwin/core-geometry';
import { Vector3d } from '@itwin/core-geometry';
import { Writable } from 'stream';
import { XAndY } from '@itwin/core-geometry';
import { XYAndZ } from '@itwin/core-geometry';
import { XYProps } from '@itwin/core-geometry';
import { XYZProps } from '@itwin/core-geometry';
import { YawPitchRollAngles } from '@itwin/core-geometry';
import { YawPitchRollProps } from '@itwin/core-geometry';

// @public
export class AdditionalTransform implements AdditionalTransformProps {
    constructor(data?: AdditionalTransformProps);
    equals(other: AdditionalTransform): boolean;
    static fromJSON(data: AdditionalTransformProps): AdditionalTransform;
    readonly helmert2DWithZOffset?: Helmert2DWithZOffset;
    toJSON(): AdditionalTransformProps;
}

// @public
export interface AdditionalTransformProps {
    helmert2DWithZOffset?: Helmert2DWithZOffsetProps;
}

// @public
export class AffineTransform implements AffineTransformProps {
    constructor(data?: AffineTransformProps);
    readonly a1: number;
    readonly a2: number;
    readonly b1: number;
    readonly b2: number;
    equals(other: AffineTransform): boolean;
    static fromJSON(data: AffineTransformProps): AffineTransform;
    toJSON(): AffineTransformProps;
    readonly translationX: number;
    readonly translationY: number;
}

// @public
export interface AffineTransformProps {
    a1: number;
    a2: number;
    b1: number;
    b2: number;
    translationX: number;
    translationY: number;
}

// @internal (undocumented)
export const aggregateLoad: {
    lastRequest: number;
    lastResponse: number;
};

// @public
export class AmbientLight {
    constructor(json?: AmbientLightProps);
    clone(changed?: AmbientLightProps): AmbientLight;
    // (undocumented)
    readonly color: RgbColor;
    // (undocumented)
    equals(rhs: AmbientLight): boolean;
    // (undocumented)
    readonly intensity: number;
    // (undocumented)
    toJSON(): AmbientLightProps | undefined;
}

// @public
export interface AmbientLightProps {
    color?: RgbColorProps;
    intensity?: number;
}

// @public
export namespace AmbientOcclusion {
    export interface Props {
        readonly bias?: number;
        readonly blurDelta?: number;
        readonly blurSigma?: number;
        // (undocumented)
        readonly blurTexelStepSize?: number;
        readonly intensity?: number;
        readonly maxDistance?: number;
        readonly texelStepSize?: number;
        readonly zLengthCap?: number;
    }
    export class Settings implements Props {
        // (undocumented)
        readonly bias: number;
        // (undocumented)
        readonly blurDelta: number;
        // (undocumented)
        readonly blurSigma: number;
        // (undocumented)
        readonly blurTexelStepSize: number;
        // (undocumented)
        static defaults: Settings;
        // (undocumented)
        static fromJSON(json?: Props): Settings;
        // (undocumented)
        readonly intensity: number;
        // (undocumented)
        readonly maxDistance: number;
        // (undocumented)
        readonly texelStepSize: number;
        // (undocumented)
        toJSON(): Props;
        // (undocumented)
        readonly zLengthCap: number;
    }
}

// @public
export class AnalysisStyle {
    clone(changedProps: AnalysisStyleProps): AnalysisStyle;
    // (undocumented)
    static readonly defaults: AnalysisStyle;
    // (undocumented)
    readonly displacement?: AnalysisStyleDisplacement;
    equals(other: AnalysisStyle): boolean;
    static fromJSON(props?: AnalysisStyleProps): AnalysisStyle;
    readonly normalChannelName?: string;
    // (undocumented)
    readonly thematic?: AnalysisStyleThematic;
    toJSON(): AnalysisStyleProps;
}

// @public
export class AnalysisStyleDisplacement {
    readonly channelName: string;
    equals(other: AnalysisStyleDisplacement): boolean;
    static fromJSON(props: AnalysisStyleDisplacementProps): AnalysisStyleDisplacement;
    readonly scale: number;
    toJSON(): AnalysisStyleDisplacementProps;
}

// @public
export interface AnalysisStyleDisplacementProps {
    channelName: string;
    scale?: number;
}

// @public
export interface AnalysisStyleProps {
    displacement?: AnalysisStyleDisplacementProps;
    normalChannelName?: string;
    scalar?: AnalysisStyleThematicProps;
}

// @public
export class AnalysisStyleThematic {
    readonly channelName: string;
    equals(other: AnalysisStyleThematic): boolean;
    static fromJSON(props: AnalysisStyleThematicProps): AnalysisStyleThematic;
    get gradient(): Gradient.Symb;
    readonly range: Readonly<Range1d>;
    readonly thematicSettings: ThematicGradientSettings;
    toJSON(): AnalysisStyleThematicProps;
}

// @public
export interface AnalysisStyleThematicProps {
    channelName: string;
    range: Range1dProps;
    thematicSettings?: ThematicGradientSettingsProps;
}

// @public
export interface AppearanceOverrideProps {
    color?: ColorDefProps;
    ids?: Id64Array;
    overrideType?: FeatureOverrideType;
}

// @public
export interface AreaFillProps {
    backgroundFill?: BackgroundFill;
    color?: ColorDefProps;
    display: FillDisplay;
    gradient?: Gradient.SymbProps;
    transparency?: number;
}

// @public (undocumented)
export namespace AreaPattern {
    // (undocumented)
    export class HatchDefLine implements HatchDefLineProps {
        constructor(json: HatchDefLineProps);
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        dashes?: number[];
        // (undocumented)
        offset?: Point2d;
        // (undocumented)
        through?: Point2d;
    }
    export interface HatchDefLineProps {
        angle?: AngleProps;
        dashes?: number[];
        offset?: XYProps;
        through?: XYProps;
    }
    export class Params {
        // (undocumented)
        angle1?: Angle;
        // (undocumented)
        angle2?: Angle;
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        clone(): Params;
        // (undocumented)
        color?: ColorDef;
        // (undocumented)
        defLines?: HatchDefLine[];
        // (undocumented)
        equals(other: Params): boolean;
        static fromJSON(json?: ParamsProps): Params;
        // (undocumented)
        static getTransformPatternScale(transform: Transform): number;
        // (undocumented)
        invisibleBoundary?: boolean;
        // (undocumented)
        origin?: Point3d;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        snappable?: boolean;
        // (undocumented)
        space1?: number;
        // (undocumented)
        space2?: number;
        // (undocumented)
        symbolId?: Id64String;
        // (undocumented)
        toJSON(): ParamsProps;
        // (undocumented)
        static transformPatternSpace(transform: Transform, oldSpace: number, patRot: Matrix3d, angle?: Angle): number;
        // (undocumented)
        weight?: number;
    }
    export interface ParamsProps {
        angle1?: AngleProps;
        angle2?: AngleProps;
        color?: ColorDefProps;
        defLines?: HatchDefLineProps[];
        invisibleBoundary?: boolean;
        origin?: XYZProps;
        rotation?: YawPitchRollProps;
        scale?: number;
        snappable?: boolean;
        space1?: number;
        space2?: number;
        symbolId?: Id64String;
        weight?: number;
    }
}

// @beta
export interface AuthorizationClient {
    getAccessToken(): Promise<AccessToken>;
}

// @public
export interface AuxCoordSystem2dProps extends AuxCoordSystemProps {
    angle?: AngleProps;
    origin?: XYProps;
}

// @public
export interface AuxCoordSystem3dProps extends AuxCoordSystemProps {
    origin?: XYZProps;
    pitch?: AngleProps;
    roll?: AngleProps;
    yaw?: AngleProps;
}

// @public (undocumented)
export interface AuxCoordSystemProps extends ElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    type?: number;
}

// @public
export type AxisAlignedBox3d = Range3d;

// @public
export type AxisAlignedBox3dProps = Range3dProps;

// @internal
export class B3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJson: any;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public (undocumented)
export class BackendError extends IModelError {
    constructor(errorNumber: number, name: string, message: string, getMetaData?: GetMetaDataFunction);
}

// @public
export enum BackgroundFill {
    None = 0,
    Outline = 2,
    Solid = 1
}

// @public
export interface BackgroundMapProps {
    applyTerrain?: boolean;
    globeMode?: GlobeMode;
    groundBias?: number;
    nonLocatable?: boolean;
    // @beta
    planarClipMask?: PlanarClipMaskProps;
    providerData?: never;
    providerName?: never;
    terrainSettings?: TerrainProps;
    transparency?: number | false;
    useDepthBuffer?: boolean;
}

// @public
export class BackgroundMapProvider {
    clone(changedProps: BackgroundMapProviderProps): BackgroundMapProvider;
    equals(other: BackgroundMapProvider): boolean;
    // @internal (undocumented)
    static fromBackgroundMapProps(props: DeprecatedBackgroundMapProps): BackgroundMapProvider;
    static fromJSON(props: BackgroundMapProviderProps): BackgroundMapProvider;
    readonly name: BackgroundMapProviderName;
    toJSON(): BackgroundMapProviderProps;
    readonly type: BackgroundMapType;
}

// @public
export type BackgroundMapProviderName = "BingProvider" | "MapBoxProvider";

// @public
export interface BackgroundMapProviderProps {
    name?: BackgroundMapProviderName;
    type?: BackgroundMapType;
}

// @public
export class BackgroundMapSettings {
    readonly applyTerrain: boolean;
    clone(changedProps?: BackgroundMapProps): BackgroundMapSettings;
    equals(other: BackgroundMapSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    equalsPersistentJSON(json?: PersistentBackgroundMapProps): boolean;
    static fromJSON(json?: BackgroundMapProps): BackgroundMapSettings;
    static fromPersistentJSON(json?: PersistentBackgroundMapProps): BackgroundMapSettings;
    readonly globeMode: GlobeMode;
    readonly groundBias: number;
    get locatable(): boolean;
    // @beta
    readonly planarClipMask: PlanarClipMaskSettings;
    readonly terrainSettings: TerrainSettings;
    toJSON(): BackgroundMapProps;
    toPersistentJSON(): PersistentBackgroundMapProps;
    readonly transparency: number | false;
    get transparencyOverride(): number | undefined;
    readonly useDepthBuffer: boolean;
}

// @public
export enum BackgroundMapType {
    // (undocumented)
    Aerial = 2,
    // (undocumented)
    Hybrid = 3,
    // (undocumented)
    Street = 1
}

// @public
export type Base64EncodedString = string;

// @public
export namespace Base64EncodedString {
    const prefix = "encoding=base64;";
    export function ensurePrefix(base64: string): Base64EncodedString;
    export function fromUint8Array(bytes: Uint8Array): Base64EncodedString;
    export function hasPrefix(str: string): boolean;
    export function stripPrefix(base64: Base64EncodedString): string;
    export function toUint8Array(base64: Base64EncodedString): Uint8Array;
    const reviver: (_name: string, value: any) => any;
    const replacer: (_name: string, value: any) => any;
}

// @public
export type BaseLayerProps = BaseMapLayerProps | ColorDefProps;

// @public
export type BaseLayerSettings = BaseMapLayerSettings | ColorDef;

// @public (undocumented)
export namespace BaseLayerSettings {
    export function fromJSON(props: BaseLayerProps): BaseLayerSettings;
}

// @public
export interface BaseMapLayerProps extends ImageMapLayerProps {
    // (undocumented)
    provider?: BackgroundMapProviderProps;
}

// @public
export class BaseMapLayerSettings extends ImageMapLayerSettings {
    clone(changedProps: Partial<BaseMapLayerProps>): BaseMapLayerSettings;
    // @internal (undocumented)
    cloneProps(changedProps: Partial<BaseMapLayerProps>): BaseMapLayerProps;
    // @alpha (undocumented)
    cloneWithProvider(provider: BackgroundMapProvider): BaseMapLayerSettings;
    // @internal (undocumented)
    static fromBackgroundMapProps(props: DeprecatedBackgroundMapProps): BaseMapLayerSettings;
    static fromJSON(props: BaseMapLayerProps): BaseMapLayerSettings;
    static fromProvider(provider: BackgroundMapProvider, options?: {
        invisible?: boolean;
        transparency?: number;
    }): BaseMapLayerSettings;
    get provider(): BackgroundMapProvider | undefined;
    toJSON(): BaseMapLayerProps;
}

// @public
export interface BaseReaderOptions {
    priority?: number;
    quota?: QueryQuota;
    restartToken?: string;
    usePrimaryConn?: boolean;
}

// @public
export interface BasicPlanarClipMaskArgs {
    invert?: boolean;
    transparency?: number;
}

// @public
export enum BatchType {
    PlanarClassifier = 2,
    Primary = 0,
    VolumeClassifier = 1
}

// @internal
export abstract class BentleyCloudRpcConfiguration extends RpcConfiguration {
    static readonly accessControl: {
        allowOrigin: string;
        allowMethods: string;
        allowHeaders: string;
    };
    abstract readonly protocol: BentleyCloudRpcProtocol;
}

// @internal
export class BentleyCloudRpcManager extends RpcManager {
    static initializeClient(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[], routing?: RpcRoutingToken): BentleyCloudRpcConfiguration;
    static initializeImpl(params: BentleyCloudRpcParams, interfaces: RpcInterfaceDefinition[]): BentleyCloudRpcConfiguration;
}

// @internal
export interface BentleyCloudRpcParams {
    info: OpenAPIInfo;
    pendingRequestListener?: RpcRequestEventHandler;
    protocol?: typeof BentleyCloudRpcProtocol;
    uriPrefix?: string;
}

// @internal
export abstract class BentleyCloudRpcProtocol extends WebAppRpcProtocol {
    // (undocumented)
    checkToken: boolean;
    getOperationFromPath(path: string): SerializedRpcOperation;
    inflateToken(tokenFromBody: IModelRpcProps, request: SerializedRpcRequest): IModelRpcProps;
    protocolVersionHeaderName: string;
    serializedClientRequestContextHeaderNames: SerializedRpcActivity;
    supplyPathForOperation(operation: RpcOperation, request: RpcRequest | undefined): string;
    supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
}

export { BentleyError }

export { BentleyStatus }

// @public
export enum BisCodeSpec {
    // @internal (undocumented)
    annotationFrameStyle = "bis:AnnotationFrameStyle",
    // @internal (undocumented)
    annotationLeaderStyle = "bis:AnnotationLeaderStyle",
    // @internal (undocumented)
    annotationTextStyle = "bis:AnnotationTextStyle",
    auxCoordSystem2d = "bis:AuxCoordSystem2d",
    auxCoordSystem3d = "bis:AuxCoordSystem3d",
    auxCoordSystemSpatial = "bis:AuxCoordSystemSpatial",
    categorySelector = "bis:CategorySelector",
    // @internal (undocumented)
    colorBook = "bis:ColorBook",
    displayStyle = "bis:DisplayStyle",
    drawing = "bis:Drawing",
    drawingCategory = "bis:DrawingCategory",
    externalSource = "bis:ExternalSource",
    externalSourceAttachment = "bis:ExternalSourceAttachment",
    geometryPart = "bis:GeometryPart",
    graphicalType2d = "bis:GraphicalType2d",
    informationPartitionElement = "bis:InformationPartitionElement",
    lineStyle = "bis:LineStyle",
    linkElement = "bis:LinkElement",
    modelSelector = "bis:ModelSelector",
    nullCodeSpec = "bis:NullCodeSpec",
    physicalMaterial = "bis:PhysicalMaterial",
    physicalType = "bis:PhysicalType",
    renderMaterial = "bis:RenderMaterial",
    sheet = "bis:Sheet",
    spatialCategory = "bis:SpatialCategory",
    spatialLocationType = "bis:SpatialLocationType",
    subCategory = "bis:SubCategory",
    subject = "bis:Subject",
    templateRecipe2d = "bis:TemplateRecipe2d",
    templateRecipe3d = "bis:TemplateRecipe3d",
    // @internal (undocumented)
    textAnnotationSeed = "bis:TextAnnotationSeed",
    texture = "bis:Texture",
    viewDefinition = "bis:ViewDefinition"
}

// @internal (undocumented)
export function bisectTileRange2d(range: Range3d, takeUpper: boolean): void;

// @internal (undocumented)
export function bisectTileRange3d(range: Range3d, takeUpper: boolean): void;

// @beta (undocumented)
export interface BlobOptions extends BaseReaderOptions {
    // (undocumented)
    range?: BlobRange;
}

// @beta (undocumented)
export class BlobOptionsBuilder {
    constructor(_options?: BlobOptions);
    // (undocumented)
    getOptions(): BlobOptions;
    // (undocumented)
    setPriority(val: number): this;
    // (undocumented)
    setQuota(val: QueryQuota): this;
    // (undocumented)
    setRange(val: BlobRange): this;
    // (undocumented)
    setRestartToken(val: string): this;
    // (undocumented)
    setUsePrimaryConnection(val: boolean): this;
}

// @beta (undocumented)
export type BlobRange = QueryLimit;

// @public
export class BoundingSphere {
    constructor(center?: Point3d, radius?: number);
    // (undocumented)
    center: Point3d;
    // (undocumented)
    init(center: Point3d, radius: number): void;
    // (undocumented)
    radius: number;
    // (undocumented)
    transformBy(transform: Transform, result: BoundingSphere): BoundingSphere;
}

// @alpha
export interface BRepCutProps {
    bothDirections?: boolean;
    distance?: number;
}

// @public
export namespace BRepEntity {
    export interface DataProps {
        data?: Base64EncodedString;
        faceSymbology?: FaceSymbologyProps[];
        transform?: TransformProps;
        type?: Type;
    }
    export interface FaceSymbologyProps {
        color?: ColorDefProps;
        materialId?: Id64String;
        transparency?: number;
    }
    export enum Type {
        Sheet = 1,
        Solid = 0,
        Wire = 2
    }
}

// @alpha
export interface BRepGeometryCreate {
    entryArray: ElementGeometryDataEntry[];
    onResult: BRepGeometryFunction;
    operation: BRepGeometryOperation;
    parameters?: BRepCutProps | BRepThickenProps | BRepHollowProps | BRepRoundProps | BRepOffsetProps;
    separateDisjoint?: boolean;
}

// @alpha
export type BRepGeometryFunction = (info: BRepGeometryInfo) => void;

// @alpha
export interface BRepGeometryInfo {
    entryArray: ElementGeometryDataEntry[];
}

// @alpha
export enum BRepGeometryOperation {
    Cut = 4,
    Emboss = 5,
    Hollow = 7,
    Intersect = 2,
    Loft = 9,
    Offset = 11,
    Round = 10,
    Sew = 3,
    Subtract = 1,
    Sweep = 8,
    Thicken = 6,
    Unite = 0
}

// @alpha
export interface BRepHollowProps {
    distance: number;
}

// @alpha
export interface BRepOffsetProps {
    distance: number;
}

// @public
export interface BRepPrimitive {
    // @beta (undocumented)
    readonly brep: BRepEntity.DataProps;
    // (undocumented)
    type: "brep";
}

// @alpha
export interface BRepRoundProps {
    radius: number;
}

// @alpha
export interface BRepThickenProps {
    backDistance?: number;
    frontDistance?: number;
}

// @public
export interface BriefcaseDownloader {
    readonly briefcaseId: BriefcaseId;
    readonly downloadPromise: Promise<void>;
    readonly fileName: LocalFileName;
    readonly requestCancel: () => Promise<boolean>;
}

// @public
export type BriefcaseId = number;

// @public
export enum BriefcaseIdValue {
    FirstValid = 2,
    Illegal = 4294967295,
    LastValid = 16777205,
    Max = 16777216,
    Unassigned = 0
}

// @public
export interface BriefcaseProps {
    readonly briefcaseId: BriefcaseId;
    readonly iModelId: GuidString;
}

export { BriefcaseStatus }

// @public
export function calculateSolarAngles(date: Date, location: Cartographic): {
    azimuth: number;
    elevation: number;
};

// @public
export function calculateSolarDirection(date: Date, location: Cartographic): Vector3d;

// @public
export function calculateSolarDirectionFromAngles(azimuthElevation: {
    azimuth: number;
    elevation: number;
}): Vector3d;

// @public
export function calculateSunriseOrSunset(date: Date, location: Cartographic, sunrise: boolean): Date;

// @public (undocumented)
export interface CalloutProps extends GeometricElement2dProps {
    // (undocumented)
    drawingModel?: RelatedElementProps;
}

// @public
export class Camera implements CameraProps {
    constructor(props?: CameraProps);
    // (undocumented)
    clone(): Camera;
    // (undocumented)
    equals(other: Camera): boolean;
    // (undocumented)
    readonly eye: Point3d;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    getEyePoint(): Point3d;
    // (undocumented)
    getFocusDistance(): number;
    // (undocumented)
    getLensAngle(): Angle;
    // (undocumented)
    invalidateFocus(): void;
    // (undocumented)
    get isFocusValid(): boolean;
    // (undocumented)
    get isLensValid(): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    static isValidLensAngle(val: Angle): boolean;
    // (undocumented)
    readonly lens: Angle;
    // (undocumented)
    setEyePoint(pt: XYAndZ): void;
    // (undocumented)
    setFocusDistance(dist: number): void;
    // (undocumented)
    setFrom(rhs: Camera): void;
    // (undocumented)
    setLensAngle(angle: Angle): void;
    // (undocumented)
    validateLens(): void;
    // (undocumented)
    static validateLensAngle(val: Angle): void;
}

// @public
export interface CameraProps {
    // (undocumented)
    eye: XYZProps;
    // (undocumented)
    focusDist: number;
    // (undocumented)
    lens: AngleProps;
}

// @public
export class Carto2DDegrees implements Carto2DDegreesProps {
    constructor(data?: Carto2DDegreesProps);
    equals(other: Carto2DDegrees): boolean;
    static fromJSON(data: Carto2DDegreesProps): Carto2DDegrees;
    get latitude(): number;
    set latitude(newLatitude: number);
    longitude: number;
    toJSON(): Carto2DDegreesProps;
}

// @public
export interface Carto2DDegreesProps {
    latitude: number;
    longitude: number;
}

// @public
export class Cartographic implements CartographicProps {
    clone(result?: Cartographic): Cartographic;
    static createZero(): Cartographic;
    equals(right: CartographicProps): boolean;
    equalsEpsilon(right: CartographicProps, epsilon: number): boolean;
    freeze(): Readonly<this>;
    static fromAngles(args: {
        longitude: Angle;
        latitude: Angle;
        height?: number;
    }, result?: Cartographic): Cartographic;
    static fromDegrees(args: {
        longitude: number;
        latitude: number;
        height?: number;
    }, result?: Cartographic): Cartographic;
    static fromEcef(cartesian: Point3d, result?: Cartographic): Cartographic | undefined;
    static fromRadians(args: {
        longitude: number;
        latitude: number;
        height?: number;
    }, result?: Cartographic): Cartographic;
    static geocentricLatitudeFromGeodeticLatitude(geodeticLatitude: number): number;
    // (undocumented)
    height: number;
    // (undocumented)
    latitude: number;
    get latitudeDegrees(): number;
    // (undocumented)
    longitude: number;
    get longitudeDegrees(): number;
    static parametricLatitudeFromGeodeticLatitude(geodeticLatitude: number): number;
    static scalePointToGeodeticSurface(point: Point3d, result?: Point3d): Point3d | undefined;
    toEcef(result?: Point3d): Point3d;
    toJSON(): CartographicProps;
    toString(): string;
}

// @public
export interface CartographicProps {
    height: number;
    latitude: number;
    longitude: number;
}

// @public
export class CartographicRange {
    constructor(spatialRange: Range3d, spatialToEcef: Transform);
    getLongitudeLatitudeBoundingBox(): Range2d;
    // (undocumented)
    intersectsRange(other: CartographicRange): boolean;
}

// @public
export interface CategoryProps extends DefinitionElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    rank?: Rank;
}

// @public
export interface CategorySelectorProps extends DefinitionElementProps {
    // (undocumented)
    categories: Id64Array;
}

// @internal (undocumented)
export interface ChangeData {
    // (undocumented)
    changedElements: ChangedElements;
    // (undocumented)
    changedModels: ChangedModels;
}

// @public
export interface ChangedElements {
    classIds: Id64String[];
    elements: Id64String[];
    modelIds?: Id64String[];
    newChecksums?: number[][];
    oldChecksums?: number[][];
    opcodes: DbOpcode[];
    parentClassIds?: Id64String[];
    parentIds?: Id64String[];
    properties?: string[][];
    type: TypeOfChange[];
}

// @public
export interface ChangedEntities {
    deleted?: CompressedId64Set;
    inserted?: CompressedId64Set;
    updated?: CompressedId64Set;
}

// @internal (undocumented)
export interface ChangedModels {
    // (undocumented)
    bboxes: AxisAlignedBox3dProps[];
    // (undocumented)
    modelIds: Id64String[];
}

// @public
export enum ChangedValueState {
    // (undocumented)
    AfterInsert = 1,
    // (undocumented)
    AfterUpdate = 3,
    // (undocumented)
    BeforeDelete = 4,
    // (undocumented)
    BeforeUpdate = 2
}

// @public
export enum ChangeOpCode {
    // (undocumented)
    Delete = 4,
    // (undocumented)
    Insert = 1,
    // (undocumented)
    Update = 2
}

// @beta
export interface ChangesetFileProps extends ChangesetProps {
    pathname: LocalFileName;
}

// @public
export type ChangesetId = string;

// @public
export interface ChangesetIdWithIndex {
    // (undocumented)
    readonly id: ChangesetId;
    // (undocumented)
    readonly index?: ChangesetIndex;
}

// @public
export type ChangesetIndex = number;

// @public
export interface ChangesetIndexAndId {
    // (undocumented)
    readonly id: ChangesetId;
    // (undocumented)
    readonly index: ChangesetIndex;
}

// @public
export type ChangesetIndexOrId = ChangesetIndexAndId | {
    readonly index: ChangesetIndex;
    readonly id?: never;
} | {
    readonly id: ChangesetId;
    readonly index?: never;
};

// @beta
export interface ChangesetProps {
    briefcaseId: number;
    changesType: ChangesetType;
    description: string;
    id: ChangesetId;
    index: ChangesetIndex;
    parentId: ChangesetId;
    pushDate: string;
    size?: number;
    userCreated: string;
}

// @public
export interface ChangesetRange {
    end?: ChangesetIndex;
    first: ChangesetIndex;
}

export { ChangeSetStatus }

// @public
export enum ChangesetType {
    Regular = 0,
    Schema = 1
}

// @alpha
export class ChannelConstraintError extends IModelError {
    constructor(message: string, getMetaData?: GetMetaDataFunction);
}

// @public
export interface ChannelRootAspectProps extends ElementAspectProps {
    owner: string;
}

// @internal
export interface ClassifierTileTreeId {
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    expansion: number;
    // (undocumented)
    type: BatchType.VolumeClassifier | BatchType.PlanarClassifier;
}

// @public
export class ClipStyle {
    static create(produceCutGeometry: boolean, cutStyle: CutStyle, insideColor?: RgbColor, outsideColor?: RgbColor): ClipStyle;
    readonly cutStyle: CutStyle;
    static readonly defaults: ClipStyle;
    // (undocumented)
    static fromJSON(props?: ClipStyleProps): ClipStyle;
    readonly insideColor?: RgbColor;
    get matchesDefaults(): boolean;
    readonly outsideColor?: RgbColor;
    readonly produceCutGeometry: boolean;
    toJSON(): ClipStyleProps | undefined;
}

// @public
export interface ClipStyleProps {
    cutStyle?: CutStyleProps;
    insideColor?: RgbColorProps;
    outsideColor?: RgbColorProps;
    produceCutGeometry?: boolean;
}

// @beta
export interface CloudContainerUri {
    // (undocumented)
    readonly uriParams: string;
}

// @beta (undocumented)
export abstract class CloudStorageCache<TContentId, TContentType> {
    constructor();
    // (undocumented)
    protected formContainerKey(id: TContentId): string;
    // (undocumented)
    abstract formContainerName(id: TContentId): string;
    // (undocumented)
    abstract formResourceName(id: TContentId): string;
    // (undocumented)
    protected getContainer(id: TContentId): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    protected abstract instantiateResource(response: Response): Promise<TContentType | undefined>;
    // (undocumented)
    protected abstract obtainContainerUrl(id: TContentId, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    provider: CloudStorageProvider;
    // (undocumented)
    protected requestResource(container: CloudStorageContainerUrl, id: TContentId): Promise<Response>;
    // (undocumented)
    retrieve(id: TContentId): Promise<TContentType | undefined>;
    // (undocumented)
    protected supplyUrlBase(_container: CloudStorageContainerUrl, _id: TContentId): string | undefined;
}

// @beta (undocumented)
export interface CloudStorageContainerDescriptor {
    // (undocumented)
    name: string;
    // (undocumented)
    provider?: CloudStorageProvider;
    // (undocumented)
    resource?: string;
}

// @beta (undocumented)
export interface CloudStorageContainerUrl {
    // (undocumented)
    bound?: boolean;
    // (undocumented)
    descriptor: CloudStorageContainerDescriptor;
    // (undocumented)
    expires: number;
    // (undocumented)
    headers?: Record<string, string>;
    // (undocumented)
    method?: string;
    // (undocumented)
    url: string;
    // (undocumented)
    valid: number;
}

// @beta (undocumented)
export namespace CloudStorageContainerUrl {
    // (undocumented)
    export function empty(): CloudStorageContainerUrl;
}

// @beta (undocumented)
export enum CloudStorageProvider {
    // (undocumented)
    AliCloud = 2,
    // (undocumented)
    Amazon = 1,
    // (undocumented)
    Azure = 0,
    // (undocumented)
    External = 3,
    // (undocumented)
    Unknown = 4
}

// @beta (undocumented)
export class CloudStorageTileCache extends CloudStorageCache<TileContentIdentifier, Uint8Array> {
    protected constructor();
    // (undocumented)
    protected formContainerKey(id: TileContentIdentifier): string;
    // (undocumented)
    formContainerName(id: TileContentIdentifier): string;
    // (undocumented)
    formResourceName(id: TileContentIdentifier): string;
    // (undocumented)
    static getCache(): CloudStorageTileCache;
    // (undocumented)
    protected instantiateResource(response: Response): Promise<Uint8Array | undefined>;
    // (undocumented)
    protected obtainContainerUrl(id: TileContentIdentifier, descriptor: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    // (undocumented)
    supplyExpiryForContainerUrl(_id: CloudStorageContainerDescriptor): Date;
}

// @public
export class Code implements CodeProps {
    constructor(codeProps: CodeProps);
    static createEmpty(): Code;
    // @internal (undocumented)
    static equalCodes(c1: CodeProps, c2: CodeProps): boolean;
    // (undocumented)
    equals(other: Code): boolean;
    // (undocumented)
    static fromJSON(json?: any): Code;
    static isEmpty(c: CodeProps): boolean;
    static isValid(c: CodeProps): boolean;
    scope: Id64String;
    spec: Id64String;
    // (undocumented)
    toJSON(): CodeProps;
    get value(): string;
    set value(val: string);
}

// @public
export interface CodeProps {
    scope: CodeScopeProps;
    spec: Id64String | string;
    value?: string;
}

// @public
export type CodeScopeProps = Id64String | GuidString;

// @public
export namespace CodeScopeSpec {
    export enum ScopeRequirement {
        ElementId = 1,
        FederationGuid = 2
    }
    export enum Type {
        Model = 2,
        ParentElement = 3,
        RelatedElement = 4,
        Repository = 1
    }
}

// @public
export class CodeSpec {
    static create(iModel: IModel, name: string, scopeType: CodeScopeSpec.Type, scopeReq?: CodeScopeSpec.ScopeRequirement): CodeSpec;
    // @internal
    static createFromJson(iModel: IModel, id: Id64String, name: string, properties: any): CodeSpec;
    id: Id64String;
    iModel: IModel;
    // @beta
    get isManagedWithIModel(): boolean;
    set isManagedWithIModel(value: boolean);
    get isValid(): boolean;
    name: string;
    // @internal
    properties: any;
    get scopeReq(): CodeScopeSpec.ScopeRequirement;
    set scopeReq(req: CodeScopeSpec.ScopeRequirement);
    get scopeType(): CodeScopeSpec.Type;
    set scopeType(scopeType: CodeScopeSpec.Type);
}

// @public
export const ColorByName: {
    aliceBlue: number;
    amber: number;
    antiqueWhite: number;
    aqua: number;
    aquamarine: number;
    azure: number;
    beige: number;
    bisque: number;
    black: number;
    blanchedAlmond: number;
    blue: number;
    blueViolet: number;
    brown: number;
    burlyWood: number;
    cadetBlue: number;
    chartreuse: number;
    chocolate: number;
    coral: number;
    cornflowerBlue: number;
    cornSilk: number;
    crimson: number;
    cyan: number;
    darkBlue: number;
    darkBrown: number;
    darkCyan: number;
    darkGoldenrod: number;
    darkGray: number;
    darkGreen: number;
    darkGrey: number;
    darkKhaki: number;
    darkMagenta: number;
    darkOliveGreen: number;
    darkOrange: number;
    darkOrchid: number;
    darkRed: number;
    darkSalmon: number;
    darkSeagreen: number;
    darkSlateBlue: number;
    darkSlateGray: number;
    darkSlateGrey: number;
    darkTurquoise: number;
    darkViolet: number;
    deepPink: number;
    deepSkyBlue: number;
    dimGray: number;
    dimGrey: number;
    dodgerBlue: number;
    fireBrick: number;
    floralWhite: number;
    forestGreen: number;
    fuchsia: number;
    gainsboro: number;
    ghostWhite: number;
    gold: number;
    goldenrod: number;
    gray: number;
    green: number;
    greenYellow: number;
    grey: number;
    honeydew: number;
    hotPink: number;
    indianRed: number;
    indigo: number;
    ivory: number;
    khaki: number;
    lavender: number;
    lavenderBlush: number;
    lawnGreen: number;
    lemonChiffon: number;
    lightBlue: number;
    lightCoral: number;
    lightCyan: number;
    lightGoldenrodYellow: number;
    lightGray: number;
    lightGreen: number;
    lightGrey: number;
    lightPink: number;
    lightSalmon: number;
    lightSeagreen: number;
    lightSkyBlue: number;
    lightSlateGray: number;
    lightSlateGrey: number;
    lightSteelBlue: number;
    lightyellow: number;
    lime: number;
    limeGreen: number;
    linen: number;
    magenta: number;
    maroon: number;
    mediumAquamarine: number;
    mediumBlue: number;
    mediumOrchid: number;
    mediumPurple: number;
    mediumSeaGreen: number;
    mediumSlateBlue: number;
    mediumSpringGreen: number;
    mediumTurquoise: number;
    mediumVioletRed: number;
    midnightBlue: number;
    mintCream: number;
    mistyRose: number;
    moccasin: number;
    navajoWhite: number;
    navy: number;
    oldLace: number;
    olive: number;
    oliveDrab: number;
    orange: number;
    orangeRed: number;
    orchid: number;
    paleGoldenrod: number;
    paleGreen: number;
    paleTurquoise: number;
    paleVioletRed: number;
    papayaWhip: number;
    peachPuff: number;
    peru: number;
    pink: number;
    plum: number;
    powderBlue: number;
    purple: number;
    rebeccaPurple: number;
    red: number;
    rosyBrown: number;
    royalBlue: number;
    saddleBrown: number;
    salmon: number;
    sandyBrown: number;
    seaGreen: number;
    seaShell: number;
    sienna: number;
    silver: number;
    skyBlue: number;
    slateBlue: number;
    slateGray: number;
    slateGrey: number;
    snow: number;
    springGreen: number;
    steelBlue: number;
    tan: number;
    teal: number;
    thistle: number;
    tomato: number;
    turquoise: number;
    violet: number;
    wheat: number;
    white: number;
    whiteSmoke: number;
    yellow: number;
    yellowGreen: number;
};

// @public
export class ColorDef {
    adjustedForContrast(other: ColorDef, alpha?: number): ColorDef;
    static readonly black: ColorDef;
    static readonly blue: ColorDef;
    get colors(): {
        r: number;
        g: number;
        b: number;
        t: number;
    };
    // @internal (undocumented)
    static computeTbgr(val?: string | ColorDefProps): ColorDefProps;
    static computeTbgrFromComponents(red: number, green: number, blue: number, transparency?: number): ColorDefProps;
    static computeTbgrFromHSL(h: number, s: number, l: number, transparency?: number): ColorDefProps;
    static computeTbgrFromString(val: string): ColorDefProps;
    static create(val?: string | ColorDefProps): ColorDef;
    equals(other: ColorDef): boolean;
    static from(red: number, green: number, blue: number, transparency?: number): ColorDef;
    static fromAbgr(abgr: number): ColorDef;
    static fromHSL(h: number, s: number, l: number, transparency?: number): ColorDef;
    static fromHSV(hsv: HSVColor, transparency?: number): ColorDef;
    static fromJSON(json?: ColorDefProps): ColorDef;
    static fromString(val: string): ColorDef;
    static fromTbgr(tbgr: ColorDefProps): ColorDef;
    getAbgr(): number;
    static getAbgr(tbgr: ColorDefProps): number;
    getAlpha(): number;
    static getAlpha(tbgr: ColorDefProps): number;
    static getColors(tbgr: ColorDefProps): {
        b: number;
        g: number;
        r: number;
        t: number;
    };
    static getName(tbgr: ColorDefProps): string | undefined;
    getRgb(): number;
    static getRgb(tbgr: ColorDefProps): number;
    getTransparency(): number;
    static getTransparency(tbgr: ColorDefProps): number;
    static readonly green: ColorDef;
    inverse(): ColorDef;
    static inverse(tbgr: ColorDefProps): ColorDefProps;
    get isOpaque(): boolean;
    static isOpaque(tbgr: ColorDefProps): boolean;
    static isValidColor(val: string | number): boolean;
    lerp(color2: ColorDef, weight: number): ColorDef;
    static lerp(tbgr1: ColorDefProps, tbgr2: ColorDefProps, weight: number): ColorDefProps;
    get name(): string | undefined;
    static readonly red: ColorDef;
    get tbgr(): ColorDefProps;
    toHexString(): string;
    static toHexString(tbgr: ColorDefProps): string;
    toHSL(): HSLColor;
    toHSV(): HSVColor;
    toJSON(): ColorDefProps;
    toRgbaString(): string;
    static toRgbaString(tbgr: ColorDefProps): string;
    toRgbString(): string;
    static toRgbString(tbgr: ColorDefProps): string;
    static tryComputeTbgrFromString(val: string): ColorDefProps | undefined;
    static readonly white: ColorDef;
    withAlpha(alpha: number): ColorDef;
    static withAlpha(tbgr: ColorDefProps, alpha: number): number;
    withTransparency(transparency: number): ColorDef;
    static withTransparency(tbgr: ColorDefProps, transparency: number): ColorDefProps;
}

// @public
export type ColorDefProps = number;

// @internal (undocumented)
export class ColorIndex {
    constructor();
    // (undocumented)
    get hasAlpha(): boolean;
    // (undocumented)
    initNonUniform(colors: Uint32Array, indices: number[], hasAlpha: boolean): void;
    // (undocumented)
    initUniform(color: ColorDef | number): void;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    get nonUniform(): NonUniformColor | undefined;
    // (undocumented)
    get numColors(): number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    get uniform(): ColorDef | undefined;
}

// @public
export enum CommonLoggerCategory {
    ElementProps = "core-common.ElementProps",
    Geometry = "core-common.Geometry",
    RpcInterfaceBackend = "core-backend.RpcInterface",
    RpcInterfaceFrontend = "core-frontend.RpcInterface"
}

// @public
export interface CommonMapLayerProps {
    name: string;
    transparency?: number;
    transparentBackground?: boolean;
    visible?: boolean;
}

// @internal
export function compareIModelTileTreeIds(lhs: IModelTileTreeId, rhs: IModelTileTreeId): number;

// @internal
export class CompositeTileHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly tileCount: number;
    // (undocumented)
    readonly tilePosition: number;
}

// @internal
export function computeChildTileProps(parent: TileMetadata, idProvider: ContentIdProvider, root: TileTreeMetadata): {
    children: TileProps[];
    numEmpty: number;
};

// @internal
export function computeChildTileRanges(tile: TileMetadata, root: TileTreeMetadata): Array<{
    range: Range3d;
    isEmpty: boolean;
}>;

// @alpha (undocumented)
export type ComputeNodeId = (elementId: Id64.Uint32Pair, featureIndex: number) => number;

// @internal
export function computeTileChordTolerance(tile: TileMetadata, is3d: boolean, tileScreenSize: number): number;

// @alpha
export enum ContentFlags {
    // (undocumented)
    AllowInstancing = 1,
    // (undocumented)
    ExternalTextures = 8,
    // (undocumented)
    IgnoreAreaPatterns = 4,
    // (undocumented)
    ImprovedElision = 2,
    // (undocumented)
    None = 0
}

// @internal
export abstract class ContentIdProvider {
    protected constructor(formatVersion: number, contentFlags: ContentFlags);
    // (undocumented)
    protected abstract computeId(depth: number, i: number, j: number, k: number, mult: number): string;
    // (undocumented)
    readonly contentFlags: ContentFlags;
    static create(allowInstancing: boolean, options: TileOptions, formatVersion?: number): ContentIdProvider;
    // (undocumented)
    idFromParentAndMultiplier(parentId: string, multiplier: number): string;
    // (undocumented)
    idFromSpec(spec: ContentIdSpec): string;
    // (undocumented)
    protected join(depth: number, i: number, j: number, k: number, mult: number): string;
    // (undocumented)
    readonly majorFormatVersion: number;
    // (undocumented)
    get rootContentId(): string;
    // (undocumented)
    protected abstract get _separator(): string;
    // (undocumented)
    specFromId(id: string): ContentIdSpec;
}

// @public
export class ContextRealityModel {
    constructor(props: ContextRealityModelProps);
    get appearanceOverrides(): FeatureAppearance | undefined;
    set appearanceOverrides(overrides: FeatureAppearance | undefined);
    // (undocumented)
    protected _appearanceOverrides?: FeatureAppearance;
    readonly classifiers?: SpatialClassifiers;
    readonly description: string;
    matchesNameAndUrl(name: string, url: string): boolean;
    readonly name: string;
    readonly onAppearanceOverridesChanged: BeEvent<(newOverrides: FeatureAppearance | undefined, model: ContextRealityModel) => void>;
    readonly onPlanarClipMaskChanged: BeEvent<(newSettings: PlanarClipMaskSettings | undefined, model: ContextRealityModel) => void>;
    // @alpha (undocumented)
    readonly orbitGtBlob?: Readonly<OrbitGtBlobProps>;
    // (undocumented)
    protected _planarClipMask?: PlanarClipMaskSettings;
    get planarClipMaskSettings(): PlanarClipMaskSettings | undefined;
    set planarClipMaskSettings(settings: PlanarClipMaskSettings | undefined);
    // @internal (undocumented)
    protected readonly _props: ContextRealityModelProps;
    // @beta
    readonly rdSourceKey?: RealityDataSourceKey;
    readonly realityDataId?: string;
    toJSON(): ContextRealityModelProps;
    readonly url: string;
}

// @public
export interface ContextRealityModelProps {
    appearanceOverrides?: FeatureAppearanceProps;
    classifiers?: SpatialClassifierProps[];
    description?: string;
    name?: string;
    // @alpha
    orbitGtBlob?: OrbitGtBlobProps;
    planarClipMask?: PlanarClipMaskProps;
    // @beta
    rdSourceKey?: RealityDataSourceKey;
    realityDataId?: string;
    tilesetUrl: string;
}

// @public (undocumented)
export namespace ContextRealityModelProps {
    export function clone(input: ContextRealityModelProps): ContextRealityModelProps;
}

// @public
export class ContextRealityModels {
    constructor(container: ContextRealityModelsContainer, createContextRealityModel?: (props: ContextRealityModelProps) => ContextRealityModel);
    add(props: ContextRealityModelProps): ContextRealityModel;
    clear(): void;
    delete(model: ContextRealityModel): boolean;
    get models(): ReadonlyArray<ContextRealityModel>;
    readonly onAppearanceOverridesChanged: BeEvent<(model: ContextRealityModel, newOverrides: FeatureAppearance | undefined) => void>;
    readonly onChanged: BeEvent<(previousModel: ContextRealityModel | undefined, newModel: ContextRealityModel | undefined) => void>;
    readonly onPlanarClipMaskChanged: BeEvent<(model: ContextRealityModel, newSettings: PlanarClipMaskSettings | undefined) => void>;
    replace(toReplace: ContextRealityModel, replaceWith: ContextRealityModelProps): ContextRealityModel;
    update(toUpdate: ContextRealityModel, updateProps: Partial<ContextRealityModelProps>): ContextRealityModel;
}

// @public
export interface ContextRealityModelsContainer {
    contextRealityModels?: ContextRealityModelProps[];
}

// @public
export type CreateEmptySnapshotIModelProps = CreateIModelProps & CreateSnapshotIModelProps;

// @internal
export type CreateEmptyStandaloneIModelProps = CreateIModelProps & CreateStandaloneIModelProps;

// @public
export interface CreateIModelProps extends IModelProps {
    readonly client?: string;
    readonly guid?: GuidString;
    // @alpha
    readonly thumbnail?: ThumbnailProps;
}

// @public
export interface CreateSnapshotIModelProps extends IModelEncryptionProps {
    readonly createClassViews?: boolean;
}

// @internal
export interface CreateStandaloneIModelProps extends IModelEncryptionProps {
    readonly allowEdit?: string;
}

// @internal (undocumented)
export const CURRENT_INVOCATION: unique symbol;

// @internal (undocumented)
export const CURRENT_REQUEST: unique symbol;

// @internal
export enum CurrentImdlVersion {
    Combined = 1900544,
    Major = 29,
    Minor = 0
}

// @beta
export interface CustomAttribute {
    ecclass: string;
    properties: {
        [propName: string]: any;
    };
}

// @internal
export interface CustomViewState3dCreatorOptions {
    // (undocumented)
    modelIds?: CompressedId64Set;
}

// @internal
export interface CustomViewState3dProps {
    // (undocumented)
    categoryIds: CompressedId64Set;
    // (undocumented)
    modelExtents: Range3dProps;
    // (undocumented)
    modelIds: CompressedId64Set;
}

// @public
export class CutStyle {
    readonly appearance?: FeatureAppearance;
    static create(viewflags?: Readonly<ViewFlagOverrides>, hiddenLine?: HiddenLine.Settings, appearance?: FeatureAppearance): CutStyle;
    static readonly defaults: CutStyle;
    // (undocumented)
    static fromJSON(props?: CutStyleProps): CutStyle;
    readonly hiddenLine?: HiddenLine.Settings;
    get matchesDefaults(): boolean;
    toJSON(): CutStyleProps | undefined;
    readonly viewflags: Readonly<ViewFlagOverrides>;
}

// @public
export interface CutStyleProps {
    appearance?: FeatureAppearanceProps;
    hiddenLine?: HiddenLine.SettingsProps;
    viewflags?: ViewFlagOverrides;
}

// @public
export type DanishSystem34Region = "Jylland" | "Sjaelland" | "Bornholm";

// @internal (undocumented)
export interface DbBlobRequest extends DbRequest, BlobOptions {
    // (undocumented)
    accessString: string;
    // (undocumented)
    className: string;
    // (undocumented)
    instanceId: Id64String;
}

// @internal (undocumented)
export interface DbBlobResponse extends DbResponse {
    // (undocumented)
    data?: Uint8Array;
    // (undocumented)
    rawBlobSize: number;
}

// @public (undocumented)
export class DbQueryError extends BentleyError {
    constructor(response: any, request?: any, rc?: DbResult);
    // (undocumented)
    readonly request?: any;
    // (undocumented)
    readonly response: any;
    // (undocumented)
    static throwIfError(response: any, request?: any): void;
}

// @internal (undocumented)
export interface DbQueryRequest extends DbRequest, QueryOptions {
    // (undocumented)
    args?: object;
    // (undocumented)
    query: string;
    // (undocumented)
    valueFormat?: DbValueFormat;
}

// @internal (undocumented)
export interface DbQueryResponse extends DbResponse {
    // (undocumented)
    data: any[];
    // (undocumented)
    meta: QueryPropertyMetaData[];
    // (undocumented)
    rowCount: number;
}

// @internal (undocumented)
export interface DbRequest extends BaseReaderOptions {
    // (undocumented)
    kind?: DbRequestKind;
}

// @internal (undocumented)
export interface DbRequestExecutor<TRequest extends DbRequest, TResponse extends DbResponse> {
    // (undocumented)
    execute(request: TRequest): Promise<TResponse>;
}

// @internal (undocumented)
export enum DbRequestKind {
    // (undocumented)
    BlobIO = 0,
    // (undocumented)
    ECSql = 1
}

// @internal (undocumented)
export interface DbResponse {
    // (undocumented)
    error?: string;
    // (undocumented)
    kind: DbResponseKind;
    // (undocumented)
    stats: DbRuntimeStats;
    // (undocumented)
    status: DbResponseStatus;
}

// @internal (undocumented)
export enum DbResponseKind {
    // (undocumented)
    BlobIO = 0,
    // (undocumented)
    ECSql = 1,
    // (undocumented)
    NoResult = 2
}

// @internal (undocumented)
export enum DbResponseStatus {
    // (undocumented)
    Cancel = 2,
    // (undocumented)
    Done = 1,
    // (undocumented)
    Error = 100,
    // (undocumented)
    Error_BlobIO_OpenFailed = 105,
    // (undocumented)
    Error_BlobIO_OutOfRange = 106,
    // (undocumented)
    Error_ECSql_BindingFailed = 104,
    // (undocumented)
    Error_ECSql_PreparedFailed = 101,
    // (undocumented)
    Error_ECSql_RowToJsonFailed = 103,
    // (undocumented)
    Error_ECSql_StepFailed = 102,
    // (undocumented)
    Partial = 3,
    // (undocumented)
    QueueFull = 5,
    // (undocumented)
    Timeout = 4
}

export { DbResult }

// @beta (undocumented)
export interface DbRuntimeStats {
    // (undocumented)
    cpuTime: number;
    // (undocumented)
    memLimit: number;
    // (undocumented)
    memUsed: number;
    // (undocumented)
    timeLimit: number;
    // (undocumented)
    totalTime: number;
}

// @internal (undocumented)
export enum DbValueFormat {
    // (undocumented)
    ECSqlNames = 0,
    // (undocumented)
    JsNames = 1
}

// @internal
export interface DecorationGeometryProps {
    // (undocumented)
    readonly geometryStream: GeometryStreamProps;
    // (undocumented)
    readonly id: Id64String;
}

// @beta
export enum DefaultSupportedTypes {
    // (undocumented)
    Cesium3dTiles = "Cesium3DTiles",
    // (undocumented)
    OMR = "OMR",
    // (undocumented)
    OPC = "OPC",
    // (undocumented)
    RealityMesh3dTiles = "RealityMesh3DTiles",
    // (undocumented)
    Terrain3dTiles = "Terrain3DTiles"
}

// @internal (undocumented)
export const defaultTileOptions: TileOptions;

// @public
export interface DefinitionElementProps extends ElementProps {
    // (undocumented)
    isPrivate?: boolean;
}

// @public
export interface DeletedElementGeometryChange {
    readonly id: Id64String;
    readonly type: DbOpcode.Delete;
}

// @public
export interface DeprecatedBackgroundMapProps {
    // @deprecated
    providerData?: {
        mapType?: BackgroundMapType;
    };
    // @deprecated
    providerName?: string;
}

// @internal
export abstract class DevToolsRpcInterface extends RpcInterface {
    static getClient(): DevToolsRpcInterface;
    static readonly interfaceName = "DevToolsRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    ping(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    setLogLevel(_iModelToken: IModelRpcProps, _loggerCategory: string, _logLevel: LogLevel): Promise<LogLevel | undefined>;
    // (undocumented)
    stats(_iModelToken: IModelRpcProps, _options: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(_iModelToken: IModelRpcProps): Promise<any>;
}

// @internal
export enum DevToolsStatsOptions {
    FormatUnits = 1,
    // (undocumented)
    None = 0
}

// @public
export interface DisplayStyle3dProps extends DisplayStyleProps {
    jsonProperties?: {
        styles?: DisplayStyle3dSettingsProps;
    };
}

// @public
export class DisplayStyle3dSettings extends DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyle3dSettingsProps;
    }, options?: DisplayStyleSettingsOptions);
    get ambientOcclusionSettings(): AmbientOcclusion.Settings;
    set ambientOcclusionSettings(ao: AmbientOcclusion.Settings);
    // @internal
    applyOverrides(overrides: DisplayStyle3dSettingsProps): void;
    clearSunTime(): void;
    get environment(): Environment;
    set environment(environment: Environment);
    getPlanProjectionSettings(modelId: Id64String): PlanProjectionSettings | undefined;
    get hiddenLineSettings(): HiddenLine.Settings;
    set hiddenLineSettings(hline: HiddenLine.Settings);
    // (undocumented)
    is3d(): this is DisplayStyle3dSettings;
    // (undocumented)
    get lights(): LightSettings;
    set lights(lights: LightSettings);
    get planProjectionSettings(): Iterable<[Id64String, PlanProjectionSettings]> | undefined;
    setPlanProjectionSettings(modelId: Id64String, settings: PlanProjectionSettings | undefined): void;
    setSunTime(timePoint: number, location: IModel | Cartographic): void;
    get solarShadows(): SolarShadowSettings;
    set solarShadows(solarShadows: SolarShadowSettings);
    get sunTime(): number | undefined;
    get thematic(): ThematicDisplay;
    set thematic(thematic: ThematicDisplay);
    toggleGroundPlane(display?: boolean): void;
    toggleSkyBox(display?: boolean): void;
    // @internal (undocumented)
    toJSON(): DisplayStyle3dSettingsProps;
    // @internal (undocumented)
    toOverrides(options?: DisplayStyleOverridesOptions): DisplayStyle3dSettingsProps;
}

// @public
export interface DisplayStyle3dSettingsProps extends DisplayStyleSettingsProps {
    ao?: AmbientOcclusion.Props;
    environment?: EnvironmentProps;
    hline?: HiddenLine.SettingsProps;
    lights?: LightSettingsProps;
    planProjections?: {
        [modelId: string]: PlanProjectionSettingsProps;
    };
    // @internal
    sceneLights?: {
        sunDir?: XYZProps;
    };
    solarShadows?: SolarShadowSettingsProps;
    thematic?: ThematicDisplayProps;
}

// @public
export interface DisplayStyleLoadProps {
    compressExcludedElementIds?: boolean;
    omitScheduleScriptElementIds?: boolean;
}

// @public
export interface DisplayStyleModelAppearanceProps extends FeatureAppearanceProps {
    modelId?: Id64String;
}

// @public
export interface DisplayStyleOverridesOptions {
    includeAll?: true;
    includeBackgroundMap?: true;
    includeDrawingAids?: true;
    includeIModelSpecific?: true;
    includeITwinSpecific?: true;
}

// @public
export interface DisplayStylePlanarClipMaskProps extends PlanarClipMaskProps {
    modelId?: Id64String;
}

// @public
export interface DisplayStyleProps extends DefinitionElementProps {
    jsonProperties?: {
        styles?: DisplayStyleSettingsProps;
    };
}

// @public
export class DisplayStyleSettings {
    constructor(jsonProperties: {
        styles?: DisplayStyleSettingsProps;
    }, options?: DisplayStyleSettingsOptions);
    addExcludedElements(id: Id64String | Iterable<Id64String>): void;
    get analysisFraction(): number;
    set analysisFraction(fraction: number);
    get analysisStyle(): AnalysisStyle | undefined;
    set analysisStyle(style: AnalysisStyle | undefined);
    applyOverrides(overrides: DisplayStyleSettingsProps): void;
    // @internal (undocumented)
    protected _applyOverrides(overrides: DisplayStyleSettingsProps): void;
    get backgroundColor(): ColorDef;
    set backgroundColor(color: ColorDef);
    get backgroundMap(): BackgroundMapSettings;
    set backgroundMap(map: BackgroundMapSettings);
    clearExcludedElements(): void;
    get clipStyle(): ClipStyle;
    set clipStyle(style: ClipStyle);
    // @internal (undocumented)
    get compressedExcludedElementIds(): CompressedId64Set;
    get contextRealityModels(): ContextRealityModels;
    dropExcludedElement(id: Id64String): void;
    dropExcludedElements(id: Id64String | Iterable<Id64String>): void;
    dropModelAppearanceOverride(id: Id64String): void;
    dropSubCategoryOverride(id: Id64String): void;
    get excludedElementIds(): OrderedId64Iterable;
    getModelAppearanceOverride(id: Id64String): FeatureAppearance | undefined;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    get hasModelAppearanceOverride(): boolean;
    get hasSubCategoryOverride(): boolean;
    is3d(): this is DisplayStyle3dSettings;
    // (undocumented)
    protected readonly _json: DisplayStyleSettingsProps;
    // @beta
    get mapImagery(): MapImagerySettings;
    set mapImagery(mapImagery: MapImagerySettings);
    get modelAppearanceOverrides(): Map<Id64String, FeatureAppearance>;
    get monochromeColor(): ColorDef;
    set monochromeColor(color: ColorDef);
    get monochromeMode(): MonochromeMode;
    set monochromeMode(mode: MonochromeMode);
    readonly onAmbientOcclusionSettingsChanged: BeEvent<(newSettings: AmbientOcclusion.Settings) => void>;
    readonly onAnalysisFractionChanged: BeEvent<(newFraction: number) => void>;
    readonly onAnalysisStyleChanged: BeEvent<(newStyle: Readonly<AnalysisStyle> | undefined) => void>;
    readonly onApplyOverrides: BeEvent<(overrides: Readonly<DisplayStyleSettingsProps>) => void>;
    readonly onBackgroundColorChanged: BeEvent<(newColor: ColorDef) => void>;
    readonly onBackgroundMapChanged: BeEvent<(newMap: BackgroundMapSettings) => void>;
    readonly onClipStyleChanged: BeEvent<(newStyle: ClipStyle) => void>;
    readonly onEnvironmentChanged: BeEvent<(newEnv: Readonly<Environment>) => void>;
    readonly onExcludedElementsChanged: BeEvent<() => void>;
    readonly onHiddenLineSettingsChanged: BeEvent<(newSettings: HiddenLine.Settings) => void>;
    readonly onLightsChanged: BeEvent<(newLights: LightSettings) => void>;
    // @beta
    readonly onMapImageryChanged: BeEvent<(newImagery: Readonly<MapImagerySettings>) => void>;
    readonly onModelAppearanceOverrideChanged: BeEvent<(modelId: Id64String, newAppearance: FeatureAppearance | undefined) => void>;
    readonly onMonochromeColorChanged: BeEvent<(newColor: ColorDef) => void>;
    readonly onMonochromeModeChanged: BeEvent<(newMode: MonochromeMode) => void>;
    readonly onOverridesApplied: BeEvent<(overrides: Readonly<DisplayStyleSettingsProps>) => void>;
    readonly onPlanarClipMaskChanged: BeEvent<(modelId: Id64String, newSettings: PlanarClipMaskSettings | undefined) => void>;
    readonly onPlanProjectionSettingsChanged: BeEvent<(modelId: Id64String, newSettings: PlanProjectionSettings | undefined) => void>;
    readonly onRenderTimelineChanged: BeEvent<(newRenderTimeline: Id64String | undefined) => void>;
    readonly onScheduleScriptPropsChanged: BeEvent<(newProps: Readonly<RenderSchedule.ScriptProps> | undefined) => void>;
    readonly onSolarShadowsChanged: BeEvent<(newSettings: SolarShadowSettings) => void>;
    readonly onSubCategoryOverridesChanged: BeEvent<(subCategoryId: Id64String, newOverrides: SubCategoryOverride | undefined) => void>;
    readonly onThematicChanged: BeEvent<(newThematic: ThematicDisplay) => void>;
    readonly onTimePointChanged: BeEvent<(newTimePoint: number | undefined) => void>;
    readonly onViewFlagsChanged: BeEvent<(newFlags: Readonly<ViewFlags>) => void>;
    readonly onWhiteOnWhiteReversalChanged: BeEvent<(newSettings: WhiteOnWhiteReversalSettings) => void>;
    overrideModelAppearance(modelId: Id64String, ovr: FeatureAppearance): void;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    get planarClipMasks(): Map<Id64String, PlanarClipMaskSettings>;
    get renderTimeline(): Id64String | undefined;
    set renderTimeline(id: Id64String | undefined);
    get scheduleScriptProps(): RenderSchedule.ScriptProps | undefined;
    set scheduleScriptProps(props: RenderSchedule.ScriptProps | undefined);
    get subCategoryOverrides(): Map<Id64String, SubCategoryOverride>;
    // @internal
    synchMapImagery(): void;
    get timePoint(): number | undefined;
    set timePoint(timePoint: number | undefined);
    // @internal (undocumented)
    toJSON(): DisplayStyleSettingsProps;
    toOverrides(options?: DisplayStyleOverridesOptions): DisplayStyleSettingsProps;
    get viewFlags(): ViewFlags;
    set viewFlags(flags: ViewFlags);
    get whiteOnWhiteReversal(): WhiteOnWhiteReversalSettings;
    set whiteOnWhiteReversal(settings: WhiteOnWhiteReversalSettings);
}

// @public
export interface DisplayStyleSettingsOptions {
    createContextRealityModel?: (props: ContextRealityModelProps) => ContextRealityModel;
}

// @public
export interface DisplayStyleSettingsProps {
    analysisFraction?: number;
    analysisStyle?: AnalysisStyleProps;
    backgroundColor?: ColorDefProps;
    backgroundMap?: PersistentBackgroundMapProps;
    clipStyle?: ClipStyleProps;
    contextRealityModels?: ContextRealityModelProps[];
    excludedElements?: Id64Array | CompressedId64Set;
    // @beta
    mapImagery?: MapImageryProps;
    modelOvr?: DisplayStyleModelAppearanceProps[];
    monochromeColor?: ColorDefProps;
    monochromeMode?: MonochromeMode;
    planarClipOvr?: DisplayStylePlanarClipMaskProps[];
    renderTimeline?: Id64String;
    scheduleScript?: RenderSchedule.ScriptProps;
    subCategoryOvr?: DisplayStyleSubCategoryProps[];
    timePoint?: number;
    viewflags?: ViewFlagProps;
    whiteOnWhiteReversal?: WhiteOnWhiteReversalProps;
}

// @public
export interface DisplayStyleSubCategoryProps extends SubCategoryAppearance.Props {
    subCategory?: Id64String;
}

// @beta
export enum DomainOptions {
    CheckRecommendedUpgrades = 1,
    CheckRequiredUpgrades = 0,
    SkipCheck = 3,
    Upgrade = 2
}

// @public
export interface DynamicGraphicsRequest2dProps extends DynamicGraphicsRequestProps {
    readonly placement: Omit<Placement2dProps, "bbox">;
    readonly type: "2d";
}

// @public
export interface DynamicGraphicsRequest3dProps extends DynamicGraphicsRequestProps {
    readonly placement: Omit<Placement3dProps, "bbox">;
    readonly type: "3d";
}

// @public
export interface DynamicGraphicsRequestProps extends GraphicsRequestProps {
    readonly categoryId: Id64String;
    readonly elementId?: Id64String;
    readonly geometry: JsonGeometryStream | FlatBufferGeometryStream;
    readonly modelId?: Id64String;
}

// @public
export const Easing: {
    Linear: {
        None: (k: number) => number;
    };
    Quadratic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Cubic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quartic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Quintic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Sinusoidal: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Exponential: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Circular: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Elastic: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Back: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
    Bounce: {
        In: (k: number) => number;
        Out: (k: number) => number;
        InOut: (k: number) => number;
    };
};

// @public (undocumented)
export type EasingFunction = (k: number) => number;

// @public
export class EcefLocation implements EcefLocationProps {
    constructor(props: EcefLocationProps);
    readonly cartographicOrigin?: Cartographic;
    static createFromCartographicOrigin(origin: Cartographic, point?: Point3d, angle?: Angle): EcefLocation;
    get earthCenter(): Point3d;
    getTransform(): Transform;
    isAlmostEqual(other: EcefLocation): boolean;
    readonly orientation: YawPitchRollAngles;
    readonly origin: Point3d;
    // (undocumented)
    toJSON(): EcefLocationProps;
    readonly xVector?: Vector3d;
    readonly yVector?: Vector3d;
}

// @public
export interface EcefLocationProps {
    readonly cartographicOrigin?: CartographicProps;
    readonly orientation: YawPitchRollProps;
    readonly origin: XYZProps;
    readonly xVector?: XYZProps;
    readonly yVector?: XYZProps;
}

// @public
export class ECJsNames {
    static systemPropertyToJsName(systemPropertyType: ECSqlSystemProperty): string;
    static toJsName(propName: string, isSystemProperty?: boolean): string;
}

// @public (undocumented)
export interface ECSchemaItemProps {
    // (undocumented)
    readonly $schema?: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name?: string;
    // (undocumented)
    readonly schema?: string;
    // (undocumented)
    readonly schemaItemType?: string;
    // (undocumented)
    readonly schemaVersion?: string;
}

// @public
export interface ECSchemaProps {
    // (undocumented)
    readonly $schema: string;
    // (undocumented)
    readonly alias: string;
    // (undocumented)
    readonly customAttributes?: Array<{
        [value: string]: any;
    }>;
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly items?: {
        [name: string]: ECSchemaItemProps;
    };
    // (undocumented)
    readonly label?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly references?: ECSchemaReferenceProps[];
    // (undocumented)
    readonly version: string;
}

// @public (undocumented)
export interface ECSchemaReferenceProps {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly version: string;
}

// @beta (undocumented)
export class ECSqlReader {
    // @internal
    constructor(_executor: DbRequestExecutor<DbQueryRequest, DbQueryResponse>, query: string, param?: QueryBinder, options?: QueryOptions);
    // (undocumented)
    get current(): QueryRowProxy;
    // (undocumented)
    get done(): boolean;
    // (undocumented)
    formatCurrentRow(onlyReturnObject?: boolean): any[] | object;
    // (undocumented)
    getMetaData(): Promise<QueryPropertyMetaData[]>;
    // (undocumented)
    getRowInternal(): any[];
    // (undocumented)
    readonly query: string;
    // (undocumented)
    reset(options?: QueryOptions): void;
    // (undocumented)
    resetBindings(): void;
    // (undocumented)
    setParams(param: QueryBinder): void;
    // (undocumented)
    get stats(): QueryStats;
    // (undocumented)
    step(): Promise<boolean>;
    // (undocumented)
    toArray(): Promise<any[]>;
}

// @public
export enum ECSqlSystemProperty {
    // (undocumented)
    ECClassId = 1,
    // (undocumented)
    ECInstanceId = 0,
    // (undocumented)
    NavigationId = 6,
    // (undocumented)
    NavigationRelClassId = 7,
    // (undocumented)
    PointX = 8,
    // (undocumented)
    PointY = 9,
    // (undocumented)
    PointZ = 10,
    // (undocumented)
    SourceECClassId = 3,
    // (undocumented)
    SourceECInstanceId = 2,
    // (undocumented)
    TargetECClassId = 5,
    // (undocumented)
    TargetECInstanceId = 4
}

// @public
export enum ECSqlValueType {
    // (undocumented)
    Blob = 1,
    // (undocumented)
    Boolean = 2,
    // (undocumented)
    DateTime = 3,
    // (undocumented)
    Double = 4,
    // (undocumented)
    Geometry = 5,
    // (undocumented)
    Guid = 16,
    // (undocumented)
    Id = 6,
    // (undocumented)
    Int = 7,
    // (undocumented)
    Int64 = 8,
    // (undocumented)
    Navigation = 12,
    // (undocumented)
    Point2d = 9,
    // (undocumented)
    Point3d = 10,
    // (undocumented)
    PrimitiveArray = 14,
    // (undocumented)
    String = 11,
    // (undocumented)
    Struct = 13,
    // (undocumented)
    StructArray = 15
}

// @internal (undocumented)
export class EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    edges?: MeshEdge[];
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get numEdges(): number;
}

// @internal
export interface EdgeOptions {
    indexed: boolean;
    smooth: boolean;
}

// @internal
export interface EditingScopeNotifications {
    // (undocumented)
    notifyGeometryChanged: (modelProps: ModelGeometryChangesProps[]) => void;
}

// @public
export type ElementAlignedBox2d = Range2d;

// @public
export type ElementAlignedBox3d = Range3d;

// @public
export interface ElementAspectProps extends EntityProps {
    // (undocumented)
    element: RelatedElementProps;
}

// @alpha
export namespace ElementGeometry {
    export function appendGeometryParams(geomParams: GeometryParams, entries: ElementGeometryDataEntry[], worldToLocal?: Transform): boolean;
    export class Builder {
        appendBRepData(brep: BRepEntity.DataProps): boolean;
        appendGeometryParamsChange(geomParams: GeometryParams): boolean;
        appendGeometryPart(partId: Id64String, partTransform?: Transform): boolean;
        appendGeometryPart2d(partId: Id64String, instanceOrigin?: Point2d, instanceRotation?: Angle, instanceScale?: number): boolean;
        appendGeometryPart3d(partId: Id64String, instanceOrigin?: Point3d, instanceRotation?: YawPitchRollAngles, instanceScale?: number): boolean;
        appendGeometryQuery(geometry: GeometryQuery): boolean;
        appendGeometryRanges(): boolean;
        appendImageGraphic(image: ImageGraphic): boolean;
        appendTextString(text: TextString): boolean;
        readonly entries: ElementGeometryDataEntry[];
        get localToWorld(): Transform | undefined;
        static placementAngleFromPoints(pts: Point3d[], result?: Angle): Angle;
        static placementAnglesFromPoints(pts: Point3d[], defaultUp?: Vector3d, result?: YawPitchRollAngles): YawPitchRollAngles;
        setLocalToWorld(localToWorld?: Transform): void;
        setLocalToWorld2d(origin: Point2d, angle?: Angle): void;
        setLocalToWorld3d(origin: Point3d, angles?: YawPitchRollAngles): void;
        setLocalToWorldFromPlacement(props: PlacementProps): void;
        get worldToLocal(): Transform | undefined;
    }
    export function fromBRep(brep: BRepEntity.DataProps, worldToLocal?: Transform): ElementGeometryDataEntry | undefined;
    export function fromGeometryPart(partId: Id64String, partTransform?: Transform, worldToLocal?: Transform): ElementGeometryDataEntry | undefined;
    export function fromGeometryQuery(geom: GeometryQuery, worldToLocal?: Transform): ElementGeometryDataEntry | undefined;
    export function fromImageGraphic(image: ImageGraphicProps, worldToLocal?: Transform): ElementGeometryDataEntry | undefined;
    export function fromSubGraphicRange(bbox: ElementAlignedBox3d): ElementGeometryDataEntry | undefined;
    export function fromTextString(text: TextStringProps, worldToLocal?: Transform): ElementGeometryDataEntry | undefined;
    export function getBRepEntityType(entry: ElementGeometryDataEntry): BRepEntity.Type | undefined;
    export function isAppearanceEntry(entry: ElementGeometryDataEntry): boolean;
    export function isCurve(entry: ElementGeometryDataEntry): boolean;
    export function isDisplayableEntry(entry: ElementGeometryDataEntry): boolean;
    export function isGeometricEntry(entry: ElementGeometryDataEntry): boolean;
    export function isGeometryQueryEntry(entry: ElementGeometryDataEntry): boolean;
    export function isSolid(entry: ElementGeometryDataEntry): boolean;
    export function isSurface(entry: ElementGeometryDataEntry): boolean;
    export class Iterator implements IterableIterator<IteratorEntry> {
        // (undocumented)
        [Symbol.iterator](): IterableIterator<IteratorEntry>;
        constructor(info: ElementGeometryInfo, categoryOrGeometryParams?: Id64String | GeometryParams, localToWorld?: Transform);
        readonly brepsPresent?: boolean;
        readonly entryArray: ElementGeometryDataEntry[];
        next(): IteratorResult<IteratorEntry>;
        readonly placement: Placement3d;
        requestWorldCoordinates(): void;
        readonly viewIndependent?: boolean;
    }
    export interface IteratorData {
        readonly geomParams: GeometryParams;
        readonly localRange?: Range3d;
        readonly localToWorld?: Transform;
        readonly value: ElementGeometryDataEntry;
    }
    // (undocumented)
    export class IteratorEntry implements IteratorData {
        constructor(geomParams: GeometryParams, localToWorld: Transform, applyLocalToWorld?: boolean);
        // (undocumented)
        readonly geomParams: GeometryParams;
        // (undocumented)
        localRange?: Range3d;
        // (undocumented)
        readonly localToWorld?: Transform;
        // (undocumented)
        get outputTransform(): Transform | undefined;
        toBRepData(wantBRepData?: boolean): BRepEntity.DataProps | undefined;
        toGeometryPart(partToLocal?: Transform, partToWorld?: Transform): Id64String | undefined;
        toGeometryQuery(): GeometryQuery | undefined;
        toImageGraphic(): ImageGraphic | undefined;
        toTextString(): TextString | undefined;
        // (undocumented)
        get value(): ElementGeometryDataEntry;
        set value(value: ElementGeometryDataEntry);
    }
    export function toBRep(entry: ElementGeometryDataEntry, wantBRepData?: boolean, localToWorld?: Transform): BRepEntity.DataProps | undefined;
    export function toElementAlignedBox3d(bbox: Float64Array): ElementAlignedBox3d | undefined;
    export function toGeometryPart(entry: ElementGeometryDataEntry, partToElement?: Transform): Id64String | undefined;
    export function toGeometryQuery(entry: ElementGeometryDataEntry, localToWorld?: Transform): GeometryQuery | undefined;
    export function toImageGraphic(entry: ElementGeometryDataEntry, localToWorld?: Transform): ImageGraphicProps | undefined;
    export function toSubGraphicRange(entry: ElementGeometryDataEntry): ElementAlignedBox3d | undefined;
    export function toTextString(entry: ElementGeometryDataEntry, localToWorld?: Transform): TextStringProps | undefined;
    export function toTransform(sourceToWorld: Float64Array): Transform | undefined;
    export function transformBRep(entry: ElementGeometryDataEntry, inputTransform: Transform): boolean;
    export function updateGeometryParams(entry: ElementGeometryDataEntry, geomParams: GeometryParams, localToWorld?: Transform): boolean;
}

// @alpha
export interface ElementGeometryBuilderParams {
    entryArray: ElementGeometryDataEntry[];
    viewIndependent?: boolean;
}

// @alpha
export interface ElementGeometryBuilderParamsForPart {
    entryArray: ElementGeometryDataEntry[];
    is2dPart?: boolean;
}

// @public (undocumented)
export type ElementGeometryChange = ExtantElementGeometryChange | DeletedElementGeometryChange;

// @public
export namespace ElementGeometryChange {
    export function iterable(modelChanges: ModelGeometryChangesProps): Iterable<ElementGeometryChange>;
    export function iterator(modelChanges: ModelGeometryChangesProps): Iterator<ElementGeometryChange>;
}

// @public
export interface ElementGeometryDataEntry {
    data: Uint8Array;
    opcode: ElementGeometryOpcode;
}

// @alpha
export type ElementGeometryFunction = (info: ElementGeometryInfo) => void;

// @alpha
export interface ElementGeometryInfo {
    bbox?: Float64Array;
    brepsPresent?: boolean;
    categoryId?: Id64String;
    entryArray: ElementGeometryDataEntry[];
    sourceToWorld?: Float64Array;
    viewIndependent?: boolean;
}

// @public
export enum ElementGeometryOpcode {
    ArcPrimitive = 7,
    BasicSymbology = 4,
    BRep = 25,
    BsplineSurface = 12,
    CurveCollection = 8,
    CurvePrimitive = 10,
    Fill = 19,
    Image = 28,
    LineStyleModifiers = 23,
    Material = 21,
    PartReference = 3,
    Pattern = 20,
    PointPrimitive = 5,
    PointPrimitive2d = 6,
    Polyface = 9,
    SolidPrimitive = 11,
    SubGraphicRange = 2,
    TextString = 22
}

// @alpha
export interface ElementGeometryRequest {
    angleTol?: number;
    chordTol?: number;
    elementId: Id64String;
    maxEdgeLength?: number;
    minBRepFeatureSize?: number;
    onGeometry: ElementGeometryFunction;
    replaceBReps?: boolean;
    skipBReps?: boolean;
}

// @public
export type ElementGraphicsRequestProps = PersistentGraphicsRequestProps | DynamicGraphicsRequest2dProps | DynamicGraphicsRequest3dProps;

// @public
export interface ElementIdsAndRangesProps {
    readonly ids: CompressedId64Set;
    readonly ranges: Range3dProps[];
}

// @public
export interface ElementLoadOptions {
    displayStyle?: DisplayStyleLoadProps;
    onlyBaseProperties?: boolean;
    renderTimeline?: RenderTimelineLoadProps;
    wantBRepData?: boolean;
    wantGeometry?: boolean;
}

// @public
export interface ElementLoadProps extends ElementLoadOptions {
    code?: CodeProps;
    // (undocumented)
    federationGuid?: GuidString;
    // (undocumented)
    id?: Id64String;
}

// @public
export interface ElementPlanarClipMaskArgs extends BasicPlanarClipMaskArgs {
    elementIds: Iterable<Id64String>;
    exclude?: boolean;
    modelIds?: Iterable<Id64String>;
    // @internal (undocumented)
    priority?: never;
    // @internal (undocumented)
    subCategoryIds?: never;
}

// @public
export interface ElementProps extends EntityProps {
    code: CodeProps;
    federationGuid?: GuidString;
    jsonProperties?: any;
    model: Id64String;
    parent?: RelatedElementProps;
    userLabel?: string;
}

// @public
export interface EmphasizeElementsProps {
    alwaysDrawn?: Id64Array;
    alwaysDrawnExclusiveEmphasized?: Id64Array;
    appearanceOverride?: AppearanceOverrideProps[];
    defaultAppearance?: FeatureAppearanceProps;
    isAlwaysDrawnExclusive?: boolean;
    neverDrawn?: Id64Array;
    unanimatedAppearance?: FeatureAppearanceProps;
    wantEmphasis?: boolean;
}

// @public
export class EmptyLocalization implements Localization {
    // (undocumented)
    changeLanguage(): Promise<void>;
    // (undocumented)
    getEnglishString(_namespace: string, key: string | string[]): string;
    // (undocumented)
    getLanguageList(): readonly string[];
    // (undocumented)
    getLocalizedKeys(inputString: string): string;
    // (undocumented)
    getLocalizedString(key: string | string[]): string;
    // (undocumented)
    getLocalizedStringWithNamespace(_namespace: string, key: string | string[]): string;
    // (undocumented)
    getNamespacePromise(): Promise<void> | undefined;
    // (undocumented)
    initialize(): Promise<void>;
    // (undocumented)
    registerNamespace(): Promise<void>;
    // (undocumented)
    unregisterNamespace(): void;
}

// @public
export interface EntityIdAndClassId {
    classId: Id64String;
    id: Id64String;
}

// @public
export type EntityIdAndClassIdIterable = Iterable<Readonly<EntityIdAndClassId>>;

// @beta
export class EntityMetaData implements EntityMetaDataProps {
    constructor(jsonObj: EntityMetaDataProps);
    readonly baseClasses: string[];
    readonly customAttributes?: CustomAttribute[];
    // (undocumented)
    readonly description?: string;
    // (undocumented)
    readonly displayLabel?: string;
    readonly ecclass: string;
    // (undocumented)
    readonly modifier?: string;
    readonly properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @beta (undocumented)
export interface EntityMetaDataProps {
    baseClasses: string[];
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    ecclass: string;
    // (undocumented)
    modifier?: string;
    properties: {
        [propName: string]: PropertyMetaData;
    };
}

// @public
export interface EntityProps {
    classFullName: string;
    id?: Id64String;
    readonly isInstanceOfEntity?: never;
    jsonProperties?: {
        [key: string]: any;
    };
}

// @public
export interface EntityQueryParams {
    bindings?: any[] | object;
    from?: string;
    limit?: number;
    offset?: number;
    only?: boolean;
    orderBy?: string;
    where?: string;
}

// @public
export class Environment {
    protected constructor(props?: Partial<EnvironmentProperties>);
    clone(changedProps?: Partial<EnvironmentProperties>): Environment;
    static create(props?: Partial<EnvironmentProperties>): Environment;
    static readonly defaults: Environment;
    readonly displayGround: boolean;
    readonly displaySky: boolean;
    static fromJSON(props?: EnvironmentProps): Environment;
    readonly ground: GroundPlane;
    readonly sky: SkyBox;
    toJSON(): EnvironmentProps;
    withDisplay(display: {
        sky?: boolean;
        ground?: boolean;
    }): Environment;
}

// @public
export type EnvironmentProperties = NonFunctionPropertiesOf<Environment>;

// @public
export interface EnvironmentProps {
    ground?: GroundPlaneProps;
    sky?: SkyBoxProps;
}

// @public
export interface ExtantElementGeometryChange {
    readonly id: Id64String;
    readonly range: Range3d;
    readonly type: DbOpcode.Insert | DbOpcode.Update;
}

// @public
export interface ExternalSourceAspectProps extends ElementAspectProps {
    checksum?: string;
    identifier: string;
    jsonProperties?: any;
    kind: string;
    scope: RelatedElementProps;
    source?: RelatedElementProps;
    version?: string;
}

// @beta
export interface ExternalSourceAttachmentProps extends ElementProps {
    // (undocumented)
    attaches?: RelatedElementProps;
    // (undocumented)
    pitch?: number;
    // (undocumented)
    role?: ExternalSourceAttachmentRole;
    // (undocumented)
    roll?: number;
    // (undocumented)
    scale?: XYZProps;
    // (undocumented)
    translation?: XYZProps;
    // (undocumented)
    yaw?: number;
}

// @beta
export enum ExternalSourceAttachmentRole {
    SpecifyContext = 0,
    SpecifyPart = 1
}

// @beta
export interface ExternalSourceProps extends ElementProps {
    // (undocumented)
    connectorName?: string;
    // (undocumented)
    connectorVersion?: string;
    // (undocumented)
    repository?: RelatedElementProps;
}

// @public
export class Feature {
    constructor(elementId?: Id64String, subCategoryId?: Id64String, geometryClass?: GeometryClass);
    compare(rhs: Feature): number;
    // (undocumented)
    readonly elementId: string;
    equals(other: Feature): boolean;
    // (undocumented)
    readonly geometryClass: GeometryClass;
    // (undocumented)
    get isDefined(): boolean;
    // (undocumented)
    get isUndefined(): boolean;
    // (undocumented)
    readonly subCategoryId: string;
}

// @public
export class FeatureAppearance {
    protected constructor(props: FeatureAppearanceProps);
    get anyOverridden(): boolean;
    clone(changedProps: FeatureAppearanceProps): FeatureAppearance;
    cloneProps(changedProps: FeatureAppearanceProps): FeatureAppearanceProps;
    static readonly defaults: FeatureAppearance;
    readonly emphasized?: true;
    // (undocumented)
    equals(other: FeatureAppearance): boolean;
    extendAppearance(base: FeatureAppearance): FeatureAppearance;
    // (undocumented)
    static fromJSON(props?: FeatureAppearanceProps): FeatureAppearance;
    static fromRgb(color: ColorDef): FeatureAppearance;
    static fromRgba(color: ColorDef, viewDependentTransparency?: boolean): FeatureAppearance;
    static fromSubCategoryOverride(ovr: SubCategoryOverride): FeatureAppearance;
    static fromTransparency(transparencyValue: number, viewDependent?: boolean): FeatureAppearance;
    readonly ignoresMaterial?: true;
    // (undocumented)
    get isFullyTransparent(): boolean;
    readonly linePixels?: LinePixels;
    get matchesDefaults(): boolean;
    readonly nonLocatable?: true;
    // (undocumented)
    get overridesLinePixels(): boolean;
    // (undocumented)
    get overridesNonLocatable(): boolean;
    // (undocumented)
    get overridesRgb(): boolean;
    // (undocumented)
    get overridesSymbology(): boolean;
    // (undocumented)
    get overridesTransparency(): boolean;
    // (undocumented)
    get overridesWeight(): boolean;
    readonly rgb?: RgbColor;
    // (undocumented)
    toJSON(): FeatureAppearanceProps;
    readonly transparency?: number;
    readonly viewDependentTransparency?: true;
    readonly weight?: number;
}

// @public
export interface FeatureAppearanceProps {
    emphasized?: true;
    ignoresMaterial?: true;
    linePixels?: LinePixels;
    nonLocatable?: true;
    rgb?: RgbColorProps;
    transparency?: number;
    viewDependentTransparency?: true;
    weight?: number;
}

// @public
export interface FeatureAppearanceProvider {
    getFeatureAppearance(source: FeatureAppearanceSource, elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): FeatureAppearance | undefined;
}

// @public (undocumented)
export namespace FeatureAppearanceProvider {
    export function chain(first: FeatureAppearanceProvider, second: FeatureAppearanceProvider): FeatureAppearanceProvider;
    export function supplement(supplementAppearance: (appearance: FeatureAppearance) => FeatureAppearance): FeatureAppearanceProvider;
}

// @public
export interface FeatureAppearanceSource {
    getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): FeatureAppearance | undefined;
}

// @internal
export class FeatureGates {
    addMonitor(feature: string, monitor: (val: GateValue) => void): () => void;
    check(feature: string, defaultVal?: GateValue): GateValue;
    readonly gates: Map<string, GateValue>;
    onChanged: BeEvent<(feature: string, val: GateValue) => void>;
    setGate(feature: string, val: GateValue): void;
}

// @internal (undocumented)
export class FeatureIndex {
    // (undocumented)
    featureID: number;
    // (undocumented)
    featureIDs?: Uint32Array;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    get isUniform(): boolean;
    // (undocumented)
    reset(): void;
    // (undocumented)
    type: FeatureIndexType;
}

// @internal (undocumented)
export enum FeatureIndexType {
    // (undocumented)
    Empty = 0,
    // (undocumented)
    NonUniform = 2,
    // (undocumented)
    Uniform = 1
}

// @public
export class FeatureOverrides implements FeatureAppearanceSource {
    constructor();
    // @internal (undocumented)
    get alwaysDrawn(): Id64.Uint32Set;
    // @internal
    protected readonly _alwaysDrawn: Id64.Uint32Set;
    alwaysDrawnIgnoresSubCategory: boolean;
    // @internal
    readonly animationNodeOverrides: Map<number, FeatureAppearance>;
    // @internal
    protected _constructions: boolean;
    get defaultOverrides(): FeatureAppearance;
    // @internal
    protected _defaultOverrides: FeatureAppearance;
    // @internal
    protected _dimensions: boolean;
    // @internal
    protected readonly _elementOverrides: Id64.Uint32Map<FeatureAppearance>;
    getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): FeatureAppearance | undefined;
    // @internal
    protected getClassifierAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, modelLo: number, modelHi: number, animationNodeId: number): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getElementOverrides(idLo: number, idHi: number, animationNodeId: number): FeatureAppearance | undefined;
    getElementOverridesById(id: Id64String): FeatureAppearance | undefined;
    getFeatureAppearance(feature: Feature, modelId: Id64String, type?: BatchType, animationNodeId?: number): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getModelOverrides(idLo: number, idHi: number): FeatureAppearance | undefined;
    getModelOverridesById(id: Id64String): FeatureAppearance | undefined;
    // @internal (undocumented)
    protected getSubCategoryOverrides(idLo: number, idHi: number): FeatureAppearance | undefined;
    getSubCategoryOverridesById(id: Id64String): FeatureAppearance | undefined;
    // @internal
    getSubCategoryPriority(idLo: number, idHi: number): number;
    ignoreAnimationOverrides(ignore: IgnoreAnimationOverrides): void;
    // @internal (undocumented)
    protected readonly _ignoreAnimationOverrides: IgnoreAnimationOverrides[];
    // @internal
    ignoreSubCategory: boolean;
    // @internal (undocumented)
    protected isAlwaysDrawn(idLo: number, idHi: number): boolean;
    isAlwaysDrawnExclusive: boolean;
    isClassVisible(geomClass: GeometryClass): boolean;
    isFeatureVisible(feature: Feature): boolean;
    // @internal (undocumented)
    protected isNeverDrawn(elemIdLo: number, elemIdHi: number, animationNodeId: number): boolean;
    isSubCategoryIdVisible(id: Id64String): boolean;
    // @internal
    isSubCategoryVisible(idLo: number, idHi: number): boolean;
    // @internal (undocumented)
    isSubCategoryVisibleInModel(subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): boolean;
    get lineWeights(): boolean;
    // @internal
    protected _lineWeights: boolean;
    // @internal
    protected readonly _modelOverrides: Id64.Uint32Map<FeatureAppearance>;
    // @internal
    protected readonly _modelSubCategoryOverrides: Id64.Uint32Map<Id64.Uint32Set>;
    // @internal (undocumented)
    get neverDrawn(): Id64.Uint32Set;
    // @internal
    protected readonly _neverDrawn: Id64.Uint32Set;
    // @internal
    readonly neverDrawnAnimationNodes: Set<number>;
    override(args: OverrideFeatureAppearanceArgs): void;
    overrideAnimationNode(id: number, app: FeatureAppearance): void;
    // @deprecated
    overrideElement(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    // @deprecated
    overrideModel(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    // @deprecated
    overrideSubCategory(id: Id64String, app: FeatureAppearance, replaceExisting?: boolean): void;
    // @internal
    protected _patterns: boolean;
    setAlwaysDrawn(id: Id64String): void;
    setAlwaysDrawnSet(ids: Iterable<Id64String>, exclusive: boolean, ignoreSubCategory?: boolean): void;
    setAnimationNodeNeverDrawn(id: number): void;
    setDefaultOverrides(appearance: FeatureAppearance, replaceExisting?: boolean): void;
    setNeverDrawn(id: Id64String): void;
    setNeverDrawnSet(ids: Iterable<Id64String>): void;
    setVisibleSubCategory(id: Id64String): void;
    // @internal
    protected readonly _subCategoryOverrides: Id64.Uint32Map<FeatureAppearance>;
    // @internal
    protected readonly _subCategoryPriorities: Id64.Uint32Map<number>;
    // @internal
    protected readonly _visibleSubCategories: Id64.Uint32Set;
}

// @public
export enum FeatureOverrideType {
    AlphaOnly = 1,
    ColorAndAlpha = 2,
    ColorOnly = 0
}

// @public
export class FeatureTable extends IndexMap<Feature> {
    constructor(maxFeatures: number, modelId?: Id64String, type?: BatchType);
    // @internal (undocumented)
    get anyDefined(): boolean;
    findFeature(index: number): Feature | undefined;
    // @internal (undocumented)
    getArray(): Array<IndexedValue<Feature>>;
    // @internal (undocumented)
    insertWithIndex(feature: Feature, index: number): void;
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    get isVolumeClassifier(): boolean;
    get maxFeatures(): number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
}

// @internal
export class FeatureTableHeader {
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    static readFrom(stream: ByteStream): FeatureTableHeader | undefined;
    // (undocumented)
    static sizeInBytes: number;
}

// @public (undocumented)
export interface FilePropertyProps {
    // (undocumented)
    id?: number | string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly namespace: string;
    // (undocumented)
    subId?: number | string;
}

// @public
export enum FillDisplay {
    Always = 2,
    Blanking = 3,
    ByView = 1,
    Never = 0
}

// @public
export enum FillFlags {
    Always = 2,
    Background = 8,
    Behind = 4,
    Blanking = 6,
    ByView = 1,
    None = 0
}

// @public
export interface FlatBufferGeometryStream {
    data: ElementGeometryDataEntry[];
    format: "flatbuffer";
}

// @public
export type FontId = number;

// @public
export class FontMap {
    constructor(props?: FontMapProps);
    // (undocumented)
    addFonts(fonts: FontProps[]): void;
    // (undocumented)
    readonly fonts: Map<number, FontProps>;
    getFont(arg: string | FontId): FontProps | undefined;
    // (undocumented)
    toJSON(): FontMapProps;
}

// @public
export interface FontMapProps {
    // (undocumented)
    fonts: FontProps[];
}

// @public
export interface FontProps {
    id: FontId;
    name: string;
    type: FontType;
}

// @public
export enum FontType {
    // (undocumented)
    Rsc = 2,
    // (undocumented)
    Shx = 3,
    // (undocumented)
    TrueType = 1
}

// @internal (undocumented)
export interface FormDataCommon {
    // (undocumented)
    append(name: string, value: string | Blob | Buffer_2, fileName?: string): void;
}

// @public
export class FresnelSettings {
    clone(changedProps?: FresnelSettingsProps): FresnelSettings;
    static create(intensity?: number, invert?: boolean): FresnelSettings;
    equals(rhs: FresnelSettings): boolean;
    static fromJSON(props?: FresnelSettingsProps): FresnelSettings;
    readonly intensity: number;
    readonly invert: boolean;
    toJSON(): FresnelSettingsProps | undefined;
}

// @public
export interface FresnelSettingsProps {
    intensity?: number;
    invert?: boolean;
}

// @public
export class Frustum {
    constructor();
    clone(result?: Frustum): Frustum;
    distance(corner1: number, corner2: number): number;
    equals(rhs: Frustum): boolean;
    fixPointOrder(): void;
    static fromRange(range: LowAndHighXYZ | LowAndHighXY, out?: Frustum): Frustum;
    get frontCenter(): Point3d;
    getCenter(): Point3d;
    getCorner(i: number): Point3d;
    getEyePoint(result?: Point3d): Point3d | undefined;
    getFraction(): number;
    getIntersectionWithPlane(plane: Plane3dByOriginAndUnitNormal): Point3d[] | undefined;
    getRangePlanes(clipFront: boolean, clipBack: boolean, expandPlaneDistance: number): ConvexClipPlaneSet;
    getRotation(result?: Matrix3d): Matrix3d | undefined;
    get hasMirror(): boolean;
    initFromRange(range: LowAndHighXYZ | LowAndHighXY): void;
    initNpc(): this;
    invalidate(): void;
    isSame(other: Frustum): boolean;
    multiply(trans: Transform): void;
    readonly points: Point3d[];
    get rearCenter(): Point3d;
    scaleAboutCenter(scale: number): void;
    scaleXYAboutCenter(scale: number): void;
    setFrom(other: Frustum): void;
    setFromCorners(corners: Point3d[]): void;
    toMap4d(): Map4d | undefined;
    toRange(range?: Range3d): Range3d;
    transformBy(trans: Transform, result?: Frustum): Frustum;
    translate(offset: XYAndZ): void;
}

// @internal
export class FrustumPlanes {
    constructor(frustum?: Frustum);
    // (undocumented)
    computeContainment(points: Point3d[], sphere?: BoundingSphere, tolerance?: number): FrustumPlanes.Containment;
    // (undocumented)
    computeFrustumContainment(box: Frustum, sphere?: BoundingSphere): FrustumPlanes.Containment;
    // (undocumented)
    containsPoint(point: Point3d, tolerance?: number): boolean;
    // (undocumented)
    init(frustum: Frustum): void;
    // (undocumented)
    intersectsFrustum(box: Frustum, sphere?: BoundingSphere): boolean;
    // (undocumented)
    intersectsRay(origin: Point3d, direction: Vector3d): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    get planes(): ClipPlane[] | undefined;
}

// @internal (undocumented)
export namespace FrustumPlanes {
    // (undocumented)
    export function addPlaneFromPoints(planes: ClipPlane[], points: Point3d[], i0: number, i1: number, i2: number, expandPlaneDistance?: number): void;
    // (undocumented)
    export enum Containment {
        // (undocumented)
        Inside = 2,
        // (undocumented)
        Outside = 0,
        // (undocumented)
        Partial = 1
    }
}

// @public (undocumented)
export interface FunctionalElementProps extends ElementProps {
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @internal (undocumented)
export type GateValue = number | boolean | string | undefined;

// @public
export class GeocentricTransform implements GeocentricTransformProps {
    constructor(data?: GeocentricTransformProps);
    readonly delta: Vector3d;
    equals(other: GeocentricTransform): boolean;
    static fromJSON(data: GeocentricTransformProps): GeocentricTransform;
    toJSON(): GeocentricTransformProps;
}

// @public
export interface GeocentricTransformProps {
    delta: XYAndZ;
}

// @beta
export interface GeoCoordinatesRequestProps {
    // (undocumented)
    iModelCoords: XYZProps[];
    // (undocumented)
    target: string;
}

// @beta
export interface GeoCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    geoCoords: PointWithStatus[];
}

// @public
export enum GeoCoordStatus {
    CSMapError = 4096,
    NoDatumConverter = 25,
    NoGCSDefined = 100,
    OutOfMathematicalDomain = 2,
    OutOfUsefulRange = 1,
    Pending = -41556,
    Success = 0,
    VerticalDatumConvertError = 26
}

// @public
export class GeodeticDatum implements GeodeticDatumProps {
    constructor(_data?: GeodeticDatumProps);
    readonly additionalTransformPaths?: GeodeticTransformPath[];
    readonly deprecated: boolean;
    readonly description?: string;
    readonly ellipsoid?: GeodeticEllipsoid;
    readonly ellipsoidId?: string;
    readonly epsg?: number;
    equals(other: GeodeticDatum): boolean;
    static fromJSON(data: GeodeticDatumProps): GeodeticDatum;
    readonly id?: string;
    readonly source?: string;
    toJSON(): GeodeticDatumProps;
    readonly transforms?: GeodeticTransform[];
}

// @public
export interface GeodeticDatumProps {
    additionalTransformPaths?: GeodeticTransformPathProps[];
    deprecated?: boolean;
    description?: string;
    ellipsoid?: GeodeticEllipsoidProps;
    ellipsoidId?: string;
    epsg?: number;
    id?: string;
    source?: string;
    transforms?: GeodeticTransformProps[];
}

// @public
export class GeodeticEllipsoid implements GeodeticEllipsoidProps {
    constructor(data?: GeodeticEllipsoidProps);
    readonly deprecated: boolean;
    readonly description?: string;
    readonly epsg?: number;
    equals(other: GeodeticEllipsoid): boolean;
    readonly equatorialRadius?: number;
    static fromJSON(data: GeodeticEllipsoidProps): GeodeticEllipsoid;
    readonly id?: string;
    readonly polarRadius?: number;
    readonly source?: string;
    toJSON(): GeodeticEllipsoidProps;
}

// @public
export interface GeodeticEllipsoidProps {
    deprecated?: boolean;
    description?: string;
    epsg?: number;
    equatorialRadius?: number;
    id?: string;
    polarRadius?: number;
    source?: string;
}

// @public
export class GeodeticTransform implements GeodeticTransformProps {
    constructor(data?: GeodeticTransformProps);
    equals(other: GeodeticTransform): boolean;
    static fromJSON(data: GeodeticTransformProps): GeodeticTransform;
    readonly geocentric?: GeocentricTransform;
    readonly gridFile?: GridFileTransform;
    readonly method: GeodeticTransformMethod;
    readonly positionalVector?: PositionalVectorTransform;
    readonly sourceDatumId?: string;
    readonly sourceEllipsoid?: GeodeticEllipsoid;
    readonly targetDatumId?: string;
    readonly targetEllipsoid?: GeodeticEllipsoid;
    toJSON(): GeodeticTransformProps;
}

// @public
export type GeodeticTransformMethod = "None" | "Geocentric" | "PositionalVector" | "GridFiles" | "MultipleRegression" | "Undefined";

// @public
export class GeodeticTransformPath implements GeodeticTransformPathProps {
    constructor(_data?: GeodeticTransformPathProps);
    equals(other: GeodeticTransformPath): boolean;
    static fromJSON(data: GeodeticTransformPathProps): GeodeticTransformPath;
    readonly sourceDatumId?: string;
    readonly targetDatumId?: string;
    toJSON(): GeodeticTransformPathProps;
    readonly transforms?: GeodeticTransform[];
}

// @public
export interface GeodeticTransformPathProps {
    sourceDatumId?: string;
    targetDatumId?: string;
    transforms?: GeodeticTransformProps[];
}

// @public
export interface GeodeticTransformProps {
    geocentric?: GeocentricTransformProps;
    gridFile?: GridFileTransformProps;
    method: GeodeticTransformMethod;
    positionalVector?: PositionalVectorTransformProps;
    sourceDatumId?: string;
    sourceEllipsoid?: GeodeticEllipsoidProps;
    targetDatumId?: string;
    targetEllipsoid?: GeodeticEllipsoidProps;
}

// @public
export class GeographicCRS implements GeographicCRSProps {
    constructor(data?: GeographicCRSProps);
    readonly additionalTransform?: AdditionalTransform;
    equals(other: GeographicCRS): boolean;
    static fromJSON(data: GeographicCRSProps): GeographicCRS;
    readonly horizontalCRS?: HorizontalCRS;
    toJSON(): GeographicCRSProps;
    readonly verticalCRS?: VerticalCRS;
}

// @beta
export interface GeographicCRSInterpretRequestProps {
    format: "WKT" | "JSON";
    geographicCRSDef: string;
}

// @beta
export interface GeographicCRSInterpretResponseProps {
    geographicCRS?: GeographicCRSProps;
    status: number;
}

// @public
export interface GeographicCRSProps {
    additionalTransform?: AdditionalTransformProps;
    horizontalCRS?: HorizontalCRSProps;
    verticalCRS?: VerticalCRSProps;
}

// @public
export interface GeometricElement2dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement2dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElement3dProps extends GeometricElementProps {
    // (undocumented)
    placement?: Placement3dProps;
    // (undocumented)
    typeDefinition?: RelatedElementProps;
}

// @public
export interface GeometricElementProps extends ElementProps {
    category: Id64String;
    // @alpha
    elementGeometryBuilderParams?: ElementGeometryBuilderParams;
    geom?: GeometryStreamProps;
    placement?: PlacementProps;
}

// @public
export interface GeometricModel2dProps extends GeometricModelProps {
    globalOrigin?: XYProps;
}

// @public
export interface GeometricModel3dProps extends GeometricModelProps {
    isNotSpatiallyLocated?: boolean;
    isPlanProjection?: boolean;
}

// @public
export interface GeometricModelProps extends ModelProps {
    geometryGuid?: GuidString;
}

// @public
export interface GeometryAppearanceProps {
    color?: ColorDefProps;
    displayPriority?: number;
    geometryClass?: GeometryClass;
    style?: Id64String;
    subCategory?: Id64String;
    transparency?: number;
    weight?: number;
}

// @public
export enum GeometryClass {
    Construction = 1,
    Dimension = 2,
    Pattern = 3,
    Primary = 0
}

// @public
export interface GeometryContainmentRequestProps {
    // (undocumented)
    allowOverlaps?: boolean;
    // (undocumented)
    candidates: Id64Array;
    // (undocumented)
    clip: ClipVectorProps;
    // (undocumented)
    offSubCategories?: Id64Array;
    // (undocumented)
    viewFlags?: ViewFlagProps;
}

// @public
export interface GeometryContainmentResponseProps {
    // (undocumented)
    candidatesContainment?: ClipPlaneContainment[];
    // (undocumented)
    numInside?: number;
    // (undocumented)
    numOutside?: number;
    // (undocumented)
    numOverlap?: number;
    // (undocumented)
    status: BentleyStatus;
}

// @public
export class GeometryParams {
    constructor(categoryId: Id64String, subCategoryId?: string);
    backgroundFill?: BackgroundFill;
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    clone(): GeometryParams;
    elmPriority?: number;
    elmTransparency?: number;
    fillColor?: ColorDef;
    fillDisplay?: FillDisplay;
    fillTransparency?: number;
    geometryClass?: GeometryClass;
    gradient?: Gradient.Symb;
    isEquivalent(other: GeometryParams): boolean;
    lineColor?: ColorDef;
    materialId?: Id64String;
    pattern?: AreaPattern.Params;
    resetAppearance(): void;
    setCategoryId(categoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    setSubCategoryId(subCategoryId: Id64String, clearAppearanceOverrides?: boolean): void;
    styleInfo?: LineStyle.Info;
    // (undocumented)
    subCategoryId: string;
    weight?: number;
}

// @public
export interface GeometryPartInstanceProps {
    origin?: XYZProps;
    part: Id64String;
    rotation?: YawPitchRollProps;
    scale?: number;
}

// @public
export interface GeometryPartProps extends ElementProps {
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // @alpha
    elementGeometryBuilderParams?: ElementGeometryBuilderParamsForPart;
    // (undocumented)
    geom?: GeometryStreamProps;
}

// @public
export interface GeometryPrimitive {
    // (undocumented)
    readonly geometry: AnyGeometryQuery;
    // (undocumented)
    type: "geometryQuery";
}

// @public
export class GeometryStreamBuilder {
    // @beta
    appendBRepData(brep: BRepEntity.DataProps): boolean;
    appendGeometry(geometry: GeometryQuery): boolean;
    appendGeometryParamsChange(geomParams: GeometryParams): boolean;
    appendGeometryPart2d(partId: Id64String, instanceOrigin?: Point2d, instanceRotation?: Angle, instanceScale?: number): boolean;
    appendGeometryPart3d(partId: Id64String, instanceOrigin?: Point3d, instanceRotation?: YawPitchRollAngles, instanceScale?: number): boolean;
    appendGeometryRanges(): void;
    appendImage(image: ImageGraphic): boolean;
    appendSubCategoryChange(subCategoryId: Id64String): boolean;
    appendTextString(textString: TextString): boolean;
    readonly geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    getHeader(): GeometryStreamHeaderProps | undefined;
    get isViewIndependent(): boolean;
    set isViewIndependent(viewIndependent: boolean);
    // @internal (undocumented)
    obtainHeader(): GeometryStreamHeaderProps;
    setLocalToWorld(localToWorld?: Transform): void;
    setLocalToWorld2d(origin: Point2d, angle?: Angle): void;
    setLocalToWorld3d(origin: Point3d, angles?: YawPitchRollAngles): void;
    setLocalToWorldFromPlacement(props: PlacementProps): void;
}

// @public
export interface GeometryStreamEntryProps extends IModelJson.GeometryProps {
    // (undocumented)
    appearance?: GeometryAppearanceProps;
    // (undocumented)
    brep?: BRepEntity.DataProps;
    // (undocumented)
    fill?: AreaFillProps;
    // (undocumented)
    geomPart?: GeometryPartInstanceProps;
    // (undocumented)
    header?: GeometryStreamHeaderProps;
    // (undocumented)
    image?: ImageGraphicProps;
    // (undocumented)
    material?: MaterialProps;
    // (undocumented)
    pattern?: AreaPattern.ParamsProps;
    // (undocumented)
    styleMod?: LineStyle.ModifierProps;
    // (undocumented)
    subRange?: LowAndHighXYZ;
    // (undocumented)
    textString?: TextStringProps;
}

// @public
export enum GeometryStreamFlags {
    None = 0,
    ViewIndependent = 1
}

// @public
export interface GeometryStreamHeaderProps {
    flags: GeometryStreamFlags;
}

// @public
export class GeometryStreamIterator implements IterableIterator<GeometryStreamIteratorEntry> {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<GeometryStreamIteratorEntry>;
    constructor(geometryStream: GeometryStreamProps, categoryOrGeometryParams?: Id64String | GeometryParams, localToWorld?: Transform);
    readonly flags: GeometryStreamFlags;
    static fromGeometricElement2d(element: Pick<GeometricElement2dProps, "geom" | "placement" | "category">): GeometryStreamIterator;
    static fromGeometricElement3d(element: Pick<GeometricElement3dProps, "geom" | "placement" | "category">): GeometryStreamIterator;
    static fromGeometryPart(geomPart: Pick<GeometryPartProps, "geom">, geomParams?: GeometryParams, partTransform?: Transform): GeometryStreamIterator;
    geometryStream: GeometryStreamProps;
    // @internal (undocumented)
    get isViewIndependent(): boolean;
    next(): IteratorResult<GeometryStreamIteratorEntry>;
    partToWorld(): Transform | undefined;
}

// @public
export interface GeometryStreamIteratorEntry {
    readonly geomParams: GeometryParams;
    readonly localRange?: Range3d;
    readonly localToWorld?: Transform;
    readonly primitive: GeometryStreamPrimitive;
}

// @public
export type GeometryStreamPrimitive = TextStringPrimitive | PartReference | BRepPrimitive | GeometryPrimitive | ImagePrimitive;

// @public
export type GeometryStreamProps = GeometryStreamEntryProps[];

// @public
export interface GeometrySummaryOptions {
    geometryVerbosity?: GeometrySummaryVerbosity;
    includePartReferences?: "2d" | "3d";
    includePlacement?: boolean;
    verboseSymbology?: boolean;
}

// @public
export interface GeometrySummaryRequestProps {
    elementIds: Id64Array;
    options?: GeometrySummaryOptions;
}

// @public
export enum GeometrySummaryVerbosity {
    Basic = 10,
    Detailed = 20,
    Full = 30
}

// @internal (undocumented)
export function getMaximumMajorTileFormatVersion(maxMajorVersion: number, formatVersion?: number): number;

export { GetMetaDataFunction }

// @internal (undocumented)
export class GlbHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly additionalChunks: TypedGltfChunk[];
    // (undocumented)
    readonly binaryChunk?: GltfChunk;
    // (undocumented)
    readonly gltfLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly jsonChunk: GltfChunk;
}

// @public
export enum GlobeMode {
    Ellipsoid = 0,
    Plane = 1
}

// @internal
export interface GltfChunk {
    length: number;
    offset: number;
}

// @internal (undocumented)
export enum GltfV2ChunkTypes {
    // (undocumented)
    Binary = 5130562,
    // (undocumented)
    JSON = 1313821514
}

// @internal
export enum GltfVersions {
    // (undocumented)
    CurrentVersion = 1,
    // (undocumented)
    Gltf1SceneFormat = 0,
    // (undocumented)
    Version1 = 1,
    // (undocumented)
    Version2 = 2
}

// @public
export namespace Gradient {
    export enum Flags {
        Invert = 1,
        None = 0,
        Outline = 2
    }
    export class KeyColor {
        constructor(json: KeyColorProps);
        // (undocumented)
        color: ColorDef;
        // (undocumented)
        value: number;
    }
    export function keyColorEquals(a: KeyColor, b: KeyColor): boolean;
    export interface KeyColorProps {
        color: ColorDefProps;
        value: number;
    }
    export enum Mode {
        // (undocumented)
        Curved = 2,
        // (undocumented)
        Cylindrical = 3,
        // (undocumented)
        Hemispherical = 5,
        // (undocumented)
        Linear = 1,
        // (undocumented)
        None = 0,
        // (undocumented)
        Spherical = 4,
        Thematic = 6
    }
    export interface ProduceImageArgs {
        height: number;
        includeThematicMargin?: boolean;
        width: number;
    }
    export class Symb {
        // (undocumented)
        angle?: Angle;
        // (undocumented)
        clone(): Symb;
        compare(other: Symb): number;
        static compareSymb(lhs: Gradient.Symb, rhs: Gradient.Symb): number;
        static createThematic(settings: ThematicGradientSettings): Symb;
        equals(other: Symb): boolean;
        // (undocumented)
        flags: Flags;
        static fromJSON(json?: SymbProps): Symb;
        getImage(width: number, height: number): ImageBuffer;
        // @internal
        getThematicImageForRenderer(maxDimension: number): ImageBuffer;
        // (undocumented)
        get hasTranslucency(): boolean;
        get isOutlined(): boolean;
        // (undocumented)
        keys: KeyColor[];
        mapColor(value: number): ColorDef;
        // (undocumented)
        mode: Mode;
        produceImage(args: ProduceImageArgs): ImageBuffer;
        // (undocumented)
        shift: number;
        // (undocumented)
        thematicSettings?: ThematicGradientSettings;
        // (undocumented)
        tint?: number;
        // (undocumented)
        toJSON(): SymbProps;
    }
    export interface SymbProps {
        angle?: AngleProps;
        flags?: Flags;
        keys: KeyColorProps[];
        mode: Mode;
        shift?: number;
        thematicSettings?: ThematicGradientSettingsProps;
        tint?: number;
    }
}

// @public
export class GraphicParams {
    // (undocumented)
    clone(out?: GraphicParams): GraphicParams;
    fillColor: ColorDef;
    fillFlags: FillFlags;
    static fromBlankingFill(fillColor: ColorDef): GraphicParams;
    static fromSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): GraphicParams;
    gradient?: Gradient.Symb;
    lineColor: ColorDef;
    linePixels: LinePixels;
    material?: RenderMaterial;
    rasterWidth: number;
    setFillTransparency(transparency: number): void;
    setLineTransparency(transparency: number): void;
}

// @public
export interface GraphicsRequestProps {
    readonly clipToProjectExtents?: boolean;
    // @alpha
    readonly contentFlags?: ContentFlags;
    // @internal
    readonly edgeType?: 1 | 2;
    // @alpha
    readonly formatVersion?: number;
    readonly id: string;
    readonly location?: TransformProps;
    readonly omitEdges?: boolean;
    quantizePositions?: boolean;
    readonly sectionCut?: string;
    // @internal
    readonly smoothPolyfaceEdges?: boolean;
    readonly toleranceLog10: number;
    // @alpha
    readonly treeFlags?: TreeFlags;
}

// @public
export class GridFileDefinition implements GridFileDefinitionProps {
    constructor(data?: GridFileDefinitionProps);
    readonly direction: GridFileDirection;
    equals(other: GridFileDefinition): boolean;
    readonly fileName: string;
    readonly format: GridFileFormat;
    static fromJSON(data: GridFileDefinitionProps): GridFileDefinition;
    toJSON(): GridFileDefinitionProps;
}

// @public
export interface GridFileDefinitionProps {
    direction: GridFileDirection;
    fileName: string;
    format: GridFileFormat;
}

// @public
export type GridFileDirection = "Direct" | "Inverse";

// @public
export type GridFileFormat = "NONE" | "NTv1" | "NTv2" | "NADCON" | "FRENCH" | "JAPAN" | "ATS77" | "GEOCN" | "OSTN02" | "OSTN15";

// @public
export class GridFileTransform implements GridFileTransformProps {
    constructor(data?: GridFileTransformProps);
    equals(other: GridFileTransform): boolean;
    readonly fallback?: PositionalVectorTransform;
    readonly files: GridFileDefinition[];
    static fromJSON(data: GridFileTransformProps): GridFileTransform;
    toJSON(): GridFileTransformProps;
}

// @public
export interface GridFileTransformProps {
    fallback?: PositionalVectorTransformProps;
    files: GridFileDefinitionProps[];
}

// @public
export enum GridOrientationType {
    AuxCoord = 4,
    View = 0,
    WorldXY = 1,
    WorldXZ = 3,
    WorldYZ = 2
}

// @public
export class GroundPlane {
    protected constructor(props: Partial<GroundPlaneProperties>);
    readonly aboveColor: ColorDef;
    readonly belowColor: ColorDef;
    clone(changedProps?: Partial<GroundPlaneProperties>): GroundPlane;
    static create(props?: Partial<GroundPlaneProperties>): GroundPlane;
    static readonly defaults: GroundPlane;
    readonly elevation: number;
    static fromJSON(props?: GroundPlaneProps): GroundPlane;
    toJSON(display?: boolean): GroundPlaneProps;
}

// @public
export type GroundPlaneProperties = NonFunctionPropertiesOf<GroundPlane>;

// @public
export interface GroundPlaneProps {
    aboveColor?: ColorDefProps;
    belowColor?: ColorDefProps;
    display?: boolean;
    elevation?: number;
}

// @public
export class Helmert2DWithZOffset implements Helmert2DWithZOffsetProps {
    constructor(data?: Helmert2DWithZOffsetProps);
    equals(other: Helmert2DWithZOffset): boolean;
    static fromJSON(data: Helmert2DWithZOffsetProps): Helmert2DWithZOffset;
    rotDeg: number;
    scale: number;
    toJSON(): Helmert2DWithZOffsetProps;
    translationX: number;
    translationY: number;
    translationZ: number;
}

// @public
export interface Helmert2DWithZOffsetProps {
    rotDeg: number;
    scale: number;
    translationX: number;
    translationY: number;
    translationZ: number;
}

// @public
export type HemisphereEnum = "South" | "North";

// @public
export class HemisphereLights {
    constructor(json?: HemisphereLightsProps);
    clone(changed?: HemisphereLightsProps): HemisphereLights;
    // (undocumented)
    equals(rhs: HemisphereLights): boolean;
    // (undocumented)
    readonly intensity: number;
    // (undocumented)
    readonly lowerColor: RgbColor;
    // (undocumented)
    toJSON(): HemisphereLightsProps | undefined;
    // (undocumented)
    readonly upperColor: RgbColor;
}

// @public
export interface HemisphereLightsProps {
    intensity?: number;
    lowerColor?: RgbColorProps;
    upperColor?: RgbColorProps;
}

// @public
export namespace HiddenLine {
    export class Settings {
        static defaults: Settings;
        // (undocumented)
        equals(other: Settings): boolean;
        static fromJSON(json?: SettingsProps): Settings;
        readonly hidden: Style;
        // (undocumented)
        get matchesDefaults(): boolean;
        override(props: SettingsProps): Settings;
        // (undocumented)
        toJSON(): SettingsProps;
        readonly transparencyThreshold: number;
        get transThreshold(): number;
        readonly visible: Style;
    }
    export interface SettingsProps {
        hidden?: StyleProps;
        transThreshold?: number;
        visible?: StyleProps;
    }
    export class Style {
        readonly color?: ColorDef;
        // (undocumented)
        static readonly defaultHidden: Style;
        // (undocumented)
        static readonly defaultVisible: Style;
        equals(other: Style): boolean;
        // (undocumented)
        static fromJSON(json?: StyleProps, hidden?: true): Style;
        overrideColor(color: ColorDef | undefined): Style;
        overridePattern(pattern: LinePixels | undefined): Style;
        overrideWidth(width: number | undefined): Style;
        // @internal (undocumented)
        get ovrColor(): boolean;
        readonly pattern?: LinePixels;
        // (undocumented)
        toJSON(): StyleProps;
        readonly width?: number;
    }
    export interface StyleProps {
        color?: ColorDefProps;
        // @internal
        ovrColor?: boolean;
        pattern?: LinePixels;
        width?: number;
    }
}

// @public
export namespace Hilite {
    export function cloneSettings(settings: Settings): Settings;
    export function equalSettings(lhs: Settings, rhs: Settings): boolean;
    export class Settings {
        constructor(color?: ColorDef, visibleRatio?: number, hiddenRatio?: number, silhouette?: Silhouette);
        readonly color: ColorDef;
        readonly hiddenRatio: number;
        silhouette: Silhouette;
        readonly visibleRatio: number;
    }
    export enum Silhouette {
        None = 0,
        Thick = 2,
        Thin = 1
    }
}

// @public
export class HorizontalCRS implements HorizontalCRSProps {
    constructor(_data?: HorizontalCRSProps);
    readonly datum?: GeodeticDatum;
    readonly datumId?: string;
    readonly deprecated: boolean;
    readonly description?: string;
    readonly ellipsoid?: GeodeticEllipsoid;
    readonly ellipsoidId?: string;
    readonly epsg?: number;
    equals(other: HorizontalCRS): boolean;
    readonly extent?: HorizontalCRSExtent;
    static fromJSON(data: HorizontalCRSProps): HorizontalCRS;
    readonly id?: string;
    readonly name?: string;
    readonly projection?: Projection;
    readonly source?: string;
    toJSON(): HorizontalCRSProps;
    readonly unit?: UnitType;
}

// @public
export class HorizontalCRSExtent implements HorizontalCRSExtentProps {
    constructor(data?: HorizontalCRSExtentProps);
    equals(other: HorizontalCRSExtent): boolean;
    static fromJSON(data: HorizontalCRSExtentProps): HorizontalCRSExtent;
    readonly northEast: Carto2DDegrees;
    readonly southWest: Carto2DDegrees;
    toJSON(): HorizontalCRSExtentProps;
}

// @public
export interface HorizontalCRSExtentProps {
    northEast: Carto2DDegreesProps;
    southWest: Carto2DDegreesProps;
}

// @public
export interface HorizontalCRSProps {
    datum?: GeodeticDatumProps;
    datumId?: string;
    deprecated?: boolean;
    description?: string;
    ellipsoid?: GeodeticEllipsoidProps;
    ellipsoidId?: string;
    epsg?: number;
    extent?: HorizontalCRSExtentProps;
    id?: string;
    name?: string;
    projection?: ProjectionProps;
    source?: string;
    unit?: UnitType;
}

// @public
export class HSLColor {
    constructor(hue?: number, saturation?: number, lightness?: number);
    // (undocumented)
    clone(hue?: number, saturation?: number, lightness?: number): HSLColor;
    // (undocumented)
    static fromColorDef(val: ColorDef): HSLColor;
    readonly h: number;
    readonly l: number;
    readonly s: number;
    // (undocumented)
    toColorDef(transparency?: number): ColorDef;
}

// @public
export class HSVColor {
    constructor(hue?: number, saturation?: number, value?: number);
    // (undocumented)
    adjusted(darkenColor: boolean, delta: number): HSVColor;
    // (undocumented)
    clone(hue?: number, saturation?: number, value?: number): HSVColor;
    // (undocumented)
    static fromColorDef(val: ColorDef): HSVColor;
    readonly h: number;
    readonly s: number;
    // (undocumented)
    toColorDef(transparency?: number): ColorDef;
    readonly v: number;
}

// @public (undocumented)
export enum HSVConstants {
    // (undocumented)
    HSV_SATURATION_WEIGHT = 4,
    // (undocumented)
    HSV_VALUE_WEIGHT = 2,
    // (undocumented)
    VISIBILITY_GOAL = 40
}

// @internal (undocumented)
export type HttpMethod_T = "get" | "put" | "post" | "delete" | "options" | "head" | "patch" | "trace";

// @public
export interface HttpServerRequest extends Readable {
    // (undocumented)
    aborted: boolean;
    // (undocumented)
    body: string | Buffer;
    // (undocumented)
    complete: boolean;
    // (undocumented)
    connection: any;
    // (undocumented)
    destroy(error?: Error): this;
    // (undocumented)
    header: (field: string) => string | undefined;
    // (undocumented)
    headers: {
        [header: string]: string | string[] | undefined;
    };
    // (undocumented)
    httpVersion: string;
    // (undocumented)
    httpVersionMajor: number;
    // (undocumented)
    httpVersionMinor: number;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    path: string;
    // (undocumented)
    rawHeaders: string[];
    // (undocumented)
    rawTrailers: string[];
    // (undocumented)
    setTimeout(msecs: number, callback: () => void): this;
    // (undocumented)
    socket: any;
    // (undocumented)
    statusCode?: number;
    // (undocumented)
    statusMessage?: string;
    // (undocumented)
    trailers: {
        [key: string]: string | undefined;
    };
    // (undocumented)
    url?: string;
}

// @public
export interface HttpServerResponse extends Writable {
    // (undocumented)
    send(body?: any): HttpServerResponse;
    // (undocumented)
    set(field: string, value: string): void;
    // (undocumented)
    status(code: number): HttpServerResponse;
}

// @internal
export interface HydrateViewStateRequestProps {
    // (undocumented)
    acsId?: string;
    // (undocumented)
    baseModelId?: Id64String;
    // @deprecated (undocumented)
    notLoadedCategoryIds?: CompressedId64Set;
    // (undocumented)
    notLoadedModelSelectorStateModels?: CompressedId64Set;
    // (undocumented)
    sheetViewAttachmentIds?: CompressedId64Set;
    // (undocumented)
    spatialViewId?: Id64String;
    // (undocumented)
    viewStateLoadProps?: ViewStateLoadProps;
}

// @internal
export interface HydrateViewStateResponseProps {
    // (undocumented)
    acsElementProps?: ElementProps;
    // (undocumented)
    baseModelProps?: ModelProps;
    // @deprecated (undocumented)
    categoryIdsResult?: SubCategoryResultRow[];
    // (undocumented)
    modelSelectorStateModels?: ModelProps[];
    // (undocumented)
    sheetViewAttachmentProps?: ViewAttachmentProps[];
    // (undocumented)
    sheetViewViews?: (ViewStateProps | undefined)[];
    // (undocumented)
    spatialViewProps?: ViewStateProps;
}

// @internal
export class I3dmHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJson: any;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    readonly featureTableJsonPosition: number;
    // (undocumented)
    readonly gltfVersion: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public
export type IgnoreAnimationOverrides = (args: IgnoreAnimationOverridesArgs) => boolean;

// @public
export interface IgnoreAnimationOverridesArgs {
    readonly animationNodeId: number;
    readonly elementId: Readonly<Id64.Uint32Pair>;
}

// @public
export class ImageBuffer {
    // @internal
    protected constructor(data: Uint8Array, format: ImageBufferFormat, width: number);
    // @internal (undocumented)
    protected static computeHeight(data: Uint8Array, format: ImageBufferFormat, width: number): number;
    static create(data: Uint8Array, format: ImageBufferFormat, width: number): ImageBuffer;
    readonly data: Uint8Array;
    readonly format: ImageBufferFormat;
    static getNumBytesPerPixel(format: ImageBufferFormat): number;
    get height(): number;
    // @internal (undocumented)
    protected static isValidData(data: Uint8Array, format: ImageBufferFormat, width: number): boolean;
    get numBytesPerPixel(): number;
    readonly width: number;
}

// @public
export enum ImageBufferFormat {
    Alpha = 5,
    Rgb = 2,
    Rgba = 0
}

// @public
export class ImageGraphic {
    constructor(corners: ImageGraphicCorners, textureId: Id64String, hasBorder?: boolean);
    // (undocumented)
    clone(): ImageGraphic;
    // (undocumented)
    cloneTransformed(transform: Transform): ImageGraphic;
    computeRange(result?: Range3d): Range3d;
    readonly corners: ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicProps): ImageGraphic;
    readonly hasBorder: boolean;
    readonly textureId: Id64String;
    // (undocumented)
    toJSON(): ImageGraphicProps;
    transformInPlace(transform: Transform): void;
}

// @public
export class ImageGraphicCorners {
    // (undocumented)
    readonly 0: Point3d;
    // (undocumented)
    readonly 1: Point3d;
    // (undocumented)
    readonly 2: Point3d;
    // (undocumented)
    readonly 3: Point3d;
    constructor(p0: Point3d, p1: Point3d, p2: Point3d, p3: Point3d);
    // (undocumented)
    clone(): ImageGraphicCorners;
    // (undocumented)
    static from4Points(points: [Point3d, Point3d, Point3d, Point3d]): ImageGraphicCorners;
    // (undocumented)
    static fromJSON(props: ImageGraphicCornersProps): ImageGraphicCorners;
    // (undocumented)
    toJSON(): ImageGraphicCornersProps;
}

// @public
export type ImageGraphicCornersProps = [XYZProps, XYZProps, XYZProps, XYZProps];

// @public
export interface ImageGraphicProps {
    corners: ImageGraphicCornersProps;
    hasBorder: boolean;
    textureId: Id64String;
}

// @public
export interface ImageMapLayerProps extends CommonMapLayerProps {
    // @internal (undocumented)
    accessKey?: MapLayerKey;
    formatId: string;
    // @internal (undocumented)
    modelId?: never;
    subLayers?: MapSubLayerProps[];
    url: string;
}

// @public
export class ImageMapLayerSettings extends MapLayerSettings {
    // @internal
    protected constructor(props: ImageMapLayerProps);
    // (undocumented)
    accessKey?: MapLayerKey;
    get allSubLayersInvisible(): boolean;
    clone(changedProps: Partial<ImageMapLayerProps>): ImageMapLayerSettings;
    // @internal (undocumented)
    protected cloneProps(changedProps: Partial<ImageMapLayerProps>): ImageMapLayerProps;
    // @internal (undocumented)
    displayMatches(other: MapLayerSettings): boolean;
    // (undocumented)
    readonly formatId: string;
    // (undocumented)
    static fromJSON(props: ImageMapLayerProps): ImageMapLayerSettings;
    getSubLayerChildren(subLayer: MapSubLayerSettings): MapSubLayerSettings[] | undefined;
    isSubLayerVisible(subLayer: MapSubLayerSettings): boolean;
    // @internal (undocumented)
    protected static mapTypeName(type: BackgroundMapType): "Aerial Imagery" | "Aerial Imagery with labels" | "Streets";
    // (undocumented)
    password?: string;
    // (undocumented)
    setCredentials(userName?: string, password?: string): void;
    // (undocumented)
    get source(): string;
    subLayerById(id?: SubLayerId): MapSubLayerSettings | undefined;
    // (undocumented)
    readonly subLayers: MapSubLayerSettings[];
    toJSON(): ImageMapLayerProps;
    // (undocumented)
    readonly url: string;
    // (undocumented)
    userName?: string;
}

// @public
export interface ImagePrimitive {
    // (undocumented)
    readonly image: ImageGraphic;
    // (undocumented)
    type: "image";
}

// @public
export type ImageryMapLayerFormatId = "ArcGIS" | "BingMaps" | "MapboxImagery" | "TileURL" | "WMS" | "WMTS";

// @public
export class ImageSource {
    constructor(data: Uint8Array | string, format: ImageSourceFormat);
    readonly data: Uint8Array | string;
    readonly format: ImageSourceFormat;
}

// @public
export enum ImageSourceFormat {
    Jpeg = 0,
    Png = 2,
    Svg = 3
}

// @internal
export enum ImdlFlags {
    ContainsCurves = 1,
    DisallowMagnification = 8,
    Incomplete = 4,
    None = 0
}

// @internal
export class ImdlHeader extends TileHeader {
    constructor(stream: ByteStream);
    readonly contentRange: ElementAlignedBox3d;
    readonly emptySubRanges: number;
    readonly flags: ImdlFlags;
    readonly headerLength: number;
    // (undocumented)
    get isReadableVersion(): boolean;
    // (undocumented)
    get isValid(): boolean;
    readonly numElementsExcluded: number;
    readonly numElementsIncluded: number;
    readonly tileLength: number;
    readonly tolerance: number;
    // (undocumented)
    get versionMajor(): number;
    // (undocumented)
    get versionMinor(): number;
}

// @public
export abstract class IModel implements IModelProps {
    // @internal
    protected constructor(tokenProps?: IModelRpcProps);
    cartographicToSpatialFromEcef(cartographic: Cartographic, result?: Point3d): Point3d;
    // (undocumented)
    changeset: ChangesetIdWithIndex;
    static readonly dictionaryId: Id64String;
    get ecefLocation(): EcefLocation | undefined;
    set ecefLocation(ecefLocation: EcefLocation | undefined);
    ecefToSpatial(ecef: XYAndZ, result?: Point3d): Point3d;
    // @internal
    protected _fileKey: string;
    get geographicCoordinateSystem(): GeographicCRS | undefined;
    set geographicCoordinateSystem(geoCRS: GeographicCRS | undefined);
    // @internal (undocumented)
    getConnectionProps(): IModelConnectionProps;
    static getDefaultSubCategoryId(categoryId: Id64String): Id64String;
    getEcefTransform(): Transform;
    getRpcProps(): IModelRpcProps;
    // @internal
    protected _getRpcProps(): IModelRpcProps;
    get globalOrigin(): Point3d;
    set globalOrigin(org: Point3d);
    get iModelId(): GuidString | undefined;
    // @internal (undocumented)
    protected initialize(name: string, props: IModelProps): void;
    abstract get isBriefcase(): boolean;
    get isGeoLocated(): boolean;
    // (undocumented)
    abstract get isOpen(): boolean;
    abstract get isSnapshot(): boolean;
    get iTwinId(): GuidString | undefined;
    // @internal (undocumented)
    protected _iTwinId?: GuidString;
    get key(): string;
    get name(): string;
    set name(name: string);
    readonly onEcefLocationChanged: BeEvent<(previousLocation: EcefLocation | undefined) => void>;
    readonly onGeographicCoordinateSystemChanged: BeEvent<(previousGCS: GeographicCRS | undefined) => void>;
    readonly onGlobalOriginChanged: BeEvent<(previousOrigin: Point3d) => void>;
    readonly onNameChanged: BeEvent<(previousName: string) => void>;
    readonly onProjectExtentsChanged: BeEvent<(previousExtents: AxisAlignedBox3d) => void>;
    readonly onRootSubjectChanged: BeEvent<(previousSubject: RootSubjectProps) => void>;
    get openMode(): OpenMode;
    // (undocumented)
    protected _openMode: OpenMode;
    get projectExtents(): AxisAlignedBox3d;
    set projectExtents(extents: AxisAlignedBox3d);
    static readonly repositoryModelId: Id64String;
    get rootSubject(): RootSubjectProps;
    set rootSubject(subject: RootSubjectProps);
    static readonly rootSubjectId: Id64String;
    setEcefLocation(ecef: EcefLocationProps): void;
    setGeographicCoordinateSystem(geoCRS: GeographicCRSProps): void;
    spatialToCartographicFromEcef(spatial: XYAndZ, result?: Cartographic): Cartographic;
    spatialToEcef(spatial: XYAndZ, result?: Point3d): Point3d;
    // @internal (undocumented)
    toJSON(): IModelConnectionProps;
}

// @public
export type IModelConnectionProps = IModelProps & IModelRpcProps;

// @beta
export interface IModelCoordinatesRequestProps {
    // (undocumented)
    geoCoords: XYZProps[];
    // (undocumented)
    source: string;
}

// @beta (undocumented)
export interface IModelCoordinatesResponseProps {
    // (undocumented)
    fromCache: number;
    // (undocumented)
    iModelCoords: PointWithStatus[];
}

// @public @deprecated
export interface IModelEncryptionProps {
    readonly password?: string;
}

// @public
export class IModelError extends BentleyError {
    constructor(errorNumber: number | IModelStatus | DbResult | BentleyStatus | BriefcaseStatus | RepositoryStatus | ChangeSetStatus | RpcInterfaceStatus, message: string, getMetaData?: GetMetaDataFunction);
}

// @public
export class IModelNotFoundResponse extends RpcNotFoundResponse {
    // (undocumented)
    isIModelNotFoundResponse: boolean;
    // (undocumented)
    message: string;
}

// @public
export interface IModelProps {
    readonly ecefLocation?: EcefLocationProps;
    readonly geographicCoordinateSystem?: GeographicCRSProps;
    readonly globalOrigin?: XYZProps;
    readonly name?: string;
    readonly projectExtents?: Range3dProps;
    readonly rootSubject: RootSubjectProps;
}

// @internal
export abstract class IModelReadRpcInterface extends RpcInterface {
    // (undocumented)
    cancelSnap(_iModelToken: IModelRpcProps, _sessionId: string): Promise<void>;
    // (undocumented)
    getAllCodeSpecs(_iModelToken: IModelRpcProps): Promise<any[]>;
    // (undocumented)
    getClassHierarchy(_iModelToken: IModelRpcProps, _startClassName: string): Promise<string[]>;
    static getClient(): IModelReadRpcInterface;
    static getClientForRouting(token: RpcRoutingToken): IModelReadRpcInterface;
    // (undocumented)
    getConnectionProps(_iModelToken: IModelRpcOpenProps): Promise<IModelConnectionProps>;
    // (undocumented)
    getCustomViewState3dData(_iModelToken: IModelRpcProps, _options: CustomViewState3dCreatorOptions): Promise<CustomViewState3dProps>;
    // (undocumented)
    getDefaultViewId(_iModelToken: IModelRpcProps): Promise<Id64String>;
    // (undocumented)
    getElementProps(_iModelToken: IModelRpcProps, _elementIds: Id64String[]): Promise<ElementProps[]>;
    // (undocumented)
    getGeoCoordinatesFromIModelCoordinates(_iModelToken: IModelRpcProps, _props: GeoCoordinatesRequestProps): Promise<GeoCoordinatesResponseProps>;
    // (undocumented)
    getGeometryContainment(_iModelToken: IModelRpcProps, _props: GeometryContainmentRequestProps): Promise<GeometryContainmentResponseProps>;
    // (undocumented)
    getGeometrySummary(_iModelToken: IModelRpcProps, _props: GeometrySummaryRequestProps): Promise<string>;
    // (undocumented)
    getIModelCoordinatesFromGeoCoordinates(_iModelToken: IModelRpcProps, _props: IModelCoordinatesRequestProps): Promise<IModelCoordinatesResponseProps>;
    // (undocumented)
    getMassProperties(_iModelToken: IModelRpcProps, _props: MassPropertiesRequestProps): Promise<MassPropertiesResponseProps>;
    // (undocumented)
    getMassPropertiesPerCandidate(_iModelToken: IModelRpcProps, _props: MassPropertiesPerCandidateRequestProps): Promise<MassPropertiesPerCandidateResponseProps[]>;
    // (undocumented)
    getModelProps(_iModelToken: IModelRpcProps, _modelIds: Id64String[]): Promise<ModelProps[]>;
    // (undocumented)
    getToolTipMessage(_iModelToken: IModelRpcProps, _elementId: string): Promise<string[]>;
    // (undocumented)
    getViewStateData(_iModelToken: IModelRpcProps, _viewDefinitionId: string, _options?: ViewStateLoadProps): Promise<ViewStateProps>;
    // @deprecated (undocumented)
    getViewThumbnail(_iModelToken: IModelRpcProps, _viewId: string): Promise<Uint8Array>;
    // (undocumented)
    hydrateViewState(_iModelToken: IModelRpcProps, _options: HydrateViewStateRequestProps): Promise<HydrateViewStateResponseProps>;
    static readonly interfaceName = "IModelReadRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    loadElementProps(_iModelToken: IModelRpcProps, _elementIdentifier: Id64String | GuidString | CodeProps, _options?: ElementLoadOptions): Promise<ElementProps | undefined>;
    // (undocumented)
    queryBlob(_iModelToken: IModelRpcProps, _request: DbBlobRequest): Promise<DbBlobResponse>;
    // (undocumented)
    queryElementProps(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<ElementProps[]>;
    // (undocumented)
    queryEntityIds(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<Id64String[]>;
    // (undocumented)
    queryModelProps(_iModelToken: IModelRpcProps, _params: EntityQueryParams): Promise<ModelProps[]>;
    // (undocumented)
    queryModelRanges(_iModelToken: IModelRpcProps, _modelIds: Id64String[]): Promise<Range3dProps[]>;
    // (undocumented)
    queryRows(_iModelToken: IModelRpcProps, _request: DbQueryRequest): Promise<DbQueryResponse>;
    // (undocumented)
    querySubCategories(_iModelToken: IModelRpcProps, _categoryIds: CompressedId64Set): Promise<SubCategoryResultRow[]>;
    // (undocumented)
    queryTextureData(_iModelToken: IModelRpcProps, _textureLoadProps: TextureLoadProps): Promise<TextureData | undefined>;
    // (undocumented)
    readFontJson(_iModelToken: IModelRpcProps): Promise<FontMapProps>;
    // (undocumented)
    requestSnap(_iModelToken: IModelRpcProps, _sessionId: string, _props: SnapRequestProps): Promise<SnapResponseProps>;
}

// @public
export interface IModelRpcOpenProps {
    readonly changeset?: ChangesetIdWithIndex;
    readonly iModelId?: GuidString;
    readonly iTwinId?: GuidString;
}

// @public
export interface IModelRpcProps extends IModelRpcOpenProps {
    readonly key: string;
}

export { IModelStatus }

// @public (undocumented)
export abstract class IModelTileRpcInterface extends RpcInterface {
    // @internal
    generateTileContent(_rpcProps: IModelRpcProps, _treeId: string, _contentId: string, _guid: string | undefined): Promise<TileContentSource>;
    // (undocumented)
    static getClient(): IModelTileRpcInterface;
    // @beta
    getTileCacheContainerUrl(_tokenProps: IModelRpcProps, _id: CloudStorageContainerDescriptor): Promise<CloudStorageContainerUrl>;
    static readonly interfaceName = "IModelTileRpcInterface";
    static interfaceVersion: string;
    // @internal @deprecated
    isUsingExternalTileCache(): Promise<boolean>;
    // @internal
    purgeTileTrees(_tokenProps: IModelRpcProps, _modelIds: Id64Array | undefined): Promise<void>;
    // @internal (undocumented)
    queryVersionInfo(): Promise<TileVersionInfo>;
    // @internal
    requestElementGraphics(_rpcProps: IModelRpcProps, _request: ElementGraphicsRequestProps): Promise<Uint8Array | undefined>;
    // @internal (undocumented)
    requestTileTreeProps(_tokenProps: IModelRpcProps, _id: string): Promise<IModelTileTreeProps>;
    // @internal
    retrieveTileContent(_rpcProps: IModelRpcProps, _key: TileContentIdentifier): Promise<Uint8Array>;
}

// @internal
export type IModelTileTreeId = PrimaryTileTreeId | ClassifierTileTreeId;

// @internal
export function iModelTileTreeIdToString(modelId: Id64String, treeId: IModelTileTreeId, options: TileOptions): string;

// @internal
export interface IModelTileTreeProps extends TileTreeProps {
    contentIdQualifier?: string;
    formatVersion?: number;
    geometryGuid?: GuidString;
    maxInitialTilesToSkip?: number;
    tileScreenSize?: number;
    transformNodeRanges?: Array<Range3dProps & {
        id: number;
    }>;
}

// @public
export class IModelVersion {
    static asOfChangeSet(changesetId: string): IModelVersion;
    static first(): IModelVersion;
    static fromJSON(json: IModelVersionProps): IModelVersion;
    getAsOfChangeSet(): ChangesetId | undefined;
    getName(): string | undefined;
    get isFirst(): boolean;
    get isLatest(): boolean;
    static latest(): IModelVersion;
    static named(versionName: string): IModelVersion;
    // (undocumented)
    toJSON(): IModelVersionProps;
}

// @public
export type IModelVersionProps = {
    first: true;
    latest?: never;
    afterChangeSetId?: never;
    versionName?: never;
} | {
    latest: true;
    first?: never;
    afterChangeSetId?: never;
    versionName?: never;
} | {
    afterChangeSetId: string;
    first?: never;
    latest?: never;
    versionName?: never;
} | {
    versionName: string;
    first?: never;
    latest?: never;
    afterChangeSetId?: never;
};

// @public
export interface InformationPartitionElementProps extends ElementProps {
    // (undocumented)
    description?: string;
}

// @internal (undocumented)
export const initializeRpcRequest: () => void;

// @internal (undocumented)
export const INSTANCE: unique symbol;

// @internal (undocumented)
export interface InterceptedRpcRequest {
    // (undocumented)
    context: {
        [index: string]: string;
    };
    // (undocumented)
    definition: {
        interfaceName: string;
        interfaceVersion: string;
    };
    // (undocumented)
    operation: string;
    // (undocumented)
    parameters: any[];
}

// @beta
export enum InternetConnectivityStatus {
    // (undocumented)
    Offline = 1,
    // (undocumented)
    Online = 0
}

// @public
export const Interpolation: {
    Linear: (v: any, k: number) => number;
    Bezier: (v: any, k: number) => number;
    CatmullRom: (v: any, k: number) => number;
    Utils: {
        Linear: (p0: number, p1: number, t: number) => number;
        Bernstein: (n: number, i: number) => number;
        Factorial: (n: number) => number;
        CatmullRom: (p0: number, p1: number, p2: number, p3: number, t: number) => number;
    };
};

// @public (undocumented)
export type InterpolationFunction = (v: any, k: number) => number;

// @internal (undocumented)
export enum IpcAppChannel {
    // (undocumented)
    AppNotify = "ipcApp-notify",
    // (undocumented)
    EditingScope = "editing-scope",
    // (undocumented)
    Functions = "ipc-app",
    // (undocumented)
    Txns = "txns"
}

// @internal
export interface IpcAppFunctions {
    cancelElementGraphicsRequests: (key: string, _requestIds: string[]) => Promise<void>;
    cancelTileContentRequests: (tokenProps: IModelRpcProps, _contentIds: TileTreeContentIds[]) => Promise<void>;
    closeIModel: (key: string) => Promise<void>;
    getRedoString: (key: string) => Promise<string>;
    getUndoString: (key: string) => Promise<string>;
    hasPendingTxns: (key: string) => Promise<boolean>;
    // (undocumented)
    isGraphicalEditingSupported: (key: string) => Promise<boolean>;
    isRedoPossible: (key: string) => Promise<boolean>;
    isUndoPossible: (key: string) => Promise<boolean>;
    log: (_timestamp: number, _level: LogLevel, _category: string, _message: string, _metaData?: any) => Promise<void>;
    openBriefcase: (_args: OpenBriefcaseProps) => Promise<IModelConnectionProps>;
    openStandalone: (_filePath: string, _openMode: OpenMode, _opts?: StandaloneOpenOptions) => Promise<IModelConnectionProps>;
    pullChanges: (key: string, toIndex?: ChangesetIndex) => Promise<ChangesetIndexAndId>;
    pushChanges: (key: string, description: string) => Promise<ChangesetIndexAndId>;
    queryConcurrency: (pool: "io" | "cpu") => Promise<number>;
    // (undocumented)
    reinstateTxn: (key: string) => Promise<IModelStatus>;
    // (undocumented)
    restartTxnSession: (key: string) => Promise<void>;
    // (undocumented)
    reverseAllTxn: (key: string) => Promise<IModelStatus>;
    // (undocumented)
    reverseTxns: (key: string, numOperations: number) => Promise<IModelStatus>;
    saveChanges: (key: string, description?: string) => Promise<void>;
    // (undocumented)
    toggleGraphicalEditingScope: (key: string, _startSession: boolean) => Promise<boolean>;
}

// @internal
export interface IpcAppNotifications {
    // (undocumented)
    notifyApp: () => void;
}

// @internal
export type IpcInvokeReturn = {
    result: any;
    error?: never;
} | {
    result?: never;
    error: {
        name: string;
        message: string;
        errorNumber: number;
        stack?: string;
    };
};

// @public
export type IpcListener = (evt: Event, ...args: any[]) => void;

// @internal (undocumented)
export abstract class IpcSession {
    // (undocumented)
    static get active(): IpcSession | undefined;
    // (undocumented)
    abstract handleRpc(info: InterceptedRpcRequest): Promise<any>;
    // (undocumented)
    static start(session: IpcSession): void;
    // (undocumented)
    static stop(): void;
}

// @public
export interface IpcSocket {
    addListener: (channel: string, listener: IpcListener) => RemoveFunction;
    removeListener: (channel: string, listener: IpcListener) => void;
    send: (channel: string, ...data: any[]) => void;
}

// @public
export interface IpcSocketBackend extends IpcSocket {
    handle: (channel: string, handler: (...args: any[]) => Promise<any>) => RemoveFunction;
}

// @public
export interface IpcSocketFrontend extends IpcSocket {
    invoke: (channel: string, ...args: any[]) => Promise<any>;
}

// @internal (undocumented)
export abstract class IpcWebSocket implements IpcSocket {
    constructor();
    // (undocumented)
    addListener(channel: string, listener: IpcListener): RemoveFunction;
    // (undocumented)
    protected _channels: Map<string, Set<IpcListener>>;
    // (undocumented)
    static receivers: Set<(evt: Event, message: IpcWebSocketMessage) => void>;
    // (undocumented)
    removeListener(channel: string, listener: IpcListener): void;
    // (undocumented)
    abstract send(channel: string, ...data: any[]): void;
    // (undocumented)
    static transport: IpcWebSocketTransport;
}

// @internal (undocumented)
export class IpcWebSocketBackend extends IpcWebSocket implements IpcSocketBackend {
    constructor();
    // (undocumented)
    handle(channel: string, handler: (event: Event, methodName: string, ...args: any[]) => Promise<any>): RemoveFunction;
    // (undocumented)
    send(channel: string, ...data: any[]): void;
}

// @internal (undocumented)
export class IpcWebSocketFrontend extends IpcWebSocket implements IpcSocketFrontend {
    constructor();
    // (undocumented)
    invoke(channel: string, methodName: string, ...args: any[]): Promise<any>;
    // (undocumented)
    send(channel: string, ...data: any[]): void;
}

// @internal (undocumented)
export interface IpcWebSocketMessage {
    // (undocumented)
    channel: string;
    // (undocumented)
    data?: any[];
    // (undocumented)
    method?: string;
    // (undocumented)
    request?: number;
    // (undocumented)
    response?: number;
    // (undocumented)
    sequence: number;
    // (undocumented)
    type: IpcWebSocketMessageType;
}

// @internal (undocumented)
export namespace IpcWebSocketMessage {
    // (undocumented)
    export function duplicate(): IpcWebSocketMessage;
    // (undocumented)
    export function internal(): IpcWebSocketMessage;
    // (undocumented)
    export function skip(message: IpcWebSocketMessage): boolean;
}

// @internal (undocumented)
export enum IpcWebSocketMessageType {
    // (undocumented)
    Duplicate = 5,
    // (undocumented)
    Internal = 4,
    // (undocumented)
    Invoke = 2,
    // (undocumented)
    Push = 1,
    // (undocumented)
    Response = 3,
    // (undocumented)
    Send = 0
}

// @internal (undocumented)
export abstract class IpcWebSocketTransport {
    // (undocumented)
    protected notifyClose(connection: any): void;
    // (undocumented)
    protected notifyIncoming(data: any, connection: any): Promise<IpcWebSocketMessage>;
    // (undocumented)
    abstract send(message: IpcWebSocketMessage): void;
    // (undocumented)
    protected serialize(data: IpcWebSocketMessage): any[];
    // (undocumented)
    protected unwrap(data: any): any;
}

// @internal
export function isKnownTileFormat(format: number): boolean;

// @public
export function isPlacement2dProps(props: PlacementProps): props is Placement2dProps;

// @public
export function isPlacement3dProps(props: PlacementProps): props is Placement3dProps;

// @public
export function isPowerOfTwo(num: number): boolean;

// @internal (undocumented)
export function isValidImageSourceFormat(format: ImageSourceFormat): boolean;

// @internal
export const iTwinChannel: (channel: string) => string;

// @public
export interface JsonGeometryStream {
    data: GeometryStreamProps;
    format: "json";
}

// @internal
export interface LegacyAnalysisStyleProps {
    // (undocumented)
    displacementChannelName?: string;
    // (undocumented)
    displacementScale?: number;
    // (undocumented)
    normalChannelName?: string;
    // (undocumented)
    scalarChannelName?: string;
    // (undocumented)
    scalarRange?: Range1dProps;
    // (undocumented)
    scalarThematicSettings?: ThematicGradientSettingsProps;
}

// @internal
export interface LightLocationProps extends GeometricElement3dProps {
    // (undocumented)
    enabled?: boolean;
}

// @public
export class LightSettings {
    // (undocumented)
    readonly ambient: AmbientLight;
    clone(changed?: LightSettingsProps): LightSettings;
    // (undocumented)
    equals(rhs: LightSettings): boolean;
    // (undocumented)
    readonly fresnel: FresnelSettings;
    // (undocumented)
    static fromJSON(props?: LightSettingsProps): LightSettings;
    // (undocumented)
    readonly hemisphere: HemisphereLights;
    readonly numCels: number;
    readonly portraitIntensity: number;
    // (undocumented)
    readonly solar: SolarLight;
    // (undocumented)
    readonly specularIntensity: number;
    // (undocumented)
    toJSON(): LightSettingsProps | undefined;
}

// @public
export interface LightSettingsProps {
    ambient?: AmbientLightProps;
    fresnel?: FresnelSettingsProps;
    hemisphere?: HemisphereLightsProps;
    numCels?: number;
    portrait?: {
        intensity?: number;
    };
    solar?: SolarLightProps;
    specularIntensity?: number;
}

// @public
export enum LinePixels {
    Code0 = 0,
    Code1 = 2155905152,
    Code2 = 4177066232,
    Code3 = 4292935648,
    Code4 = 4262526480,
    Code5 = 3772834016,
    Code6 = 4169726088,
    Code7 = 4279828248,
    HiddenLine = 3435973836,
    Invalid = -1,
    Invisible = 1,
    Solid = 0
}

// @public (undocumented)
export namespace LineStyle {
    export class Info {
        constructor(styleId: Id64String, styleMod?: Modifier);
        clone(): Info;
        // (undocumented)
        equals(other: Info): boolean;
        // (undocumented)
        styleId: Id64String;
        // (undocumented)
        styleMod?: Modifier;
    }
    export class Modifier implements ModifierProps {
        constructor(props: ModifierProps);
        // (undocumented)
        applyTransform(transform: Transform): boolean;
        // (undocumented)
        centerPhase?: boolean;
        clone(): Modifier;
        // (undocumented)
        dashScale?: number;
        // (undocumented)
        distPhase?: number;
        // (undocumented)
        endWidth?: number;
        equals(other: Modifier): boolean;
        // (undocumented)
        fractPhase?: number;
        // (undocumented)
        gapScale?: number;
        // (undocumented)
        normal?: Vector3d;
        // (undocumented)
        physicalWidth?: boolean;
        // (undocumented)
        rotation?: YawPitchRollAngles;
        // (undocumented)
        scale?: number;
        // (undocumented)
        segmentMode?: boolean;
        // (undocumented)
        startWidth?: number;
    }
    export interface ModifierProps {
        centerPhase?: boolean;
        dashScale?: number;
        distPhase?: number;
        endWidth?: number;
        fractPhase?: number;
        gapScale?: number;
        normal?: XYZProps;
        physicalWidth?: boolean;
        rotation?: YawPitchRollProps;
        scale?: number;
        segmentMode?: boolean;
        startWidth?: number;
    }
}

// @public
export interface LineStyleProps extends DefinitionElementProps {
    data: string;
    // (undocumented)
    description?: string;
}

// @public
export type LocalAlignedBox3d = Range3d;

// @public
export interface LocalBriefcaseProps {
    readonly briefcaseId: BriefcaseId;
    readonly changeset: ChangesetIdWithIndex;
    readonly fileName: LocalFileName;
    readonly fileSize: number;
    readonly iModelId: GuidString;
    readonly iTwinId: GuidString;
}

// @public (undocumented)
export type LocalDirName = string;

// @public (undocumented)
export type LocalFileName = string;

// @public
export interface Localization {
    changeLanguage(language: string): Promise<void>;
    getEnglishString(namespace: string, key: string | string[], options?: TranslationOptions): string;
    getLanguageList(): readonly string[];
    getLocalizedKeys(inputString: string): string;
    getLocalizedString(key: string | string[], options?: TranslationOptions): string;
    getLocalizedStringWithNamespace(namespace: string, key: string | string[], options?: TranslationOptions): string;
    // @internal (undocumented)
    getNamespacePromise(name: string): Promise<void> | undefined;
    initialize(namespaces: string[]): Promise<void>;
    registerNamespace(namespace: string): Promise<void>;
    // @internal (undocumented)
    unregisterNamespace(namespace: string): void;
}

export { LogFunction }

// @public
export interface MapImageryProps {
    // (undocumented)
    backgroundBase?: BaseLayerProps;
    // (undocumented)
    backgroundLayers?: MapLayerProps[];
    // (undocumented)
    overlayLayers?: MapLayerProps[];
}

// @public
export class MapImagerySettings {
    get backgroundBase(): BaseLayerSettings;
    set backgroundBase(base: BaseLayerSettings);
    // (undocumented)
    get backgroundLayers(): MapLayerSettings[];
    // @internal
    get baseTransparency(): number;
    // @internal (undocumented)
    static createFromJSON(imageryJson?: MapImageryProps, mapProps?: DeprecatedBackgroundMapProps): MapImagerySettings;
    static fromJSON(imageryJson?: MapImageryProps): MapImagerySettings;
    // (undocumented)
    get overlayLayers(): MapLayerSettings[];
    // (undocumented)
    toJSON(): MapImageryProps;
}

// @public
export interface MapLayerKey {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public
export type MapLayerProps = ImageMapLayerProps | ModelMapLayerProps;

// @public
export abstract class MapLayerSettings {
    // @internal
    protected constructor(name: string, visible?: boolean, transparency?: number, transparentBackground?: boolean);
    // (undocumented)
    abstract get allSubLayersInvisible(): boolean;
    // (undocumented)
    abstract clone(changedProps: Partial<MapLayerProps>): MapLayerSettings;
    // @internal (undocumented)
    protected cloneProps(changedProps: Partial<MapLayerProps>): CommonMapLayerProps;
    // @internal (undocumented)
    displayMatches(other: MapLayerSettings): boolean;
    static fromJSON(props: MapLayerProps): MapLayerSettings;
    // @internal (undocumented)
    matchesNameAndSource(name: string, source: string): boolean;
    // (undocumented)
    readonly name: string;
    abstract get source(): string;
    // (undocumented)
    abstract toJSON(): MapLayerProps;
    // @internal (undocumented)
    protected _toJSON(): CommonMapLayerProps;
    // (undocumented)
    readonly transparency: number;
    // (undocumented)
    readonly transparentBackground: boolean;
    // (undocumented)
    readonly visible: boolean;
}

// @public
export interface MapSubLayerProps {
    // (undocumented)
    children?: SubLayerId[];
    // (undocumented)
    id?: SubLayerId;
    // (undocumented)
    name: string;
    // (undocumented)
    parent?: SubLayerId;
    // (undocumented)
    title?: string;
    // (undocumented)
    visible?: boolean;
}

// @public
export class MapSubLayerSettings {
    constructor(name: string, title?: string, visible?: boolean, id?: SubLayerId, parent?: SubLayerId, children?: SubLayerId[]);
    readonly children?: SubLayerId[];
    clone(changedProps: Partial<MapSubLayerProps>): MapSubLayerSettings;
    // @internal (undocumented)
    displayMatches(other: MapSubLayerSettings): boolean;
    static fromJSON(json: MapSubLayerProps): MapSubLayerSettings;
    readonly id: SubLayerId;
    get idString(): string;
    get isLeaf(): boolean;
    get isNamed(): boolean;
    get isUnnamedGroup(): boolean;
    readonly name: string;
    readonly parent?: SubLayerId;
    readonly title?: string;
    // (undocumented)
    toJSON(): MapSubLayerProps;
    readonly visible: boolean;
}

// @public
export function mapToGeoServiceStatus(s: GeoCoordStatus): GeoServiceStatus;

// @internal (undocumented)
export interface MarshalingBinaryMarker {
    // (undocumented)
    chunks: number;
    // (undocumented)
    index: number;
    // (undocumented)
    isBinary: true;
    // (undocumented)
    size: number;
}

// @internal (undocumented)
export namespace MarshalingBinaryMarker {
    // (undocumented)
    export function createDefault(): MarshalingBinaryMarker;
}

// @public
export enum MassPropertiesOperation {
    AccumulateAreas = 1,
    AccumulateLengths = 0,
    AccumulateVolumes = 2
}

// @public
export interface MassPropertiesPerCandidateRequestProps {
    // (undocumented)
    candidates: CompressedId64Set;
    // (undocumented)
    operations: MassPropertiesOperation[];
}

// @public
export interface MassPropertiesPerCandidateResponseProps extends MassPropertiesResponseProps {
    // (undocumented)
    candidate: Id64String;
}

// @public
export interface MassPropertiesRequestProps {
    // (undocumented)
    candidates?: Id64Array;
    // (undocumented)
    operation: MassPropertiesOperation;
}

// @public
export interface MassPropertiesResponseProps {
    area?: number;
    centroid?: XYZProps;
    ixy?: number;
    ixz?: number;
    iyz?: number;
    length?: number;
    moments?: XYZProps;
    perimeter?: number;
    status: BentleyStatus;
    volume?: number;
}

// @public
export interface MaterialProps {
    materialId?: Id64String;
    // @internal (undocumented)
    origin?: XYZProps;
    // @internal (undocumented)
    rotation?: YawPitchRollProps;
    // @internal (undocumented)
    size?: XYZProps;
}

// @internal (undocumented)
export class MeshEdge {
    constructor(index0?: number, index1?: number);
    // (undocumented)
    compareTo(other: MeshEdge): number;
    // (undocumented)
    indices: number[];
}

// @internal (undocumented)
export class MeshEdges {
    constructor();
    // (undocumented)
    polylines: MeshPolylineList;
    // (undocumented)
    silhouette: MeshEdge[];
    // (undocumented)
    silhouetteNormals: OctEncodedNormalPair[];
    // (undocumented)
    visible: MeshEdge[];
}

// @internal (undocumented)
export class MeshPolyline {
    constructor(indices?: number[]);
    // (undocumented)
    addIndex(index: number): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly indices: number[];
}

// @internal (undocumented)
export class MeshPolylineList extends Array<MeshPolyline> {
    constructor(...args: MeshPolyline[]);
}

// @public
export class ModelClipGroup {
    readonly clip?: ClipVector;
    clone(): ModelClipGroup;
    static create(clip: ClipVector | undefined, models?: Id64Array): ModelClipGroup;
    static fromJSON(props: ModelClipGroupProps): ModelClipGroup;
    includesModel(modelId: Id64String): boolean;
    readonly models?: Id64Array;
    toJSON(): ModelClipGroupProps;
}

// @public
export interface ModelClipGroupProps {
    clip?: ClipVectorProps;
    models?: Id64Array;
}

// @public
export class ModelClipGroups {
    constructor(groups?: ModelClipGroup[]);
    clone(): ModelClipGroups;
    findGroup(modelId: Id64String): ModelClipGroup | undefined;
    findGroupIndex(modelId: Id64String): number;
    static fromJSON(props: ModelClipGroupProps[] | undefined): ModelClipGroups;
    getClipForModel(modelId: Id64String): ClipVector | undefined;
    readonly groups: ModelClipGroup[];
    toJSON(): ModelClipGroupProps[];
}

// @public
export interface ModelGeometryChanges {
    readonly elements: Iterable<ElementGeometryChange>;
    readonly geometryGuid: GuidString;
    readonly id: Id64String;
    readonly range: Range3d;
}

// @public
export namespace ModelGeometryChanges {
    export function findByModelId(changes: Iterable<ModelGeometryChanges>, modelId: Id64String): ModelGeometryChanges | undefined;
    export function fromJSON(props: ModelGeometryChangesProps): ModelGeometryChanges;
    export function iterable(modelChanges: ModelGeometryChangesProps[]): Iterable<ModelGeometryChanges>;
    export function iterator(modelChanges: ModelGeometryChangesProps[]): Iterator<ModelGeometryChanges>;
}

// @public
export interface ModelGeometryChangesProps {
    readonly deleted?: CompressedId64Set;
    readonly guid: GuidString;
    readonly id: Id64String;
    readonly inserted?: ElementIdsAndRangesProps;
    readonly range: Range3dProps;
    readonly updated?: ElementIdsAndRangesProps;
}

// @public
export interface ModelIdAndGeometryGuid {
    guid: GuidString;
    id: Id64String;
}

// @public
export interface ModelLoadProps {
    // (undocumented)
    code?: CodeProps;
    // (undocumented)
    id?: Id64String;
}

// @public
export interface ModelMapLayerProps extends CommonMapLayerProps {
    // @internal (undocumented)
    accessKey?: never;
    // @internal (undocumented)
    formatId?: never;
    modelId: Id64String;
    // @internal (undocumented)
    subLayers?: never;
    // @internal (undocumented)
    url?: never;
}

// @public
export class ModelMapLayerSettings extends MapLayerSettings {
    // @internal
    protected constructor(modelId: Id64String, name: string, visible?: boolean, transparency?: number, transparentBackground?: boolean);
    get allSubLayersInvisible(): boolean;
    clone(changedProps: Partial<ModelMapLayerProps>): ModelMapLayerSettings;
    // @internal (undocumented)
    protected cloneProps(changedProps: Partial<ModelMapLayerProps>): ModelMapLayerProps;
    // @internal (undocumented)
    displayMatches(other: MapLayerSettings): boolean;
    static fromJSON(json: ModelMapLayerProps): ModelMapLayerSettings;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    get source(): string;
    toJSON(): ModelMapLayerProps;
}

// @public
export interface ModelPlanarClipMaskArgs extends BasicPlanarClipMaskArgs {
    // @internal (undocumented)
    elementIds?: never;
    // @internal (undocumented)
    exclude?: never;
    modelIds?: Iterable<Id64String>;
    // @internal (undocumented)
    priority?: never;
    // @internal (undocumented)
    subCategoryIds?: never;
}

// @public
export interface ModelProps extends EntityProps {
    // (undocumented)
    isPrivate?: boolean;
    // (undocumented)
    isTemplate?: boolean;
    // (undocumented)
    jsonProperties?: any;
    // (undocumented)
    modeledElement: RelatedElementProps;
    // (undocumented)
    name?: string;
    // (undocumented)
    parentModel?: Id64String;
}

// @public
export interface ModelQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
    // (undocumented)
    wantTemplate?: boolean;
}

// @public
export interface ModelSelectorProps extends DefinitionElementProps {
    // (undocumented)
    models: Id64Array;
}

// @public
export enum MonochromeMode {
    Flat = 0,
    Scaled = 1
}

// @internal (undocumented)
export const nativeAppChannel = "nativeApp";

// @internal
export interface NativeAppFunctions {
    acquireNewBriefcaseId(_iModelId: GuidString): Promise<number>;
    checkInternetConnectivity(): Promise<InternetConnectivityStatus>;
    deleteBriefcaseFiles(_fileName: string): Promise<void>;
    downloadBriefcase(_requestProps: RequestNewBriefcaseProps, _reportProgress: boolean, _interval?: number): Promise<LocalBriefcaseProps>;
    getAccessToken: () => Promise<AccessToken | undefined>;
    getBriefcaseFileName(_props: BriefcaseProps): Promise<string>;
    getCachedBriefcases(_iModelId?: GuidString): Promise<LocalBriefcaseProps[]>;
    overrideInternetConnectivity(_overriddenBy: OverriddenBy, _status: InternetConnectivityStatus): Promise<void>;
    requestCancelDownloadBriefcase(_fileName: string): Promise<boolean>;
    storageGet(_storageId: string, _key: string): Promise<StorageValue | undefined>;
    storageGetValueType(_storageId: string, _key: string): Promise<"number" | "string" | "boolean" | "Uint8Array" | "null" | undefined>;
    storageKeys(_storageId: string): Promise<string[]>;
    storageMgrClose(_storageId: string, _deleteOnClose: boolean): Promise<void>;
    storageMgrNames(): Promise<string[]>;
    storageMgrOpen(_storageId: string): Promise<string>;
    storageRemove(_storageId: string, _key: string): Promise<void>;
    storageRemoveAll(_storageId: string): Promise<void>;
    storageSet(_storageId: string, _key: string, _value: StorageValue): Promise<void>;
}

// @internal
export interface NativeAppNotifications {
    // (undocumented)
    notifyInternetConnectivityChanged(status: InternetConnectivityStatus): void;
}

// @internal (undocumented)
export const nativeAppNotify = "nativeApp-notify";

// @public
export interface NavigationBindingValue {
    id: Id64String;
    relClassName?: string;
    relClassTableSpace?: string;
}

// @public
export interface NavigationValue {
    id: Id64String;
    relClassName?: string;
}

// @public
export function nextHighestPowerOfTwo(num: number): number;

// @internal
export function nextPoint3d64FromByteStream(stream: ByteStream, result?: Point3d): Point3d;

// @public
export class NoContentError extends IModelError {
    constructor();
}

// @internal (undocumented)
export class NonUniformColor {
    constructor(colors: Uint32Array, indices: number[], hasAlpha: boolean);
    // (undocumented)
    readonly colors: Uint32Array;
    // (undocumented)
    readonly indices: Uint16Array;
    // (undocumented)
    readonly isOpaque: boolean;
}

// @public
export enum Npc {
    _000 = 0,
    _001 = 4,
    _010 = 2,
    _011 = 6,
    _100 = 1,
    _101 = 5,
    _110 = 3,
    _111 = 7,
    CORNER_COUNT = 8,
    // (undocumented)
    LeftBottomFront = 4,
    // (undocumented)
    LeftBottomRear = 0,
    // (undocumented)
    LeftTopFront = 6,
    // (undocumented)
    LeftTopRear = 2,
    // (undocumented)
    RightBottomFront = 5,
    // (undocumented)
    RightBottomRear = 1,
    // (undocumented)
    RightTopFront = 7,
    // (undocumented)
    RightTopRear = 3
}

// @public
export const NpcCenter: Point3d;

// @public
export const NpcCorners: Point3d[];

// @public
export class OctEncodedNormal {
    constructor(val: number);
    decode(): Vector3d;
    static decodeValue(val: number, result?: Vector3d): Vector3d;
    static encode(vec: XYAndZ): number;
    static encodeXYZ(nx: number, ny: number, nz: number): number;
    static fromVector(val: XYAndZ): OctEncodedNormal;
    readonly value: number;
}

// @internal (undocumented)
export class OctEncodedNormalPair {
    constructor(first: OctEncodedNormal, second: OctEncodedNormal);
    // (undocumented)
    first: OctEncodedNormal;
    // (undocumented)
    second: OctEncodedNormal;
}

// @internal
export interface OpenAPIContentMap {
    // (undocumented)
    [index: string]: OpenAPIMediaType;
}

// @internal
export interface OpenAPIDocument {
    // (undocumented)
    info: OpenAPIInfo;
    // (undocumented)
    openapi: "3.0.0";
    // (undocumented)
    paths: OpenAPIPaths;
}

// @internal
export interface OpenAPIEncoding {
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    style?: string;
}

// @public
export interface OpenAPIInfo {
    // (undocumented)
    title: string;
    // (undocumented)
    version: string;
}

// @internal
export interface OpenAPIMediaType {
    // (undocumented)
    schema?: OpenAPISchema;
}

// @internal
export interface OpenAPIOperation {
    // (undocumented)
    operationId?: string;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    requestBody?: OpenAPIRequestBody;
    // (undocumented)
    responses: OpenAPIResponses;
    // (undocumented)
    summary?: string;
}

// @internal
export interface OpenAPIParameter {
    // (undocumented)
    allowEmptyValue?: boolean;
    // (undocumented)
    allowReserved?: boolean;
    // (undocumented)
    content?: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    explode?: boolean;
    // (undocumented)
    in: "query" | "header" | "path" | "cookie";
    // (undocumented)
    name: string;
    // (undocumented)
    required?: boolean;
    // (undocumented)
    schema?: OpenAPISchema;
    // (undocumented)
    style?: "matrix" | "label" | "form" | "simple" | "spaceDelimited" | "pipeDelimited" | "deepObject";
}

// @internal
export interface OpenAPIPathItem {
    // (undocumented)
    delete?: OpenAPIOperation;
    // (undocumented)
    get?: OpenAPIOperation;
    // (undocumented)
    head?: OpenAPIOperation;
    // (undocumented)
    options?: OpenAPIOperation;
    // (undocumented)
    parameters?: OpenAPIParameter[];
    // (undocumented)
    patch?: OpenAPIOperation;
    // (undocumented)
    post?: OpenAPIOperation;
    // (undocumented)
    put?: OpenAPIOperation;
    // (undocumented)
    summary?: string;
    // (undocumented)
    trace?: OpenAPIOperation;
}

// @internal
export interface OpenAPIPaths {
    // (undocumented)
    [index: string]: OpenAPIPathItem;
}

// @internal
export interface OpenAPIRequestBody {
    // (undocumented)
    content: OpenAPIContentMap;
    // (undocumented)
    description?: string;
    // (undocumented)
    required?: boolean;
}

// @internal
export interface OpenAPIResponse {
    // (undocumented)
    content?: {
        [index: string]: OpenAPIMediaType;
    };
    // (undocumented)
    description: string;
}

// @internal
export interface OpenAPIResponses {
    // (undocumented)
    "200"?: OpenAPIResponse;
    // (undocumented)
    "301"?: OpenAPIResponse;
    // (undocumented)
    "302"?: OpenAPIResponse;
    // (undocumented)
    "400"?: OpenAPIResponse;
    // (undocumented)
    "404"?: OpenAPIResponse;
    // (undocumented)
    "500"?: OpenAPIResponse;
    // (undocumented)
    default?: OpenAPIResponse;
}

// @internal
export interface OpenAPISchema {
    // (undocumented)
    description?: string;
    // (undocumented)
    nullable?: boolean;
    // (undocumented)
    type?: "boolean" | "object" | "array" | "number" | "string";
}

// @public
export interface OpenBriefcaseOptions {
    readonly openAsReadOnly?: boolean;
}

// @public
export interface OpenBriefcaseProps extends IModelEncryptionProps, OpenDbKey {
    readonly fileName: LocalFileName;
    readonly readonly?: boolean;
}

// @public
export interface OpenDbKey {
    // (undocumented)
    readonly key?: string;
}

// @internal (undocumented)
export const OPERATION: unique symbol;

// @alpha
export interface OrbitGtBlobProps {
    // (undocumented)
    accountName: string;
    // (undocumented)
    blobFileName: string;
    // (undocumented)
    containerName: string;
    // (undocumented)
    rdsUrl?: string;
    // (undocumented)
    sasToken: string;
}

// @beta
export enum OverriddenBy {
    // (undocumented)
    Browser = 0,
    // (undocumented)
    User = 1
}

// @public
export interface OverrideElementAppearanceOptions extends OverrideFeatureAppearanceOptions {
    elementId: Id64String;
    // @internal (undocumented)
    modelId?: never;
    // @internal (undocumented)
    subCategoryId?: never;
}

// @public
export type OverrideFeatureAppearanceArgs = OverrideElementAppearanceOptions | OverrideModelAppearanceOptions | OverrideSubCategoryAppearanceOptions;

// @public
export interface OverrideFeatureAppearanceOptions {
    appearance: FeatureAppearance;
    onConflict?: "extend" | "subsume" | "replace" | "skip";
}

// @public
export interface OverrideModelAppearanceOptions extends OverrideFeatureAppearanceOptions {
    // @internal (undocumented)
    elementId?: never;
    modelId: Id64String;
    // @internal (undocumented)
    subCategoryId?: never;
}

// @public
export interface OverrideSubCategoryAppearanceOptions extends OverrideFeatureAppearanceOptions {
    // @internal (undocumented)
    elementId?: never;
    // @internal (undocumented)
    modelId?: never;
    subCategoryId: Id64String;
}

// @internal (undocumented)
export interface PackedFeature {
    // (undocumented)
    animationNodeId: number;
    // (undocumented)
    elementId: Id64.Uint32Pair;
    // (undocumented)
    geometryClass: GeometryClass;
    // (undocumented)
    subCategoryId: Id64.Uint32Pair;
}

// @internal
export class PackedFeatureTable {
    constructor(data: Uint32Array, modelId: Id64String, numFeatures: number, maxFeatures: number, type: BatchType, animationNodeIds?: Uint8Array | Uint16Array | Uint32Array);
    // (undocumented)
    get animationNodeIds(): Readonly<Uint8Array | Uint16Array | Uint32Array> | undefined;
    // (undocumented)
    readonly anyDefined: boolean;
    // (undocumented)
    get byteLength(): number;
    findElementId(featureIndex: number): Id64String | undefined;
    findFeature(featureIndex: number): Feature | undefined;
    // (undocumented)
    getAnimationNodeId(featureIndex: number): number;
    // (undocumented)
    getElementIdPair(featureIndex: number, out?: Id64.Uint32Pair): Id64.Uint32Pair;
    getFeature(featureIndex: number): Feature;
    // (undocumented)
    getPackedFeature(featureIndex: number): PackedFeature;
    // (undocumented)
    getSubCategoryIdPair(featureIndex: number): Id64.Uint32Pair;
    // (undocumented)
    get isClassifier(): boolean;
    // (undocumented)
    get isPlanarClassifier(): boolean;
    get isUniform(): boolean;
    // (undocumented)
    get isVolumeClassifier(): boolean;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly numFeatures: number;
    static pack(featureTable: FeatureTable): PackedFeatureTable;
    // (undocumented)
    populateAnimationNodeIds(computeNodeId: ComputeNodeId, maxNodeId: number): void;
    // (undocumented)
    readonly type: BatchType;
    get uniform(): Feature | undefined;
    unpack(): FeatureTable;
}

// @internal
export interface ParsedTileTreeIdAndContentId {
    // (undocumented)
    contentId: ContentIdSpec;
    // (undocumented)
    modelId: Id64String;
    // (undocumented)
    options: TileOptions;
    // (undocumented)
    treeId: IModelTileTreeId;
}

// @internal (undocumented)
export function parseTileTreeIdAndContentId(treeId: string, contentId: string): ParsedTileTreeIdAndContentId;

// @public
export interface PartReference {
    // (undocumented)
    part: {
        id: Id64String;
        readonly toLocal?: Transform;
    };
    // (undocumented)
    type: "partReference";
}

// @public
export type PersistentBackgroundMapProps = Omit<BackgroundMapProps, keyof DeprecatedBackgroundMapProps> & DeprecatedBackgroundMapProps;

// @public
export interface PersistentGraphicsRequestProps extends GraphicsRequestProps {
    readonly elementId: Id64String;
}

// @public
export interface PhysicalElementProps extends GeometricElement3dProps {
    // (undocumented)
    physicalMaterial?: RelatedElementProps;
}

// @public
export interface PhysicalTypeProps extends TypeDefinitionElementProps {
    physicalMaterial?: RelatedElementProps;
}

// @public
export type Placement = Placement2d | Placement3d;

// @public
export class Placement2d implements Placement2dProps {
    constructor(origin: Point2d, angle: Angle, bbox: ElementAlignedBox2d);
    // (undocumented)
    angle: Angle;
    // (undocumented)
    bbox: ElementAlignedBox2d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement2dProps): Placement2d;
    getWorldCorners(out?: Frustum): Frustum;
    get is3d(): boolean;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point2d;
    get rotation(): Matrix3d;
    setFrom(other: Placement2d): void;
    get transform(): Transform;
}

// @public
export interface Placement2dProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    bbox?: LowAndHighXY;
    // (undocumented)
    origin: XYProps;
}

// @public
export class Placement3d implements Placement3dProps {
    constructor(origin: Point3d, angles: YawPitchRollAngles, bbox: ElementAlignedBox3d);
    // (undocumented)
    angles: YawPitchRollAngles;
    // (undocumented)
    bbox: ElementAlignedBox3d;
    calculateRange(): AxisAlignedBox3d;
    static fromJSON(json?: Placement3dProps): Placement3d;
    getWorldCorners(out?: Frustum): Frustum;
    get is3d(): boolean;
    get isValid(): boolean;
    multiplyTransform(other: Transform): void;
    // (undocumented)
    origin: Point3d;
    get rotation(): Matrix3d;
    setFrom(other: Placement3d): void;
    get transform(): Transform;
}

// @public
export interface Placement3dProps {
    // (undocumented)
    angles: YawPitchRollProps;
    // (undocumented)
    bbox?: LowAndHighXYZ;
    // (undocumented)
    origin: XYZProps;
}

// @public (undocumented)
export type PlacementProps = Placement2dProps | Placement3dProps;

// @public
export enum PlanarClipMaskMode {
    ExcludeElements = 5,
    IncludeElements = 4,
    IncludeSubCategories = 3,
    Models = 2,
    None = 0,
    Priority = 1
}

// @public
export enum PlanarClipMaskPriority {
    BackgroundMap = -2048,
    DesignModel = 2048,
    GlobalRealityModel = -1024,
    RealityModel = 0
}

// @public
export interface PlanarClipMaskProps {
    invert?: boolean;
    mode: PlanarClipMaskMode;
    modelIds?: CompressedId64Set;
    priority?: number;
    subCategoryOrElementIds?: CompressedId64Set;
    transparency?: number;
}

// @public
export class PlanarClipMaskSettings {
    clone(changedProps?: PlanarClipMaskProps): PlanarClipMaskSettings;
    get compressedModelIds(): CompressedId64Set | undefined;
    static create(args: ModelPlanarClipMaskArgs | ElementPlanarClipMaskArgs | SubCategoryPlanarClipMaskArgs | PriorityPlanarClipMaskArgs): PlanarClipMaskSettings;
    static defaults: PlanarClipMaskSettings;
    // (undocumented)
    equals(other: PlanarClipMaskSettings): boolean;
    static fromJSON(json?: PlanarClipMaskProps): PlanarClipMaskSettings;
    readonly invert: boolean;
    get isValid(): boolean;
    readonly mode: PlanarClipMaskMode;
    readonly modelIds?: OrderedId64Iterable;
    readonly priority?: number;
    readonly subCategoryOrElementIds?: OrderedId64Iterable;
    toJSON(): PlanarClipMaskProps;
    readonly transparency?: number;
}

// @public
export class PlanProjectionSettings {
    // @internal
    constructor(props: PlanProjectionSettingsProps);
    clone(changedProps?: PlanProjectionSettingsProps): PlanProjectionSettings;
    readonly elevation?: number;
    readonly enforceDisplayPriority?: boolean;
    // (undocumented)
    static fromJSON(props: PlanProjectionSettingsProps | undefined): PlanProjectionSettings | undefined;
    readonly overlay: boolean;
    // (undocumented)
    toJSON(): PlanProjectionSettingsProps;
    readonly transparency?: number;
}

// @public
export interface PlanProjectionSettingsProps {
    elevation?: number;
    enforceDisplayPriority?: boolean;
    overlay?: boolean;
    transparency?: number;
}

// @internal
export class PntsHeader extends TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    readonly batchTableBinaryLength: number;
    // (undocumented)
    readonly batchTableJsonLength: number;
    // (undocumented)
    readonly featureTableBinaryLength: number;
    // (undocumented)
    readonly featureTableJsonLength: number;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    readonly length: number;
}

// @public
export type Point2dProps = number[];

// @beta
export interface PointWithStatus {
    // (undocumented)
    p: XYZProps;
    // (undocumented)
    s: GeoCoordStatus;
}

// @internal (undocumented)
export const POLICY: unique symbol;

// @internal (undocumented)
export class PolylineData {
    constructor(vertIndices?: number[], numIndices?: number);
    // (undocumented)
    init(polyline: MeshPolyline): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    numIndices: number;
    // (undocumented)
    reset(): void;
    // (undocumented)
    vertIndices: number[];
}

// @internal (undocumented)
export class PolylineEdgeArgs {
    constructor(lines?: PolylineData[]);
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(lines?: PolylineData[]): boolean;
    // (undocumented)
    get isValid(): boolean;
    // (undocumented)
    lines?: PolylineData[];
    // (undocumented)
    get numLines(): number;
}

// @internal
export class PolylineFlags {
    constructor(is2d?: boolean, isPlanar?: boolean, isDisjoint?: boolean, type?: PolylineTypeFlags);
    // (undocumented)
    clone(): PolylineFlags;
    // (undocumented)
    equals(other: PolylineFlags): boolean;
    // (undocumented)
    initDefaults(): void;
    // (undocumented)
    is2d: boolean;
    // (undocumented)
    get isAnyEdge(): boolean;
    // (undocumented)
    isDisjoint: boolean;
    // (undocumented)
    get isNormalEdge(): boolean;
    // (undocumented)
    get isOutlineEdge(): boolean;
    // (undocumented)
    isPlanar: boolean;
    pack(): number;
    // (undocumented)
    setIsNormalEdge(): void;
    // (undocumented)
    setIsOutlineEdge(): void;
    // (undocumented)
    type: PolylineTypeFlags;
    static unpack(value: number): PolylineFlags;
}

// @internal (undocumented)
export enum PolylineTypeFlags {
    // (undocumented)
    Edge = 1,
    // (undocumented)
    Normal = 0,
    // (undocumented)
    Outline = 2
}

// @public
export class PositionalVectorTransform implements PositionalVectorTransformProps {
    constructor(data?: PositionalVectorTransformProps);
    readonly delta: Vector3d;
    equals(other: PositionalVectorTransform): boolean;
    static fromJSON(data: PositionalVectorTransformProps): PositionalVectorTransform;
    readonly rotation: XyzRotation;
    readonly scalePPM: number;
    toJSON(): PositionalVectorTransformProps;
}

// @public
export interface PositionalVectorTransformProps {
    delta: XYAndZ;
    rotation: XyzRotationProps;
    scalePPM: number;
}

// @internal
export interface PrimaryTileTreeId {
    animationId?: Id64String;
    edges: EdgeOptions | false;
    enforceDisplayPriority?: boolean;
    sectionCut?: string;
    type: BatchType.Primary;
}

// @beta
export enum PrimitiveTypeCode {
    // (undocumented)
    Binary = 257,
    // (undocumented)
    Boolean = 513,
    // (undocumented)
    DateTime = 769,
    // (undocumented)
    Double = 1025,
    // (undocumented)
    Integer = 1281,
    // (undocumented)
    Long = 1537,
    // (undocumented)
    Point2d = 1793,
    // (undocumented)
    Point3d = 2049,
    // (undocumented)
    String = 2305,
    // (undocumented)
    Uninitialized = 0
}

// @public
export interface PriorityPlanarClipMaskArgs extends BasicPlanarClipMaskArgs {
    // @internal (undocumented)
    elementIds?: never;
    // @internal (undocumented)
    exclude?: never;
    // @internal (undocumented)
    modelIds?: never;
    priority: number;
}

// @beta
export enum ProfileOptions {
    None = 0,
    Upgrade = 1
}

// @public
export class Projection implements ProjectionProps {
    constructor(_data?: ProjectionProps);
    readonly affine?: AffineTransform;
    readonly azimuth?: number;
    readonly centralMeridian?: number;
    readonly centralPointLatitude?: number;
    readonly centralPointLongitude?: number;
    readonly danishSystem34Region?: DanishSystem34Region;
    readonly elevationAboveGeoid?: number;
    equals(other: Projection): boolean;
    readonly falseEasting?: number;
    readonly falseNorthing?: number;
    static fromJSON(data: ProjectionProps): Projection;
    readonly geoidSeparation?: number;
    readonly hemisphere?: HemisphereEnum;
    readonly latitudeOfOrigin?: number;
    readonly longitudeOfOrigin?: number;
    readonly method: ProjectionMethod;
    readonly point1Latitude?: number;
    readonly point1Longitude?: number;
    readonly point2Latitude?: number;
    readonly point2Longitude?: number;
    readonly scaleFactor?: number;
    readonly standardParallel?: number;
    readonly standardParallel1?: number;
    readonly standardParallel2?: number;
    toJSON(): ProjectionProps;
    readonly zoneNumber?: number;
}

// @public
export type ProjectionMethod = "None" | "TransverseMercator" | "SouthOrientedTransverseMercator" | "TransverseMercatorWisconsin" | "TransverseMercatorMinnesota" | "TransverseMercatorAffine" | "MercatorStandardParallel" | "Mercator" | "UniversalTransverseMercator" | "LambertConformalConicTwoParallels" | "LambertConformalConicBelgium" | "LambertConformalConicAffine" | "LambertConformalConicWisconsin" | "LambertConformalConicMinnesota" | "LambertConformalConicMichigan" | "LambertConformalConicOneParallel" | "AlbersEqualArea" | "NewZealandNationalGrid" | "ObliqueMercator1" | "ObliqueMercator2" | "TransverseMercatorOSTN97" | "TransverseMercatorOSTN02" | "TransverseMercatorOSTN15" | "Krovak" | "KrovakModified" | "ObliqueCylindricalSwiss" | "TransverseMercatorDenmarkSystem34" | "TransverseMercatorDenmarkSystem3499" | "TransverseMercatorDenmarkSystem3401" | "Cassini" | "Sinusoidal" | "VanDerGrinten" | "Bonne" | "Mollweide" | "EckertIV" | "EckertVI" | "GoodeHomolosine" | "Robinson" | "PlateCarree" | "MillerCylindrical" | "WinkelTripel" | "AzimuthalEqualArea" | "ObliqueStereographic" | "RectifiedSkewOrthomorphicCentered" | "RectifiedSkewOrthomorphicOrigin" | "ObliqueCylindricalHungary" | "Orthographic" | "AmericanPolyconic" | "LambertEquidistantAzimuthal" | "ObliqueMercatorMinnesota";

// @public
export interface ProjectionProps {
    affine?: AffineTransformProps;
    azimuth?: number;
    centralMeridian?: number;
    centralPointLatitude?: number;
    centralPointLongitude?: number;
    danishSystem34Region?: DanishSystem34Region;
    elevationAboveGeoid?: number;
    falseEasting?: number;
    falseNorthing?: number;
    geoidSeparation?: number;
    hemisphere?: HemisphereEnum;
    latitudeOfOrigin?: number;
    longitudeOfOrigin?: number;
    method: ProjectionMethod;
    point1Latitude?: number;
    point1Longitude?: number;
    point2Latitude?: number;
    point2Longitude?: number;
    scaleFactor?: number;
    standardParallel?: number;
    standardParallel1?: number;
    standardParallel2?: number;
    zoneNumber?: number;
}

// @beta
export type PropertyCallback = (name: string, meta: PropertyMetaData) => void;

// @beta
export class PropertyMetaData implements PropertyMetaDataProps {
    constructor(jsonObj: PropertyMetaDataProps);
    createProperty(jsonObj: any): any;
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    get isNavigation(): boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: PrimitiveTypeCode;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @beta (undocumented)
export class PropertyMetaDataMap implements Iterable<QueryPropertyMetaData> {
    // (undocumented)
    [Symbol.iterator](): Iterator<QueryPropertyMetaData, any, undefined>;
    constructor(properties: QueryPropertyMetaData[]);
    // (undocumented)
    findByJsonName(name: string): QueryPropertyMetaData | undefined;
    // (undocumented)
    findByName(name: string): QueryPropertyMetaData | undefined;
    // (undocumented)
    findByNoCase(name: string): QueryPropertyMetaData | undefined;
    // (undocumented)
    get length(): number;
    // (undocumented)
    readonly properties: QueryPropertyMetaData[];
}

// @beta (undocumented)
export interface PropertyMetaDataProps {
    // (undocumented)
    customAttributes?: CustomAttribute[];
    // (undocumented)
    description?: string;
    // (undocumented)
    direction?: string;
    // (undocumented)
    displayLabel?: string;
    // (undocumented)
    extendedType?: string;
    // (undocumented)
    isCustomHandled?: boolean;
    // (undocumented)
    isCustomHandledOrphan?: boolean;
    // (undocumented)
    kindOfQuantity?: string;
    // (undocumented)
    maximumLength?: number;
    // (undocumented)
    maximumValue?: any;
    // (undocumented)
    maxOccurs?: number;
    // (undocumented)
    minimumLength?: number;
    // (undocumented)
    minimumValue?: any;
    // (undocumented)
    minOccurs?: number;
    // (undocumented)
    primitiveType?: number;
    // (undocumented)
    readOnly?: boolean;
    // (undocumented)
    relationshipClass?: string;
    // (undocumented)
    structName?: string;
}

// @public
export class QParams2d {
    clone(out?: QParams2d): QParams2d;
    copyFrom(src: QParams2d): void;
    static fromNormalizedRange(rangeScale?: number): QParams2d;
    static fromOriginAndScale(originX: number, originY: number, scaleX: number, scaleY: number): QParams2d;
    static fromRange(range: Range2d, out?: QParams2d, rangeScale?: number): QParams2d;
    static fromZeroToOne(rangeScale?: number): QParams2d;
    isQuantizable(point: Point2d): boolean;
    readonly origin: Point2d;
    // @internal (undocumented)
    get rangeDiagonal(): Vector2d;
    readonly scale: Point2d;
    setFromRange(range: Range2d, rangeScale?: number): void;
    unquantize(x: number, y: number, out?: Point2d): Point2d;
}

// @public
export class QParams3d {
    clone(out?: QParams3d): QParams3d;
    computeRange(out?: Range3d): Range3d;
    copyFrom(src: QParams3d): void;
    static fromNormalizedRange(rangeScale?: number): QParams3d;
    static fromOriginAndScale(origin: Point3d, scale: Point3d, out?: QParams3d): QParams3d;
    static fromRange(range: Range3d, out?: QParams3d, rangeScale?: number): QParams3d;
    static fromZeroToOne(rangeScale?: number): QParams3d;
    isQuantizable(point: Point3d): boolean;
    readonly origin: Point3d;
    // @internal (undocumented)
    get rangeDiagonal(): Vector3d;
    readonly scale: Point3d;
    setFromOriginAndScale(origin: Point3d, scale: Point3d): void;
    setFromRange(range: Range3d, rangeScale?: number): void;
    unquantize(x: number, y: number, z: number, out?: Point3d): Point3d;
}

// @public
export class QPoint2d {
    constructor();
    clone(out?: QPoint2d): QPoint2d;
    copyFrom(src: QPoint2d): void;
    static create(pos: Point2d, params: QParams2d): QPoint2d;
    static fromScalars(x: number, y: number): QPoint2d;
    init(pos: Point2d, params: QParams2d): void;
    setFromScalars(x: number, y: number): void;
    unquantize(params: QParams2d, out?: Point2d): Point2d;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
}

// @public
export class QPoint2dList {
    constructor(params: QParams2d);
    add(pt: Point2d): void;
    clear(): void;
    static fromPoints(points: Point2d[], out?: QPoint2dList): QPoint2dList;
    fromTypedArray(range: Range2d, array: Uint16Array): void;
    get length(): number;
    get list(): ReadonlyArray<QPoint2d>;
    readonly params: QParams2d;
    push(qpt: QPoint2d): void;
    requantize(params: QParams2d): void;
    reset(params: QParams2d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point2d): Point2d;
}

// @public
export class QPoint3d {
    constructor();
    clone(out?: QPoint3d): QPoint3d;
    compare(rhs: QPoint3d): number;
    copyFrom(src: QPoint3d): void;
    static create(pos: Point3d, params: QParams3d): QPoint3d;
    equals(other: QPoint3d): boolean;
    static fromScalars(x: number, y: number, z: number, out?: QPoint3d): QPoint3d;
    init(pos: Point3d, params: QParams3d): void;
    setFromScalars(x: number, y: number, z: number): void;
    unquantize(params: QParams3d, out?: Point3d): Point3d;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get z(): number;
    set z(z: number);
}

// @public
export class QPoint3dList {
    [Symbol.iterator](): IterableIterator<QPoint3d>;
    constructor(params?: QParams3d);
    add(pt: Point3d): void;
    clear(): void;
    static createFrom(points: Point3d[], params: QParams3d): QPoint3dList;
    static fromPoints(points: Point3d[], out?: QPoint3dList): QPoint3dList;
    fromTypedArray(range: Range3d, array: Uint16Array): void;
    get length(): number;
    get list(): ReadonlyArray<QPoint3d>;
    readonly params: QParams3d;
    push(qpt: QPoint3d): void;
    requantize(params: QParams3d): void;
    reset(params: QParams3d): void;
    toTypedArray(): Uint16Array;
    unquantize(index: number, out?: Point3d): Point3d;
}

// @public
export namespace Quantization {
    const // (undocumented)
    rangeScale16 = 65535;
    const // (undocumented)
    rangeScale8 = 255;
    export function computeScale(extent: number, rangeScale?: number): number;
    // @internal (undocumented)
    export function isInRange(qpos: number, rangeScale?: number): boolean;
    // @internal (undocumented)
    export function isQuantizable(pos: number, origin: number, scale: number, rangeScale?: number): boolean;
    // @internal (undocumented)
    export function isQuantized(qpos: number): boolean;
    export function quantize(pos: number, origin: number, scale: number, rangeScale?: number): number;
    export function unquantize(qpos: number, origin: number, scale: number): number;
}

// @public (undocumented)
export class QueryBinder {
    // (undocumented)
    bindBlob(indexOrName: string | number, val: Uint8Array): this;
    // (undocumented)
    bindBoolean(indexOrName: string | number, val: boolean): this;
    // (undocumented)
    bindDouble(indexOrName: string | number, val: number): this;
    // (undocumented)
    bindId(indexOrName: string | number, val: Id64String): this;
    // (undocumented)
    bindIdSet(indexOrName: string | number, val: OrderedId64Iterable): this;
    // (undocumented)
    bindInt(indexOrName: string | number, val: number): this;
    // (undocumented)
    bindLong(indexOrName: string | number, val: number): this;
    // (undocumented)
    bindNull(indexOrName: string | number): this;
    // (undocumented)
    bindPoint2d(indexOrName: string | number, val: Point2d): this;
    // (undocumented)
    bindPoint3d(indexOrName: string | number, val: Point3d): this;
    // (undocumented)
    bindString(indexOrName: string | number, val: string): this;
    // (undocumented)
    bindStruct(indexOrName: string | number, val: object): this;
    // (undocumented)
    static from(args: any[] | object | undefined): QueryBinder;
    // (undocumented)
    serialize(): object;
}

// @public
export interface QueryLimit {
    count?: number;
    offset?: number;
}

// @public
export interface QueryOptions extends BaseReaderOptions {
    abbreviateBlobs?: boolean;
    convertClassIdsToClassNames?: boolean;
    includeMetaData?: boolean;
    limit?: QueryLimit;
    rowFormat?: QueryRowFormat;
    suppressLogErrors?: boolean;
}

// @public (undocumented)
export class QueryOptionsBuilder {
    constructor(_options?: QueryOptions);
    // (undocumented)
    getOptions(): QueryOptions;
    // (undocumented)
    setAbbreviateBlobs(val: boolean): this;
    // (undocumented)
    setConvertClassIdsToNames(val: boolean): this;
    // (undocumented)
    setLimit(val: QueryLimit): this;
    // (undocumented)
    setPriority(val: number): this;
    // (undocumented)
    setQuota(val: QueryQuota): this;
    // (undocumented)
    setRestartToken(val: string): this;
    // (undocumented)
    setRowFormat(val: QueryRowFormat): this;
    // (undocumented)
    setSuppressLogErrors(val: boolean): this;
    // (undocumented)
    setUsePrimaryConnection(val: boolean): this;
}

// @beta (undocumented)
export interface QueryPropertyMetaData {
    // (undocumented)
    className: string;
    // (undocumented)
    extendType: string;
    // (undocumented)
    generated: boolean;
    // (undocumented)
    index: number;
    // (undocumented)
    jsonName: string;
    // (undocumented)
    name: string;
    // (undocumented)
    typeName: string;
}

// @public
export interface QueryQuota {
    memory?: number;
    time?: number;
}

// @public
export enum QueryRowFormat {
    UseECSqlPropertyIndexes = 1,
    UseECSqlPropertyNames = 0,
    UseJsPropertyNames = 2
}

// @beta (undocumented)
export interface QueryRowProxy {
    // (undocumented)
    [propertyName: string]: QueryValueType;
    // (undocumented)
    [propertyIndex: number]: QueryValueType;
    // (undocumented)
    getMetaData(): QueryPropertyMetaData[];
    // (undocumented)
    toArray(): QueryValueType[];
    // (undocumented)
    toRow(): any;
}

// @beta (undocumented)
export interface QueryStats {
    // (undocumented)
    backendCpuTime: number;
    // (undocumented)
    backendMemUsed: number;
    // (undocumented)
    backendRowsReturned: number;
    // (undocumented)
    backendTotalTime: number;
    // (undocumented)
    retryCount: number;
    // (undocumented)
    totalTime: number;
}

// @beta (undocumented)
export type QueryValueType = any;

// @public
export enum Rank {
    Application = 2,
    Domain = 1,
    System = 0,
    User = 3
}

// @internal (undocumented)
export interface ReadableFormData extends Readable {
    // (undocumented)
    getHeaders(): {
        [key: string]: any;
    };
}

// @internal
export function readTileContentDescription(stream: ByteStream, sizeMultiplier: number | undefined, is2d: boolean, options: TileOptions, isVolumeClassifier: boolean): TileContentDescription;

// @beta
export interface RealityData {
    // (undocumented)
    getBlobUrl(accessToken: AccessToken, blobPath: string): Promise<URL>;
    // (undocumented)
    id?: string;
    // (undocumented)
    rootDocument?: string;
    // (undocumented)
    type?: string;
}

// @beta
export interface RealityDataAccess {
    // (undocumented)
    getRealityData: (accessToken: AccessToken, iTwinId: string | undefined, realityDataId: string) => Promise<RealityData>;
    // (undocumented)
    getRealityDataUrl: (iTwinId: string | undefined, realityDataId: string) => Promise<string>;
}

// @beta
export enum RealityDataFormat {
    OPC = "OPC",
    ThreeDTile = "ThreeDTile"
}

// @beta
export namespace RealityDataFormat {
    export function fromUrl(tilesetUrl: string): RealityDataFormat;
}

// @beta
export enum RealityDataProvider {
    CesiumIonAsset = "CesiumIonAsset",
    ContextShare = "ContextShare",
    OrbitGtBlob = "OrbitGtBlob",
    TilesetUrl = "TilesetUrl"
}

// @beta
export interface RealityDataSourceKey {
    format: string;
    id: string;
    iTwinId?: string;
    provider: string;
}

// @beta
export namespace RealityDataSourceKey {
    export function convertToString(rdSourceKey: RealityDataSourceKey): string;
    export function isEqual(key1: RealityDataSourceKey, key2: RealityDataSourceKey): boolean;
}

// @beta
export interface RealityDataSourceProps {
    sourceKey: RealityDataSourceKey;
}

// @internal (undocumented)
export const REGISTRY: unique symbol;

// @public
export class RelatedElement implements RelatedElementProps {
    constructor(props: RelatedElementProps);
    // (undocumented)
    static fromJSON(json?: RelatedElementProps): RelatedElement | undefined;
    readonly id: Id64String;
    static idFromJson(json: any): Id64String;
    static readonly none: RelatedElement;
    readonly relClassName?: string;
    // (undocumented)
    toJSON(): RelatedElementProps;
}

// @public
export interface RelatedElementProps {
    id: Id64String;
    relClassName?: string;
}

// @public
export interface RelationshipProps extends EntityProps, SourceAndTarget {
}

// @public
export type RemoveFunction = () => void;

// @public
export abstract class RenderMaterial {
    protected constructor(params: RenderMaterial.Params);
    // (undocumented)
    get hasTexture(): boolean;
    readonly key?: string;
    readonly textureMapping?: TextureMapping;
}

// @public (undocumented)
export namespace RenderMaterial {
    // @deprecated (undocumented)
    export class Params {
        constructor(key?: string);
        get alpha(): number | undefined;
        set alpha(alpha: number | undefined);
        // @alpha
        ambient: number;
        static readonly defaults: Params;
        diffuse: number;
        diffuseColor?: ColorDef;
        // @alpha
        emissiveColor?: ColorDef;
        static fromColors(key?: string, diffuseColor?: ColorDef, specularColor?: ColorDef, emissiveColor?: ColorDef, reflectColor?: ColorDef, textureMap?: TextureMapping): Params;
        key?: string;
        // @alpha
        reflect: number;
        // @alpha
        reflectColor?: ColorDef;
        // @alpha
        refract: number;
        // @alpha
        shadows: boolean;
        specular: number;
        specularColor?: ColorDef;
        // (undocumented)
        specularExponent: number;
        textureMapping?: TextureMapping;
    }
}

// @public
export interface RenderMaterialAssetProps {
    color?: RgbFactorProps;
    diffuse?: number;
    finish?: number;
    HasBaseColor?: boolean;
    HasDiffuse?: boolean;
    HasFinish?: boolean;
    HasReflect?: boolean;
    HasReflectColor?: boolean;
    HasSpecular?: boolean;
    HasSpecularColor?: boolean;
    HasTransmit?: boolean;
    Map?: {
        Pattern?: TextureMapProps;
    };
    reflect?: number;
    reflect_color?: RgbFactorProps;
    specular?: number;
    specular_color?: RgbFactorProps;
    transmit?: number;
}

// @public
export interface RenderMaterialProps extends DefinitionElementProps {
    description?: string;
    // (undocumented)
    jsonProperties?: {
        materialAssets?: {
            renderMaterial?: RenderMaterialAssetProps;
        };
    };
    paletteName: string;
}

// @public
export enum RenderMode {
    HiddenLine = 3,
    SmoothShade = 6,
    SolidFill = 4,
    Wireframe = 0
}

// @public
export namespace RenderSchedule {
    export class ColorEntry extends TimelineEntry {
        constructor(props: ColorEntryProps);
        // (undocumented)
        compareTo(other: ColorEntry): number;
        // (undocumented)
        toJSON(): ColorEntryProps;
        readonly value: RgbColor | undefined;
    }
    export interface ColorEntryProps extends TimelineEntryProps {
        value?: {
            red: number;
            green: number;
            blue: number;
        };
    }
    export class CuttingPlane {
        constructor(props: CuttingPlaneProps);
        // (undocumented)
        compareTo(other: CuttingPlane): number;
        readonly direction: XYAndZ;
        // (undocumented)
        equals(other: CuttingPlane): boolean;
        readonly hidden: boolean;
        readonly position: XYAndZ;
        // (undocumented)
        toJSON(): CuttingPlaneProps;
        readonly visible: boolean;
    }
    export class CuttingPlaneEntry extends TimelineEntry {
        constructor(props: CuttingPlaneEntryProps);
        // (undocumented)
        compareTo(other: CuttingPlaneEntry): number;
        // (undocumented)
        toJSON(): CuttingPlaneEntryProps;
        readonly value: CuttingPlane | undefined;
    }
    export interface CuttingPlaneEntryProps extends TimelineEntryProps {
        value?: CuttingPlaneProps;
    }
    export interface CuttingPlaneProps {
        direction: number[];
        hidden?: boolean;
        position: number[];
        visible?: boolean;
    }
    export class ElementTimeline extends Timeline {
        // @internal (undocumented)
        addSymbologyOverrides(overrides: FeatureOverrides, time: number): void;
        readonly batchId: number;
        // (undocumented)
        compareTo(other: ElementTimeline): number;
        // (undocumented)
        get containsElementIds(): boolean;
        get containsFeatureOverrides(): boolean;
        get containsTransform(): boolean;
        get elementIds(): Iterable<Id64String>;
        // (undocumented)
        static fromJSON(props?: ElementTimelineProps): ElementTimeline;
        // @internal (undocumented)
        static getElementIds(ids: Id64String[] | CompressedId64Set): Iterable<Id64String>;
        // @internal
        get requiresBatching(): boolean;
        // (undocumented)
        toJSON(): ElementTimelineProps;
    }
    export class ElementTimelineBuilder extends TimelineBuilder {
        constructor(batchId: number, elementIds: CompressedId64Set);
        readonly batchId: number;
        readonly elementIds: CompressedId64Set;
        finish(): ElementTimelineProps;
    }
    export interface ElementTimelineProps extends TimelineProps {
        batchId: number;
        elementIds: Id64String[] | CompressedId64Set;
    }
    export enum Interpolation {
        Linear = 2,
        Step = 1
    }
    // @internal
    export class Interval {
        constructor(lower?: number, upper?: number, fraction?: number);
        fraction: number;
        // (undocumented)
        init(lower?: number, upper?: number, fraction?: number): void;
        lowerIndex: number;
        upperIndex: number;
    }
    export class ModelTimeline extends Timeline {
        // @internal (undocumented)
        addSymbologyOverrides(overrides: FeatureOverrides, time: number): void;
        // (undocumented)
        compareTo(other: ModelTimeline): number;
        readonly containsFeatureOverrides: boolean;
        readonly containsModelClipping: boolean;
        readonly containsTransform: boolean;
        // @alpha
        get discreteBatchIds(): Set<number>;
        readonly elementTimelines: ReadonlyArray<ElementTimeline>;
        findByBatchId(batchId: number): ElementTimeline | undefined;
        // (undocumented)
        static fromJSON(props?: ModelTimelineProps): ModelTimeline;
        // @alpha
        getTimelineForElement(idLo: number, idHi: number): ElementTimeline | undefined;
        getTransform(batchId: number, time: number): Readonly<Transform> | undefined;
        get maxBatchId(): number;
        readonly modelId: Id64String;
        readonly omitsElementIds: boolean;
        // @internal (undocumented)
        readonly realityModelUrl?: string;
        // @internal
        readonly requiresBatching: boolean;
        // (undocumented)
        toJSON(): ModelTimelineProps;
        // @internal (undocumented)
        readonly transformBatchIds: ReadonlyArray<number>;
    }
    export class ModelTimelineBuilder extends TimelineBuilder {
        constructor(modelId: Id64String, obtainNextBatchId: () => number);
        addElementTimeline(elementIds: CompressedId64Set | Iterable<Id64String>): ElementTimelineBuilder;
        finish(): ModelTimelineProps;
        readonly modelId: Id64String;
        // @internal (undocumented)
        realityModelUrl?: string;
    }
    export interface ModelTimelineProps extends TimelineProps {
        elementTimelines: ElementTimelineProps[];
        modelId: Id64String;
        // @alpha (undocumented)
        realityModelUrl?: string;
    }
    export class Script {
        protected constructor(props: Readonly<ScriptProps>);
        // @internal (undocumented)
        addSymbologyOverrides(overrides: FeatureOverrides, time: number): void;
        // (undocumented)
        compareTo(other: Script): number;
        readonly containsFeatureOverrides: boolean;
        readonly containsModelClipping: boolean;
        readonly containsTransform: boolean;
        // @internal
        discloseIds(ids: Id64Set): void;
        readonly duration: Range1d;
        // (undocumented)
        equals(other: Script): boolean;
        find(modelId: Id64String): ModelTimeline | undefined;
        // (undocumented)
        static fromJSON(props: Readonly<ScriptProps>): Script | undefined;
        // @internal (undocumented)
        getTransform(modelId: Id64String, batchId: number, time: number): Readonly<Transform> | undefined;
        // @internal (undocumented)
        getTransformBatchIds(modelId: Id64String): ReadonlyArray<number> | undefined;
        // @internal (undocumented)
        modelRequiresBatching(modelId: Id64String): boolean;
        readonly modelTimelines: ReadonlyArray<ModelTimeline>;
        // @internal
        readonly requiresBatching: boolean;
        // (undocumented)
        toJSON(): ScriptProps;
        // @internal
        readonly transformBatchIds: ReadonlySet<number>;
    }
    export class ScriptBuilder {
        addModelTimeline(modelId: Id64String): ModelTimelineBuilder;
        finish(): ScriptProps;
    }
    export type ScriptProps = ModelTimelineProps[];
    export class ScriptReference {
        constructor(script: Script);
        constructor(sourceId: Id64String, script: Script);
        // @internal
        constructor(sourceIdOrScript: Id64String | Script, scriptIfSourceId?: Script);
        readonly script: Script;
        readonly sourceId: Id64String;
    }
    export class Timeline {
        constructor(props: TimelineProps);
        readonly color?: TimelineEntryList<ColorEntry, ColorEntryProps, RgbColor | undefined>;
        // (undocumented)
        compareTo(other: Timeline): number;
        readonly cuttingPlane?: TimelineEntryList<CuttingPlaneEntry, CuttingPlaneEntryProps, CuttingPlane | undefined>;
        readonly duration: Range1d;
        // (undocumented)
        equals(other: Timeline): boolean;
        getAnimationTransform(time: number): Readonly<Transform>;
        getClipVector(time: number): ClipVector | undefined;
        getColor(time: number): RgbColor | undefined;
        getCuttingPlane(time: number): Plane3dByOriginAndUnitNormal | undefined;
        // @internal (undocumented)
        protected getFeatureAppearance(visibility: number, time: number): FeatureAppearance | undefined;
        getVisibility(time: number): number;
        // (undocumented)
        toJSON(): TimelineProps;
        readonly transform?: TransformTimelineEntries;
        readonly visibility?: VisibilityTimelineEntries;
    }
    export class TimelineBuilder {
        addColor(time: number, color: RgbColor | {
            red: number;
            green: number;
            blue: number;
        } | undefined, interpolation?: Interpolation): void;
        addCuttingPlane(time: number, plane: {
            position: XYAndZ;
            direction: XYAndZ;
            visible?: boolean;
            hidden?: boolean;
        } | undefined, interpolation?: Interpolation): void;
        addTransform(time: number, transform: Readonly<Transform> | undefined, components?: {
            pivot: XYAndZ;
            orientation: Point4d;
            position: XYAndZ;
        }, interpolation?: Interpolation): void;
        addVisibility(time: number, visibility: number | undefined, interpolation?: Interpolation): void;
        color?: ColorEntryProps[];
        cuttingPlane?: CuttingPlaneEntryProps[];
        finish(): TimelineProps;
        transform?: TransformEntryProps[];
        visibility?: VisibilityEntryProps[];
    }
    export class TimelineEntry {
        constructor(props: TimelineEntryProps);
        // (undocumented)
        compareTo(other: TimelineEntry): number;
        // (undocumented)
        equals(other: TimelineEntry): boolean;
        readonly interpolation: Interpolation;
        readonly time: number;
        // (undocumented)
        toJSON(): TimelineEntryProps;
    }
    export class TimelineEntryList<T extends TimelineEntry & {
        readonly value: V;
    }, P extends TimelineEntryProps, V> implements Iterable<T> {
        [Symbol.iterator](): Iterator<T>;
        constructor(props: P[], ctor: Constructor<T>);
        // (undocumented)
        compareTo(other: TimelineEntryList<T, P, V>): number;
        readonly duration: Range1d;
        // (undocumented)
        equals(other: TimelineEntryList<T, P, V>): boolean;
        // @internal (undocumented)
        findInterval(time: number, interval?: Interval): Interval | undefined;
        getEntry(index: number): T | undefined;
        getValue(index: number): V | undefined;
        get length(): number;
        // (undocumented)
        toJSON(): P[];
    }
    export interface TimelineEntryProps {
        interpolation?: Interpolation;
        time: number;
    }
    export interface TimelineProps {
        colorTimeline?: ColorEntryProps[];
        cuttingPlaneTimeline?: CuttingPlaneEntryProps[];
        transformTimeline?: TransformEntryProps[];
        visibilityTimeline?: VisibilityEntryProps[];
    }
    export class TransformComponents {
        constructor(position: Vector3d, pivot: Vector3d, orientation: Point4d);
        // (undocumented)
        compareTo(other: TransformComponents): number;
        // (undocumented)
        equals(other: TransformComponents): boolean;
        // (undocumented)
        static fromJSON(props: TransformComponentsProps): TransformComponents | undefined;
        readonly orientation: Point4d;
        readonly pivot: Vector3d;
        readonly position: Vector3d;
        // (undocumented)
        toJSON(): TransformComponentsProps;
    }
    export interface TransformComponentsProps {
        orientation?: number[];
        pivot?: number[];
        position?: number[];
    }
    export class TransformEntry extends TimelineEntry {
        constructor(props: TransformEntryProps);
        // (undocumented)
        compareTo(other: TransformEntry): number;
        readonly components?: TransformComponents;
        // (undocumented)
        toJSON(): TransformEntryProps;
        readonly value: Readonly<Transform>;
    }
    export interface TransformEntryProps extends TimelineEntryProps {
        value?: TransformProps;
    }
    export interface TransformProps extends TransformComponentsProps {
        transform?: number[][];
    }
    export class TransformTimelineEntries extends TimelineEntryList<TransformEntry, TransformEntryProps, Readonly<Transform>> {
        getValue(index: number): Readonly<Transform>;
    }
    export class VisibilityEntry extends TimelineEntry {
        constructor(props: VisibilityEntryProps);
        // (undocumented)
        compareTo(other: VisibilityEntry): number;
        // (undocumented)
        toJSON(): VisibilityEntryProps;
        readonly value: number;
    }
    export interface VisibilityEntryProps extends TimelineEntryProps {
        value?: number;
    }
    export class VisibilityTimelineEntries extends TimelineEntryList<VisibilityEntry, VisibilityEntryProps, number> {
        getValue(index: number): number;
    }
}

// @public
export abstract class RenderTexture implements IDisposable {
    protected constructor(type: RenderTexture.Type);
    // (undocumented)
    abstract get bytesUsed(): number;
    abstract dispose(): void;
    // (undocumented)
    get isGlyph(): boolean;
    // (undocumented)
    get isSkyBox(): boolean;
    // (undocumented)
    get isTileSection(): boolean;
    readonly type: RenderTexture.Type;
}

// @public (undocumented)
export namespace RenderTexture {
    // @deprecated
    export class Params {
        constructor(key?: string, type?: RenderTexture.Type, isOwned?: boolean);
        // (undocumented)
        get isGlyph(): boolean;
        readonly isOwned: boolean;
        // (undocumented)
        get isSkyBox(): boolean;
        // (undocumented)
        get isTileSection(): boolean;
        readonly key?: string;
        readonly type: RenderTexture.Type;
    }
    export enum Type {
        FilteredTileSection = 4,
        Glyph = 1,
        Normal = 0,
        SkyBox = 3,
        ThematicGradient = 5,
        TileSection = 2
    }
}

// @public
export interface RenderTimelineLoadProps {
    omitScriptElementIds?: boolean;
}

// @public
export interface RenderTimelineProps extends ElementProps {
    description?: string;
    script: string;
}

// @public
export interface RepositoryLinkProps extends UrlLinkProps {
    // (undocumented)
    format?: string;
    // (undocumented)
    repositoryGuid?: GuidString;
}

export { RepositoryStatus }

// @public
export interface RequestNewBriefcaseProps {
    asOf?: IModelVersionProps;
    briefcaseId?: BriefcaseId;
    readonly fileName?: LocalFileName;
    readonly iModelId: GuidString;
    readonly iTwinId: GuidString;
}

// @internal (undocumented)
export class ResponseLike implements Response {
    constructor(data: any);
    // (undocumented)
    arrayBuffer(): Promise<ArrayBuffer>;
    // (undocumented)
    blob(): Promise<Blob>;
    // (undocumented)
    get body(): null;
    // (undocumented)
    get bodyUsed(): boolean;
    // (undocumented)
    clone(): this;
    // (undocumented)
    formData(): Promise<FormData>;
    // (undocumented)
    get headers(): Headers;
    // (undocumented)
    json(): Promise<any>;
    // (undocumented)
    get ok(): boolean;
    // (undocumented)
    get redirected(): boolean;
    // (undocumented)
    get status(): number;
    // (undocumented)
    get statusText(): string;
    // (undocumented)
    text(): Promise<string>;
    // (undocumented)
    get trailer(): Promise<Headers>;
    // (undocumented)
    get type(): ResponseType;
    // (undocumented)
    get url(): string;
}

// @public
export class RgbColor {
    constructor(r: number, g: number, b: number);
    // (undocumented)
    readonly b: number;
    // (undocumented)
    compareTo(other: RgbColor): number;
    // (undocumented)
    equals(rhs: RgbColor): boolean;
    static fromColorDef(colorDef: ColorDef): RgbColor;
    // (undocumented)
    static fromJSON(json: RgbColorProps | undefined): RgbColor;
    // (undocumented)
    readonly g: number;
    // (undocumented)
    readonly r: number;
    toColorDef(transparency?: number): ColorDef;
    // (undocumented)
    toJSON(): RgbColorProps;
}

// @public
export interface RgbColorProps {
    // (undocumented)
    b: number;
    // (undocumented)
    g: number;
    // (undocumented)
    r: number;
}

// @public
export type RgbFactorProps = number[];

// @public
export interface RootSubjectProps {
    readonly description?: string;
    readonly name: string;
}

// @public
export interface RpcActivity extends SessionProps {
    readonly accessToken: AccessToken;
    readonly activityId: GuidString;
    readonly rpcMethod?: string;
}

// @internal (undocumented)
export type RpcActivityRun = (activity: RpcActivity, fn: () => Promise<any>) => Promise<any>;

// @internal
export abstract class RpcConfiguration {
    // (undocumented)
    allowAttachedInterfaces: boolean;
    static assign<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, supplier: RpcConfigurationSupplier): void;
    static assignWithRouting<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing: RpcRoutingToken, configuration: new () => RpcConfiguration): void;
    // (undocumented)
    attach<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    attached: RpcInterfaceDefinition[];
    // (undocumented)
    get attachedInterfaces(): ReadonlyArray<RpcInterfaceDefinition>;
    readonly controlChannel: RpcControlChannel;
    static developmentMode: boolean;
    static disableRoutingValidation: boolean;
    static initializeInterfaces(configuration: RpcConfiguration): void;
    abstract readonly interfaces: () => RpcInterfaceDefinition[];
    static obtain<T extends RpcConfiguration>(configurationConstructor: new () => T): T;
    // (undocumented)
    onRpcClientInitialized(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // (undocumented)
    onRpcClientTerminated(definition: RpcInterfaceDefinition, client: RpcInterface): void;
    // (undocumented)
    onRpcImplInitialized(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    // (undocumented)
    onRpcImplTerminated(definition: RpcInterfaceDefinition, impl: RpcInterface): void;
    pendingOperationRetryInterval: number;
    abstract readonly protocol: RpcProtocol;
    static requestContext: RpcRequestContext;
    // (undocumented)
    readonly routing: RpcRoutingToken;
    static strictMode: boolean;
    // (undocumented)
    static supply(definition: RpcInterface): RpcConfiguration;
    static throwOnTokenMismatch: boolean;
    transientFaultLimit: number;
}

// @internal (undocumented)
export type RpcConfigurationSupplier = (routing?: RpcRoutingToken) => {
    new (): RpcConfiguration;
};

// @public
export enum RpcContentType {
    // (undocumented)
    Binary = 2,
    // (undocumented)
    Multipart = 3,
    // (undocumented)
    Stream = 4,
    // (undocumented)
    Text = 1,
    // (undocumented)
    Unknown = 0
}

// @internal
export class RpcControlChannel {
    // (undocumented)
    static channels: RpcControlChannel[];
    // (undocumented)
    describeEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    handleUnknownOperation(invocation: RpcInvocation, _error: any): boolean;
    // (undocumented)
    initialize(): void;
    // (undocumented)
    static obtain(configuration: RpcConfiguration): RpcControlChannel;
}

// @public
export abstract class RpcControlResponse {
    // (undocumented)
    message: string;
}

// @internal
export class RpcDefaultConfiguration extends RpcConfiguration {
    // (undocumented)
    interfaces: () => never[];
    // (undocumented)
    protocol: RpcProtocol;
}

// @internal
export class RpcDirectProtocol extends RpcProtocol {
    // (undocumented)
    readonly requestType: typeof RpcDirectRequest;
}

// @internal
export class RpcDirectRequest extends RpcRequest {
    // (undocumented)
    fulfillment: RpcRequestFulfillment | undefined;
    // (undocumented)
    headers: Map<string, string>;
    // (undocumented)
    protected load(): Promise<RpcSerializedValue>;
    // (undocumented)
    protected send(): Promise<number>;
    // (undocumented)
    protected setHeader(name: string, value: string): void;
}

// @public
export enum RpcEndpoint {
    // (undocumented)
    Backend = 1,
    // (undocumented)
    Frontend = 0
}

// @public
export abstract class RpcInterface {
    // @internal
    constructor(routing?: RpcRoutingToken);
    // @internal
    readonly configuration: RpcConfiguration;
    // @internal (undocumented)
    configurationSupplier: RpcConfigurationSupplier | undefined;
    forward<T = any>(parameters: IArguments): Promise<T>;
    static isVersionCompatible(backend: string, frontend: string): boolean;
    // @internal (undocumented)
    readonly routing: RpcRoutingToken;
}

// @internal (undocumented)
export interface RpcInterfaceDefinition<T extends RpcInterface = RpcInterface> {
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    prototype: T;
}

// @internal
export interface RpcInterfaceEndpoints {
    // (undocumented)
    compatible: boolean;
    // (undocumented)
    interfaceName: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationNames: string[];
}

// @internal (undocumented)
export type RpcInterfaceImplementation<T extends RpcInterface = RpcInterface> = new () => T;

export { RpcInterfaceStatus }

// @internal
export class RpcInvocation {
    constructor(protocol: RpcProtocol, request: SerializedRpcRequest);
    static current(rpcImpl: RpcInterface): RpcInvocation;
    get elapsed(): number;
    readonly fulfillment: Promise<RpcRequestFulfillment>;
    readonly operation: RpcOperation;
    readonly protocol: RpcProtocol;
    readonly request: SerializedRpcRequest;
    readonly result: Promise<any>;
    // (undocumented)
    static runActivity: RpcActivityRun;
    // (undocumented)
    static sanitizeForLog(activity?: RpcActivity): {
        ActivityId: string;
        SessionId: string;
        ApplicationId: string;
        ApplicationVersion: string;
        rpcMethod: string | undefined;
    } | undefined;
    get status(): RpcRequestStatus;
}

// @internal
export interface RpcManagedStatus {
    // (undocumented)
    iTwinRpcCoreResponse: true;
    // (undocumented)
    managedStatus: "pending" | "notFound" | "noContent";
    // (undocumented)
    responseValue: string | {
        message: string;
    } | RpcNotFoundResponse;
}

// @internal
export class RpcManager {
    static describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    static getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing?: RpcRoutingToken): T;
    static initializeInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    static setIModel(props: IModelRpcProps): void;
    static supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    static terminateInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    static unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @internal (undocumented)
export class RpcMarshaling {
    static deserialize(protocol: RpcProtocol | undefined, value: RpcSerializedValue): any;
    static serialize(protocol: RpcProtocol | undefined, value: any): Promise<RpcSerializedValue>;
}

// @internal
export class RpcMultipart {
    static createForm(value: RpcSerializedValue): FormData;
    static createStream(_value: RpcSerializedValue): ReadableFormData;
    static parseRequest(_req: HttpServerRequest): Promise<RpcSerializedValue>;
    // (undocumented)
    static writeValueToForm(form: FormDataCommon, value: RpcSerializedValue): void;
}

// @public
export class RpcNotFoundResponse extends RpcControlResponse {
    // (undocumented)
    message: string;
}

// @internal
export class RpcOpenAPIDescription {
    constructor(protocol: WebAppRpcProtocol);
    get document(): OpenAPIDocument;
    get paths(): OpenAPIPaths;
    readonly protocol: WebAppRpcProtocol;
    toJSON(): OpenAPIDocument;
}

// @internal
export class RpcOperation {
    constructor(definition: RpcInterfaceDefinition, operation: string, policy: RpcOperationPolicy);
    // (undocumented)
    static computeOperationName(identifier: string): string;
    static fallbackToken: IModelRpcProps | undefined;
    static forEach(definition: RpcInterfaceDefinition, callback: (operation: RpcOperation) => void): void;
    readonly interfaceDefinition: RpcInterfaceDefinition;
    get interfaceVersion(): string;
    static lookup(target: string | RpcInterfaceDefinition, operationName: string): RpcOperation;
    readonly operationName: string;
    policy: RpcOperationPolicy;
}

// @internal (undocumented)
export namespace RpcOperation {
    export function allowResponseCaching(control?: RpcResponseCacheControl): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
    export function setDefaultPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(definition: RpcInterfaceDefinition<T>) => void;
    export function setPolicy(policy: RpcOperationPolicy | RpcOperationPolicyProps): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
    export function setRoutingProps(handler: RpcRequestTokenSupplier_T): <T extends RpcInterface>(target: T, propertyKey: string, descriptor: PropertyDescriptor) => void;
}

// @internal
export class RpcOperationPolicy {
    allowResponseCaching: RpcResponseCachingCallback_T;
    allowResponseCompression: boolean;
    allowTokenMismatch: boolean;
    forceStrictMode: boolean;
    requestCallback: RpcRequestCallback_T;
    retryInterval: RpcRequestInitialRetryIntervalSupplier_T;
    sentCallback: RpcRequestCallback_T;
    token: RpcRequestTokenSupplier_T;
}

// @internal (undocumented)
export type RpcOperationPolicyProps = Partial<RpcOperationPolicy>;

// @internal
export interface RpcOperationsProfile {
    // (undocumented)
    readonly lastRequest: number;
    // (undocumented)
    readonly lastResponse: number;
}

// @internal
export class RpcPendingQueue {
    // (undocumented)
    static initialize(): void;
    // (undocumented)
    static instance: RpcPendingQueue;
}

// @public
export class RpcPendingResponse extends RpcControlResponse {
    constructor(message?: string);
    message: string;
}

// @internal
export abstract class RpcProtocol {
    constructor(configuration: RpcConfiguration);
    checkToken: boolean;
    readonly configuration: RpcConfiguration;
    static readonly events: BeEvent<RpcProtocolEventHandler>;
    readonly events: BeEvent<RpcProtocolEventHandler>;
    fulfill(request: SerializedRpcRequest): Promise<RpcRequestFulfillment>;
    getCode(status: RpcRequestStatus): number;
    getOperationFromPath(path: string): SerializedRpcOperation;
    getStatus(code: number): RpcRequestStatus;
    inflateToken(tokenFromBody: IModelRpcProps, _request: SerializedRpcRequest): IModelRpcProps;
    readonly invocationType: typeof RpcInvocation;
    // (undocumented)
    onRpcClientInitialized(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // (undocumented)
    onRpcClientTerminated(_definition: RpcInterfaceDefinition, _client: RpcInterface): void;
    // (undocumented)
    onRpcImplInitialized(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    // (undocumented)
    onRpcImplTerminated(_definition: RpcInterfaceDefinition, _impl: RpcInterface): void;
    preserveStreams: boolean;
    static readonly protocolVersion: number;
    protocolVersionHeaderName: string;
    abstract readonly requestType: typeof RpcRequest;
    serialize(request: RpcRequest): Promise<SerializedRpcRequest>;
    // (undocumented)
    serializedClientRequestContextHeaderNames: SerializedRpcActivity;
    supplyPathForOperation(operation: RpcOperation, _request: RpcRequest | undefined): string;
    supportsStatusCategory: boolean;
    transferChunkThreshold: number;
}

// @public
export enum RpcProtocolEvent {
    // (undocumented)
    BackendErrorOccurred = 11,
    // (undocumented)
    BackendErrorReceived = 5,
    // (undocumented)
    BackendReportedNoContent = 12,
    // (undocumented)
    BackendReportedNotFound = 10,
    // (undocumented)
    BackendReportedPending = 9,
    // (undocumented)
    BackendResponseCreated = 8,
    // (undocumented)
    ConnectionAborted = 6,
    // (undocumented)
    ConnectionErrorReceived = 3,
    // (undocumented)
    RequestCreated = 0,
    // (undocumented)
    RequestReceived = 7,
    // (undocumented)
    ResponseLoaded = 1,
    // (undocumented)
    ResponseLoading = 2,
    // (undocumented)
    UnknownErrorReceived = 4
}

// @internal
export type RpcProtocolEventHandler = (type: RpcProtocolEvent, object: RpcRequest | RpcInvocation, err?: any) => void;

// @internal
export enum RpcProtocolVersion {
    // (undocumented)
    IntroducedNoContent = 1,
    // (undocumented)
    IntroducedStatusCategory = 2,
    // (undocumented)
    None = 0
}

// @internal
export class RpcPushChannel<T> {
    static create<T>(name: string, service?: RpcPushService): RpcPushChannel<T>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    static enabled: boolean;
    // (undocumented)
    get enabled(): boolean;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get isDisposed(): boolean;
    // (undocumented)
    readonly name: string;
    static obtain<T>(name: string, service?: RpcPushService): RpcPushChannel<T>;
    // (undocumented)
    readonly service: RpcPushService;
    // (undocumented)
    static setup(transport: RpcPushTransport): void;
    // (undocumented)
    subscribe(): RpcPushSubscription<T>;
}

// @internal
export abstract class RpcPushConnection<T> {
    protected constructor(channel: RpcPushChannel<T>, client: unknown);
    // (undocumented)
    readonly channel: RpcPushChannel<T>;
    // (undocumented)
    readonly client: unknown;
    // (undocumented)
    static for<T>(_channel: RpcPushChannel<T>, _client?: unknown): RpcPushConnection<T>;
    // (undocumented)
    abstract send(messageData: T): Promise<void>;
}

// @internal (undocumented)
export type RpcPushMessageListener<T> = (message: T) => void;

// @internal
export class RpcPushService {
    constructor(name: string);
    static dedicated: RpcPushService;
    // (undocumented)
    readonly name: string;
}

// @internal
export class RpcPushSubscription<T> {
    constructor(channel: RpcPushChannel<T>);
    // (undocumented)
    readonly channel: RpcPushChannel<T>;
    // (undocumented)
    readonly onMessage: BeEvent<RpcPushMessageListener<T>>;
}

// @internal
export abstract class RpcPushTransport {
    // (undocumented)
    onMessage?: (channelId: string, messageData: any) => void;
}

// @internal (undocumented)
export class RpcRegistry {
    // (undocumented)
    definitionClasses: Map<string, RpcInterfaceDefinition>;
    // (undocumented)
    describeAvailableEndpoints(): Promise<RpcInterfaceEndpoints[]>;
    // (undocumented)
    getClientForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>, routing?: RpcRoutingToken): T;
    // (undocumented)
    getImplForInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): T;
    // (undocumented)
    id: () => number;
    // (undocumented)
    implementationClasses: Map<string, RpcInterfaceImplementation>;
    // (undocumented)
    implementations: Map<string, RpcInterface>;
    // (undocumented)
    initializeRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    static get instance(): RpcRegistry;
    // (undocumented)
    isRpcInterfaceInitialized<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): boolean;
    // (undocumented)
    lookupImpl<T extends RpcInterface>(interfaceName: string): T;
    // (undocumented)
    lookupInterfaceDefinition(name: string): RpcInterfaceDefinition;
    // (undocumented)
    proxies: Map<string, Map<number, RpcInterface>>;
    // (undocumented)
    registerImpl<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, implementation: RpcInterfaceImplementation<TImplementation>): void;
    // (undocumented)
    suppliedImplementations: Map<string, RpcInterface>;
    // (undocumented)
    supplyImplInstance<TDefinition extends RpcInterface, TImplementation extends TDefinition>(definition: RpcInterfaceDefinition<TDefinition>, instance: TImplementation): void;
    // (undocumented)
    terminateRpcInterface<T extends RpcInterface>(definition: RpcInterfaceDefinition<T>): void;
    // (undocumented)
    unregisterImpl<TDefinition extends RpcInterface>(definition: RpcInterfaceDefinition<TDefinition>): void;
}

// @internal
export abstract class RpcRequest<TResponse = any> {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    static get activeRequests(): ReadonlyMap<string, RpcRequest>;
    static get aggregateLoad(): RpcOperationsProfile;
    // (undocumented)
    cancel(): void;
    readonly client: RpcInterface;
    // (undocumented)
    protected computeRetryAfter(attempts: number): number;
    get connecting(): boolean;
    static current(context: RpcInterface): RpcRequest;
    // (undocumented)
    dispose(): void;
    get elapsed(): number;
    static readonly events: BeEvent<RpcRequestEventHandler>;
    get extendedStatus(): string;
    // (undocumented)
    _extendedStatus: string;
    findParameterOfType<T>(requiredProperties: {
        [index: string]: string;
    }): T | undefined;
    findTokenPropsParameter(): IModelRpcProps | undefined;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    readonly id: string;
    get lastSubmitted(): number;
    get lastUpdated(): number;
    protected abstract load(): Promise<RpcSerializedValue>;
    method: string;
    static readonly notFoundHandlers: BeEvent<RpcRequestNotFoundHandler>;
    readonly operation: RpcOperation;
    parameters: any[];
    path: string;
    get pending(): boolean;
    readonly protocol: RpcProtocol;
    // (undocumented)
    protected _rawPromise: Promise<Response | undefined>;
    get rawResponse(): Promise<Response | undefined>;
    // (undocumented)
    protected recordTransientFault(): void;
    // (undocumented)
    protected reject(reason: any): void;
    // (undocumented)
    protected resetTransientFaultCount(): void;
    // (undocumented)
    protected _resolveRaw: (value?: Response | PromiseLike<Response> | undefined) => void;
    readonly response: Promise<TResponse | undefined>;
    // (undocumented)
    protected _response: Response | undefined;
    // (undocumented)
    responseProtocolVersion: RpcProtocolVersion;
    get retryAfter(): number | null;
    retryInterval: number;
    protected abstract send(): Promise<number>;
    protected abstract setHeader(name: string, value: string): void;
    // (undocumented)
    protected setHeaders(): Promise<void>;
    protected setLastUpdatedTime(): void;
    get status(): RpcRequestStatus;
    // (undocumented)
    _status: RpcRequestStatus;
    // (undocumented)
    submit(): Promise<void>;
    // (undocumented)
    protected supportsStatusCategory(): boolean;
}

// @internal
export type RpcRequestCallback_T = (request: RpcRequest) => void;

// @internal
export interface RpcRequestContext {
    getId: (request: RpcRequest) => string;
    serialize: (request: RpcRequest) => Promise<SerializedRpcActivity>;
}

// @public
export enum RpcRequestEvent {
    // (undocumented)
    PendingUpdateReceived = 1,
    // (undocumented)
    StatusChanged = 0,
    // (undocumented)
    TransientErrorReceived = 2
}

// @internal
export type RpcRequestEventHandler = (type: RpcRequestEvent, request: RpcRequest) => void;

// @internal
export interface RpcRequestFulfillment {
    allowCompression?: boolean;
    id: string;
    interfaceName: string;
    rawResult: any;
    result: RpcSerializedValue;
    // (undocumented)
    retry?: string;
    status: number;
}

// @internal (undocumented)
export namespace RpcRequestFulfillment {
    // (undocumented)
    export function forUnknownError(request: SerializedRpcRequest, error: any): Promise<RpcRequestFulfillment>;
}

// @internal
export type RpcRequestInitialRetryIntervalSupplier_T = (configuration: RpcConfiguration) => number;

// @internal
export type RpcRequestNotFoundHandler = (request: RpcRequest, response: RpcNotFoundResponse, resubmit: () => void, reject: (reason: any) => void) => void;

// @public
export enum RpcRequestStatus {
    // (undocumented)
    BadGateway = 10,
    // (undocumented)
    Cancelled = 8,
    // (undocumented)
    Created = 1,
    // (undocumented)
    Disposed = 6,
    // (undocumented)
    GatewayTimeout = 12,
    // (undocumented)
    NoContent = 9,
    // (undocumented)
    NotFound = 7,
    // (undocumented)
    Pending = 3,
    // (undocumented)
    Rejected = 5,
    // (undocumented)
    Resolved = 4,
    // (undocumented)
    ServiceUnavailable = 11,
    // (undocumented)
    Submitted = 2,
    // (undocumented)
    Unknown = 0
}

// @public (undocumented)
export namespace RpcRequestStatus {
    // (undocumented)
    export function isTransientError(status: RpcRequestStatus): boolean;
}

// @internal
export type RpcRequestTokenSupplier_T = (request: RpcRequest) => IModelRpcProps | undefined;

// @public
export enum RpcResponseCacheControl {
    // (undocumented)
    Immutable = 1,
    // (undocumented)
    None = 0
}

// @internal
export type RpcResponseCachingCallback_T = (request: RpcRequest) => RpcResponseCacheControl;

// @internal (undocumented)
export interface RpcRoutingMap extends RpcConfigurationSupplier {
    // (undocumented)
    configurations: Map<number, RpcConfigurationSupplier>;
}

// @internal (undocumented)
export namespace RpcRoutingMap {
    // (undocumented)
    export function create(): RpcRoutingMap;
}

// @internal (undocumented)
export class RpcRoutingToken {
    // (undocumented)
    readonly debugLabel: string;
    // (undocumented)
    static readonly default: RpcRoutingToken;
    // (undocumented)
    static generate(debugLabel?: string): RpcRoutingToken;
    // (undocumented)
    readonly id: number;
}

// @internal (undocumented)
export interface RpcSerializedValue {
    // (undocumented)
    chunks?: number;
    // (undocumented)
    data: Uint8Array[];
    // (undocumented)
    objects: string;
    // (undocumented)
    stream?: Readable;
}

// @internal (undocumented)
export namespace RpcSerializedValue {
    // (undocumented)
    export function create(objects?: string, data?: Uint8Array[]): RpcSerializedValue;
}

// @internal (undocumented)
export class RpcSessionInvocation extends RpcInvocation {
    // (undocumented)
    static create(request: InterceptedRpcRequest): RpcSessionInvocation;
    // (undocumented)
    get rejected(): boolean;
}

// @beta
export enum SchemaState {
    TooNew = 4,
    TooOld = 3,
    UpgradeRecommended = 2,
    UpgradeRequired = 1,
    UpToDate = 0
}

// @public
export interface SectionDrawingLocationProps extends GeometricElement3dProps {
    sectionView?: RelatedElementProps;
}

// @public
export interface SectionDrawingProps extends ElementProps {
    // (undocumented)
    jsonProperties?: {
        drawingToSpatialTransform?: TransformProps;
        sheetToSpatialTransform?: TransformProps;
        drawingBoundaryClip?: ClipVectorProps;
        displaySpatialView?: true;
    };
    sectionType?: SectionType;
    spatialView?: RelatedElementProps;
}

// @public
export interface SectionDrawingViewProps {
    displaySpatialView: boolean;
    drawingToSpatialTransform?: TransformProps;
    spatialView: Id64String;
}

// @public
export enum SectionType {
    // (undocumented)
    Detail = 4,
    // (undocumented)
    Elevation = 5,
    // (undocumented)
    Plan = 6,
    // (undocumented)
    Section = 3
}

// @public
export interface SerializedRpcActivity {
    // (undocumented)
    applicationId: string;
    // (undocumented)
    applicationVersion: string;
    // (undocumented)
    authorization: string;
    // (undocumented)
    csrfToken?: {
        headerName: string;
        headerValue: string;
    };
    // (undocumented)
    id: string;
    // (undocumented)
    sessionId: string;
}

// @internal
export interface SerializedRpcOperation {
    // (undocumented)
    encodedRequest?: string;
    // (undocumented)
    interfaceDefinition: string;
    // (undocumented)
    interfaceVersion: string;
    // (undocumented)
    operationName: string;
}

// @internal
export interface SerializedRpcRequest extends SerializedRpcActivity {
    // (undocumented)
    caching: RpcResponseCacheControl;
    // (undocumented)
    ip?: string;
    // (undocumented)
    method: string;
    // (undocumented)
    operation: SerializedRpcOperation;
    // (undocumented)
    parameters: RpcSerializedValue;
    // (undocumented)
    parametersOverride?: any[];
    // (undocumented)
    path: string;
    // (undocumented)
    protocolVersion?: number;
}

// @public (undocumented)
export class ServerError extends IModelError {
    constructor(errorNumber: number, message: string);
}

// @public (undocumented)
export class ServerTimeoutError extends ServerError {
    constructor(message: string);
}

// @public
export interface SessionProps {
    readonly applicationId: string;
    readonly applicationVersion: string;
    readonly sessionId: GuidString;
}

// @beta
export interface SheetBorderTemplateProps extends ElementProps {
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @public
export interface SheetProps extends ElementProps {
    // (undocumented)
    attachments?: Id64String[];
    // (undocumented)
    height?: number;
    // (undocumented)
    scale?: number;
    // (undocumented)
    sheetTemplate?: Id64String;
    // (undocumented)
    width?: number;
}

// @beta
export interface SheetTemplateProps extends ElementProps {
    // (undocumented)
    border?: Id64String;
    // (undocumented)
    height?: number;
    // (undocumented)
    width?: number;
}

// @internal (undocumented)
export class SilhouetteEdgeArgs extends EdgeArgs {
    // (undocumented)
    clear(): void;
    // (undocumented)
    init(meshEdges?: MeshEdges): boolean;
    // (undocumented)
    normals?: OctEncodedNormalPair[];
}

// @public
export class SkyBox {
    protected constructor(gradient: SkyGradient);
    static createGradient(gradient?: SkyGradient): SkyBox;
    static readonly defaults: SkyBox;
    static fromJSON(props?: SkyBoxProps): SkyBox;
    readonly gradient: SkyGradient;
    // @internal (undocumented)
    get textureIds(): Iterable<Id64String>;
    toJSON(display?: boolean): SkyBoxProps;
}

// @public
export type SkyBoxImageProps = SkySphereImageProps | SkyCubeImageProps | {
    type?: SkyBoxImageType;
    texture?: never;
    textures?: never;
};

// @public
export enum SkyBoxImageType {
    Cube = 3,
    // @internal
    Cylindrical = 2,
    None = 0,
    Spherical = 1
}

// @public
export interface SkyBoxProps {
    display?: boolean;
    groundColor?: ColorDefProps;
    groundExponent?: number;
    image?: SkyBoxImageProps;
    nadirColor?: ColorDefProps;
    skyColor?: ColorDefProps;
    skyExponent?: number;
    twoColor?: boolean;
    zenithColor?: ColorDefProps;
}

// @public
export class SkyCube extends SkyBox {
    constructor(images: SkyCubeProps, gradient?: SkyGradient);
    readonly images: SkyCubeProps;
    // @internal (undocumented)
    get textureIds(): Iterable<Id64String>;
    // @internal
    toJSON(display?: boolean): SkyBoxProps;
}

// @public
export interface SkyCubeImageProps {
    // @internal (undocumented)
    texture?: never;
    // (undocumented)
    textures: SkyCubeProps;
    // (undocumented)
    type: SkyBoxImageType.Cube;
}

// @public
export interface SkyCubeProps {
    // (undocumented)
    back: TextureImageSpec;
    // (undocumented)
    bottom: TextureImageSpec;
    // (undocumented)
    front: TextureImageSpec;
    // (undocumented)
    left: TextureImageSpec;
    // (undocumented)
    right: TextureImageSpec;
    // (undocumented)
    top: TextureImageSpec;
}

// @public
export class SkyGradient {
    clone(changedProps: SkyGradientProperties): SkyGradient;
    static create(props?: Partial<SkyGradientProperties>): SkyGradient;
    static readonly defaults: SkyGradient;
    equals(other: SkyGradient): boolean;
    static fromJSON(props?: SkyBoxProps): SkyGradient;
    // (undocumented)
    readonly groundColor: ColorDef;
    // (undocumented)
    readonly groundExponent: number;
    // (undocumented)
    readonly nadirColor: ColorDef;
    // (undocumented)
    readonly skyColor: ColorDef;
    // (undocumented)
    readonly skyExponent: number;
    toJSON(): SkyBoxProps;
    // (undocumented)
    readonly twoColor: boolean;
    // (undocumented)
    readonly zenithColor: ColorDef;
}

// @public
export type SkyGradientProperties = NonFunctionPropertiesOf<SkyGradient>;

// @public
export class SkySphere extends SkyBox {
    constructor(image: TextureImageSpec, gradient?: SkyGradient);
    readonly image: TextureImageSpec;
    // @internal (undocumented)
    get textureIds(): Iterable<Id64String>;
    // @internal
    toJSON(display?: boolean): SkyBoxProps;
}

// @public
export interface SkySphereImageProps {
    // (undocumented)
    texture: TextureImageSpec;
    // @internal (undocumented)
    textures?: never;
    // (undocumented)
    type: SkyBoxImageType.Spherical;
}

// @internal
export interface SnapRequestProps {
    // (undocumented)
    closePoint: XYZProps;
    // (undocumented)
    decorationGeometry?: DecorationGeometryProps[];
    // (undocumented)
    geometryClass?: GeometryClass;
    // (undocumented)
    id: Id64String;
    // (undocumented)
    intersectCandidates?: Id64Array;
    // (undocumented)
    snapAperture?: number;
    // (undocumented)
    snapDivisor?: number;
    // (undocumented)
    snapModes?: number[];
    // (undocumented)
    subCategoryId?: Id64String;
    // (undocumented)
    testPoint: XYZProps;
    // (undocumented)
    viewFlags?: ViewFlagProps;
    // (undocumented)
    worldToView: Matrix4dProps;
}

// @internal
export interface SnapResponseProps {
    // (undocumented)
    curve?: any;
    // (undocumented)
    geomType?: number;
    // (undocumented)
    heat?: number;
    // (undocumented)
    hitPoint?: XYZProps;
    // (undocumented)
    intersectCurve?: any;
    // (undocumented)
    intersectId?: string;
    // (undocumented)
    normal?: XYZProps;
    // (undocumented)
    parentGeomType?: number;
    // (undocumented)
    snapMode?: number;
    // (undocumented)
    snapPoint?: XYZProps;
    // (undocumented)
    status: number;
}

// @internal
export abstract class SnapshotIModelRpcInterface extends RpcInterface {
    // (undocumented)
    close(_iModelRpcProps: IModelRpcProps): Promise<boolean>;
    static getClient(): SnapshotIModelRpcInterface;
    static getClientForRouting(token: RpcRoutingToken): SnapshotIModelRpcInterface;
    static readonly interfaceName = "SnapshotIModelRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    openFile(_filePath: string, _opts?: SnapshotOpenOptions): Promise<IModelConnectionProps>;
    // (undocumented)
    openRemote(_key: string, _opts?: SnapshotOpenOptions): Promise<IModelConnectionProps>;
}

// @public
export interface SnapshotOpenOptions extends IModelEncryptionProps, OpenDbKey {
    // @internal
    readonly tempFileBase?: string;
}

// @public
export class SolarLight {
    constructor(json?: SolarLightProps);
    readonly alwaysEnabled: boolean;
    clone(changedProps?: SolarLightProps): SolarLight;
    readonly direction: Readonly<Vector3d>;
    // (undocumented)
    equals(rhs: SolarLight): boolean;
    readonly intensity: number;
    readonly timePoint?: number;
    // (undocumented)
    toJSON(): SolarLightProps | undefined;
}

// @public
export interface SolarLightProps {
    alwaysEnabled?: boolean;
    direction?: XYZProps;
    intensity?: number;
    timePoint?: number;
}

// @public
export class SolarShadowSettings {
    // @internal (undocumented)
    readonly bias: number;
    clone(changedProps?: SolarShadowSettingsProps): SolarShadowSettings;
    readonly color: RgbColor;
    // (undocumented)
    static defaults: SolarShadowSettings;
    // (undocumented)
    equals(rhs: SolarShadowSettings): boolean;
    // (undocumented)
    static fromJSON(props?: SolarShadowSettingsProps): SolarShadowSettings;
    // (undocumented)
    toJSON(): SolarShadowSettingsProps | undefined;
}

// @public
export interface SolarShadowSettingsProps {
    // @internal (undocumented)
    bias?: number;
    color?: ColorDefProps;
}

// @public
export interface SourceAndTarget {
    // (undocumented)
    sourceId: Id64String;
    // (undocumented)
    targetId: Id64String;
}

// @public
export class SpatialClassifier {
    constructor(modelId: Id64String, name: string, flags?: SpatialClassifierFlags, expand?: number);
    clone(changedProps?: Partial<SpatialClassifierProps>): SpatialClassifier;
    equals(other: SpatialClassifier): boolean;
    equalsProps(props: SpatialClassifierProps): boolean;
    readonly expand: number;
    readonly flags: SpatialClassifierFlags;
    static fromJSON(props: SpatialClassifierProps): SpatialClassifier;
    // @beta
    static fromModelMapLayer(mapLayer: ModelMapLayerSettings): SpatialClassifier;
    readonly modelId: Id64String;
    readonly name: string;
    toJSON(): SpatialClassifierProps;
}

// @public
export class SpatialClassifierFlags {
    constructor(inside?: SpatialClassifierInsideDisplay, outside?: SpatialClassifierOutsideDisplay, isVolumeClassifier?: boolean);
    clone(changedProps?: Partial<SpatialClassifierFlagsProps>): SpatialClassifierFlags;
    equals(other: SpatialClassifierFlags): boolean;
    equalsProps(props: SpatialClassifierFlagsProps): boolean;
    static fromJSON(props: SpatialClassifierFlagsProps): SpatialClassifierFlags;
    readonly inside: SpatialClassifierInsideDisplay;
    readonly isVolumeClassifier: boolean;
    readonly outside: SpatialClassifierOutsideDisplay;
    toJSON(): SpatialClassifierFlagsProps;
}

// @public
export interface SpatialClassifierFlagsProps {
    inside: SpatialClassifierInsideDisplay;
    isVolumeClassifier?: boolean;
    outside: SpatialClassifierOutsideDisplay;
}

// @public
export enum SpatialClassifierInsideDisplay {
    Dimmed = 2,
    ElementColor = 4,
    Hilite = 3,
    Off = 0,
    On = 1
}

// @public
export enum SpatialClassifierOutsideDisplay {
    Dimmed = 2,
    Off = 0,
    On = 1
}

// @public
export interface SpatialClassifierProps {
    expand: number;
    flags: SpatialClassifierFlagsProps;
    isActive?: boolean;
    modelId: Id64String;
    name: string;
}

// @public
export class SpatialClassifiers implements Iterable<SpatialClassifier> {
    [Symbol.iterator](): Iterator<SpatialClassifier>;
    constructor(container: SpatialClassifiersContainer);
    get active(): SpatialClassifier | undefined;
    add(classifier: SpatialClassifier): SpatialClassifier;
    clear(): void;
    delete(classifier: SpatialClassifier): SpatialClassifier | undefined;
    find(criterion: (classifier: SpatialClassifier) => boolean): SpatialClassifier | undefined;
    findEquivalent(classifier: SpatialClassifier): SpatialClassifier | undefined;
    has(classifier: SpatialClassifier): boolean;
    replace(toReplace: SpatialClassifier, replacement: SpatialClassifier): boolean;
    setActive(active: SpatialClassifier | undefined): SpatialClassifier | undefined;
    get size(): number;
}

// @public
export interface SpatialClassifiersContainer {
    classifiers?: SpatialClassifierProps[];
}

// @public
export interface SpatialViewDefinitionProps extends ViewDefinition3dProps {
    // (undocumented)
    modelSelectorId: Id64String;
}

// @public
export type StandaloneOpenOptions = OpenDbKey;

// @beta
export type StorageValue = string | number | boolean | undefined | Uint8Array;

// @public
export class SubCategoryAppearance {
    constructor(props?: SubCategoryAppearance.Props);
    // (undocumented)
    clone(): SubCategoryAppearance;
    readonly color: ColorDef;
    // (undocumented)
    static defaults: SubCategoryAppearance;
    // @internal (undocumented)
    readonly dontLocate: boolean;
    // @internal (undocumented)
    readonly dontPlot: boolean;
    // @internal (undocumented)
    readonly dontSnap: boolean;
    // (undocumented)
    equals(other: SubCategoryAppearance): boolean;
    get fillColor(): ColorDef;
    // @internal (undocumented)
    protected readonly _fillColor?: ColorDef;
    get fillTransparency(): number;
    // @internal (undocumented)
    protected readonly _fillTransparency?: number;
    readonly invisible: boolean;
    readonly materialId: Id64String;
    readonly priority: number;
    readonly styleId: Id64String;
    // @internal (undocumented)
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency: number;
    readonly weight: number;
}

// @public (undocumented)
export namespace SubCategoryAppearance {
    export interface Props {
        color?: ColorDefProps;
        // @internal (undocumented)
        dontLocate?: boolean;
        // @internal (undocumented)
        dontPlot?: boolean;
        // @internal (undocumented)
        dontSnap?: boolean;
        fill?: ColorDefProps;
        invisible?: boolean;
        material?: Id64String;
        priority?: number;
        style?: Id64String;
        transp?: number;
        transpFill?: number;
        weight?: number;
    }
}

// @public
export class SubCategoryOverride {
    get anyOverridden(): boolean;
    readonly color?: ColorDef;
    static defaults: SubCategoryOverride;
    equals(other: SubCategoryOverride): boolean;
    static fromJSON(json?: SubCategoryAppearance.Props): SubCategoryOverride;
    readonly invisible?: boolean;
    readonly material?: Id64String;
    override(appearance: SubCategoryAppearance): SubCategoryAppearance;
    readonly priority?: number;
    // @internal
    readonly style?: Id64String;
    // @internal
    toJSON(): SubCategoryAppearance.Props;
    readonly transparency?: number;
    readonly weight?: number;
}

// @public
export interface SubCategoryPlanarClipMaskArgs extends BasicPlanarClipMaskArgs {
    // @internal (undocumented)
    elementIds?: never;
    // @internal (undocumented)
    exclude?: never;
    modelIds?: Iterable<Id64String>;
    // @internal (undocumented)
    priority?: never;
    subCategoryIds: Iterable<Id64String>;
}

// @public
export interface SubCategoryProps extends DefinitionElementProps {
    // (undocumented)
    appearance?: SubCategoryAppearance.Props;
    // (undocumented)
    description?: string;
}

// @internal
export interface SubCategoryResultRow {
    // (undocumented)
    appearance: SubCategoryAppearance.Props;
    // (undocumented)
    id: Id64String;
    // (undocumented)
    parentId: Id64String;
}

// @public
export interface SubjectProps extends ElementProps {
    // (undocumented)
    description?: string;
}

// @public (undocumented)
export type SubLayerId = string | number;

// @beta
export interface SynchronizationConfigLinkProps extends UrlLinkProps {
    // (undocumented)
    lastSuccessfulRun?: string;
}

// @public
export enum SyncMode {
    FixedVersion = 1,
    PullAndPush = 2,
    PullOnly = 3
}

// @public
export enum TerrainHeightOriginMode {
    Geodetic = 0,
    Geoid = 1,
    Ground = 2
}

// @public
export interface TerrainProps {
    applyLighting?: boolean;
    exaggeration?: number;
    heightOrigin?: number;
    heightOriginMode?: TerrainHeightOriginMode;
    // @internal
    nonLocatable?: boolean;
    providerName?: string;
}

// @public
export type TerrainProviderName = "CesiumWorldTerrain";

// @public
export class TerrainSettings {
    constructor(providerName?: TerrainProviderName, exaggeration?: number, applyLighting?: boolean, heightOrigin?: number, heightOriginMode?: TerrainHeightOriginMode);
    readonly applyLighting: boolean;
    clone(changedProps?: TerrainProps): TerrainSettings;
    // (undocumented)
    equals(other: TerrainSettings): boolean;
    equalsJSON(json?: BackgroundMapProps): boolean;
    readonly exaggeration: number;
    // (undocumented)
    static fromJSON(json?: TerrainProps): TerrainSettings;
    readonly heightOrigin: number;
    readonly heightOriginMode: TerrainHeightOriginMode;
    // @internal
    get nonLocatable(): true | undefined;
    readonly providerName: TerrainProviderName;
    // (undocumented)
    toJSON(): TerrainProps;
}

// @internal
export class TestRpcManager {
    // (undocumented)
    static initialize(interfaces: RpcInterfaceDefinition[]): void;
}

// @public
export class TextString {
    constructor(props: TextStringProps);
    bold?: boolean;
    font: FontId;
    // (undocumented)
    height: number;
    italic?: boolean;
    readonly origin: Point3d;
    readonly rotation: YawPitchRollAngles;
    text: string;
    // (undocumented)
    toJSON(): TextStringProps;
    // (undocumented)
    transformInPlace(transform: Transform): boolean;
    underline?: boolean;
    // (undocumented)
    get width(): number;
    // (undocumented)
    widthFactor?: number;
}

// @public
export interface TextStringPrimitive {
    // (undocumented)
    readonly textString: TextString;
    // (undocumented)
    type: "textString";
}

// @public
export interface TextStringProps {
    bold?: boolean;
    font: FontId;
    // (undocumented)
    height: number;
    italic?: boolean;
    origin?: XYZProps;
    rotation?: YawPitchRollProps;
    text: string;
    underline?: boolean;
    // (undocumented)
    widthFactor?: number;
}

// @public
export interface TextureData {
    bytes: Uint8Array;
    format: ImageSourceFormat;
    height: number;
    transparency?: TextureTransparency;
    width: number;
}

// @public
export type TextureImageSpec = Id64String | string;

// @public
export interface TextureLoadProps {
    maxTextureSize?: number;
    name: Id64String;
}

// @public
export class TextureMapping {
    constructor(tx: RenderTexture, params: TextureMapping.Params);
    // @internal (undocumented)
    computeUVParams(visitor: PolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
    readonly params: TextureMapping.Params;
    readonly texture: RenderTexture;
}

// @public (undocumented)
export namespace TextureMapping {
    export enum Mode {
        // @internal (undocumented)
        Cubic = 4,
        // @internal (undocumented)
        Cylindrical = 6,
        // @internal (undocumented)
        DirectionalDrape = 3,
        // (undocumented)
        ElevationDrape = 1,
        // @internal
        FrontProject = 8,
        // (undocumented)
        None = -1,
        // (undocumented)
        Parametric = 0,
        // (undocumented)
        Planar = 2,
        // @internal (undocumented)
        Solid = 7,
        // @internal (undocumented)
        Spherical = 5
    }
    export interface ParamProps {
        mapMode?: TextureMapping.Mode;
        textureMat2x3?: TextureMapping.Trans2x3;
        textureWeight?: number;
        // @internal (undocumented)
        worldMapping?: boolean;
    }
    export class Params {
        constructor(props?: TextureMapping.ParamProps);
        // @internal
        computeUVParams(visitor: IndexedPolyfaceVisitor, transformToImodel: Transform): Point2d[] | undefined;
        mode: TextureMapping.Mode;
        textureMatrix: TextureMapping.Trans2x3;
        weight: number;
        // @internal (undocumented)
        worldMapping: boolean;
    }
    export class Trans2x3 {
        constructor(m00?: number, m01?: number, originX?: number, m10?: number, m11?: number, originY?: number);
        static readonly identity: Trans2x3;
        readonly transform: Transform;
    }
}

// @public
export interface TextureMapProps {
    pattern_angle?: number;
    pattern_flip?: boolean;
    pattern_mapping?: TextureMapping.Mode;
    pattern_offset?: Point2dProps;
    pattern_scale?: Point2dProps;
    pattern_scalemode?: TextureMapUnits;
    pattern_u_flip?: boolean;
    pattern_weight?: number;
    TextureId: Id64String;
}

// @public
export enum TextureMapUnits {
    // (undocumented)
    Feet = 5,
    // (undocumented)
    Inches = 6,
    // (undocumented)
    Meters = 3,
    // (undocumented)
    Millimeters = 4,
    Relative = 0
}

// @public
export interface TextureProps extends DefinitionElementProps {
    data: Base64EncodedString;
    description?: string;
    format: ImageSourceFormat;
}

// @public
export enum TextureTransparency {
    Mixed = 2,
    Opaque = 0,
    Translucent = 1
}

// @public
export class ThematicDisplay {
    readonly axis: Vector3d;
    readonly displayMode: ThematicDisplayMode;
    // (undocumented)
    equals(other: ThematicDisplay): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplayProps): ThematicDisplay;
    readonly gradientSettings: ThematicGradientSettings;
    readonly range: Range1d;
    readonly sensorSettings: ThematicDisplaySensorSettings;
    readonly sunDirection: Vector3d;
    // (undocumented)
    toJSON(): ThematicDisplayProps;
}

// @public
export enum ThematicDisplayMode {
    Height = 0,
    HillShade = 3,
    InverseDistanceWeightedSensors = 1,
    Slope = 2
}

// @public
export interface ThematicDisplayProps {
    axis?: XYZProps;
    displayMode?: ThematicDisplayMode;
    gradientSettings?: ThematicGradientSettingsProps;
    range?: Range1dProps;
    sensorSettings?: ThematicDisplaySensorSettingsProps;
    sunDirection?: XYZProps;
}

// @public
export class ThematicDisplaySensor {
    // (undocumented)
    equals(other: ThematicDisplaySensor): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplaySensorProps): ThematicDisplaySensor;
    position: Readonly<Point3d>;
    // (undocumented)
    toJSON(): ThematicDisplaySensorProps;
    readonly value: number;
}

// @public
export interface ThematicDisplaySensorProps {
    position?: XYZProps;
    value?: number;
}

// @public
export class ThematicDisplaySensorSettings {
    readonly distanceCutoff: number;
    // (undocumented)
    equals(other: ThematicDisplaySensorSettings): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicDisplaySensorSettingsProps): ThematicDisplaySensorSettings;
    readonly sensors: ThematicDisplaySensor[];
    // (undocumented)
    toJSON(): ThematicDisplaySensorSettingsProps;
}

// @public
export interface ThematicDisplaySensorSettingsProps {
    distanceCutoff?: number;
    sensors?: ThematicDisplaySensorProps[];
}

// @public
export enum ThematicGradientColorScheme {
    BlueRed = 0,
    Custom = 5,
    Monochrome = 2,
    RedBlue = 1,
    SeaMountain = 4,
    Topographic = 3
}

// @public
export enum ThematicGradientMode {
    IsoLines = 3,
    Smooth = 0,
    Stepped = 1,
    SteppedWithDelimiter = 2
}

// @public
export class ThematicGradientSettings {
    clone(changedProps?: ThematicGradientSettingsProps): ThematicGradientSettings;
    readonly colorMix: number;
    readonly colorScheme: ThematicGradientColorScheme;
    static compare(lhs: ThematicGradientSettings, rhs: ThematicGradientSettings): number;
    // (undocumented)
    static get contentMax(): number;
    // (undocumented)
    static get contentRange(): number;
    readonly customKeys: Gradient.KeyColor[];
    // (undocumented)
    static readonly defaults: ThematicGradientSettings;
    // (undocumented)
    equals(other: ThematicGradientSettings): boolean;
    // (undocumented)
    static fromJSON(json?: ThematicGradientSettingsProps): ThematicGradientSettings;
    // (undocumented)
    static get margin(): number;
    readonly marginColor: ColorDef;
    readonly mode: ThematicGradientMode;
    readonly stepCount: number;
    // (undocumented)
    toJSON(): ThematicGradientSettingsProps;
}

// @public
export interface ThematicGradientSettingsProps {
    colorMix?: number;
    colorScheme?: ThematicGradientColorScheme;
    customKeys?: Gradient.KeyColorProps[];
    marginColor?: ColorDefProps;
    mode?: ThematicGradientMode;
    stepCount?: number;
}

// @public
export interface ThumbnailFormatProps {
    format: "jpeg" | "png";
    height: number;
    width: number;
}

// @public
export interface ThumbnailProps extends ThumbnailFormatProps {
    image: Uint8Array;
}

// @internal (undocumented)
export interface TileContentDescription extends TileContentMetadata {
    // (undocumented)
    readonly featureTableStartPos: number;
}

// @beta (undocumented)
export interface TileContentIdentifier {
    // (undocumented)
    contentId: string;
    // (undocumented)
    guid: string | undefined;
    // (undocumented)
    tokenProps: IModelRpcProps;
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileContentMetadata {
    // (undocumented)
    readonly contentRange: Range3d;
    // (undocumented)
    readonly emptySubRangeMask: number;
    // (undocumented)
    readonly isLeaf: boolean;
    // (undocumented)
    readonly sizeMultiplier?: number;
}

// @internal (undocumented)
export enum TileContentSource {
    // (undocumented)
    Backend = 0,
    // (undocumented)
    ExternalCache = 1
}

// @internal
export enum TileFormat {
    // (undocumented)
    A3x = 5780289,
    // (undocumented)
    B3dm = 1835283298,
    // (undocumented)
    Cmpt = 1953525091,
    // (undocumented)
    Gltf = 1179937895,
    // (undocumented)
    I3dm = 1835283305,
    // (undocumented)
    IModel = 1818512745,
    // (undocumented)
    Pnts = 1937010288,
    // (undocumented)
    Unknown = 0
}

// @internal
export function tileFormatFromNumber(formatNumber: number): TileFormat;

// @internal
export abstract class TileHeader {
    constructor(stream: ByteStream);
    // (undocumented)
    get format(): TileFormat;
    protected invalidate(): void;
    abstract get isValid(): boolean;
    // (undocumented)
    version: number;
}

// @internal
export interface TileMetadata extends TileContentMetadata {
    // (undocumented)
    readonly contentId: string;
    // (undocumented)
    readonly range: Range3d;
}

// @internal
export class TileMetadataReader {
    constructor(type: BatchType, is2d: boolean, options: TileOptions);
    read(stream: ByteStream, props: TileProps): TileMetadata;
}

// @internal (undocumented)
export interface TileOptions {
    // (undocumented)
    readonly alwaysSubdivideIncompleteTiles: boolean;
    // (undocumented)
    readonly disableMagnification: boolean;
    // (undocumented)
    readonly enableExternalTextures: boolean;
    // (undocumented)
    readonly enableImprovedElision: boolean;
    // (undocumented)
    readonly enableIndexedEdges: boolean;
    // (undocumented)
    readonly enableInstancing: boolean;
    // (undocumented)
    readonly generateAllPolyfaceEdges: boolean;
    // (undocumented)
    readonly ignoreAreaPatterns: boolean;
    // (undocumented)
    readonly maximumMajorTileFormatVersion: number;
    // (undocumented)
    readonly optimizeBRepProcessing: boolean;
    // (undocumented)
    readonly useLargerTiles: boolean;
    // (undocumented)
    readonly useProjectExtents: boolean;
}

// @internal (undocumented)
export namespace TileOptions {
    export function fromTreeIdAndContentId(treeId: string, contentId: string): TileOptions;
}

// @internal
export interface TileProps {
    contentId: string;
    contentRange?: Range3dProps;
    isLeaf?: boolean;
    maximumSize: number;
    range: Range3dProps;
    sizeMultiplier?: number;
}

// @internal
export class TileReadError extends BentleyError {
    constructor(status: TileReadStatus, message?: string);
    // (undocumented)
    get wasCanceled(): boolean;
}

// @internal
export enum TileReadStatus {
    // (undocumented)
    Canceled = 7,
    // (undocumented)
    InvalidBatchTable = 3,
    // (undocumented)
    InvalidFeatureTable = 5,
    // (undocumented)
    InvalidHeader = 2,
    // (undocumented)
    InvalidScene = 4,
    // (undocumented)
    InvalidTileData = 1,
    // (undocumented)
    NewerMajorVersion = 6,
    // (undocumented)
    Success = 0
}

// @internal
export interface TileTreeContentIds {
    // (undocumented)
    contentIds: string[];
    // (undocumented)
    treeId: string;
}

// @internal
export interface TileTreeMetadata {
    // (undocumented)
    readonly contentRange?: Range3d;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly tileScreenSize: number;
}

// @internal
export interface TileTreeProps {
    contentRange?: Range3dProps;
    id: string;
    location: TransformProps;
    maxTilesToSkip?: number;
    rootTile: TileProps;
}

// @public
export interface TileVersionInfo {
    formatVersion: number;
}

// @public
export interface TranslationOptions {
    [key: string]: any;
    context?: any;
    count?: number;
    defaultValue?: any;
    fallbackLng?: string;
    lngs?: string[];
}

// @alpha
export enum TreeFlags {
    // (undocumented)
    EnforceDisplayPriority = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    OptimizeBRepProcessing = 4,
    // (undocumented)
    UseLargerTiles = 8,
    // (undocumented)
    UseProjectExtents = 1
}

// @public
export class Tween {
    constructor(_group: Tweens, _object: any);
    // (undocumented)
    chain(...tweens: Tween[]): this;
    // (undocumented)
    delay(amount?: number): this;
    // (undocumented)
    duration(d: number): this;
    // (undocumented)
    easing(easingFunction?: EasingFunction): this;
    // (undocumented)
    end(): this;
    // (undocumented)
    getId(): number;
    // (undocumented)
    group(group: Tweens): this;
    // (undocumented)
    interpolation(interpolationFunction?: InterpolationFunction): this;
    // (undocumented)
    get isPaused(): boolean;
    // (undocumented)
    get isPlaying(): boolean;
    // (undocumented)
    onComplete(callback?: TweenCallback): this;
    // (undocumented)
    onRepeat(callback: TweenCallback): this;
    // (undocumented)
    onStart(callback: TweenCallback): this;
    // (undocumented)
    onStop(callback: TweenCallback): this;
    // (undocumented)
    onUpdate(callback: UpdateCallback): this;
    // (undocumented)
    pause(time: number): this;
    // (undocumented)
    repeat(times: number): this;
    // (undocumented)
    repeatDelay(amount: number): this;
    // (undocumented)
    resume(time?: number): this;
    // (undocumented)
    start(time?: string | number): this;
    // (undocumented)
    stop(): this;
    // (undocumented)
    stopChainedTweens(): void;
    // (undocumented)
    to(properties: any, duration?: number): this;
    // (undocumented)
    update(time: number): boolean;
    // (undocumented)
    yoyo(yoyo: boolean): this;
}

// @public (undocumented)
export type TweenCallback = (obj: any) => void;

// @public
export class Tweens {
    // (undocumented)
    add(tween: Tween): void;
    create(from: any, opts?: {
        to: any;
        duration: number;
        onUpdate: UpdateCallback;
        onComplete?: TweenCallback;
        delay?: number;
        start?: boolean;
        easing?: EasingFunction;
        interpolation?: InterpolationFunction;
    }): Tween;
    // (undocumented)
    getAll(): any[];
    // (undocumented)
    nextId(): number;
    // (undocumented)
    remove(tween: Tween): void;
    // (undocumented)
    removeAll(): void;
    // (undocumented)
    update(time?: number, preserve?: boolean): boolean;
}

// @public
export enum TxnAction {
    Abandon = 2,
    Commit = 1,
    Merge = 5,
    None = 0,
    Reinstate = 4,
    Reverse = 3
}

// @internal
export interface TxnNotifications {
    // (undocumented)
    notifyAfterUndoRedo: (isUndo: boolean) => void;
    // (undocumented)
    notifyBeforeUndoRedo: (isUndo: boolean) => void;
    // (undocumented)
    notifyChangesApplied: () => void;
    // (undocumented)
    notifyCommit: () => void;
    // (undocumented)
    notifyCommitted: (hasPendingTxns: boolean, time: number) => void;
    // (undocumented)
    notifyEcefLocationChanged: (ecef: EcefLocationProps | undefined) => void;
    // (undocumented)
    notifyElementsChanged: (changes: ChangedEntities) => void;
    // (undocumented)
    notifyGeographicCoordinateSystemChanged: (gcs: GeographicCRSProps | undefined) => void;
    // (undocumented)
    notifyGeometryGuidsChanged: (changes: ModelIdAndGeometryGuid[]) => void;
    // (undocumented)
    notifyGlobalOriginChanged: (origin: XYZProps) => void;
    // (undocumented)
    notifyIModelNameChanged: (name: string) => void;
    // (undocumented)
    notifyModelsChanged: (changes: ChangedEntities) => void;
    // (undocumented)
    notifyProjectExtentsChanged: (extents: Range3dProps) => void;
    // (undocumented)
    notifyPulledChanges: (parentChangeSetId: ChangesetIndexAndId) => void;
    // (undocumented)
    notifyPushedChanges: (parentChangeSetId: ChangesetIndexAndId) => void;
    // (undocumented)
    notifyRootSubjectChanged: (subject: RootSubjectProps) => void;
}

// @public
export class TypeDefinition extends RelatedElement {
}

// @public
export interface TypeDefinitionElementProps extends DefinitionElementProps {
    // (undocumented)
    recipe?: RelatedElementProps;
}

// @internal
export type TypedGltfChunk = GltfChunk & {
    type: number;
};

// @public
export enum TypeOfChange {
    Geometry = 2,
    Hidden = 16,
    Indirect = 8,
    Placement = 4,
    Property = 1
}

// @public
export type UnitType = "Meter" | "InternationalFoot" | "USSurveyFoot" | "Degree" | "Unsupported";

// @public (undocumented)
export type UpdateCallback = (obj: any, t: number) => void;

// @beta
export interface UpgradeOptions {
    readonly domain?: DomainOptions;
    readonly profile?: ProfileOptions;
}

// @public
export interface UrlLinkProps extends ElementProps {
    // (undocumented)
    description?: string;
    // (undocumented)
    url?: string;
}

// @public
export class VerticalCRS implements VerticalCRSProps {
    constructor(data?: VerticalCRSProps);
    equals(other: VerticalCRS): boolean;
    static fromJSON(data: VerticalCRSProps): VerticalCRS;
    readonly id: "GEOID" | "ELLIPSOID" | "NGVD29" | "NAVD88" | "LOCAL_ELLIPSOID";
    toJSON(): VerticalCRSProps;
}

// @public
export interface VerticalCRSProps {
    id: "GEOID" | "ELLIPSOID" | "NGVD29" | "NAVD88" | "LOCAL_ELLIPSOID";
}

// @public (undocumented)
export interface ViewAttachmentLabelProps extends GeometricElement2dProps {
    // (undocumented)
    viewAttachment?: RelatedElementProps;
}

// @public
export interface ViewAttachmentProps extends GeometricElement2dProps {
    // (undocumented)
    jsonProperties?: {
        displayPriority?: number;
        clip?: ClipVectorProps;
        displayOptions?: {
            drawAsRaster?: boolean;
            preserveBackground?: boolean;
        };
    };
    // (undocumented)
    view: RelatedElementProps;
}

// @public
export interface ViewDefinition2dProps extends ViewDefinitionProps {
    // (undocumented)
    angle: AngleProps;
    // (undocumented)
    baseModelId: Id64String;
    // (undocumented)
    delta: XYProps;
    // (undocumented)
    origin: XYProps;
}

// @public
export interface ViewDefinition3dProps extends ViewDefinitionProps {
    angles?: YawPitchRollProps;
    camera: CameraProps;
    cameraOn: boolean;
    extents: XYZProps;
    // (undocumented)
    jsonProperties?: {
        viewDetails?: ViewDetails3dProps;
    };
    origin: XYZProps;
}

// @public
export interface ViewDefinitionProps extends DefinitionElementProps {
    // (undocumented)
    categorySelectorId: Id64String;
    // (undocumented)
    description?: string;
    // (undocumented)
    displayStyleId: Id64String;
    // (undocumented)
    jsonProperties?: {
        viewDetails?: ViewDetailsProps;
    };
}

// @public
export class ViewDetails {
    // @internal
    constructor(jsonProperties: {
        viewDetails?: ViewDetailsProps;
    });
    get aspectRatioSkew(): number;
    set aspectRatioSkew(skew: number);
    get auxiliaryCoordinateSystemId(): Id64String;
    set auxiliaryCoordinateSystemId(id: Id64String);
    get clipVector(): ClipVector | undefined;
    set clipVector(clip: ClipVector | undefined);
    // @internal
    getJSON(): Readonly<ViewDetailsProps>;
    get gridOrientation(): GridOrientationType;
    set gridOrientation(orientation: GridOrientationType);
    get gridSpacing(): XAndY;
    set gridSpacing(spacing: XAndY);
    get gridsPerRef(): number;
    set gridsPerRef(gridsPerRef: number);
    // @internal (undocumented)
    protected readonly _json: ViewDetailsProps;
    static maxSkew: number;
    readonly onClipVectorChanged: BeEvent<(newClip: ClipVector | undefined) => void>;
}

// @public
export class ViewDetails3d extends ViewDetails {
    // @internal
    constructor(jsonProperties: {
        viewDetails?: ViewDetails3dProps;
    });
    get allow3dManipulations(): boolean;
    set allow3dManipulations(allow: boolean);
    // @internal
    getJSON(): Readonly<ViewDetails3dProps>;
    get modelClipGroups(): ModelClipGroups;
    set modelClipGroups(groups: ModelClipGroups);
    readonly onModelClipGroupsChanged: BeEvent<(newGroups: ModelClipGroups) => void>;
}

// @public
export interface ViewDetails3dProps extends ViewDetailsProps {
    disable3dManipulations?: boolean;
    modelClipGroups?: ModelClipGroupProps[];
}

// @public
export interface ViewDetailsProps {
    acs?: Id64String;
    aspectSkew?: number;
    clip?: ClipVectorProps;
    gridOrient?: GridOrientationType;
    gridPerRef?: number;
    gridSpaceX?: number;
    gridSpaceY?: number;
}

// @public
export type ViewFlagOverrides = Partial<ViewFlagsProperties>;

// @public
export interface ViewFlagProps {
    acs?: boolean;
    ambientOcclusion?: boolean;
    backgroundMap?: boolean;
    clipVol?: boolean;
    forceSurfaceDiscard?: boolean;
    grid?: boolean;
    hidEdges?: boolean;
    monochrome?: boolean;
    noCameraLights?: boolean;
    noConstruct?: boolean;
    noDim?: boolean;
    noFill?: boolean;
    noMaterial?: boolean;
    noPattern?: boolean;
    noSolarLight?: boolean;
    noSourceLights?: boolean;
    noStyle?: boolean;
    noTexture?: boolean;
    noTransp?: boolean;
    noWeight?: boolean;
    noWhiteOnWhiteReversal?: boolean;
    renderMode?: RenderMode;
    shadows?: boolean;
    thematicDisplay?: boolean;
    visEdges?: boolean;
    // @beta
    wiremesh?: boolean;
}

// @public
export class ViewFlags {
    constructor(flags?: Partial<ViewFlagsProperties>);
    readonly acsTriad: boolean;
    readonly ambientOcclusion: boolean;
    readonly backgroundMap: boolean;
    readonly clipVolume: boolean;
    readonly constructions: boolean;
    copy(changedFlags: Partial<ViewFlagsProperties>): ViewFlags;
    static create(flags?: Partial<ViewFlagsProperties>): ViewFlags;
    static readonly defaults: ViewFlags;
    readonly dimensions: boolean;
    edgesRequired(): boolean;
    equals(other: Readonly<ViewFlagsProperties>): boolean;
    readonly fill: boolean;
    readonly forceSurfaceDiscard: boolean;
    static fromJSON(json?: ViewFlagProps): ViewFlags;
    readonly grid: boolean;
    readonly hiddenEdges: boolean;
    // @internal (undocumented)
    hiddenEdgesVisible(): boolean;
    readonly lighting: boolean;
    readonly materials: boolean;
    readonly monochrome: boolean;
    // @internal
    normalize(): ViewFlags;
    override(overrides: Partial<ViewFlagsProperties>): ViewFlags;
    readonly patterns: boolean;
    readonly renderMode: RenderMode;
    readonly shadows: boolean;
    readonly styles: boolean;
    readonly textures: boolean;
    readonly thematicDisplay: boolean;
    // @internal
    toFullyDefinedJSON(): Required<ViewFlagProps>;
    toJSON(): ViewFlagProps;
    readonly transparency: boolean;
    readonly visibleEdges: boolean;
    readonly weights: boolean;
    readonly whiteOnWhiteReversal: boolean;
    // @beta
    readonly wiremesh: boolean;
    with(flag: keyof Omit<ViewFlagsProperties, "renderMode">, value: boolean): ViewFlags;
    withRenderMode(renderMode: RenderMode): ViewFlags;
}

// @public
export type ViewFlagsProperties = Mutable<NonFunctionPropertiesOf<ViewFlags>>;

// @public
export interface ViewQueryParams extends EntityQueryParams {
    // (undocumented)
    wantPrivate?: boolean;
}

// @public
export interface ViewStateLoadProps {
    displayStyle?: DisplayStyleLoadProps;
}

// @public
export interface ViewStateProps {
    // (undocumented)
    categorySelectorProps: CategorySelectorProps;
    // (undocumented)
    displayStyleProps: DisplayStyleProps;
    modelExtents?: Range3dProps;
    // (undocumented)
    modelSelectorProps?: ModelSelectorProps;
    sectionDrawing?: SectionDrawingViewProps;
    sheetAttachments?: Id64Array;
    sheetProps?: SheetProps;
    // (undocumented)
    viewDefinitionProps: ViewDefinitionProps;
}

// @internal (undocumented)
export const WEB_RPC_CONSTANTS: {
    CONTENT: string;
    TEXT: string;
    ANY_TEXT: string;
    BINARY: string;
    MULTIPART: string;
};

// @internal
export abstract class WebAppRpcProtocol extends RpcProtocol {
    constructor(configuration: RpcConfiguration);
    static computeContentType(httpType: string | null | undefined): RpcContentType;
    getCode(status: RpcRequestStatus): number;
    getStatus(code: number): RpcRequestStatus;
    handleOpenApiDescriptionRequest(_req: HttpServerRequest, res: HttpServerResponse): void;
    handleOperationGetRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    handleOperationPostRequest(req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    abstract info: OpenAPIInfo;
    isTimeout(code: number): boolean;
    get openAPIDescription(): RpcOpenAPIDescription;
    pathPrefix: string;
    // (undocumented)
    preserveStreams: boolean;
    readonly requestType: typeof WebAppRpcRequest;
    abstract supplyPathParametersForOperation(_operation: RpcOperation): OpenAPIParameter[];
    // (undocumented)
    supportsStatusCategory: boolean;
}

// @internal
export class WebAppRpcRequest extends RpcRequest {
    constructor(client: RpcInterface, operation: string, parameters: any[]);
    // (undocumented)
    protected computeRetryAfter(attempts: number): number;
    protected static computeTransportType(value: RpcSerializedValue, source: any): RpcContentType;
    // (undocumented)
    protected handleUnknownResponse(code: number): void;
    // (undocumented)
    protected load(): Promise<RpcSerializedValue>;
    static maxUrlComponentSize: number;
    metadata: {
        status: number;
        message: string;
    };
    method: HttpMethod_T;
    static parseRequest(protocol: WebAppRpcProtocol, req: HttpServerRequest): Promise<SerializedRpcRequest>;
    readonly protocol: WebAppRpcProtocol;
    protected send(): Promise<number>;
    static sendResponse(protocol: WebAppRpcProtocol, request: SerializedRpcRequest, fulfillment: RpcRequestFulfillment, req: HttpServerRequest, res: HttpServerResponse): Promise<void>;
    protected setHeader(name: string, value: string): void;
    protected supplyFetch(): typeof fetch;
    protected supplyRequest(): typeof Request;
}

// @public
export interface WhiteOnWhiteReversalProps {
    ignoreBackgroundColor?: boolean;
}

// @public
export class WhiteOnWhiteReversalSettings {
    equals(other: WhiteOnWhiteReversalSettings): boolean;
    static fromJSON(props?: WhiteOnWhiteReversalProps): WhiteOnWhiteReversalSettings;
    readonly ignoreBackgroundColor: boolean;
    toJSON(): WhiteOnWhiteReversalProps | undefined;
}

// @internal
export abstract class WipRpcInterface extends RpcInterface {
    // (undocumented)
    attachChangeCache(_iModelToken: IModelRpcProps): Promise<void>;
    // (undocumented)
    getChangedElements(_iModelToken: IModelRpcProps, _startChangesetId: string, _endChangesetId: string): Promise<ChangedElements | undefined>;
    static getClient(): WipRpcInterface;
    static readonly interfaceName = "WipRpcInterface";
    static interfaceVersion: string;
    // (undocumented)
    isChangeCacheAttached(_iModelToken: IModelRpcProps): Promise<boolean>;
    // (undocumented)
    isChangesetProcessed(_iModelToken: IModelRpcProps, _changesetId: string): Promise<boolean>;
    // (undocumented)
    placeholder(_iModelToken: IModelRpcProps): Promise<string>;
}

// @public
export class XyzRotation implements XyzRotationProps {
    constructor(data?: XyzRotationProps);
    equals(other: XyzRotation): boolean;
    static fromJSON(data: XyzRotationProps): XyzRotation;
    toJSON(): XyzRotationProps;
    readonly x: number;
    readonly y: number;
    readonly z: number;
}

// @public
export interface XyzRotationProps {
    x: number;
    y: number;
    z: number;
}

// (No @packageDocumentation comment for this package)

```
