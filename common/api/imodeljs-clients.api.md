## API Report File for "@bentley/imodeljs-clients"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyError } from '@bentley/bentleyjs-core';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClientRequestContextProps } from '@bentley/bentleyjs-core';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GuidString } from '@bentley/bentleyjs-core';
import * as https from 'https';
import { HttpStatus } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelHubStatus } from '@bentley/bentleyjs-core';
import { LogFunction } from '@bentley/bentleyjs-core';
import { Range2d } from '@bentley/geometry-core';
import { URL } from 'url';

// @internal
export class AccessToken extends Token {
    // (undocumented)
    static foreignProjectAccessTokenJsonProperty: string;
    static fromForeignProjectAccessTokenJson(foreignJsonStr: string): AccessToken | undefined;
    static fromJson(jsonObj: any): AccessToken | undefined;
    static fromJsonWebTokenString(jwt: string, startsAt?: Date, expiresAt?: Date, userInfo?: UserInfo): AccessToken;
    static fromSamlAssertion(samlAssertion: string): AccessToken;
    static fromSamlTokenString(accessTokenStr: string, includesPrefix?: IncludePrefix): AccessToken;
    static fromTokenString(tokenStr: string): AccessToken;
    readonly isJwt: boolean;
    toTokenString(includePrefix?: IncludePrefix): string;
}

// @internal
export function addSelectFileAccessKey(query: RequestQueryOptions): void;

// @internal
export class AggregateResponseError extends Error {
    errors: ResponseError[];
}

// @alpha
export class AllCodesDeletedEvent extends BriefcaseEvent {
}

// @alpha
export class AllLocksDeletedEvent extends BriefcaseEvent {
}

// @internal (undocumented)
export class ArgumentCheck {
    // (undocumented)
    static defined(argumentName: string, argument?: any): void;
    // (undocumented)
    static definedNumber(argumentName: string, argument?: number): void;
    // (undocumented)
    static nonEmptyArray(argumentName: string, argument?: any[]): void;
    // (undocumented)
    static valid(argumentName: string, argument?: any): void;
    static validBriefcaseId(argumentName: string, argument?: number): void;
    // (undocumented)
    static validChangeSetId(argumentName: string, argument?: string): void;
    // (undocumented)
    static validGuid(argumentName: string, argument?: string): void;
}

// @public
export class Asset extends CommonContext {
    // (undocumented)
    assetType?: string;
}

// @public
export class AuthenticationError extends ResponseError {
}

// @internal
export class AuthorizationToken extends Token {
    static fromSamlAssertion(samlAssertion: string): AuthorizationToken;
    toTokenString(includePrefix?: IncludePrefix): string;
}

// @beta
export class AuthorizedClientRequestContext extends ClientRequestContext implements AuthorizedClientRequestContextProps {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @beta, but its signature references "AccessToken" which is marked as @internal
    constructor(accessToken: AccessToken, activityId?: GuidString, applicationId?: string, applicationVersion?: string, sessionId?: GuidString);
    // Warning: (ae-incompatible-release-tags) The symbol "accessToken" is marked as @beta, but its signature references "AccessToken" which is marked as @internal
    accessToken: AccessToken;
    // (undocumented)
    toJSON(): AuthorizedClientRequestContextProps;
}

// @beta
export interface AuthorizedClientRequestContextProps extends ClientRequestContextProps {
    // (undocumented)
    accessToken: any;
}

// @internal
export class Briefcase extends WsgInstance {
    // (undocumented)
    accessMode?: BriefcaseAccessMode;
    acquiredDate?: string;
    briefcaseId?: number;
    downloadUrl?: string;
    fileDescription?: string;
    fileId?: GuidString;
    fileName?: string;
    fileSize?: string;
    // (undocumented)
    iModelId?: GuidString;
    isReadOnly?: boolean;
    // (undocumented)
    lastAccessedAt?: Date;
    // (undocumented)
    localPathname?: string;
    mergedChangeSetId?: string;
    userId?: string;
}

// @internal
export enum BriefcaseAccessMode {
    // (undocumented)
    Exclusive = 1,
    // (undocumented)
    Shared = 0
}

// @internal
export class BriefcaseDeletedEvent extends BriefcaseEvent {
}

// @public
export abstract class BriefcaseEvent extends IModelHubEvent {
    briefcaseId?: number;
    // @internal
    fromJson(obj: any): void;
}

// @internal
export class BriefcaseHandler {
    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler);
    create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<Briefcase>;
    delete(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void>;
    download(requestContext: AuthorizedClientRequestContext, briefcase: Briefcase, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void>;
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: BriefcaseQuery): Promise<Briefcase[]>;
    }

// @internal
export class BriefcaseQuery extends Query {
    byId(id: number): this;
    getId(): number | undefined;
    ownedByMe(): this;
    selectDownloadUrl(): this;
}

// Warning: (ae-incompatible-release-tags) The symbol "ChangeSet" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class ChangeSet extends WsgInstance {
    briefcaseId?: number;
    changesType?: ChangesType;
    description?: string;
    downloadUrl?: string;
    fileName?: string;
    fileSize?: string;
    id?: string;
    index?: string;
    isUploaded?: boolean;
    parentId?: string;
    pathname?: string;
    pushDate?: string;
    seedFileId?: GuidString;
    uploadUrl?: string;
    userCreated?: string;
}

// @public
export class ChangeSetCreatedEvent extends IModelHubGlobalEvent {
    // (undocumented)
    briefcaseId?: number;
    // (undocumented)
    changeSetId?: string;
    // (undocumented)
    changeSetIndex?: string;
    fromJson(obj: any): void;
}

// @public
export class ChangeSetHandler {
    // @internal
    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, changeSet: ChangeSet, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<ChangeSet>;
    // Warning: (ae-incompatible-release-tags) The symbol "download" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    download(requestContext: AuthorizedClientRequestContext, changeSets: ChangeSet[], path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: ChangeSetQuery): Promise<ChangeSet[]>;
    }

// @public
export class ChangeSetPostPushEvent extends BriefcaseEvent {
    changeSetId?: string;
    changeSetIndex?: string;
    // @internal
    fromJson(obj: any): void;
}

// @public
export class ChangeSetPrePushEvent extends IModelHubEvent {
}

// Warning: (ae-incompatible-release-tags) The symbol "ChangeSetQuery" is marked as @public, but its signature references "StringIdQuery" which is marked as @internal
// 
// @public
export class ChangeSetQuery extends StringIdQuery {
    constructor();
    afterVersion(versionId: GuidString): this;
    betweenChangeSets(firstChangeSetId: string, secondChangeSetId?: string): this;
    betweenVersionAndChangeSet(versionId: GuidString, changeSetId: string): this;
    betweenVersions(sourceVersionId: GuidString, destinationVersionId: GuidString): this;
    // @internal
    bySeedFileId(seedFileId: GuidString): this;
    // @internal (undocumented)
    protected checkValue(id: string): void;
    // @internal
    static defaultPageSize: number;
    fromId(id: string): this;
    getVersionChangeSets(versionId: GuidString): this;
    latest(): this;
    selectDownloadUrl(): this;
}

// @internal (undocumented)
export type ChangeState = "new" | "modified" | "deleted";

// @public
export enum ChangesType {
    Regular = 0,
    Schema = 1
}

// @internal
export class Checkpoint extends WsgInstance {
    createdDate?: string;
    downloadUrl?: string;
    fileDescription?: string;
    fileId?: GuidString;
    fileName?: string;
    fileSize?: string;
    mergedChangeSetId?: string;
    state?: InitializationState;
}

// @internal
export class CheckpointHandler {
    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler);
    download(requestContext: AuthorizedClientRequestContext, checkpoint: Checkpoint, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void>;
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: CheckpointQuery): Promise<Checkpoint[]>;
    }

// @internal
export class CheckpointQuery extends Query {
    byChangeSetId(changeSetId: string): this;
    nearestCheckpoint(targetChangeSetId: string): this;
    precedingCheckpoint(targetChangeSetId: string): this;
    selectDownloadUrl(): this;
}

// @internal (undocumented)
export interface ClassKeyMapInfo {
    classKeyPropertyName?: string;
    classPropertyName?: string;
    schemaPropertyName?: string;
}

// @public
export abstract class Client {
    protected constructor();
    // Warning: (ae-incompatible-release-tags) The symbol "delete" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    protected delete(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string): Promise<void>;
    getUrl(requestContext: ClientRequestContext): Promise<string>;
    protected abstract getUrlSearchKey(): string;
    // Warning: (ae-incompatible-release-tags) The symbol "setupOptionDefaults" is marked as @public, but its signature references "RequestOptions" which is marked as @alpha
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
    // (undocumented)
    protected _url?: string;
}

// @public
export enum ClientsLoggerCategory {
    Clients = "imodeljs-clients.Clients",
    ECJson = "ECJson",
    // @internal (undocumented)
    IModelBank = "imodeljs-clients.iModelBank",
    IModelHub = "imodeljs-clients.imodelhub",
    // @internal (undocumented)
    ImsClients = "imodeljs-clients.ImsClients",
    // (undocumented)
    Request = "imodeljs-clients.Request",
    // @internal (undocumented)
    UlasClient = "ulasclient"
}

// Warning: (ae-incompatible-release-tags) The symbol "CodeBase" is marked as @alpha, but its signature references "WsgInstance" which is marked as @internal
// 
// @alpha
export class CodeBase extends WsgInstance {
    briefcaseId?: number;
    codeScope?: string;
    codeSpecId?: Id64String;
    createdDate?: string;
    queryOnly?: boolean;
    state?: CodeState;
}

// @alpha
export class CodeEvent extends BriefcaseEvent {
    codeScope?: string;
    codeSpecId?: Id64String;
    // @internal
    fromJson(obj: any): void;
    state?: CodeState;
    values?: string[];
}

// @alpha
export class CodeHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    deleteAll(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void>;
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: CodeQuery): Promise<HubCode[]>;
    readonly sequences: CodeSequenceHandler;
    update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, codes: HubCode[], updateOptions?: CodeUpdateOptions): Promise<HubCode[]>;
    }

// Warning: (ae-incompatible-release-tags) The symbol "CodeQuery" is marked as @alpha, but its signature references "Query" which is marked as @internal
// 
// @alpha
export class CodeQuery extends Query {
    constructor();
    byBriefcaseId(briefcaseId: number): this;
    byCodes(codes: HubCode[]): this;
    byCodeScope(codeScope: string): this;
    byCodeSpecId(codeSpecId: Id64String): this;
    // @internal
    static defaultPageSize: number;
    // @internal
    readonly isMultiCodeQuery: boolean;
    unavailableCodes(briefcaseId: number): this;
}

// Warning: (ae-incompatible-release-tags) The symbol "CodeSequence" is marked as @alpha, but its signature references "WsgInstance" which is marked as @internal
// 
// @alpha
export class CodeSequence extends WsgInstance {
    codeScope?: string;
    codeSpecId?: Id64String;
    incrementBy?: number;
    startIndex?: number;
    type?: CodeSequenceType;
    value?: string;
    valuePattern?: string;
}

// @alpha
export class CodeSequenceHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, sequence: CodeSequence): Promise<string>;
    }

// @alpha
export enum CodeSequenceType {
    LargestUsed = 0,
    NextAvailable = 1
}

// @alpha
export enum CodeState {
    Available = 0,
    Reserved = 1,
    Retired = 3,
    Used = 2
}

// @alpha
export interface CodeUpdateOptions {
    codesPerRequest?: number;
    continueOnConflict?: boolean;
    deniedCodes?: boolean;
    unlimitedReporting?: boolean;
}

// @public
export class Config {
    static readonly App: Config;
    get(varName: string, defaultVal?: ValueType): any;
    getBoolean(name: string, defaultVal?: boolean): boolean;
    getContainer(): any;
    getNumber(name: string, defaultVal?: number): number;
    getString(name: string, defaultVal?: string): string;
    getVars(): string[];
    has(varName: string): boolean;
    merge(source: any): void;
    query(varName: string): any;
    remove(varName: string): void;
    set(varName: string, value: ValueType): void;
    }

// @alpha
export class ConflictingCodesError extends IModelHubError {
    // @internal
    addCodes(error: IModelHubError): void;
    conflictingCodes?: HubCode[];
    // @internal
    static fromError(error: IModelHubError): ConflictingCodesError | undefined;
}

// @alpha
export class ConflictingLocksError extends IModelHubError {
    // @internal
    addLocks(error: IModelHubError): void;
    conflictingLocks?: Lock[];
    // @internal
    static fromError(error: IModelHubError): ConflictingLocksError | undefined;
}

// Warning: (ae-incompatible-release-tags) The symbol "ConnectClient" is marked as @public, but its signature references "WsgClient" which is marked as @internal
// 
// @public
export class ConnectClient extends WsgClient {
    constructor();
    // (undocumented)
    static readonly configRelyingPartyUri = "imjs_connected_context_service_relying_party_uri";
    // Warning: (ae-incompatible-release-tags) The symbol "getAsset" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getAsset" is marked as @public, but its signature references "RequestQueryOptions" which is marked as @alpha
    getAsset(requestContext: AuthorizedClientRequestContext, queryOptions?: RequestQueryOptions): Promise<Asset>;
    // Warning: (ae-incompatible-release-tags) The symbol "getAssets" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getAssets" is marked as @public, but its signature references "RequestQueryOptions" which is marked as @alpha
    getAssets(requestContext: AuthorizedClientRequestContext, queryOptions?: RequestQueryOptions): Promise<Asset[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getInvitedProjects" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getInvitedProjects" is marked as @public, but its signature references "ConnectRequestQueryOptions" which is marked as @internal
    getInvitedProjects(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getProject" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getProject" is marked as @public, but its signature references "ConnectRequestQueryOptions" which is marked as @internal
    getProject(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project>;
    // Warning: (ae-incompatible-release-tags) The symbol "getProjects" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getProjects" is marked as @public, but its signature references "ConnectRequestQueryOptions" which is marked as @internal
    getProjects(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project[]>;
    protected getRelyingPartyUrl(): string;
    protected getUrlSearchKey(): string;
    // (undocumented)
    static readonly searchKey: string;
    // Warning: (ae-incompatible-release-tags) The symbol "setupOptionDefaults" is marked as @public, but its signature references "RequestOptions" which is marked as @alpha
    // 
    // (undocumented)
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
}

// @internal
export interface ConnectRequestQueryOptions extends RequestQueryOptions {
    isFavorite?: boolean;
    isMRU?: boolean;
}

// @internal
export class ConnectSettingsClient extends Client implements SettingsAdmin {
    constructor(applicationId: string);
    // (undocumented)
    applicationId: string;
    // (undocumented)
    deleteSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    // (undocumented)
    deleteUserSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    getAccessToken(requestContext: ClientRequestContext, authSamlToken: AuthorizationToken): Promise<AccessToken>;
    // (undocumented)
    getSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    // (undocumented)
    getSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;
    // (undocumented)
    protected getUrlSearchKey(): string;
    // (undocumented)
    getUserSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    // (undocumented)
    getUserSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;
    // (undocumented)
    saveSetting(requestContext: AuthorizedClientRequestContext, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    // (undocumented)
    saveUserSetting(requestContext: AuthorizedClientRequestContext, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    // (undocumented)
    static readonly searchKey: string;
}

// @internal (undocumented)
export type ConstructorType = new () => any;

// Warning: (ae-incompatible-release-tags) The symbol "Context" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class Context extends WsgInstance {
    // (undocumented)
    allowExternalTeamMembers?: boolean;
    // (undocumented)
    contextTypeId?: ContextType;
    // (undocumented)
    dataLocationId?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    number?: string;
    // (undocumented)
    status?: number;
    // (undocumented)
    ultimateRefId?: string;
}

// @public
export enum ContextType {
    // (undocumented)
    Asset = 2,
    // (undocumented)
    Project = 3,
    // (undocumented)
    Unknown = 0
}

// @internal
export class DefaultCodeUpdateOptionsProvider {
    constructor();
    assignOptions(options: CodeUpdateOptions): Promise<void>;
    // (undocumented)
    protected _defaultOptions: CodeUpdateOptions;
}

// @internal
export class DefaultLockUpdateOptionsProvider {
    constructor();
    assignOptions(options: LockUpdateOptions): Promise<void>;
    // (undocumented)
    protected _defaultOptions: LockUpdateOptions;
}

// @internal
export class DefaultRequestOptionsProvider {
    constructor();
    assignOptions(options: RequestOptions): Promise<void>;
    // (undocumented)
    protected _defaultOptions: RequestOptions;
}

// @internal
export class DefaultWsgRequestOptionsProvider extends DefaultRequestOptionsProvider {
    constructor();
}

// @internal
export abstract class ECInstance {
    // (undocumented)
    [index: string]: any;
    // (undocumented)
    ecId: string;
}

// @internal
export class ECJsonTypeMap {
    static classToJson(applicationKey: string, classKey: string, classKeyMapInfo: ClassKeyMapInfo): (typedConstructor: ConstructorType) => void;
    static fromJson<T extends ECInstance>(typedConstructor: new () => T, applicationKey: string, ecJsonInstance: any): T | undefined;
    static propertyToJson(applicationKey: string, propertyAccessString: string): (object: any, propertyKey: string) => void;
    static toJson<T extends ECInstance>(applicationKey: string, typedInstance: T): any | undefined;
}

// @public
export class EventHandler extends EventBaseHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "createListener" is marked as @public, but its signature references "AccessToken" which is marked as @internal
    createListener(requestContext: ClientRequestContext, authenticationCallback: () => Promise<AccessToken>, subscriptionId: string, iModelId: GuidString, listener: (event: IModelHubEvent) => void): () => void;
    getEvent(requestContext: ClientRequestContext, sasToken: string, baseAddress: string, subscriptionId: string, timeout?: number): Promise<IModelHubEvent | undefined>;
    // Warning: (ae-incompatible-release-tags) The symbol "getSASToken" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    getSASToken(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<EventSAS>;
    readonly subscriptions: EventSubscriptionHandler;
}

// @public
export class EventSAS extends BaseEventSAS {
}

// Warning: (ae-incompatible-release-tags) The symbol "EventSubscription" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class EventSubscription extends WsgInstance {
    eventTypes?: EventType[];
}

// @public
export class EventSubscriptionHandler {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "IModelBaseHandler" which is marked as @internal
    constructor(handler: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, events: EventType[]): Promise<EventSubscription>;
    // Warning: (ae-incompatible-release-tags) The symbol "delete" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    delete(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, eventSubscriptionId: string): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "update" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, subscription: EventSubscription): Promise<EventSubscription>;
}

// @public
export type EventType = 
/** Sent when one or more [[Lock]]s are updated. See [[LockEvent]].
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
"LockEvent" | 
/** Sent when all [[Lock]]s for a [[Briefcase]] are deleted. See [[AllLocksDeletedEvent]].
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
"AllLocksDeletedEvent" | 
/** Sent when a [[ChangeSet]] is successfully pushed. See [[ChangeSetPostPushEvent]]. */
"ChangeSetPostPushEvent" | 
/** Sent when a [[ChangeSet]] push has started. See [[ChangeSetPrePushEvent]]. */
"ChangeSetPrePushEvent" | 
/** Sent when one or more [Code]($common)s are updated. See [[CodeEvent]].
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
"CodeEvent" | 
/** Sent when all [Code]($common)s for a [[Briefcase]] are deleted. See [[AllCodesDeletedEvent]].
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
"AllCodesDeletedEvent" | 
/** Sent when a [[Briefcase]] is deleted. See [[BriefcaseDeletedEvent]].
 * @internal
 */
"BriefcaseDeletedEvent" | 
/** Sent when an iModel is deleted. See [[iModelDeletedEvent]]. */
"iModelDeletedEvent" | 
/** Sent when a new named [[Version]] is created. See [[VersionEvent]]. */
"VersionEvent";

// @internal
export class FeatureEndedLogEntry extends FeatureLogEntry {
    constructor(featureId: GuidString, startEntryId: GuidString, hostName: string, usageType: UsageType);
    static fromStartEntry(startEntry: FeatureStartedLogEntry): FeatureEndedLogEntry;
    // (undocumented)
    readonly startEntryId: GuidString;
}

// @internal
export class FeatureLogEntry {
    constructor(featureId: GuidString, hostName: string, usageType: UsageType);
    readonly featureId: GuidString;
    readonly hostName: string;
    projectId?: GuidString;
    readonly timestamp: string;
    usageData: FeatureLogEntryAttribute[];
    readonly usageType: UsageType;
}

// @internal
export interface FeatureLogEntryAttribute {
    // (undocumented)
    name: string;
    // (undocumented)
    value: any;
}

// @internal (undocumented)
export interface FeatureLogEntryAttributeJson {
    // (undocumented)
    name: string;
    // (undocumented)
    value: string;
}

// @internal
export interface FeatureLogEntryJson extends UsageLogEntryJson {
    eDateZ: string;
    ftrID: GuidString;
    sDateZ: string;
    uData: FeatureLogEntryAttributeJson[];
}

// @internal
export class FeatureStartedLogEntry extends FeatureLogEntry {
    constructor(featureId: GuidString, hostName: string, usageType: UsageType);
    readonly entryId: GuidString;
}

// @internal
export class FileAccessKey extends WsgInstance {
    // (undocumented)
    permissions?: string;
    // (undocumented)
    requiresConfirmation?: string;
    // (undocumented)
    type?: string;
    // (undocumented)
    url?: string;
}

// @internal
export interface FileHandler {
    // (undocumented)
    agent: https.Agent;
    basename(filePath: string): string;
    downloadFile(requestContext: AuthorizedClientRequestContext, downloadUrl: string, path: string, fileSize?: number, progress?: (progress: ProgressInfo) => void): Promise<void>;
    exists(filePath: string): boolean;
    getFileSize(filePath: string): number;
    isDirectory(filePath: string): boolean;
    join(...paths: string[]): string;
    uploadFile(requestContext: AuthorizedClientRequestContext, uploadUrlString: string, path: string, progress?: (progress: ProgressInfo) => void): Promise<void>;
}

// @public
export function getArrayBuffer(requestContext: ClientRequestContext, url: string): Promise<any>;

// @public
export enum GetEventOperationType {
    Destructive = 0,
    Peek = 1
}

// @public
export function getJson(requestContext: ClientRequestContext, url: string): Promise<any>;

// @public
export class GlobalEventHandler extends EventBaseHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "createListener" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "createListener" is marked as @public, but its signature references "AccessToken" which is marked as @internal
    createListener(requestContext: AuthorizedClientRequestContext, authenticationCallback: () => Promise<AccessToken>, subscriptionInstanceId: string, listener: (event: IModelHubGlobalEvent) => void): () => void;
    getEvent(requestContext: ClientRequestContext, sasToken: string, baseAddress: string, subscriptionId: string, timeout?: number, getOperation?: GetEventOperationType): Promise<IModelHubGlobalEvent | undefined>;
    // Warning: (ae-incompatible-release-tags) The symbol "getSASToken" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    getSASToken(requestContext: AuthorizedClientRequestContext): Promise<GlobalEventSAS>;
    readonly subscriptions: GlobalEventSubscriptionHandler;
}

// @public
export class GlobalEventSAS extends BaseEventSAS {
}

// Warning: (ae-incompatible-release-tags) The symbol "GlobalEventSubscription" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class GlobalEventSubscription extends WsgInstance {
    // (undocumented)
    eventTypes?: GlobalEventType[];
    // (undocumented)
    subscriptionId?: string;
}

// @public
export class GlobalEventSubscriptionHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, subscriptionId: GuidString, globalEvents: GlobalEventType[]): Promise<GlobalEventSubscription>;
    // Warning: (ae-incompatible-release-tags) The symbol "delete" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    delete(requestContext: AuthorizedClientRequestContext, subscriptionId: string): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "update" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    update(requestContext: AuthorizedClientRequestContext, subscription: GlobalEventSubscription): Promise<GlobalEventSubscription>;
}

// @public
export type GlobalEventType = 
/** Sent when an iModel is put into the archive. See [[SoftiModelDeleteEvent]].
 * @beta Rename to SoftIModelDeleteEvent
 */
"SoftiModelDeleteEvent" | 
/** Sent when an archived iModel is completely deleted from the storage. See [[HardiModelDeleteEvent]].
 * @beta Rename to HardIModelDeleteEvent
 */
"HardiModelDeleteEvent" | 
/** Sent when an iModel is created. See [[IModelCreatedEvent]].
 * @beta Rename to IModelCreatedEvent
 */
"iModelCreatedEvent" | 
/** Sent when a [[ChangeSet]] is pushed. See [[ChangeSetCreatedEvent]]. */
"ChangeSetCreatedEvent" | 
/** Sent when a named [[Version]] is created. See [[NamedVersionCreatedEvent]]. */
"NamedVersionCreatedEvent";

// @beta
export class HardiModelDeleteEvent extends IModelHubGlobalEvent {
}

// @alpha
export class HubCode extends CodeBase {
    value?: string;
}

// Warning: (ae-incompatible-release-tags) The symbol "HubIModel" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class HubIModel extends WsgInstance {
    createdDate?: string;
    description?: string;
    id?: GuidString;
    // @internal
    iModelTemplate?: string;
    initialized?: boolean;
    name?: string;
    userCreated?: string;
}

// Warning: (ae-incompatible-release-tags) The symbol "HubUserInfo" is marked as @alpha, but its signature references "WsgInstance" which is marked as @internal
// 
// @alpha
export class HubUserInfo extends WsgInstance {
    email?: string;
    firstName?: string;
    id?: string;
    lastName?: string;
}

// @beta
export interface IAngularOidcFrontendClient extends IOidcFrontendClient {
    // (undocumented)
    handleRedirectCallback(): Promise<boolean>;
}

// @beta
export interface IAuthorizationClient {
    // Warning: (ae-incompatible-release-tags) The symbol "getAccessToken" is marked as @beta, but its signature references "AccessToken" which is marked as @internal
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    hasExpired: boolean;
    hasSignedIn: boolean;
    isAuthorized: boolean;
}

// @internal
export class IModelBankClient extends IModelClient {
    constructor(url: string, handler: FileHandler | undefined);
}

// @internal (undocumented)
export class IModelBankFileSystemContextClient implements ContextManagerClient {
    constructor(baseUri: string);
    // (undocumented)
    baseUri: string;
    // (undocumented)
    createContext(requestContext: AuthorizedClientRequestContext, name: string): Promise<void>;
    // (undocumented)
    deleteContext(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<void>;
    // (undocumented)
    queryAssetByName(requestContext: AuthorizedClientRequestContext, assetName: string): Promise<Asset>;
    // (undocumented)
    queryProjectByName(requestContext: AuthorizedClientRequestContext, projectName: string): Promise<Project>;
}

// @internal
export class IModelBankHandler extends IModelBaseHandler {
    constructor(url: string, handler: FileHandler | undefined, keepAliveDuration?: number);
    // (undocumented)
    getUrl(_requestContext: ClientRequestContext, excludeApiVersion?: boolean): Promise<string>;
    // (undocumented)
    protected getUrlSearchKey(): string;
}

// @internal
export class IModelBaseHandler extends WsgClient {
    constructor(keepAliveDuration?: number, fileHandler?: FileHandler);
    // (undocumented)
    protected _agent: any;
    // (undocumented)
    static readonly configRelyingPartyUri = "imjs_imodelhub_relying_party_uri";
    delete(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string): Promise<void>;
    deleteInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string, instance?: T, requestOptions?: WsgRequestOptions): Promise<void>;
    // (undocumented)
    protected _fileHandler: FileHandler | undefined;
    // (undocumented)
    formatContextIdForUrl(contextId: string): string;
    getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken>;
    getAgent(): any;
    getCustomRequestOptions(): CustomRequestOptions;
    // (undocumented)
    getFileHandler(): FileHandler | undefined;
    getInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions?: RequestQueryOptions): Promise<T[]>;
    protected getRelyingPartyUrl(): string;
    getUrl(requestContext: ClientRequestContext): Promise<string>;
    protected getUrlSearchKey(): string;
    postInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instance: T, requestOptions?: WsgRequestOptions): Promise<T>;
    postInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instances: T[], requestOptions?: WsgRequestOptions): Promise<T[]>;
    postQuery<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions: RequestQueryOptions): Promise<T[]>;
    // (undocumented)
    static readonly searchKey: string;
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
    // (undocumented)
    protected _url?: string;
}

// @public
export abstract class IModelClient {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "IModelBaseHandler" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "FileHandler" which is marked as @internal
    constructor(baseHandler: IModelBaseHandler, fileHandler?: FileHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "briefcases" is marked as @public, but its signature references "BriefcaseHandler" which is marked as @internal
    readonly briefcases: BriefcaseHandler;
    readonly changeSets: ChangeSetHandler;
    // Warning: (ae-incompatible-release-tags) The symbol "checkpoints" is marked as @public, but its signature references "CheckpointHandler" which is marked as @internal
    readonly checkpoints: CheckpointHandler;
    // Warning: (ae-incompatible-release-tags) The symbol "codes" is marked as @public, but its signature references "CodeHandler" which is marked as @alpha
    readonly codes: CodeHandler;
    readonly events: EventHandler;
    readonly globalEvents: GlobalEventHandler;
    // Warning: (ae-incompatible-release-tags) The symbol "_handler" is marked as @public, but its signature references "IModelBaseHandler" which is marked as @internal
    // 
    // (undocumented)
    protected _handler: IModelBaseHandler;
    readonly iModel: IModelHandler;
    readonly iModels: IModelsHandler;
    // Warning: (ae-incompatible-release-tags) The symbol "locks" is marked as @public, but its signature references "LockHandler" which is marked as @alpha
    readonly locks: LockHandler;
    readonly requestOptions: CustomRequestOptions;
    // Warning: (ae-incompatible-release-tags) The symbol "setFileHandler" is marked as @public, but its signature references "FileHandler" which is marked as @internal
    setFileHandler(fileHandler: FileHandler): void;
    // Warning: (ae-incompatible-release-tags) The symbol "thumbnails" is marked as @public, but its signature references "ThumbnailHandler" which is marked as @alpha
    readonly thumbnails: ThumbnailHandler;
    // Warning: (ae-incompatible-release-tags) The symbol "users" is marked as @public, but its signature references "UserInfoHandler" which is marked as @alpha
    readonly users: UserInfoHandler;
    readonly versions: VersionHandler;
}

// @public
export class IModelCreatedEvent extends IModelHubGlobalEvent {
}

// @public
export class IModelDeletedEvent extends IModelHubEvent {
}

// @internal (undocumented)
export interface IModelFileSystemContextProps {
    // (undocumented)
    description: string;
    // (undocumented)
    id: string;
    // (undocumented)
    name: string;
}

// @public
export class IModelHandler {
    // @internal
    constructor(handler: IModelsHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, contextId: string, name: string, path?: string, description?: string, progressCallback?: (progress: ProgressInfo) => void, timeOutInMilliseconds?: number): Promise<HubIModel>;
    // Warning: (ae-incompatible-release-tags) The symbol "delete" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    delete(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "download" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    download(requestContext: AuthorizedClientRequestContext, contextId: string, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    get(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<HubIModel>;
    // Warning: (ae-incompatible-release-tags) The symbol "getInitializationState" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getInitializationState" is marked as @public, but its signature references "InitializationState" which is marked as @internal
    getInitializationState(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<InitializationState>;
    // Warning: (ae-incompatible-release-tags) The symbol "update" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    update(requestContext: AuthorizedClientRequestContext, contextId: string, imodel: HubIModel): Promise<HubIModel>;
}

// @public
export class IModelHubClient extends IModelClient {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "FileHandler" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "IModelBaseHandler" which is marked as @internal
    constructor(fileHandler?: FileHandler, iModelBaseHandler?: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "getAccessToken" is marked as @public, but its signature references "AuthorizationToken" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "getAccessToken" is marked as @public, but its signature references "AccessToken" which is marked as @internal
    getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken>;
}

// @public
export class IModelHubClientError extends IModelHubError {
    // @internal
    static browser(): IModelHubClientError;
    // @internal
    static fileHandler(): IModelHubClientError;
    // @internal
    static fileNotFound(): IModelHubClientError;
    // @internal
    static fromId(id: IModelHubStatus, message: string): IModelHubClientError;
    // @internal
    static initializationTimeout(): IModelHubClientError;
    // @internal
    static invalidArgument(argumentName: string): IModelHubClientError;
    // @internal
    static missingDownloadUrl(argumentName: string): IModelHubClientError;
    // @internal
    static undefinedArgument(argumentName: string): IModelHubClientError;
}

// Warning: (ae-incompatible-release-tags) The symbol "IModelHubError" is marked as @public, but its signature references "WsgError" which is marked as @internal
// 
// @public
export class IModelHubError extends WsgError {
    // @internal
    constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction);
    data: any;
    // @internal
    static fromId(id: IModelHubStatus, message: string): IModelHubError;
    // @internal
    getLogLevel(): LogFunction;
    // @internal
    log(): void;
    // @internal
    static parse(response: any, log?: boolean): ResponseError;
    // @internal
    static shouldRetry(error: any, response: any): boolean;
}

// @public
export abstract class IModelHubEvent extends IModelHubBaseEvent {
    // @internal
    fromJson(obj: any): void;
    iModelId?: GuidString;
}

// @public
export abstract class IModelHubGlobalEvent extends IModelHubBaseEvent {
    contextId?: string;
    contextTypeId?: ContextType;
    // @internal
    fromJson(obj: any): void;
    iModelId?: GuidString;
    projectId?: string;
}

// Warning: (ae-incompatible-release-tags) The symbol "IModelQuery" is marked as @public, but its signature references "InstanceIdQuery" which is marked as @internal
// 
// @public
export class IModelQuery extends InstanceIdQuery {
    byName(name: string): this;
}

// @public
export class IModelsHandler {
    // @internal
    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, contextId: string, name: string, path?: string, description?: string, progressCallback?: (progress: ProgressInfo) => void, timeOutInMilliseconds?: number): Promise<HubIModel>;
    // Warning: (ae-incompatible-release-tags) The symbol "delete" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    delete(requestContext: AuthorizedClientRequestContext, contextId: string, iModelId: GuidString): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "download" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    download(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    get(requestContext: AuthorizedClientRequestContext, contextId: string, query?: IModelQuery): Promise<HubIModel[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "getInitializationState" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "getInitializationState" is marked as @public, but its signature references "InitializationState" which is marked as @internal
    getInitializationState(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<InitializationState>;
    // Warning: (ae-incompatible-release-tags) The symbol "update" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    update(requestContext: AuthorizedClientRequestContext, contextId: string, imodel: HubIModel): Promise<HubIModel>;
}

// @internal @deprecated
export class ImsActiveSecureTokenClient extends Client {
    constructor();
    getToken(requestContext: ClientRequestContext, userCredentials: ImsUserCredentials, appId?: string): Promise<AuthorizationToken>;
    protected getUrlSearchKey(): string;
    // (undocumented)
    static readonly searchKey: string;
    // (undocumented)
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
}

// @internal @deprecated
export class ImsDelegationSecureTokenClient extends Client {
    constructor();
    getToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken, relyingPartyUri?: string, appId?: string): Promise<AccessToken>;
    protected getUrlSearchKey(): string;
    // (undocumented)
    static readonly searchKey: string;
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
}

// @internal @deprecated
export class ImsFederatedAuthenticationClient extends Client {
    constructor();
    protected getUrlSearchKey(): string;
    static parseTokenResponse(authTokenResponse: string): AuthorizationToken | undefined;
    // (undocumented)
    static readonly searchKey: string;
}

// @internal @deprecated
export class ImsTestAuthorizationClient implements IAuthorizationClient {
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    readonly hasExpired: boolean;
    readonly hasSignedIn: boolean;
    readonly isAuthorized: boolean;
    // (undocumented)
    signIn(requestContext: ClientRequestContext, userCredentials: ImsUserCredentials, relyingPartyUri?: string): Promise<AccessToken>;
    }

// @internal @deprecated
export interface ImsUserCredentials {
    // (undocumented)
    email: string;
    // (undocumented)
    password: string;
}

// @internal (undocumented)
export enum IncludePrefix {
    // (undocumented)
    No = 1,
    // (undocumented)
    Yes = 0
}

// @internal
export enum InitializationState {
    CodeTooLong = 5,
    Failed = 3,
    NotStarted = 1,
    OutdatedFile = 4,
    Scheduled = 2,
    SeedFileIsBriefcase = 6,
    Successful = 0
}

// @internal
export class InstanceIdQuery extends Query {
    byId(id: GuidString): this;
    // (undocumented)
    protected _byId?: GuidString;
    getId(): string | undefined;
}

// @beta
export interface IOidcFrontendClient extends IDisposable, IAuthorizationClient {
    // Warning: (ae-incompatible-release-tags) The symbol "getAccessToken" is marked as @beta, but its signature references "AccessToken" which is marked as @internal
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    hasExpired: boolean;
    hasSignedIn: boolean;
    initialize(requestContext: ClientRequestContext): Promise<void>;
    isAuthorized: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "onUserStateChanged" is marked as @beta, but its signature references "AccessToken" which is marked as @internal
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext): Promise<void>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
}

// @alpha
export class LargeThumbnail extends Thumbnail {
}

// @alpha
export class Lock extends LockBase {
    objectId?: Id64String;
}

// Warning: (ae-incompatible-release-tags) The symbol "LockBase" is marked as @alpha, but its signature references "WsgInstance" which is marked as @internal
// 
// @alpha
export class LockBase extends WsgInstance {
    briefcaseId?: number;
    lockLevel?: LockLevel;
    lockType?: LockType;
    releasedWithChangeSet?: string;
    releasedWithChangeSetIndex?: string;
    seedFileId?: GuidString;
}

// @alpha
export class LockEvent extends BriefcaseEvent {
    // @internal
    fromJson(obj: any): void;
    lockLevel?: LockLevel;
    lockType?: LockType;
    objectIds?: Id64String[];
    releasedWithChangeSet?: string;
}

// @alpha
export class LockHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    deleteAll(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void>;
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: LockQuery): Promise<Lock[]>;
    update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, locks: Lock[], updateOptions?: LockUpdateOptions): Promise<Lock[]>;
    }

// @alpha
export enum LockLevel {
    Exclusive = 2,
    None = 0,
    Shared = 1
}

// Warning: (ae-incompatible-release-tags) The symbol "LockQuery" is marked as @alpha, but its signature references "Query" which is marked as @internal
// 
// @alpha
export class LockQuery extends Query {
    constructor();
    byBriefcaseId(briefcaseId: number): this;
    byLockLevel(lockLevel: LockLevel): this;
    byLocks(locks: Lock[]): this;
    byLockType(lockType: LockType): this;
    byObjectId(objectId: Id64String): this;
    byReleasedWithChangeSet(changeSetId: string): this;
    byReleasedWithChangeSetIndex(changeSetIndex: number): this;
    // @internal
    static defaultPageSize: number;
    // @internal
    readonly isMultiLockQuery: boolean;
    unavailableLocks(briefcaseId: number, lastChangeSetIndex: string): this;
}

// @alpha
export enum LockType {
    CodeSpecs = 4,
    Db = 0,
    Element = 2,
    Model = 1,
    Schemas = 3
}

// @alpha
export interface LockUpdateOptions {
    continueOnConflict?: boolean;
    deniedLocks?: boolean;
    locksPerRequest?: number;
    unlimitedReporting?: boolean;
}

// @internal (undocumented)
export class LogEntryConverter {
    // (undocumented)
    static toFeatureLogJson(requestContext: AuthorizedClientRequestContext, entries: FeatureLogEntry[]): FeatureLogEntryJson[];
    // (undocumented)
    static toUsageLogJson(requestContext: AuthorizedClientRequestContext, entry: UsageLogEntry): UsageLogEntryJson;
    }

// @internal
export interface LogPostingResponse {
    // (undocumented)
    message: string;
    // (undocumented)
    requestId: GuidString;
    // (undocumented)
    status: BentleyStatus;
    // (undocumented)
    time: number;
}

// @internal
export class MultiCode extends CodeBase {
    // (undocumented)
    values?: string[];
}

// @alpha
export class MultiLock extends LockBase {
    // (undocumented)
    objectIds?: Id64String[];
}

// @public
export class NamedVersionCreatedEvent extends IModelHubGlobalEvent {
    // (undocumented)
    changeSetId?: string;
    fromJson(obj: any): void;
    // (undocumented)
    versionId?: GuidString;
    // (undocumented)
    versionName?: string;
}

// @beta (undocumented)
export abstract class OidcClient extends Client {
    constructor();
    protected getUrlSearchKey(): string;
    // (undocumented)
    static readonly searchKey: string;
}

// @beta
export interface OidcFrontendClientConfiguration {
    clientId: string;
    postSignoutRedirectUri?: string;
    redirectUri: string;
    scope: string;
}

// @internal
export function ParseEvent(response: Response): IModelHubEvent;

// @internal
export function ParseGlobalEvent(response: Response, handler?: IModelBaseHandler, sasToken?: string): IModelHubGlobalEvent;

// @internal
export class Permission extends WsgInstance {
    // (undocumented)
    categoryId?: number;
    // (undocumented)
    description?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    serviceGprId?: number;
}

// @internal
export interface ProductVersion {
    // (undocumented)
    major: number;
    // (undocumented)
    minor: number;
    // (undocumented)
    sub1?: number;
    // (undocumented)
    sub2?: number;
}

// @public (undocumented)
export interface ProgressInfo {
    // (undocumented)
    loaded: number;
    // (undocumented)
    percent?: number;
    // (undocumented)
    total?: number;
}

// @public
export class Project extends CommonContext {
    // (undocumented)
    assetId?: string;
    // (undocumented)
    isRbacEnabled?: boolean;
    // (undocumented)
    type?: string;
}

// @internal
export class Query {
    protected addFilter(filter: string, operator?: "and" | "or"): void;
    protected addSelect(select: string): this;
    filter(filter: string): this;
    getQueryOptions(): RequestQueryOptions;
    orderBy(orderBy: string): this;
    pageSize(n: number): this;
    // (undocumented)
    protected _query: RequestQueryOptions;
    resetQueryOptions(): void;
    select(select: string): this;
    skip(n: number): this;
    top(n: number): this;
}

// @internal
export class RbacProject extends WsgInstance {
}

// @internal (undocumented)
export interface RbacRequestQueryOptions extends RequestQueryOptions {
    // (undocumented)
    rbacOnly?: boolean;
}

// @internal
export class RbacUser extends WsgInstance {
}

// @internal
export class RealityData extends WsgInstance {
    // (undocumented)
    accuracyInMeters?: string;
    // (undocumented)
    approximateFootprint?: boolean;
    // (undocumented)
    classification?: string;
    // (undocumented)
    client: undefined | RealityDataServicesClient;
    containerName?: string;
    // (undocumented)
    copyright?: string;
    // (undocumented)
    createdTimestamp?: string;
    // (undocumented)
    creatorId?: string;
    // (undocumented)
    dataLocationGuid?: string;
    // (undocumented)
    dataSet?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    footprint?: string;
    getBlobStringUrl(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath?: boolean): Promise<string>;
    getBlobUrl(requestContext: AuthorizedClientRequestContext, writeAccess?: boolean): Promise<URL>;
    getModelData(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath?: boolean): Promise<any>;
    getRootDocumentJson(requestContext: AuthorizedClientRequestContext): Promise<any>;
    getTileContent(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath?: boolean): Promise<any>;
    getTileJson(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath?: boolean): Promise<any>;
    // (undocumented)
    group?: string;
    // (undocumented)
    hidden?: boolean;
    // (undocumented)
    id?: string;
    // (undocumented)
    lastAccessedTimestamp?: string;
    // (undocumented)
    listable?: boolean;
    // (undocumented)
    metadataUrl?: string;
    // (undocumented)
    modifiedTimestamp?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    organizationId?: string;
    // (undocumented)
    ownedBy?: string;
    // (undocumented)
    ownerId?: string;
    // (undocumented)
    projectId: undefined | string;
    // (undocumented)
    resolutionInMeters?: string;
    // (undocumented)
    rootDocument?: string;
    // (undocumented)
    size?: string;
    // (undocumented)
    sizeUpToDate?: boolean;
    // (undocumented)
    streamed?: boolean;
    // (undocumented)
    termsOfUse?: string;
    // (undocumented)
    thumbnailDocument?: string;
    // (undocumented)
    type?: string;
    // (undocumented)
    ultimateId?: string;
    // (undocumented)
    ultimateSite?: string;
    // (undocumented)
    version?: string;
    // (undocumented)
    visibility?: string;
}

// @internal
export class RealityDataRelationship extends WsgInstance {
    // (undocumented)
    createdTimestamp?: string;
    // (undocumented)
    modifiedTimestamp?: string;
    // (undocumented)
    realityDataId?: string;
    // (undocumented)
    relatedId?: string;
    // (undocumented)
    relationType?: string;
}

// @internal
export class RealityDataServicesClient extends WsgClient {
    constructor();
    // (undocumented)
    static readonly configRelyingPartyUri = "imjs_reality_data_service_relying_party_uri";
    createRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityData: RealityData): Promise<RealityData>;
    createRealityDataRelationship(requestContext: AuthorizedClientRequestContext, projectId: string, relationship: RealityDataRelationship): Promise<RealityDataRelationship>;
    deleteRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityDataId: string): Promise<void>;
    deleteRealityDataRelationship(requestContext: AuthorizedClientRequestContext, projectId: string, relationshipId: string): Promise<void>;
    getFileAccessKey(requestContext: AuthorizedClientRequestContext, projectId: string, tilesId: string, writeAccess?: boolean): Promise<FileAccessKey[]>;
    getRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, tilesId: string): Promise<RealityData>;
    getRealityDataIdFromUrl(url: string): string | undefined;
    getRealityDataInProject(requestContext: AuthorizedClientRequestContext, projectId: string): Promise<RealityData[]>;
    getRealityDataInProjectOverlapping(requestContext: AuthorizedClientRequestContext, projectId: string, range: Range2d): Promise<RealityData[]>;
    getRealityDataRelationships(requestContext: AuthorizedClientRequestContext, projectId: string, realityDataId: string): Promise<RealityDataRelationship[]>;
    getRealityDataUrl(requestContext: ClientRequestContext, projectId: string, tilesId: string): Promise<string>;
    protected getRelyingPartyUrl(): string;
    protected getUrlSearchKey(): string;
    // (undocumented)
    static readonly searchKey: string;
    updateRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityData: RealityData): Promise<RealityData>;
}

// Warning: (ae-incompatible-release-tags) The symbol "request" is marked as @public, but its signature references "RequestOptions" which is marked as @alpha
// 
// @public
export function request(requestContext: ClientRequestContext, url: string, options: RequestOptions): Promise<Response>;

// @alpha (undocumented)
export interface RequestBasicCredentials {
    // (undocumented)
    password: string;
    // (undocumented)
    user: string;
}

// @internal (undocumented)
export class RequestGlobalOptions {
    // (undocumented)
    static httpsProxy?: https.Agent;
    // (undocumented)
    static timeout: RequestTimeoutOptions;
}

// @alpha (undocumented)
export const requestIdHeaderName = "X-Correlation-Id";

// @alpha (undocumented)
export interface RequestOptions {
    // (undocumented)
    accept?: string;
    // (undocumented)
    agent?: https.Agent;
    // (undocumented)
    auth?: RequestBasicCredentials;
    // (undocumented)
    body?: any;
    // (undocumented)
    buffer?: any;
    // (undocumented)
    errorCallback?: (response: any) => ResponseError;
    // (undocumented)
    headers?: any;
    // (undocumented)
    method: string;
    // (undocumented)
    parser?: any;
    // (undocumented)
    progressCallback?: (progress: ProgressInfo) => void;
    // (undocumented)
    qs?: any | RequestQueryOptions;
    // (undocumented)
    readStream?: any;
    // (undocumented)
    redirects?: number;
    // (undocumented)
    responseType?: string;
    // (undocumented)
    retries?: number;
    // (undocumented)
    retryCallback?: (error: any, response: any) => boolean;
    // (undocumented)
    stream?: any;
    // (undocumented)
    timeout?: RequestTimeoutOptions;
    // (undocumented)
    useCorsProxy?: boolean;
}

// @alpha
export interface RequestQueryOptions {
    $filter?: string;
    $orderby?: string;
    $pageSize?: number;
    $select?: string;
    $skip?: number;
    $top?: number;
}

// @alpha (undocumented)
export interface RequestQueryStringifyOptions {
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    encode?: boolean;
}

// @alpha
export interface RequestTimeoutOptions {
    deadline?: number;
    response?: number;
}

// @public
export interface Response {
    // (undocumented)
    body: any;
    // (undocumented)
    header: any;
    // (undocumented)
    status: number;
}

// @public
export class ResponseError extends BentleyError {
    constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction);
    // (undocumented)
    protected _data?: any;
    // (undocumented)
    description?: string;
    log(): void;
    // (undocumented)
    logMessage(): string;
    static parse(response: any, log?: boolean): ResponseError;
    // (undocumented)
    static parseHttpStatus(statusType: number): HttpStatus;
    static shouldRetry(error: any, response: any): boolean;
    // (undocumented)
    status?: number;
}

// @internal
export class SeedFile extends WsgInstance {
    // (undocumented)
    downloadUrl?: string;
    // (undocumented)
    fileDescription?: string;
    // (undocumented)
    fileId?: GuidString;
    // (undocumented)
    fileName?: string;
    // (undocumented)
    fileSize?: string;
    id?: GuidString;
    // (undocumented)
    iModelName?: string;
    // (undocumented)
    index?: number;
    // (undocumented)
    initializationState?: InitializationState;
    // (undocumented)
    isUploaded?: boolean;
    // (undocumented)
    mergedChangeSetId?: string;
    // (undocumented)
    uploadedDate?: string;
    // (undocumented)
    uploadUrl?: string;
    // (undocumented)
    userUploaded?: string;
}

// @alpha
export interface SettingsAdmin {
    deleteSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    deleteUserSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    getSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    getSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;
    getUserSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    getUserSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;
    saveSetting(requestContext: AuthorizedClientRequestContext, settings: any, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
    saveUserSetting(requestContext: AuthorizedClientRequestContext, settings: any, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;
}

// @alpha
export class SettingsMapResult {
    // @internal
    constructor(status: SettingsStatus, errorMessage?: string | undefined, settingsMap?: Map<string, any> | undefined);
    // (undocumented)
    errorMessage?: string | undefined;
    // (undocumented)
    settingsMap?: Map<string, any> | undefined;
    // (undocumented)
    status: SettingsStatus;
}

// @alpha
export class SettingsResult {
    // @internal
    constructor(status: SettingsStatus, errorMessage?: string | undefined, setting?: any);
    // (undocumented)
    errorMessage?: string | undefined;
    // (undocumented)
    setting?: any;
    // (undocumented)
    status: SettingsStatus;
}

// @alpha
export enum SettingsStatus {
    AuthorizationError = 110593,
    IModelInvalid = 110596,
    ProjectInvalid = 110595,
    ServerError = 110598,
    SettingNotFound = 110597,
    // (undocumented)
    SETTINGS_ERROR_BASE = 110592,
    Success = 0,
    UnknownError = 110600,
    UrlError = 110594
}

// @alpha
export class SmallThumbnail extends Thumbnail {
}

// @beta
export class SoftiModelDeleteEvent extends IModelHubGlobalEvent {
}

// @internal
export class StringIdQuery extends Query {
    byId(id: string): this;
    // (undocumented)
    protected _byId?: string;
    // (undocumented)
    protected checkValue(id: string): void;
    getId(): string | undefined;
}

// Warning: (ae-incompatible-release-tags) The symbol "Thumbnail" is marked as @alpha, but its signature references "WsgInstance" which is marked as @internal
// 
// @alpha
export abstract class Thumbnail extends WsgInstance {
    // (undocumented)
    id?: GuidString;
}

// @alpha
export class ThumbnailHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    download(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, thumbnail: Thumbnail | TipThumbnail): Promise<string>;
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, size: ThumbnailSize, query?: ThumbnailQuery): Promise<Thumbnail[]>;
    }

// Warning: (ae-incompatible-release-tags) The symbol "ThumbnailQuery" is marked as @alpha, but its signature references "InstanceIdQuery" which is marked as @internal
// 
// @alpha
export class ThumbnailQuery extends InstanceIdQuery {
    byVersionId(versionId: GuidString): this;
}

// @alpha
export type ThumbnailSize = "Small" | "Large";

// @alpha
export interface TipThumbnail {
    contextId: string;
    size: ThumbnailSize;
}

// @internal
export abstract class Token {
    protected constructor();
    // (undocumented)
    protected _expiresAt?: Date;
    // (undocumented)
    getExpiresAt(): Date | undefined;
    // (undocumented)
    protected getSaml(): string | undefined;
    // (undocumented)
    getSamlAssertion(): string | undefined;
    // (undocumented)
    getStartsAt(): Date | undefined;
    // (undocumented)
    getUserInfo(): UserInfo | undefined;
    // (undocumented)
    protected _jwt?: string;
    // (undocumented)
    protected parseSamlAssertion(): boolean;
    // (undocumented)
    protected _saml?: string;
    // (undocumented)
    protected _samlAssertion?: string;
    // (undocumented)
    setUserInfo(userInfo: UserInfo): void;
    // (undocumented)
    protected _startsAt?: Date;
    // (undocumented)
    protected _userInfo?: UserInfo;
    // (undocumented)
    protected _x509Certificate?: string;
}

// @internal
export class UlasClient extends Client {
    constructor();
    getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken>;
    protected getUrlSearchKey(): string;
    logFeature(requestContext: AuthorizedClientRequestContext, ...entries: FeatureLogEntry[]): Promise<LogPostingResponse>;
    logUsage(requestContext: AuthorizedClientRequestContext, entry: UsageLogEntry): Promise<LogPostingResponse>;
    // (undocumented)
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
}

// @internal
export class UrlDiscoveryClient extends Client {
    constructor();
    // (undocumented)
    static readonly configResolveUrlUsingRegion = "imjs_buddi_resolve_url_using_region";
    // (undocumented)
    static readonly configURL = "imjs_buddi_url";
    discoverUrl(requestContext: ClientRequestContext, searchKey: string, regionId: number | undefined): Promise<string>;
    getUrl(): Promise<string>;
    protected getUrlSearchKey(): string;
}

// @internal
export class UsageLogEntry {
    constructor(hostName: string, usageType: UsageType);
    readonly hostName: string;
    projectId?: GuidString;
    readonly timestamp: string;
    readonly usageType: UsageType;
}

// @internal
export interface UsageLogEntryJson {
    corID?: GuidString;
    country?: string;
    evTimeZ?: string;
    fstr: string;
    hID: string;
    imsID?: GuidString;
    lSrc: string;
    lVer: number;
    pid?: GuidString;
    polID: GuidString;
    prdid: number;
    projID?: GuidString;
    secID: string;
    uID?: string;
    ultID?: number;
    uType: string;
    ver: number;
}

// @internal
export enum UsageType {
    // (undocumented)
    Beta = 2,
    // (undocumented)
    HomeUse = 3,
    // (undocumented)
    PreActivation = 4,
    // (undocumented)
    Production = 0,
    // (undocumented)
    Trial = 1
}

// @beta
export class UserInfo {
    constructor(
    id: string, 
    email?: {
        id: string;
        isVerified?: boolean | undefined;
    } | undefined, 
    profile?: {
        firstName: string;
        lastName: string;
        name?: string | undefined;
        preferredUserName?: string | undefined;
    } | undefined, 
    organization?: {
        id: string;
        name: string;
    } | undefined, 
    featureTracking?: {
        ultimateSite: string;
        usageCountryIso: string;
    } | undefined);
    email?: {
        id: string;
        isVerified?: boolean | undefined;
    } | undefined;
    featureTracking?: {
        ultimateSite: string;
        usageCountryIso: string;
    } | undefined;
    // (undocumented)
    static fromJson(jsonObj: any): UserInfo | undefined;
    id: string;
    organization?: {
        id: string;
        name: string;
    } | undefined;
    profile?: {
        firstName: string;
        lastName: string;
        name?: string | undefined;
        preferredUserName?: string | undefined;
    } | undefined;
}

// @alpha
export class UserInfoHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: UserInfoQuery): Promise<HubUserInfo[]>;
    readonly statistics: UserStatisticsHandler;
}

// Warning: (ae-incompatible-release-tags) The symbol "UserInfoQuery" is marked as @alpha, but its signature references "Query" which is marked as @internal
// 
// @alpha
export class UserInfoQuery extends Query {
    byId(id: string): this;
    // @internal (undocumented)
    protected _byId?: string;
    byIds(ids: string[]): this;
    // @internal
    getId(): string | undefined;
    // @internal (undocumented)
    readonly isQueriedByIds: boolean;
    }

// @alpha
export class UserStatistics extends HubUserInfo {
    briefcasesCount?: number;
    lastChangeSetPushDate?: string;
    ownedLocksCount?: number;
    pushedChangeSetsCount?: number;
}

// @alpha
export class UserStatisticsHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: UserStatisticsQuery): Promise<UserStatistics[]>;
    }

// Warning: (ae-incompatible-release-tags) The symbol "UserStatisticsQuery" is marked as @alpha, but its signature references "Query" which is marked as @internal
// 
// @alpha
export class UserStatisticsQuery extends Query {
    // @internal
    constructor();
    byId(id: string): this;
    // @internal (undocumented)
    protected _byId?: string;
    byIds(ids: string[]): this;
    // @internal
    getId(): string | undefined;
    // @internal
    readonly isQueriedByIds: boolean;
    selectAll(): this;
    selectBriefcasesCount(): this;
    selectLastChangeSetPushDate(): this;
    selectOwnedLocksCount(): this;
    selectPushedChangeSetsCount(): this;
    }

// Warning: (ae-incompatible-release-tags) The symbol "Version" is marked as @public, but its signature references "WsgInstance" which is marked as @internal
// 
// @public
export class Version extends WsgInstance {
    changeSetId?: GuidString;
    createdDate?: string;
    description?: string;
    // (undocumented)
    id?: GuidString;
    largeThumbnailId?: GuidString;
    name?: string;
    smallThumbnailId?: GuidString;
    userCreated?: string;
}

// @public
export class VersionEvent extends IModelHubEvent {
    changeSetId?: string;
    // @internal
    fromJson(obj: any): void;
    versionId?: GuidString;
    versionName?: string;
}

// @public
export class VersionHandler {
    // @internal
    constructor(handler: IModelBaseHandler);
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, changeSetId: string, name: string, description?: string): Promise<Version>;
    // Warning: (ae-incompatible-release-tags) The symbol "get" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query?: VersionQuery): Promise<Version[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "update" is marked as @public, but its signature references "AuthorizedClientRequestContext" which is marked as @beta
    update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, version: Version): Promise<Version>;
}

// Warning: (ae-incompatible-release-tags) The symbol "VersionQuery" is marked as @public, but its signature references "InstanceIdQuery" which is marked as @internal
// 
// @public
export class VersionQuery extends InstanceIdQuery {
    byChangeSet(changesetId: string): this;
    byName(name: string): this;
    // Warning: (ae-incompatible-release-tags) The symbol "selectThumbnailId" is marked as @public, but its signature references "ThumbnailSize" which is marked as @alpha
    selectThumbnailId(...sizes: ThumbnailSize[]): this;
}

// @internal
export abstract class WsgClient extends Client {
    protected constructor(apiVersion: string);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    static readonly configHostRelyingPartyUri = "imjs_default_relying_party_uri";
    // (undocumented)
    static readonly configUseHostRelyingPartyUriAsFallback = "imjs_use_default_relying_party_uri_as_fallback";
    protected deleteInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string, instance?: T, requestOptions?: WsgRequestOptions): Promise<void>;
    getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken>;
    protected getInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions?: RequestQueryOptions): Promise<T[]>;
    protected abstract getRelyingPartyUrl(): string;
    getUrl(requestContext: ClientRequestContext, excludeApiVersion?: boolean): Promise<string>;
    protected postInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instance: T, requestOptions?: WsgRequestOptions): Promise<T>;
    protected postInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instances: T[], requestOptions?: WsgRequestOptions): Promise<T[]>;
    protected postQuery<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions: RequestQueryOptions): Promise<T[]>;
    protected setupOptionDefaults(options: RequestOptions): Promise<void>;
    // (undocumented)
    protected _url?: string;
}

// @internal
export class WsgError extends ResponseError {
    constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction);
    static getErrorStatus(errorId: number, httpStatusType: number): number;
    static getWSStatusId(error: string): number;
    log(): void;
    static parse(response: any, log?: boolean): ResponseError;
    static shouldRetry(error: any, response: any): boolean;
}

// @internal
export abstract class WsgInstance extends ECInstance {
    // (undocumented)
    changeState?: ChangeState;
    // (undocumented)
    eTag?: string;
    // (undocumented)
    wsgId: string;
}

// @internal
export interface WsgRequestOptions {
    // (undocumented)
    CustomOptions?: any;
    // (undocumented)
    RefreshInstances?: boolean;
    // (undocumented)
    ResponseContent?: "FullInstance" | "Empty" | "InstanceId";
}


// (No @packageDocumentation comment for this package)

```
